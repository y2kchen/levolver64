; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\YEXPARSE.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_list:DWORD
COMM	_listtop:DWORD
COMM	_maxp:DWORD
COMM	_loopdepth:DWORD
COMM	_loopbase:DWORD:01eH
COMM	_using_param_flag:DWORD
COMM	_permlist:DWORD
COMM	_listmax:DWORD
_DATA	ENDS
PUBLIC	_free_expr
EXTRN	_myfree:PROC
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\yexparse.c
;	COMDAT _free_expr
_TEXT	SEGMENT
_ex$ = 8						; size = 4
_free_expr PROC						; COMDAT

; 163  : { 

	push	ebp
	mov	ebp, esp
	push	edi

; 164  :   if ( ex == NULL ) return;

	mov	edi, DWORD PTR _ex$[ebp]
	test	edi, edi
	je	SHORT $LN10@free_expr

; 165  :   if ( ex->flag == NOUSERCOPY ) return;

	cmp	DWORD PTR [edi+12], 0
	je	SHORT $LN10@free_expr

; 166  :   if ( ex->start )

	push	esi
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN7@free_expr

; 167  :   { 
; 168  :    struct treenode *node;
; 169  :     for ( node = ex->start ; node != ex->root ; node ++  )

	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN4@free_expr
	npad	3
$LL6@free_expr:

; 170  :     {
; 171  :     #ifdef XXXXXXX
; 172  :    /* free local symbol tables ?? */
; 173  :       if ( node->flags & HAS_LOCALLIST )
; 174  :       { struct locallist_t *locals = node->op5.locals;
; 175  :         if ( locals->list ) 
; 176  :         { if ( locals->flags & LL_PERMANENT ) free((char*)locals->list);
; 177  :           else myfree((char*)locals->list);
; 178  :         }
; 179  :         if ( locals->flags & LL_PERMANENT ) 
; 180  :           free((char*)locals);
; 181  :         else 
; 182  :           myfree((char*)locals);
; 183  :       }
; 184  :     #endif
; 185  :       if ( node->flags & HAS_STRING )

	test	BYTE PTR [esi+24], 32			; 00000020H
	je	SHORT $LN3@free_expr

; 186  :         myfree(node->op1.string);

	mov	eax, DWORD PTR [esi+32]
	push	eax
	call	_myfree
	add	esp, 4
$LN3@free_expr:

; 187  :       if ( node->flags & HAS_STRING_5 )

	test	DWORD PTR [esi+24], 512			; 00000200H
	je	SHORT $LN5@free_expr

; 188  :         myfree(node->op5.string);

	mov	ecx, DWORD PTR [esi+152]
	push	ecx
	call	_myfree
	add	esp, 4
$LN5@free_expr:

; 167  :   { 
; 168  :    struct treenode *node;
; 169  :     for ( node = ex->start ; node != ex->root ; node ++  )

	add	esi, 168				; 000000a8H
	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LL6@free_expr
$LN4@free_expr:

; 189  :     }
; 190  :     myfree((char *)ex->start);

	mov	edx, DWORD PTR [edi]
	push	edx
	call	_myfree
	add	esp, 4
$LN7@free_expr:

; 191  :   }
; 192  :   ex->root = NULL;
; 193  :   ex->start = NULL;
; 194  : 
; 195  :   if ( ex->locals )

	mov	eax, DWORD PTR [edi+8]
	xor	esi, esi
	mov	DWORD PTR [edi+4], esi
	mov	DWORD PTR [edi], esi
	cmp	eax, esi
	je	SHORT $LN1@free_expr

; 196  :   { myfree((char*)(ex->locals->list));

	mov	eax, DWORD PTR [eax]
	push	eax
	call	_myfree

; 197  :     myfree((char*)(ex->locals));

	mov	ecx, DWORD PTR [edi+8]
	push	ecx
	call	_myfree
	add	esp, 8
$LN1@free_expr:

; 198  :   }
; 199  :   ex->locals = NULL;

	mov	DWORD PTR [edi+8], esi
	pop	esi
$LN10@free_expr:
	pop	edi

; 200  : 
; 201  : } // end free_expr()

	pop	ebp
	ret	0
_free_expr ENDP
_TEXT	ENDS
PUBLIC	_perm_free_expr
EXTRN	_free:PROC
; Function compile flags: /Ogtp
;	COMDAT _perm_free_expr
_TEXT	SEGMENT
_ex$ = 8						; size = 4
_perm_free_expr PROC					; COMDAT

; 211  : { struct treenode *node;

	push	ebp
	mov	ebp, esp
	push	edi

; 212  : 
; 213  :   if ( ex == NULL ) return;

	mov	edi, DWORD PTR _ex$[ebp]
	test	edi, edi
	je	SHORT $LN9@perm_free_

; 214  :   if ( ex->flag == NOUSERCOPY ) return;

	cmp	DWORD PTR [edi+12], 0
	je	SHORT $LN9@perm_free_

; 215  :   if ( ex->start )

	push	esi
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN6@perm_free_

; 216  :   { for ( node = ex->start ; node != ex->root ; node ++  )

	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $LN3@perm_free_
	npad	3
$LL5@perm_free_:

; 217  :     if ( node->flags & HAS_STRING )

	test	BYTE PTR [esi+24], 32			; 00000020H
	je	SHORT $LN4@perm_free_

; 218  :       free(node->op1.string);

	mov	eax, DWORD PTR [esi+32]
	push	eax
	call	_free
	add	esp, 4
$LN4@perm_free_:

; 216  :   { for ( node = ex->start ; node != ex->root ; node ++  )

	add	esi, 168				; 000000a8H
	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LL5@perm_free_
$LN3@perm_free_:

; 219  :     if ( node->flags & HAS_STRING_5 )

	test	DWORD PTR [esi+24], 512			; 00000200H
	je	SHORT $LN1@perm_free_

; 220  :       free(node->op5.string);

	mov	ecx, DWORD PTR [esi+152]
	push	ecx
	call	_free
	add	esp, 4
$LN1@perm_free_:

; 221  :      free((char *)ex->start);

	mov	edx, DWORD PTR [edi]
	push	edx
	call	_free
	add	esp, 4
$LN6@perm_free_:

; 222  :   }
; 223  :   ex->root = NULL;

	mov	DWORD PTR [edi+4], 0

; 224  :   ex->start = NULL;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN9@perm_free_:
	pop	edi

; 225  : } // end perm_free_expr()

	pop	ebp
	ret	0
_perm_free_expr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@OKHAMMPH@YEXPARSE?4C?$AA@		; `string'
PUBLIC	??_C@_0EC@HBCHEBCM@Internal?5error?3?5Left?3?5?$CFd?9?$CFd?5?5rig@ ; `string'
PUBLIC	_subtree_swap
EXTRN	_temp_free:PROC
EXTRN	_kb_memmove:PROC
EXTRN	_kb_temp_calloc:PROC
EXTRN	_kb_error:PROC
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0L@OKHAMMPH@YEXPARSE?4C?$AA@
CONST	SEGMENT
??_C@_0L@OKHAMMPH@YEXPARSE?4C?$AA@ DB 'YEXPARSE.C', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@HBCHEBCM@Internal?5error?3?5Left?3?5?$CFd?9?$CFd?5?5rig@
CONST	SEGMENT
??_C@_0EC@HBCHEBCM@Internal?5error?3?5Left?3?5?$CFd?9?$CFd?5?5rig@ DB 'In'
	DB	'ternal error: Left: %d-%d  right: %d-%d subtrees not adjacent'
	DB	'.', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _subtree_swap
_TEXT	SEGMENT
tv423 = -16						; size = 4
tv391 = -12						; size = 4
tv385 = -12						; size = 4
tv388 = -8						; size = 4
_temp$ = -8						; size = 4
tv425 = -4						; size = 4
_leftstart$90396 = -4					; size = 4
tv503 = 8						; size = 4
$T91384 = 8						; size = 4
_left$ = 8						; size = 4
_right$ = 12						; size = 4
_subtree_swap PROC					; COMDAT

; 2979 : { int n;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2980 :   struct treenode *temp;
; 2981 : 
; 2982 :   if ( *left && *right && (*left < *right ) )

	mov	eax, DWORD PTR _left$[ebp]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR tv385[ebp], edi
	test	edi, edi
	je	$LN3@subtree_sw
	mov	ecx, DWORD PTR _right$[ebp]
	push	ebx
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR tv388[ebp], ebx
	test	ebx, ebx
	je	$LN53@subtree_sw
	cmp	edi, ebx
	jge	$LN53@subtree_sw

; 2983 :   { int leftstart = *left, rightstart = *right;

	push	esi
	mov	esi, DWORD PTR _list
	npad	9
$LL31@subtree_sw:

; 2984 :     int leftsize,rightsize;
; 2985 :     for (;;)
; 2986 :     { if ( list[leftstart].left && list[leftstart].right )

	mov	ecx, edi
	imul	ecx, 168				; 000000a8H
	mov	eax, DWORD PTR [ecx+esi+4]
	test	eax, eax
	je	SHORT $LN25@subtree_sw
	mov	edx, DWORD PTR [ecx+esi+8]
	test	edx, edx
	je	SHORT $LN51@subtree_sw

; 2987 :       { if ( list[leftstart].left < list[leftstart].right )

	cmp	eax, edx
	jge	SHORT $LN28@subtree_sw

; 2988 :           leftstart += list[leftstart].left;

	add	edi, eax
	jmp	SHORT $LL31@subtree_sw
$LN28@subtree_sw:

; 2989 :         else leftstart += list[leftstart].right;

	add	edi, edx

; 2990 :       }
; 2991 :       else if ( list[leftstart].left )

	jmp	SHORT $LL31@subtree_sw
$LN51@subtree_sw:
	test	eax, eax
	je	SHORT $LN25@subtree_sw

; 2992 :         leftstart += list[leftstart].left;

	add	edi, eax
	jmp	SHORT $LL31@subtree_sw
$LN25@subtree_sw:

; 2993 :       else if ( list[leftstart].right )

	mov	ecx, DWORD PTR [ecx+esi+8]
	test	ecx, ecx
	je	SHORT $LN44@subtree_sw

; 2994 :         leftstart += list[leftstart].right;

	add	edi, ecx

; 2995 :       else break;
; 2996 :     }

	jmp	SHORT $LL31@subtree_sw
$LN44@subtree_sw:

; 2988 :           leftstart += list[leftstart].left;

	mov	DWORD PTR _leftstart$90396[ebp], edi
	npad	5
$LL21@subtree_sw:

; 2997 :     for (;;)
; 2998 :     { if ( list[rightstart].left && list[rightstart].right )

	mov	ecx, ebx
	imul	ecx, 168				; 000000a8H
	mov	eax, DWORD PTR [ecx+esi+4]
	test	eax, eax
	je	SHORT $LN15@subtree_sw
	mov	edx, DWORD PTR [ecx+esi+8]
	test	edx, edx
	je	SHORT $LN52@subtree_sw

; 2999 :       { if ( list[rightstart].left < list[rightstart].right )

	cmp	eax, edx
	jge	SHORT $LN18@subtree_sw

; 3000 :           rightstart += list[rightstart].left;

	add	ebx, eax
	jmp	SHORT $LL21@subtree_sw
$LN18@subtree_sw:

; 3001 :         else rightstart += list[rightstart].right;

	add	ebx, edx

; 3002 :       }
; 3003 :       else if ( list[rightstart].left )

	jmp	SHORT $LL21@subtree_sw
$LN52@subtree_sw:
	test	eax, eax
	je	SHORT $LN15@subtree_sw

; 3004 :         rightstart += list[rightstart].left;

	add	ebx, eax
	jmp	SHORT $LL21@subtree_sw
$LN15@subtree_sw:

; 3005 :       else if ( list[rightstart].right )

	mov	ecx, DWORD PTR [ecx+esi+8]
	test	ecx, ecx
	je	SHORT $LN13@subtree_sw

; 3006 :         rightstart += list[rightstart].right;

	add	ebx, ecx

; 3007 :       else break;
; 3008 :     }

	jmp	SHORT $LL21@subtree_sw
$LN13@subtree_sw:

; 3009 :     if ( rightstart != *left + 1 )

	mov	eax, DWORD PTR tv385[ebp]
	lea	ecx, DWORD PTR [eax+1]
	cmp	ebx, ecx
	je	SHORT $LN11@subtree_sw

; 3010 :      { sprintf(errmsg,
; 3011 :           "Internal error: Left: %d-%d  right: %d-%d subtrees not adjacent.\n",
; 3012 :           leftstart,*left,rightstart,*right);

	mov	edx, DWORD PTR tv388[ebp]
	push	edx
	push	ebx
	push	eax
	push	edi
	push	OFFSET ??_C@_0EC@HBCHEBCM@Internal?5error?3?5Left?3?5?$CFd?9?$CFd?5?5rig@
	push	OFFSET _errmsg
	call	_sprintf

; 3013 :         kb_error(1387,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	1387					; 0000056bH
	call	_kb_error
	add	esp, 36					; 00000024H
$LN11@subtree_sw:

; 3014 :      }      
; 3015 : 
; 3016 :     /* swap subtrees */
; 3017 :     leftsize = *left - leftstart + 1;

	mov	eax, DWORD PTR _left$[ebp]
	mov	esi, DWORD PTR [eax]

; 3018 :     rightsize = *right - rightstart +1;

	mov	ecx, DWORD PTR _right$[ebp]

; 3019 :     temp = (struct treenode*)temp_calloc(leftsize,sizeof(struct treenode));

	push	3019					; 00000bcbH
	sub	esi, edi
	mov	edi, DWORD PTR [ecx]
	push	OFFSET ??_C@_0L@OKHAMMPH@YEXPARSE?4C?$AA@
	inc	esi
	push	168					; 000000a8H
	sub	edi, ebx
	push	esi
	inc	edi
	call	_kb_temp_calloc

; 3020 :     memcpy((char*)(temp),(char*)(list+leftstart),
; 3021 :         leftsize*sizeof(struct treenode));

	mov	edx, DWORD PTR _leftstart$90396[ebp]
	imul	edx, 168				; 000000a8H
	mov	ecx, esi
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR tv391[ebp], edx
	add	edx, DWORD PTR _list
	push	ecx
	push	edx
	push	eax
	mov	DWORD PTR _temp$[ebp], eax
	mov	DWORD PTR tv423[ebp], ecx
	call	_memcpy

; 3022 :     kb_memmove((char*)(list+leftstart),(char*)(list+rightstart),
; 3023 :         rightsize*sizeof(struct treenode));

	imul	ebx, 168				; 000000a8H
	mov	eax, DWORD PTR _list
	mov	ecx, DWORD PTR tv391[ebp]
	mov	edx, edi
	imul	edx, 168				; 000000a8H
	push	edx
	add	ebx, eax
	add	ecx, eax
	push	ebx
	push	ecx
	call	_kb_memmove

; 3024 :     memcpy((char*)(list+leftstart+rightsize),(char*)(temp),
; 3025 :         leftsize*sizeof(struct treenode));

	mov	ebx, DWORD PTR _leftstart$90396[ebp]
	mov	edx, DWORD PTR tv423[ebp]
	mov	ecx, DWORD PTR _temp$[ebp]
	lea	eax, DWORD PTR [edi+ebx]
	mov	DWORD PTR tv425[ebp], eax
	imul	eax, 168				; 000000a8H
	add	eax, DWORD PTR _list
	push	edx
	push	ecx
	push	eax
	call	_memcpy

; 3026 :     temp_free((char*)temp);

	mov	edx, DWORD PTR _temp$[ebp]
	push	edx
	call	_temp_free

; 3027 : 
; 3028 :     /* adjust subtree pointers */
; 3029 :     *left += rightsize;

	mov	eax, DWORD PTR _left$[ebp]
	add	DWORD PTR [eax], edi

; 3030 :     *right -= leftsize;

	mov	eax, DWORD PTR _right$[ebp]
	sub	DWORD PTR [eax], esi

; 3031 :     /* kludge to adjust pointers to local variables */
; 3032 :     for ( n = leftstart ; n < leftstart+rightsize ; n++ )

	mov	ecx, DWORD PTR tv425[ebp]
	add	esp, 56					; 00000038H
	mov	eax, ebx
	cmp	ebx, ecx
	jge	SHORT $LN47@subtree_sw

; 3014 :      }      
; 3015 : 
; 3016 :     /* swap subtrees */
; 3017 :     leftsize = *left - leftstart + 1;

	mov	edx, DWORD PTR tv391[ebp]
	mov	DWORD PTR tv503[ebp], edx
	npad	13
$LL10@subtree_sw:

; 3033 :     { 
; 3034 :       if ( ((list[n].type == BREAK_NODE) || (list[n].type == CONTINUE_NODE)) &&
; 3035 :          (n+leftsize+list[n].op1.skipsize < leftstart)  ) 

	mov	ecx, DWORD PTR _list
	mov	ecx, DWORD PTR [edx+ecx]
	cmp	ecx, 10067				; 00002753H
	je	SHORT $LN6@subtree_sw
	cmp	ecx, 10066				; 00002752H
	jne	SHORT $LN9@subtree_sw
$LN6@subtree_sw:
	mov	ecx, DWORD PTR _list
	lea	ecx, DWORD PTR [edx+ecx+32]
	mov	edx, DWORD PTR [ecx]
	add	edx, eax
	add	edx, esi
	cmp	edx, ebx
	jge	SHORT $LN9@subtree_sw

; 3036 :             list[n].op1.skipsize += leftsize;

	add	DWORD PTR [ecx], esi
$LN9@subtree_sw:

; 3031 :     /* kludge to adjust pointers to local variables */
; 3032 :     for ( n = leftstart ; n < leftstart+rightsize ; n++ )

	mov	edx, DWORD PTR tv503[ebp]
	mov	ecx, DWORD PTR tv425[ebp]
	inc	eax
	add	edx, 168				; 000000a8H
	mov	DWORD PTR tv503[ebp], edx
	cmp	eax, ecx
	jl	SHORT $LL10@subtree_sw
$LN47@subtree_sw:

; 3037 :     }
; 3038 :     for ( n = leftstart+rightsize ; n < leftstart+rightsize+leftsize ; n++ )

	add	esi, edi
	add	esi, ebx
	mov	eax, ecx
	mov	DWORD PTR $T91384[ebp], esi
	cmp	eax, esi
	jge	SHORT $LN54@subtree_sw
	mov	edx, eax
	imul	edx, 168				; 000000a8H
	npad	8
$LL5@subtree_sw:

; 3039 :     { 
; 3040 :       if ( ((list[n].type == BREAK_NODE) || (list[n].type == CONTINUE_NODE)) &&
; 3041 :          (n-rightsize+list[n].op1.skipsize < leftstart)  ) 

	mov	ecx, DWORD PTR _list
	mov	ecx, DWORD PTR [edx+ecx]
	cmp	ecx, 10067				; 00002753H
	je	SHORT $LN1@subtree_sw
	cmp	ecx, 10066				; 00002752H
	jne	SHORT $LN4@subtree_sw
$LN1@subtree_sw:
	mov	ecx, DWORD PTR _list
	mov	esi, DWORD PTR [edx+ecx+32]
	lea	ecx, DWORD PTR [edx+ecx+32]
	sub	esi, edi
	add	esi, eax
	cmp	esi, ebx

; 3042 :             list[n].op1.skipsize -= rightsize;

	mov	esi, DWORD PTR $T91384[ebp]
	jge	SHORT $LN4@subtree_sw
	sub	DWORD PTR [ecx], edi
$LN4@subtree_sw:

; 3037 :     }
; 3038 :     for ( n = leftstart+rightsize ; n < leftstart+rightsize+leftsize ; n++ )

	inc	eax
	add	edx, 168				; 000000a8H
	cmp	eax, esi
	jl	SHORT $LL5@subtree_sw
$LN54@subtree_sw:
	pop	esi
$LN53@subtree_sw:
	pop	ebx
$LN3@subtree_sw:
	pop	edi

; 3043 :     } 
; 3044 :   }
; 3045 : } // end subtree_swap()  

	mov	esp, ebp
	pop	ebp
	ret	0
_subtree_swap ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@NOJGADFO@Bad?5expression?4?6?$AA@	; `string'
PUBLIC	_is_constant
;	COMDAT ??_C@_0BB@NOJGADFO@Bad?5expression?4?6?$AA@
CONST	SEGMENT
??_C@_0BB@NOJGADFO@Bad?5expression?4?6?$AA@ DB 'Bad expression.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _is_constant
_TEXT	SEGMENT
_node$ = 8						; size = 4
_is_constant PROC					; COMDAT

; 4639 : { 

	push	ebp
	mov	ebp, esp
	push	esi

; 4640 :   if ( node < 0 || node > listtop )

	mov	esi, DWORD PTR _node$[ebp]
	test	esi, esi
	js	SHORT $LN5@is_constan
	cmp	esi, DWORD PTR _listtop
	jle	SHORT $LN6@is_constan
$LN5@is_constan:

; 4641 :   { kb_error(7732,"Bad expression.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BB@NOJGADFO@Bad?5expression?4?6?$AA@
	push	7732					; 00001e34H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN6@is_constan:

; 4642 :   }
; 4643 :   
; 4644 :   switch(list[node].type)

	mov	eax, DWORD PTR _list
	imul	esi, 168				; 000000a8H
	mov	esi, DWORD PTR [esi+eax]
	cmp	esi, 10095				; 0000276fH
	je	SHORT $LN2@is_constan
	cmp	esi, 10105				; 00002779H
	jle	SHORT $LN1@is_constan
	cmp	esi, 10107				; 0000277bH
	jle	SHORT $LN2@is_constan
$LN1@is_constan:

; 4649 :      default:
; 4650 :         return 0;

	xor	eax, eax
	pop	esi

; 4651 :   }
; 4652 : } // end is_constant()

	pop	ebp
	ret	0
$LN2@is_constan:

; 4645 :   {  case PUSHPI_NODE:
; 4646 :      case PUSHE_NODE:
; 4647 :      case PUSHCONST_NODE:
; 4648 :         return 1;

	mov	eax, 1
	pop	esi

; 4651 :   }
; 4652 : } // end is_constant()

	pop	ebp
	ret	0
_is_constant ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@EHOENKHA@No_display?5is?5only?5for?5facets?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CJ@EDKJMKM@No?5no_transform?5for?5vertices?5or?5@ ; `string'
PUBLIC	??_C@_0CG@FHLFDHCM@No?5no_refine?5for?5vertices?5or?5bod@ ; `string'
PUBLIC	??_C@_0CA@FHFDHGGE@Hit_partner?5only?5for?5vertices?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@INAMPMOC@No?5density?5for?5vertices?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@DNPOAKCB@Volume?5only?5for?5bodies?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@OFNMICCI@Volconst?5only?5for?5bodies?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@EFNOPFG@Target?5only?5for?5bodies?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@DCMEGDBD@Facet?5only?5for?5facetedges?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@KLEOHFMJ@Edge?5only?5for?5facetedges?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@CFFJCELC@Area?5only?5for?5facets?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DH@DHGCMOKK@Dihedral?5defined?5only?5for?5STRING@ ; `string'
PUBLIC	??_C@_0BN@GAOOLKBB@Dihedral?5only?5for?5vertices?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@NOIBKFEK@Dihedral?5only?5for?5edges?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@LCPNBOMD@Mid_facet?5only?5for?5vertices?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@ECGOBLJL@Mid_edge?5only?5for?5vertices?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@MIBFLFMI@Wrap?5only?5for?5edges?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@PAPLLPOF@Fixedvol?5only?5for?5bodies?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@KJEFMOAH@Facetnormal?5only?5for?5edges?4?6?$AA@ ; `string'
PUBLIC	??_C@_0EL@EGEGNGHH@Mean_curvature?5attribute?5impleme@ ; `string'
PUBLIC	??_C@_0CD@JEGMKDIE@Mean_curvature?5only?5for?5vertices@ ; `string'
PUBLIC	??_C@_0BI@FKEBJKIN@Length?5only?5for?5edges?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@MKBFFPCD@Orientation?5only?5for?5edges?5or?5fa@ ; `string'
PUBLIC	??_C@_0CC@HLAHPKPG@?$CCShow?$CC?5only?5for?5edges?5or?5facets?4@ ; `string'
PUBLIC	??_C@_0CD@JCOGGAAE@No?5bareness?5for?5facets?5or?5bodies@ ; `string'
PUBLIC	??_C@_0CB@IIPHIEPO@Color?5only?5for?5edges?5or?5facets?4?6@ ; `string'
PUBLIC	??_C@_0CK@ENGPPANK@Frontcolor?5or?5backcolor?5only?5for@ ; `string'
PUBLIC	??_C@_0DP@LEOPIADF@Frontbody?5or?5backbody?5only?5for?5f@ ; `string'
PUBLIC	??_C@_0CK@KKODAGDB@Square?5mean?5curvature?5only?5for?5v@ ; `string'
PUBLIC	??_C@_0CA@KGJBLLHB@Midv?5only?5for?5quadratic?5edges?4?6?$AA@ ; `string'
PUBLIC	_check_element_type
EXTRN	_web:BYTE
;	COMDAT ??_C@_0CA@EHOENKHA@No_display?5is?5only?5for?5facets?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@EHOENKHA@No_display?5is?5only?5for?5facets?4?6?$AA@ DB 'No_disp'
	DB	'lay is only for facets.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EDKJMKM@No?5no_transform?5for?5vertices?5or?5@
CONST	SEGMENT
??_C@_0CJ@EDKJMKM@No?5no_transform?5for?5vertices?5or?5@ DB 'No no_transf'
	DB	'orm for vertices or bodies.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FHLFDHCM@No?5no_refine?5for?5vertices?5or?5bod@
CONST	SEGMENT
??_C@_0CG@FHLFDHCM@No?5no_refine?5for?5vertices?5or?5bod@ DB 'No no_refin'
	DB	'e for vertices or bodies.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FHFDHGGE@Hit_partner?5only?5for?5vertices?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@FHFDHGGE@Hit_partner?5only?5for?5vertices?4?6?$AA@ DB 'Hit_part'
	DB	'ner only for vertices.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@INAMPMOC@No?5density?5for?5vertices?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@INAMPMOC@No?5density?5for?5vertices?4?6?$AA@ DB 'No density for'
	DB	' vertices.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DNPOAKCB@Volume?5only?5for?5bodies?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@DNPOAKCB@Volume?5only?5for?5bodies?4?6?$AA@ DB 'Volume only for'
	DB	' bodies.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OFNMICCI@Volconst?5only?5for?5bodies?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@OFNMICCI@Volconst?5only?5for?5bodies?4?6?$AA@ DB 'Volconst only'
	DB	' for bodies.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EFNOPFG@Target?5only?5for?5bodies?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@EFNOPFG@Target?5only?5for?5bodies?4?6?$AA@ DB 'Target only for '
	DB	'bodies.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DCMEGDBD@Facet?5only?5for?5facetedges?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@DCMEGDBD@Facet?5only?5for?5facetedges?4?6?$AA@ DB 'Facet only f'
	DB	'or facetedges.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KLEOHFMJ@Edge?5only?5for?5facetedges?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@KLEOHFMJ@Edge?5only?5for?5facetedges?4?6?$AA@ DB 'Edge only for'
	DB	' facetedges.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFFJCELC@Area?5only?5for?5facets?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@CFFJCELC@Area?5only?5for?5facets?4?6?$AA@ DB 'Area only for fac'
	DB	'ets.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@DHGCMOKK@Dihedral?5defined?5only?5for?5STRING@
CONST	SEGMENT
??_C@_0DH@DHGCMOKK@Dihedral?5defined?5only?5for?5STRING@ DB 'Dihedral def'
	DB	'ined only for STRING and SOAPFILM models.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GAOOLKBB@Dihedral?5only?5for?5vertices?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@GAOOLKBB@Dihedral?5only?5for?5vertices?4?6?$AA@ DB 'Dihedral on'
	DB	'ly for vertices.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NOIBKFEK@Dihedral?5only?5for?5edges?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@NOIBKFEK@Dihedral?5only?5for?5edges?4?6?$AA@ DB 'Dihedral only '
	DB	'for edges.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LCPNBOMD@Mid_facet?5only?5for?5vertices?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@LCPNBOMD@Mid_facet?5only?5for?5vertices?4?6?$AA@ DB 'Mid_facet '
	DB	'only for vertices.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ECGOBLJL@Mid_edge?5only?5for?5vertices?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@ECGOBLJL@Mid_edge?5only?5for?5vertices?4?6?$AA@ DB 'Mid_edge on'
	DB	'ly for vertices.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MIBFLFMI@Wrap?5only?5for?5edges?4?6?$AA@
CONST	SEGMENT
??_C@_0BG@MIBFLFMI@Wrap?5only?5for?5edges?4?6?$AA@ DB 'Wrap only for edge'
	DB	's.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PAPLLPOF@Fixedvol?5only?5for?5bodies?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@PAPLLPOF@Fixedvol?5only?5for?5bodies?4?6?$AA@ DB 'Fixedvol only'
	DB	' for bodies.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KJEFMOAH@Facetnormal?5only?5for?5edges?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@KJEFMOAH@Facetnormal?5only?5for?5edges?4?6?$AA@ DB 'Facetnormal'
	DB	' only for edges.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@EGEGNGHH@Mean_curvature?5attribute?5impleme@
CONST	SEGMENT
??_C@_0EL@EGEGNGHH@Mean_curvature?5attribute?5impleme@ DB 'Mean_curvature'
	DB	' attribute implemented only for string and soapfilm models.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JEGMKDIE@Mean_curvature?5only?5for?5vertices@
CONST	SEGMENT
??_C@_0CD@JEGMKDIE@Mean_curvature?5only?5for?5vertices@ DB 'Mean_curvatur'
	DB	'e only for vertices.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FKEBJKIN@Length?5only?5for?5edges?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@FKEBJKIN@Length?5only?5for?5edges?4?6?$AA@ DB 'Length only for '
	DB	'edges.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MKBFFPCD@Orientation?5only?5for?5edges?5or?5fa@
CONST	SEGMENT
??_C@_0CH@MKBFFPCD@Orientation?5only?5for?5edges?5or?5fa@ DB 'Orientation'
	DB	' only for edges or facets.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HLAHPKPG@?$CCShow?$CC?5only?5for?5edges?5or?5facets?4@
CONST	SEGMENT
??_C@_0CC@HLAHPKPG@?$CCShow?$CC?5only?5for?5edges?5or?5facets?4@ DB '"Sho'
	DB	'w" only for edges or facets.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JCOGGAAE@No?5bareness?5for?5facets?5or?5bodies@
CONST	SEGMENT
??_C@_0CD@JCOGGAAE@No?5bareness?5for?5facets?5or?5bodies@ DB 'No bareness'
	DB	' for facets or bodies.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@IIPHIEPO@Color?5only?5for?5edges?5or?5facets?4?6@
CONST	SEGMENT
??_C@_0CB@IIPHIEPO@Color?5only?5for?5edges?5or?5facets?4?6@ DB 'Color onl'
	DB	'y for edges or facets.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@ENGPPANK@Frontcolor?5or?5backcolor?5only?5for@
CONST	SEGMENT
??_C@_0CK@ENGPPANK@Frontcolor?5or?5backcolor?5only?5for@ DB 'Frontcolor o'
	DB	'r backcolor only for facets.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@LEOPIADF@Frontbody?5or?5backbody?5only?5for?5f@
CONST	SEGMENT
??_C@_0DP@LEOPIADF@Frontbody?5or?5backbody?5only?5for?5f@ DB 'Frontbody o'
	DB	'r backbody only for facets, or string model edges.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KKODAGDB@Square?5mean?5curvature?5only?5for?5v@
CONST	SEGMENT
??_C@_0CK@KKODAGDB@Square?5mean?5curvature?5only?5for?5v@ DB 'Square mean'
	DB	' curvature only for vertices.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KGJBLLHB@Midv?5only?5for?5quadratic?5edges?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@KGJBLLHB@Midv?5only?5for?5quadratic?5edges?4?6?$AA@ DB 'Midv on'
	DB	'ly for quadratic edges.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _check_element_type
_TEXT	SEGMENT
_attrib$ = 8						; size = 4
_etype$ = 12						; size = 4
_check_element_type PROC				; COMDAT

; 4665 : {

	push	ebp
	mov	ebp, esp

; 4666 :   switch ( attrib )

	mov	eax, DWORD PTR _attrib$[ebp]
	add	eax, -10165				; ffffd84bH
	cmp	eax, 116				; 00000074H
	ja	$LN1@check_elem
	movzx	eax, BYTE PTR $LN69@check_elem[eax]
	jmp	DWORD PTR $LN71@check_elem[eax*4]
$LN64@check_elem:

; 4667 :   {  
; 4668 : 
; 4669 :     case GET_MIDV_NODE:
; 4670 :      if ( etype != EDGE )

	cmp	DWORD PTR _etype$[ebp], 1
	je	$LN1@check_elem

; 4671 :          kb_error(1456,"Midv only for quadratic edges.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CA@KGJBLLHB@Midv?5only?5for?5quadratic?5edges?4?6?$AA@
	push	1456					; 000005b0H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN62@check_elem:

; 4672 :             break;
; 4673 : 
; 4674 :     case GET_SQ_MEAN_CURV_NODE:
; 4675 :      if ( etype != VERTEX )

	cmp	DWORD PTR _etype$[ebp], 0
	je	$LN1@check_elem

; 4676 :          kb_error(1457,"Square mean curvature only for vertices.\n",
; 4677 :          COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CK@KKODAGDB@Square?5mean?5curvature?5only?5for?5v@
	push	1457					; 000005b1H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN60@check_elem:

; 4678 :      break;
; 4679 : 
; 4680 :     case GET_FRONTBODY_NODE:
; 4681 :     case GET_BACKBODY_NODE:
; 4682 :      if ( (etype != FACET) && !((etype==EDGE)&&(web.representation==STRING)))

	mov	eax, DWORD PTR _etype$[ebp]
	cmp	eax, 2
	je	$LN1@check_elem
	cmp	eax, 1
	jne	SHORT $LN58@check_elem
	cmp	DWORD PTR _web+624, eax
	je	$LN1@check_elem
$LN58@check_elem:

; 4683 :          kb_error(1297,"Frontbody or backbody only for facets, or string model edges.\n",
; 4684 :            COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DP@LEOPIADF@Frontbody?5or?5backbody?5only?5for?5f@
	push	1297					; 00000511H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN57@check_elem:

; 4685 :       break;
; 4686 : 
; 4687 :     case GET_FRONTCOLOR_NODE:
; 4688 :     case GET_BACKCOLOR_NODE:
; 4689 :      if ( (etype != FACET) )

	cmp	DWORD PTR _etype$[ebp], 2
	je	$LN1@check_elem

; 4690 :          kb_error(1458,"Frontcolor or backcolor only for facets.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CK@ENGPPANK@Frontcolor?5or?5backcolor?5only?5for@
	push	1458					; 000005b2H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN55@check_elem:

; 4691 :       break;
; 4692 : 
; 4693 :     case GET_COLOR_NODE:
; 4694 :      if ( !((etype == FACET) || (etype == EDGE)) )

	mov	eax, DWORD PTR _etype$[ebp]
	cmp	eax, 2
	je	$LN1@check_elem
	cmp	eax, 1
	je	$LN1@check_elem

; 4695 :          kb_error(1459,"Color only for edges or facets.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CB@IIPHIEPO@Color?5only?5for?5edges?5or?5facets?4?6@
	push	1459					; 000005b3H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN53@check_elem:

; 4696 :       break;
; 4697 : 
; 4698 :     case GET_BARE_NODE:
; 4699 :       if ( (etype == BODY) || (etype == FACET) )

	mov	eax, DWORD PTR _etype$[ebp]
	cmp	eax, 3
	je	SHORT $LN51@check_elem
	cmp	eax, 2
	jne	$LN1@check_elem
$LN51@check_elem:

; 4700 :           kb_error(1460,"No bareness for facets or bodies.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CD@JCOGGAAE@No?5bareness?5for?5facets?5or?5bodies@
	push	1460					; 000005b4H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN50@check_elem:

; 4701 :       break;
; 4702 : 
; 4703 :     case GET_SHOW_NODE:
; 4704 :      if ( (etype != EDGE) && (etype != FACET) )

	mov	eax, DWORD PTR _etype$[ebp]
	cmp	eax, 1
	je	$LN1@check_elem
	cmp	eax, 2
	je	$LN1@check_elem

; 4705 :         kb_error(2243,"\"Show\" only for edges or facets.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CC@HLAHPKPG@?$CCShow?$CC?5only?5for?5edges?5or?5facets?4@
	push	2243					; 000008c3H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN48@check_elem:

; 4706 :      break;
; 4707 : 
; 4708 : 
; 4709 :     case GET_ORIENTATION_NODE:
; 4710 :      if ( (etype != EDGE) && (etype != FACET) )

	mov	eax, DWORD PTR _etype$[ebp]
	cmp	eax, 1
	je	$LN1@check_elem
	cmp	eax, 2
	je	$LN1@check_elem

; 4711 :         kb_error(1461,"Orientation only for edges or facets.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CH@MKBFFPCD@Orientation?5only?5for?5edges?5or?5fa@
	push	1461					; 000005b5H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN46@check_elem:

; 4712 :      break;
; 4713 : 
; 4714 :     case GET_LENGTH_NODE:
; 4715 :      if ( etype != EDGE )

	cmp	DWORD PTR _etype$[ebp], 1
	je	$LN1@check_elem

; 4716 :          kb_error(1462,"Length only for edges.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BI@FKEBJKIN@Length?5only?5for?5edges?4?6?$AA@
	push	1462					; 000005b6H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN44@check_elem:

; 4717 :      break;
; 4718 : 
; 4719 :     case GET_MEANCURV_NODE:
; 4720 :      if ( etype != VERTEX )

	cmp	DWORD PTR _etype$[ebp], 0
	je	SHORT $LN43@check_elem

; 4721 :          kb_error(2872,"Mean_curvature only for vertices.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CD@JEGMKDIE@Mean_curvature?5only?5for?5vertices@
	push	2872					; 00000b38H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN43@check_elem:

; 4722 :      if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	jne	$LN1@check_elem

; 4723 :         kb_error(3036,
; 4724 :  "Mean_curvature attribute implemented only for string and soapfilm models.\n",
; 4725 :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EL@EGEGNGHH@Mean_curvature?5attribute?5impleme@
	push	3036					; 00000bdcH

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN41@check_elem:

; 4726 :      break;
; 4727 : 
; 4728 :     case GET_VERTEXNORMAL_NODE:
; 4729 :      if ( etype != VERTEX )

	cmp	DWORD PTR _etype$[ebp], 0
	je	$LN1@check_elem

; 4730 :          kb_error(2244,"Facetnormal only for edges.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BN@KJEFMOAH@Facetnormal?5only?5for?5edges?4?6?$AA@
	push	2244					; 000008c4H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN39@check_elem:

; 4731 :       break;
; 4732 : 
; 4733 :     case GET_FIXEDVOL_NODE:
; 4734 :      if ( etype != BODY )

	cmp	DWORD PTR _etype$[ebp], 3
	je	$LN1@check_elem

; 4735 :          kb_error(1463,"Fixedvol only for bodies.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BL@PAPLLPOF@Fixedvol?5only?5for?5bodies?4?6?$AA@
	push	1463					; 000005b7H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN37@check_elem:

; 4736 :      break;
; 4737 : 
; 4738 :     case GET_WRAP_NODE:
; 4739 :      if ( etype != EDGE )

	cmp	DWORD PTR _etype$[ebp], 1
	je	$LN1@check_elem

; 4740 :          kb_error(1464,"Wrap only for edges.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BG@MIBFLFMI@Wrap?5only?5for?5edges?4?6?$AA@
	push	1464					; 000005b8H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN35@check_elem:

; 4741 :      break;
; 4742 : 
; 4743 :     case GET_MID_EDGE_NODE:
; 4744 :      if ( etype != VERTEX )

	cmp	DWORD PTR _etype$[ebp], 0
	je	$LN1@check_elem

; 4745 :          kb_error(3112,"Mid_edge only for vertices.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BN@ECGOBLJL@Mid_edge?5only?5for?5vertices?4?6?$AA@
	push	3112					; 00000c28H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN33@check_elem:

; 4746 :      break;
; 4747 : 
; 4748 :     case GET_MID_FACET_NODE:
; 4749 :      if ( etype != VERTEX )

	cmp	DWORD PTR _etype$[ebp], 0
	je	$LN1@check_elem

; 4750 :          kb_error(3113,"Mid_facet only for vertices.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BO@LCPNBOMD@Mid_facet?5only?5for?5vertices?4?6?$AA@
	push	3113					; 00000c29H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN31@check_elem:

; 4751 :      break;
; 4752 : 
; 4753 :     case GET_DIHEDRAL_NODE:
; 4754 :      if ( web.representation == SOAPFILM )

	mov	eax, DWORD PTR _web+624
	cmp	eax, 2
	jne	SHORT $LN30@check_elem

; 4755 :      { if (etype != EDGE) 

	cmp	DWORD PTR _etype$[ebp], 1
	je	$LN1@check_elem

; 4756 :           kb_error(1465,"Dihedral only for edges.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BK@NOIBKFEK@Dihedral?5only?5for?5edges?4?6?$AA@
	push	1465					; 000005b9H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN30@check_elem:

; 4757 :      }
; 4758 :      else if ( web.representation == STRING )

	cmp	eax, 1
	jne	SHORT $LN27@check_elem

; 4759 :      { if (etype != VERTEX) 

	cmp	DWORD PTR _etype$[ebp], 0
	je	$LN1@check_elem

; 4760 :          kb_error(1466,"Dihedral only for vertices.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BN@GAOOLKBB@Dihedral?5only?5for?5vertices?4?6?$AA@
	push	1466					; 000005baH

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN27@check_elem:

; 4761 :      }
; 4762 :      else 
; 4763 :       kb_error(1467,
; 4764 :       "Dihedral defined only for STRING and SOAPFILM models.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DH@DHGCMOKK@Dihedral?5defined?5only?5for?5STRING@
	push	1467					; 000005bbH

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN24@check_elem:

; 4765 :      break;
; 4766 : 
; 4767 :     case GET_AREA_NODE:
; 4768 :      if ( etype != FACET )

	cmp	DWORD PTR _etype$[ebp], 2
	je	$LN1@check_elem

; 4769 :          kb_error(1468,"Area only for facets.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BH@CFFJCELC@Area?5only?5for?5facets?4?6?$AA@
	push	1468					; 000005bcH

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN22@check_elem:

; 4770 :      break;
; 4771 : 
; 4772 :     case GET_EDGE_NODE:
; 4773 :      if ( etype != FACETEDGE )

	cmp	DWORD PTR _etype$[ebp], 4
	je	$LN1@check_elem

; 4774 :          kb_error(1469,"Edge only for facetedges.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BL@KLEOHFMJ@Edge?5only?5for?5facetedges?4?6?$AA@
	push	1469					; 000005bdH

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN20@check_elem:

; 4775 :      break;
; 4776 : 
; 4777 :     case GET_FACET_NODE:
; 4778 :      if ( etype != FACETEDGE )

	cmp	DWORD PTR _etype$[ebp], 4
	je	$LN1@check_elem

; 4779 :          kb_error(1470,"Facet only for facetedges.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BM@DCMEGDBD@Facet?5only?5for?5facetedges?4?6?$AA@
	push	1470					; 000005beH

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN18@check_elem:

; 4780 :      break;
; 4781 : 
; 4782 :     case GET_TARGET_NODE:
; 4783 :      if ( etype != BODY )

	cmp	DWORD PTR _etype$[ebp], 3
	je	$LN1@check_elem

; 4784 :          kb_error(1471,"Target only for bodies.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BJ@EFNOPFG@Target?5only?5for?5bodies?4?6?$AA@
	push	1471					; 000005bfH

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN16@check_elem:

; 4785 :      break;
; 4786 : 
; 4787 :     case GET_VOLCONST_NODE:
; 4788 :      if ( etype != BODY )

	cmp	DWORD PTR _etype$[ebp], 3
	je	$LN1@check_elem

; 4789 :          kb_error(1472,"Volconst only for bodies.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BL@OFNMICCI@Volconst?5only?5for?5bodies?4?6?$AA@
	push	1472					; 000005c0H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN14@check_elem:

; 4790 :      break;
; 4791 : 
; 4792 :     case GET_VOLUME_NODE:
; 4793 :      if ( etype != BODY )

	cmp	DWORD PTR _etype$[ebp], 3
	je	$LN1@check_elem

; 4794 :          kb_error(1473,"Volume only for bodies.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BJ@DNPOAKCB@Volume?5only?5for?5bodies?4?6?$AA@
	push	1473					; 000005c1H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN12@check_elem:

; 4795 :      break;
; 4796 : 
; 4797 :     case GET_DENSITY_NODE:
; 4798 :      if ( etype == VERTEX )

	cmp	DWORD PTR _etype$[ebp], 0
	jne	$LN1@check_elem

; 4799 :          kb_error(1474,"No density for vertices.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BK@INAMPMOC@No?5density?5for?5vertices?4?6?$AA@
	push	1474					; 000005c2H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN10@check_elem:

; 4800 :      break;
; 4801 : 
; 4802 :     case SET_HIT_PARTNER_NODE:
; 4803 :      if ( etype != VERTEX )

	cmp	DWORD PTR _etype$[ebp], 0
	je	SHORT $LN1@check_elem

; 4804 :          kb_error(3003,"Hit_partner only for vertices.\n",
; 4805 :            COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CA@FHFDHGGE@Hit_partner?5only?5for?5vertices?4?6?$AA@
	push	3003					; 00000bbbH

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN8@check_elem:

; 4806 :      break;
; 4807 : 
; 4808 :     case SET_NO_REFINE_NODE:
; 4809 :      if ( etype == BODY || etype == VERTEX )

	mov	eax, DWORD PTR _etype$[ebp]
	cmp	eax, 3
	je	SHORT $LN6@check_elem
	test	eax, eax
	jne	SHORT $LN1@check_elem
$LN6@check_elem:

; 4810 :          kb_error(1494,"No no_refine for vertices or bodies.\n",
; 4811 :            COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CG@FHLFDHCM@No?5no_refine?5for?5vertices?5or?5bod@
	push	1494					; 000005d6H

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN5@check_elem:

; 4812 :      break;
; 4813 : 
; 4814 :     case SET_NO_TRANSFORM_NODE:
; 4815 :      if ( etype == BODY || etype == VERTEX )

	mov	eax, DWORD PTR _etype$[ebp]
	cmp	eax, 3
	je	SHORT $LN3@check_elem
	test	eax, eax
	jne	SHORT $LN1@check_elem
$LN3@check_elem:

; 4816 :          kb_error(3034,"No no_transform for vertices or bodies.\n",
; 4817 :            COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CJ@EDKJMKM@No?5no_transform?5for?5vertices?5or?5@
	push	3034					; 00000bdaH

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
$LN2@check_elem:

; 4818 :      break;
; 4819 : 
; 4820 :     case SET_NO_DISPLAY_NODE:
; 4821 :      if ( etype != FACET )

	cmp	DWORD PTR _etype$[ebp], 2
	je	SHORT $LN1@check_elem

; 4822 :          kb_error(1320,"No_display is only for facets.\n",
; 4823 :          COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CA@EHOENKHA@No_display?5is?5only?5for?5facets?4?6?$AA@
	push	1320					; 00000528H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@check_elem:

; 4824 :          break;
; 4825 :       }
; 4826 : } // end check_element_type()

	pop	ebp
	ret	0
	npad	1
$LN71@check_elem:
	DD	$LN41@check_elem
	DD	$LN62@check_elem
	DD	$LN39@check_elem
	DD	$LN44@check_elem
	DD	$LN46@check_elem
	DD	$LN31@check_elem
	DD	$LN48@check_elem
	DD	$LN22@check_elem
	DD	$LN20@check_elem
	DD	$LN24@check_elem
	DD	$LN35@check_elem
	DD	$LN33@check_elem
	DD	$LN37@check_elem
	DD	$LN12@check_elem
	DD	$LN14@check_elem
	DD	$LN16@check_elem
	DD	$LN18@check_elem
	DD	$LN55@check_elem
	DD	$LN57@check_elem
	DD	$LN60@check_elem
	DD	$LN53@check_elem
	DD	$LN64@check_elem
	DD	$LN50@check_elem
	DD	$LN2@check_elem
	DD	$LN10@check_elem
	DD	$LN8@check_elem
	DD	$LN5@check_elem
	DD	$LN1@check_elem
$LN69@check_elem:
	DB	0
	DB	27					; 0000001bH
	DB	1
	DB	2
	DB	27					; 0000001bH
	DB	3
	DB	4
	DB	5
	DB	6
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	7
	DB	8
	DB	27					; 0000001bH
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	13					; 0000000dH
	DB	27					; 0000001bH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	22					; 00000016H
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	23					; 00000017H
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	24					; 00000018H
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	25					; 00000019H
	DB	27					; 0000001bH
	DB	26					; 0000001aH
_check_element_type ENDP
_TEXT	ENDS
PUBLIC	_check_array_dims_same
EXTRN	_dymem:DWORD
EXTRN	_localbase:DWORD
; Function compile flags: /Ogtp
;	COMDAT _check_array_dims_same
_TEXT	SEGMENT
_left$ = 8						; size = 4
_afixed$ = 12						; size = 4
_right$ = 16						; size = 4
_bfixed$ = 20						; size = 4
_check_array_dims_same PROC				; COMDAT

; 4843 : {

	push	ebp
	mov	ebp, esp

; 4844 :   struct array *alvalue;
; 4845 :   struct array *arvalue;
; 4846 :   int adim,bdim;
; 4847 : 
; 4848 :   if ( (left & GTYPEMASK) == ATTRIBNAME )

	mov	eax, DWORD PTR _left$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _localbase
	mov	ecx, eax
	push	esi
	and	ecx, -268435456				; f0000000H
	push	edi
	mov	edi, DWORD PTR _web+5652
	cmp	ecx, 1073741824				; 40000000H
	jne	SHORT $LN4@check_arra

; 4849 :   { struct extra *ex = EXTRAS(name_eltype(left)) + (left & GLOBMASK);
; 4850 :     alvalue = &(ex->array_spec);
; 4851 :     adim = alvalue->dim;

	mov	edx, eax
	sar	edx, 24					; 00000018H
	and	edx, 15					; 0000000fH
	and	eax, 16777215				; 00ffffffH
	imul	edx, 112				; 00000070H
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web[edx+104]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+76]

; 4852 :   }
; 4853 :   else

	jmp	SHORT $LN3@check_arra
$LN4@check_arra:

; 4854 :   { struct global *glvalue = globals(left);

	mov	edx, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN7@check_arra
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN9@check_arra
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ebx]
	jmp	SHORT $LN8@check_arra
$LN9@check_arra:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN7@check_arra
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN8@check_arra
$LN7@check_arra:
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+edx]
$LN8@check_arra:

; 4855 :     adim = glvalue->attr.arrayptr->dim;

	mov	ecx, DWORD PTR [eax+168]
	mov	eax, DWORD PTR [ecx+4]
$LN3@check_arra:

; 4856 :   }
; 4857 :   if ( (right & GTYPEMASK) == ATTRIBNAME )

	mov	ecx, DWORD PTR _right$[ebp]
	mov	esi, ecx
	and	esi, -268435456				; f0000000H
	cmp	esi, 1073741824				; 40000000H

; 4858 :   { struct extra *ex = EXTRAS(name_eltype(right)) + (right & GLOBMASK);
; 4859 :     arvalue = &(ex->array_spec);
; 4860 :     bdim = arvalue->dim;

	mov	esi, ecx
	jne	SHORT $LN2@check_arra

; 4866 :  }
; 4867 : 
; 4868 :   return (adim-afixed) == (bdim-bfixed);

	sub	eax, DWORD PTR _afixed$[ebp]
	sar	esi, 24					; 00000018H
	and	ecx, 16777215				; 00ffffffH
	and	esi, 15					; 0000000fH
	imul	ecx, 240				; 000000f0H
	imul	esi, 112				; 00000070H
	add	ecx, DWORD PTR _web[esi+104]
	pop	edi
	mov	ecx, DWORD PTR [ecx+edx+76]
	sub	ecx, DWORD PTR _bfixed$[ebp]
	xor	edx, edx
	cmp	eax, ecx
	sete	dl
	pop	esi
	pop	ebx
	mov	eax, edx

; 4869 : } // end check_array_dims_same()

	pop	ebp
	ret	0
$LN2@check_arra:

; 4861 :  }
; 4862 :   else
; 4863 :   { struct global *grvalue = globals(right);

	and	esi, -16777216				; ff000000H
	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN13@check_arra
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN15@check_arra
	and	ecx, 16777215				; 00ffffffH
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [ebx]
	jmp	SHORT $LN14@check_arra
$LN15@check_arra:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN13@check_arra
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN14@check_arra
$LN13@check_arra:
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+edx]
$LN14@check_arra:

; 4864 :     arvalue = grvalue->attr.arrayptr;
; 4865 :     bdim = grvalue->attr.arrayptr->dim;

	mov	edx, DWORD PTR [ecx+168]
	mov	ecx, DWORD PTR [edx+4]

; 4866 :  }
; 4867 : 
; 4868 :   return (adim-afixed) == (bdim-bfixed);

	sub	eax, DWORD PTR _afixed$[ebp]
	sub	ecx, DWORD PTR _bfixed$[ebp]
	xor	edx, edx
	cmp	eax, ecx
	sete	dl
	pop	edi
	pop	esi
	pop	ebx
	mov	eax, edx

; 4869 : } // end check_array_dims_same()

	pop	ebp
	ret	0
_check_array_dims_same ENDP
_TEXT	ENDS
PUBLIC	_check_array_dims_for_mult
; Function compile flags: /Ogtp
;	COMDAT _check_array_dims_for_mult
_TEXT	SEGMENT
_left$ = 8						; size = 4
_afixed$ = 12						; size = 4
_right1$ = 16						; size = 4
_bfixed$ = 20						; size = 4
_right2$ = 24						; size = 4
_cfixed$ = 28						; size = 4
_check_array_dims_for_mult PROC				; COMDAT

; 4889 : {

	push	ebp
	mov	ebp, esp

; 4890 :   struct array *alvalue;
; 4891 :   struct array *ar1value,*ar2value;
; 4892 :   int adim,bdim,cdim;
; 4893 : 
; 4894 :   if ( (left & GTYPEMASK) == ATTRIBNAME )

	mov	eax, DWORD PTR _left$[ebp]
	push	ebx
	mov	ecx, eax
	push	esi
	and	ecx, -268435456				; f0000000H
	push	edi
	mov	edi, DWORD PTR _web+5652
	cmp	ecx, 1073741824				; 40000000H
	jne	SHORT $LN6@check_arra@2

; 4895 :   { struct extra *ex = EXTRAS(name_eltype(left)) + (left & GLOBMASK);
; 4896 :     alvalue = &(ex->array_spec);
; 4897 :     adim = alvalue->dim;

	mov	edx, eax
	sar	edx, 24					; 00000018H
	and	edx, 15					; 0000000fH
	and	eax, 16777215				; 00ffffffH
	imul	edx, 112				; 00000070H
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web[edx+104]
	mov	edx, DWORD PTR _dymem
	mov	ebx, DWORD PTR [eax+edx+76]

; 4898 :   }
; 4899 :   else

	jmp	SHORT $LN5@check_arra@2
$LN6@check_arra@2:

; 4900 :   { struct global *glvalue = globals(left);

	mov	edx, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN9@check_arra@2
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN11@check_arra@2
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN10@check_arra@2
$LN11@check_arra@2:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN9@check_arra@2
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN10@check_arra@2
$LN9@check_arra@2:
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+edx]
$LN10@check_arra@2:

; 4901 :     adim = glvalue->attr.arrayptr->dim;

	mov	ecx, DWORD PTR [eax+168]
	mov	ebx, DWORD PTR [ecx+4]
$LN5@check_arra@2:

; 4902 :   }
; 4903 : 
; 4904 :   if ( (right1 & GTYPEMASK) == ATTRIBNAME )

	mov	ecx, DWORD PTR _right1$[ebp]
	mov	eax, ecx
	and	eax, -268435456				; f0000000H
	cmp	eax, 1073741824				; 40000000H
	jne	SHORT $LN4@check_arra@2

; 4905 :   { struct extra *ex = EXTRAS(name_eltype(right1)) + (right1 & GLOBMASK);
; 4906 :     ar1value = &(ex->array_spec);
; 4907 :     bdim = ar1value->dim;

	mov	eax, ecx
	sar	eax, 24					; 00000018H
	and	eax, 15					; 0000000fH
	and	ecx, 16777215				; 00ffffffH
	imul	eax, 112				; 00000070H
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR [ecx+edx+76]

; 4908 :  }
; 4909 :   else

	jmp	SHORT $LN3@check_arra@2
$LN4@check_arra@2:

; 4910 :   { struct global *grvalue = globals(right1);

	mov	esi, ecx
	and	esi, -16777216				; ff000000H
	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN15@check_arra@2
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN17@check_arra@2
	mov	eax, DWORD PTR _localbase
	and	ecx, 16777215				; 00ffffffH
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [eax]
	jmp	SHORT $LN16@check_arra@2
$LN17@check_arra@2:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN15@check_arra@2
	mov	eax, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN16@check_arra@2
$LN15@check_arra@2:
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+edx]
$LN16@check_arra@2:

; 4911 :     ar1value = grvalue->attr.arrayptr;
; 4912 :     bdim = grvalue->attr.arrayptr->dim;

	mov	eax, DWORD PTR [ecx+168]
	mov	eax, DWORD PTR [eax+4]
$LN3@check_arra@2:

; 4913 :  }
; 4914 : 
; 4915 :   if ( (right2 & GTYPEMASK) == ATTRIBNAME )

	mov	ecx, DWORD PTR _right2$[ebp]
	mov	esi, ecx
	and	esi, -268435456				; f0000000H
	cmp	esi, 1073741824				; 40000000H

; 4916 :   { struct extra *ex = EXTRAS(name_eltype(right2)) + (right2 & GLOBMASK);
; 4917 :     ar2value = &(ex->array_spec);
; 4918 :     cdim = ar2value->dim;

	mov	esi, ecx
	jne	SHORT $LN2@check_arra@2
	sar	esi, 24					; 00000018H
	and	ecx, 16777215				; 00ffffffH
	and	esi, 15					; 0000000fH
	imul	ecx, 240				; 000000f0H
	imul	esi, 112				; 00000070H
	add	ecx, DWORD PTR _web[esi+104]
	mov	ecx, DWORD PTR [ecx+edx+76]

; 4919 :  }
; 4920 :   else

	jmp	SHORT $LN1@check_arra@2
$LN2@check_arra@2:

; 4921 :   { struct global *grvalue = globals(right2);

	and	esi, -16777216				; ff000000H
	cmp	esi, 268435456				; 10000000H
	je	SHORT $LN21@check_arra@2
	cmp	esi, 805306368				; 30000000H
	jne	SHORT $LN23@check_arra@2
	mov	edx, DWORD PTR _localbase
	and	ecx, 16777215				; 00ffffffH
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN22@check_arra@2
$LN23@check_arra@2:
	cmp	esi, 536870912				; 20000000H
	jne	SHORT $LN21@check_arra@2
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN22@check_arra@2
$LN21@check_arra@2:
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+edx]
$LN22@check_arra@2:

; 4922 :     ar2value = grvalue->attr.arrayptr;
; 4923 :     cdim = grvalue->attr.arrayptr->dim;

	mov	edx, DWORD PTR [ecx+168]
	mov	ecx, DWORD PTR [edx+4]
$LN1@check_arra@2:

; 4924 :  }
; 4925 : 
; 4926 :   return (adim-afixed) == (bdim-bfixed) + (cdim-cfixed) - 2;

	sub	ecx, DWORD PTR _bfixed$[ebp]
	sub	ebx, DWORD PTR _afixed$[ebp]
	sub	ecx, DWORD PTR _cfixed$[ebp]
	pop	edi
	lea	eax, DWORD PTR [ecx+eax-2]
	xor	ecx, ecx
	cmp	ebx, eax
	sete	cl
	pop	esi
	pop	ebx
	mov	eax, ecx

; 4927 : } // end check_array_dims_for_mult()

	pop	ebp
	ret	0
_check_array_dims_for_mult ENDP
_TEXT	ENDS
PUBLIC	_check_recalc_attr
; Function compile flags: /Ogtp
;	COMDAT _check_recalc_attr
_TEXT	SEGMENT
_name_id$ = 8						; size = 4
_check_recalc_attr PROC					; COMDAT

; 4937 : {

	push	ebp
	mov	ebp, esp

; 4938 :   switch (name_id & GTYPEMASK)

	mov	eax, DWORD PTR _name_id$[ebp]
	mov	ecx, eax
	and	ecx, -268435456				; f0000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN1@check_reca
	cmp	ecx, 536870912				; 20000000H
	je	SHORT $LN1@check_reca
	cmp	ecx, 1073741824				; 40000000H
	je	SHORT $LN2@check_reca

; 4947 :       }
; 4948 :   }
; 4949 :   return 0;

	xor	eax, eax

; 4950 : } // end check_recalc_attr()

	pop	ebp
	ret	0
$LN2@check_reca:

; 4939 :   { case ATTRIBNAME:
; 4940 :     { struct extra *ex = EXTRAS(name_eltype(name_id)) + (name_id & GLOBMASK);
; 4941 :       return ex->flags & RECALC_ATTR;

	mov	edx, DWORD PTR _dymem
	mov	ecx, eax
	sar	ecx, 24					; 00000018H
	and	eax, 16777215				; 00ffffffH
	and	ecx, 15					; 0000000fH
	imul	eax, 240				; 000000f0H
	imul	ecx, 112				; 00000070H
	add	eax, DWORD PTR _web[ecx+104]
	mov	eax, DWORD PTR [eax+edx+232]
	and	eax, 8

; 4950 : } // end check_recalc_attr()

	pop	ebp
	ret	0
$LN1@check_reca:

; 4942 :     }
; 4943 :     case EPHGLOBAL:
; 4944 :     case PERMGLOBAL:
; 4945 :       { struct global *g = globals(name_id);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN7@check_reca
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN9@check_reca
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]

; 4946 :         return g->flags & ALWAYS_RECALC;

	mov	eax, DWORD PTR [eax+192]
	and	eax, 134217728				; 08000000H

; 4950 : } // end check_recalc_attr()

	pop	ebp
	ret	0
$LN9@check_reca:

; 4942 :     }
; 4943 :     case EPHGLOBAL:
; 4944 :     case PERMGLOBAL:
; 4945 :       { struct global *g = globals(name_id);

	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN7@check_reca
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 4946 :         return g->flags & ALWAYS_RECALC;

	mov	eax, DWORD PTR [eax+192]
	and	eax, 134217728				; 08000000H

; 4950 : } // end check_recalc_attr()

	pop	ebp
	ret	0
$LN7@check_reca:

; 4942 :     }
; 4943 :     case EPHGLOBAL:
; 4944 :     case PERMGLOBAL:
; 4945 :       { struct global *g = globals(name_id);

	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]

; 4946 :         return g->flags & ALWAYS_RECALC;

	mov	eax, DWORD PTR [eax+192]
	and	eax, 134217728				; 08000000H

; 4950 : } // end check_recalc_attr()

	pop	ebp
	ret	0
_check_recalc_attr ENDP
_TEXT	ENDS
PUBLIC	_check_dont_resize_attr
; Function compile flags: /Ogtp
;	COMDAT _check_dont_resize_attr
_TEXT	SEGMENT
_name_id$ = 8						; size = 4
_check_dont_resize_attr PROC				; COMDAT

; 4961 : {

	push	ebp
	mov	ebp, esp

; 4962 :   switch (name_id & GTYPEMASK)

	mov	eax, DWORD PTR _name_id$[ebp]
	mov	ecx, eax
	and	ecx, -268435456				; f0000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN1@check_dont
	cmp	ecx, 536870912				; 20000000H
	je	SHORT $LN1@check_dont

; 4968 :       }
; 4969 :   }
; 4970 :   return 0;

	xor	eax, eax

; 4971 : } // end check_dont_resize_attr()

	pop	ebp
	ret	0
$LN1@check_dont:

; 4963 :   { 
; 4964 :     case EPHGLOBAL:
; 4965 :     case PERMGLOBAL:
; 4966 :       { struct global *g = globals(name_id);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN6@check_dont
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN8@check_dont
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]

; 4967 :         return g->flags & DONT_RESIZE;

	mov	eax, DWORD PTR [eax+192]
	and	eax, 1073741824				; 40000000H

; 4971 : } // end check_dont_resize_attr()

	pop	ebp
	ret	0
$LN8@check_dont:

; 4963 :   { 
; 4964 :     case EPHGLOBAL:
; 4965 :     case PERMGLOBAL:
; 4966 :       { struct global *g = globals(name_id);

	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN6@check_dont
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 4967 :         return g->flags & DONT_RESIZE;

	mov	eax, DWORD PTR [eax+192]
	and	eax, 1073741824				; 40000000H

; 4971 : } // end check_dont_resize_attr()

	pop	ebp
	ret	0
$LN6@check_dont:

; 4963 :   { 
; 4964 :     case EPHGLOBAL:
; 4965 :     case PERMGLOBAL:
; 4966 :       { struct global *g = globals(name_id);

	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]

; 4967 :         return g->flags & DONT_RESIZE;

	mov	eax, DWORD PTR [eax+192]
	and	eax, 1073741824				; 40000000H

; 4971 : } // end check_dont_resize_attr()

	pop	ebp
	ret	0
_check_dont_resize_attr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@GLOMOJEF@?$CFs?5is?5a?5read?9only?5variable?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@KBHFLGLJ@?$CFs?5is?5a?5read?9only?5attribute?4?6?$AA@ ; `string'
PUBLIC	_check_readonly_attr
;	COMDAT ??_C@_0BN@GLOMOJEF@?$CFs?5is?5a?5read?9only?5variable?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@GLOMOJEF@?$CFs?5is?5a?5read?9only?5variable?4?6?$AA@ DB '%s is '
	DB	'a read-only variable.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KBHFLGLJ@?$CFs?5is?5a?5read?9only?5attribute?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@KBHFLGLJ@?$CFs?5is?5a?5read?9only?5attribute?4?6?$AA@ DB '%s is'
	DB	' a read-only attribute.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _check_readonly_attr
_TEXT	SEGMENT
_name_id$ = 8						; size = 4
_check_readonly_attr PROC				; COMDAT

; 4981 : {

	push	ebp
	mov	ebp, esp

; 4982 :   if ( (name_id & GTYPEMASK) == ATTRIBNAME )

	mov	eax, DWORD PTR _name_id$[ebp]
	mov	ecx, eax
	and	ecx, -268435456				; f0000000H
	cmp	ecx, 1073741824				; 40000000H
	jne	SHORT $LN4@check_read

; 4983 :   { struct extra *ex = EXTRAS(name_eltype(name_id)) + (name_id & GLOBMASK);

	mov	edx, eax
	sar	edx, 24					; 00000018H
	and	edx, 15					; 0000000fH
	imul	edx, 112				; 00000070H
	mov	ecx, DWORD PTR _web[edx+104]
	and	eax, 16777215				; 00ffffffH
	imul	eax, 240				; 000000f0H
	add	ecx, eax
	add	ecx, DWORD PTR _dymem

; 4984 :     if ( ex->flags & READ_ONLY_ATTR )

	test	BYTE PTR [ecx+232], 16			; 00000010H
	je	$LN1@check_read

; 4985 :     { sprintf(errmsg,"%s is a read-only attribute.\n",ex->name);

	push	ecx
	push	OFFSET ??_C@_0BO@KBHFLGLJ@?$CFs?5is?5a?5read?9only?5attribute?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4986 :       kb_error(3017,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	3017					; 00000bc9H

; 4994 :       kb_error(3018,errmsg,COMMAND_ERROR);

	call	_kb_error
	add	esp, 24					; 00000018H

; 4995 :     }
; 4996 :   }
; 4997 :     
; 4998 : } /* end check_readonly_attr() */

	pop	ebp
	ret	0
$LN4@check_read:

; 4987 :     }
; 4988 :   }
; 4989 :   else /* regular global */
; 4990 :   { struct global *g;
; 4991 :     g = globals(name_id);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN7@check_read
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN9@check_read
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN8@check_read
$LN9@check_read:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN7@check_read
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN8@check_read
$LN7@check_read:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN8@check_read:

; 4992 :     if ( g->flags & READONLY )

	test	DWORD PTR [eax+192], 8388608		; 00800000H
	je	SHORT $LN1@check_read

; 4993 :     { sprintf(errmsg,"%s is a read-only variable.\n",g->name);

	push	eax
	push	OFFSET ??_C@_0BN@GLOMOJEF@?$CFs?5is?5a?5read?9only?5variable?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4994 :       kb_error(3018,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	3018					; 00000bcaH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN1@check_read:

; 4995 :     }
; 4996 :   }
; 4997 :     
; 4998 : } /* end check_readonly_attr() */

	pop	ebp
	ret	0
_check_readonly_attr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@NEMAEDIL@__facet_normal?5term?5must?5be?5lone@ ; `string'
PUBLIC	??_C@_0DF@FLHOCFFH@__edge_vector?5term?5must?5be?5lone?5@ ; `string'
PUBLIC	??_C@_0DH@HOKEIMGL@__vertex_normal?5term?5must?5be?5lon@ ; `string'
PUBLIC	_check_special_attr
;	COMDAT ??_C@_0DG@NEMAEDIL@__facet_normal?5term?5must?5be?5lone@
CONST	SEGMENT
??_C@_0DG@NEMAEDIL@__facet_normal?5term?5must?5be?5lone@ DB '__facet_norm'
	DB	'al term must be lone term on right side.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@FLHOCFFH@__edge_vector?5term?5must?5be?5lone?5@
CONST	SEGMENT
??_C@_0DF@FLHOCFFH@__edge_vector?5term?5must?5be?5lone?5@ DB '__edge_vect'
	DB	'or term must be lone term on right side.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@HOKEIMGL@__vertex_normal?5term?5must?5be?5lon@
CONST	SEGMENT
??_C@_0DH@HOKEIMGL@__vertex_normal?5term?5must?5be?5lon@ DB '__vertex_nor'
	DB	'mal term must be lone term on right side.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _check_special_attr
_TEXT	SEGMENT
_name_id$ = 8						; size = 4
_check_special_attr PROC				; COMDAT

; 5009 : {

	push	ebp
	mov	ebp, esp

; 5010 :   if ( (name_id & GTYPEMASK) == ATTRIBNAME )

	mov	eax, DWORD PTR _name_id$[ebp]
	mov	ecx, eax
	and	ecx, -268435456				; f0000000H
	cmp	ecx, 1073741824				; 40000000H
	jne	SHORT $LN1@check_spec

; 5011 :   { if ( name_id == set_name_eltype(V_NORMAL_ATTR,VERTEX) )

	cmp	eax, 1073741831				; 40000007H
	jne	SHORT $LN3@check_spec

; 5012 :       kb_error(3123,"__vertex_normal term must be lone term on right side.\n",
; 5013 :         COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DH@HOKEIMGL@__vertex_normal?5term?5must?5be?5lon@
	push	3123					; 00000c33H

; 5018 :       kb_error(3124,"__facet_normal term must be lone term on right side.\n",
; 5019 :         COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 5020 :   }
; 5021 : } // end check_special_attr()

	pop	ebp
	ret	0
$LN3@check_spec:

; 5014 :     if ( name_id == set_name_eltype(E_VECTOR_ATTR,EDGE) )

	cmp	eax, 1090519042				; 41000002H
	jne	SHORT $LN2@check_spec

; 5015 :       kb_error(3024,"__edge_vector term must be lone term on right side.\n",
; 5016 :         COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DF@FLHOCFFH@__edge_vector?5term?5must?5be?5lone?5@
	push	3024					; 00000bd0H

; 5018 :       kb_error(3124,"__facet_normal term must be lone term on right side.\n",
; 5019 :         COMMAND_ERROR);

	call	_kb_error
	add	esp, 12					; 0000000cH

; 5020 :   }
; 5021 : } // end check_special_attr()

	pop	ebp
	ret	0
$LN2@check_spec:

; 5017 :     if ( name_id == set_name_eltype(F_NORMAL_ATTR,FACET) )

	cmp	eax, 1107296258				; 42000002H
	jne	SHORT $LN1@check_spec

; 5018 :       kb_error(3124,"__facet_normal term must be lone term on right side.\n",
; 5019 :         COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DG@NEMAEDIL@__facet_normal?5term?5must?5be?5lone@
	push	3124					; 00000c34H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@check_spec:

; 5020 :   }
; 5021 : } // end check_special_attr()

	pop	ebp
	ret	0
_check_special_attr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@LINGLBGC@Internal?5error?3?5lvalue?5type?5?$CFd?6?$AA@ ; `string'
PUBLIC	_convert_lvalue_to_rvalue
;	COMDAT ??_C@_0CA@LINGLBGC@Internal?5error?3?5lvalue?5type?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0CA@LINGLBGC@Internal?5error?3?5lvalue?5type?5?$CFd?6?$AA@ DB 'Inte'
	DB	'rnal error: lvalue type %d', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _convert_lvalue_to_rvalue
_TEXT	SEGMENT
_list$ = 8						; size = 4
_convert_lvalue_to_rvalue PROC				; COMDAT

; 5034 : {

	push	ebp
	mov	ebp, esp

; 5035 :    switch ( list->type )

	mov	eax, DWORD PTR _list$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, edx
	sub	ecx, 10701				; 000029cdH
	je	SHORT $LN2@convert_lv
	dec	ecx
	je	SHORT $LN3@convert_lv

; 5045 :        break;
; 5046 :      default:
; 5047 :        sprintf(errmsg,"Internal error: lvalue type %d\n",list->type);

	push	edx
	push	OFFSET ??_C@_0CA@LINGLBGC@Internal?5error?3?5lvalue?5type?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 5048 :        kb_error(2883,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	2883					; 00000b43H
	call	_kb_error
	add	esp, 24					; 00000018H

; 5049 :    }
; 5050 :  
; 5051 : } // end convert_lvalue_to_rvalue()

	pop	ebp
	ret	0
$LN3@convert_lv:

; 5036 :    { case SET_DELTA_NODE:
; 5037 :        list->type = PUSHDELTA_NODE;

	mov	DWORD PTR [eax], 10096			; 00002770H

; 5043 :        list->left = 0;
; 5044 :        list->stack_delta = 1;

	mov	DWORD PTR [eax+156], 1
	mov	DWORD PTR [eax+4], 0

; 5049 :    }
; 5050 :  
; 5051 : } // end convert_lvalue_to_rvalue()

	pop	ebp
	ret	0
$LN2@convert_lv:

; 5038 :        list->left = 0;
; 5039 :        list->stack_delta = 1;
; 5040 :        break;
; 5041 :      case SET_PARAM_SCALE_NODE:
; 5042 :        list->type = PUSH_PARAM_SCALE_NODE;

	mov	DWORD PTR [eax], 10097			; 00002771H

; 5043 :        list->left = 0;
; 5044 :        list->stack_delta = 1;

	mov	DWORD PTR [eax+156], 1
	mov	DWORD PTR [eax+4], 0

; 5049 :    }
; 5050 :  
; 5051 : } // end convert_lvalue_to_rvalue()

	pop	ebp
	ret	0
_convert_lvalue_to_rvalue ENDP
_TEXT	ENDS
PUBLIC	_exparse
EXTRN	_stack_usage:PROC
EXTRN	_KB_realloc:PROC
EXTRN	_exit_local_scope:PROC
EXTRN	_end_local_scope:PROC
EXTRN	_yyparse:PROC
EXTRN	_begin_local_scope:PROC
EXTRN	_init_local_scope:PROC
EXTRN	_backquote_flag:DWORD
EXTRN	_const_expr_flag:DWORD
EXTRN	_unput_tok:PROC
EXTRN	_tok:DWORD
EXTRN	_parens:DWORD
EXTRN	_in_quote:DWORD
EXTRN	_parse_error_flag:DWORD
EXTRN	_kb_calloc:PROC
EXTRN	_inputbufferspot:DWORD
EXTRN	_brace_depth:DWORD
; Function compile flags: /Ogtp
;	COMDAT _exparse
_TEXT	SEGMENT
_old_brace_depth$ = -16					; size = 4
_old_listmax$ = -12					; size = 4
_old_listtop$ = -8					; size = 4
_old_list$ = -4						; size = 4
_maxparam$ = 8						; size = 4
_enode$ = 12						; size = 4
_flag$ = 16						; size = 4
_exparse PROC						; COMDAT

; 51   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 52   :   int retval;
; 53   :   struct treenode *old_list = list;  /* for nested parsing */

	mov	eax, DWORD PTR _list

; 54   :   int old_listtop = listtop;

	mov	ecx, DWORD PTR _listtop

; 55   :   int old_listmax = listmax;

	mov	edx, DWORD PTR _listmax
	push	ebx

; 56   :   int old_brace_depth = brace_depth;
; 57   :   int old_inputbufferspot =  inputbufferspot;
; 58   : 
; 59   :   PROF_START(exparse);
; 60   : 
; 61   :   if ( enode->start )  // take care of memory leak for addload

	mov	ebx, DWORD PTR _enode$[ebp]
	push	esi
	mov	DWORD PTR _old_list$[ebp], eax
	mov	eax, DWORD PTR _brace_depth
	xor	esi, esi
	push	edi
	mov	edi, DWORD PTR _inputbufferspot
	mov	DWORD PTR _old_listtop$[ebp], ecx
	mov	DWORD PTR _old_listmax$[ebp], edx
	mov	DWORD PTR _old_brace_depth$[ebp], eax
	cmp	DWORD PTR [ebx], esi
	je	SHORT $LN17@exparse

; 62   :      free_expr(enode);

	push	ebx
	call	_free_expr
	add	esp, 4
$LN17@exparse:

; 63   : 
; 64   :   listmax = LISTMAX;
; 65   :   if ( permlist == NULL )

	mov	eax, DWORD PTR _permlist
	mov	DWORD PTR _listmax, 200			; 000000c8H
	cmp	eax, esi
	jne	SHORT $LN20@exparse

; 66   :      permlist = 
; 67   :       (struct treenode *)mycalloc(listmax,sizeof(struct treenode));

	push	67					; 00000043H
	push	OFFSET ??_C@_0L@OKHAMMPH@YEXPARSE?4C?$AA@
	push	168					; 000000a8H
	push	200					; 000000c8H
	call	_kb_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _permlist, eax
$LN20@exparse:

; 68   :   maxp = (NTYPE)maxparam;
; 69   : 
; 70   :   if ( flag == USERCOPY )

	cmp	DWORD PTR _flag$[ebp], 1
	mov	ecx, DWORD PTR _maxparam$[ebp]
	mov	DWORD PTR _maxp, ecx
	jne	SHORT $LN15@exparse

; 71   :   { enode->start = list = 
; 72   :       (struct treenode *)mycalloc(listmax,sizeof(struct treenode));

	mov	edx, DWORD PTR _listmax
	push	72					; 00000048H
	push	OFFSET ??_C@_0L@OKHAMMPH@YEXPARSE?4C?$AA@
	push	168					; 000000a8H
	push	edx
	call	_kb_calloc
	add	esp, 16					; 00000010H
$LN15@exparse:

; 73   :   }
; 74   :   else enode->start = list = permlist;

	mov	DWORD PTR _list, eax
	mov	DWORD PTR [ebx], eax

; 75   : 
; 76   :   list[1].type = SETUP_FRAME_NODE;

	mov	eax, DWORD PTR _list
	mov	DWORD PTR [eax+168], 10001		; 00002711H

; 77   :   listtop = 2;

	mov	DWORD PTR _listtop, 2

; 78   :   parse_error_flag = 0;

	mov	DWORD PTR _parse_error_flag, esi

; 79   :   brace_depth = parens = in_quote = 0;

	mov	DWORD PTR _in_quote, esi
	mov	DWORD PTR _parens, esi
	mov	DWORD PTR _brace_depth, esi

; 80   :   /* unput expression start token for yacc */
; 81   :   tok = EXPRESSION_START_TOK; unput_tok();

	mov	DWORD PTR _tok, 258			; 00000102H
	call	_unput_tok

; 82   : 
; 83   :   using_param_flag = 0;

	mov	DWORD PTR _using_param_flag, esi

; 84   :   if ( !const_expr_flag || backquote_flag )

	cmp	DWORD PTR _const_expr_flag, esi
	je	SHORT $LN12@exparse
	cmp	DWORD PTR _backquote_flag, esi
	je	SHORT $LN13@exparse
$LN12@exparse:

; 85   :   { 
; 86   :     /*local_nest_depth = 0;*/
; 87   :     init_local_scope(0,0);

	push	esi
	push	esi
	call	_init_local_scope
	add	esp, 8

; 88   :     begin_local_scope();

	call	_begin_local_scope
$LN13@exparse:

; 89   :   }
; 90   :   PROF_FINISH(exparse);
; 91   :   PROF_START(yyparse); 
; 92   :   retval = yyparse();  /* 0 for accept, 1 for error */

	call	_yyparse

; 93   :   inputbufferspot = old_inputbufferspot;

	mov	DWORD PTR _inputbufferspot, edi

; 94   :   PROF_FINISH(yyparse);
; 95   :   PROF_START(exparse);
; 96   :   if ( !const_expr_flag || backquote_flag )

	xor	edi, edi
	mov	esi, eax
	cmp	DWORD PTR _const_expr_flag, edi
	je	SHORT $LN10@exparse
	cmp	DWORD PTR _backquote_flag, edi
	je	SHORT $LN11@exparse
$LN10@exparse:

; 97   :   { end_local_scope();

	call	_end_local_scope

; 98   :     enode->locals = localbase;

	mov	ecx, DWORD PTR _localbase
	mov	DWORD PTR [ebx+8], ecx

; 99   :     if ( localbase )

	mov	eax, DWORD PTR _localbase
	cmp	eax, edi
	je	SHORT $LN9@exparse

; 100  :       localbase->flags |= LL_IN_USE;

	or	DWORD PTR [eax+20], 4
$LN9@exparse:

; 101  :     exit_local_scope();

	call	_exit_local_scope
$LN11@exparse:

; 102  :   } 
; 103  : 
; 104  :   if ( (tok != 0) && (tok != ',') && (tok != LEXERROR) )

	mov	eax, DWORD PTR _tok
	cmp	eax, edi
	je	SHORT $LN8@exparse
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN8@exparse
	cmp	eax, 15004				; 00003a9cH
	je	SHORT $LN8@exparse

; 105  :   {
; 106  :     /* push back last token */
; 107  :     unput_tok();

	call	_unput_tok
$LN8@exparse:

; 108  :   }
; 109  : 
; 110  :   if ( (retval == 1) || parse_error_flag  || (listtop == 1) )

	mov	ecx, 1
	cmp	esi, ecx
	je	$LN6@exparse
	cmp	DWORD PTR _parse_error_flag, edi
	jne	$LN6@exparse
	mov	eax, DWORD PTR _listtop
	cmp	eax, ecx
	je	$LN6@exparse

; 118  :     goto exparse_exit;
; 119  :   }
; 120  : 
; 121  :   /* free excess list */
; 122  :   if ( flag == USERCOPY )

	cmp	DWORD PTR _flag$[ebp], ecx
	jne	SHORT $LN2@exparse

; 123  :     enode->start = list = (struct treenode *)kb_realloc((char *)list,
; 124  :      (listtop+2)*sizeof(struct treenode));

	mov	edx, DWORD PTR _list
	add	eax, 2
	imul	eax, 168				; 000000a8H
	push	124					; 0000007cH
	push	OFFSET ??_C@_0L@OKHAMMPH@YEXPARSE?4C?$AA@
	push	eax
	push	edx
	call	_KB_realloc
	mov	DWORD PTR _list, eax
	mov	DWORD PTR [ebx], eax
	mov	eax, DWORD PTR _listtop
	add	esp, 16					; 00000010H
$LN2@exparse:

; 125  :   
; 126  :   enode->root = list + listtop - 1;

	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	lea	edx, DWORD PTR [eax+ecx-168]
	mov	DWORD PTR [ebx+4], edx

; 127  :   list[0] = list[listtop-1];  /* root also in first spot */

	mov	eax, DWORD PTR _listtop
	mov	edi, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	lea	esi, DWORD PTR [eax+edi-168]
	mov	ecx, 42					; 0000002aH
	rep movsd

; 128  :   list[0].left += listtop - 1;

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	dec	ecx
	add	DWORD PTR [eax+4], ecx

; 129  :   list[0].right += listtop - 1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	dec	edx
	add	DWORD PTR [eax+8], edx

; 130  : 
; 131  :   /* put DONE marker after root */
; 132  :   list[listtop++].type = FINISHED_NODE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10386		; 00002892H
	inc	DWORD PTR _listtop

; 133  : 
; 134  :   /* figure stack usage */
; 135  :   stack_usage(enode);

	push	ebx
	call	_stack_usage

; 136  : 
; 137  :   enode->flag = flag;

	mov	eax, DWORD PTR _flag$[ebp]
	add	esp, 4
	mov	DWORD PTR [ebx+12], eax

; 138  :   if ( using_param_flag ) 

	cmp	DWORD PTR _using_param_flag, 0
	je	SHORT $LN1@exparse

; 139  :     enode->flag |= USING_PARAM_FLAG;

	or	eax, 512				; 00000200H
	mov	DWORD PTR [ebx+12], eax
$LN1@exparse:

; 140  : 
; 141  :   retval = listtop*sizeof(struct treenode);
; 142  : 
; 143  :   list = old_list;                /* for nested parsing */

	mov	edx, DWORD PTR _old_list$[ebp]

; 144  :   listtop = old_listtop;

	mov	ecx, DWORD PTR _old_listtop$[ebp]
	mov	eax, DWORD PTR _listtop
	pop	edi
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR _list, edx

; 145  :   listmax = old_listmax;

	mov	edx, DWORD PTR _old_listmax$[ebp]
	mov	DWORD PTR _listtop, ecx

; 146  :   brace_depth = old_brace_depth;

	mov	ecx, DWORD PTR _old_brace_depth$[ebp]
	pop	esi
	mov	DWORD PTR _listmax, edx
	mov	DWORD PTR _brace_depth, ecx
	pop	ebx

; 147  : 
; 148  : exparse_exit:
; 149  :   PROF_FINISH(exparse);
; 150  :   return retval;
; 151  : 
; 152  : } // end exparse()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@exparse:

; 111  :   { if ( flag == USERCOPY ) 

	cmp	DWORD PTR _flag$[ebp], ecx
	jne	SHORT $LN3@exparse

; 112  :     { myfree((char *)enode->start); 

	mov	edx, DWORD PTR [ebx]
	push	edx
	call	_myfree

; 113  :       if ( enode->start == list ) list = NULL;

	mov	eax, DWORD PTR [ebx]
	add	esp, 4
	cmp	eax, DWORD PTR _list
	jne	SHORT $LN4@exparse
	mov	DWORD PTR _list, edi
$LN4@exparse:

; 114  :       if ( enode->start == permlist ) permlist = NULL;

	mov	ecx, DWORD PTR [ebx]
	cmp	ecx, DWORD PTR _permlist
	jne	SHORT $LN3@exparse
	mov	DWORD PTR _permlist, edi
$LN3@exparse:

; 115  :     }
; 116  :     enode->start = NULL;

	mov	DWORD PTR [ebx], edi
	pop	edi
	pop	esi

; 117  :     retval = -1; 

	or	eax, -1
$exparse_exit$89406:
	pop	ebx

; 147  : 
; 148  : exparse_exit:
; 149  :   PROF_FINISH(exparse);
; 150  :   return retval;
; 151  : 
; 152  : } // end exparse()

	mov	esp, ebp
	pop	ebp
	ret	0
_exparse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FO@GLOCEABG@?$CC?$CFs?$CC?5is?5an?5indexed?5attribute?$DL?5in@ ; `string'
PUBLIC	??_C@_0CE@MNJJPJOP@Attribute?5?$CFs?5must?5have?5?$CFd?5indice@ ; `string'
PUBLIC	??_C@_0CN@KKOGLFKO@Internal?5error?3?5Unknown?5MAKENODE@ ; `string'
PUBLIC	??_C@_0DD@CMMHBHLH@Cannot?5use?5arithmetic?5assign?5wit@ ; `string'
PUBLIC	??_C@_0DA@DHKJDMLH@Cannot?5assign?5value?5to?5this?5attr@ ; `string'
PUBLIC	??_C@_0CN@BJGPMAKA@Noncontent?5only?5applies?5to?5edges@ ; `string'
PUBLIC	??_C@_0DE@NGJNLEL@No_transform?5does?5not?5apply?5to?5v@ ; `string'
PUBLIC	??_C@_0CD@ELNKFOCH@Hit_partner?5is?5only?5for?5vertices@ ; `string'
PUBLIC	??_C@_0CK@IOPEEGI@Use?5?8set?5body?5target?5?4?4?4?8?5to?5fix@ ; `string'
PUBLIC	??_C@_0BO@FCBOEPPP@No?5fixedness?5for?5facetedges?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@KPLMFDOD@Pressure?5only?5for?5bodies?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CO@IKCMNGON@Volume?5is?5read?9only?4?5Setting?5TAR@ ; `string'
PUBLIC	??_C@_0CA@DDNLCDCD@Target?5volume?5only?5for?5bodies?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@IEJCGHPF@Frontbody?5or?5backbody?5only?5for?5f@ ; `string'
PUBLIC	??_C@_0EB@BHLIPGAE@Frontbody?5or?5backbody?5only?5for?5f@ ; `string'
PUBLIC	??_C@_0CG@PJFEHFFP@Front?5or?5back?5color?5only?5for?5fac@ ; `string'
PUBLIC	??_C@_0BK@NEICOOEL@Opacity?5only?5for?5facets?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@JEPJACJN@Boundary?5parameters?5only?5for?5ver@ ; `string'
PUBLIC	??_C@_0CA@HENHFIIN@Coordinates?5only?5for?5vertices?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CP@EEKPMBAG@Coordinate?5dimension?5exceeds?5spa@ ; `string'
PUBLIC	??_C@_0CA@ELLFACCD@Attribute?5?8?$CFs?8?5has?5?$CFd?5indexes?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@IFBIOELO@Must?5use?5index?5with?5attribute?5?8?$CF@ ; `string'
PUBLIC	??_C@_0CH@NMIDINCN@Cannot?5use?5index?5with?5attribute?5@ ; `string'
PUBLIC	??_C@_0CE@CIKANACF@Invalid?5extra?5attribute?5name?5?8?$CFs@ ; `string'
PUBLIC	??_C@_0BL@LFPPAIJK@Attribute?5is?5not?5indexed?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CP@EADLGAJE@Don?8t?5have?5element?5for?5attribute@ ; `string'
PUBLIC	??_C@_0CM@IJMBNBLJ@Attribute?5?$CFs?5must?5have?5at?5most?5?$CF@ ; `string'
PUBLIC	??_C@_0FA@KPBJMLGF@?8?$CFs?8?5attached?5to?5too?5many?5quanti@ ; `string'
PUBLIC	??_C@_0CH@IBIBGHBN@Vertexnormal?5can?5have?5only?5one?5i@ ; `string'
PUBLIC	??_C@_0CF@PPIHGAA@Coordinate?5can?5have?5only?5one?5ind@ ; `string'
PUBLIC	??_C@_0CA@HCCILBNN@Illegal?5attribute?5of?5variable?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@HFNHMOA@Invalid?5user?5function?5number?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0CA@IOKNLDFI@Coordinate?5number?5too?5high?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@MONDKFGG@Constant?5expression?5required?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@HHFGMLDC@Exponent?51?4?5?5Did?5you?5mean?5this?$DP?6@ ; `string'
PUBLIC	??_C@_0CB@PGHDKOBF@Exponent?50?4?5?5Did?5you?5mean?5this?$DP?6@ ; `string'
PUBLIC	??_C@_0BO@DCHCJGFO@Constant?5folding?5not?5working?4?$AA@ ; `string'
PUBLIC	??_C@_0BK@PJJFIHAA@sqrt?5of?5negative?5number?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@IJAOBLOA@acos?5argument?5out?5of?5bounds?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@JJEBJFHA@asin?5argument?5out?5of?5bounds?4?6?$AA@ ; `string'
PUBLIC	__real@4000000000000000
PUBLIC	??_C@_0CC@EHDJDLDK@acosh?5argument?5is?5less?5than?51?40?4@ ; `string'
PUBLIC	__real@3fe0000000000000
PUBLIC	??_C@_0BJ@LEEEDPAJ@log?5of?5negative?5number?4?6?$AA@ ; `string'
PUBLIC	__real@4005bf0a8b145769
PUBLIC	__real@400921fb54442d18
PUBLIC	??_C@_0BA@HPOADLHK@Divide?5by?5zero?4?$AA@	; `string'
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	??_C@_0CO@GPMAMBBE@Internal?5error?3?5Constant?5folding@ ; `string'
PUBLIC	_more_makenode
EXTRN	_tokname:PROC
EXTRN	_assigntype:DWORD
EXTRN	_kb_stricmp:PROC
EXTRN	_set_extra_name:BYTE
EXTRN	_attr_kind:DWORD
EXTRN	_elsym:DWORD
EXTRN	_read_method_instance:PROC
EXTRN	_read_quantity:PROC
EXTRN	_read_boundary:PROC
EXTRN	_kb_unput:PROC
EXTRN	_read_constraint:PROC
EXTRN	_datafile_flag:DWORD
EXTRN	_verb_flag:DWORD
EXTRN	_yytext:DWORD
EXTRN	_attach_method_num:PROC
EXTRN	_cur_quant:DWORD
EXTRN	_basic_gen_methods:BYTE
EXTRN	_gen_quant_list:DWORD
EXTRN	_meth_inst_list:DWORD
EXTRN	_reading_comp_quant_flag:DWORD
EXTRN	_userfunc:BYTE
EXTRN	_int_val:DWORD
EXTRN	_coord_num:DWORD
EXTRN	_incompleteEllipticF:PROC
EXTRN	_incompleteEllipticE:PROC
EXTRN	_ceil:PROC
EXTRN	_ellipticE:PROC
EXTRN	_ellipticK:PROC
EXTRN	_real_val:QWORD
EXTRN	__fltused:DWORD
EXTRN	__CIpow:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__CIatan2:PROC
EXTRN	__CIatan:PROC
EXTRN	__CItan:PROC
EXTRN	__CIacos:PROC
EXTRN	__CIcos:PROC
EXTRN	__CIasin:PROC
EXTRN	__CIsqrt:PROC
EXTRN	__CIsin:PROC
EXTRN	__CIlog:PROC
EXTRN	__CIexp:PROC
EXTRN	_floor:PROC
;	COMDAT ??_C@_0FO@GLOCEABG@?$CC?$CFs?$CC?5is?5an?5indexed?5attribute?$DL?5in@
CONST	SEGMENT
??_C@_0FO@GLOCEABG@?$CC?$CFs?$CC?5is?5an?5indexed?5attribute?$DL?5in@ DB '"'
	DB	'%s" is an indexed attribute; index is missing.  Or use elemen'
	DB	't name to print as full array.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MNJJPJOP@Attribute?5?$CFs?5must?5have?5?$CFd?5indice@
CONST	SEGMENT
??_C@_0CE@MNJJPJOP@Attribute?5?$CFs?5must?5have?5?$CFd?5indice@ DB 'Attri'
	DB	'bute %s must have %d indices.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KKOGLFKO@Internal?5error?3?5Unknown?5MAKENODE@
CONST	SEGMENT
??_C@_0CN@KKOGLFKO@Internal?5error?3?5Unknown?5MAKENODE@ DB 'Internal err'
	DB	'or: Unknown MAKENODE %d type %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@CMMHBHLH@Cannot?5use?5arithmetic?5assign?5wit@
CONST	SEGMENT
??_C@_0DD@CMMHBHLH@Cannot?5use?5arithmetic?5assign?5wit@ DB 'Cannot use a'
	DB	'rithmetic assign with this attribute.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DHKJDMLH@Cannot?5assign?5value?5to?5this?5attr@
CONST	SEGMENT
??_C@_0DA@DHKJDMLH@Cannot?5assign?5value?5to?5this?5attr@ DB 'Cannot assi'
	DB	'gn value to this attribute with :=.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BJGPMAKA@Noncontent?5only?5applies?5to?5edges@
CONST	SEGMENT
??_C@_0CN@BJGPMAKA@Noncontent?5only?5applies?5to?5edges@ DB 'Noncontent o'
	DB	'nly applies to edges or facets.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NGJNLEL@No_transform?5does?5not?5apply?5to?5v@
CONST	SEGMENT
??_C@_0DE@NGJNLEL@No_transform?5does?5not?5apply?5to?5v@ DB 'No_transform'
	DB	' does not apply to vertices or bodies.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@ELNKFOCH@Hit_partner?5is?5only?5for?5vertices@
CONST	SEGMENT
??_C@_0CD@ELNKFOCH@Hit_partner?5is?5only?5for?5vertices@ DB 'Hit_partner '
	DB	'is only for vertices.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IOPEEGI@Use?5?8set?5body?5target?5?4?4?4?8?5to?5fix@
CONST	SEGMENT
??_C@_0CK@IOPEEGI@Use?5?8set?5body?5target?5?4?4?4?8?5to?5fix@ DB 'Use '''
	DB	'set body target ...'' to fix volume.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FCBOEPPP@No?5fixedness?5for?5facetedges?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@FCBOEPPP@No?5fixedness?5for?5facetedges?4?6?$AA@ DB 'No fixedne'
	DB	'ss for facetedges.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KPLMFDOD@Pressure?5only?5for?5bodies?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@KPLMFDOD@Pressure?5only?5for?5bodies?4?6?$AA@ DB 'Pressure only'
	DB	' for bodies.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IKCMNGON@Volume?5is?5read?9only?4?5Setting?5TAR@
CONST	SEGMENT
??_C@_0CO@IKCMNGON@Volume?5is?5read?9only?4?5Setting?5TAR@ DB 'Volume is '
	DB	'read-only. Setting TARGET instead.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DDNLCDCD@Target?5volume?5only?5for?5bodies?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@DDNLCDCD@Target?5volume?5only?5for?5bodies?4?6?$AA@ DB 'Target '
	DB	'volume only for bodies.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@IEJCGHPF@Frontbody?5or?5backbody?5only?5for?5f@
CONST	SEGMENT
??_C@_0CI@IEJCGHPF@Frontbody?5or?5backbody?5only?5for?5f@ DB 'Frontbody o'
	DB	'r backbody only for facets.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@BHLIPGAE@Frontbody?5or?5backbody?5only?5for?5f@
CONST	SEGMENT
??_C@_0EB@BHLIPGAE@Frontbody?5or?5backbody?5only?5for?5f@ DB 'Frontbody o'
	DB	'r backbody only for facets or edges in string model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PJFEHFFP@Front?5or?5back?5color?5only?5for?5fac@
CONST	SEGMENT
??_C@_0CG@PJFEHFFP@Front?5or?5back?5color?5only?5for?5fac@ DB 'Front or b'
	DB	'ack color only for facets.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NEICOOEL@Opacity?5only?5for?5facets?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@NEICOOEL@Opacity?5only?5for?5facets?4?6?$AA@ DB 'Opacity only f'
	DB	'or facets.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JEPJACJN@Boundary?5parameters?5only?5for?5ver@
CONST	SEGMENT
??_C@_0CI@JEPJACJN@Boundary?5parameters?5only?5for?5ver@ DB 'Boundary par'
	DB	'ameters only for vertices.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HENHFIIN@Coordinates?5only?5for?5vertices?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@HENHFIIN@Coordinates?5only?5for?5vertices?4?6?$AA@ DB 'Coordina'
	DB	'tes only for vertices.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@EEKPMBAG@Coordinate?5dimension?5exceeds?5spa@
CONST	SEGMENT
??_C@_0CP@EEKPMBAG@Coordinate?5dimension?5exceeds?5spa@ DB 'Coordinate di'
	DB	'mension exceeds space dimension.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@ELLFACCD@Attribute?5?8?$CFs?8?5has?5?$CFd?5indexes?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@ELLFACCD@Attribute?5?8?$CFs?8?5has?5?$CFd?5indexes?4?6?$AA@ DB 'A'
	DB	'ttribute ''%s'' has %d indexes.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IFBIOELO@Must?5use?5index?5with?5attribute?5?8?$CF@
CONST	SEGMENT
??_C@_0CF@IFBIOELO@Must?5use?5index?5with?5attribute?5?8?$CF@ DB 'Must us'
	DB	'e index with attribute ''%s''.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NMIDINCN@Cannot?5use?5index?5with?5attribute?5@
CONST	SEGMENT
??_C@_0CH@NMIDINCN@Cannot?5use?5index?5with?5attribute?5@ DB 'Cannot use '
	DB	'index with attribute ''%s''.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CIKANACF@Invalid?5extra?5attribute?5name?5?8?$CFs@
CONST	SEGMENT
??_C@_0CE@CIKANACF@Invalid?5extra?5attribute?5name?5?8?$CFs@ DB 'Invalid '
	DB	'extra attribute name ''%s''.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LFPPAIJK@Attribute?5is?5not?5indexed?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@LFPPAIJK@Attribute?5is?5not?5indexed?4?6?$AA@ DB 'Attribute is '
	DB	'not indexed.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@EADLGAJE@Don?8t?5have?5element?5for?5attribute@
CONST	SEGMENT
??_C@_0CP@EADLGAJE@Don?8t?5have?5element?5for?5attribute@ DB 'Don''t have'
	DB	' element for attribute to apply to.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IJMBNBLJ@Attribute?5?$CFs?5must?5have?5at?5most?5?$CF@
CONST	SEGMENT
??_C@_0CM@IJMBNBLJ@Attribute?5?$CFs?5must?5have?5at?5most?5?$CF@ DB 'Attr'
	DB	'ibute %s must have at most %d indices.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@KPBJMLGF@?8?$CFs?8?5attached?5to?5too?5many?5quanti@
CONST	SEGMENT
??_C@_0FA@KPBJMLGF@?8?$CFs?8?5attached?5to?5too?5many?5quanti@ DB '''%s'''
	DB	' attached to too many quantities. This version of Evolver per'
	DB	'mits only %d.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@IBIBGHBN@Vertexnormal?5can?5have?5only?5one?5i@
CONST	SEGMENT
??_C@_0CH@IBIBGHBN@Vertexnormal?5can?5have?5only?5one?5i@ DB 'Vertexnorma'
	DB	'l can have only one index.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PPIHGAA@Coordinate?5can?5have?5only?5one?5ind@
CONST	SEGMENT
??_C@_0CF@PPIHGAA@Coordinate?5can?5have?5only?5one?5ind@ DB 'Coordinate c'
	DB	'an have only one index.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HCCILBNN@Illegal?5attribute?5of?5variable?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@HCCILBNN@Illegal?5attribute?5of?5variable?4?6?$AA@ DB 'Illegal '
	DB	'attribute of variable.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@HFNHMOA@Invalid?5user?5function?5number?3?5?$CFd@
CONST	SEGMENT
??_C@_0CC@HFNHMOA@Invalid?5user?5function?5number?3?5?$CFd@ DB 'Invalid u'
	DB	'ser function number: %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IOKNLDFI@Coordinate?5number?5too?5high?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0CA@IOKNLDFI@Coordinate?5number?5too?5high?3?5?$CFd?6?$AA@ DB 'Coor'
	DB	'dinate number too high: %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MONDKFGG@Constant?5expression?5required?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@MONDKFGG@Constant?5expression?5required?4?6?$AA@ DB 'Constant e'
	DB	'xpression required.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HHFGMLDC@Exponent?51?4?5?5Did?5you?5mean?5this?$DP?6@
CONST	SEGMENT
??_C@_0CB@HHFGMLDC@Exponent?51?4?5?5Did?5you?5mean?5this?$DP?6@ DB 'Expon'
	DB	'ent 1.  Did you mean this?', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PGHDKOBF@Exponent?50?4?5?5Did?5you?5mean?5this?$DP?6@
CONST	SEGMENT
??_C@_0CB@PGHDKOBF@Exponent?50?4?5?5Did?5you?5mean?5this?$DP?6@ DB 'Expon'
	DB	'ent 0.  Did you mean this?', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DCHCJGFO@Constant?5folding?5not?5working?4?$AA@
CONST	SEGMENT
??_C@_0BO@DCHCJGFO@Constant?5folding?5not?5working?4?$AA@ DB 'Constant fo'
	DB	'lding not working.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PJJFIHAA@sqrt?5of?5negative?5number?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@PJJFIHAA@sqrt?5of?5negative?5number?4?6?$AA@ DB 'sqrt of negati'
	DB	've number.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IJAOBLOA@acos?5argument?5out?5of?5bounds?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@IJAOBLOA@acos?5argument?5out?5of?5bounds?4?6?$AA@ DB 'acos argu'
	DB	'ment out of bounds.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JJEBJFHA@asin?5argument?5out?5of?5bounds?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@JJEBJFHA@asin?5argument?5out?5of?5bounds?4?6?$AA@ DB 'asin argu'
	DB	'ment out of bounds.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT ??_C@_0CC@EHDJDLDK@acosh?5argument?5is?5less?5than?51?40?4@
CONST	SEGMENT
??_C@_0CC@EHDJDLDK@acosh?5argument?5is?5less?5than?51?40?4@ DB 'acosh arg'
	DB	'ument is less than 1.0.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT ??_C@_0BJ@LEEEDPAJ@log?5of?5negative?5number?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@LEEEDPAJ@log?5of?5negative?5number?4?6?$AA@ DB 'log of negative'
	DB	' number.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@4005bf0a8b145769
CONST	SEGMENT
__real@4005bf0a8b145769 DQ 04005bf0a8b145769r	; 2.71828
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT ??_C@_0BA@HPOADLHK@Divide?5by?5zero?4?$AA@
CONST	SEGMENT
??_C@_0BA@HPOADLHK@Divide?5by?5zero?4?$AA@ DB 'Divide by zero.', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0CO@GPMAMBBE@Internal?5error?3?5Constant?5folding@
CONST	SEGMENT
??_C@_0CO@GPMAMBBE@Internal?5error?3?5Constant?5folding@ DB 'Internal err'
	DB	'or: Constant folding not working.', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _more_makenode
_TEXT	SEGMENT
tv4310 = -16						; size = 8
tv3644 = -16						; size = 8
tv1775 = -16						; size = 8
tv511 = -16						; size = 8
_p$90593 = -16						; size = 8
_x$90532 = -16						; size = 8
tv4309 = -8						; size = 8
tv4110 = -8						; size = 8
_x$90535 = -8						; size = 8
_x$90529 = -8						; size = 8
tv4509 = -4						; size = 4
tv5225 = 8						; size = 4
tv3651 = 8						; size = 4
_top$90908 = 8						; size = 4
_exnum$90771 = 8					; size = 4
_n$ = 8							; size = 4
_type$ = 8						; size = 4
_left$ = 12						; size = 4
_right$ = 16						; size = 4
_more_makenode PROC					; COMDAT

; 3059 : { int n,etype;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 3060 : 
; 3061 :   switch (type)

	mov	esi, DWORD PTR _type$[ebp]
	push	edi
	cmp	esi, 10009				; 00002719H
	jg	$LN384@more_maken
	je	$LN329@more_maken
	lea	eax, DWORD PTR [esi-37]
	cmp	eax, 57					; 00000039H
	ja	$LN1@more_maken
	movzx	eax, BYTE PTR $LN405@more_maken[eax]
	jmp	DWORD PTR $LN491@more_maken[eax*4]
$LN206@more_maken:

; 3807 : 
; 3808 :     case '+':
; 3809 :         if ( is_constant(right) && is_constant(left) )

	mov	esi, DWORD PTR _right$[ebp]
	push	esi
	call	_is_constant
	mov	edi, DWORD PTR _left$[ebp]
	add	esp, 4
	test	eax, eax
	je	$LN205@more_maken
	push	edi
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	$LN205@more_maken

; 3810 :         { /* fold constants */
; 3811 :           
; 3812 :           listtop -= 2;

	mov	eax, DWORD PTR _listtop
	sub	eax, 2
	mov	DWORD PTR _listtop, eax

; 3813 :           if ( (left != listtop) || (right != listtop+1) )

	cmp	edi, eax
	jne	SHORT $LN203@more_maken
	lea	ecx, DWORD PTR [eax+1]
	cmp	esi, ecx
	je	SHORT $LN204@more_maken
$LN203@more_maken:

; 3814 :              kb_error(1436,"Internal error: Constant folding not working.",
; 3815 :                  COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CO@GPMAMBBE@Internal?5error?3?5Constant?5folding@
	push	1436					; 0000059cH
	call	_kb_error
	mov	eax, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN204@more_maken:

; 3816 :           list[listtop].op1.real = list[left].op1.real + list[right].op1.real;

	mov	ecx, DWORD PTR _list
	imul	edi, 168				; 000000a8H
	imul	esi, 168				; 000000a8H
	fld	QWORD PTR [edi+ecx+32]
	fadd	QWORD PTR [esi+ecx+32]
	imul	eax, 168				; 000000a8H
	fstp	QWORD PTR [eax+ecx+32]

; 3817 :           list[listtop].type = PUSHCONST_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10095		; 0000276fH

; 3818 :           list[listtop].stack_delta = 1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], 1
	jmp	$LN198@more_maken
$LN205@more_maken:

; 3819 :         }
; 3820 :         else if ( is_constant(right) && (list[right].op1.real==0.0) )

	push	esi
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	SHORT $LN201@more_maken
	mov	ecx, DWORD PTR _list
	mov	eax, esi
	imul	eax, 168				; 000000a8H
	fld	QWORD PTR [eax+ecx+32]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H

; 3821 :           listtop -= 2; /* just leave left summand */

	jnp	SHORT $LN453@more_maken
$LN201@more_maken:

; 3822 :         else if ( is_constant(left) && (list[left].op1.real==0.0) )

	push	edi
	call	_is_constant
	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	je	SHORT $LN199@more_maken
	mov	edx, edi
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+ecx+32]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN199@more_maken
$LN480@more_maken:

; 3823 :         { subtree_swap(&left,&right);

	lea	eax, DWORD PTR _right$[ebp]
	push	eax
	lea	ecx, DWORD PTR _left$[ebp]
	push	ecx
	call	_subtree_swap
	add	esp, 8
$LN453@more_maken:

; 3824 :           listtop -= 2;

	sub	DWORD PTR _listtop, 2

; 3825 :         }
; 3826 :         else

	jmp	$LN198@more_maken
$LN199@more_maken:

; 3827 :         {
; 3828 :           list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], esi

; 3829 :           list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], edi

; 3830 :           list[listtop].type = PLUS_NODE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10122		; 0000278aH
$LN481@more_maken:

; 3831 :           list[listtop].stack_delta = -1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], -1

; 3832 :         }
; 3833 :         list[listtop].datatype = REAL_TYPE;
; 3834 :         break;

	jmp	$LN198@more_maken
$LN197@more_maken:

; 3835 : 
; 3836 :     case '-':
; 3837 :         if ( is_constant(right) && is_constant(left) )

	mov	esi, DWORD PTR _right$[ebp]
	push	esi
	call	_is_constant
	mov	edi, DWORD PTR _left$[ebp]
	add	esp, 4
	test	eax, eax
	je	$LN196@more_maken
	push	edi
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	$LN196@more_maken

; 3838 :         { /* fold constants */
; 3839 :           
; 3840 :           listtop -= 2;

	mov	eax, DWORD PTR _listtop
	sub	eax, 2
	mov	DWORD PTR _listtop, eax

; 3841 :           if ( (left != listtop) || (right != listtop+1) )

	cmp	edi, eax
	jne	SHORT $LN194@more_maken
	lea	edx, DWORD PTR [eax+1]
	cmp	esi, edx
	je	SHORT $LN195@more_maken
$LN194@more_maken:

; 3842 :              kb_error(1437,"Internal error: Constant folding not working.",
; 3843 :                 COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CO@GPMAMBBE@Internal?5error?3?5Constant?5folding@
	push	1437					; 0000059dH
$LN482@more_maken:
	call	_kb_error
	mov	eax, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN195@more_maken:

; 3844 :           list[listtop].op1.real = list[left].op1.real - list[right].op1.real;

	mov	ecx, DWORD PTR _list
	imul	edi, 168				; 000000a8H
	imul	esi, 168				; 000000a8H
	fld	QWORD PTR [edi+ecx+32]
	fsub	QWORD PTR [esi+ecx+32]
$LN483@more_maken:
	imul	eax, 168				; 000000a8H
	fstp	QWORD PTR [eax+ecx+32]

; 3845 :           list[listtop].type = PUSHCONST_NODE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH

; 3846 :           list[listtop].stack_delta = 1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], 1
	jmp	$LN198@more_maken
$LN196@more_maken:

; 3847 :         }
; 3848 :         else if ( is_constant(right) && (list[right].op1.real==0.0) )

	push	esi
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	SHORT $LN192@more_maken
	mov	edx, DWORD PTR _list
	mov	ecx, esi
	imul	ecx, 168				; 000000a8H
	fld	QWORD PTR [ecx+edx+32]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H

; 3849 :           listtop -= 2; /* just leave left summand */

	jnp	$LN453@more_maken
$LN192@more_maken:

; 3850 :         else if ( is_constant(left) && (list[left].op1.real==0.0) )

	push	edi
	call	_is_constant
	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	je	$LN190@more_maken
	mov	eax, edi
	imul	eax, 168				; 000000a8H
	fld	QWORD PTR [eax+ecx+32]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN190@more_maken

; 3851 :         { subtree_swap(&left,&right);

	lea	ecx, DWORD PTR _right$[ebp]
	push	ecx
	lea	edx, DWORD PTR _left$[ebp]
	push	edx
	call	_subtree_swap

; 3852 :           listtop -= 1;

	mov	eax, DWORD PTR _listtop

; 3853 :           list[listtop].left = right - listtop;

	mov	ecx, DWORD PTR _right$[ebp]
	mov	edx, DWORD PTR _list
	dec	eax
	mov	DWORD PTR _listtop, eax
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx

; 3854 :           list[listtop].type = CHS_NODE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10160		; 000027b0H

; 3855 :           list[listtop].stack_delta = 0;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	add	esp, 8
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], 0

; 3856 :         }
; 3857 :         else

	jmp	$LN198@more_maken
$LN190@more_maken:

; 3858 :         {
; 3859 :           list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], esi

; 3860 :           list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edi

; 3861 :           list[listtop].type = MINUS_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10123		; 0000278bH

; 3862 :           list[listtop].stack_delta = -1;
; 3863 :         }
; 3864 :         list[listtop].datatype = REAL_TYPE;
; 3865 :         break;

	jmp	$LN475@more_maken
$LN188@more_maken:

; 3866 : 
; 3867 :     case '=':  /* equality as low priority minus */
; 3868 :         if ( is_constant(right) && is_constant(left) )

	mov	esi, DWORD PTR _right$[ebp]
	push	esi
	call	_is_constant
	mov	edi, DWORD PTR _left$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN187@more_maken
	push	edi
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	SHORT $LN187@more_maken

; 3869 :         { /* fold constants */
; 3870 :           
; 3871 :           listtop -= 2;

	mov	eax, DWORD PTR _listtop
	sub	eax, 2
	mov	DWORD PTR _listtop, eax

; 3872 :           if ( (left != listtop) || (right != listtop+1) )

	cmp	edi, eax
	jne	SHORT $LN185@more_maken
	lea	edx, DWORD PTR [eax+1]
	cmp	esi, edx
	je	$LN195@more_maken
$LN185@more_maken:

; 3873 :              kb_error(1438,"Internal error: Constant folding not working.",
; 3874 :                 COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CO@GPMAMBBE@Internal?5error?3?5Constant?5folding@
	push	1438					; 0000059eH

; 3875 :           list[listtop].op1.real = list[left].op1.real - list[right].op1.real;
; 3876 :           list[listtop].type = PUSHCONST_NODE;
; 3877 :           list[listtop].stack_delta = 1;

	jmp	$LN482@more_maken
$LN187@more_maken:

; 3878 :         }
; 3879 :         else if ( is_constant(right) && (list[right].op1.real==0.0) )

	push	esi
	call	_is_constant
	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	je	SHORT $LN183@more_maken
	mov	edx, esi
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+ecx+32]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H

; 3880 :           listtop -= 2; /* just leave left summand */
; 3881 :         else

	jnp	$LN453@more_maken
$LN183@more_maken:

; 3882 :         {
; 3883 :           list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], esi

; 3884 :           list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edi

; 3885 :           list[listtop].type = EQUATE_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10124		; 0000278cH

; 3886 :           list[listtop].stack_delta = -1;
; 3887 :         }
; 3888 :         list[listtop].datatype = REAL_TYPE;
; 3889 :         break;

	jmp	$LN475@more_maken
$LN181@more_maken:

; 3890 : 
; 3891 :     case '*':
; 3892 :         if ( is_constant(right) && is_constant(left) )

	mov	edi, DWORD PTR _right$[ebp]
	push	edi
	call	_is_constant
	mov	esi, DWORD PTR _left$[ebp]
	add	esp, 4
	test	eax, eax
	je	SHORT $LN180@more_maken
	push	esi
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	SHORT $LN180@more_maken

; 3893 :         { /* fold constants */
; 3894 :           
; 3895 :           listtop -= 2;

	mov	eax, DWORD PTR _listtop
	sub	eax, 2
	mov	DWORD PTR _listtop, eax

; 3896 :           if ( (left != listtop) || (right != listtop+1) )

	cmp	esi, eax
	jne	SHORT $LN178@more_maken
	lea	edx, DWORD PTR [eax+1]
	cmp	edi, edx
	je	SHORT $LN179@more_maken
$LN178@more_maken:

; 3897 :              kb_error(1439,"Internal error: Constant folding not working.",
; 3898 :                COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CO@GPMAMBBE@Internal?5error?3?5Constant?5folding@
	push	1439					; 0000059fH
	call	_kb_error
	mov	eax, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN179@more_maken:

; 3899 :           list[listtop].op1.real = list[left].op1.real * list[right].op1.real;

	mov	ecx, DWORD PTR _list
	imul	esi, 168				; 000000a8H
	imul	edi, 168				; 000000a8H
	fld	QWORD PTR [esi+ecx+32]
	fmul	QWORD PTR [edi+ecx+32]

; 3900 :           list[listtop].type = PUSHCONST_NODE;
; 3901 :           list[listtop].stack_delta = 1;

	jmp	$LN483@more_maken
$LN180@more_maken:

; 3902 :         }
; 3903 :         else if ( is_constant(left) && (list[left].op1.real==0.0) )

	push	esi
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	SHORT $LN176@more_maken
	mov	edx, DWORD PTR _list
	mov	ecx, esi
	imul	ecx, 168				; 000000a8H
	fld	QWORD PTR [ecx+edx+32]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN176@more_maken

; 3904 :          { 
; 3905 :            listtop = left; /* just leave 0 */

	mov	DWORD PTR _listtop, esi
	jmp	$LN198@more_maken
$LN176@more_maken:

; 3906 :          }
; 3907 :         else if ( ( is_constant(right) && (list[right].op1.real==0.0) ) )

	push	edi
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	SHORT $LN174@more_maken
	mov	ecx, DWORD PTR _list
	mov	eax, edi
	imul	eax, 168				; 000000a8H
	fld	QWORD PTR [eax+ecx+32]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN174@more_maken

; 3908 :          { subtree_swap(&left,&right);

	lea	edx, DWORD PTR _right$[ebp]
	push	edx
	lea	eax, DWORD PTR _left$[ebp]
	push	eax
	call	_subtree_swap

; 3909 :            listtop = right; /* just leave 0 */

	mov	ecx, DWORD PTR _right$[ebp]
	add	esp, 8
	mov	DWORD PTR _listtop, ecx
	jmp	$LN198@more_maken
$LN174@more_maken:

; 3910 :          }
; 3911 :         else if ( is_constant(right) && (list[right].op1.real==1.0) )

	push	edi
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	SHORT $LN172@more_maken
	mov	eax, DWORD PTR _list
	mov	edx, edi
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+eax+32]
	fld1
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H

; 3912 :            listtop -= 2; /* just leave left multiplicand */

	jnp	$LN453@more_maken
$LN172@more_maken:

; 3913 :         else if ( is_constant(left) && (list[left].op1.real==1.0) )

	push	esi
	call	_is_constant
	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	je	SHORT $LN170@more_maken
	mov	edx, esi
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+ecx+32]
	fld1
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H

; 3914 :         { subtree_swap(&left,&right);
; 3915 :           listtop -= 2;
; 3916 :         }
; 3917 :         else

	jnp	$LN480@more_maken
$LN170@more_maken:

; 3918 :         {
; 3919 :           list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edi

; 3920 :           list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 3921 :           list[listtop].type = TIMES_NODE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10125		; 0000278dH

; 3922 :           list[listtop].stack_delta = -1;
; 3923 :         }
; 3924 :         list[listtop].datatype = REAL_TYPE;
; 3925 :         break;

	jmp	$LN481@more_maken
$LN168@more_maken:

; 3926 : 
; 3927 :     case '/':
; 3928 :         if ( is_constant(right) && is_constant(left) )

	mov	edi, DWORD PTR _right$[ebp]
	push	edi
	call	_is_constant
	mov	esi, DWORD PTR _left$[ebp]
	add	esp, 4
	test	eax, eax
	je	$LN167@more_maken
	push	esi
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	$LN167@more_maken

; 3929 :         { /* fold constants */
; 3930 :           
; 3931 :           listtop -= 2;

	mov	ecx, DWORD PTR _listtop
	sub	ecx, 2
	mov	DWORD PTR _listtop, ecx

; 3932 :           if ( (left != listtop) || (right != listtop+1) )

	cmp	esi, ecx
	jne	SHORT $LN165@more_maken
	lea	edx, DWORD PTR [ecx+1]
	cmp	edi, edx
	je	SHORT $LN166@more_maken
$LN165@more_maken:

; 3933 :              kb_error(1440,"Internal error: Constant folding not working.",
; 3934 :                COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CO@GPMAMBBE@Internal?5error?3?5Constant?5folding@
	push	1440					; 000005a0H
	call	_kb_error
	mov	ecx, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN166@more_maken:

; 3935 :           if ( list[right].op1.real == 0.0 ) 

	mov	edx, DWORD PTR _list
	imul	edi, 168				; 000000a8H
	fld	QWORD PTR [edx+edi+32]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN164@more_maken

; 3936 :           {
; 3937 :              kb_error(1441,"Divide by zero.",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BA@HPOADLHK@Divide?5by?5zero?4?$AA@
	push	1441					; 000005a1H
	call	_kb_error
	mov	edx, DWORD PTR _list
	mov	ecx, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN164@more_maken:

; 3938 :           }
; 3939 :           list[listtop].op1.real = list[left].op1.real / list[right].op1.real;

	imul	esi, 168				; 000000a8H
	imul	ecx, 168				; 000000a8H
	fld	QWORD PTR [esi+edx+32]
	fdiv	QWORD PTR [edx+edi+32]
	fstp	QWORD PTR [ecx+edx+32]

; 3940 :           list[listtop].type = PUSHCONST_NODE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH
	jmp	$LN198@more_maken
$LN167@more_maken:

; 3941 :         }
; 3942 :         else if  ( is_constant(left) && (list[left].op1.real==0.0) ) 

	push	esi
	call	_is_constant
	fldz
	add	esp, 4
	test	eax, eax
	je	SHORT $LN426@more_maken
	mov	eax, DWORD PTR _list
	mov	edx, esi
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+eax+32]
	fld	ST(1)
	fucompp
	lea	ecx, DWORD PTR [edx+eax+32]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN426@more_maken

; 3943 :         { listtop = left; /* just leave 0 */

	mov	DWORD PTR _listtop, esi

; 3944 :           list[listtop].op1.real = 0.0;

	fstp	QWORD PTR [ecx]
$LN484@more_maken:

; 3945 :           list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], 10095		; 0000276fH

; 3946 :           list[listtop].stack_delta = 1;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+156], 1
	jmp	$LN198@more_maken
$LN426@more_maken:

; 3947 :         }
; 3948 :         else if ( is_constant(right) && (list[right].op1.real==0.0) )

	push	edi
	fstp	ST(0)
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	SHORT $LN160@more_maken
	mov	eax, DWORD PTR _list
	mov	edx, edi
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+eax+32]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN160@more_maken

; 3949 :            kb_error(1442,"Divide by zero.",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BA@HPOADLHK@Divide?5by?5zero?4?$AA@
	push	1442					; 000005a2H
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	$LN198@more_maken
$LN160@more_maken:

; 3950 :         else if ( is_constant(right) && (list[right].op1.real==1.0) )

	push	edi
	call	_is_constant
	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	je	SHORT $LN158@more_maken
	mov	edx, edi
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+ecx+32]
	fld1
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H

; 3951 :            listtop -= 2; /* just leave numerator */
; 3952 :         else

	jnp	$LN453@more_maken
$LN158@more_maken:

; 3953 :         {
; 3954 :           list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edi

; 3955 :           list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], esi

; 3956 :           list[listtop].type = DIVIDE_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10126		; 0000278eH

; 3957 :           list[listtop].stack_delta = -1;
; 3958 :         }
; 3959 :         list[listtop].datatype = REAL_TYPE;
; 3960 :         break;

	jmp	$LN475@more_maken
$LN156@more_maken:

; 3961 : 
; 3962 :     case '%':
; 3963 :         if ( is_constant(right) && is_constant(left) )

	mov	esi, DWORD PTR _right$[ebp]
	push	esi
	call	_is_constant
	mov	edi, DWORD PTR _left$[ebp]
	add	esp, 4
	test	eax, eax
	je	$LN155@more_maken
	push	edi
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	SHORT $LN155@more_maken

; 3964 :         { /* fold constants */
; 3965 :           listtop -= 2;

	mov	ebx, DWORD PTR _listtop
	sub	ebx, 2
	mov	DWORD PTR _listtop, ebx

; 3966 :           if ( (left != listtop) || (right != listtop+1) )

	cmp	edi, ebx
	jne	SHORT $LN153@more_maken
	lea	edx, DWORD PTR [ebx+1]
	cmp	esi, edx
	je	SHORT $LN154@more_maken
$LN153@more_maken:

; 3967 :              kb_error(1443,"Internal error: Constant folding not working.",
; 3968 :                COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CO@GPMAMBBE@Internal?5error?3?5Constant?5folding@
	push	1443					; 000005a3H
	call	_kb_error
	mov	ebx, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN154@more_maken:

; 3969 :           list[listtop].op1.real = list[left].op1.real - 
; 3970 :               floor(list[left].op1.real / list[right].op1.real)
; 3971 :               *list[right].op1.real;

	mov	eax, DWORD PTR _list
	imul	edi, 168				; 000000a8H
	imul	esi, 168				; 000000a8H
	fld	QWORD PTR [edi+eax+32]
	fst	QWORD PTR tv4110[ebp]
	fdiv	QWORD PTR [esi+eax+32]
	lea	esi, DWORD PTR [esi+eax+32]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	fmul	QWORD PTR [esi]
	mov	eax, DWORD PTR _list
	add	esp, 8
	imul	ebx, 168				; 000000a8H
	fsubr	QWORD PTR tv4110[ebp]
	fstp	QWORD PTR [ebx+eax+32]

; 3972 :           list[listtop].type = PUSHCONST_NODE;
; 3973 :           list[listtop].stack_delta = 1;
; 3974 :         }
; 3975 :         else

	jmp	$LN484@more_maken
$LN155@more_maken:

; 3976 :         { list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], esi

; 3977 :           list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edi

; 3978 :           list[listtop].type = REALMOD_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10127		; 0000278fH

; 3979 :           list[listtop].stack_delta = -1;
; 3980 :         }
; 3981 :         list[listtop].datatype = REAL_TYPE;
; 3982 :         break;

	jmp	$LN475@more_maken
$LN329@more_maken:

; 3082 :          }
; 3083 :          break;
; 3084 : 
; 3085 :     case SINGLE_LETTER_NODE:
; 3086 :          list[listtop].type = SINGLE_LETTER_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10009		; 00002719H

; 3087 :          list[listtop].op1.letter = left;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _left$[ebp]
	imul	ecx, 168				; 000000a8H
	mov	eax, DWORD PTR _list
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+eax+32], edx
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN384@more_maken:

; 3060 : 
; 3061 :   switch (type)

	cmp	esi, 10395				; 0000289bH
	jg	$LN385@more_maken
	je	$LN134@more_maken
	lea	eax, DWORD PTR [esi-10018]
	cmp	eax, 220				; 000000dcH
	ja	$LN1@more_maken
	movzx	ecx, BYTE PTR $LN406@more_maken[eax]
	jmp	DWORD PTR $LN492@more_maken[ecx*4]
$LN328@more_maken:

; 3088 :          break;
; 3089 : 
; 3090 :     case SINGLE_REDEFD_NODE:
; 3091 :          list[listtop].type = SINGLE_REDEFD_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10032		; 00002730H

; 3092 :          list[listtop].op1.letter = left;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _left$[ebp]
	imul	ecx, 168				; 000000a8H
	mov	eax, DWORD PTR _list
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+eax+32], edx
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN327@more_maken:

; 3093 :          break;
; 3094 : 
; 3095 :     case CMDLIST_NODE:  
; 3096 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], esi

; 3097 :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _left$[ebp]
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx

; 3098 :          if ( right ) list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _right$[ebp]
	test	eax, eax
	je	$LN333@more_maken
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	eax, ecx
	imul	ecx, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+edx+8], eax
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN325@more_maken:

; 3099 :          break;
; 3100 : 
; 3101 :     case COMMAND_BLOCK_NODE:  
; 3102 :          list[listtop].type = COMMAND_BLOCK_NODE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H

; 3103 :          list[listtop].left = left - listtop;

	mov	edx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax+ecx], 10029		; 0000272dH
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+ecx+4], edx
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN324@more_maken:

; 3104 :          break;
; 3105 : 
; 3106 :     case REPEAT_INIT_NODE:
; 3107 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 3108 :          list[listtop].left = left - listtop;

	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [edx+eax], esi
	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx
$LN462@more_maken:

; 3109 :          list[listtop].stack_delta = +1;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+ecx+156], 1
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN323@more_maken:

; 3110 :          break;
; 3111 : 
; 3112 :     case REPEAT_NODE:
; 3113 :          list[listtop].type = REPEAT_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10061		; 0000274dH

; 3114 :          list[listtop].left = left - listtop;

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _left$[ebp]
	mov	esi, DWORD PTR _list
	mov	edx, eax
	sub	edx, ecx
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+esi+4], edx

; 3115 :          list[listtop].right = right - listtop;

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _right$[ebp]
	mov	edi, DWORD PTR _list
	mov	esi, ecx
	sub	esi, edx
	imul	edx, 168				; 000000a8H

; 3116 :          list[left].op1.skipsize = right+1-left; /* for skipping body */

	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [edx+edi+8], esi
	mov	edx, DWORD PTR _list
	inc	ecx
	mov	DWORD PTR [eax+edx+32], ecx

; 3117 :          list[listtop].stack_delta = -2;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+ecx+156], -2		; fffffffeH
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN321@more_maken:

; 3122 :          break;
; 3123 : 
; 3124 :       case COND_TEST_NODE:
; 3125 :          list[listtop].type = COND_TEST_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 3126 :          list[listtop].left = left - listtop;

	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [edx+eax], 10063		; 0000274fH

; 3127 :          /* inx will be target for false jmp */
; 3128 :          list[listtop].stack_delta = -1;
; 3129 :          break;

	jmp	$LN460@more_maken
$LN320@more_maken:

; 3130 : 
; 3131 :       case COND_EXPR_NODE:
; 3132 :          list[listtop].type = COND_EXPR_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10065		; 00002751H

; 3133 :          list[listtop].left = left - listtop;

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _left$[ebp]
	mov	esi, DWORD PTR _list
	mov	edx, eax
	sub	edx, ecx
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+esi+4], edx

; 3134 :          list[listtop].right = right - listtop;

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _right$[ebp]
	mov	edi, DWORD PTR _list
	mov	esi, ecx
	sub	esi, edx
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+edi+8], esi

; 3135 :          list[left].op1.skipsize = listtop - left; /* to skip TRUE part */

	mov	edx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+esi+32], edx

; 3136 :          list[listtop].stack_delta = -1;  /* since one expression skipped */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+156], -1

; 3137 :          list[listtop].datatype = list[right].datatype;
; 3138 :          break;

	jmp	$LN455@more_maken
$LN306@more_maken:

; 3250 :          break;
; 3251 : 
; 3252 :     case PUSHCONST_NODE:
; 3253 :          list[listtop].type = PUSHCONST_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10095		; 0000276fH

; 3254 :          list[listtop].op1.real = real_val;

	mov	ecx, DWORD PTR _listtop
	fld	QWORD PTR _real_val
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	fstp	QWORD PTR [ecx+edx+32]

; 3255 :          list[listtop].stack_delta = 1;
; 3256 :          list[listtop].datatype = REAL_TYPE;
; 3257 :          break;

	jmp	$LN463@more_maken
$LN303@more_maken:

; 3266 : 
; 3267 :     case PUSH_METHOD_INSTANCE_NODE:
; 3268 :          list[listtop].type = type;
; 3269 :          list[listtop].op1.meth_id = left;
; 3270 :          list[listtop].flags |= EPHEMERAL;
; 3271 :          list[listtop].stack_delta = 1;
; 3272 :          list[listtop].datatype = REAL_TYPE;
; 3273 :          break;
; 3274 : 
; 3275 :     case PUSHPI_NODE:
; 3276 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop

; 3277 :          list[listtop].op1.real = M_PI;

	fld	QWORD PTR __real@400921fb54442d18
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	fstp	QWORD PTR [edx+eax+32]

; 3278 :          list[listtop].stack_delta = 1;
; 3279 :          list[listtop].datatype = REAL_TYPE;
; 3280 :          break;

	jmp	$LN463@more_maken
$LN302@more_maken:

; 3281 : 
; 3282 :     case PUSHE_NODE:
; 3283 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop

; 3284 :          list[listtop].op1.real = M_E;

	fld	QWORD PTR __real@4005bf0a8b145769
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	fstp	QWORD PTR [edx+eax+32]

; 3285 :          list[listtop].stack_delta = 1;
; 3286 :          list[listtop].datatype = REAL_TYPE;
; 3287 :          break;

	jmp	$LN463@more_maken
$LN301@more_maken:

; 3288 : 
; 3289 :     case PUSHG_NODE:
; 3290 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 3291 :          list[listtop].stack_delta = 1;
; 3292 :          list[listtop].datatype = REAL_TYPE;
; 3293 :          break;

	jmp	$LN465@more_maken
$LN297@more_maken:

; 3316 :          break;
; 3317 : 
; 3318 :     case EXP_NODE:
; 3319 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3322 :            list[listtop].type = PUSHCONST_NODE;

	mov	edx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	SHORT $LN296@more_maken

; 3320 :          { /* fold constants */
; 3321 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3322 :            list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx], 10095		; 0000276fH

; 3323 :            list[listtop].op1.real = exp(list[listtop].op1.real);

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	fld	QWORD PTR [eax+ecx+32]
	lea	esi, DWORD PTR [eax+ecx+32]
	call	__CIexp
	pop	edi
	fstp	QWORD PTR [esi]
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN296@more_maken:

; 3324 :            break;
; 3325 :          }
; 3326 :          list[listtop].left = left - listtop;

	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], edi

; 3327 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 3328 :          list[listtop].datatype = REAL_TYPE;
; 3329 :          break;

	jmp	$LN470@more_maken
$LN295@more_maken:

; 3330 : 
; 3331 :     case LOG_NODE:
; 3332 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3333 :          { /* fold constants */
; 3334 :            listtop--;
; 3335 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	SHORT $LN294@more_maken

; 3336 :            if ( list[listtop].op1.real < 0.0 )

	fldz
	dec	eax
	mov	DWORD PTR _listtop, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH
	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	mov	edx, ecx
	imul	edx, 168				; 000000a8H
	fcomp	QWORD PTR [edx+eax+32]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN293@more_maken

; 3337 :              kb_error(1425,"log of negative number.\n", COMMAND_ERROR );

	push	5
	push	OFFSET ??_C@_0BJ@LEEEDPAJ@log?5of?5negative?5number?4?6?$AA@
	push	1425					; 00000591H
	call	_kb_error
	mov	ecx, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN293@more_maken:

; 3338 :            list[listtop].op1.real = log(list[listtop].op1.real);

	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	fld	QWORD PTR [ecx+edx+32]
	lea	esi, DWORD PTR [ecx+edx+32]
	call	__CIlog
	pop	edi
	fstp	QWORD PTR [esi]
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN294@more_maken:

; 3339 :            break;
; 3340 :          }
; 3341 :          list[listtop].left = left - listtop;

	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edi

; 3342 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], esi

; 3343 :          list[listtop].datatype = REAL_TYPE;
; 3344 :          break;

	jmp	$LN468@more_maken
$LN292@more_maken:

; 3345 : 
; 3346 :     case ABS_NODE:
; 3347 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3350 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	SHORT $LN294@more_maken

; 3348 :          { /* fold constants */
; 3349 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3350 :            list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH

; 3351 :            list[listtop].op1.real = fabs(list[listtop].op1.real);

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+eax+32]
	fabs
	fstp	QWORD PTR [edx+eax+32]
	lea	eax, DWORD PTR [edx+eax+32]
	pop	edi
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN290@more_maken:

; 3352 :            break;
; 3353 :          }
; 3354 :          list[listtop].left = left - listtop;
; 3355 :          list[listtop].type = type;
; 3356 :          list[listtop].datatype = REAL_TYPE;
; 3357 :          break;
; 3358 : 
; 3359 :     case SIN_NODE:
; 3360 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3363 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3361 :          { /* fold constants */
; 3362 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3363 :            list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH

; 3364 :            list[listtop].op1.real = sin(list[listtop].op1.real);

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+eax+32]
	lea	esi, DWORD PTR [edx+eax+32]
	call	__CIsin
	pop	edi
	fstp	QWORD PTR [esi]
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN288@more_maken:

; 3365 :            break;
; 3366 :          }
; 3367 :          list[listtop].left = left - listtop;
; 3368 :          list[listtop].type = type;
; 3369 :          list[listtop].datatype = REAL_TYPE;
; 3370 :          break;
; 3371 : 
; 3372 :     case SINH_NODE:
; 3373 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3377 :            x = exp(list[listtop].op1.real);

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3374 :          { /* fold constants */
; 3375 :            REAL x;
; 3376 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3377 :            x = exp(list[listtop].op1.real);

	imul	eax, 168				; 000000a8H
	fld	QWORD PTR [eax+ecx+32]
	lea	esi, DWORD PTR [eax+ecx]
	call	__CIexp

; 3379 :            list[listtop].op1.real = (x-1/x)/2;

	fld1
	fdiv	ST(0), ST(1)
	fsubp	ST(1), ST(0)
$LN479@more_maken:

; 3378 :            list[listtop].type = PUSHCONST_NODE;

	mov	DWORD PTR [esi], 10095			; 0000276fH
$LN472@more_maken:

; 3379 :            list[listtop].op1.real = (x-1/x)/2;

	fmul	QWORD PTR __real@3fe0000000000000
$LN473@more_maken:
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	pop	edi
	pop	esi
	fstp	QWORD PTR [edx+eax+32]
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN286@more_maken:

; 3380 :            break;
; 3381 :          }
; 3382 :          list[listtop].left = left - listtop;
; 3383 :          list[listtop].type = type;
; 3384 :          list[listtop].datatype = REAL_TYPE;
; 3385 :          break;
; 3386 : 
; 3387 :     case COSH_NODE:
; 3388 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3392 :            x = exp(list[listtop].op1.real);

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3389 :          { /* fold constants */
; 3390 :            REAL x;
; 3391 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3392 :            x = exp(list[listtop].op1.real);

	imul	eax, 168				; 000000a8H
	fld	QWORD PTR [eax+ecx+32]
	lea	esi, DWORD PTR [eax+ecx]
	call	__CIexp

; 3393 :            list[listtop].type = PUSHCONST_NODE;
; 3394 :            list[listtop].op1.real = (x+1/x)/2;

	fld1
	fdiv	ST(0), ST(1)
	faddp	ST(1), ST(0)

; 3395 :            break;

	jmp	SHORT $LN479@more_maken
$LN284@more_maken:

; 3396 :          }
; 3397 :          list[listtop].left = left - listtop;
; 3398 :          list[listtop].type = type;
; 3399 :          list[listtop].datatype = REAL_TYPE;
; 3400 :          break;
; 3401 : 
; 3402 :     case TANH_NODE:
; 3403 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3407 :            x = exp(list[listtop].op1.real);

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3404 :          { /* fold constants */
; 3405 :            REAL x;
; 3406 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3407 :            x = exp(list[listtop].op1.real);

	imul	eax, 168				; 000000a8H
	fld	QWORD PTR [eax+ecx+32]
	lea	esi, DWORD PTR [eax+ecx]
	call	__CIexp

; 3408 :            list[listtop].type = PUSHCONST_NODE;

	mov	DWORD PTR [esi], 10095			; 0000276fH

; 3409 :            list[listtop].op1.real = (x-1/x)/(x+1/x);

	fld1
	fdiv	ST(0), ST(1)
	fld	ST(1)
	fsub	ST(0), ST(1)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fdivrp	ST(1), ST(0)

; 3410 :            break;

	jmp	$LN473@more_maken
$LN282@more_maken:

; 3411 :          }
; 3412 :          list[listtop].left = left - listtop;
; 3413 :          list[listtop].type = type;
; 3414 :          list[listtop].datatype = REAL_TYPE;
; 3415 :          break;
; 3416 : 
; 3417 :     case ATANH_NODE:
; 3418 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3422 :            x = list[listtop].op1.real;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3419 :          { /* fold constants */
; 3420 :            REAL x;
; 3421 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3422 :            x = list[listtop].op1.real;

	imul	eax, 168				; 000000a8H
	fld	QWORD PTR [eax+ecx+32]

; 3423 :            list[listtop].type = PUSHCONST_NODE;

	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH
	fst	QWORD PTR _x$90529[ebp]

; 3424 :            list[listtop].op1.real = (log(x+1)-log(1-x))/2;

	fadd	QWORD PTR __real@3ff0000000000000
	call	__CIlog
	fstp	QWORD PTR tv1775[ebp]
	fld1
	fsub	QWORD PTR _x$90529[ebp]
	call	__CIlog
	fsubr	QWORD PTR tv1775[ebp]

; 3425 :            break;

	jmp	$LN472@more_maken
$LN280@more_maken:

; 3426 :          }
; 3427 :          list[listtop].left = left - listtop;
; 3428 :          list[listtop].type = type;
; 3429 :          list[listtop].datatype = REAL_TYPE;
; 3430 :          break;
; 3431 : 
; 3432 :     case ASINH_NODE:
; 3433 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3437 :            x = list[listtop].op1.real;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3434 :          { /* fold constants */
; 3435 :            REAL x;
; 3436 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3437 :            x = list[listtop].op1.real;

	imul	eax, 168				; 000000a8H
	fld	QWORD PTR [eax+ecx+32]

; 3438 :            list[listtop].type = PUSHCONST_NODE;

	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH
	fst	QWORD PTR _x$90532[ebp]

; 3439 :            list[listtop].op1.real = log(x + sqrt(x*x+1));

	fmul	ST(0), ST(0)
	fadd	QWORD PTR __real@3ff0000000000000
	call	__CIsqrt
	fadd	QWORD PTR _x$90532[ebp]
	call	__CIlog

; 3440 :            break;

	jmp	$LN473@more_maken
$LN278@more_maken:

; 3441 :          }
; 3442 :          list[listtop].left = left - listtop;
; 3443 :          list[listtop].type = type;
; 3444 :          list[listtop].datatype = REAL_TYPE;
; 3445 :          break;
; 3446 : 
; 3447 :     case ACOSH_NODE:
; 3448 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3452 :            x = list[listtop].op1.real;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3449 :          { /* fold constants */
; 3450 :            REAL x;
; 3451 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3452 :            x = list[listtop].op1.real;

	imul	eax, 168				; 000000a8H
	fld	QWORD PTR [eax+ecx+32]

; 3453 :            list[listtop].type = PUSHCONST_NODE;

	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH
	fst	QWORD PTR _x$90535[ebp]

; 3454 :            if ( x < 1.0 )

	fld1
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN276@more_maken

; 3455 :              kb_error(1424,"acosh argument is less than 1.0.\n", COMMAND_ERROR );

	push	5
	fstp	ST(0)
	push	OFFSET ??_C@_0CC@EHDJDLDK@acosh?5argument?5is?5less?5than?51?40?4@
	push	1424					; 00000590H
	call	_kb_error
	fld	QWORD PTR _x$90535[ebp]
	add	esp, 12					; 0000000cH
$LN276@more_maken:

; 3456 :            list[listtop].op1.real = 2*log(sqrt(x+1) + sqrt(x-1))-log(2.0);

	fsub	QWORD PTR __real@3ff0000000000000
	call	__CIsqrt
	fstp	QWORD PTR tv3644[ebp]
	fld	QWORD PTR _x$90535[ebp]
	fadd	QWORD PTR __real@3ff0000000000000
	call	__CIsqrt
	fadd	QWORD PTR tv3644[ebp]
	call	__CIlog
	fld	QWORD PTR __real@4000000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR tv511[ebp]
	call	__CIlog
	fsubr	QWORD PTR tv511[ebp]

; 3457 :            break;

	jmp	$LN473@more_maken
$LN275@more_maken:

; 3458 :          }
; 3459 :          list[listtop].left = left - listtop;
; 3460 :          list[listtop].type = type;
; 3461 :          list[listtop].datatype = REAL_TYPE;
; 3462 :          break;
; 3463 : 
; 3464 :     case ASIN_NODE:
; 3465 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3468 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3466 :          { /* fold constants */
; 3467 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3468 :            list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH

; 3469 :            if ( fabs(list[listtop].op1.real) > 1.0 )

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	mov	edx, ecx
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+eax+32]
	fabs
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN273@more_maken

; 3470 :              kb_error(1426,"asin argument out of bounds.\n", COMMAND_ERROR );

	push	5
	push	OFFSET ??_C@_0BO@JJEBJFHA@asin?5argument?5out?5of?5bounds?4?6?$AA@
	push	1426					; 00000592H
	call	_kb_error
	mov	ecx, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN273@more_maken:

; 3471 :            list[listtop].op1.real = asin(list[listtop].op1.real);

	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	fld	QWORD PTR [ecx+edx+32]
	lea	esi, DWORD PTR [ecx+edx+32]
	call	__CIasin
	pop	edi
	fstp	QWORD PTR [esi]
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN272@more_maken:

; 3472 :            break;
; 3473 :          }
; 3474 :          list[listtop].left = left - listtop;
; 3475 :          list[listtop].type = type;
; 3476 :          list[listtop].datatype = REAL_TYPE;
; 3477 :          break;
; 3478 : 
; 3479 :     case COS_NODE:
; 3480 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3483 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3481 :          { /* fold constants */
; 3482 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3483 :            list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH

; 3484 :            list[listtop].op1.real = cos(list[listtop].op1.real);

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+eax+32]
	lea	esi, DWORD PTR [edx+eax+32]
	call	__CIcos
	pop	edi
	fstp	QWORD PTR [esi]
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN270@more_maken:

; 3485 :            break;
; 3486 :          }
; 3487 :          list[listtop].left = left - listtop;
; 3488 :          list[listtop].type = type;
; 3489 :          list[listtop].datatype = REAL_TYPE;
; 3490 :          break;
; 3491 : 
; 3492 :     case ACOS_NODE:
; 3493 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3496 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3494 :          { /* fold constants */
; 3495 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3496 :            list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH

; 3497 :            if ( fabs(list[listtop].op1.real) > 1.0 )

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	mov	edx, ecx
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+eax+32]
	fabs
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN268@more_maken

; 3498 :              kb_error(1427,"acos argument out of bounds.\n", COMMAND_ERROR );

	push	5
	push	OFFSET ??_C@_0BO@IJAOBLOA@acos?5argument?5out?5of?5bounds?4?6?$AA@
	push	1427					; 00000593H
	call	_kb_error
	mov	ecx, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN268@more_maken:

; 3499 :            list[listtop].op1.real = acos(list[listtop].op1.real);

	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	fld	QWORD PTR [ecx+edx+32]
	lea	esi, DWORD PTR [ecx+edx+32]
	call	__CIacos
	pop	edi
	fstp	QWORD PTR [esi]
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN267@more_maken:

; 3500 :            break;
; 3501 :          }
; 3502 :          list[listtop].left = left - listtop;
; 3503 :          list[listtop].type = type;
; 3504 :          list[listtop].datatype = REAL_TYPE;
; 3505 :          break;
; 3506 : 
; 3507 :     case TAN_NODE:
; 3508 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3511 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3509 :          { /* fold constants */
; 3510 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3511 :            list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH

; 3512 :            list[listtop].op1.real = tan(list[listtop].op1.real);

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+eax+32]
	lea	esi, DWORD PTR [edx+eax+32]
	call	__CItan
	pop	edi
	fstp	QWORD PTR [esi]
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN265@more_maken:

; 3513 :            break;
; 3514 :          }
; 3515 :          list[listtop].left = left - listtop;
; 3516 :          list[listtop].type = type;
; 3517 :          list[listtop].datatype = REAL_TYPE;
; 3518 :          break;
; 3519 : 
; 3520 :     case ATAN_NODE:
; 3521 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3524 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3522 :          { /* fold constants */
; 3523 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3524 :            list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH

; 3525 :            list[listtop].op1.real = atan(list[listtop].op1.real);

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+eax+32]
	lea	esi, DWORD PTR [edx+eax+32]
	call	__CIatan
	pop	edi
	fstp	QWORD PTR [esi]
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN263@more_maken:

; 3526 :            break;
; 3527 :          }
; 3528 :          list[listtop].left = left - listtop;
; 3529 :          list[listtop].type = type;
; 3530 :          list[listtop].datatype = REAL_TYPE;
; 3531 :          break;
; 3532 : 
; 3533 :     case SQR_NODE:
; 3534 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3537 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3535 :          { /* fold constants */
; 3536 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3537 :            list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH

; 3538 :            list[listtop].op1.real = list[listtop].op1.real*list[listtop].op1.real;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+eax+32]
	fmul	ST(0), ST(0)
	fstp	QWORD PTR [edx+eax+32]
	lea	eax, DWORD PTR [edx+eax+32]
	pop	edi
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN261@more_maken:

; 3539 :            break;
; 3540 :          }
; 3541 :          list[listtop].left = left - listtop;
; 3542 :          list[listtop].type = type;
; 3543 :          list[listtop].datatype = REAL_TYPE;
; 3544 :          break;
; 3545 : 
; 3546 :     case SQRT_NODE:
; 3547 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3548 :          { /* fold constants */
; 3549 :            listtop--;
; 3550 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3551 :            if ( list[listtop].op1.real < 0.0 )

	fldz
	dec	eax
	mov	DWORD PTR _listtop, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH
	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	mov	edx, ecx
	imul	edx, 168				; 000000a8H
	fcomp	QWORD PTR [edx+eax+32]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN259@more_maken

; 3552 :              kb_error(1428,"sqrt of negative number.\n", COMMAND_ERROR );

	push	5
	push	OFFSET ??_C@_0BK@PJJFIHAA@sqrt?5of?5negative?5number?4?6?$AA@
	push	1428					; 00000594H
	call	_kb_error
	mov	ecx, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN259@more_maken:

; 3553 :            list[listtop].op1.real = sqrt(list[listtop].op1.real);

	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	fld	QWORD PTR [ecx+edx+32]
	lea	esi, DWORD PTR [ecx+edx+32]
	call	__CIsqrt
	pop	edi
	fstp	QWORD PTR [esi]
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN258@more_maken:

; 3554 :            break;
; 3555 :          }
; 3556 :          list[listtop].left = left - listtop;
; 3557 :          list[listtop].type = type;
; 3558 :          list[listtop].datatype = REAL_TYPE;
; 3559 :          break;
; 3560 : 
; 3561 :     case ELLIPTICK_NODE:
; 3562 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3565 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3563 :          { /* fold constants */
; 3564 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3565 :            list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH

; 3566 :            list[listtop].op1.real = ellipticK(list[listtop].op1.real);

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	sub	esp, 8
	fld	QWORD PTR [edx+eax+32]
	fstp	QWORD PTR [esp]
	call	_ellipticK
$LN474@more_maken:
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	add	esp, 8
	imul	ecx, 168				; 000000a8H
	pop	edi
	pop	esi
	fstp	QWORD PTR [ecx+edx+32]
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN256@more_maken:

; 3567 :            break;
; 3568 :          }
; 3569 :          list[listtop].left = left - listtop;
; 3570 :          list[listtop].type = type;
; 3571 :          list[listtop].datatype = REAL_TYPE;
; 3572 :          break;
; 3573 : 
; 3574 :     case ELLIPTICE_NODE:
; 3575 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3578 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3576 :          { /* fold constants */
; 3577 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3578 :            list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH

; 3579 :            list[listtop].op1.real = ellipticE(list[listtop].op1.real);

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	sub	esp, 8
	fld	QWORD PTR [edx+eax+32]
	fstp	QWORD PTR [esp]
	call	_ellipticE

; 3580 :            break;

	jmp	SHORT $LN474@more_maken
$LN254@more_maken:

; 3581 :          }
; 3582 :          list[listtop].left = left - listtop;
; 3583 :          list[listtop].type = type;
; 3584 :          list[listtop].datatype = REAL_TYPE;
; 3585 :          break;
; 3586 : 
; 3587 : 
; 3588 :     case CEIL_NODE:
; 3589 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3592 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3590 :          { /* fold constants */
; 3591 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3592 :            list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH

; 3593 :            list[listtop].op1.real = ceil(list[listtop].op1.real);

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	sub	esp, 8
	fld	QWORD PTR [edx+eax+32]
	fstp	QWORD PTR [esp]
	call	_ceil

; 3594 :            break;

	jmp	$LN474@more_maken
$LN252@more_maken:

; 3595 :          }
; 3596 :          list[listtop].left = left - listtop;
; 3597 :          list[listtop].type = type;
; 3598 :          list[listtop].datatype = REAL_TYPE;
; 3599 :          break;
; 3600 : 
; 3601 :     case FLOOR_NODE:
; 3602 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3605 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3603 :          { /* fold constants */
; 3604 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3605 :            list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH

; 3606 :            list[listtop].op1.real = floor(list[listtop].op1.real);

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+eax+32]
	lea	esi, DWORD PTR [edx+eax+32]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fstp	QWORD PTR [esi]
	pop	edi
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN250@more_maken:

; 3607 :            break;
; 3608 :          }
; 3609 :          list[listtop].left = left - listtop;
; 3610 :          list[listtop].type = type;
; 3611 :          list[listtop].datatype = REAL_TYPE;
; 3612 :          break;
; 3613 : 
; 3614 :     case CHS_NODE:
; 3615 :          if ( is_constant(left) )

	mov	edi, DWORD PTR _left$[ebp]
	push	edi
	call	_is_constant

; 3618 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN294@more_maken

; 3616 :          { /* fold constants */
; 3617 :            listtop--;

	dec	eax
	mov	DWORD PTR _listtop, eax

; 3618 :            list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH

; 3619 :            list[listtop].op1.real = -list[listtop].op1.real;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	fld	QWORD PTR [edx+eax+32]
	fchs
	fstp	QWORD PTR [edx+eax+32]
	lea	eax, DWORD PTR [edx+eax+32]
	pop	edi
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN248@more_maken:

; 3620 :            break;
; 3621 :          }
; 3622 :          list[listtop].left = left - listtop;
; 3623 :          list[listtop].type = type;
; 3624 :          list[listtop].datatype = REAL_TYPE;
; 3625 :          break;
; 3626 : 
; 3627 : 
; 3628 :     case MAXIMUM_NODE:
; 3629 :          if ( is_constant(right) && is_constant(left) )

	mov	edi, DWORD PTR _right$[ebp]
	push	edi
	call	_is_constant
	mov	ebx, DWORD PTR _left$[ebp]
	add	esp, 4
	test	eax, eax
	je	$LN247@more_maken
	push	ebx
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	$LN247@more_maken

; 3630 :          { /* fold constants */
; 3631 :            listtop -= 2;

	mov	esi, DWORD PTR _listtop
	sub	esi, 2
	mov	DWORD PTR _listtop, esi

; 3632 :            if ( (left != listtop) || (right != listtop+1) )

	cmp	ebx, esi
	jne	SHORT $LN245@more_maken
	lea	eax, DWORD PTR [esi+1]
	cmp	edi, eax
	je	SHORT $LN246@more_maken
$LN245@more_maken:

; 3633 :              kb_error(1429,"Constant folding not working.",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BO@DCHCJGFO@Constant?5folding?5not?5working?4?$AA@
	push	1429					; 00000595H
	call	_kb_error
	mov	esi, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN246@more_maken:

; 3634 :            list[listtop].op1.real = 
; 3635 :              (list[left].op1.real > list[right].op1.real) ?
; 3636 :                 list[left].op1.real : list[right].op1.real;

	mov	ecx, DWORD PTR _list
	imul	edi, 168				; 000000a8H
	imul	ebx, 168				; 000000a8H
	fld	QWORD PTR [edi+ecx+32]
	fcomp	QWORD PTR [ebx+ecx+32]
	fnstsw	ax
	lea	edi, DWORD PTR [edi+ecx+32]
	lea	edx, DWORD PTR [ebx+ecx+32]
	test	ah, 5
	jp	SHORT $LN338@more_maken
	fld	QWORD PTR [edx]
	jmp	SHORT $LN339@more_maken
$LN338@more_maken:
	fld	QWORD PTR [edi]
$LN339@more_maken:
	imul	esi, 168				; 000000a8H
	fstp	QWORD PTR [esi+ecx+32]

; 3637 :            list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], 10095		; 0000276fH

; 3638 :            list[listtop].stack_delta = 1;
; 3639 :            break;

	jmp	$LN462@more_maken
$LN247@more_maken:

; 3640 :          }
; 3641 :          list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi

; 3642 :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	ebx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], ebx
$LN476@more_maken:

; 3643 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], esi
$LN475@more_maken:

; 3644 :          list[listtop].stack_delta = -1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], -1
$LN198@more_maken:

; 3645 :          list[listtop].datatype = REAL_TYPE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+ecx+20], 1
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN244@more_maken:

; 3646 :          break;
; 3647 : 
; 3648 :     case MINIMUM_NODE:
; 3649 :          if ( is_constant(right) && is_constant(left) )

	mov	edi, DWORD PTR _right$[ebp]
	push	edi
	call	_is_constant
	mov	ebx, DWORD PTR _left$[ebp]
	add	esp, 4
	test	eax, eax
	je	$LN243@more_maken
	push	ebx
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	$LN243@more_maken

; 3650 :          { /* fold constants */
; 3651 :            listtop -= 2;

	mov	esi, DWORD PTR _listtop
	sub	esi, 2
	mov	DWORD PTR _listtop, esi

; 3652 :            if ( (left != listtop) || (right != listtop+1) )

	cmp	ebx, esi
	jne	SHORT $LN241@more_maken
	lea	edx, DWORD PTR [esi+1]
	cmp	edi, edx
	je	SHORT $LN242@more_maken
$LN241@more_maken:

; 3653 :               kb_error(1430,"Internal error: Constant folding not working.",
; 3654 :                  COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CO@GPMAMBBE@Internal?5error?3?5Constant?5folding@
	push	1430					; 00000596H
	call	_kb_error
	mov	esi, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN242@more_maken:

; 3655 :            list[listtop].op1.real = 
; 3656 :              (list[left].op1.real < list[right].op1.real) ?
; 3657 :                 list[left].op1.real : list[right].op1.real;

	mov	ecx, DWORD PTR _list
	imul	edi, 168				; 000000a8H
	imul	ebx, 168				; 000000a8H
	fld	QWORD PTR [edi+ecx+32]
	fcomp	QWORD PTR [ebx+ecx+32]
	fnstsw	ax
	lea	edi, DWORD PTR [edi+ecx+32]
	lea	edx, DWORD PTR [ebx+ecx+32]
	test	ah, 65					; 00000041H
	jne	SHORT $LN340@more_maken
	fld	QWORD PTR [edx]
	jmp	SHORT $LN341@more_maken
$LN340@more_maken:
	fld	QWORD PTR [edi]
$LN341@more_maken:
	imul	esi, 168				; 000000a8H
	fstp	QWORD PTR [esi+ecx+32]

; 3658 :            list[listtop].type = PUSHCONST_NODE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH
$LN477@more_maken:

; 3659 :            list[listtop].stack_delta = 1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+eax+156], 1
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN243@more_maken:

; 3660 :            break;
; 3661 :          }
; 3662 :          list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, edi

; 3663 :          list[listtop].left = left - listtop;
; 3664 :          list[listtop].type = type;
; 3665 :          list[listtop].stack_delta = -1;
; 3666 :          list[listtop].datatype = list[right].datatype;

	imul	edi, 168				; 000000a8H
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], ecx
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	ebx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], ebx
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], esi
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], -1
	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [edi+eax+20]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+eax+20], edx
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN240@more_maken:

; 3667 :          break;
; 3668 : 
; 3669 :     case ATAN2_NODE:
; 3670 :     case INCOMPLETE_ELLIPTICF_NODE:
; 3671 :     case INCOMPLETE_ELLIPTICE_NODE:
; 3672 :          if ( is_constant(right) && is_constant(left) )

	mov	edi, DWORD PTR _right$[ebp]
	push	edi
	call	_is_constant
	mov	ebx, DWORD PTR _left$[ebp]
	add	esp, 4
	test	eax, eax
	je	$LN247@more_maken
	push	ebx
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	$LN247@more_maken

; 3673 :          { /* fold constants */
; 3674 :            listtop -= 2;

	mov	eax, DWORD PTR _listtop
	sub	eax, 2
	mov	DWORD PTR _listtop, eax

; 3675 :            if ( (left != listtop) || (right != listtop+1) )

	cmp	ebx, eax
	jne	SHORT $LN237@more_maken
	inc	eax
	cmp	edi, eax
	je	SHORT $LN238@more_maken
$LN237@more_maken:

; 3676 :               kb_error(1431,"Internal error: Constant folding not working.",
; 3677 :                  COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CO@GPMAMBBE@Internal?5error?3?5Constant?5folding@
	push	1431					; 00000597H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN238@more_maken:

; 3678 :            switch(type)

	sub	esi, 10136				; 00002798H
	je	$LN234@more_maken
	sub	esi, 22					; 00000016H
	je	SHORT $LN233@more_maken
	dec	esi
	jne	$LN235@more_maken

; 3685 :              case INCOMPLETE_ELLIPTICE_NODE: list[listtop].op1.real = 
; 3686 :                 incompleteEllipticE(list[left].op1.real,list[right].op1.real);

	mov	eax, DWORD PTR _list
	imul	edi, 168				; 000000a8H
	imul	ebx, 168				; 000000a8H
	fld	QWORD PTR [edi+eax+32]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [ebx+eax+32]
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticE
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	add	esp, 16					; 00000010H
	imul	eax, 168				; 000000a8H
	fstp	QWORD PTR [eax+ecx+32]

; 3687 :               break;

	jmp	SHORT $LN235@more_maken
$LN233@more_maken:

; 3681 :               break;
; 3682 :              case INCOMPLETE_ELLIPTICF_NODE: list[listtop].op1.real = 
; 3683 :                 incompleteEllipticF(list[left].op1.real,list[right].op1.real);

	mov	eax, DWORD PTR _list
	imul	edi, 168				; 000000a8H
	imul	ebx, 168				; 000000a8H
	fld	QWORD PTR [edi+eax+32]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [ebx+eax+32]
	fstp	QWORD PTR [esp]
	call	_incompleteEllipticF
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	add	esp, 16					; 00000010H
	imul	edx, 168				; 000000a8H
	fstp	QWORD PTR [edx+eax+32]

; 3684 :                  break;

	jmp	SHORT $LN235@more_maken
$LN234@more_maken:

; 3679 :            { case ATAN2_NODE: list[listtop].op1.real = 
; 3680 :                 atan2(list[left].op1.real,list[right].op1.real);

	mov	esi, DWORD PTR _list
	imul	ebx, 168				; 000000a8H
	imul	edi, 168				; 000000a8H
	fld	QWORD PTR [ebx+esi+32]
	fld	QWORD PTR [edi+esi+32]
	call	__CIatan2
	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	fstp	QWORD PTR [ecx+esi+32]
$LN235@more_maken:

; 3688 :            }
; 3689 :            list[listtop].type = PUSHCONST_NODE;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx], 10095		; 0000276fH

; 3690 :            list[listtop].stack_delta = 1;
; 3691 :            break;

	jmp	$LN462@more_maken
$LN231@more_maken:

; 3692 :          }
; 3693 :          list[listtop].right = right - listtop;
; 3694 :          list[listtop].left = left - listtop;
; 3695 :          list[listtop].type = type;
; 3696 :          list[listtop].stack_delta = -1;
; 3697 :          list[listtop].datatype = REAL_TYPE;
; 3698 :          break;
; 3699 : 
; 3700 :     case WRAP_COMPOSE_NODE:
; 3701 :          list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR _list
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edx

; 3702 :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR _list
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 3703 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], esi

; 3704 :          list[listtop].stack_delta = -1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], -1

; 3705 :          list[listtop].datatype = REAL_TYPE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+ecx+20], 1
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN230@more_maken:

; 3706 :          break;
; 3707 : 
; 3708 :     case WRAP_INVERSE_NODE:
; 3709 :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR _list
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 3710 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], esi

; 3711 :          list[listtop].datatype = REAL_TYPE;
; 3712 :          break;

	jmp	$LN468@more_maken
$LN229@more_maken:

; 3713 : 
; 3714 :     case POW_NODE:
; 3715 :     case '^':
; 3716 :       if ( is_constant(right) )

	mov	edi, DWORD PTR _right$[ebp]
	push	edi
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	$LN227@more_maken

; 3717 :       { REAL p = list[right].op1.real;

	mov	ecx, DWORD PTR _list
	mov	eax, edi
	imul	eax, 168				; 000000a8H

; 3718 :         if ( floor(p) == p )

	sub	esp, 8
	fld	QWORD PTR [eax+ecx+32]
	fst	QWORD PTR _p$90593[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	fld	QWORD PTR _p$90593[ebp]
	add	esp, 8
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	$LN434@more_maken

; 3719 :         { /* integer power */
; 3720 :           n = (int)p;

	call	__ftol2_sse
	mov	ebx, eax

; 3721 :           if ( n == 0 )

	test	ebx, ebx
	jne	SHORT $LN226@more_maken

; 3722 :           { kb_error(1432,"Exponent 0.  Did you mean this?\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CB@PGHDKOBF@Exponent?50?4?5?5Did?5you?5mean?5this?$DP?6@
	push	1432					; 00000598H
	call	_kb_error

; 3723 :              listtop--;
; 3724 :              list[listtop].type = REPLACECONST_NODE;
; 3725 :              list[listtop].op1.real = 1.0;

	fld1
	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	dec	eax
	mov	DWORD PTR _listtop, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx], 10094		; 0000276eH
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	add	esp, 12					; 0000000cH
	imul	eax, 168				; 000000a8H
	pop	edi
	pop	esi
	fstp	QWORD PTR [eax+ecx+32]
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN226@more_maken:

; 3726 :              break;
; 3727 :           }
; 3728 :           else if ( n == 1 )

	mov	edi, 1
	cmp	ebx, edi
	jne	SHORT $LN224@more_maken

; 3729 :           { /* leave alone */
; 3730 :              kb_error(1433,"Exponent 1.  Did you mean this?\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CB@HHFGMLDC@Exponent?51?4?5?5Did?5you?5mean?5this?$DP?6@
	push	1433					; 00000599H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3731 :              listtop-=2;

	sub	DWORD PTR _listtop, 2
	pop	edi
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN224@more_maken:

; 3732 :              break;
; 3733 :           }
; 3734 :           else if ( n == 2 )
; 3735 :           { listtop--;
; 3736 :             if ( is_constant(left) )

	mov	esi, DWORD PTR _left$[ebp]
	push	esi
	cmp	ebx, 2
	jne	$LN222@more_maken
	sub	DWORD PTR _listtop, edi
	call	_is_constant

; 3738 :               list[listtop].type = PUSHCONST_NODE;

	mov	edx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	je	SHORT $LN221@more_maken

; 3737 :             { listtop--;

	mov	eax, DWORD PTR _listtop
	sub	eax, edi
	mov	DWORD PTR _listtop, eax

; 3738 :               list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx], 10095		; 0000276fH

; 3739 :               list[listtop].op1.real *= list[listtop].op1.real;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	fld	QWORD PTR [eax+ecx+32]
	fmul	ST(0), ST(0)
	fstp	QWORD PTR [eax+ecx+32]

; 3740 :               list[listtop].stack_delta = 1;

	mov	edx, DWORD PTR _listtop
	lea	eax, DWORD PTR [eax+ecx+32]
	imul	edx, 168				; 000000a8H
	mov	eax, DWORD PTR _list
	mov	DWORD PTR [edx+eax+156], edi
	pop	edi
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN221@more_maken:

; 3741 :             }
; 3742 :             else
; 3743 :             { list[listtop].type = SQR_NODE;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], 10137		; 00002799H
$LN478@more_maken:

; 3744 :               list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], esi

; 3745 :               list[listtop].stack_delta = 0;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+eax+156], 0
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN222@more_maken:

; 3746 :             }
; 3747 :             break;
; 3748 :           }
; 3749 :           else if ( n == -1 )

	cmp	ebx, -1
	jne	SHORT $LN218@more_maken

; 3750 :           { listtop--;

	sub	DWORD PTR _listtop, edi

; 3751 :             if ( is_constant(left) )

	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	SHORT $LN217@more_maken

; 3752 :             { listtop--;

	mov	eax, DWORD PTR _listtop

; 3753 :               list[listtop].op1.real = 1./list[listtop].op1.real;

	fld1
	mov	ecx, DWORD PTR _list
	sub	eax, edi
	mov	DWORD PTR _listtop, eax
	imul	eax, 168				; 000000a8H
	fdiv	QWORD PTR [eax+ecx+32]
	lea	eax, DWORD PTR [eax+ecx+32]
	pop	edi
	pop	esi
	pop	ebx
	fstp	QWORD PTR [eax]

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN217@more_maken:

; 3754 :             }
; 3755 :             else
; 3756 :             { list[listtop].type = INV_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10161		; 000027b1H

; 3757 :               list[listtop].left = left - listtop;
; 3758 :               list[listtop].stack_delta = 0;
; 3759 :             }
; 3760 :             break;

	jmp	$LN478@more_maken
$LN218@more_maken:

; 3761 :           }
; 3762 : 
; 3763 :           /* general */
; 3764 :           if ( is_constant(left) )

	call	_is_constant

; 3770 :              list[listtop].type = PUSHCONST_NODE;

	mov	ecx, DWORD PTR _list
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _listtop
	je	$LN215@more_maken

; 3765 :           { /* fold constants */
; 3766 :              int k;
; 3767 :              REAL x;
; 3768 : 
; 3769 :              listtop -= 2;

	sub	eax, 2
	mov	DWORD PTR _listtop, eax

; 3770 :              list[listtop].type = PUSHCONST_NODE;

	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10095		; 0000276fH

; 3771 :              list[listtop].stack_delta = 1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], edi

; 3772 :              if ( left != listtop )

	cmp	esi, DWORD PTR _listtop
	je	SHORT $LN214@more_maken

; 3773 :                kb_error(1434,"Internal error: Constant folding not working.",
; 3774 :                  COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CO@GPMAMBBE@Internal?5error?3?5Constant?5folding@
	push	1434					; 0000059aH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN214@more_maken:

; 3775 :              x = list[left].op1.real;

	mov	ecx, esi
	mov	esi, DWORD PTR _list
	imul	ecx, 168				; 000000a8H

; 3776 :              for ( k = 1 ; k < abs(n) ; k++ )

	mov	eax, ebx
	fld	QWORD PTR [esi+ecx+32]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 1
	jle	SHORT $LN447@more_maken
	lea	edx, DWORD PTR [eax-1]
	cmp	edx, 4
	jl	SHORT $LC401@more_maken

; 3777 :                list[left].op1.real *= x;

	lea	edx, DWORD PTR [eax-5]
	shr	edx, 2
	inc	edx
	lea	edi, DWORD PTR [edx*4+1]
$LN413@more_maken:
	dec	edx
	fld	ST(0)
	fmul	QWORD PTR [ecx+esi+32]
	fstp	QWORD PTR [ecx+esi+32]
	mov	esi, DWORD PTR _list
	fld	ST(0)
	fmul	QWORD PTR [ecx+esi+32]
	fstp	QWORD PTR [ecx+esi+32]
	mov	esi, DWORD PTR _list
	fld	ST(0)
	fmul	QWORD PTR [ecx+esi+32]
	fstp	QWORD PTR [ecx+esi+32]
	mov	esi, DWORD PTR _list
	fld	ST(0)
	fmul	QWORD PTR [ecx+esi+32]
	fstp	QWORD PTR [ecx+esi+32]
	mov	esi, DWORD PTR _list
	jne	SHORT $LN413@more_maken
$LC401@more_maken:

; 3776 :              for ( k = 1 ; k < abs(n) ; k++ )

	cmp	edi, eax
	jge	SHORT $LN447@more_maken
	sub	eax, edi
$LC213@more_maken:
	dec	eax

; 3777 :                list[left].op1.real *= x;

	fld	ST(0)
	fmul	QWORD PTR [ecx+esi+32]
	fstp	QWORD PTR [ecx+esi+32]
	mov	esi, DWORD PTR _list
	jne	SHORT $LC213@more_maken
$LN447@more_maken:

; 3776 :              for ( k = 1 ; k < abs(n) ; k++ )

	fstp	ST(0)

; 3778 :              if ( n < 0 )

	test	ebx, ebx
	jns	$LN333@more_maken

; 3779 :                list[left].op1.real = 1/list[left].op1.real;

	fld1
	pop	edi
	fdiv	QWORD PTR [esi+ecx+32]
	fstp	QWORD PTR [esi+ecx+32]
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN215@more_maken:

; 3780 :              break;
; 3781 :           }
; 3782 :           listtop--; /* pop constant power */

	sub	eax, edi
	mov	DWORD PTR _listtop, eax

; 3783 :           list[listtop].left = left - listtop;

	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], esi

; 3784 :           list[listtop].op1.intpow = n;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], ebx

; 3785 :           list[listtop].type = INTPOW_NODE;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+edx], 10130		; 00002792H
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN434@more_maken:

; 3718 :         if ( floor(p) == p )

	fstp	ST(0)
$LN227@more_maken:

; 3786 :           break;
; 3787 :         }
; 3788 :       }
; 3789 :       if ( is_constant(right) && is_constant(left) )

	push	edi
	call	_is_constant
	mov	ebx, DWORD PTR _left$[ebp]
	add	esp, 4
	test	eax, eax
	je	$LN209@more_maken
	push	ebx
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	$LN209@more_maken

; 3790 :         { /* fold constants */
; 3791 :           listtop -= 2;

	mov	esi, DWORD PTR _listtop
	sub	esi, 2
	mov	DWORD PTR _listtop, esi

; 3792 :           if ( (left != listtop) || (right != listtop+1) )

	cmp	ebx, esi
	jne	SHORT $LN207@more_maken
	lea	eax, DWORD PTR [esi+1]
	cmp	edi, eax
	je	SHORT $LN208@more_maken
$LN207@more_maken:

; 3793 :              kb_error(1435,"Internal error: Constant folding not working.",
; 3794 :                 COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CO@GPMAMBBE@Internal?5error?3?5Constant?5folding@
	push	1435					; 0000059bH
	call	_kb_error
	mov	esi, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN208@more_maken:

; 3795 :           list[listtop].op1.real = 
; 3796 :               pow(list[left].op1.real,list[right].op1.real);

	mov	eax, DWORD PTR _list
	imul	ebx, 168				; 000000a8H
	imul	edi, 168				; 000000a8H
	fld	QWORD PTR [ebx+eax+32]
	fld	QWORD PTR [edi+eax+32]
	call	__CIpow
	imul	esi, 168				; 000000a8H
	mov	ecx, DWORD PTR _list
	pop	edi
	fstp	QWORD PTR [esi+ecx+32]

; 3797 :           list[listtop].type = PUSHCONST_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10095		; 0000276fH

; 3798 :           list[listtop].stack_delta = 1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	pop	esi
	mov	DWORD PTR [ecx+edx+156], 1
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN209@more_maken:

; 3799 :           break;
; 3800 :         }
; 3801 :       list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edi

; 3802 :       list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	ebx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ebx

; 3803 :       list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi
$LN487@more_maken:

; 3804 :       list[listtop].stack_delta = -1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], -1

; 3805 :       list[listtop].datatype = REAL_TYPE;
; 3806 :       break;

	jmp	$LN468@more_maken
$LN151@more_maken:

; 3983 : 
; 3984 :     case IMOD_NODE:
; 3985 :         if ( is_constant(right) && is_constant(left) )

	mov	esi, DWORD PTR _right$[ebp]
	push	esi
	call	_is_constant
	mov	edi, DWORD PTR _left$[ebp]
	add	esp, 4
	test	eax, eax
	je	$LN150@more_maken
	push	edi
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	$LN150@more_maken

; 3986 :         { /* fold constants */
; 3987 :           listtop -= 2;

	mov	ebx, DWORD PTR _listtop
	sub	ebx, 2
	mov	DWORD PTR _listtop, ebx

; 3988 :           if ( (left != listtop) || (right != listtop+1) )

	cmp	edi, ebx
	jne	SHORT $LN148@more_maken
	lea	eax, DWORD PTR [ebx+1]
	cmp	esi, eax
	je	SHORT $LN149@more_maken
$LN148@more_maken:

; 3989 :              kb_error(1444,"Internal error: Constant folding not working.",
; 3990 :                COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CO@GPMAMBBE@Internal?5error?3?5Constant?5folding@
	push	1444					; 000005a4H
	call	_kb_error
	mov	ebx, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN149@more_maken:

; 3991 :           list[listtop].op1.real = floor(list[left].op1.real) - 
; 3992 :               floor(floor(list[left].op1.real)/floor(list[right].op1.real))
; 3993 :               *floor(list[right].op1.real);

	mov	ecx, DWORD PTR _list
	imul	edi, 168				; 000000a8H
	sub	esp, 8
	fld	QWORD PTR [edi+ecx+32]
	fstp	QWORD PTR [esp]
	call	_floor
	imul	esi, 168				; 000000a8H
	fstp	QWORD PTR tv4309[ebp]
	mov	edi, DWORD PTR _list
	fld	QWORD PTR [esi+edi+32]
	fstp	QWORD PTR [esp]
	call	_floor
	fst	QWORD PTR tv4310[ebp]
	fdivr	QWORD PTR tv4309[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	fmul	QWORD PTR tv4310[ebp]
	add	esp, 8
	fsubr	QWORD PTR tv4309[ebp]
$LN488@more_maken:
	imul	ebx, 168				; 000000a8H
	fstp	QWORD PTR [ebx+edi+32]

; 3994 :           list[listtop].type = PUSHCONST_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10095		; 0000276fH

; 3995 :           list[listtop].stack_delta = 1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], 1

; 3996 :         }
; 3997 :         else

	jmp	$LN468@more_maken
$LN150@more_maken:

; 3998 :         { list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], esi

; 3999 :           list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], edi

; 4000 :           list[listtop].type = IMOD_NODE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10128		; 00002790H

; 4001 :           list[listtop].stack_delta = -1;
; 4002 :         }
; 4003 :         list[listtop].datatype = REAL_TYPE;
; 4004 :         break;

	jmp	$LN487@more_maken
$LN146@more_maken:

; 4005 : 
; 4006 :     case IDIV_NODE:
; 4007 :         if ( is_constant(right) && is_constant(left) )

	mov	esi, DWORD PTR _right$[ebp]
	push	esi
	call	_is_constant
	mov	edi, DWORD PTR _left$[ebp]
	add	esp, 4
	test	eax, eax
	je	$LN145@more_maken
	push	edi
	call	_is_constant
	add	esp, 4
	test	eax, eax
	je	SHORT $LN145@more_maken

; 4008 :         { /* fold constants */
; 4009 :           listtop -= 2;

	mov	ebx, DWORD PTR _listtop
	sub	ebx, 2
	mov	DWORD PTR _listtop, ebx

; 4010 :           if ( (left != listtop) || (right != listtop+1) )

	cmp	edi, ebx
	jne	SHORT $LN143@more_maken
	lea	eax, DWORD PTR [ebx+1]
	cmp	esi, eax
	je	SHORT $LN144@more_maken
$LN143@more_maken:

; 4011 :              kb_error(1445,"Internal error: Constant folding not working.",
; 4012 :                COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CO@GPMAMBBE@Internal?5error?3?5Constant?5folding@
	push	1445					; 000005a5H
	call	_kb_error
	mov	ebx, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN144@more_maken:

; 4013 :           list[listtop].op1.real = 
; 4014 :               (int)(list[left].op1.real)/(int)(list[right].op1.real);

	mov	ecx, DWORD PTR _list
	imul	edi, 168				; 000000a8H
	fld	QWORD PTR [edi+ecx+32]
	call	__ftol2_sse
	imul	esi, 168				; 000000a8H
	mov	edi, DWORD PTR _list
	mov	DWORD PTR tv5225[ebp], eax
	fld	QWORD PTR [esi+edi+32]
	call	__ftol2_sse
	mov	ecx, eax
	mov	eax, DWORD PTR tv5225[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR tv3651[ebp], eax
	fild	DWORD PTR tv3651[ebp]

; 4015 :           list[listtop].type = PUSHCONST_NODE;
; 4016 :           list[listtop].stack_delta = 1;
; 4017 :         }
; 4018 :         else

	jmp	$LN488@more_maken
$LN145@more_maken:

; 4019 :         { list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], esi

; 4020 :           list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], edi

; 4021 :           list[listtop].type = IDIV_NODE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10129		; 00002791H

; 4022 :           list[listtop].stack_delta = -1;
; 4023 :         }
; 4024 :         list[listtop].datatype = REAL_TYPE;
; 4025 :         break;

	jmp	$LN487@more_maken
$LN141@more_maken:

; 4026 : 
; 4027 :     case PUSHPARAM_NODE:
; 4028 :         if ( maxp == 0 )

	cmp	DWORD PTR _maxp, 0
	jne	SHORT $LN140@more_maken

; 4029 :           kb_error(1446,"Constant expression required.\n",EXPRESSION_ERROR);

	push	4
	push	OFFSET ??_C@_0BP@MONDKFGG@Constant?5expression?5required?4?6?$AA@
	push	1446					; 000005a6H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN140@more_maken:

; 4030 :         list[listtop].type = PUSHPARAM_NODE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10109		; 0000277dH

; 4031 :         list[listtop].op1.coordnum = n = coord_num-1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _coord_num
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _list
	dec	eax
	mov	DWORD PTR [edx+ecx+32], eax

; 4032 :         if ( (n < 0) || (n >= maxp) )

	test	eax, eax
	js	SHORT $LN138@more_maken
	cmp	eax, DWORD PTR _maxp
	jl	$LN465@more_maken
$LN138@more_maken:

; 4033 :         {
; 4034 :           sprintf(errmsg,"Coordinate number too high: %d\n",n+1);

	inc	eax
	push	eax
	push	OFFSET ??_C@_0CA@IOKNLDFI@Coordinate?5number?5too?5high?3?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4035 :           kb_error(1447,errmsg,EXPRESSION_ERROR);

	push	4
	push	OFFSET _errmsg
	push	1447					; 000005a7H
	call	_kb_error
	add	esp, 24					; 00000018H

; 4036 :         }
; 4037 :         list[listtop].stack_delta = 1;
; 4038 :         list[listtop].datatype = REAL_TYPE;
; 4039 :         break;

	jmp	$LN465@more_maken
$LN137@more_maken:

; 4040 : 
; 4041 :     case USERFUNC_NODE:
; 4042 :          list[listtop].type = USERFUNC_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10110		; 0000277eH

; 4043 :          list[listtop].op1.userfunc = (NTYPE)int_val-1;

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _int_val
	imul	edx, 168				; 000000a8H
	mov	eax, DWORD PTR _list
	dec	ecx
	mov	DWORD PTR [edx+eax+32], ecx

; 4044 :          if ( int_val < 1 || (userfunc[int_val-1] == NULL) )

	mov	eax, DWORD PTR _int_val
	mov	esi, 1
	cmp	eax, esi
	jl	SHORT $LN135@more_maken
	cmp	DWORD PTR _userfunc[eax*4-4], 0
	jne	SHORT $LN136@more_maken
$LN135@more_maken:

; 4045 :          { sprintf(errmsg,"Invalid user function number: %d\n",int_val);

	push	eax
	push	OFFSET ??_C@_0CC@HFNHMOA@Invalid?5user?5function?5number?3?5?$CFd@
	push	OFFSET _errmsg
	call	_sprintf

; 4046 :            kb_error(1448,errmsg,EXPRESSION_ERROR);

	push	4
	push	OFFSET _errmsg
	push	1448					; 000005a8H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN136@more_maken:

; 4047 :          }     
; 4048 :          list[listtop].stack_delta = 1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], esi

; 4049 :          list[listtop].datatype = REAL_TYPE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	pop	edi
	mov	DWORD PTR [eax+ecx+20], esi
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN116@more_maken:

; 4143 : 
; 4144 :     case DYNAMIC_LOAD_FUNC_NODE:
; 4145 :          list[listtop].type = DYNAMIC_LOAD_FUNC_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 4146 :          list[listtop].op1.funcptr = globals(left)->value.funcptr;

	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [edx+eax], 10111		; 0000277fH
	mov	eax, ecx
	and	eax, -16777216				; ff000000H
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN346@more_maken
	mov	eax, DWORD PTR _web+5652
	mov	edx, ecx
	and	edx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
	jmp	SHORT $LN343@more_maken
$LN346@more_maken:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN344@more_maken
	mov	edx, DWORD PTR _localbase
	mov	eax, ecx
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN343@more_maken
$LN344@more_maken:
	cmp	eax, 536870912				; 20000000H
	mov	eax, ecx
	jne	SHORT $LN342@more_maken
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN343@more_maken
$LN342@more_maken:
	mov	edx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx]
$LN343@more_maken:
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR [eax+64]
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR _list
	mov	DWORD PTR [edx+esi+32], eax

; 4147 :          list[listtop].op2.name_id = left;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+136], ecx

; 4148 :          list[listtop].stack_delta = 1;
; 4149 :          list[listtop].datatype = REAL_TYPE;
; 4150 :          break;

	jmp	$LN463@more_maken
$LN114@more_maken:

; 4151 : 
; 4152 :     case PUSHDELTA_NODE:
; 4153 :     case PUSH_PARAM_SCALE_NODE:
; 4154 :     case PUSH_PARAM_FIXED_NODE:
; 4155 :     case PUSH_PARAM_VELOCITY_NODE:
; 4156 :     case PUSH_PARAM_FORCE_NODE:
; 4157 :          list[listtop].type = type;
; 4158 :          list[listtop].op1.name_id = left;
; 4159 :          list[listtop].flags |= EPHEMERAL;
; 4160 :          list[listtop].stack_delta = 1;
; 4161 :          list[listtop].datatype = REAL_TYPE;
; 4162 :          break;
; 4163 : 
; 4164 :     case PUSH_PARAM_EXTRA_NODE:  
; 4165 :          if ( (right != V_VELOCITY_ATTR) && (right != V_FORCE_ATTR) )

	mov	edi, DWORD PTR _right$[ebp]
	cmp	edi, 4
	je	SHORT $LN113@more_maken
	cmp	edi, 3
	je	SHORT $LN113@more_maken

; 4166 :            kb_error(2473,"Illegal attribute of variable.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CA@HCCILBNN@Illegal?5attribute?5of?5variable?4?6?$AA@
	push	2473					; 000009a9H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN113@more_maken:

; 4167 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 4168 :          list[listtop].op1.name_id = left; /* which parameter */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [edx+eax+32], ecx

; 4169 :          list[listtop].op2.extranum = right; /* which attribute */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+136], edi

; 4170 :          list[listtop].flags |= EPHEMERAL;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	or	DWORD PTR [ecx+edx+24], 64		; 00000040H
	lea	eax, DWORD PTR [ecx+edx+24]

; 4171 :          list[listtop].stack_delta = 1;
; 4172 :          list[listtop].datatype = REAL_TYPE;
; 4173 :          break;

	jmp	$LN463@more_maken
$LN112@more_maken:

; 4174 : 
; 4175 :     case PUSHGLOBAL_NODE:
; 4176 :        { 
; 4177 :          struct global *g = globals(left);

	mov	ecx, DWORD PTR _left$[ebp]
	mov	eax, ecx
	and	eax, -16777216				; ff000000H
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN352@more_maken
	mov	edx, DWORD PTR _web+5652
	mov	eax, ecx
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+edx]
	jmp	SHORT $LN349@more_maken
$LN352@more_maken:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN350@more_maken
	mov	eax, DWORD PTR _localbase
	mov	esi, ecx
	and	esi, 16777215				; 00ffffffH
	imul	esi, 224				; 000000e0H
	add	esi, DWORD PTR [eax]
	jmp	SHORT $LN349@more_maken
$LN350@more_maken:
	mov	edx, ecx
	and	edx, 16777215				; 00ffffffH
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN348@more_maken
	mov	eax, DWORD PTR _web+5656
	mov	esi, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN349@more_maken
$LN348@more_maken:
	mov	eax, DWORD PTR _web+5652
	lea	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax]
$LN349@more_maken:

; 4178 :          list[listtop].type = PUSHGLOBAL_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10102		; 00002776H

; 4179 :          list[listtop].op1.name_id = left;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], ecx

; 4180 :          list[listtop].flags |= EPHEMERAL;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	or	DWORD PTR [edx+eax+24], 64		; 00000040H

; 4181 :          if ( (g->flags & METHOD_NAME) && reading_comp_quant_flag )

	test	DWORD PTR [esi+192], 1024		; 00000400H
	lea	eax, DWORD PTR [edx+eax+24]
	je	SHORT $LN111@more_maken
	cmp	DWORD PTR _reading_comp_quant_flag, 0
	je	SHORT $LN111@more_maken

; 4182 :          { struct method_instance *mi=METH_INSTANCE(left);

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 4183 :            mi->flags |= Q_COMPOUND;
; 4184 :            quant_flags[basic_gen_methods[mi->gen_method].type] 
; 4185 :             |= GEN_QUANT(cur_quant)->flags &
; 4186 :                      (Q_ENERGY|Q_FIXED|Q_INFO|Q_CONSERVED);
; 4187 :            attach_method_num(cur_quant,left);

	push	ecx
	or	DWORD PTR [eax+140], 256		; 00000100H
	mov	eax, DWORD PTR [eax+148]
	mov	ebx, DWORD PTR _gen_quant_list
	lea	edx, DWORD PTR [eax+eax*4]
	shl	edx, 5
	mov	eax, DWORD PTR _basic_gen_methods[edx+128]
	mov	edx, DWORD PTR _cur_quant
	mov	edi, edx
	imul	edi, 368				; 00000170H
	mov	edi, DWORD PTR [edi+ebx+136]
	and	edi, 15					; 0000000fH
	or	DWORD PTR _web[eax*4+5628], edi
	push	edx
	call	_attach_method_num
	add	esp, 8
$LN111@more_maken:

; 4188 :          }
; 4189 :          list[listtop].datatype = (g->type <= MAX_NUMERIC_TYPE) ? REAL_TYPE :
; 4190 :            g->type;

	mov	esi, DWORD PTR [esi+200]
	cmp	esi, 10					; 0000000aH
	jg	SHORT $LN354@more_maken
	mov	esi, 1
$LN354@more_maken:
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+20], esi

; 4191 :          list[listtop].stack_delta = 1;
; 4192 :          break;

	jmp	$LN477@more_maken
$LN110@more_maken:

; 4193 :        }
; 4194 :      
; 4195 :     case PUSH_PERM_GLOBAL_NODE:
; 4196 :     case PERM_STRINGGLOBAL_NODE:
; 4197 :        { struct global *g;
; 4198 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H

; 4199 :          list[listtop].op1.name_id = left;

	mov	eax, DWORD PTR _left$[ebp]
	mov	DWORD PTR [ecx+edx], esi
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+32], eax

; 4200 :          list[listtop].stack_delta = 1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], 1

; 4201 :          g = globals(left);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN356@more_maken
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN358@more_maken
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN357@more_maken
$LN358@more_maken:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN356@more_maken
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN357@more_maken
$LN356@more_maken:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN357@more_maken:

; 4202 :          list[listtop].datatype = g->type <= MAX_NUMERIC_TYPE ? REAL_TYPE :
; 4203 :             g->type;

	mov	eax, DWORD PTR [eax+200]
	cmp	eax, 10					; 0000000aH
	jg	$LN362@more_maken
	mov	eax, 1

; 4204 :          break;

	jmp	$LN362@more_maken
$LN109@more_maken:

; 4205 :        }
; 4206 :        
; 4207 :     case PERM_PROCEDURE_NODE:
; 4208 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 4209 :          list[listtop].op1.name_id = left;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _left$[ebp]
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _list
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+ecx+32], eax
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN108@more_maken:

; 4210 :          break;
; 4211 : 
; 4212 :     case STRINGGLOBAL_NODE:
; 4213 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], esi

; 4214 :          list[listtop].op1.name_id = left;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	eax, DWORD PTR _left$[ebp]
	mov	DWORD PTR [ecx+edx+32], eax

; 4215 :          list[listtop].flags |= EPHEMERAL;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	or	DWORD PTR [ecx+edx+24], 64		; 00000040H
	lea	eax, DWORD PTR [ecx+edx+24]

; 4216 :          list[listtop].stack_delta = 1;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+156], 1

; 4217 :          list[listtop].datatype = STRING_TYPE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+eax+20], 11		; 0000000bH
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN107@more_maken:

; 4218 :          break;
; 4219 : 
; 4220 :     case PROCEDURE_NODE:
; 4221 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], esi

; 4222 :          list[listtop].op1.name_id = left;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	edx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax+ecx+32], edx

; 4223 :          list[listtop].flags |= EPHEMERAL;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	or	DWORD PTR [eax+ecx+24], 64		; 00000040H
	pop	edi
	lea	eax, DWORD PTR [eax+ecx+24]
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN104@more_maken:

; 4238 :          break;
; 4239 : 
; 4240 :         
; 4241 :         
; 4242 :     case ON_CONSTRAINT_NODE:
; 4243 :     case HIT_CONSTRAINT_NODE:
; 4244 :     case ON_BOUNDARY_NODE:
; 4245 :     case CONSTRAINT_VALUE_NODE:
; 4246 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 4247 :          list[listtop].left = left - listtop;

	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [edx+eax], esi
	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx

; 4248 :          list[listtop].flags |= EPHEMERAL;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	or	DWORD PTR [eax+ecx+24], 64		; 00000040H
	lea	eax, DWORD PTR [eax+ecx+24]

; 4249 :          list[listtop].stack_delta = 0;
; 4250 :          list[listtop].datatype = REAL_TYPE;
; 4251 :          break;

	jmp	$LN469@more_maken
$LN103@more_maken:

; 4252 : 
; 4253 :     case ON_CONSTRAINT_NAME_NODE:
; 4254 :     case HIT_CONSTRAINT_NAME_NODE:
; 4255 :     case CONSTRAINT_NAME_VALUE_NODE:
; 4256 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 4257 :          list[listtop].op3.connum = globals(left)->value.cnum; 

	mov	eax, DWORD PTR _left$[ebp]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN370@more_maken
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN372@more_maken
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN371@more_maken
$LN372@more_maken:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN370@more_maken
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN371@more_maken
$LN370@more_maken:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN371@more_maken:
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR [eax+64]
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _list
	mov	DWORD PTR [edx+ecx+140], eax

; 4258 :                                      /* actual constraint number */
; 4259 :          list[listtop].flags |= EPHEMERAL;
; 4260 :          list[listtop].stack_delta = 1;
; 4261 :          list[listtop].datatype = REAL_TYPE;
; 4262 :          break;

	jmp	$LN486@more_maken
$LN101@more_maken:

; 4263 : 
; 4264 :     case ON_BOUNDARY_NAME_NODE:
; 4265 :          list[listtop].type = type;
; 4266 :          list[listtop].op3.bdrynum = globals(left)->value.bnum;
; 4267 :          list[listtop].flags |= EPHEMERAL;
; 4268 :          list[listtop].stack_delta = 1;
; 4269 :          list[listtop].datatype = REAL_TYPE;
; 4270 :          break;
; 4271 : 
; 4272 :     case ON_QUANTITY_NODE:
; 4273 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 4274 :          list[listtop].op2.quant_id = left;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [edx+eax+136], ecx

; 4275 :          list[listtop].stack_delta = 1;
; 4276 :          list[listtop].datatype = REAL_TYPE;
; 4277 :          break;

	jmp	$LN465@more_maken
$LN100@more_maken:

; 4278 : 
; 4279 :     case ON_METHOD_INSTANCE_NODE:
; 4280 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], esi

; 4281 :          list[listtop].op2.meth_id = left;

	mov	eax, DWORD PTR _left$[ebp]

; 4282 :          list[listtop].stack_delta = 1;
; 4283 :          list[listtop].datatype = REAL_TYPE;
; 4284 :          break;

	jmp	$LN485@more_maken
$LN99@more_maken:

; 4285 : 
; 4286 :     case INDEXED_COORD_NODE:
; 4287 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 4288 :          list[listtop].left = left - listtop;   

	mov	eax, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	mov	edx, eax

; 4289 :          if ( list[left].op5.indexcount != 1 )

	imul	eax, 168				; 000000a8H
	sub	edx, ecx
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+esi+4], edx
	mov	ecx, DWORD PTR _list
	mov	esi, 1
	cmp	DWORD PTR [eax+ecx+152], esi
	je	SHORT $LN98@more_maken

; 4290 :            kb_error(2568,"Coordinate can have only one index.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CF@PPIHGAA@Coordinate?5can?5have?5only?5one?5ind@
	push	2568					; 00000a08H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN98@more_maken:

; 4291 :          list[listtop].datatype = REAL_TYPE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	pop	edi
	mov	DWORD PTR [edx+eax+20], esi
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN97@more_maken:

; 4292 :          break;
; 4293 : 
; 4294 :     case PRINT_VERTEXNORMAL_NODE:
; 4295 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], esi

; 4296 :          list[listtop].left = left - listtop;    /* element */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _left$[ebp]
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+edx+4], ecx
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN96@more_maken:

; 4297 :          break;
; 4298 : 
; 4299 :     case GET_VERTEXNORMAL_NODE:
; 4300 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 4301 :          list[listtop].left = left - listtop;    /* index set */

	mov	eax, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	mov	edx, eax

; 4302 :          if ( list[left].op5.indexcount != 1 )

	imul	eax, 168				; 000000a8H
	sub	edx, ecx
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+esi+4], edx
	mov	ecx, DWORD PTR _list
	mov	esi, 1
	cmp	DWORD PTR [eax+ecx+152], esi
	je	$LN98@more_maken

; 4303 :            kb_error(2569,"Vertexnormal can have only one index.\n",
; 4304 :               COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CH@IBIBGHBN@Vertexnormal?5can?5have?5only?5one?5i@
	push	2569					; 00000a09H
	call	_kb_error

; 4305 :          list[listtop].datatype = REAL_TYPE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	add	esp, 12					; 0000000cH
	imul	edx, 168				; 000000a8H
	pop	edi
	mov	DWORD PTR [edx+eax+20], esi
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN89@more_maken:

; 4346 :             }
; 4347 :             break;
; 4348 : 
; 4349 :      case QUALIFIED_ATTRIBUTE_NODE:
; 4350 :           list[listtop].type = QUALIFIED_ATTRIBUTE_NODE;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H

; 4351 :           list[listtop].left = left-listtop;

	mov	eax, DWORD PTR _left$[ebp]
	mov	DWORD PTR [ecx+edx], 10238		; 000027feH
	mov	ecx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	mov	edx, eax

; 4352 :           list[listtop].right = right-listtop;
; 4353 :           list[listtop].datatype = REAL_TYPE;
; 4354 :           etype = list[left].op1.eltype; /* element type */

	imul	eax, 168				; 000000a8H
	sub	edx, ecx
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+esi+4], edx
	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _right$[ebp]
	mov	edi, DWORD PTR _list
	mov	esi, ecx

; 4355 :           /* element type error checking */
; 4356 :           check_element_type(list[right].type,etype);

	imul	ecx, 168				; 000000a8H
	sub	esi, edx
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+edi+8], esi
	mov	edx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+esi+20], 1
	mov	edx, DWORD PTR _list
	mov	eax, DWORD PTR [eax+edx+32]
	mov	ecx, DWORD PTR [ecx+edx]
	push	eax
	push	ecx
	call	_check_element_type
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@more_maken:

; 4585 :            } 
; 4586 :          }
; 4587 :          break;
; 4588 : 
; 4589 :      case EQ_NODE:
; 4590 :      case NE_NODE:
; 4591 :      case GE_NODE:
; 4592 :      case LE_NODE:
; 4593 :      case GT_NODE:
; 4594 :      case LT_NODE:
; 4595 :          list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR _list
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edx

; 4596 :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _left$[ebp]
	mov	ecx, DWORD PTR _list
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 4597 :          list[listtop].type = type;
; 4598 :          list[listtop].stack_delta = -1;
; 4599 :          list[listtop].datatype = REAL_TYPE;
; 4600 :          break;

	jmp	$LN476@more_maken
$LN3@more_maken:

; 4601 : 
; 4602 :      case AND_NODE:  /* for short-circuit evaluation, have to move test */
; 4603 :      case OR_NODE:    /* node between operands */
; 4604 :       { int top;
; 4605 :          top = listtop;

	mov	eax, DWORD PTR _listtop

; 4606 :          list[listtop].type = type;

	mov	edx, DWORD PTR _list
	mov	DWORD PTR _top$90908[ebp], eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx], esi

; 4607 :          subtree_swap(&right,&top);

	lea	eax, DWORD PTR _top$90908[ebp]
	push	eax
	lea	ecx, DWORD PTR _right$[ebp]
	push	ecx
	call	_subtree_swap

; 4608 :          list[top].right = right - top;

	mov	eax, DWORD PTR _top$90908[ebp]
	mov	esi, DWORD PTR _list
	mov	edx, DWORD PTR _right$[ebp]
	mov	ecx, eax
	imul	ecx, 168				; 000000a8H
	sub	edx, eax
	mov	DWORD PTR [ecx+esi+8], edx

; 4609 :          list[top].left = left - top;

	mov	esi, DWORD PTR _list
	mov	edx, DWORD PTR _left$[ebp]
	sub	edx, eax
	mov	DWORD PTR [ecx+esi+4], edx

; 4610 :          list[top].op1.skipsize = listtop - top;

	mov	edx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	sub	edx, eax
	mov	DWORD PTR [ecx+esi+32], edx

; 4611 :          listtop++;

	mov	ecx, DWORD PTR _listtop

; 4612 :          list[listtop].type = CONJUNCTION_END_NODE;

	mov	edx, DWORD PTR _list
	inc	ecx
	mov	DWORD PTR _listtop, ecx
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], 10119		; 00002787H

; 4613 :          list[listtop].left = top - listtop;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	eax, ecx
	add	esp, 8
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+4], eax

; 4614 :          list[listtop].stack_delta = -1;
; 4615 :          list[listtop].datatype = REAL_TYPE;
; 4616 :          break;

	jmp	$LN471@more_maken
$LN2@more_maken:

; 4617 :       }
; 4618 :      case NOT_NODE:
; 4619 :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _left$[ebp]
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx

; 4620 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 4621 :          list[listtop].datatype = REAL_TYPE;
; 4622 :          break;

	jmp	$LN470@more_maken
$LN134@more_maken:

; 4050 :          break;
; 4051 : 
; 4052 :     case VIEW_MATRIX_NODE:
; 4053 :          list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _right$[ebp]
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], ecx

; 4054 :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _left$[ebp]
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx

; 4055 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10395		; 0000289bH

; 4056 :          list[listtop].stack_delta = -1;
; 4057 :          list[listtop].datatype = REAL_TYPE;
; 4058 :          break;

	jmp	$LN487@more_maken
$LN385@more_maken:

; 3060 : 
; 3061 :   switch (type)

	cmp	esi, 10676				; 000029b4H
	jg	$LN386@more_maken
	je	$LN322@more_maken
	lea	eax, DWORD PTR [esi-10410]
	cmp	eax, 251				; 000000fbH
	ja	$LN1@more_maken
	movzx	eax, BYTE PTR $LN407@more_maken[eax]
	jmp	DWORD PTR $LN493@more_maken[eax*4]
$LN332@more_maken:

; 3062 :   {
; 3063 :     case QUOTATION_NODE:
; 3064 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], esi

; 3065 :          list[listtop].op1.string = 
; 3066 :             (char*)mycalloc(strlen(yytext)+1,sizeof(char));

	mov	eax, DWORD PTR _yytext
	lea	edx, DWORD PTR [eax+1]
$LL408@more_maken:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL408@more_maken
	push	3066					; 00000bfaH
	sub	eax, edx
	push	OFFSET ??_C@_0L@OKHAMMPH@YEXPARSE?4C?$AA@
	inc	eax
	push	1
	push	eax
	call	_kb_calloc
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+32], eax

; 3067 :          list[listtop].flags |= HAS_STRING;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	or	DWORD PTR [eax+ecx+24], 32		; 00000020H

; 3068 :          strcpy(list[listtop].op1.string,yytext);

	mov	edx, DWORD PTR _listtop
	lea	eax, DWORD PTR [eax+ecx+24]
	mov	eax, DWORD PTR _list
	mov	ecx, DWORD PTR _yytext
	add	esp, 16					; 00000010H
	imul	edx, 168				; 000000a8H
	mov	edx, DWORD PTR [edx+eax+32]
	npad	3
$LL337@more_maken:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL337@more_maken

; 3069 :          list[listtop].stack_delta = 1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], 1

; 3070 :          list[listtop].datatype = STRING_TYPE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+ecx+20], 11		; 0000000bH
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN318@more_maken:

; 3146 :          break;
; 3147 :       
; 3148 :     case SIZEOF_ATTR_NODE: /* current attribute dimension */
; 3149 :          list[listtop].type = SIZEOF_ATTR_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10420		; 000028b4H

; 3150 :          list[listtop].op1.extranum = left;  /* attr num */

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _left$[ebp]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _list
	mov	DWORD PTR [ecx+edx+32], eax

; 3151 :          list[listtop].op2.eltype = right; /* etype */

	mov	eax, DWORD PTR _right$[ebp]
$LN485@more_maken:
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+136], eax
$LN463@more_maken:

; 3152 :          list[listtop].stack_delta = 1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	eax, 1
	mov	DWORD PTR [ecx+edx+156], eax
$LN362@more_maken:

; 3153 :          list[listtop].datatype = REAL_TYPE;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+edx+20], eax
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN317@more_maken:

; 3154 :          break;
; 3155 : 
; 3156 :     case SIZEOF_ARRAY_NODE: /* current array total size */
; 3157 :          list[listtop].type = SIZEOF_ARRAY_NODE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10421		; 000028b5H
$LN466@more_maken:

; 3158 :          list[listtop].op1.name_id = left;  /* array id */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [edx+eax+32], ecx
$LN465@more_maken:

; 3159 :          list[listtop].stack_delta = 1;

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	eax, 1
	mov	DWORD PTR [edx+ecx+156], eax

; 3160 :          list[listtop].datatype = REAL_TYPE;

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+ecx+20], eax
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN316@more_maken:

; 3161 :          break;
; 3162 : 
; 3163 :     case SIZEOF_STRING_NODE: /* string length */
; 3164 :          list[listtop].type = SIZEOF_STRING_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 3165 :          list[listtop].left = left-listtop;  /* string expr */

	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [edx+eax], 10422		; 000028b6H
	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx

; 3166 :          list[listtop].stack_delta = 1;
; 3167 :          list[listtop].datatype = REAL_TYPE;
; 3168 :          break;

	jmp	$LN463@more_maken
$LN315@more_maken:

; 3169 : 
; 3170 : 
; 3171 :     case DEFINE_CONSTRAINT_NODE:
; 3172 :        { int old_verb_flag;
; 3173 :          struct treenode *old_list;
; 3174 :          int retval;
; 3175 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 3176 :          /* Parse-time evaluation and construction of quantity */
; 3177 : 	     datafile_flag = PRETEND_DATAFILE; 
; 3178 :          old_verb_flag = verb_flag; verb_flag = 0; 

	mov	edi, DWORD PTR _verb_flag

; 3179 :          old_list = list;

	mov	esi, DWORD PTR _list
	xor	ebx, ebx
	mov	DWORD PTR _datafile_flag, 2
	mov	DWORD PTR _verb_flag, ebx

; 3180 :          retval = read_constraint(); 

	call	_read_constraint
$LN467@more_maken:

; 3181 :          list = old_list;
; 3182 :          list[listtop].op1.con_id = retval;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR _list, esi
	mov	DWORD PTR [edx+esi+32], eax

; 3183 : 	     datafile_flag = NOT_DATAFILE;
; 3184 :          verb_flag = old_verb_flag;
; 3185 :          if ( tok == ';' ) /* in case reentrant parser ate ';' */

	cmp	DWORD PTR _tok, 59			; 0000003bH
	mov	DWORD PTR _datafile_flag, ebx
	mov	DWORD PTR _verb_flag, edi
	jne	$LN333@more_maken

; 3186 :             kb_unput(';');

	push	59					; 0000003bH
	call	_kb_unput
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN313@more_maken:

; 3187 :        }
; 3188 :          break;
; 3189 : 
; 3190 :     case DEFINE_BOUNDARY_NODE:
; 3191 :        { int old_verb_flag;
; 3192 :          int retval;
; 3193 :          struct treenode *old_list;
; 3194 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 3195 :          /* Parse-time evaluation and construction of quantity */
; 3196 : 		 datafile_flag = PRETEND_DATAFILE; old_verb_flag = verb_flag; verb_flag = 0; 

	mov	edi, DWORD PTR _verb_flag

; 3197 :          old_list = list;

	mov	esi, DWORD PTR _list
	xor	ebx, ebx
	mov	DWORD PTR _datafile_flag, 2
	mov	DWORD PTR _verb_flag, ebx

; 3198 :          retval = read_boundary(); 

	call	_read_boundary

; 3199 :          list = old_list;
; 3200 :          list[listtop].op1.bdry_id = retval;
; 3201 : 		 datafile_flag = NOT_DATAFILE;
; 3202 :          verb_flag = old_verb_flag;
; 3203 :          if ( tok == ';' ) /* in case reentrant parser ate ';' */
; 3204 :             kb_unput(';');
; 3205 :        }
; 3206 :          break;

	jmp	SHORT $LN467@more_maken
$LN311@more_maken:

; 3207 : 
; 3208 :     case DEFINE_QUANTITY_NODE:
; 3209 :        { int old_verb_flag;
; 3210 :          struct treenode *old_list;
; 3211 :          int retval;
; 3212 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 3213 :          /* Parse-time evaluation and construction of quantity */
; 3214 : 		 datafile_flag = 1; old_verb_flag = verb_flag; verb_flag = 0; 

	mov	edi, DWORD PTR _verb_flag

; 3215 :          old_list = list;

	mov	esi, DWORD PTR _list
	xor	ebx, ebx
	mov	DWORD PTR _datafile_flag, 1
	mov	DWORD PTR _verb_flag, ebx

; 3216 :          retval = read_quantity(); // calls exec(), so wipes "list" at exit

	call	_read_quantity

; 3217 :          list = old_list;
; 3218 :          list[listtop].op1.quant_id = retval;
; 3219 : 		 datafile_flag = 0;
; 3220 :          verb_flag = old_verb_flag;
; 3221 :          if ( tok == ';' ) /* in case reentrant parser ate ';' */
; 3222 :             kb_unput(';');
; 3223 :        }
; 3224 :          break;

	jmp	$LN467@more_maken
$LN309@more_maken:

; 3225 : 
; 3226 :     case DEFINE_METHOD_INSTANCE_NODE:
; 3227 :        { int old_verb_flag;
; 3228 :          int retval;
; 3229 :          struct treenode *old_list;
; 3230 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 3231 :          /* Parse-time evaluation and construction of quantity */
; 3232 : 		 datafile_flag = 1; old_verb_flag = verb_flag; verb_flag = 0; 

	mov	edi, DWORD PTR _verb_flag

; 3233 :          old_list = list;

	mov	esi, DWORD PTR _list
	xor	ebx, ebx
	mov	DWORD PTR _datafile_flag, 1
	mov	DWORD PTR _verb_flag, ebx

; 3234 :          retval = read_method_instance(); 

	call	_read_method_instance

; 3235 :          list = old_list;
; 3236 :          list[listtop].op1.quant_id = retval;
; 3237 : 		 datafile_flag = 0;
; 3238 :          verb_flag = old_verb_flag;
; 3239 :          if ( tok == ';' ) /* in case reentrant parser ate ';' */
; 3240 :             kb_unput(';');
; 3241 :        }
; 3242 :          break;

	jmp	$LN467@more_maken
$LN307@more_maken:

; 3243 : 
; 3244 :     case IS_DEFINED_NODE:
; 3245 :          /* Parse-time evaluation. */
; 3246 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H

; 3247 :          list[listtop].left = left-listtop; 

	mov	edx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax+ecx], esi
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx
$LN469@more_maken:

; 3248 :          list[listtop].stack_delta = 0;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], 0
$LN468@more_maken:

; 3249 :          list[listtop].datatype = REAL_TYPE;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+edx+20], 1
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN305@more_maken:

; 3258 : 
; 3259 :     case PUSH_NAMED_QUANTITY_NODE:
; 3260 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 3261 :          list[listtop].op1.quant_id = left;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [edx+eax+32], ecx
$LN486@more_maken:

; 3262 :          list[listtop].flags |= EPHEMERAL;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	or	DWORD PTR [edx+eax+24], 64		; 00000040H
	lea	eax, DWORD PTR [edx+eax+24]

; 3263 :          list[listtop].stack_delta = 1;
; 3264 :          list[listtop].datatype = REAL_TYPE;
; 3265 :          break;

	jmp	$LN463@more_maken
$LN300@more_maken:

; 3294 : 
; 3295 :     case DATE_AND_TIME_NODE:
; 3296 :     case EVOLVER_VERSION_NODE:
; 3297 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 3298 :          list[listtop].stack_delta = 1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], 1

; 3299 :          list[listtop].datatype = STRING_TYPE;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+edx+20], 11		; 0000000bH
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN299@more_maken:

; 3300 :          break;
; 3301 : 
; 3302 :     case TOGGLEVALUE_NODE:
; 3303 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 3304 :          list[listtop].op1.toggle_id = left; /* which toggle */
; 3305 :          list[listtop].stack_delta = 1;
; 3306 :          list[listtop].datatype = REAL_TYPE;
; 3307 :          break;

	jmp	$LN466@more_maken
$LN298@more_maken:

; 3308 : 
; 3309 :     case GET_TORUS_PERIODS_NODE:
; 3310 :     case GET_INVERSE_PERIODS_NODE:
; 3311 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 3312 :          list[listtop].left = left - listtop;

	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [edx+eax], esi
	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx

; 3313 :          list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _right$[ebp]
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], ecx
$LN471@more_maken:

; 3314 :          list[listtop].stack_delta = -1;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+156], -1
$LN470@more_maken:

; 3315 :          list[listtop].datatype = REAL_TYPE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+eax+20], 1
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN133@more_maken:

; 4059 : 
; 4060 :     case GET_INTERNAL_NODE:
; 4061 :          list[listtop].type = GET_INTERNAL_NODE;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], 10413		; 000028adH

; 4062 :          list[listtop].op1.name_id = left;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	edx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax+ecx+32], edx

; 4063 :          list[listtop].stack_delta = 1;
; 4064 :          list[listtop].datatype = REAL_TYPE;
; 4065 :          break;

	jmp	$LN463@more_maken
$LN131@more_maken:

; 4066 : 
; 4067 :     case PUSHQPRESSURE_NODE:
; 4068 :     case PUSHQTARGET_NODE:
; 4069 :     case PUSHQVALUE_NODE:
; 4070 :     case PUSHQMODULUS_NODE:
; 4071 :     case PUSHQTOLERANCE_NODE:
; 4072 :     case PUSHMMODULUS_NODE:
; 4073 :     case PUSHQVOLCONST_NODE:
; 4074 :     case PUSHQFIXED_NODE:
; 4075 :     case PUSHQENERGY_NODE:
; 4076 :     case PUSHQCONSERVED_NODE:
; 4077 :     case PUSHQINFO_ONLY_NODE:
; 4078 :          list[listtop].type = type;
; 4079 :          list[listtop].op1.quant_id = left;
; 4080 :          list[listtop].stack_delta = 1;
; 4081 :          list[listtop].datatype = REAL_TYPE;
; 4082 :          break;
; 4083 : 
; 4084 :     case PUSHMVALUE_NODE:
; 4085 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 4086 :          list[listtop].op1.meth_id = left;

	mov	ebx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [edx+eax], esi
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+32], ebx

; 4087 :          if ( reading_comp_quant_flag ) 

	cmp	DWORD PTR _reading_comp_quant_flag, 0
	je	$LN463@more_maken

; 4088 :          { int i;
; 4089 :            struct gen_quant *q = GEN_QUANT(cur_quant);

	mov	esi, DWORD PTR _cur_quant

; 4090 :            struct method_instance *mi = METH_INSTANCE(left);

	mov	eax, ebx
	imul	esi, 368				; 00000170H
	add	esi, DWORD PTR _gen_quant_list
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 4091 :            mi->flags |= Q_COMPOUND;
; 4092 : 
; 4093 :            /* see if in quantity's list */
; 4094 :            for ( i = 0 ; i < q->method_count ; i++ )

	xor	ecx, ecx
	or	DWORD PTR [eax+140], 256		; 00000100H
	mov	edx, DWORD PTR [esi+240]
	test	edx, edx
	jle	SHORT $LN419@more_maken

; 4088 :          { int i;
; 4089 :            struct gen_quant *q = GEN_QUANT(cur_quant);

	mov	edi, DWORD PTR [esi+244]
	npad	2
$LL129@more_maken:

; 4095 :              if ( q->meth_inst[i] == left ) 

	cmp	DWORD PTR [edi], ebx
	je	SHORT $LN419@more_maken

; 4091 :            mi->flags |= Q_COMPOUND;
; 4092 : 
; 4093 :            /* see if in quantity's list */
; 4094 :            for ( i = 0 ; i < q->method_count ; i++ )

	inc	ecx
	add	edi, 4
	cmp	ecx, edx
	jl	SHORT $LL129@more_maken
$LN419@more_maken:

; 4096 :                 break;
; 4097 :            if ( i == q->method_count )

	cmp	ecx, edx
	jne	$LN463@more_maken

; 4098 :            {  int j; 
; 4099 :               /* add to list */
; 4100 :               for ( j = 0 ; j < MMAXQUANTS ; j++ )

	xor	ecx, ecx
	lea	edx, DWORD PTR [eax+152]
	npad	4
$LL124@more_maken:

; 4101 :                  if ( mi->quants[j] == -1 )

	cmp	DWORD PTR [edx], -1
	je	SHORT $LN394@more_maken

; 4098 :            {  int j; 
; 4099 :               /* add to list */
; 4100 :               for ( j = 0 ; j < MMAXQUANTS ; j++ )

	inc	ecx
	add	edx, 4
	cmp	ecx, 8
	jl	SHORT $LL124@more_maken

; 4428 :                 if ( stricmp(ex->name,set_extra_name) == 0 ) break;

	jmp	SHORT $LN122@more_maken
$LN394@more_maken:

; 4102 :                  { mi->quants[j] = cur_quant;

	mov	edx, DWORD PTR _cur_quant
	mov	DWORD PTR [eax+ecx*4+152], edx

; 4103 :                    mi->quants_index[j] = q->method_count;

	mov	edx, DWORD PTR [esi+240]
	mov	DWORD PTR [eax+ecx*4+184], edx
$LN122@more_maken:

; 4104 :                    break;
; 4105 :                  }
; 4106 :               if ( j == MMAXQUANTS )

	cmp	ecx, 8
	jne	SHORT $LN120@more_maken

; 4107 :               { sprintf(errmsg,"'%s' attached to too many quantities. This version of Evolver permits only %d.\n",
; 4108 :                    mi->name,MMAXQUANTS);

	push	ecx
	push	eax
	push	OFFSET ??_C@_0FA@KPBJMLGF@?8?$CFs?8?5attached?5to?5too?5many?5quanti@
	push	OFFSET _errmsg
	call	_sprintf

; 4109 :                 kb_error(4865,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	4865					; 00001301H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN120@more_maken:

; 4110 :               }
; 4111 : 			  attach_method_num(cur_quant,left);

	mov	eax, DWORD PTR _cur_quant
	push	ebx
	push	eax
	call	_attach_method_num
	add	esp, 8

; 4112 :            }
; 4113 :          }
; 4114 :          list[listtop].stack_delta = 1;
; 4115 :          list[listtop].datatype = REAL_TYPE;
; 4116 :          break;

	jmp	$LN463@more_maken
$LN106@more_maken:

; 4224 :          break;
; 4225 : 
; 4226 :     case SET_CONSTRAINT_GLOBAL_NODE:
; 4227 :     case UNSET_CONSTRAINT_GLOBAL_NODE:
; 4228 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H

; 4229 :          list[listtop].left = left - listtop;

	mov	edx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax+ecx], esi
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 4230 :          list[listtop].stack_delta = -1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+eax+156], -1
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN105@more_maken:

; 4231 :          break;
; 4232 : 
; 4233 :     case SET_CONSTRAINT_NAME_GLOBAL_NODE:
; 4234 :     case UNSET_CONSTRAINT_NAME_GLOBAL_NODE:
; 4235 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], esi

; 4236 :          list[listtop].stack_delta = 0;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+156], 0

; 4237 :          list[listtop].op3.connum = globals(left)->value.cnum; 

	mov	eax, DWORD PTR _left$[ebp]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN364@more_maken
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN366@more_maken
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN365@more_maken
$LN366@more_maken:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN364@more_maken
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN365@more_maken
$LN364@more_maken:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN365@more_maken:
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR [eax+64]
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _list
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+ecx+140], eax
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN92@more_maken:

; 4324 :             }
; 4325 :             break;
; 4326 : 
; 4327 :      case PRINT_ATTR_ARRAY_NODE:  /* print element attribute array or slice */
; 4328 :             { struct extra *ex;
; 4329 :               int exnum;
; 4330 :               etype = int_val >> YYTYPESHIFT;

	mov	ecx, DWORD PTR _int_val
	mov	eax, ecx
	sar	eax, 25					; 00000019H

; 4331 :               exnum = int_val & YYSHIFTMASK;
; 4332 :               ex = EXTRAS(etype) + exnum;

	mov	edx, eax
	imul	edx, 112				; 00000070H
	and	ecx, 33554431				; 01ffffffH
	mov	edi, ecx
	mov	DWORD PTR _exnum$90771[ebp], ecx
	imul	edi, 240				; 000000f0H
	mov	ecx, DWORD PTR _web[edx+104]

; 4333 :               list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	add	ecx, edi
	mov	edi, DWORD PTR _list
	add	ecx, DWORD PTR _dymem
	mov	DWORD PTR [edx+edi], esi

; 4334 :               list[listtop].op5.indexcount = right ? list[right].op5.indexcount : 0; /* indices */

	mov	edx, DWORD PTR _right$[ebp]
	mov	edi, DWORD PTR _list
	test	edx, edx
	je	SHORT $LN382@more_maken
	mov	esi, edx
	imul	esi, 168				; 000000a8H
	mov	esi, DWORD PTR [esi+edi+152]
	jmp	SHORT $LN383@more_maken
$LN382@more_maken:
	xor	esi, esi
$LN383@more_maken:
	mov	ebx, DWORD PTR _listtop
	imul	ebx, 168				; 000000a8H
	mov	DWORD PTR [ebx+edi+152], esi

; 4335 :               list[listtop].op2.eltype = etype;

	mov	esi, DWORD PTR _listtop
	mov	edi, DWORD PTR _list
	imul	esi, 168				; 000000a8H
	mov	DWORD PTR [esi+edi+136], eax

; 4336 :               list[listtop].op3.extranum = exnum;  /* which extra */

	mov	eax, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	edi, DWORD PTR _exnum$90771[ebp]
	mov	DWORD PTR [eax+esi+140], edi

; 4337 :               list[listtop].left = left - listtop;  /* element */

	mov	eax, DWORD PTR _listtop
	mov	esi, DWORD PTR _left$[ebp]
	mov	edi, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edi+4], esi

; 4338 :               if ( right ) list[listtop].right = right - listtop;  /* index */

	test	edx, edx
	je	SHORT $LN91@more_maken
	mov	eax, DWORD PTR _listtop
	mov	edi, DWORD PTR _list
	mov	esi, edx
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edi+8], esi
$LN91@more_maken:

; 4339 :               if ( ex->array_spec.dim < list[right].op5.indexcount )

	mov	eax, DWORD PTR [ecx+76]
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR _list
	cmp	eax, DWORD PTR [edx+esi+152]
	jge	SHORT $LN90@more_maken

; 4340 :               { sprintf(errmsg,"Attribute %s must have at most %d indices.\n",
; 4341 :                  ex->name,ex->array_spec.dim);

	push	eax
	push	ecx
	push	OFFSET ??_C@_0CM@IJMBNBLJ@Attribute?5?$CFs?5must?5have?5at?5most?5?$CF@
	push	OFFSET _errmsg
	call	_sprintf

; 4342 :                 kb_error(2644,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	2644					; 00000a54H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN90@more_maken:

; 4343 :               }
; 4344 :               list[listtop].flags |= EPHEMERAL;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	or	DWORD PTR [ecx+edx+24], 64		; 00000040H
	lea	eax, DWORD PTR [ecx+edx+24]

; 4345 :               list[listtop].stack_delta = -list[listtop].op5.indexcount;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	edx, DWORD PTR [eax+ecx+152]
	pop	edi
	neg	edx
	pop	esi
	mov	DWORD PTR [eax+ecx+156], edx
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN78@more_maken:

; 4397 : 
; 4398 :      case SET_ATTRIBUTE_NODE:
; 4399 :      case SET_ATTRIBUTE_L_NODE:
; 4400 :      case SET_ATTRIBUTE_A_NODE:
; 4401 :           if ( elsym == NULL )

	cmp	DWORD PTR _elsym, 0
	jne	SHORT $LN77@more_maken

; 4402 :               kb_error(1477,"Don't have element for attribute to apply to.\n",
; 4403 :                     COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CP@EADLGAJE@Don?8t?5have?5element?5for?5attribute@
	push	1477					; 000005c5H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN77@more_maken:

; 4404 :           list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], esi

; 4405 :           if ( left ) list[listtop].left = left-listtop;  /* value */

	mov	eax, DWORD PTR _left$[ebp]
	test	eax, eax
	je	SHORT $LN76@more_maken
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	eax, ecx
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+4], eax
$LN76@more_maken:

; 4406 :           if ( right )

	mov	eax, DWORD PTR _right$[ebp]
	test	eax, eax
	je	SHORT $LN71@more_maken

; 4407 :           { /* index; check which attributes are legal */
; 4408 :             list[listtop].right = right-listtop;

	mov	edx, DWORD PTR _list
	mov	ecx, eax
	mov	eax, DWORD PTR _listtop
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], ecx

; 4409 :             switch ( attr_kind )

	mov	eax, DWORD PTR _attr_kind
	sub	eax, 10315				; 0000284bH
	je	SHORT $LN71@more_maken
	sub	eax, 11					; 0000000bH
	je	SHORT $LN71@more_maken
	sub	eax, 8
	je	SHORT $LN72@more_maken

; 4412 :                  break;
; 4413 :                case SET_COORD_1_NODE: case SET_PARAM_1_NODE: break;
; 4414 :                default: kb_error(1478,"Attribute is not indexed.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BL@LFPPAIJK@Attribute?5is?5not?5indexed?4?6?$AA@
	push	1478					; 000005c6H
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN71@more_maken
$LN72@more_maken:

; 4410 :              { case SET_EXTRA_ATTR_NODE: 
; 4411 :                  list[listtop].flags |= EPHEMERAL;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	or	DWORD PTR [eax+ecx+24], 64		; 00000040H
	lea	eax, DWORD PTR [eax+ecx+24]
$LN71@more_maken:

; 4415 :              }
; 4416 :           }
; 4417 :           list[listtop].op1.localnum = elsym->localnum; 

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _elsym
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [eax+68]
	mov	eax, DWORD PTR _list
	mov	DWORD PTR [edx+eax+32], ecx

; 4418 :           list[listtop].op2.attr_kind = attr_kind;

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _attr_kind
	mov	DWORD PTR [ecx+eax+136], edx

; 4419 :          /* to node */
; 4420 :           /* error checking on attributes and element types */
; 4421 :           etype = elsym->type;

	mov	ecx, DWORD PTR _elsym
	mov	ebx, DWORD PTR [ecx+64]

; 4422 :           switch ( attr_kind )

	mov	ecx, DWORD PTR _attr_kind
	lea	eax, DWORD PTR [ecx-10265]
	cmp	eax, 187				; 000000bbH
	ja	$LN15@more_maken
	movzx	edx, BYTE PTR $LN409@more_maken[eax]
	jmp	DWORD PTR $LN494@more_maken[edx*4]
$LN67@more_maken:

; 4423 :           {
; 4424 :             case SET_EXTRA_ATTR_NODE:
; 4425 :             { struct extra *ex;
; 4426 :               ex = EXTRAS(etype);

	mov	eax, ebx
	imul	eax, 112				; 00000070H
	mov	edi, DWORD PTR _web[eax+104]
	add	edi, DWORD PTR _dymem

; 4427 :               for ( n = 0 ; n < web.skel[etype].extra_count ; n++,ex++ )

	cmp	DWORD PTR _web[eax+108], 0
	mov	DWORD PTR tv4509[ebp], eax
	mov	DWORD PTR _n$[ebp], 0
	jle	SHORT $LN395@more_maken
$LL66@more_maken:

; 4428 :                 if ( stricmp(ex->name,set_extra_name) == 0 ) break;

	push	OFFSET _set_extra_name
	push	edi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN417@more_maken

; 4427 :               for ( n = 0 ; n < web.skel[etype].extra_count ; n++,ex++ )

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR tv4509[ebp]
	inc	eax
	add	edi, 240				; 000000f0H
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, DWORD PTR _web[ecx+108]
	jl	SHORT $LL66@more_maken
$LN417@more_maken:
	mov	eax, DWORD PTR tv4509[ebp]
$LN395@more_maken:

; 4429 :               if ( n == web.skel[etype].extra_count )

	mov	edx, DWORD PTR _n$[ebp]
	cmp	edx, DWORD PTR _web[eax+108]
	jne	SHORT $LN62@more_maken

; 4430 :               { sprintf(errmsg,"Invalid extra attribute name '%s'.\n",
; 4431 :                 set_extra_name);

	push	OFFSET _set_extra_name
	push	OFFSET ??_C@_0CE@CIKANACF@Invalid?5extra?5attribute?5name?5?8?$CFs@
	push	OFFSET _errmsg
	call	_sprintf

; 4432 :                 kb_error(1479,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	1479					; 000005c7H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN62@more_maken:

; 4433 :               }
; 4434 :               list[listtop].op3.extra_info = (etype << ESHIFT) + n;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	shl	ebx, 12					; 0000000cH
	add	ebx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+ecx+140], ebx

; 4435 :               if ( !(ex->flags & DIMENSIONED_ATTR) && right )

	mov	eax, DWORD PTR _right$[ebp]
	mov	bl, 4
	test	BYTE PTR [edi+232], bl
	jne	SHORT $LN490@more_maken
	test	eax, eax
	je	SHORT $LN61@more_maken

; 4436 :               { sprintf(errmsg,"Cannot use index with attribute '%s'.\n",ex->name);

	push	edi
	push	OFFSET ??_C@_0CH@NMIDINCN@Cannot?5use?5index?5with?5attribute?5@
	push	OFFSET _errmsg
	call	_sprintf

; 4437 :                 kb_error(2499,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	2499					; 000009c3H
	call	_kb_error
	mov	eax, DWORD PTR _right$[ebp]
	add	esp, 24					; 00000018H
$LN61@more_maken:

; 4438 :               }
; 4439 :               if ( (ex->flags & DIMENSIONED_ATTR) && !right )

	test	BYTE PTR [edi+232], bl
	je	SHORT $LN60@more_maken
$LN490@more_maken:
	test	eax, eax
	jne	SHORT $LN404@more_maken

; 4440 :               { sprintf(errmsg,"Must use index with attribute '%s'.\n",ex->name);

	push	edi
	push	OFFSET ??_C@_0CF@IFBIOELO@Must?5use?5index?5with?5attribute?5?8?$CF@
	push	OFFSET _errmsg
	call	_sprintf

; 4441 :                 kb_error(1481,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	1481					; 000005c9H
	call	_kb_error
	add	esp, 24					; 00000018H

; 4442 :               }
; 4443 :               if ( right && (list[right].op5.indexcount != ex->array_spec.dim) )

	jmp	SHORT $LN415@more_maken
$LN60@more_maken:
	test	eax, eax
	je	SHORT $LN415@more_maken
$LN404@more_maken:
	mov	ecx, DWORD PTR [edi+76]
	imul	eax, 168				; 000000a8H
	mov	edx, DWORD PTR _list
	cmp	DWORD PTR [eax+edx+152], ecx
	je	SHORT $LN415@more_maken

; 4444 :               { sprintf(errmsg,"Attribute '%s' has %d indexes.\n",
; 4445 :                      ex->name,ex->array_spec.dim);

	push	ecx
	push	edi
	push	OFFSET ??_C@_0CA@ELLFACCD@Attribute?5?8?$CFs?8?5has?5?$CFd?5indexes?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4446 :                 kb_error(2498,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	2498					; 000009c2H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN415@more_maken:

; 4447 :               }
; 4448 :             list[listtop].stack_delta = -1-ex->array_spec.dim;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	or	eax, -1
	sub	eax, DWORD PTR [edi+76]
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], eax

; 4449 :             }
; 4450 :             break;

	jmp	$LN15@more_maken
$LN58@more_maken:

; 4451 :           case SET_WRAP_NODE:
; 4452 :             if ( etype != EDGE )

	cmp	ebx, 1
	je	SHORT $LN57@more_maken

; 4453 :             kb_error(2239,"Wrap only for edges.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BG@MIBFLFMI@Wrap?5only?5for?5edges?4?6?$AA@
	push	2239					; 000008bfH
$LN458@more_maken:
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN57@more_maken:

; 4454 :             list[listtop].stack_delta = -1;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+156], -1

; 4455 :             break;

	jmp	$LN15@more_maken
$LN56@more_maken:

; 4456 :           case SET_COORD_NODE: case SET_COORD_1_NODE: case SET_COORD_2_NODE:
; 4457 :           case SET_COORD_3_NODE: case SET_COORD_4_NODE: case SET_COORD_5_NODE:
; 4458 :           case SET_COORD_6_NODE: case SET_COORD_7_NODE: case SET_COORD_8_NODE:
; 4459 :             if ( attr_kind-SET_COORD_1_NODE >= SDIM )

	add	ecx, -10315				; ffffd7b5H
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN55@more_maken

; 4460 :              kb_error(2543,"Coordinate dimension exceeds space dimension.\n",
; 4461 :                COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CP@EEKPMBAG@Coordinate?5dimension?5exceeds?5spa@
	push	2543					; 000009efH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN55@more_maken:

; 4462 :             if ( etype != VERTEX )

	test	ebx, ebx
	je	SHORT $LN54@more_maken

; 4463 :               kb_error(1482,"Coordinates only for vertices.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CA@HENHFIIN@Coordinates?5only?5for?5vertices?4?6?$AA@
	push	1482					; 000005caH
$LN459@more_maken:
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN54@more_maken:

; 4464 :             list[listtop].stack_delta = -1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], -1

; 4465 :             break;

	jmp	$LN15@more_maken
$LN53@more_maken:

; 4466 :           case SET_PARAM_NODE: case SET_PARAM_1_NODE: case SET_PARAM_2_NODE:
; 4467 :           case SET_PARAM_3_NODE: case SET_PARAM_4_NODE:
; 4468 :             if ( etype != VERTEX )

	test	ebx, ebx
	je	SHORT $LN52@more_maken

; 4469 :               kb_error(1483,"Boundary parameters only for vertices.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CI@JEPJACJN@Boundary?5parameters?5only?5for?5ver@
	push	1483					; 000005cbH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN52@more_maken:

; 4470 :             list[listtop].stack_delta = -1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], -1

; 4471 :             break;

	jmp	$LN15@more_maken
$LN51@more_maken:

; 4472 :           case SET_OPACITY_NODE:
; 4473 :             if ( etype != FACET )

	cmp	ebx, 2
	je	$LN57@more_maken

; 4474 :               kb_error(1485,"Opacity only for facets.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BK@NEICOOEL@Opacity?5only?5for?5facets?4?6?$AA@
	push	1485					; 000005cdH

; 4475 :             list[listtop].stack_delta = -1;
; 4476 :             break;

	jmp	$LN458@more_maken
$LN49@more_maken:

; 4477 :           case SET_FRONTCOLOR_NODE:
; 4478 :           case SET_BACKCOLOR_NODE:
; 4479 :             if ( (etype != FACET) )

	cmp	ebx, 2
	je	SHORT $LN54@more_maken

; 4480 :               kb_error(1304,"Front or back color only for facets.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CG@PJFEHFFP@Front?5or?5back?5color?5only?5for?5fac@
	push	1304					; 00000518H
	call	_kb_error

; 4481 :             list[listtop].stack_delta = -1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	add	esp, 12					; 0000000cH
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], -1

; 4482 :             break;

	jmp	$LN15@more_maken
$LN47@more_maken:

; 4483 :           case SET_FRONTBODY_NODE:
; 4484 :           case SET_BACKBODY_NODE:
; 4485 :             if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN46@more_maken

; 4486 :             { if ( (etype != FACET) && (etype != EDGE) )

	cmp	ebx, 2
	je	$LN52@more_maken
	cmp	ebx, 1
	je	$LN52@more_maken

; 4487 :                 kb_error(1486,
; 4488 :      "Frontbody or backbody only for facets or edges in string model.\n",
; 4489 :                 COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0EB@BHLIPGAE@Frontbody?5or?5backbody?5only?5for?5f@
	push	1486					; 000005ceH

; 4490 :             }
; 4491 :             else if (etype != FACET) 

	jmp	SHORT $LN456@more_maken
$LN46@more_maken:
	cmp	ebx, 2
	je	$LN52@more_maken

; 4492 :                kb_error(1308,"Frontbody or backbody only for facets.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CI@IEJCGHPF@Frontbody?5or?5backbody?5only?5for?5f@
	push	1308					; 0000051cH
$LN456@more_maken:
	call	_kb_error

; 4493 :             list[listtop].stack_delta = -1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	add	esp, 12					; 0000000cH
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], -1

; 4494 :             break;

	jmp	$LN15@more_maken
$LN42@more_maken:

; 4495 :           case SET_COLOR_NODE:
; 4496 :             if ( !((etype == FACET) || (etype == EDGE)) )

	cmp	ebx, 2
	je	$LN57@more_maken
	cmp	ebx, 1
	je	$LN57@more_maken

; 4497 :                kb_error(1487,"Color only for edges or facets.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CB@IIPHIEPO@Color?5only?5for?5edges?5or?5facets?4?6@
	push	1487					; 000005cfH

; 4498 :             list[listtop].stack_delta = -1;
; 4499 :             break;

	jmp	$LN458@more_maken
$LN40@more_maken:

; 4500 :           case SET_VOLCONST_NODE:
; 4501 :             if ( etype != BODY )

	cmp	ebx, 3
	je	$LN54@more_maken

; 4502 :              kb_error(1488,"Volconst only for bodies.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BL@OFNMICCI@Volconst?5only?5for?5bodies?4?6?$AA@
	push	1488					; 000005d0H
	call	_kb_error

; 4503 :             list[listtop].stack_delta = -1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	add	esp, 12					; 0000000cH
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], -1

; 4504 :             break;

	jmp	$LN15@more_maken
$LN38@more_maken:

; 4505 :           case SET_TARGET_NODE:
; 4506 :             if ( etype != BODY )

	cmp	ebx, 3
	je	$LN52@more_maken

; 4507 :              kb_error(1489,"Target volume only for bodies.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CA@DDNLCDCD@Target?5volume?5only?5for?5bodies?4?6?$AA@
	push	1489					; 000005d1H
	call	_kb_error

; 4508 :             list[listtop].stack_delta = -1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	add	esp, 12					; 0000000cH
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], -1

; 4509 :             break;

	jmp	$LN15@more_maken
$LN36@more_maken:

; 4510 :           case SET_VOLUME_NODE:
; 4511 :             if ( etype != BODY )

	cmp	ebx, 3
	je	SHORT $LN35@more_maken

; 4512 :              kb_error(1490,"Target volume only for bodies.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CA@DDNLCDCD@Target?5volume?5only?5for?5bodies?4?6?$AA@
	push	1490					; 000005d2H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN35@more_maken:

; 4513 :             kb_error(1491,
; 4514 :             "Volume is read-only. Setting TARGET instead.\n",
; 4515 :               WARNING);

	push	2
	push	OFFSET ??_C@_0CO@IKCMNGON@Volume?5is?5read?9only?4?5Setting?5TAR@
	push	1491					; 000005d3H
	call	_kb_error

; 4516 :             list[listtop].op2.attr_kind = SET_TARGET_NODE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	add	esp, 12					; 0000000cH
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+136], 10451		; 000028d3H

; 4517 :             list[listtop].stack_delta = -1;
; 4518 :             break;

	jmp	$LN54@more_maken
$LN34@more_maken:

; 4519 :           case SET_PRESSURE_NODE:
; 4520 :             if ( etype != BODY )

	cmp	ebx, 3
	je	$LN52@more_maken

; 4521 :             kb_error(1492,"Pressure only for bodies.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BL@KPLMFDOD@Pressure?5only?5for?5bodies?4?6?$AA@
	push	1492					; 000005d4H
	call	_kb_error

; 4522 :             list[listtop].stack_delta = -1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	add	esp, 12					; 0000000cH
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], -1

; 4523 :             break;

	jmp	$LN15@more_maken
$LN31@more_maken:

; 4524 :           case SET_PHASE_NODE:
; 4525 :           case SET_CONSTRAINT_NODE: 
; 4526 :           case SET_BOUNDARY_NODE: 
; 4527 :           case SET_ORIGINAL_NODE: 
; 4528 :             list[listtop].stack_delta = -1;
; 4529 :             break;
; 4530 :           case SET_DENSITY_NODE:
; 4531 :             if ( etype == VERTEX )

	test	ebx, ebx
	jne	$LN54@more_maken

; 4532 :             kb_error(1493,"No density for vertices.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BK@INAMPMOC@No?5density?5for?5vertices?4?6?$AA@
	push	1493					; 000005d5H

; 4533 :             list[listtop].stack_delta = -1;
; 4534 :             break;

	jmp	$LN459@more_maken
$LN29@more_maken:

; 4535 :           case SET_FIXED_NODE:
; 4536 :             if ( etype == FACETEDGE )

	cmp	ebx, 4
	jne	SHORT $LN28@more_maken

; 4537 :             kb_error(2527,"No fixedness for facetedges.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BO@FCBOEPPP@No?5fixedness?5for?5facetedges?4?6?$AA@
	push	2527					; 000009dfH

; 4538 :             if ( etype == BODY )

	jmp	$LN457@more_maken
$LN28@more_maken:
	cmp	ebx, 3
	jne	$LN15@more_maken

; 4539 :             kb_error(2528,"Use 'set body target ...' to fix volume.\n",
; 4540 :                COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CK@IOPEEGI@Use?5?8set?5body?5target?5?4?4?4?8?5to?5fix@
	push	2528					; 000009e0H

; 4541 :             break;

	jmp	SHORT $LN457@more_maken
$LN26@more_maken:

; 4542 :           case SET_HIT_PARTNER_NODE:
; 4543 :             if ( etype != VERTEX )

	test	ebx, ebx
	je	$LN15@more_maken

; 4544 :             kb_error(3002,"Hit_partner is only for vertices.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CD@ELNKFOCH@Hit_partner?5is?5only?5for?5vertices@
	push	3002					; 00000bbaH

; 4545 :             break;

	jmp	SHORT $LN457@more_maken
$LN24@more_maken:

; 4546 :           case SET_NO_DISPLAY_NODE:
; 4547 :             if ( etype != FACET )

	cmp	ebx, 2
	je	SHORT $LN15@more_maken

; 4548 :             kb_error(1495,"No_display is only for facets.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CA@EHOENKHA@No_display?5is?5only?5for?5facets?4?6?$AA@
	push	1495					; 000005d7H

; 4549 :             break;

	jmp	SHORT $LN457@more_maken
$LN22@more_maken:

; 4550 :           case SET_NO_REFINE_NODE:
; 4551 :             if ( etype == BODY || etype == VERTEX )

	cmp	ebx, 3
	je	SHORT $LN20@more_maken
	test	ebx, ebx
	jne	SHORT $LN15@more_maken
$LN20@more_maken:

; 4552 :             kb_error(1496,"No no_refine for vertices or bodies.\n",
; 4553 :                 COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CG@FHLFDHCM@No?5no_refine?5for?5vertices?5or?5bod@
	push	1496					; 000005d8H

; 4554 :             break;

	jmp	SHORT $LN457@more_maken
$LN19@more_maken:

; 4555 :           case SET_NO_TRANSFORM_NODE:
; 4556 :             if ( etype == BODY || etype == VERTEX )

	cmp	ebx, 3
	je	SHORT $LN17@more_maken
	test	ebx, ebx
	jne	SHORT $LN15@more_maken
$LN17@more_maken:

; 4557 :             kb_error(3035,"No_transform does not apply to vertices or bodies.\n",
; 4558 :                 COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DE@NGJNLEL@No_transform?5does?5not?5apply?5to?5v@
	push	3035					; 00000bdbH

; 4559 :             break;

	jmp	SHORT $LN457@more_maken
$LN16@more_maken:

; 4560 :           case SET_NONCONTENT_NODE:
; 4561 :              if ( ((web.representation == STRING) && (etype != EDGE)) || 
; 4562 :                   ((web.representation != STRING) && (etype != FACET)) )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN403@more_maken
	cmp	ebx, 1
	jne	SHORT $LN14@more_maken
	jmp	SHORT $LN15@more_maken
$LN403@more_maken:
	cmp	ebx, 2
	je	SHORT $LN15@more_maken
$LN14@more_maken:

; 4563 :                 kb_error(2903,"Noncontent only applies to edges or facets.\n",
; 4564 :                    COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CN@BJGPMAKA@Noncontent?5only?5applies?5to?5edges@
	push	2903					; 00000b57H
$LN457@more_maken:
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN15@more_maken:

; 4565 :             break;
; 4566 :          }
; 4567 :          /* error checking for arithmetic assigns */
; 4568 :          if ( type == SET_ATTRIBUTE_A_NODE )

	cmp	esi, 10453				; 000028d5H
	jne	$LN333@more_maken

; 4569 :          { switch ( attr_kind )

	mov	eax, DWORD PTR _attr_kind
	add	eax, -10265				; ffffd7e7H
	cmp	eax, 34					; 00000022H
	ja	SHORT $LN421@more_maken
	movzx	ecx, BYTE PTR $LN410@more_maken[eax]
	jmp	DWORD PTR $LN495@more_maken[ecx*4]
$LN9@more_maken:

; 4570 :            { case SET_FIXED_NODE: case SET_TRIPLE_PT_NODE: case SET_TETRA_PT_NODE: 
; 4571 :              case SET_AXIAL_POINT_NODE:
; 4572 :                 kb_error(2241,"Cannot assign value to this attribute with :=.\n",
; 4573 :                  COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DA@DHKJDMLH@Cannot?5assign?5value?5to?5this?5attr@
	push	2241					; 000008c1H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN421@more_maken:

; 4574 :            }
; 4575 :            if ( assigntype != ASSIGN_OP ) 

	cmp	DWORD PTR _assigntype, 30001		; 00007531H
	je	$LN333@more_maken

; 4576 :            switch ( attr_kind )

	mov	eax, DWORD PTR _attr_kind
	add	eax, -10286				; ffffd7d2H
	cmp	eax, 166				; 000000a6H
	ja	$LN333@more_maken
	movzx	edx, BYTE PTR $LN411@more_maken[eax]
	jmp	DWORD PTR $LN496@more_maken[edx*4]
$LN5@more_maken:

; 4577 :            { case SET_ORIENTATION_NODE: case SET_PHASE_NODE: case SET_OPACITY_NODE:
; 4578 :              case SET_CONSTRAINT_NODE: case SET_ORIGINAL_NODE: case SET_COLOR_NODE:
; 4579 :              case SET_FRONTCOLOR_NODE: case SET_BACKCOLOR_NODE: case SET_WRAP_NODE:
; 4580 :              case SET_FRONTBODY_NODE: case SET_BACKBODY_NODE:
; 4581 :              case SET_BOUNDARY_NODE:
; 4582 :              kb_error(2242,
; 4583 :                "Cannot use arithmetic assign with this attribute.\n",
; 4584 :              COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DD@CMMHBHLH@Cannot?5use?5arithmetic?5assign?5wit@
	push	2242					; 000008c2H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN322@more_maken:

; 3118 :          break;
; 3119 : 
; 3120 :     case EPRINT_NODE:
; 3121 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+ecx], 10676		; 000029b4H
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN386@more_maken:

; 3060 : 
; 3061 :   switch (type)

	cmp	esi, 10742				; 000029f6H
	jg	$LN387@more_maken
	je	$LN331@more_maken
	lea	eax, DWORD PTR [esi-10708]
	cmp	eax, 6
	ja	$LN1@more_maken
	jmp	DWORD PTR $LN497@more_maken[eax*4]
$LN119@more_maken:

; 4117 : 
; 4118 :     case VIEW_MATRIX_LVALUE_NODE:
; 4119 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 4120 :          list[listtop].left = left - listtop;

	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [edx+eax], esi
	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx

; 4121 :          list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _right$[ebp]
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+edx+8], ecx
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN118@more_maken:

; 4122 :          break;
; 4123 : 
; 4124 :     case SET_VIEW_MATRIX_NODE:
; 4125 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H

; 4126 :          list[listtop].left = left - listtop;

	mov	edx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax+ecx], esi
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 4127 :          list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR _list
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edx

; 4128 :          list[listtop].op2.assigntype = assigntype;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _assigntype
	mov	DWORD PTR [edx+eax+136], ecx

; 4129 :          list[listtop].stack_delta = -3;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+eax+156], -3		; fffffffdH
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN117@more_maken:

; 4130 :          break;
; 4131 :          
; 4132 :     case SET_QMODULUS_NODE:
; 4133 :     case SET_QTOLERANCE_NODE:
; 4134 :     case SET_MMODULUS_NODE:
; 4135 :     case SET_QVOLCONST_NODE:
; 4136 :     case SET_QTARGET_NODE:
; 4137 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], esi

; 4138 :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _left$[ebp]
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx

; 4139 :          list[listtop].op1.quant_id = right;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	edx, DWORD PTR _right$[ebp]
	mov	DWORD PTR [eax+ecx+32], edx

; 4140 :          list[listtop].op2.assigntype = assigntype;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	edx, DWORD PTR _assigntype
	mov	DWORD PTR [eax+ecx+136], edx

; 4141 :          list[listtop].stack_delta = -1;
; 4142 :          break;

	jmp	SHORT $LN461@more_maken
$LN331@more_maken:

; 3071 :          break;
; 3072 : 
; 3073 :     case DUMP_NODE:
; 3074 :     case LOAD_NODE:
; 3075 :     case PERMLOAD_NODE:
; 3076 :     case ADDLOAD_NODE:
; 3077 :     case REPLACE_LOAD_NODE:
; 3078 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop

; 3079 :          if ( left ) 

	mov	ecx, DWORD PTR _left$[ebp]
	imul	edx, 168				; 000000a8H
	mov	eax, DWORD PTR _list
	mov	DWORD PTR [edx+eax], esi
	test	ecx, ecx
	je	$LN333@more_maken
$LN460@more_maken:

; 3080 :          { list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx
$LN461@more_maken:

; 3081 :            list[listtop].stack_delta = -1;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+ecx+156], -1
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN387@more_maken:

; 3060 : 
; 3061 :   switch (type)

	mov	eax, esi
	sub	eax, 10761				; 00002a09H
	je	$LN319@more_maken
	sub	eax, 9242				; 0000241aH
	je	$LN88@more_maken
	sub	eax, 4
	je	SHORT $LN94@more_maken
$LN1@more_maken:

; 4623 : 
; 4624 :      default:
; 4625 :         sprintf(errmsg,"Internal error: Unknown MAKENODE %d type %s\n",type,tokname(type));

	push	esi
	call	_tokname
	push	eax
	push	esi
	push	OFFSET ??_C@_0CN@KKOGLFKO@Internal?5error?3?5Unknown?5MAKENODE@
	push	OFFSET _errmsg
	call	_sprintf

; 4626 :         kb_error(1329,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	1329					; 00000531H
	call	_kb_error
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN94@more_maken:

; 4306 :          break;
; 4307 : 
; 4308 :      case INDEXED_ATTRIBUTE_NODE:  /* get extra attribute value */
; 4309 :             { struct extra *ex;
; 4310 :               etype = (unsigned)right >> YYTYPESHIFT;

	mov	edx, DWORD PTR _right$[ebp]
	mov	ecx, edx

; 4311 :               right = right & YYSHIFTMASK;
; 4312 :               ex = EXTRAS(etype) + right;
; 4313 :               list[listtop].type = GET_EXTRA_ATTR_NODE;

	mov	edi, DWORD PTR _list
	shr	ecx, 25					; 00000019H
	and	edx, 33554431				; 01ffffffH
	mov	eax, ecx
	mov	esi, edx
	imul	eax, 112				; 00000070H
	mov	eax, DWORD PTR _web[eax+104]
	imul	esi, 240				; 000000f0H
	add	eax, esi
	mov	esi, DWORD PTR _listtop
	add	eax, DWORD PTR _dymem
	imul	esi, 168				; 000000a8H
	mov	DWORD PTR [esi+edi], 10221		; 000027edH

; 4314 :               list[listtop].op2.eltype = etype;

	mov	esi, DWORD PTR _listtop
	mov	edi, DWORD PTR _list
	imul	esi, 168				; 000000a8H
	mov	DWORD PTR [esi+edi+136], ecx

; 4315 :               list[listtop].op3.extranum = right;  /* which extra */

	mov	ecx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+esi+140], edx

; 4316 :               list[listtop].left = left - listtop;  /* index */

	mov	ecx, DWORD PTR _left$[ebp]
	mov	edx, DWORD PTR _listtop
	mov	edi, DWORD PTR _list
	mov	esi, ecx

; 4317 :               list[listtop].stack_delta = 1 - ex->array_spec.dim;
; 4318 :               if ( ex->array_spec.dim != list[left].op5.indexcount )

	imul	ecx, 168				; 000000a8H
	sub	esi, edx
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+edi+4], esi
	mov	esi, DWORD PTR _listtop
	mov	edi, DWORD PTR _list
	imul	esi, 168				; 000000a8H
	mov	edx, 1
	sub	edx, DWORD PTR [eax+76]
	mov	DWORD PTR [esi+edi+156], edx
	mov	edx, DWORD PTR [eax+76]
	mov	esi, DWORD PTR _list
	cmp	edx, DWORD PTR [ecx+esi+152]
	je	SHORT $LN93@more_maken

; 4319 :               { sprintf(errmsg,"Attribute %s must have %d indices.\n",
; 4320 :                  ex->name,ex->array_spec.dim);

	push	edx
	push	eax
	push	OFFSET ??_C@_0CE@MNJJPJOP@Attribute?5?$CFs?5must?5have?5?$CFd?5indice@
	push	OFFSET _errmsg
	call	_sprintf

; 4321 :                 kb_error(2513,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	2513					; 000009d1H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN93@more_maken:

; 4322 :               }
; 4323 :               list[listtop].flags |= EPHEMERAL;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	or	DWORD PTR [edx+eax+24], 64		; 00000040H
	pop	edi
	lea	eax, DWORD PTR [edx+eax+24]
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN88@more_maken:

; 4357 :           break;
; 4358 :   
; 4359 :      case ATTRIBUTE_NODE:
; 4360 :         list[listtop].type = (NTYPE)left;

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _left$[ebp]
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR _list
	mov	DWORD PTR [ecx+edx], eax

; 4361 :         /* some special treatments */
; 4362 :         switch ( left )

	add	eax, -10162				; ffffd84eH
	cmp	eax, 59					; 0000003bH
	ja	$LN416@more_maken
	movzx	eax, BYTE PTR $LN412@more_maken[eax]
	jmp	DWORD PTR $LN498@more_maken[eax*4]
$LN85@more_maken:

; 4363 :         { 
; 4364 :           case COORD_NODE: list[listtop].op2.coordnum = right-1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _right$[ebp]
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR _list
	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR [edx+esi+136], ecx

; 4365 :              if ( right > SDIM )

	cmp	eax, DWORD PTR _web+616
	jle	$LN416@more_maken

; 4366 :              kb_error(2475,"Coordinate dimension exceeds space dimension.\n",
; 4367 :                  COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CP@EEKPMBAG@Coordinate?5dimension?5exceeds?5spa@
	push	2475					; 000009abH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 4368 :              break;

	jmp	$LN416@more_maken
$LN83@more_maken:

; 4369 :           case PARAM_NODE: list[listtop].op2.coordnum = right-1;

	mov	eax, DWORD PTR _right$[ebp]
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	dec	eax
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+136], eax

; 4370 :              using_param_flag = 1;

	mov	DWORD PTR _using_param_flag, 1

; 4371 :              break;

	jmp	$LN416@more_maken
$LN82@more_maken:

; 4372 :           case GET_INSTANCE_NODE:
; 4373 :           case GET_QUANTITY_NODE: list[listtop].op2.quant_id = right;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _right$[ebp]
	imul	eax, 168				; 000000a8H
	mov	edx, DWORD PTR _list
	mov	DWORD PTR [eax+edx+136], ecx

; 4374 :              break;

	jmp	$LN416@more_maken
$LN81@more_maken:

; 4375 :           case GET_EXTRA_ATTR_NODE:
; 4376 :             { struct extra *ex;
; 4377 :               etype = (unsigned)right >> YYTYPESHIFT;

	mov	ebx, DWORD PTR _right$[ebp]
	mov	edi, ebx
	shr	edi, 25					; 00000019H

; 4378 :               ex = EXTRAS(etype) + (right & YYSHIFTMASK);

	and	ebx, 33554431				; 01ffffffH
	mov	eax, edi
	imul	eax, 112				; 00000070H
	mov	esi, DWORD PTR _web[eax+104]
	mov	ecx, ebx
	imul	ecx, 240				; 000000f0H
	add	esi, ecx
	add	esi, DWORD PTR _dymem

; 4379 : 
; 4380 :               if ( ex->array_spec.dim > 0 ) 

	cmp	DWORD PTR [esi+76], 0
	jle	SHORT $LN80@more_maken

; 4381 :               { sprintf(errmsg,
; 4382 :                   "\"%s\" is an indexed attribute; index is missing.  Or use element name to print as full array.\n",
; 4383 :                       ex->name);

	push	esi
	push	OFFSET ??_C@_0FO@GLOCEABG@?$CC?$CFs?$CC?5is?5an?5indexed?5attribute?$DL?5in@
	push	OFFSET _errmsg
	call	_sprintf

; 4384 :                 kb_error(2634,errmsg,Q_ERROR);

	push	8
	push	OFFSET _errmsg
	push	2634					; 00000a4aH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN80@more_maken:

; 4385 :               }
; 4386 : 
; 4387 :               list[listtop].op2.eltype = etype;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+136], edi

; 4388 :               list[listtop].op3.extranum = (right & YYSHIFTMASK);

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+140], ebx

; 4389 :               list[listtop].flags |= EPHEMERAL;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	or	DWORD PTR [eax+ecx+24], 64		; 00000040H
	lea	eax, DWORD PTR [eax+ecx+24]

; 4390 :               list[listtop].stack_delta = 1-ex->array_spec.dim;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, 1
	sub	edx, DWORD PTR [esi+76]
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+156], edx
$LN416@more_maken:

; 4391 :             }
; 4392 :             break;
; 4393 :          }
; 4394 :          if ( left != GET_EXTRA_ATTR_NODE )

	cmp	DWORD PTR _left$[ebp], 10221		; 000027edH
	je	$LN333@more_maken

; 4395 :             list[listtop].stack_delta = 1;
; 4396 :          break;

	jmp	$LN477@more_maken
$LN319@more_maken:

; 3139 : 
; 3140 :       case COND_ELSE_NODE: /* really the continue node at root of IF */
; 3141 :          list[listtop].type = COND_ELSE_NODE;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H

; 3142 :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _left$[ebp]
	mov	DWORD PTR [ecx+edx], 10761		; 00002a09H
	mov	ecx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	mov	edx, eax
	sub	edx, ecx
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+esi+4], edx

; 3143 :          list[listtop].right = right - listtop;

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _right$[ebp]
	mov	edi, DWORD PTR _list
	mov	esi, ecx
	sub	esi, edx
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+edi+8], esi

; 3144 :          list[left].op1.skipsize = listtop - left; /* to skip ELSE part */

	mov	edx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+esi+32], edx
$LN455@more_maken:

; 3145 :          list[listtop].datatype = list[right].datatype;

	mov	edx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [ecx+eax+20]
	mov	DWORD PTR [edx+eax+20], ecx
$LN333@more_maken:
	pop	edi
	pop	esi
	pop	ebx

; 4627 : 
; 4628 :       }
; 4629 : } // end more_makenode()

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN491@more_maken:
	DD	$LN156@more_maken
	DD	$LN181@more_maken
	DD	$LN206@more_maken
	DD	$LN197@more_maken
	DD	$LN168@more_maken
	DD	$LN188@more_maken
	DD	$LN229@more_maken
	DD	$LN1@more_maken
$LN405@more_maken:
	DB	0
	DB	7
	DB	7
	DB	7
	DB	7
	DB	1
	DB	2
	DB	7
	DB	3
	DB	7
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
	npad	2
$LN492@more_maken:
	DD	$LN331@more_maken
	DD	$LN107@more_maken
	DD	$LN109@more_maken
	DD	$LN327@more_maken
	DD	$LN325@more_maken
	DD	$LN328@more_maken
	DD	$LN324@more_maken
	DD	$LN323@more_maken
	DD	$LN321@more_maken
	DD	$LN320@more_maken
	DD	$LN306@more_maken
	DD	$LN305@more_maken
	DD	$LN114@more_maken
	DD	$LN112@more_maken
	DD	$LN108@more_maken
	DD	$LN110@more_maken
	DD	$LN303@more_maken
	DD	$LN302@more_maken
	DD	$LN301@more_maken
	DD	$LN141@more_maken
	DD	$LN137@more_maken
	DD	$LN116@more_maken
	DD	$LN4@more_maken
	DD	$LN3@more_maken
	DD	$LN2@more_maken
	DD	$LN151@more_maken
	DD	$LN146@more_maken
	DD	$LN229@more_maken
	DD	$LN248@more_maken
	DD	$LN244@more_maken
	DD	$LN231@more_maken
	DD	$LN230@more_maken
	DD	$LN240@more_maken
	DD	$LN263@more_maken
	DD	$LN261@more_maken
	DD	$LN254@more_maken
	DD	$LN252@more_maken
	DD	$LN292@more_maken
	DD	$LN290@more_maken
	DD	$LN272@more_maken
	DD	$LN267@more_maken
	DD	$LN297@more_maken
	DD	$LN288@more_maken
	DD	$LN286@more_maken
	DD	$LN284@more_maken
	DD	$LN280@more_maken
	DD	$LN278@more_maken
	DD	$LN282@more_maken
	DD	$LN295@more_maken
	DD	$LN275@more_maken
	DD	$LN270@more_maken
	DD	$LN265@more_maken
	DD	$LN258@more_maken
	DD	$LN256@more_maken
	DD	$LN250@more_maken
	DD	$LN99@more_maken
	DD	$LN97@more_maken
	DD	$LN96@more_maken
	DD	$LN104@more_maken
	DD	$LN103@more_maken
	DD	$LN100@more_maken
	DD	$LN101@more_maken
	DD	$LN89@more_maken
	DD	$LN1@more_maken
$LN406@more_maken:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	1
	DB	2
	DB	3
	DB	4
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	5
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	6
	DB	7
	DB	63					; 0000003fH
	DB	8
	DB	63					; 0000003fH
	DB	9
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	63					; 0000003fH
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	63					; 0000003fH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	46					; 0000002eH
	DB	47					; 0000002fH
	DB	48					; 00000030H
	DB	49					; 00000031H
	DB	50					; 00000032H
	DB	51					; 00000033H
	DB	52					; 00000034H
	DB	53					; 00000035H
	DB	32					; 00000020H
	DB	32					; 00000020H
	DB	54					; 00000036H
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	55					; 00000037H
	DB	56					; 00000038H
	DB	57					; 00000039H
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	58					; 0000003aH
	DB	59					; 0000003bH
	DB	58					; 0000003aH
	DB	59					; 0000003bH
	DB	58					; 0000003aH
	DB	59					; 0000003bH
	DB	58					; 0000003aH
	DB	59					; 0000003bH
	DB	60					; 0000003cH
	DB	61					; 0000003dH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	63					; 0000003fH
	DB	62					; 0000003eH
	npad	3
$LN493@more_maken:
	DD	$LN298@more_maken
	DD	$LN133@more_maken
	DD	$LN318@more_maken
	DD	$LN317@more_maken
	DD	$LN316@more_maken
	DD	$LN299@more_maken
	DD	$LN131@more_maken
	DD	$LN305@more_maken
	DD	$LN78@more_maken
	DD	$LN92@more_maken
	DD	$LN307@more_maken
	DD	$LN309@more_maken
	DD	$LN311@more_maken
	DD	$LN315@more_maken
	DD	$LN313@more_maken
	DD	$LN106@more_maken
	DD	$LN105@more_maken
	DD	$LN332@more_maken
	DD	$LN300@more_maken
	DD	$LN1@more_maken
$LN407@more_maken:
	DB	0
	DB	0
	DB	19					; 00000013H
	DB	1
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	2
	DB	3
	DB	4
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	6
	DB	5
	DB	7
	DB	7
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	8
	DB	8
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	8
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	9
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	10					; 0000000aH
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	19					; 00000013H
	DB	5
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	18					; 00000012H
$LN494@more_maken:
	DD	$LN29@more_maken
	DD	$LN24@more_maken
	DD	$LN16@more_maken
	DD	$LN26@more_maken
	DD	$LN22@more_maken
	DD	$LN19@more_maken
	DD	$LN57@more_maken
	DD	$LN31@more_maken
	DD	$LN36@more_maken
	DD	$LN34@more_maken
	DD	$LN51@more_maken
	DD	$LN42@more_maken
	DD	$LN49@more_maken
	DD	$LN56@more_maken
	DD	$LN53@more_maken
	DD	$LN67@more_maken
	DD	$LN47@more_maken
	DD	$LN40@more_maken
	DD	$LN38@more_maken
	DD	$LN58@more_maken
	DD	$LN15@more_maken
$LN409@more_maken:
	DB	0
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	1
	DB	20					; 00000014H
	DB	2
	DB	20					; 00000014H
	DB	3
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	4
	DB	20					; 00000014H
	DB	5
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	6
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	6
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	6
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	6
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
$LN495@more_maken:
	DD	$LN9@more_maken
	DD	$LN421@more_maken
$LN410@more_maken:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	0
	DB	1
	DB	0
	npad	1
$LN496@more_maken:
	DD	$LN5@more_maken
	DD	$LN333@more_maken
$LN411@more_maken:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	0
	npad	1
$LN497@more_maken:
	DD	$LN119@more_maken
	DD	$LN118@more_maken
	DD	$LN117@more_maken
	DD	$LN117@more_maken
	DD	$LN117@more_maken
	DD	$LN117@more_maken
	DD	$LN117@more_maken
$LN498@more_maken:
	DD	$LN85@more_maken
	DD	$LN83@more_maken
	DD	$LN82@more_maken
	DD	$LN81@more_maken
	DD	$LN416@more_maken
$LN412@more_maken:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_more_makenode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@DDBLPGGI@Expression?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0DA@POKLEMJB@Internal?5error?3?5Bad?5NEXT_ELEMENT@ ; `string'
PUBLIC	??_C@_0BL@HGGLGGIP@Cannot?5do?5bodies?5of?5body?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DD@IKPOJIMJ@Facetedge?5can?5only?5have?5edge?5or?5@ ; `string'
PUBLIC	??_C@_0BM@HJDHIACA@Cannot?5do?5facets?5of?5facet?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@JEMKGOCB@Cannot?5do?5facetedges?5of?5facet?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DB@KGBAHOPI@Facet?5body?5iterator?5not?5valid?5in@ ; `string'
PUBLIC	??_C@_0DB@CEOGHBOA@Facet?5edge?5iterator?5not?5valid?5in@ ; `string'
PUBLIC	??_C@_0BP@EKOGCLLJ@Cannot?5do?5facetedges?5of?5edge?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DA@BBLKODON@Edge?5body?5iterator?5not?5valid?5in?5@ ; `string'
PUBLIC	??_C@_0DB@NGHEKADF@Edge?5facet?5iterator?5not?5valid?5in@ ; `string'
PUBLIC	??_C@_0BK@GMAAKKCE@Cannot?5do?5edges?5of?5edge?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DC@MBIBHGFE@Vertex?5edge?5iterator?5not?5valid?5i@ ; `string'
PUBLIC	??_C@_0BP@JGHIEHPG@Cannot?5do?5vertices?5of?5vertex?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@LOKJCEML@Internal?5error?3?5Bad?5INIT_ELEMENT@ ; `string'
PUBLIC	??_C@_0CH@DHGEIJOF@Can?5set?5parameters?5only?5for?5vert@ ; `string'
PUBLIC	??_C@_0CI@GEMLFPAO@Can?5set?5coordinates?5only?5for?5ver@ ; `string'
PUBLIC	??_C@_0DB@LJLNLDOK@Internal?5error?3?5Invalid?5extra?5at@ ; `string'
PUBLIC	??_C@_0CP@MGPBKJPH@No_transform?5only?5applies?5to?5edg@ ; `string'
PUBLIC	??_C@_0CM@MKPPBFFJ@No_refine?5only?5applies?5to?5edges?5@ ; `string'
PUBLIC	??_C@_0CH@BLOJFOKI@Hit_partner?5only?5applies?5to?5vert@ ; `string'
PUBLIC	??_C@_0CE@NBPCEGGM@No_display?5only?5applies?5to?5facet@ ; `string'
PUBLIC	??_C@_0CC@NKHDEADJ@Can?5refine?5only?5edges?5or?5facets?4@ ; `string'
PUBLIC	??_C@_0CO@ODOECMFJ@Can?5equiangulate?5only?5in?5the?5SOA@ ; `string'
PUBLIC	??_C@_0BN@LIFJJDEB@Can?5t1_edgeswap?5only?5edges?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CL@IPOKAHAD@Can?5t1_edgeswap?5only?5in?5the?5STRI@ ; `string'
PUBLIC	??_C@_0BK@IADKNDDN@Can?5edgeswap?5only?5edges?4?6?$AA@ ; `string'
PUBLIC	??_C@_0EE@OBDAOELG@Can?5edgeswap?5only?5in?5the?5SOAPFIL@ ; `string'
PUBLIC	??_C@_0CD@BKBGNKOH@Can?5pop_quad_to_quad?5only?5facets@ ; `string'
PUBLIC	??_C@_0CO@JJDGKHGD@Can?5pop_quad_to_quad?5only?5in?5SOA@ ; `string'
PUBLIC	??_C@_0CB@OEOLOLOG@Can?5pop_edge_to_tri?5only?5edges?4?6@ ; `string'
PUBLIC	??_C@_0CN@KBOFAJEK@Can?5pop_edge_to_tro?5only?5in?5SOAP@ ; `string'
PUBLIC	??_C@_0CC@LFHDKCIA@Can?5pop_tri_to_edge?5only?5facets?4@ ; `string'
PUBLIC	??_C@_0CN@GANONAHP@Can?5pop_tri_to_edge?5only?5in?5SOAP@ ; `string'
PUBLIC	??_C@_0CH@DOEIMLPB@Can?5pop?5edges?5only?5in?5soapfilm?5m@ ; `string'
PUBLIC	??_C@_0CB@PCAOINFN@Can?5pop?5only?5edges?5or?5vertices?4?6@ ; `string'
PUBLIC	??_C@_0CL@CDLLBBI@Can?5pop?5only?5in?5SOAPFILM?5or?5STRI@ ; `string'
PUBLIC	??_C@_0CP@NADDAGOO@Can?5reverse_orientation?5only?5edg@ ; `string'
PUBLIC	??_C@_0CC@GEOLKELN@Can?5delete?5only?5edges?5or?5facets?4@ ; `string'
PUBLIC	??_C@_0CD@MCCPHKEO@Can?5vertex_average?5only?5vertices@ ; `string'
PUBLIC	??_C@_0CJ@LGIFMPGA@No?5vertex_average?5in?5simplex?5mod@ ; `string'
PUBLIC	??_C@_0CJ@NHNHDHGB@Can?5unset?5centerofmass?5for?5bodie@ ; `string'
PUBLIC	??_C@_0DM@MFLGHDJO@Cannot?5UNFIX?5bodies?4?5To?5unfix?5vo@ ; `string'
PUBLIC	??_C@_0DO@MGJNCOHG@Cannot?5FIX?5bodies?4?5To?5fix?5volume@ ; `string'
PUBLIC	??_C@_0BP@GOBDCNHG@Illegal?5format?5specifier?3?5?$CFn?5?6?$AA@ ; `string'
PUBLIC	??_C@_0EA@FFIPKJOG@Cannot?5assign?5expression?5of?5type@ ; `string'
PUBLIC	??_C@_0BH@PNBBNCCB@Illegal?5element?5type?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CL@NBJONBCH@Right?5side?5expression?5must?5be?5an@ ; `string'
PUBLIC	??_C@_0DF@CMJIKKNE@Cannot?5change?5the?5number?5of?5dime@ ; `string'
PUBLIC	??_C@_0CB@FMOFCBKA@Cannot?5change?5type?5of?5array?5?$CFs?4?6@ ; `string'
PUBLIC	??_C@_0DG@DFGHPACG@Maximum?5number?5of?5array?5dimensio@ ; `string'
PUBLIC	??_C@_0DA@PDJBPEDI@Cannot?5re?9declare?5a?5local?5fixed?9@ ; `string'
PUBLIC	??_C@_0DH@IOIJAIMG@Illegal?5to?5convert?5ordinary?5vari@ ; `string'
PUBLIC	??_C@_0CK@OOLAKBHI@Cannot?5change?5number?5of?5dimensio@ ; `string'
PUBLIC	__real@3f1a36e2eb1c432d
PUBLIC	??_C@_0DA@JJBDKLNJ@Variable?5?$CFs?5is?5not?5proper?5type?5f@ ; `string'
PUBLIC	??_C@_0DN@FPHMDPLJ@Variable?5?$CFs?5is?5not?5proper?5type?5f@ ; `string'
PUBLIC	??_C@_0BI@MJAAACDM@Array?5?$CFs?5is?5read?9only?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DH@BDIEAHJL@Array?5?$CFs?5has?5wrong?5number?5of?5dim@ ; `string'
PUBLIC	??_C@_0EF@DIIILPA@Arrays?5don?8t?5have?5same?5number?5of@ ; `string'
PUBLIC	??_C@_0O@ILBCJIOO@temp_array_?$CFd?$AA@		; `string'
PUBLIC	??_C@_0EB@HHJIPDPG@Arrays?5don?8t?5have?5same?5number?5of@ ; `string'
PUBLIC	??_C@_0CM@CFLEBAG@Dot?5product?5operands?5must?5be?5of?5@ ; `string'
PUBLIC	??_C@_0CP@LMHOJAKD@Dot?5product?5operands?5must?5be?5one@ ; `string'
PUBLIC	??_C@_0DC@IPLHDPDE@Array?5?$CFs?5should?5have?5at?5most?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0CO@PEOAOHHI@?8?$CFs?8?5cannot?5be?5made?5an?5optimizin@ ; `string'
PUBLIC	??_C@_0CE@GNJOFDDC@Cannot?5set?5internal?5variable?5?8?$CFs@ ; `string'
PUBLIC	??_C@_0DE@BIBENIGB@Please?5use?5integral_order_1d?5or?5@ ; `string'
PUBLIC	??_C@_0CO@PEJKEKJN@Need?5exactly?5?$CFd?5vertices?5in?5NEW_@ ; `string'
PUBLIC	??_C@_0CO@IHGLLACA@facet_crosscut?$CI?$CJ?5only?5valid?5in?5s@ ; `string'
PUBLIC	??_C@_0DC@PFHFLMGE@Need?5exactly?5?$CFd?5coordinates?5in?5N@ ; `string'
PUBLIC	??_C@_0CA@LOPGCAPG@Unimplemented?5subtype?5of?5body?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@FJBLHHOF@Unimplemented?5subtype?5of?5facet?4?6@ ; `string'
PUBLIC	??_C@_0CA@EMPJHMEM@Unimplemented?5subtype?5of?5edge?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@IHNNOPLF@Unimplemented?5subtype?5of?5vertex?4@ ; `string'
PUBLIC	??_C@_0CM@ELHMDCJI@Cannot?5do?5same?5subtype?5as?5type?5o@ ; `string'
PUBLIC	??_C@_0CB@ODFFJHOG@Element?5index?5must?5be?5positive?4?6@ ; `string'
PUBLIC	??_C@_0CA@CBCKOCFL@Element?5index?5must?5be?5nonzero?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DB@KJKMGOKE@Procedure?5?$CC?$CFs?$CC?5needs?5?$CFd?5argument@ ; `string'
PUBLIC	??_C@_0DB@LABGMEKM@on_assign_call?5procedure?5cannot?5@ ; `string'
PUBLIC	??_C@_0DA@NEJEBFAM@Function?5?$CC?$CFs?$CC?5needs?5?$CFd?5arguments@ ; `string'
PUBLIC	??_C@_0CF@LEPAHKPA@Cannot?5redefine?5?8?$CFs?8?5as?5a?5functi@ ; `string'
PUBLIC	??_C@_0CK@OCKAMEPI@Non?9permanent?5items?5in?5definitio@ ; `string'
PUBLIC	??_C@_0CN@HBMNHHDH@Cannot?5redefine?5variable?5?8?$CFs?8?5as@ ; `string'
PUBLIC	_right$GSCopy$
PUBLIC	??_C@_0BD@IBKBDFEL@Illegal?5redefine?4?6?$AA@	; `string'
PUBLIC	??_C@_0BF@MBGCPADL@Illegal?5unredefine?4?6?$AA@	; `string'
PUBLIC	??_C@_0DC@IMBGKBA@matrix_determinant?5array?5is?5not?5@ ; `string'
PUBLIC	??_C@_0DF@GJDLMJDI@matrix_inverse?5second?5array?5is?5n@ ; `string'
PUBLIC	??_C@_0DE@JGEOBBCA@matrix_inverse?5first?5array?5is?5no@ ; `string'
PUBLIC	??_C@_0DE@KKELGCPH@matrix_inverse?3?5second?5matrix?5is@ ; `string'
PUBLIC	??_C@_0DD@JNOCGJAC@matrix_inverse?3?5first?5matrix?5is?5@ ; `string'
PUBLIC	??_C@_0EJ@OAKEJDGP@matrix_multiply?3?5second?5and?5thir@ ; `string'
PUBLIC	??_C@_0EI@PHKJOELK@matrix_multiply?3?5first?5and?5third@ ; `string'
PUBLIC	??_C@_0DE@FHFPHPDO@matrix_multiply?3?5third?5matrix?5is@ ; `string'
PUBLIC	??_C@_0DF@MGFJOCIL@matrix_multiply?3?5second?5matrix?5i@ ; `string'
PUBLIC	??_C@_0DE@IJPHPIFG@matrix_multiply?3?5first?5matrix?5is@ ; `string'
PUBLIC	??_C@_0BK@KDIHDDIN@Element?5id?50?5is?5illegal?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@NEDBIMHF@Internal?5error?3?5loopdepth?5negati@ ; `string'
PUBLIC	??_C@_0CL@JMJIJLCN@BREAK?5or?5CONTINUE?5out?5of?5too?5man@ ; `string'
PUBLIC	??_C@_0DA@CLANOEMJ@Cannot?5BREAK?5or?5CONTINUE?5unless?5@ ; `string'
PUBLIC	??_C@_0BP@LNGHNJGK@Index?5?$CFd?5must?5be?5nonnegative?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@GLHPNAPD@Index?5?$CFd?5must?5be?5positive?4?6?$AA@ ; `string'
PUBLIC	_left$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_makenode
EXTRN	_use_given_id:DWORD
EXTRN	_datatype_name:BYTE
EXTRN	_datatype_size:BYTE
EXTRN	_perm_flag:DWORD
EXTRN	_temp_array_number:DWORD
EXTRN	_get_name_datatype:PROC
EXTRN	_get_name_dim:PROC
EXTRN	_get_name_name:PROC
EXTRN	_keywordname:PROC
EXTRN	_msg:DWORD
EXTRN	_subtype:DWORD
EXTRN	_symtable:BYTE
EXTRN	_topflag:DWORD
EXTRN	_file_no:DWORD
EXTRN	_line_no:DWORD
EXTRN	_aggrtype:DWORD
EXTRN	_get_name_arrayptr:PROC
EXTRN	_add_local_var:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BE@DDBLPGGI@Expression?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@DDBLPGGI@Expression?5too?5long?$AA@ DB 'Expression too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@POKLEMJB@Internal?5error?3?5Bad?5NEXT_ELEMENT@
CONST	SEGMENT
??_C@_0DA@POKLEMJB@Internal?5error?3?5Bad?5NEXT_ELEMENT@ DB 'Internal err'
	DB	'or: Bad NEXT_ELEMENT_NODE type %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HGGLGGIP@Cannot?5do?5bodies?5of?5body?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@HGGLGGIP@Cannot?5do?5bodies?5of?5body?4?6?$AA@ DB 'Cannot do bo'
	DB	'dies of body.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IKPOJIMJ@Facetedge?5can?5only?5have?5edge?5or?5@
CONST	SEGMENT
??_C@_0DD@IKPOJIMJ@Facetedge?5can?5only?5have?5edge?5or?5@ DB 'Facetedge '
	DB	'can only have edge or facet subelement.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HJDHIACA@Cannot?5do?5facets?5of?5facet?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@HJDHIACA@Cannot?5do?5facets?5of?5facet?4?6?$AA@ DB 'Cannot do f'
	DB	'acets of facet.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JEMKGOCB@Cannot?5do?5facetedges?5of?5facet?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@JEMKGOCB@Cannot?5do?5facetedges?5of?5facet?4?6?$AA@ DB 'Cannot '
	DB	'do facetedges of facet.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KGBAHOPI@Facet?5body?5iterator?5not?5valid?5in@
CONST	SEGMENT
??_C@_0DB@KGBAHOPI@Facet?5body?5iterator?5not?5valid?5in@ DB 'Facet body '
	DB	'iterator not valid in simplex model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CEOGHBOA@Facet?5edge?5iterator?5not?5valid?5in@
CONST	SEGMENT
??_C@_0DB@CEOGHBOA@Facet?5edge?5iterator?5not?5valid?5in@ DB 'Facet edge '
	DB	'iterator not valid in simplex model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EKOGCLLJ@Cannot?5do?5facetedges?5of?5edge?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@EKOGCLLJ@Cannot?5do?5facetedges?5of?5edge?4?6?$AA@ DB 'Cannot d'
	DB	'o facetedges of edge.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BBLKODON@Edge?5body?5iterator?5not?5valid?5in?5@
CONST	SEGMENT
??_C@_0DA@BBLKODON@Edge?5body?5iterator?5not?5valid?5in?5@ DB 'Edge body '
	DB	'iterator not valid in simplex model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@NGHEKADF@Edge?5facet?5iterator?5not?5valid?5in@
CONST	SEGMENT
??_C@_0DB@NGHEKADF@Edge?5facet?5iterator?5not?5valid?5in@ DB 'Edge facet '
	DB	'iterator not valid in simplex model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GMAAKKCE@Cannot?5do?5edges?5of?5edge?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@GMAAKKCE@Cannot?5do?5edges?5of?5edge?4?6?$AA@ DB 'Cannot do edg'
	DB	'es of edge.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MBIBHGFE@Vertex?5edge?5iterator?5not?5valid?5i@
CONST	SEGMENT
??_C@_0DC@MBIBHGFE@Vertex?5edge?5iterator?5not?5valid?5i@ DB 'Vertex edge'
	DB	' iterator not valid in simplex model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JGHIEHPG@Cannot?5do?5vertices?5of?5vertex?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@JGHIEHPG@Cannot?5do?5vertices?5of?5vertex?4?6?$AA@ DB 'Cannot d'
	DB	'o vertices of vertex.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LOKJCEML@Internal?5error?3?5Bad?5INIT_ELEMENT@
CONST	SEGMENT
??_C@_0CN@LOKJCEML@Internal?5error?3?5Bad?5INIT_ELEMENT@ DB 'Internal err'
	DB	'or: Bad INIT_ELEMENT_NODE type.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DHGEIJOF@Can?5set?5parameters?5only?5for?5vert@
CONST	SEGMENT
??_C@_0CH@DHGEIJOF@Can?5set?5parameters?5only?5for?5vert@ DB 'Can set par'
	DB	'ameters only for vertices.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GEMLFPAO@Can?5set?5coordinates?5only?5for?5ver@
CONST	SEGMENT
??_C@_0CI@GEMLFPAO@Can?5set?5coordinates?5only?5for?5ver@ DB 'Can set coo'
	DB	'rdinates only for vertices.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LJLNLDOK@Internal?5error?3?5Invalid?5extra?5at@
CONST	SEGMENT
??_C@_0DB@LJLNLDOK@Internal?5error?3?5Invalid?5extra?5at@ DB 'Internal er'
	DB	'ror: Invalid extra attribute number.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@MGPBKJPH@No_transform?5only?5applies?5to?5edg@
CONST	SEGMENT
??_C@_0CP@MGPBKJPH@No_transform?5only?5applies?5to?5edg@ DB 'No_transform'
	DB	' only applies to edges or facets.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MKPPBFFJ@No_refine?5only?5applies?5to?5edges?5@
CONST	SEGMENT
??_C@_0CM@MKPPBFFJ@No_refine?5only?5applies?5to?5edges?5@ DB 'No_refine o'
	DB	'nly applies to edges or facets.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BLOJFOKI@Hit_partner?5only?5applies?5to?5vert@
CONST	SEGMENT
??_C@_0CH@BLOJFOKI@Hit_partner?5only?5applies?5to?5vert@ DB 'Hit_partner '
	DB	'only applies to vertices.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NBPCEGGM@No_display?5only?5applies?5to?5facet@
CONST	SEGMENT
??_C@_0CE@NBPCEGGM@No_display?5only?5applies?5to?5facet@ DB 'No_display o'
	DB	'nly applies to facets.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NKHDEADJ@Can?5refine?5only?5edges?5or?5facets?4@
CONST	SEGMENT
??_C@_0CC@NKHDEADJ@Can?5refine?5only?5edges?5or?5facets?4@ DB 'Can refine'
	DB	' only edges or facets.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@ODOECMFJ@Can?5equiangulate?5only?5in?5the?5SOA@
CONST	SEGMENT
??_C@_0CO@ODOECMFJ@Can?5equiangulate?5only?5in?5the?5SOA@ DB 'Can equiang'
	DB	'ulate only in the SOAPFILM model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LIFJJDEB@Can?5t1_edgeswap?5only?5edges?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@LIFJJDEB@Can?5t1_edgeswap?5only?5edges?4?6?$AA@ DB 'Can t1_edge'
	DB	'swap only edges.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IPOKAHAD@Can?5t1_edgeswap?5only?5in?5the?5STRI@
CONST	SEGMENT
??_C@_0CL@IPOKAHAD@Can?5t1_edgeswap?5only?5in?5the?5STRI@ DB 'Can t1_edge'
	DB	'swap only in the STRING model.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IADKNDDN@Can?5edgeswap?5only?5edges?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@IADKNDDN@Can?5edgeswap?5only?5edges?4?6?$AA@ DB 'Can edgeswap o'
	DB	'nly edges.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@OBDAOELG@Can?5edgeswap?5only?5in?5the?5SOAPFIL@
CONST	SEGMENT
??_C@_0EE@OBDAOELG@Can?5edgeswap?5only?5in?5the?5SOAPFIL@ DB 'Can edgeswa'
	DB	'p only in the SOAPFILM model. Did you mean t1_edgeswap?', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BKBGNKOH@Can?5pop_quad_to_quad?5only?5facets@
CONST	SEGMENT
??_C@_0CD@BKBGNKOH@Can?5pop_quad_to_quad?5only?5facets@ DB 'Can pop_quad_'
	DB	'to_quad only facets.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JJDGKHGD@Can?5pop_quad_to_quad?5only?5in?5SOA@
CONST	SEGMENT
??_C@_0CO@JJDGKHGD@Can?5pop_quad_to_quad?5only?5in?5SOA@ DB 'Can pop_quad'
	DB	'_to_quad only in SOAPFILM model.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OEOLOLOG@Can?5pop_edge_to_tri?5only?5edges?4?6@
CONST	SEGMENT
??_C@_0CB@OEOLOLOG@Can?5pop_edge_to_tri?5only?5edges?4?6@ DB 'Can pop_edg'
	DB	'e_to_tri only edges.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@KBOFAJEK@Can?5pop_edge_to_tro?5only?5in?5SOAP@
CONST	SEGMENT
??_C@_0CN@KBOFAJEK@Can?5pop_edge_to_tro?5only?5in?5SOAP@ DB 'Can pop_edge'
	DB	'_to_tro only in SOAPFILM model.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LFHDKCIA@Can?5pop_tri_to_edge?5only?5facets?4@
CONST	SEGMENT
??_C@_0CC@LFHDKCIA@Can?5pop_tri_to_edge?5only?5facets?4@ DB 'Can pop_tri_'
	DB	'to_edge only facets.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GANONAHP@Can?5pop_tri_to_edge?5only?5in?5SOAP@
CONST	SEGMENT
??_C@_0CN@GANONAHP@Can?5pop_tri_to_edge?5only?5in?5SOAP@ DB 'Can pop_tri_'
	DB	'to_edge only in SOAPFILM model.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DOEIMLPB@Can?5pop?5edges?5only?5in?5soapfilm?5m@
CONST	SEGMENT
??_C@_0CH@DOEIMLPB@Can?5pop?5edges?5only?5in?5soapfilm?5m@ DB 'Can pop ed'
	DB	'ges only in soapfilm model.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PCAOINFN@Can?5pop?5only?5edges?5or?5vertices?4?6@
CONST	SEGMENT
??_C@_0CB@PCAOINFN@Can?5pop?5only?5edges?5or?5vertices?4?6@ DB 'Can pop o'
	DB	'nly edges or vertices.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CDLLBBI@Can?5pop?5only?5in?5SOAPFILM?5or?5STRI@
CONST	SEGMENT
??_C@_0CL@CDLLBBI@Can?5pop?5only?5in?5SOAPFILM?5or?5STRI@ DB 'Can pop onl'
	DB	'y in SOAPFILM or STRING model.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@NADDAGOO@Can?5reverse_orientation?5only?5edg@
CONST	SEGMENT
??_C@_0CP@NADDAGOO@Can?5reverse_orientation?5only?5edg@ DB 'Can reverse_o'
	DB	'rientation only edges or facets.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GEOLKELN@Can?5delete?5only?5edges?5or?5facets?4@
CONST	SEGMENT
??_C@_0CC@GEOLKELN@Can?5delete?5only?5edges?5or?5facets?4@ DB 'Can delete'
	DB	' only edges or facets.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MCCPHKEO@Can?5vertex_average?5only?5vertices@
CONST	SEGMENT
??_C@_0CD@MCCPHKEO@Can?5vertex_average?5only?5vertices@ DB 'Can vertex_av'
	DB	'erage only vertices.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@LGIFMPGA@No?5vertex_average?5in?5simplex?5mod@
CONST	SEGMENT
??_C@_0CJ@LGIFMPGA@No?5vertex_average?5in?5simplex?5mod@ DB 'No vertex_av'
	DB	'erage in simplex model yet.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NHNHDHGB@Can?5unset?5centerofmass?5for?5bodie@
CONST	SEGMENT
??_C@_0CJ@NHNHDHGB@Can?5unset?5centerofmass?5for?5bodie@ DB 'Can unset ce'
	DB	'nterofmass for bodies only.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@MFLGHDJO@Cannot?5UNFIX?5bodies?4?5To?5unfix?5vo@
CONST	SEGMENT
??_C@_0DM@MFLGHDJO@Cannot?5UNFIX?5bodies?4?5To?5unfix?5vo@ DB 'Cannot UNF'
	DB	'IX bodies. To unfix volume, "unset body target".', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@MGJNCOHG@Cannot?5FIX?5bodies?4?5To?5fix?5volume@
CONST	SEGMENT
??_C@_0DO@MGJNCOHG@Cannot?5FIX?5bodies?4?5To?5fix?5volume@ DB 'Cannot FIX'
	DB	' bodies. To fix volume, do "set body target expr".', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GOBDCNHG@Illegal?5format?5specifier?3?5?$CFn?5?6?$AA@
CONST	SEGMENT
??_C@_0BP@GOBDCNHG@Illegal?5format?5specifier?3?5?$CFn?5?6?$AA@ DB 'Illeg'
	DB	'al format specifier: %n ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@FFIPKJOG@Cannot?5assign?5expression?5of?5type@
CONST	SEGMENT
??_C@_0EA@FFIPKJOG@Cannot?5assign?5expression?5of?5type@ DB 'Cannot assig'
	DB	'n expression of type %s to variable %s of type %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PNBBNCCB@Illegal?5element?5type?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@PNBBNCCB@Illegal?5element?5type?4?6?$AA@ DB 'Illegal element ty'
	DB	'pe.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NBJONBCH@Right?5side?5expression?5must?5be?5an@
CONST	SEGMENT
??_C@_0CL@NBJONBCH@Right?5side?5expression?5must?5be?5an@ DB 'Right side '
	DB	'expression must be an element.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@CMJIKKNE@Cannot?5change?5the?5number?5of?5dime@
CONST	SEGMENT
??_C@_0DF@CMJIKKNE@Cannot?5change?5the?5number?5of?5dime@ DB 'Cannot chan'
	DB	'ge the number of dimensions of array %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FMOFCBKA@Cannot?5change?5type?5of?5array?5?$CFs?4?6@
CONST	SEGMENT
??_C@_0CB@FMOFCBKA@Cannot?5change?5type?5of?5array?5?$CFs?4?6@ DB 'Cannot'
	DB	' change type of array %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@DFGHPACG@Maximum?5number?5of?5array?5dimensio@
CONST	SEGMENT
??_C@_0DG@DFGHPACG@Maximum?5number?5of?5array?5dimensio@ DB 'Maximum numb'
	DB	'er of array dimensions is %d; %s has %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PDJBPEDI@Cannot?5re?9declare?5a?5local?5fixed?9@
CONST	SEGMENT
??_C@_0DA@PDJBPEDI@Cannot?5re?9declare?5a?5local?5fixed?9@ DB 'Cannot re-'
	DB	'declare a local fixed-size array %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@IOIJAIMG@Illegal?5to?5convert?5ordinary?5vari@
CONST	SEGMENT
??_C@_0DH@IOIJAIMG@Illegal?5to?5convert?5ordinary?5vari@ DB 'Illegal to c'
	DB	'onvert ordinary variable "%s" into array.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OOLAKBHI@Cannot?5change?5number?5of?5dimensio@
CONST	SEGMENT
??_C@_0CK@OOLAKBHI@Cannot?5change?5number?5of?5dimensio@ DB 'Cannot chang'
	DB	'e number of dimensions of %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@3f1a36e2eb1c432d
CONST	SEGMENT
__real@3f1a36e2eb1c432d DQ 03f1a36e2eb1c432dr	; 0.0001
CONST	ENDS
;	COMDAT ??_C@_0DA@JJBDKLNJ@Variable?5?$CFs?5is?5not?5proper?5type?5f@
CONST	SEGMENT
??_C@_0DA@JJBDKLNJ@Variable?5?$CFs?5is?5not?5proper?5type?5f@ DB 'Variabl'
	DB	'e %s is not proper type for assignment.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@FPHMDPLJ@Variable?5?$CFs?5is?5not?5proper?5type?5f@
CONST	SEGMENT
??_C@_0DN@FPHMDPLJ@Variable?5?$CFs?5is?5not?5proper?5type?5f@ DB 'Variabl'
	DB	'e %s is not proper type for left side of assignment.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MJAAACDM@Array?5?$CFs?5is?5read?9only?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@MJAAACDM@Array?5?$CFs?5is?5read?9only?4?6?$AA@ DB 'Array %s is '
	DB	'read-only.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@BDIEAHJL@Array?5?$CFs?5has?5wrong?5number?5of?5dim@
CONST	SEGMENT
??_C@_0DH@BDIEAHJL@Array?5?$CFs?5has?5wrong?5number?5of?5dim@ DB 'Array %'
	DB	's has wrong number of dimensions; should be %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@DIIILPA@Arrays?5don?8t?5have?5same?5number?5of@
CONST	SEGMENT
??_C@_0EF@DIIILPA@Arrays?5don?8t?5have?5same?5number?5of@ DB 'Arrays don'''
	DB	't have same number of dimensions or types are different.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ILBCJIOO@temp_array_?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@ILBCJIOO@temp_array_?$CFd?$AA@ DB 'temp_array_%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@HHJIPDPG@Arrays?5don?8t?5have?5same?5number?5of@
CONST	SEGMENT
??_C@_0EB@HHJIPDPG@Arrays?5don?8t?5have?5same?5number?5of@ DB 'Arrays don'
	DB	'''t have same number of dimensions or types different.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CFLEBAG@Dot?5product?5operands?5must?5be?5of?5@
CONST	SEGMENT
??_C@_0CM@CFLEBAG@Dot?5product?5operands?5must?5be?5of?5@ DB 'Dot product'
	DB	' operands must be of type real.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LMHOJAKD@Dot?5product?5operands?5must?5be?5one@
CONST	SEGMENT
??_C@_0CP@LMHOJAKD@Dot?5product?5operands?5must?5be?5one@ DB 'Dot product'
	DB	' operands must be one dimensional.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@IPLHDPDE@Array?5?$CFs?5should?5have?5at?5most?5?$CFd?5@
CONST	SEGMENT
??_C@_0DC@IPLHDPDE@Array?5?$CFs?5should?5have?5at?5most?5?$CFd?5@ DB 'Arr'
	DB	'ay %s should have at most %d indexes, has %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PEOAOHHI@?8?$CFs?8?5cannot?5be?5made?5an?5optimizin@
CONST	SEGMENT
??_C@_0CO@PEOAOHHI@?8?$CFs?8?5cannot?5be?5made?5an?5optimizin@ DB '''%s'''
	DB	' cannot be made an optimizing parameter.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GNJOFDDC@Cannot?5set?5internal?5variable?5?8?$CFs@
CONST	SEGMENT
??_C@_0CE@GNJOFDDC@Cannot?5set?5internal?5variable?5?8?$CFs@ DB 'Cannot s'
	DB	'et internal variable ''%s''.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@BIBENIGB@Please?5use?5integral_order_1d?5or?5@
CONST	SEGMENT
??_C@_0DE@BIBENIGB@Please?5use?5integral_order_1d?5or?5@ DB 'Please use i'
	DB	'ntegral_order_1d or integral_order_2d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PEJKEKJN@Need?5exactly?5?$CFd?5vertices?5in?5NEW_@
CONST	SEGMENT
??_C@_0CO@PEJKEKJN@Need?5exactly?5?$CFd?5vertices?5in?5NEW_@ DB 'Need exa'
	DB	'ctly %d vertices in NEW_FACET (...).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IHGLLACA@facet_crosscut?$CI?$CJ?5only?5valid?5in?5s@
CONST	SEGMENT
??_C@_0CO@IHGLLACA@facet_crosscut?$CI?$CJ?5only?5valid?5in?5s@ DB 'facet_'
	DB	'crosscut() only valid in string model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@PFHFLMGE@Need?5exactly?5?$CFd?5coordinates?5in?5N@
CONST	SEGMENT
??_C@_0DC@PFHFLMGE@Need?5exactly?5?$CFd?5coordinates?5in?5N@ DB 'Need exa'
	DB	'ctly %d coordinates in NEW_VERTEX (...).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LOPGCAPG@Unimplemented?5subtype?5of?5body?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@LOPGCAPG@Unimplemented?5subtype?5of?5body?4?6?$AA@ DB 'Unimplem'
	DB	'ented subtype of body.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FJBLHHOF@Unimplemented?5subtype?5of?5facet?4?6@
CONST	SEGMENT
??_C@_0CB@FJBLHHOF@Unimplemented?5subtype?5of?5facet?4?6@ DB 'Unimplement'
	DB	'ed subtype of facet.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@EMPJHMEM@Unimplemented?5subtype?5of?5edge?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@EMPJHMEM@Unimplemented?5subtype?5of?5edge?4?6?$AA@ DB 'Unimplem'
	DB	'ented subtype of edge.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IHNNOPLF@Unimplemented?5subtype?5of?5vertex?4@
CONST	SEGMENT
??_C@_0CC@IHNNOPLF@Unimplemented?5subtype?5of?5vertex?4@ DB 'Unimplemente'
	DB	'd subtype of vertex.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@ELHMDCJI@Cannot?5do?5same?5subtype?5as?5type?5o@
CONST	SEGMENT
??_C@_0CM@ELHMDCJI@Cannot?5do?5same?5subtype?5as?5type?5o@ DB 'Cannot do '
	DB	'same subtype as type of element.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@ODFFJHOG@Element?5index?5must?5be?5positive?4?6@
CONST	SEGMENT
??_C@_0CB@ODFFJHOG@Element?5index?5must?5be?5positive?4?6@ DB 'Element in'
	DB	'dex must be positive.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CBCKOCFL@Element?5index?5must?5be?5nonzero?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@CBCKOCFL@Element?5index?5must?5be?5nonzero?4?6?$AA@ DB 'Element'
	DB	' index must be nonzero.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KJKMGOKE@Procedure?5?$CC?$CFs?$CC?5needs?5?$CFd?5argument@
CONST	SEGMENT
??_C@_0DB@KJKMGOKE@Procedure?5?$CC?$CFs?$CC?5needs?5?$CFd?5argument@ DB 'P'
	DB	'rocedure "%s" needs %d arguments; call has %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LABGMEKM@on_assign_call?5procedure?5cannot?5@
CONST	SEGMENT
??_C@_0DB@LABGMEKM@on_assign_call?5procedure?5cannot?5@ DB 'on_assign_cal'
	DB	'l procedure cannot have arguments.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NEJEBFAM@Function?5?$CC?$CFs?$CC?5needs?5?$CFd?5arguments@
CONST	SEGMENT
??_C@_0DA@NEJEBFAM@Function?5?$CC?$CFs?$CC?5needs?5?$CFd?5arguments@ DB 'F'
	DB	'unction "%s" needs %d arguments; call has %d,', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LEPAHKPA@Cannot?5redefine?5?8?$CFs?8?5as?5a?5functi@
CONST	SEGMENT
??_C@_0CF@LEPAHKPA@Cannot?5redefine?5?8?$CFs?8?5as?5a?5functi@ DB 'Cannot'
	DB	' redefine ''%s'' as a function.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OCKAMEPI@Non?9permanent?5items?5in?5definitio@
CONST	SEGMENT
??_C@_0CK@OCKAMEPI@Non?9permanent?5items?5in?5definitio@ DB 'Non-permanen'
	DB	't items in definition of %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HBMNHHDH@Cannot?5redefine?5variable?5?8?$CFs?8?5as@
CONST	SEGMENT
??_C@_0CN@HBMNHHDH@Cannot?5redefine?5variable?5?8?$CFs?8?5as@ DB 'Cannot '
	DB	'redefine variable ''%s'' as a command.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IBKBDFEL@Illegal?5redefine?4?6?$AA@
CONST	SEGMENT
??_C@_0BD@IBKBDFEL@Illegal?5redefine?4?6?$AA@ DB 'Illegal redefine.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MBGCPADL@Illegal?5unredefine?4?6?$AA@
CONST	SEGMENT
??_C@_0BF@MBGCPADL@Illegal?5unredefine?4?6?$AA@ DB 'Illegal unredefine.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@IMBGKBA@matrix_determinant?5array?5is?5not?5@
CONST	SEGMENT
??_C@_0DC@IMBGKBA@matrix_determinant?5array?5is?5not?5@ DB 'matrix_determ'
	DB	'inant array is not two-dimensional.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GJDLMJDI@matrix_inverse?5second?5array?5is?5n@
CONST	SEGMENT
??_C@_0DF@GJDLMJDI@matrix_inverse?5second?5array?5is?5n@ DB 'matrix_inver'
	DB	'se second array is not two-dimensional.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@JGEOBBCA@matrix_inverse?5first?5array?5is?5no@
CONST	SEGMENT
??_C@_0DE@JGEOBBCA@matrix_inverse?5first?5array?5is?5no@ DB 'matrix_inver'
	DB	'se first array is not two-dimensional.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@KKELGCPH@matrix_inverse?3?5second?5matrix?5is@
CONST	SEGMENT
??_C@_0DE@KKELGCPH@matrix_inverse?3?5second?5matrix?5is@ DB 'matrix_inver'
	DB	'se: second matrix is not of type REAL.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JNOCGJAC@matrix_inverse?3?5first?5matrix?5is?5@
CONST	SEGMENT
??_C@_0DD@JNOCGJAC@matrix_inverse?3?5first?5matrix?5is?5@ DB 'matrix_inve'
	DB	'rse: first matrix is not of type REAL.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@OAKEJDGP@matrix_multiply?3?5second?5and?5thir@
CONST	SEGMENT
??_C@_0EJ@OAKEJDGP@matrix_multiply?3?5second?5and?5thir@ DB 'matrix_multi'
	DB	'ply: second and third matrices must not be the same matrix.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@PHKJOELK@matrix_multiply?3?5first?5and?5third@
CONST	SEGMENT
??_C@_0EI@PHKJOELK@matrix_multiply?3?5first?5and?5third@ DB 'matrix_multi'
	DB	'ply: first and third matrices must not be the same matrix.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FHFPHPDO@matrix_multiply?3?5third?5matrix?5is@
CONST	SEGMENT
??_C@_0DE@FHFPHPDO@matrix_multiply?3?5third?5matrix?5is@ DB 'matrix_multi'
	DB	'ply: third matrix is not of type REAL.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@MGFJOCIL@matrix_multiply?3?5second?5matrix?5i@
CONST	SEGMENT
??_C@_0DF@MGFJOCIL@matrix_multiply?3?5second?5matrix?5i@ DB 'matrix_multi'
	DB	'ply: second matrix is not of type REAL.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IJPHPIFG@matrix_multiply?3?5first?5matrix?5is@
CONST	SEGMENT
??_C@_0DE@IJPHPIFG@matrix_multiply?3?5first?5matrix?5is@ DB 'matrix_multi'
	DB	'ply: first matrix is not of type REAL.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KDIHDDIN@Element?5id?50?5is?5illegal?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@KDIHDDIN@Element?5id?50?5is?5illegal?4?6?$AA@ DB 'Element id 0 '
	DB	'is illegal.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@NEDBIMHF@Internal?5error?3?5loopdepth?5negati@
CONST	SEGMENT
??_C@_0CF@NEDBIMHF@Internal?5error?3?5loopdepth?5negati@ DB 'Internal err'
	DB	'or: loopdepth negative.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JMJIJLCN@BREAK?5or?5CONTINUE?5out?5of?5too?5man@
CONST	SEGMENT
??_C@_0CL@JMJIJLCN@BREAK?5or?5CONTINUE?5out?5of?5too?5man@ DB 'BREAK or C'
	DB	'ONTINUE out of too many levels.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@CLANOEMJ@Cannot?5BREAK?5or?5CONTINUE?5unless?5@
CONST	SEGMENT
??_C@_0DA@CLANOEMJ@Cannot?5BREAK?5or?5CONTINUE?5unless?5@ DB 'Cannot BREA'
	DB	'K or CONTINUE unless inside a loop.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LNGHNJGK@Index?5?$CFd?5must?5be?5nonnegative?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@LNGHNJGK@Index?5?$CFd?5must?5be?5nonnegative?4?6?$AA@ DB 'Index'
	DB	' %d must be nonnegative.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GLHPNAPD@Index?5?$CFd?5must?5be?5positive?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@GLHPNAPD@Index?5?$CFd?5must?5be?5positive?4?6?$AA@ DB 'Index %d'
	DB	' must be positive.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _makenode
_TEXT	SEGMENT
tv9529 = -152						; size = 4
tv9525 = -148						; size = 4
_b$89600 = -148						; size = 4
tv9528 = -144						; size = 4
_i$90047 = -144						; size = 4
_c$89602 = -144						; size = 4
tv11427 = -140						; size = 4
_i$90145 = -140						; size = 4
_i$90119 = -140						; size = 4
_rexpr_node$90046 = -140				; size = 4
tv11371 = -136						; size = 4
tv11338 = -136						; size = 4
_i$90169 = -136						; size = 4
_datatype$90029 = -136					; size = 4
tv10982 = -132						; size = 4
tv9247 = -132						; size = 4
_type$ = -132						; size = 2
_ar$90117 = -132					; size = 4
_adim$90091 = -132					; size = 4
_a$90080 = -132						; size = 4
_n$89765 = -132						; size = 4
_wnode$89754 = -132					; size = 4
_a$89615 = -132						; size = 4
_a$89598 = -132						; size = 4
tv11449 = -128						; size = 4
tv11404 = -128						; size = 4
tv8520 = -128						; size = 4
_ar$90143 = -128					; size = 4
_al$90115 = -128					; size = 4
_name1$90089 = -128					; size = 4
_b$89617 = -128						; size = 4
_n$ = -128						; size = 4
_g$90224 = -124						; size = 4
_al$90165 = -124					; size = 4
_pointercount$90147 = -124				; size = 4
_pointercount$90121 = -124				; size = 4
_name2$90090 = -124					; size = 4
_datacount$90053 = -124					; size = 4
_indexset_node$90045 = -124				; size = 4
tv9134 = -120						; size = 4
tv9030 = -120						; size = 4
_g$90263 = -120						; size = 4
_g$90255 = -120						; size = 4
_g$ = -120						; size = 4
_pointercount$90171 = -120				; size = 4
_temp_id$90163 = -120					; size = 4
_dim$90030 = -120					; size = 4
tv9249 = -116						; size = 4
tv8522 = -116						; size = 4
_left$GSCopy$ = -116					; size = 4
_temp_id$90141 = -116					; size = 4
_temp_id$90113 = -116					; size = 4
tv9136 = -112						; size = 4
tv9032 = -112						; size = 4
tv8548 = -112						; size = 4
_right$GSCopy$ = -112					; size = 4
_eltype$90232 = -112					; size = 4
_pointercount$90054 = -112				; size = 4
_g$90011 = -112						; size = 4
_g$89987 = -112						; size = 4
_g$89973 = -112						; size = 4
tv8511 = -108						; size = 4
_g$90229 = -108						; size = 4
_ar$90167 = -108					; size = 4
_g$90026 = -108						; size = 4
_etype$ = -108						; size = 4
_tempname$90162 = -104					; size = 100
_tempname$90140 = -104					; size = 100
_tempname$90112 = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_ntype$ = 8						; size = 4
_left$ = 12						; size = 4
_right$ = 16						; size = 4
_makenode PROC						; COMDAT

; 246  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 247  :   short type = (short)ntype;

	movzx	eax, WORD PTR _ntype$[ebp]

; 248  :   int i,n;
; 249  :   struct treenode *nnode;
; 250  :   struct global *g;
; 251  :   int etype = -1; /* element type */
; 252  : 
; 253  :   if ( listtop > listmax - 10 )

	mov	ecx, DWORD PTR _listmax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _left$[ebp]
	mov	DWORD PTR _type$[ebp], eax
	mov	eax, DWORD PTR _listtop
	lea	edx, DWORD PTR [ecx-10]
	push	edi
	mov	edi, DWORD PTR _right$[ebp]
	mov	DWORD PTR _left$GSCopy$[ebp], esi
	mov	DWORD PTR _etype$[ebp], -1
	cmp	eax, edx
	jle	SHORT $LN578@makenode

; 254  :   { list = (struct treenode *)kb_realloc((char*)list,
; 255  :               (listmax+LISTMAX)*sizeof(struct treenode));

	mov	eax, DWORD PTR _list
	add	ecx, 200				; 000000c8H
	imul	ecx, 168				; 000000a8H
	push	255					; 000000ffH
	push	OFFSET ??_C@_0L@OKHAMMPH@YEXPARSE?4C?$AA@
	push	ecx
	push	eax
	call	_KB_realloc
	add	esp, 16					; 00000010H

; 256  :     listmax += LISTMAX;

	add	DWORD PTR _listmax, 200			; 000000c8H
	mov	DWORD PTR _list, eax

; 257  :   }
; 258  :   else

	jmp	SHORT $LN577@makenode
$LN578@makenode:

; 259  :      memset((char*)(list+listtop),0,2*sizeof(struct treenode)); /* clear nodes */

	imul	eax, 168				; 000000a8H
	add	eax, DWORD PTR _list
	push	336					; 00000150H
	push	0
	push	eax
	call	_memset
	mov	eax, DWORD PTR _list
	add	esp, 12					; 0000000cH
$LN577@makenode:

; 260  :   switch ( type )

	mov	ecx, DWORD PTR _ntype$[ebp]
	movsx	ebx, cx
	mov	edx, ebx
	cmp	edx, 10262				; 00002816H
	jg	$LN820@makenode
	je	$LN454@makenode
	sub	edx, 10002				; 00002712H
	cmp	edx, 239				; 000000efH
	ja	$LN2@makenode
	movzx	ecx, BYTE PTR $LN864@makenode[edx]
	jmp	DWORD PTR $LN946@makenode[ecx*4]
$LN570@makenode:

; 280  : 
; 281  :       case WHEREAMI_COMMAND_NODE:
; 282  :          list[listtop].type = WHEREAMI_COMMAND_NODE;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10007		; 00002717H

; 283  :          break;

	jmp	$LN878@makenode
$LN569@makenode:

; 284  : 
; 285  :       case SET_BREAKPOINT_NODE:
; 286  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 287  :          list[listtop].op1.name_id = left;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], esi
$LN922@makenode:

; 288  :          list[listtop].left = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edi
$LN567@makenode:

; 289  :          list[listtop].flags |= EPHEMERAL;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	or	DWORD PTR [edx+eax+24], 64		; 00000040H
	lea	eax, DWORD PTR [edx+eax+24]

; 290  :          break;

	jmp	$LN878@makenode
$LN568@makenode:

; 291  : 
; 292  :       case UNSET_BREAKPOINT_NODE:
; 293  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 294  :          list[listtop].op1.name_id = left;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], esi

; 295  :          if ( right )

	test	edi, edi
	je	SHORT $LN567@makenode

; 296  :            list[listtop].left = right - listtop;
; 297  :          list[listtop].flags |= EPHEMERAL;
; 298  :          break;

	jmp	SHORT $LN922@makenode
$LN566@makenode:

; 299  : 
; 300  :       case BACKQUOTE_START_NODE:
; 301  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 302  :          break;

	jmp	$LN878@makenode
$LN565@makenode:

; 303  : 
; 304  :       case BACKQUOTE_END_NODE:
; 305  :          list[listtop].type = FINISHED_NODE;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10386		; 00002892H

; 306  :          listtop++;

	mov	eax, DWORD PTR _listtop

; 307  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _list
	inc	eax
	mov	DWORD PTR _listtop, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], ebx

; 308  :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 309  :          list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, edi
	sub	edx, eax
	imul	eax, 168				; 000000a8H

; 310  :          list[left].op1.skipsize = right-left+1; /* so START can jump over */

	sub	edi, esi
	inc	edi
	imul	esi, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edx
	mov	edx, DWORD PTR _list
	mov	DWORD PTR [esi+edx+32], edi

; 311  :          break;

	jmp	$LN878@makenode
$LN564@makenode:

; 312  : 
; 313  :       /* command ',' expr */
; 314  :       case ACOMMANDEXPR_NODE:
; 315  :          list[listtop].type = ACOMMANDEXPR_NODE;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], 10038		; 00002736H

; 316  :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 317  :          list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edi
$LN924@makenode:

; 318  :          list[listtop].datatype = REAL_TYPE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+20], 1

; 319  :          break;

	jmp	$LN878@makenode
$LN563@makenode:

; 320  : 
; 321  : 
; 322  :       /* IF THEN ELSE parse tree
; 323  : 
; 324  :              ELSE_
; 325  :              /     \
; 326  :               IF_    command2
; 327  :              /    \
; 328  :           IFTEST_  command1
; 329  :           /
; 330  :      testexpr
; 331  : 
; 332  :      sequence: testexpr IFTEST_ command1 IF_ command2 ELSE_
; 333  : 
; 334  :      */
; 335  :       case IFTEST_NODE:
; 336  :          list[listtop].type = IFTEST_NODE;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], 10062		; 0000274eH

; 337  :          list[listtop].left = left - listtop; /* test expression */
; 338  :          /* op1 will be offset for jump if condition false */
; 339  :          list[listtop].stack_delta = -1;
; 340  :          break;

	jmp	$LN920@makenode
$LN562@makenode:

; 341  : 
; 342  :       case IF_NODE:
; 343  :          list[listtop].type = IF_NODE;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10064		; 00002750H

; 344  :          list[listtop].left = left - listtop;  /* IFTEST_ */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, esi
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx
$LN925@makenode:

; 345  :          list[listtop].right = right - listtop; /* THEN command */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edi
$LN560@makenode:

; 346  :          list[left].op1.skipsize = listtop - left; /* in IFTEST_ node */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	sub	edx, esi
	imul	esi, 168				; 000000a8H
	mov	DWORD PTR [esi+eax+32], edx

; 347  :          /* op1 will be offset to skip ELSE part */
; 348  :          break;

	jmp	$LN878@makenode
$LN559@makenode:

; 356  :       
; 357  :       case DECLARE_LOCAL_NODE:
; 358  :          list[listtop].type = DECLARE_LOCAL_NODE;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], 10030		; 0000272eH

; 359  :          list[listtop].op1.name_id = left; /* identifier */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], esi

; 360  :          globals(left)->flags |= GLOB_LOCALVAR;

	mov	eax, esi
	and	eax, -16777216				; ff000000H
	and	esi, 16777215				; 00ffffffH
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN585@makenode
	mov	ecx, DWORD PTR _web+5652
	mov	eax, DWORD PTR _dymem
	lea	edx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [edx+eax]
	or	DWORD PTR [esi+192], 524288		; 00080000H

; 361  :    /*     globals(left)->flags |= ORDINARY_PARAM; */
; 362  :          break;

	jmp	$LN878@makenode
$LN585@makenode:

; 360  :          globals(left)->flags |= GLOB_LOCALVAR;

	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN583@makenode
	mov	ecx, DWORD PTR _localbase
	imul	esi, 224				; 000000e0H
	add	esi, DWORD PTR [ecx]
	or	DWORD PTR [esi+192], 524288		; 00080000H

; 361  :    /*     globals(left)->flags |= ORDINARY_PARAM; */
; 362  :          break;

	jmp	$LN878@makenode
$LN583@makenode:

; 360  :          globals(left)->flags |= GLOB_LOCALVAR;

	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN581@makenode
	mov	edx, DWORD PTR _web+5656
	mov	esi, DWORD PTR [edx+esi*4]
	or	DWORD PTR [esi+192], 524288		; 00080000H

; 361  :    /*     globals(left)->flags |= ORDINARY_PARAM; */
; 362  :          break;

	jmp	$LN878@makenode
$LN581@makenode:

; 360  :          globals(left)->flags |= GLOB_LOCALVAR;

	mov	eax, DWORD PTR _web+5652
	mov	edx, DWORD PTR _dymem
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+edx]
	or	DWORD PTR [esi+192], 524288		; 00080000H

; 361  :    /*     globals(left)->flags |= ORDINARY_PARAM; */
; 362  :          break;

	jmp	$LN878@makenode
$LN558@makenode:

; 363  :  
; 364  :       case LOCAL_LIST_START_NODE:
; 365  :          list[listtop].type = LOCAL_LIST_START_NODE;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], 10031		; 0000272fH
$LN926@makenode:

; 366  :          list[listtop].left = left-listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 367  :          break;

	jmp	$LN878@makenode
$LN556@makenode:

; 374  : 
; 375  :       case INDEXSET_NODE:
; 376  :          list[listtop].type = INDEXSET_NODE;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], 10039		; 00002737H

; 377  :          /* "left" is previous indexset  */
; 378  :          /* "right" is next index expression */
; 379  :          /* note we have to use left pointer if any used at all for
; 380  :             later nodes trying to find start of subtree */
; 381  :          if ( left )

	test	esi, esi
	je	SHORT $LN555@makenode

; 382  :          { /* then left is previous indexlist */
; 383  :            list[listtop].left = left-listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi

; 384  :            list[listtop].right = right-listtop;
; 385  :            list[listtop].op5.indexcount = list[left].op5.indexcount+1; 

	imul	esi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, edi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edx
	mov	eax, DWORD PTR _list
	mov	edx, DWORD PTR [esi+eax+152]
	mov	ecx, DWORD PTR _listtop
	inc	edx
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax+152], edx

; 386  :          } 
; 387  :          else 

	jmp	SHORT $LN554@makenode
$LN555@makenode:

; 388  :          { list[listtop].op5.indexcount = 1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+152], 1

; 389  :            list[listtop].left = right-listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, edi
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx
$LN554@makenode:

; 390  :          }
; 391  :          /* Sanity check on index */
; 392  :          if ( list[right].type == PUSHCONST_NODE )

	mov	esi, DWORD PTR _list
	imul	edi, 168				; 000000a8H
	cmp	DWORD PTR [edi+esi], 10095		; 0000276fH
	lea	eax, DWORD PTR [edi+esi]
	jne	$LN878@makenode

; 393  :          { if ( (int)(list[right].op1.real) < 1 ) 

	fld	QWORD PTR [eax+32]
	call	__ftol2_sse
	cmp	eax, 1
	jge	$LN878@makenode

; 394  :            { sprintf(errmsg,"Index %d must be positive.\n",
; 395  :                       list[listtop].op5.indexcount);

	mov	eax, DWORD PTR _listtop
	imul	eax, 168				; 000000a8H
	mov	ecx, DWORD PTR [eax+esi+152]
	push	ecx
	push	OFFSET ??_C@_0BM@GLHPNAPD@Index?5?$CFd?5must?5be?5positive?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 396  :              kb_error(2238,errmsg, COMMAND_ERROR);          

	push	5
	push	OFFSET _errmsg
	push	2238					; 000008beH
	call	_kb_error
	add	esp, 24					; 00000018H

; 397  :            }
; 398  :          }
; 399  :          break;

	jmp	$LN878@makenode
$LN551@makenode:

; 400  : 
; 401  :       case DIMENSIONSET_NODE:
; 402  :          /* "left" is previous indexset, except in leaf it is index expr  */
; 403  :          /* "right" is next index expression, except 0 in leaf */
; 404  :          list[listtop].type = DIMENSIONSET_NODE;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10040		; 00002738H

; 405  :          if ( left )  /* have previous dimensionset */
; 406  :          { list[listtop].left = left-listtop;

	mov	eax, DWORD PTR _listtop
	test	esi, esi
	je	SHORT $LN550@makenode
	mov	edx, DWORD PTR _list
	mov	ecx, esi

; 407  :            list[listtop].op5.indexcount = list[left].op5.indexcount+1;

	imul	esi, 168				; 000000a8H
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [esi+eax+152]
	inc	ecx
	mov	DWORD PTR [edx+eax+152], ecx

; 408  :            list[listtop].right = right-listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, edi
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], ecx

; 409  :          } else 

	jmp	SHORT $LN549@makenode
$LN550@makenode:

; 410  :          { list[listtop].op5.indexcount = 1;

	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+152], 1

; 411  :            list[listtop].left = right-listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, edi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx
$LN549@makenode:

; 412  :          }
; 413  :          /* Sanity check on index */
; 414  :          if ( list[right].type == PUSHCONST_NODE )

	mov	esi, DWORD PTR _list
	imul	edi, 168				; 000000a8H
	cmp	DWORD PTR [edi+esi], 10095		; 0000276fH
	lea	eax, DWORD PTR [edi+esi]
	jne	$LN878@makenode

; 415  :          { if ( (int)(list[right].op1.real) < 0 ) /* can be 0 in define */

	fld	QWORD PTR [eax+32]
	call	__ftol2_sse
	test	eax, eax
	jns	$LN878@makenode

; 416  :            { sprintf(errmsg,"Index %d must be nonnegative.\n",
; 417  :                       list[listtop].op5.indexcount);

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	eax, DWORD PTR [edx+esi+152]
	push	eax
	push	OFFSET ??_C@_0BP@LNGHNJGK@Index?5?$CFd?5must?5be?5nonnegative?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 418  :              kb_error(2522,errmsg, COMMAND_ERROR);          

	push	5
	push	OFFSET _errmsg
	push	2522					; 000009daH
	call	_kb_error
	add	esp, 24					; 00000018H

; 419  :            }
; 420  :          }
; 421  :          break;

	jmp	$LN878@makenode
$LN541@makenode:

; 461  :  
; 462  :       case ATTR_FUNCTION_NODE: /* attribute function */
; 463  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 464  :          list[listtop].left = left-listtop; /* main define  */
; 465  :          break;

	jmp	$LN926@makenode
$LN540@makenode:

; 466  : 
; 467  :       case ATTR_FUNCTION_END_NODE: /* attribute function */
; 468  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 469  :          list[listtop].left = left-listtop; /* ATTR_FUNCTION node  */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 470  :          list[listtop].right = right-listtop; /* function */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edi

; 471  :          break;

	jmp	$LN878@makenode
$LN539@makenode:

; 472  : 
; 473  : 
; 474  :       case RETURN_NODE: /* end command */
; 475  :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 476  :          if ( left ) list[listtop].left = left - listtop; /* return expr */

	test	esi, esi
	je	$LN878@makenode
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], esi

; 477  :          break;

	jmp	$LN878@makenode
$LN533@makenode:

; 482  : 
; 483  :       case FLUSH_COUNTS_NODE:  /* print pending counts */
; 484  :          list[listtop].type = type;
; 485  :          break;
; 486  : 
; 487  :       case PAUSE_NODE:  /* wait for user */
; 488  :          list[listtop].type = type;
; 489  :          break;
; 490  : 
; 491  :       case PRINT_PROFILING_NODE:
; 492  :       case RESET_PROFILING_NODE:
; 493  :          list[listtop].type = type;
; 494  :          break;
; 495  : 
; 496  :       case BREAK_NODE:
; 497  :       case CONTINUE_NODE:
; 498  :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 499  :          if ( loopdepth < 1 )

	mov	eax, DWORD PTR _loopdepth
	cmp	eax, 1
	jge	SHORT $LN532@makenode

; 500  :            kb_error(1388,"Cannot BREAK or CONTINUE unless inside a loop.\n",
; 501  :             COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DA@CLANOEMJ@Cannot?5BREAK?5or?5CONTINUE?5unless?5@
	push	1388					; 0000056cH
	call	_kb_error
	mov	eax, DWORD PTR _loopdepth
	add	esp, 12					; 0000000cH
$LN532@makenode:

; 502  :          if ( loopdepth < left )

	cmp	eax, esi
	jge	SHORT $LN531@makenode

; 503  :            kb_error(1389,"BREAK or CONTINUE out of too many levels.\n",
; 504  :             COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CL@JMJIJLCN@BREAK?5or?5CONTINUE?5out?5of?5too?5man@
	push	1389					; 0000056dH
	call	_kb_error
	mov	eax, DWORD PTR _loopdepth
	add	esp, 12					; 0000000cH
$LN531@makenode:

; 505  :          list[listtop].op1.skipsize = loopbase[loopdepth-left]-listtop;

	mov	edx, DWORD PTR _list
	sub	eax, esi
	mov	ecx, DWORD PTR _loopbase[eax*4]
	mov	eax, DWORD PTR _listtop
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+32], ecx

; 506  :          list[listtop].op2.breakdepth = left; 

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+136], esi

; 507  :          break;

	jmp	$LN878@makenode
$LN530@makenode:

; 508  : 
; 509  : /* WHILE DO tree:     WHILE_END_
; 510  :                       /        \
; 511  :                 WHILE_TOP_    command 
; 512  :                  /
; 513  :             testexpr
; 514  : 
; 515  : execution sequence: testexpr WHILE_TOP_ command WHILE_END_
; 516  : */
; 517  :       case WHILE_TOP_NODE:
; 518  :          list[listtop].type = WHILE_TOP_NODE;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10068		; 00002754H

; 519  :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, esi
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx

; 520  :          /* op1 will be offset to after WHILE_END_ */
; 521  :          loopbase[loopdepth++] = listtop;

	mov	eax, DWORD PTR _loopdepth
	mov	edx, DWORD PTR _listtop

; 522  :              /* find start of WHILE expression */
; 523  :          for ( n = left ; list[n].left ; n += list[n].left ) ; 

	mov	edi, DWORD PTR _list
	mov	DWORD PTR _loopbase[eax*4], edx
	inc	eax
	mov	DWORD PTR _loopdepth, eax
	mov	eax, esi
	imul	esi, 168				; 000000a8H
	mov	esi, DWORD PTR [esi+edi+4]
	test	esi, esi
	je	SHORT $LN527@makenode
	mov	ecx, esi
$LL529@makenode:
	add	eax, ecx
	mov	ecx, eax
	imul	ecx, 168				; 000000a8H
	mov	ecx, DWORD PTR [ecx+edi+4]
	test	ecx, ecx
	jne	SHORT $LL529@makenode
$LN527@makenode:

; 524  :          list[listtop].op4.contjump = n - listtop - 1; /* for continue */

	sub	eax, edx
	imul	edx, 168				; 000000a8H
	dec	eax

; 525  :          i = add_local_var(NULL,1);

	push	1
	push	0
	mov	DWORD PTR [edx+edi+148], eax
	call	_add_local_var

; 526  :          list[listtop].stackpos = get_local(i).offset;

	mov	edx, DWORD PTR _localbase
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _listtop
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	mov	eax, DWORD PTR [eax+ecx+216]
	mov	ecx, DWORD PTR _list
	add	esp, 8
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+ecx+160], eax
$LN512@makenode:

; 527  :          list[listtop].stack_delta = -1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], -1

; 528  :          break;

	jmp	$LN878@makenode
$LN526@makenode:

; 529  : 
; 530  :       case WHILE_END_NODE:
; 531  :          list[listtop].type = WHILE_END_NODE;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], 10069		; 00002755H

; 532  :          list[listtop].left = left - listtop; /* test */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 533  :          list[listtop].right = right - listtop; /* command */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi

; 534  :          list[left].op1.skipsize = listtop - left; /* jump if test fails */

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	eax, esi
	imul	eax, 168				; 000000a8H
	sub	ecx, esi
	mov	DWORD PTR [eax+edx+32], ecx

; 535  :          list[left].op3.breakjump = listtop - left; /* for break */

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	ecx, esi
	mov	DWORD PTR [eax+edx+140], ecx

; 536  :          /* find start of WHILE test expression and set jump back */
; 537  :          for ( n = left ; list[n].left ; n += list[n].left ) ; 

	mov	ecx, DWORD PTR _list
	mov	eax, DWORD PTR [eax+ecx+4]
	test	eax, eax
	je	SHORT $LN523@makenode
	npad	8
$LL525@makenode:
	add	esi, eax
	mov	eax, esi
	imul	eax, 168				; 000000a8H
	mov	eax, DWORD PTR [eax+ecx+4]
	test	eax, eax
	jne	SHORT $LL525@makenode
$LN523@makenode:

; 538  :          list[listtop].op1.skipsize = n - listtop - 1; /* allow increment */

	mov	eax, DWORD PTR _listtop
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	dec	esi
	mov	DWORD PTR [eax+ecx+32], esi

; 539  :          loopdepth--;

	dec	DWORD PTR _loopdepth

; 540  :          if ( loopdepth < 0 )

	jns	$LN878@makenode

; 541  :            kb_error(1390,"Internal error: loopdepth negative.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CF@NEDBIMHF@Internal?5error?3?5loopdepth?5negati@
	push	1390					; 0000056eH
	call	_kb_error

; 542  : 
; 543  :          break;

	jmp	$LN907@makenode
$LN521@makenode:

; 544  : 
; 545  : 
; 546  : /*  DO WHILE tree:        DO_END_
; 547  :                         /        \
; 548  :                      DO_TOP_    test expr
; 549  :                     /             / 
; 550  :                    DO_ENTRY_     command
; 551  : 
; 552  : execution sequence:  DO_ENTRY command DO_TOP_ test expr DO_END_
; 553  : */
; 554  :       case DO_ENTRY_NODE:
; 555  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 556  :          loopbase[loopdepth++] = listtop;

	mov	eax, DWORD PTR _loopdepth
	mov	edx, DWORD PTR _listtop
	mov	DWORD PTR _loopbase[eax*4], edx
	inc	eax

; 557  :          /* op3 will hold offsets for break and continue */
; 558  :          i = add_local_var(NULL,1);

	push	1
	push	0
	mov	DWORD PTR _loopdepth, eax
	call	_add_local_var

; 559  :          list[listtop].stackpos = get_local(i).offset;

	mov	ecx, DWORD PTR _localbase
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _listtop
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	mov	edx, DWORD PTR [eax+edx+216]
	mov	eax, DWORD PTR _list
	add	esp, 8
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax+160], edx

; 560  :          break;

	jmp	$LN878@makenode
$LN520@makenode:

; 561  : 
; 562  :       case DO_TOP_NODE:
; 563  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 564  :          list[listtop].left = left - listtop; /* DO_ENTRY */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 565  :          list[listtop].right = right - listtop; /* command */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edi
$LN930@makenode:

; 566  :          i = add_local_var(NULL,1);

	push	1
	push	0
	call	_add_local_var

; 567  :          list[listtop].stackpos = get_local(i).offset;

	mov	edx, DWORD PTR _localbase
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _listtop
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	mov	eax, DWORD PTR [eax+ecx+216]
	mov	ecx, DWORD PTR _list
	add	esp, 8
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+ecx+160], eax

; 568  :          break;

	jmp	$LN878@makenode
$LN519@makenode:

; 569  : 
; 570  :       case DO_END_NODE:
; 571  :       { int entry;
; 572  :         list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 573  :         list[listtop].left = left - listtop; /* DO_TOP_ */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, esi
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx

; 574  :         list[listtop].right = right - listtop; /* command */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, edi
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], ecx

; 575  :         /* find start of DO loop */
; 576  :         for ( n = left ; list[n].left ; n += list[n].left ) ; 

	mov	ecx, DWORD PTR _list
	mov	edx, esi
	imul	edx, 168				; 000000a8H
	mov	ebx, DWORD PTR [edx+ecx+4]
	mov	eax, esi
	test	ebx, ebx
	je	SHORT $LN516@makenode
	npad	6
$LL518@makenode:
	add	eax, ebx
	mov	ebx, eax
	imul	ebx, 168				; 000000a8H
	mov	ebx, DWORD PTR [ebx+ecx+4]
	test	ebx, ebx
	jne	SHORT $LL518@makenode
$LN516@makenode:

; 577  :         list[listtop].op1.skipsize = n - listtop - 1; /* allow increment */

	mov	ebx, DWORD PTR _listtop
	sub	eax, ebx
	imul	ebx, 168				; 000000a8H
	dec	eax
	mov	DWORD PTR [ebx+ecx+32], eax

; 578  :         /* find start of test loop */
; 579  :         for ( n = right ; list[n].left ; n += list[n].left ) ; 

	mov	ecx, DWORD PTR _list
	mov	eax, edi
	imul	edi, 168				; 000000a8H
	mov	edi, DWORD PTR [edi+ecx+4]
	test	edi, edi
	je	SHORT $LN513@makenode
	npad	5
$LL515@makenode:
	add	eax, edi
	mov	edi, eax
	imul	edi, 168				; 000000a8H
	mov	edi, DWORD PTR [edi+ecx+4]
	test	edi, edi
	jne	SHORT $LL515@makenode
$LN513@makenode:

; 580  :         entry = left + list[left].left;  /* DO_ENTRY_ */

	mov	edx, DWORD PTR [edx+ecx+4]

; 581  :         list[entry].op3.breakjump = listtop-entry; /* break */

	mov	edi, DWORD PTR _listtop
	add	edx, esi
	mov	esi, edx
	imul	esi, 168				; 000000a8H
	sub	edi, edx
	mov	DWORD PTR [esi+ecx+140], edi

; 582  :         list[entry].op4.contjump = n - entry - 1;  /* continue */

	mov	ecx, DWORD PTR _list
	sub	eax, edx
	dec	eax
	mov	DWORD PTR [esi+ecx+148], eax

; 583  :         loopdepth--;

	dec	DWORD PTR _loopdepth

; 584  :         if ( loopdepth < 0 )

	jns	$LN512@makenode

; 585  :           kb_error(1391,"Internal error: loopdepth negative.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CF@NEDBIMHF@Internal?5error?3?5loopdepth?5negati@
	push	1391					; 0000056fH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 586  :         list[listtop].stack_delta = -1;
; 587  : 
; 588  :         break;

	jmp	$LN512@makenode
$LN511@makenode:

; 589  :       }
; 590  : 
; 591  : /* FOR syntax:   FOR ( command1 ; expr ; command2 ) command3 
; 592  : 
; 593  :  FOR tree:
; 594  :                        FOR_END_
; 595  :                       /       \
; 596  :                FOR_TOP_       command3
; 597  :               /       \
; 598  :        FOR_HEAD_    command2
; 599  :        /       \
; 600  :   FOR_ENTRY    expr
; 601  :       |
; 602  :   command1
; 603  : 
; 604  :  FOR execution sequence:
; 605  : 
; 606  :  command1 expr FOR_HEAD_ command2 FOR_TOP_ command3 FOR_END_
; 607  :  FOR_ENTRY.op3.breakjump holds break jump
; 608  :  FOR_ENTRY.op4.contjump holds continue jump
; 609  :  FOR_HEAD_.op1.skipsize is jump to command3
; 610  :  FOR_HEAD_.op2.jumpsize is jump out of loop
; 611  :  FOR_TOP_.op1.skipsize is jump back to expr
; 612  :  FOR_END_.op1.skipsize is jump back to command2
; 613  : */
; 614  :       case FOR_ENTRY_NODE:
; 615  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 616  :          list[listtop].left = left - listtop; /* command1 */ 

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 617  :          loopbase[loopdepth++] = listtop;

	mov	eax, DWORD PTR _loopdepth
	mov	ecx, DWORD PTR _listtop
	mov	DWORD PTR _loopbase[eax*4], ecx
	inc	eax
	mov	DWORD PTR _loopdepth, eax

; 618  :          /* op3 will hold offsets for break and continue */
; 619  :          i = add_local_var(NULL,1);
; 620  :          list[listtop].stackpos = get_local(i).offset;
; 621  :          break;

	jmp	$LN930@makenode
$LN510@makenode:

; 622  : 
; 623  :       case FOR_HEAD_NODE:
; 624  :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 625  :          list[listtop].left = left - listtop; /* FOR_ENTRY */ 

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, esi
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx

; 626  :          list[listtop].right = right - listtop; /* expr */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edi

; 627  :          list[left].op4.contjump = listtop-left; /* expr follows immediately */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	sub	edx, esi
	imul	esi, 168				; 000000a8H
	mov	DWORD PTR [esi+eax+148], edx
$LN257@makenode:

; 628  :          list[listtop].stack_delta = -1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], -1

; 629  :          break;

	jmp	$LN878@makenode
$LN509@makenode:

; 630  : 
; 631  :       case FOR_TOP_NODE:
; 632  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 633  :          list[listtop].left = left - listtop; /* FOR_HEAD_ */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 634  :          list[listtop].right = right - listtop; /* command2 */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi

; 635  :          list[listtop].op1.skipsize = left + list[left].left - listtop;

	mov	edx, DWORD PTR _list
	mov	ecx, DWORD PTR _listtop
	mov	eax, esi
	imul	eax, 168				; 000000a8H
	mov	edi, DWORD PTR [eax+edx+4]
	sub	edi, ecx
	imul	ecx, 168				; 000000a8H
	add	edi, esi
	mov	DWORD PTR [ecx+edx+32], edi

; 636  :          list[left].op1.skipsize = listtop - left; 

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	ecx, esi
	mov	DWORD PTR [eax+edx+32], ecx

; 637  :          break;

	jmp	$LN878@makenode
$LN508@makenode:

; 638  : 
; 639  :       case FOR_END_NODE:
; 640  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 641  :          list[listtop].left = left - listtop; /* FOR_TOP_ */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 642  :          if ( right )

	test	edi, edi
	je	SHORT $LN507@makenode

; 643  :            list[listtop].right = right - listtop; /* command3 */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi
$LN507@makenode:

; 644  :          list[left+list[left].left].op2.jumpsize = 
; 645  :                              listtop - left - list[left].left;

	mov	ecx, DWORD PTR _list
	mov	edi, DWORD PTR _listtop
	mov	eax, esi
	imul	eax, 168				; 000000a8H
	mov	edx, DWORD PTR [eax+ecx+4]
	sub	edi, edx
	add	edx, esi
	imul	edx, 168				; 000000a8H
	sub	edi, esi
	mov	DWORD PTR [edx+ecx+136], edi

; 646  :          list[listtop].op1.skipsize = (left + list[left].left) - listtop;

	mov	ecx, DWORD PTR _list
	mov	edi, DWORD PTR [eax+ecx+4]
	mov	edx, DWORD PTR _listtop
	sub	edi, edx
	imul	edx, 168				; 000000a8H
	add	edi, esi
	mov	DWORD PTR [edx+ecx+32], edi

; 647  :          n = left+list[left].left;  /* n = FOR_HEAD */

	mov	edx, DWORD PTR _list
	mov	eax, DWORD PTR [eax+edx+4]
	add	eax, esi

; 648  :          n += list[n].left;   /* n = FOR_ENTRY */

	mov	ecx, eax
	imul	ecx, 168				; 000000a8H
	add	eax, DWORD PTR [ecx+edx+4]

; 649  :          list[n].op3.breakjump = listtop-n; /* break */

	mov	ecx, DWORD PTR _listtop
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+140], ecx

; 650  :          loopdepth--;

	dec	DWORD PTR _loopdepth

; 651  :          if ( loopdepth < 0 )

	jns	$LN878@makenode

; 652  :           kb_error(2515,"Internal error: loopdepth negative.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CF@NEDBIMHF@Internal?5error?3?5loopdepth?5negati@
	push	2515					; 000009d3H
	call	_kb_error

; 653  :          break;

	jmp	$LN907@makenode
$LN485@makenode:

; 779  : 
; 780  :       case ELINDEX_NODE: 
; 781  :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 782  :          list[listtop].left = left-listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], esi

; 783  :          if ( right )

	test	edi, edi
	je	$LN878@makenode

; 784  :          { list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi

; 785  :            list[listtop].stack_delta = -1;
; 786  :          }
; 787  :          break;

	jmp	$LN921@makenode
$LN483@makenode:

; 788  : 
; 789  :       case PUSH_ELEMENT_ID_NODE:
; 790  :          list[listtop].type = PUSH_ELEMENT_ID_NODE;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10014		; 0000271eH

; 791  :          if ( left == 0 )

	test	esi, esi
	jne	SHORT $LN482@makenode

; 792  :            kb_error(6343,"Element id 0 is illegal.\n",RECOVERABLE); 

	push	1
	push	OFFSET ??_C@_0BK@KDIHDDIN@Element?5id?50?5is?5illegal?4?6?$AA@
	push	6343					; 000018c7H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN482@makenode:

; 793  :          list[listtop].op1.id = (element_id)abs(left) - 1;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _list
	dec	eax
	mov	DWORD PTR [ecx+edx+32], eax

; 794  :          if ( left < 0 ) 

	test	esi, esi
	jns	SHORT $LN481@makenode

; 795  :            invert(list[listtop].op1.id);

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	xor	DWORD PTR [eax+ecx+32], 134217728	; 08000000H
	lea	eax, DWORD PTR [eax+ecx+32]
$LN481@makenode:

; 796  : #ifdef MPI_EVOLVER
; 797  :          list[listtop].op1.id |= ((element_id)right << TASK_ID_SHIFT);
; 798  : #endif
; 799  :          list[listtop].stack_delta = 1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], 1

; 800  :          break;

	jmp	$LN878@makenode
$LN480@makenode:

; 801  :          
; 802  : 
; 803  :       case VALID_ELEMENT_NODE:
; 804  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 805  :          list[listtop].op1.eltype = left;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], esi

; 806  :          list[listtop].left = right - listtop;    /* index expression */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edi

; 807  :          list[listtop].datatype = REAL_TYPE;
; 808  :          break;

	jmp	$LN924@makenode
$LN477@makenode:

; 809  : 
; 810  :       case VALID_CONSTRAINT_NODE:
; 811  :          list[listtop].type = type;
; 812  :          list[listtop].left = left - listtop;    /* index expression */
; 813  :          list[listtop].datatype = REAL_TYPE;
; 814  :          break;
; 815  : 
; 816  :       case VALID_BOUNDARY_NODE:
; 817  :          list[listtop].type = type;
; 818  :          list[listtop].left = left - listtop;    /* index expression */
; 819  :          list[listtop].datatype = REAL_TYPE;
; 820  :          break;
; 821  : 
; 822  :       
; 823  :       case MATRIX_MULTIPLY_NODE:
; 824  :         { struct array *a = get_name_arrayptr(list[left].op2.name_id,NULL,localbase);

	mov	ecx, DWORD PTR _localbase
	imul	esi, 168				; 000000a8H
	mov	edx, DWORD PTR [esi+eax+136]
	push	ecx
	push	0
	push	edx
	call	_get_name_arrayptr

; 825  :           struct array *b = get_name_arrayptr(list[right].op2.name_id,NULL,localbase);

	imul	edi, 168				; 000000a8H
	mov	ecx, DWORD PTR _list
	mov	edx, DWORD PTR [edi+ecx+136]
	mov	DWORD PTR _a$89598[ebp], eax
	mov	eax, DWORD PTR _localbase
	push	eax
	push	0
	push	edx
	call	_get_name_arrayptr

; 826  :           struct array *c = get_name_arrayptr(list[int_val].op2.name_id,NULL,localbase);

	mov	ecx, DWORD PTR _int_val
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR _b$89600[ebp], eax
	mov	eax, DWORD PTR _localbase
	push	eax
	mov	eax, DWORD PTR [ecx+edx+136]
	push	0
	push	eax
	call	_get_name_arrayptr

; 827  : 
; 828  :           list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], ebx

; 829  :           list[listtop].op1.name_id = list[left].op2.name_id;  /* first multiplicand */

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR _c$89602[ebp], eax
	mov	eax, DWORD PTR _list
	mov	edx, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [ecx+eax+32], edx

; 830  :           list[listtop].op2.name_id = list[right].op2.name_id;  /* second multiplicand */

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [edi+eax+136]
	mov	DWORD PTR [ecx+eax+136], edx

; 831  :           list[listtop].op3.name_id = list[int_val].op2.name_id;  /* result */

	mov	ecx, DWORD PTR _int_val
	mov	edx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [ecx+eax+136]

; 832  :           list[listtop].stack_delta = -3;
; 833  : 
; 834  :           if ( a->datatype != REAL_TYPE)

	mov	esi, DWORD PTR _a$89598[ebp]
	mov	DWORD PTR [edx+eax+140], ecx
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	add	esp, 36					; 00000024H
	mov	DWORD PTR [edx+eax+156], -3		; fffffffdH
	cmp	DWORD PTR [esi+8], 1
	je	SHORT $LN879@makenode

; 835  :            kb_error(3863,"matrix_multiply: first matrix is not of type REAL.\n",
; 836  :             RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DE@IJPHPIFG@matrix_multiply?3?5first?5matrix?5is@
	push	3863					; 00000f17H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN879@makenode:

; 837  :           if ( b->datatype != REAL_TYPE )

	mov	ebx, DWORD PTR _b$89600[ebp]
	cmp	DWORD PTR [ebx+8], 1
	je	SHORT $LN475@makenode

; 838  :             kb_error(3864,"matrix_multiply: second matrix is not of type REAL.\n",
; 839  :               RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DF@MGFJOCIL@matrix_multiply?3?5second?5matrix?5i@
	push	3864					; 00000f18H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN475@makenode:

; 840  :           if ( c->datatype != REAL_TYPE )

	mov	edi, DWORD PTR _c$89602[ebp]
	cmp	DWORD PTR [edi+8], 1
	je	SHORT $LN474@makenode

; 841  :             kb_error(3865,"matrix_multiply: third matrix is not of type REAL.\n",
; 842  :               RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DE@FHFPHPDO@matrix_multiply?3?5third?5matrix?5is@
	push	3865					; 00000f19H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN474@makenode:

; 843  :   
; 844  :           if ( a == c )

	cmp	esi, edi
	jne	SHORT $LN473@makenode

; 845  :            kb_error(3866,
; 846  :             "matrix_multiply: first and third matrices must not be the same matrix.\n",
; 847  :                RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EI@PHKJOELK@matrix_multiply?3?5first?5and?5third@
	push	3866					; 00000f1aH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN473@makenode:

; 848  :           if ( b == c )

	cmp	ebx, edi
	jne	$LN878@makenode

; 849  :             kb_error(3867,
; 850  :               "matrix_multiply: second and third matrices must not be the same matrix.\n",
; 851  :                 RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EJ@OAKEJDGP@matrix_multiply?3?5second?5and?5thir@
	push	3867					; 00000f1bH
	call	_kb_error

; 852  :         }
; 853  :          break;

	jmp	$LN907@makenode
$LN471@makenode:

; 854  : 
; 855  :       case MATRIX_INVERSE_NODE:
; 856  :         { struct array *a = get_name_arrayptr(list[left].op2.name_id,NULL,localbase);

	mov	ecx, DWORD PTR _localbase
	imul	esi, 168				; 000000a8H
	mov	edx, DWORD PTR [esi+eax+136]
	push	ecx
	push	0
	push	edx
	call	_get_name_arrayptr

; 857  :           struct array *b = get_name_arrayptr(list[right].op2.name_id,NULL,localbase);

	imul	edi, 168				; 000000a8H
	mov	ecx, DWORD PTR _list
	mov	edx, DWORD PTR [edi+ecx+136]
	mov	DWORD PTR _a$89615[ebp], eax
	mov	eax, DWORD PTR _localbase
	push	eax
	push	0
	push	edx
	call	_get_name_arrayptr

; 858  : 
; 859  :           list[listtop].type = type;

	mov	ecx, DWORD PTR _list
	mov	DWORD PTR _b$89617[ebp], eax
	mov	eax, DWORD PTR _listtop
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], ebx

; 860  :           list[listtop].op1.name_id = list[left].op2.name_id;  /* original */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+eax+32], ecx

; 861  :           list[listtop].op2.name_id = list[right].op2.name_id;  /* inverse */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [edi+eax+136]
	mov	DWORD PTR [edx+eax+136], ecx

; 862  :           list[listtop].stack_delta = -1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 863  :           list[listtop].datatype = REAL_TYPE;
; 864  : 
; 865  :           if ( a->datatype != REAL_TYPE )

	mov	esi, DWORD PTR _a$89615[ebp]
	mov	DWORD PTR [edx+eax+156], -1
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	eax, 1
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ecx+edx+20], eax
	cmp	DWORD PTR [esi+8], eax
	je	SHORT $LN880@makenode

; 866  :             kb_error(3874,"matrix_inverse: first matrix is not of type REAL.\n",
; 867  :               RECOVERABLE);

	push	eax
	push	OFFSET ??_C@_0DD@JNOCGJAC@matrix_inverse?3?5first?5matrix?5is?5@
	push	3874					; 00000f22H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN880@makenode:

; 868  :           if ( b->datatype != REAL_TYPE )

	mov	eax, DWORD PTR _b$89617[ebp]
	cmp	DWORD PTR [eax+8], 1
	je	SHORT $LN469@makenode

; 869  :             kb_error(3875,"matrix_inverse: second matrix is not of type REAL.\n",
; 870  :               RECOVERABLE); 

	push	1
	push	OFFSET ??_C@_0DE@KKELGCPH@matrix_inverse?3?5second?5matrix?5is@
	push	3875					; 00000f23H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN469@makenode:

; 871  :  
; 872  :           if ( a->dim != 2 )

	mov	edi, 2
	cmp	DWORD PTR [esi+4], edi
	je	SHORT $LN468@makenode

; 873  :             kb_error(3870,"matrix_inverse first array is not two-dimensional.\n",
; 874  :               RECOVERABLE); 

	push	1
	push	OFFSET ??_C@_0DE@JGEOBBCA@matrix_inverse?5first?5array?5is?5no@
	push	3870					; 00000f1eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN468@makenode:

; 875  :           if ( b->dim != 2 )

	mov	ecx, DWORD PTR _b$89617[ebp]
	cmp	DWORD PTR [ecx+4], edi
	je	$LN878@makenode

; 876  :             kb_error(3871,"matrix_inverse second array is not two-dimensional.\n",
; 877  :               RECOVERABLE); 

	push	1
	push	OFFSET ??_C@_0DF@GJDLMJDI@matrix_inverse?5second?5array?5is?5n@
	push	3871					; 00000f1fH
	call	_kb_error

; 878  :          }
; 879  :          break;

	jmp	$LN907@makenode
$LN466@makenode:

; 880  : 
; 881  :       case MATRIX_DETERMINANT_NODE:
; 882  :        { struct array *a = get_name_arrayptr(list[left].op2.name_id,NULL,localbase);

	mov	edx, DWORD PTR _localbase
	imul	esi, 168				; 000000a8H
	mov	eax, DWORD PTR [esi+eax+136]
	push	edx
	push	0
	push	eax
	call	_get_name_arrayptr

; 883  : 
; 884  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], ebx

; 885  :          list[listtop].op1.name_id = list[left].op2.name_id;  /* original */

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR [esi+ecx+136]
	mov	DWORD PTR [edx+ecx+32], esi

; 886  :          list[listtop].stack_delta = 1;

	mov	edx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, 1
	mov	DWORD PTR [edx+esi+156], ecx

; 887  :          list[listtop].datatype = REAL_TYPE;

	mov	edx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edx+esi+20], ecx

; 888  :          
; 889  :          if ( a->dim != 2 )

	cmp	DWORD PTR [eax+4], 2
	je	$LN878@makenode

; 890  :            kb_error(3219,"matrix_determinant array is not two-dimensional.\n",
; 891  :              RECOVERABLE); 

	push	ecx
	push	OFFSET ??_C@_0DC@IMBGKBA@matrix_determinant?5array?5is?5not?5@
	push	3219					; 00000c93H
	call	_kb_error

; 892  :         }
; 893  :         break;

	jmp	$LN907@makenode
$LN460@makenode:

; 901  : 
; 902  :       case MERGE_EDGE_NODE:
; 903  :          list[listtop].type = type;
; 904  :          list[listtop].left = left - listtop;    /* oid of first edge */
; 905  :          list[listtop].right = right - listtop;    /* oid of second edge */
; 906  :          list[listtop].stack_delta = -2;
; 907  :          break;
; 908  : 
; 909  :       case MERGE_FACET_NODE:
; 910  :          list[listtop].type = type;
; 911  :          list[listtop].left = left - listtop;    /* oid of first facet */
; 912  :          list[listtop].right = right - listtop;    /* oid of second facet */
; 913  :          list[listtop].stack_delta = -2;
; 914  :          break;
; 915  : 
; 916  : 
; 917  : /* Aggregate loops.
; 918  : (not all nodes need be present)
; 919  : Tree:            AGGREGATE_END_
; 920  :                   /          \
; 921  :           AGGREGATE_INIT_    AGGREGATE_
; 922  :              or SET_INIT_   /         \ 
; 923  :                           WHERE_        SET_ATTRIBUTE_L
; 924  :                           /      \        /            \
; 925  :                     element_gen  expr    value expr    index expr
; 926  : 
; 927  : sequence: INIT_ element_gen expr WHERE_ value index SET_AT_L AGGR_  AGGR_END_
; 928  :          prep                                    cleanup
; 929  : 
; 930  : If present, SET_ATTRIBUTE_L will do setting and AGGREGATE_ does looping.
; 931  : Else AGGREGATE_ does both.
; 932  : Actually, AGGREGATE_ type is collection of node types.
; 933  : */
; 934  :       case SET_INIT_NODE: 
; 935  :          list[listtop].type = type;
; 936  :          loopbase[loopdepth++] = listtop;
; 937  :          i = add_local_var(NULL,1);
; 938  :          list[listtop].stackpos = get_local(i).offset;
; 939  :          break;
; 940  : 
; 941  :       case AGGREGATE_INIT_NODE:
; 942  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 943  :          list[listtop].op1.aggrtype = aggrtype;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _aggrtype
	mov	DWORD PTR [edx+eax+32], ecx

; 944  :          loopbase[loopdepth-1] = listtop;  

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _loopdepth

; 945  :          i = add_local_var(NULL,1);

	push	1
	push	0
	mov	DWORD PTR _loopbase[eax*4-4], edx
	call	_add_local_var

; 946  :          list[listtop].stackpos = get_local(i).offset;

	mov	ecx, DWORD PTR _localbase
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _listtop
	and	eax, 16777215				; 00ffffffH
	imul	ecx, 168				; 000000a8H
	imul	eax, 224				; 000000e0H
	mov	edx, DWORD PTR [eax+edx+216]
	mov	eax, DWORD PTR _list
	mov	DWORD PTR [ecx+eax+160], edx

; 947  :          switch ( aggrtype )

	mov	eax, DWORD PTR _aggrtype
	add	eax, -10339				; ffffd79dH
	add	esp, 8
	cmp	eax, 6
	ja	$LN878@makenode
	jmp	DWORD PTR $LN947@makenode[eax*4]
$LN456@makenode:

; 948  :          { case MAX_NODE: case MIN_NODE: case SUM_NODE: case COUNT_NODE:
; 949  :              list[listtop].stack_delta = 1;
; 950  :              break;
; 951  :            case AVG_NODE:
; 952  :              list[listtop].stack_delta = 2;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+156], 2

; 953  :              break;

	jmp	$LN878@makenode
$LN455@makenode:

; 954  :            case HISTOGRAM_NODE: case LOGHISTOGRAM_NODE:
; 955  :              list[listtop].stack_delta = 3 + HISTBINS + 1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], 25		; 00000019H

; 956  :              break;
; 957  :          }
; 958  :          /* op1 has aggregate type; op2 will have element type; */
; 959  :          /* op3 will have break and continue jump offsets */
; 960  :          break;

	jmp	$LN878@makenode
$LN241@makenode:

; 1638 : 
; 1639 :     case UNREDEFINE_SINGLE_NODE:
; 1640 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 1641 :          list[listtop].op1.letter = right; 

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+32], edi

; 1642 :          if ( right > 127 )

	cmp	edi, 127				; 0000007fH
	jle	$LN878@makenode

; 1643 :            kb_error(1415,"Illegal unredefine.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BF@MBGCPADL@Illegal?5unredefine?4?6?$AA@
	push	1415					; 00000587H
	call	_kb_error

; 1644 :          break;

	jmp	$LN907@makenode
$LN239@makenode:

; 1645 : 
; 1646 :     case REDEFINE_SINGLE_NODE:
; 1647 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 1648 :          list[listtop].op1.letter = right; /* letter */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+32], edi

; 1649 :          list[listtop].op5.locals = localbase;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _localbase
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _list
	mov	DWORD PTR [edx+ecx+152], eax

; 1650 :          if ( localbase )

	mov	eax, DWORD PTR _localbase
	test	eax, eax
	je	SHORT $LN238@makenode

; 1651 :             localbase->flags |= LL_IN_USE;

	or	DWORD PTR [eax+20], 4
$LN238@makenode:

; 1652 :          if ( right > 127 ) 

	cmp	edi, 127				; 0000007fH
	jle	SHORT $LN237@makenode

; 1653 :            kb_error(1416,"Illegal redefine.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BD@IBKBDFEL@Illegal?5redefine?4?6?$AA@
	push	1416					; 00000588H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN237@makenode:

; 1654 :          right = listtop;

	mov	edx, DWORD PTR _listtop

; 1655 :          subtree_swap(&left,&right);

	lea	eax, DWORD PTR _right$GSCopy$[ebp]
	push	eax
	lea	ecx, DWORD PTR _left$GSCopy$[ebp]
	push	ecx
	mov	DWORD PTR _right$GSCopy$[ebp], edx
	call	_subtree_swap

; 1656 :          list[right].op2.jumpsize = left - right; /* proc root */

	mov	eax, DWORD PTR _right$GSCopy$[ebp]
	mov	ecx, DWORD PTR _left$GSCopy$[ebp]
	mov	edi, DWORD PTR _list
	mov	esi, eax
	imul	esi, 168				; 000000a8H
	mov	edx, ecx
	sub	edx, eax
	mov	DWORD PTR [esi+edi+136], edx

; 1657 :          list[listtop].line_no = line_no;

	mov	edx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	edi, DWORD PTR _line_no
	mov	DWORD PTR [edx+esi+12], edi

; 1658 :          list[listtop].file_no = file_no;

	mov	edx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	edi, DWORD PTR _file_no
	mov	DWORD PTR [edx+esi+16], edi

; 1659 :          listtop++;

	mov	edx, DWORD PTR _listtop

; 1660 :          list[listtop].type = SET_PROC_END_NODE;

	mov	esi, DWORD PTR _list
	inc	edx
	mov	DWORD PTR _listtop, edx
	add	esp, 8
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+esi], 10756		; 00002a04H
$LN935@makenode:

; 1661 :          list[listtop].left = right - listtop; /* action node */

	mov	edx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	sub	eax, edx
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+esi+4], eax
$LN934@makenode:

; 1662 :          list[listtop].right = left - listtop; /* procedure */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], ecx

; 1663 :          break;

	jmp	$LN878@makenode
$LN236@makenode:

; 1664 : 
; 1665 :     case SET_PROCEDURE_NODE:
; 1666 :        { struct global *g = globals(right);

	mov	ecx, edi
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN612@makenode
	mov	edx, DWORD PTR _web+5652
	mov	ecx, edi
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR [ecx+edx]
	jmp	SHORT $LN609@makenode
$LN612@makenode:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN610@makenode
	mov	ecx, DWORD PTR _localbase
	mov	esi, edi
	and	esi, 16777215				; 00ffffffH
	imul	esi, 224				; 000000e0H
	add	esi, DWORD PTR [ecx]
	jmp	SHORT $LN609@makenode
$LN610@makenode:
	mov	edx, edi
	and	edx, 16777215				; 00ffffffH
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN608@makenode
	mov	ecx, DWORD PTR _web+5656
	mov	esi, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN609@makenode
$LN608@makenode:
	mov	ecx, DWORD PTR _web+5652
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+ecx]
$LN609@makenode:

; 1667 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 1668 :          list[listtop].op1.name_id = right; /* variable number */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+32], edi

; 1669 :          if ( g->flags & ORDINARY_PARAM )

	test	BYTE PTR [esi+192], 1
	je	SHORT $LN235@makenode

; 1670 :          { sprintf(errmsg,"Cannot redefine variable '%s' as a command.\n",
; 1671 :              g->name);

	push	esi
	push	OFFSET ??_C@_0CN@HBMNHHDH@Cannot?5redefine?5variable?5?8?$CFs?8?5as@
	push	OFFSET _errmsg
	call	_sprintf

; 1672 :            kb_error(3357,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	3357					; 00000d1dH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN235@makenode:

; 1673 :          }
; 1674 :          g->flags |= SUBROUTINE;

	mov	ecx, 4
	or	DWORD PTR [esi+192], ecx

; 1675 :          list[listtop].op5.locals = localbase; 

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _localbase
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR _list
	mov	DWORD PTR [edx+esi+152], eax

; 1676 :          if ( localbase )

	cmp	DWORD PTR _localbase, 0
	je	SHORT $LN234@makenode

; 1677 :          { list[listtop].flags |= HAS_LOCALLIST;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	or	DWORD PTR [edx+eax+24], 256		; 00000100H
	lea	eax, DWORD PTR [edx+eax+24]

; 1678 :            localbase->flags |= LL_IN_USE;

	mov	eax, DWORD PTR _localbase
	or	DWORD PTR [eax+20], ecx
$LN234@makenode:

; 1679 :          }
; 1680 :          right = listtop;

	mov	ecx, DWORD PTR _listtop

; 1681 :          subtree_swap(&left,&right);

	lea	edx, DWORD PTR _right$GSCopy$[ebp]
	push	edx
	lea	eax, DWORD PTR _left$GSCopy$[ebp]
	push	eax
	mov	DWORD PTR _right$GSCopy$[ebp], ecx
	call	_subtree_swap

; 1682 :          list[right].op2.jumpsize = left - right; /* proc root */

	mov	eax, DWORD PTR _right$GSCopy$[ebp]
	mov	edi, DWORD PTR _list
	mov	ecx, DWORD PTR _left$GSCopy$[ebp]
	mov	esi, eax
	imul	esi, 168				; 000000a8H
	mov	edx, ecx
	sub	edx, eax
	mov	DWORD PTR [esi+edi+136], edx

; 1683 :          list[listtop].line_no = line_no;

	mov	edx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	edi, DWORD PTR _line_no
	mov	DWORD PTR [edx+esi+12], edi

; 1684 :          list[listtop].file_no = file_no;

	mov	edx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	edi, DWORD PTR _file_no
	mov	DWORD PTR [edx+esi+16], edi

; 1685 :          listtop++;

	mov	edx, DWORD PTR _listtop

; 1686 :          list[listtop].type = SET_PROC_END_NODE;

	mov	esi, DWORD PTR _list
	inc	edx
	mov	DWORD PTR _listtop, edx
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+esi], 10756		; 00002a04H

; 1687 :          list[listtop].left = right - listtop; /* action node */

	mov	edx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	sub	eax, edx
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+esi+4], eax

; 1688 :          list[listtop].right = left - listtop; /* procedure */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	add	esp, 8
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], ecx
$LN939@makenode:

; 1689 :          list[listtop].flags |= EPHEMERAL;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	or	DWORD PTR [eax+ecx+24], 64		; 00000040H
	lea	eax, DWORD PTR [eax+ecx+24]
	jmp	$LN878@makenode
$LN233@makenode:

; 1690 :          break;
; 1691 :        }
; 1692 : 
; 1693 :     case SET_PERM_PROCEDURE_NODE:
; 1694 :        { struct global *g = globals(right);

	mov	ecx, edi
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN618@makenode
	mov	ecx, DWORD PTR _web+5652
	mov	edx, edi
	and	edx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+ecx]
	jmp	SHORT $LN615@makenode
$LN618@makenode:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN616@makenode
	mov	edx, DWORD PTR _localbase
	mov	esi, edi
	and	esi, 16777215				; 00ffffffH
	imul	esi, 224				; 000000e0H
	add	esi, DWORD PTR [edx]
	jmp	SHORT $LN615@makenode
$LN616@makenode:
	cmp	ecx, 536870912				; 20000000H
	mov	ecx, edi
	jne	SHORT $LN614@makenode
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN615@makenode
$LN614@makenode:
	mov	edx, DWORD PTR _web+5652
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR [ecx+edx]
$LN615@makenode:

; 1695 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1696 :          list[listtop].op1.name_id = right; /* variable number */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], edi

; 1697 :          if ( g->flags & ORDINARY_PARAM )

	test	BYTE PTR [esi+192], 1
	je	SHORT $LN881@makenode

; 1698 :          { sprintf(errmsg,"Cannot redefine variable '%s' as a command.\n",
; 1699 :              g->name);

	push	esi
	push	OFFSET ??_C@_0CN@HBMNHHDH@Cannot?5redefine?5variable?5?8?$CFs?8?5as@
	push	OFFSET _errmsg
	call	_sprintf

; 1700 :            kb_error(2516,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	2516					; 000009d4H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN881@makenode:

; 1701 :          }
; 1702 :          g->flags |= SUBROUTINE;

	or	DWORD PTR [esi+192], 4

; 1703 : 
; 1704 :          right = listtop;

	mov	ecx, DWORD PTR _listtop

; 1705 :          subtree_swap(&left,&right);

	lea	edx, DWORD PTR _right$GSCopy$[ebp]
	push	edx
	lea	eax, DWORD PTR _left$GSCopy$[ebp]
	push	eax
	mov	DWORD PTR _right$GSCopy$[ebp], ecx
	call	_subtree_swap

; 1706 :          /* see if any ephemeral stuff, and mark as part of permanent cmd */
; 1707 :          for ( n = right ; n < listtop ; n++ )

	mov	ebx, DWORD PTR _right$GSCopy$[ebp]
	add	esp, 8
	mov	DWORD PTR _n$[ebp], ebx
	cmp	ebx, DWORD PTR _listtop
	jge	SHORT $LN882@makenode

; 1701 :          }
; 1702 :          g->flags |= SUBROUTINE;

	mov	edi, ebx
	imul	edi, 168				; 000000a8H
	npad	4
$LL231@makenode:

; 1708 :          { if ( list[n].flags & EPHEMERAL )

	mov	eax, DWORD PTR _list
	test	BYTE PTR [edi+eax+24], 64		; 00000040H
	je	SHORT $LN228@makenode

; 1709 :            { sprintf(errmsg,"Non-permanent items in definition of %s.\n",
; 1710 :                g->name);

	push	esi
	push	OFFSET ??_C@_0CK@OCKAMEPI@Non?9permanent?5items?5in?5definitio@
	push	OFFSET _errmsg
	call	_sprintf

; 1711 :              kb_error(2517,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	2517					; 000009d5H
	call	_kb_error
	mov	eax, DWORD PTR _list
	add	esp, 24					; 00000018H
$LN228@makenode:

; 1712 :            }
; 1713 :            list[n].flags |= PERMNODE; 

	or	DWORD PTR [edi+eax+24], 128		; 00000080H
	mov	eax, DWORD PTR _n$[ebp]
	inc	eax
	add	edi, 168				; 000000a8H
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, DWORD PTR _listtop
	jl	SHORT $LL231@makenode
$LN882@makenode:

; 1714 :          }
; 1715 :          list[right].op2.jumpsize = left - right; /* proc root */

	mov	ecx, DWORD PTR _left$GSCopy$[ebp]
	mov	esi, DWORD PTR _list
	mov	eax, ebx
	imul	eax, 168				; 000000a8H
	mov	edx, ecx
	sub	edx, ebx
	mov	DWORD PTR [eax+esi+136], edx

; 1716 :          list[listtop].line_no = line_no;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR _line_no
	mov	DWORD PTR [edx+eax+12], esi

; 1717 :          list[listtop].file_no = file_no;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR _file_no
	mov	DWORD PTR [edx+eax+16], esi

; 1718 :          list[listtop].op5.locals = localbase; 

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _localbase
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR _list
	mov	DWORD PTR [edx+esi+152], eax

; 1719 :          if ( localbase )

	cmp	DWORD PTR _localbase, 0
	je	SHORT $LN227@makenode

; 1720 :          { list[listtop].flags |= HAS_LOCALLIST;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	or	DWORD PTR [edx+eax+24], 256		; 00000100H
	lea	eax, DWORD PTR [edx+eax+24]

; 1721 :            localbase->flags |= LL_IN_USE;

	mov	eax, DWORD PTR _localbase
	or	DWORD PTR [eax+20], 4
$LN227@makenode:

; 1722 :          }
; 1723 :          listtop++;

	mov	eax, DWORD PTR _listtop

; 1724 :          list[listtop].type = SET_PERM_PROC_END_NODE;

	mov	edx, DWORD PTR _list
	inc	eax
	mov	DWORD PTR _listtop, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx], 10758		; 00002a06H

; 1725 :          list[listtop].left = right - listtop; /* action node */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	ebx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ebx

; 1726 :          list[listtop].right = left - listtop; /* procedure */
; 1727 :          break;

	jmp	$LN934@makenode
$LN226@makenode:

; 1728 :        }
; 1729 : 
; 1730 :     case ARGLIST_NODE:
; 1731 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1732 :          list[listtop].left = left ? left - listtop : 0; /* prev args */

	mov	ecx, DWORD PTR _listtop
	test	esi, esi
	je	SHORT $LN620@makenode
	mov	eax, esi
	sub	eax, ecx
	jmp	SHORT $LN621@makenode
$LN620@makenode:
	xor	eax, eax
$LN621@makenode:
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+4], eax

; 1733 :          if ( right )

	test	edi, edi
	je	$LN225@makenode

; 1734 :          { list[listtop].op1.name_id = right; /* name id */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+32], edi

; 1735 :            globals(right)->flags |= ORDINARY_PARAM;

	mov	eax, edi
	and	eax, -16777216				; ff000000H
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN626@makenode
	mov	eax, DWORD PTR _web+5652
	mov	edx, edi
	and	edx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [ecx+edx]
	jmp	SHORT $LN623@makenode
$LN626@makenode:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN624@makenode
	mov	ecx, DWORD PTR _localbase
	mov	eax, edi
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN623@makenode
$LN624@makenode:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN622@makenode
	mov	eax, DWORD PTR _web+5656
	mov	edx, edi
	and	edx, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN623@makenode
$LN622@makenode:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, edi
	and	ecx, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx]
$LN623@makenode:
	or	DWORD PTR [eax+192], 1
$LN225@makenode:

; 1736 :          }
; 1737 :          list[listtop].op2.argcount =  /* count of arguments */
; 1738 :               (left ? list[left].op2.argcount : 0) + (right?1:0);

	mov	eax, DWORD PTR _list
	test	esi, esi
	je	SHORT $LN628@makenode
	imul	esi, 168				; 000000a8H
	mov	esi, DWORD PTR [esi+eax+136]
	jmp	SHORT $LN629@makenode
$LN628@makenode:
	xor	esi, esi
$LN629@makenode:
	mov	ecx, DWORD PTR _listtop
	xor	edx, edx
	test	edi, edi
	setne	dl
	imul	ecx, 168				; 000000a8H
	add	edx, esi
	mov	DWORD PTR [ecx+eax+136], edx

; 1739 :          list[listtop].op3.argtype = int_val; /* argument type */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _int_val
	mov	DWORD PTR [edx+eax+140], ecx

; 1740 :          break;

	jmp	$LN878@makenode
$LN224@makenode:

; 1741 : 
; 1742 :     case FUNCTION_DEF_START_NODE:
; 1743 :     case FUNCTION_PROTO_START_NODE:
; 1744 :        { struct global *g = globals(left);

	mov	ecx, esi
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN634@makenode
	mov	ecx, DWORD PTR _web+5652
	mov	edx, esi
	and	edx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx]
	jmp	SHORT $LN908@makenode
$LN634@makenode:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN632@makenode
	mov	edx, DWORD PTR _localbase
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN908@makenode
$LN632@makenode:
	cmp	ecx, 536870912				; 20000000H
	mov	ecx, esi
	jne	SHORT $LN630@makenode
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN908@makenode
$LN630@makenode:
	mov	edx, DWORD PTR _web+5652
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
$LN908@makenode:

; 1745 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 1746 :          list[listtop].op1.name_id = left; /* name id */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+32], esi

; 1747 :          if ( g->flags & ORDINARY_PARAM )

	test	BYTE PTR [ecx+192], 1
	mov	DWORD PTR _g$89973[ebp], ecx
	je	SHORT $LN223@makenode

; 1748 :          { sprintf(errmsg,"Cannot redefine '%s' as a function.\n",g->name);

	mov	eax, ecx
	push	eax
	push	OFFSET ??_C@_0CF@LEPAHKPA@Cannot?5redefine?5?8?$CFs?8?5as?5a?5functi@
	push	OFFSET _errmsg
	call	_sprintf

; 1749 :            kb_error(3358,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	3358					; 00000d1eH
	call	_kb_error
	mov	ecx, DWORD PTR _g$89973[ebp]
	add	esp, 24					; 00000018H
$LN223@makenode:

; 1750 :          }
; 1751 :          g->flags |= FUNCTION_NAME;

	or	DWORD PTR [ecx+192], 1048576		; 00100000H

; 1752 :          /* op2.jumpsize for skip ahead, set later */
; 1753 :          /* op3.argcount for argument count */
; 1754 :          list[listtop].op4.ret_type = right;  /* type of return value */

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+148], edi

; 1755 :          break;

	jmp	$LN878@makenode
$LN222@makenode:

; 1756 :        }
; 1757 :        
; 1758 :     case FUNCTION_HEAD_NODE:
; 1759 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1760 :          list[listtop].left = left - listtop; /* function def start */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi

; 1761 :          list[listtop].right = right - listtop; /* function arglist */
; 1762 :          list[listtop].op1.name_id = list[left].op1.name_id; /* name id */

	imul	esi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, edi

; 1763 :          list[left].op3.argcount = list[right].op2.argcount; /* arg count */

	imul	edi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edx
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [esi+eax+32]
	mov	DWORD PTR [edx+eax+32], ecx
	mov	eax, DWORD PTR _list
	mov	edx, DWORD PTR [edi+eax+136]
	mov	DWORD PTR [esi+eax+140], edx

; 1764 :          globals(list[left].op1.name_id)->attr.procstuff.argcount =
; 1765 :               list[right].op2.argcount;

	mov	edx, DWORD PTR _list
	mov	eax, DWORD PTR [esi+edx+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN636@makenode
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN638@makenode
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN637@makenode
$LN638@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN636@makenode
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN637@makenode
$LN636@makenode:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx]
$LN637@makenode:
	mov	edx, DWORD PTR [edi+edx+136]
	mov	DWORD PTR [eax+168], edx

; 1766 :          list[listtop].op4.ret_type = list[left].op4.ret_type; 

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [esi+eax+148]
	mov	DWORD PTR [ecx+eax+148], edx

; 1767 :          break;

	jmp	$LN878@makenode
$LN221@makenode:

; 1768 : 
; 1769 :     case SET_FUNCTION_NODE:
; 1770 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1771 :          list[listtop].left = left - listtop; /* function head */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 1772 :          list[listtop].right = right - listtop; /* function body */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi

; 1773 :          list[listtop].op1.name_id = list[left].op1.name_id; /* name id */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, esi
	imul	ecx, 168				; 000000a8H
	mov	edi, DWORD PTR [ecx+eax+32]
	mov	DWORD PTR [edx+eax+32], edi

; 1774 :          n = left + list[left].left;

	mov	edx, DWORD PTR _list
	mov	eax, DWORD PTR [ecx+edx+4]
	add	eax, esi

; 1775 :          list[n].op2.jumpsize = listtop - n; /* for FUNCTION_START_ jump */

	mov	esi, DWORD PTR _listtop
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+136], esi

; 1776 :          list[listtop].flags |= EPHEMERAL;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	or	DWORD PTR [eax+edx+24], 64		; 00000040H
	lea	eax, DWORD PTR [eax+edx+24]

; 1777 :          list[listtop].op4.ret_type = list[left].op4.ret_type;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR [ecx+eax+148]
	mov	DWORD PTR [edx+eax+148], esi
$LN941@makenode:

; 1778 :          if ( topflag ) 

	cmp	DWORD PTR _topflag, 0
	je	$LN878@makenode

; 1779 :            globals(list[left].op1.name_id)->flags |= IN_DATAFILE_TOP;

	mov	eax, DWORD PTR _list
	mov	ecx, DWORD PTR [ecx+eax+32]
	mov	eax, ecx
	and	eax, -16777216				; ff000000H
	cmp	eax, 268435456				; 10000000H
	je	SHORT $LN642@makenode
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN644@makenode
	mov	edx, DWORD PTR _localbase
	and	ecx, 16777215				; 00ffffffH
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	or	DWORD PTR [ecx+192], 67108864		; 04000000H

; 1780 :          break;

	jmp	$LN878@makenode
$LN644@makenode:

; 1779 :            globals(list[left].op1.name_id)->flags |= IN_DATAFILE_TOP;

	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN642@makenode
	mov	eax, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	or	DWORD PTR [ecx+192], 67108864		; 04000000H

; 1780 :          break;

	jmp	$LN878@makenode
$LN642@makenode:

; 1779 :            globals(list[left].op1.name_id)->flags |= IN_DATAFILE_TOP;

	mov	edx, DWORD PTR _web+5652
	and	ecx, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [eax+ecx]
	or	DWORD PTR [ecx+192], 67108864		; 04000000H

; 1780 :          break;

	jmp	$LN878@makenode
$LN218@makenode:

; 1792 : 
; 1793 :     case FUNCTION_CALL_NODE:
; 1794 :        { struct global *g = globals(left);

	mov	ecx, esi
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN652@makenode
	mov	ecx, DWORD PTR _web+5652
	mov	edx, esi
	and	edx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx]
	jmp	SHORT $LN909@makenode
$LN652@makenode:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN650@makenode
	mov	edx, DWORD PTR _localbase
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN909@makenode
$LN650@makenode:
	cmp	ecx, 536870912				; 20000000H
	mov	ecx, esi
	jne	SHORT $LN648@makenode
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN909@makenode
$LN648@makenode:
	mov	edx, DWORD PTR _web+5652
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
$LN909@makenode:

; 1795 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR _g$89987[ebp], ecx
	mov	DWORD PTR [edx+eax], ebx

; 1796 :          if ( right )

	test	edi, edi
	je	SHORT $LN217@makenode

; 1797 :            list[listtop].left = right - listtop; /* argument expressions */

	mov	eax, DWORD PTR _listtop
	mov	ebx, DWORD PTR _list
	mov	edx, edi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ebx+4], edx
$LN217@makenode:

; 1798 :          list[listtop].op1.name_id = left;  /* function name id */

	mov	eax, DWORD PTR _listtop

; 1799 :          if ( list[right].op1.argcount != g->attr.procstuff.argcount )

	imul	edi, 168				; 000000a8H
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+32], esi
	mov	eax, DWORD PTR _list
	mov	edi, DWORD PTR [edi+eax+32]
	mov	eax, DWORD PTR [ecx+168]
	cmp	edi, eax
	je	SHORT $LN216@makenode

; 1800 :          { sprintf(errmsg,"Function \"%s\" needs %d arguments; call has %d,\n",
; 1801 :                g->name,g->attr.procstuff.argcount,list[right].op1.argcount);

	mov	ecx, DWORD PTR _g$89987[ebp]
	push	edi
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DA@NEJEBFAM@Function?5?$CC?$CFs?$CC?5needs?5?$CFd?5arguments@
	push	OFFSET _errmsg
	call	_sprintf

; 1802 :            kb_error(2620,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	2620					; 00000a3cH
	call	_kb_error
	mov	ecx, DWORD PTR _g$89987[ebp]
	add	esp, 32					; 00000020H
$LN216@makenode:

; 1803 :          }
; 1804 :          list[listtop].op2.argcount = g->attr.procstuff.argcount;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR [ecx+168]
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR _list
	mov	DWORD PTR [edx+esi+136], eax

; 1805 :          list[listtop].stack_delta = 1 - g->attr.procstuff.argcount;

	mov	eax, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	edx, 1
	sub	edx, DWORD PTR [ecx+168]
	mov	DWORD PTR [eax+esi+156], edx

; 1806 :          list[listtop].datatype = g->type <= MAX_NUMERIC_TYPE ? REAL_TYPE :
; 1807 :                  g->type;

	mov	ecx, DWORD PTR [ecx+200]
	cmp	ecx, 10					; 0000000aH
	jg	SHORT $LN654@makenode
	mov	ecx, 1
$LN654@makenode:
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+20], ecx

; 1808 :          break;

	jmp	$LN878@makenode
$LN215@makenode:

; 1809 :       }
; 1810 :     case FUNCTION_CALL_RETURN_NODE: 
; 1811 : 
; 1812 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1813 :          list[listtop].left = left - listtop; /* to FUNCTION_CALL */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi

; 1814 :          list[listtop].op2.argcount = list[left].op2.argcount; 

	imul	esi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+eax+136], ecx

; 1815 :          list[listtop].datatype = list[left].datatype;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [esi+eax+20]
	mov	DWORD PTR [edx+eax+20], ecx

; 1816 :          break;

	jmp	$LN878@makenode
$LN214@makenode:

; 1817 : 
; 1818 : 
; 1819 :     case PROCEDURE_DEF_START_NODE:
; 1820 :     case PROCEDURE_PROTO_START_NODE:
; 1821 :        { struct global *g = globals(left);

	mov	ecx, esi
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN660@makenode
	mov	ecx, DWORD PTR _web+5652
	mov	edx, esi
	and	edx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	edi, DWORD PTR [edx+ecx]
	jmp	SHORT $LN657@makenode
$LN660@makenode:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN658@makenode
	mov	edx, DWORD PTR _localbase
	mov	edi, esi
	and	edi, 16777215				; 00ffffffH
	imul	edi, 224				; 000000e0H
	add	edi, DWORD PTR [edx]
	jmp	SHORT $LN657@makenode
$LN658@makenode:
	cmp	ecx, 536870912				; 20000000H
	mov	ecx, esi
	jne	SHORT $LN656@makenode
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	edi, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN657@makenode
$LN656@makenode:
	mov	edx, DWORD PTR _web+5652
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	edi, DWORD PTR [ecx+edx]
$LN657@makenode:

; 1822 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1823 :          list[listtop].op1.name_id = left; /* name id */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], esi

; 1824 :          if ( g->flags & ORDINARY_PARAM )

	test	BYTE PTR [edi+192], 1
	je	SHORT $LN213@makenode

; 1825 :          { sprintf(errmsg,"Cannot redefine '%s' as a function.\n",g->name);

	push	edi
	push	OFFSET ??_C@_0CF@LEPAHKPA@Cannot?5redefine?5?8?$CFs?8?5as?5a?5functi@
	push	OFFSET _errmsg
	call	_sprintf

; 1826 :            kb_error(1417,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	1417					; 00000589H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN213@makenode:

; 1827 :          }
; 1828 :          g->flags |= PROCEDURE_NAME;

	or	DWORD PTR [edi+192], 2097152		; 00200000H

; 1829 :          /* op2.jumpsize for skip ahead, set later */
; 1830 :          /* op3.argcount for argument count */
; 1831 :          break;

	jmp	$LN878@makenode
$LN212@makenode:

; 1832 :        }
; 1833 :        
; 1834 :     case PROCEDURE_HEAD_NODE:
; 1835 :        { struct global *g;
; 1836 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1837 :          list[listtop].left = left - listtop; /* procedure def start */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi

; 1838 :          list[listtop].right = right - listtop; /* procedure arglist */
; 1839 :          list[listtop].op1.name_id = list[left].op1.name_id; /* name id */

	imul	esi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, edi

; 1840 :          list[left].op3.argcount = list[right].op2.argcount; /* arg count */

	imul	edi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edx
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [esi+eax+32]
	mov	DWORD PTR [edx+eax+32], ecx
	mov	eax, DWORD PTR _list
	mov	edx, DWORD PTR [edi+eax+136]
	mov	DWORD PTR [esi+eax+140], edx

; 1841 :          g = globals(list[left].op1.name_id);

	mov	ecx, DWORD PTR _list
	mov	esi, DWORD PTR [esi+ecx+32]
	mov	eax, esi
	and	eax, -16777216				; ff000000H
	and	esi, 16777215				; 00ffffffH
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN666@makenode
	mov	eax, DWORD PTR _web+5652
	lea	edx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax]
	jmp	SHORT $LN663@makenode
$LN666@makenode:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN664@makenode
	mov	edx, DWORD PTR _localbase
	imul	esi, 224				; 000000e0H
	add	esi, DWORD PTR [edx]
	jmp	SHORT $LN663@makenode
$LN664@makenode:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN662@makenode
	mov	eax, DWORD PTR _web+5656
	mov	esi, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN663@makenode
$LN662@makenode:
	mov	edx, DWORD PTR _web+5652
	lea	eax, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+edx]
$LN663@makenode:

; 1842 :          g->attr.procstuff.argcount = list[right].op2.argcount;
; 1843 :          if ( g->flags & USED_ON_ASSIGN_CALL && g->attr.procstuff.argcount > 0 )

	test	DWORD PTR [esi+192], -2147483648	; 80000000H
	mov	ecx, DWORD PTR [edi+ecx+136]
	mov	DWORD PTR [esi+168], ecx
	je	$LN878@makenode
	test	ecx, ecx
	jle	$LN878@makenode

; 1844 :            kb_error(6578,"on_assign_call procedure cannot have arguments.\n",
; 1845 :               RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DB@LABGMEKM@on_assign_call?5procedure?5cannot?5@
	push	6578					; 000019b2H
	call	_kb_error

; 1846 :          break;

	jmp	$LN907@makenode
$LN210@makenode:

; 1847 :        }
; 1848 :     case SET_ARGSPROC_NODE:
; 1849 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1850 :          list[listtop].left = left - listtop; /* function head */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 1851 :          list[listtop].right = right - listtop; /* function body */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi

; 1852 :          list[listtop].op1.name_id = list[left].op1.name_id; /* name id */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, esi
	imul	ecx, 168				; 000000a8H
	mov	edi, DWORD PTR [ecx+eax+32]
	mov	DWORD PTR [edx+eax+32], edi

; 1853 :          n = left + list[left].left;

	mov	edx, DWORD PTR _list
	mov	eax, DWORD PTR [ecx+edx+4]
	add	eax, esi

; 1854 :          list[n].op2.jumpsize = listtop - n; /* for PROCEDURE_START_ jump */

	mov	esi, DWORD PTR _listtop
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+136], esi

; 1855 :          list[listtop].flags |= EPHEMERAL;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	or	DWORD PTR [eax+edx+24], 64		; 00000040H
	lea	eax, DWORD PTR [eax+edx+24]

; 1856 :          if ( topflag ) 
; 1857 :            globals(list[left].op1.name_id)->flags |= IN_DATAFILE_TOP;

	jmp	$LN941@makenode
$LN207@makenode:

; 1869 : 
; 1870 :     case PROCEDURE_CALL_NODE:
; 1871 :        { struct global *g = globals(left);

	mov	ecx, esi
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN678@makenode
	mov	ecx, DWORD PTR _web+5652
	mov	edx, esi
	and	edx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx]
	jmp	SHORT $LN910@makenode
$LN678@makenode:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN676@makenode
	mov	edx, DWORD PTR _localbase
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN910@makenode
$LN676@makenode:
	cmp	ecx, 536870912				; 20000000H
	mov	ecx, esi
	jne	SHORT $LN674@makenode
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN910@makenode
$LN674@makenode:
	mov	edx, DWORD PTR _web+5652
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
$LN910@makenode:

; 1872 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR _g$90011[ebp], ecx
	mov	DWORD PTR [edx+eax], ebx

; 1873 :          if ( right )

	test	edi, edi
	je	SHORT $LN206@makenode

; 1874 :            list[listtop].left = right - listtop; /* argument expressions */

	mov	eax, DWORD PTR _listtop
	mov	ebx, DWORD PTR _list
	mov	edx, edi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ebx+4], edx
$LN206@makenode:

; 1875 :          list[listtop].op1.name_id = left;  /* procedure name id */

	mov	eax, DWORD PTR _listtop

; 1876 :          if ( list[right].op1.argcount != g->attr.procstuff.argcount )

	imul	edi, 168				; 000000a8H
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+32], esi
	mov	eax, DWORD PTR _list
	mov	edi, DWORD PTR [edi+eax+32]
	mov	eax, DWORD PTR [ecx+168]
	cmp	edi, eax
	je	SHORT $LN205@makenode

; 1877 :          { sprintf(errmsg,"Procedure \"%s\" needs %d arguments; call has %d.\n",
; 1878 :                g->name,g->attr.procstuff.argcount,list[right].op1.argcount);

	mov	ecx, DWORD PTR _g$90011[ebp]
	push	edi
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DB@KJKMGOKE@Procedure?5?$CC?$CFs?$CC?5needs?5?$CFd?5argument@
	push	OFFSET _errmsg
	call	_sprintf

; 1879 :            kb_error(2623,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	2623					; 00000a3fH
	call	_kb_error
	mov	ecx, DWORD PTR _g$90011[ebp]
	add	esp, 32					; 00000020H
$LN205@makenode:

; 1880 :          }
; 1881 :          list[listtop].op2.argcount = g->attr.procstuff.argcount; 

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR [ecx+168]
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR _list
	mov	DWORD PTR [edx+esi+136], eax

; 1882 :          list[listtop].stack_delta = -g->attr.procstuff.argcount;

	mov	ecx, DWORD PTR [ecx+168]

; 1883 :          break;

	jmp	$LN928@makenode
$LN204@makenode:

; 1884 :       }
; 1885 : 
; 1886 :     case PROCEDURE_CALL_RETURN_NODE:
; 1887 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1888 :          list[listtop].left = left - listtop; /* to PROCEDURE_CALL */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi

; 1889 :          list[listtop].op2.argcount = list[left].op2.argcount; 

	imul	esi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+eax+136], ecx

; 1890 :          break;

	jmp	$LN878@makenode
$LN76@makenode:

; 2602 : 
; 2603 :     case SHOW_NODE:
; 2604 :     case SHOW_EXPR_NODE:
; 2605 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 2606 :          /* put node in front of expression */
; 2607 :          right = listtop;

	mov	eax, DWORD PTR _listtop

; 2608 :          subtree_swap(&left,&right);

	lea	ecx, DWORD PTR _right$GSCopy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _left$GSCopy$[ebp]
	push	edx
	mov	DWORD PTR _right$GSCopy$[ebp], eax
	call	_subtree_swap

; 2609 :          list[right].op1.skipsize = left - right; 

	mov	eax, DWORD PTR _right$GSCopy$[ebp]
	mov	ecx, DWORD PTR _left$GSCopy$[ebp]
	mov	edi, DWORD PTR _list
	mov	esi, eax
	imul	esi, 168				; 000000a8H
	mov	edx, ecx
	sub	edx, eax
	mov	DWORD PTR [esi+edi+32], edx

; 2610 :          list[listtop].line_no = line_no;

	mov	edx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	edi, DWORD PTR _line_no
	mov	DWORD PTR [edx+esi+12], edi

; 2611 :          list[listtop].file_no = file_no;

	mov	edx, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	edi, DWORD PTR _file_no
	mov	DWORD PTR [edx+esi+16], edi

; 2612 :          listtop++;

	mov	edx, DWORD PTR _listtop

; 2613 :          list[listtop].type = SHOW_END_NODE;

	mov	esi, DWORD PTR _list
	inc	edx
	mov	DWORD PTR _listtop, edx
	add	esp, 8
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+esi], 10759		; 00002a07H

; 2614 :          list[listtop].left = right - listtop; /* action node */
; 2615 :          list[listtop].right = left - listtop; /* procedure */
; 2616 :          break;

	jmp	$LN935@makenode
$LN75@makenode:

; 2617 : 
; 2618 :     case SELF_ELEMENT_NODE:
; 2619 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2620 :          list[listtop].op1.eltype = left; 

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], esi

; 2621 :          list[listtop].op2.localnum = elsym->localnum; 

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _elsym
	imul	ecx, 168				; 000000a8H
	mov	eax, DWORD PTR [edx+68]
	mov	edx, DWORD PTR _list
	mov	DWORD PTR [ecx+edx+136], eax

; 2622 :          break;

	jmp	$LN878@makenode
$LN74@makenode:

; 2623 : 
; 2624 :     case SINGLE_ELEMENT_EXPR_NODE:
; 2625 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2626 :          list[listtop].left = left - listtop; /* action node */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 2627 :          list[listtop].op1.eltype = right; 

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+32], edi

; 2628 :          list[listtop].stack_delta = 1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], 1

; 2629 :          list[listtop].datatype = VERTEX_TYPE + right;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	add	edi, 13					; 0000000dH
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+20], edi

; 2630 :          break;

	jmp	$LN878@makenode
$LN73@makenode:

; 2631 : 
; 2632 :     case ELEMENT_IDENT_NODE:
; 2633 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2634 :          list[listtop].op3.name_id = left;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 2635 :          list[listtop].op2.localnum = add_local_var(NULL,1);

	push	1
	push	0
	mov	DWORD PTR [edx+eax+140], esi
	call	_add_local_var
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	add	esp, 8
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+136], eax

; 2636 :          break;

	jmp	$LN878@makenode
$LN72@makenode:

; 2637 : 
; 2638 :     case SYMBOL_ELEMENT_NODE:
; 2639 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2640 :          list[listtop].op1.eltype = symtable[left].type; 

	mov	edx, DWORD PTR _listtop
	lea	eax, DWORD PTR [esi+esi*8]
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR _list
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR _symtable[eax+eax+64]
	add	eax, eax
	mov	DWORD PTR [edx+esi+32], ecx

; 2641 :          list[listtop].op2.localnum = symtable[left].localnum; 

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _symtable[eax+68]
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR _list
	mov	DWORD PTR [edx+esi+136], ecx

; 2642 :          list[listtop].op5.string =
; 2643 :            (char*)mycalloc(strlen(symtable[left].name)+1,1);

	lea	esi, DWORD PTR _symtable[eax]
	mov	eax, esi
	lea	ecx, DWORD PTR [eax+1]
$LL865@makenode:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL865@makenode
	push	2643					; 00000a53H
	sub	eax, ecx
	push	OFFSET ??_C@_0L@OKHAMMPH@YEXPARSE?4C?$AA@
	inc	eax
	push	1
	push	eax
	call	_kb_calloc
	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+ecx+152], eax

; 2644 :          list[listtop].flags |= HAS_STRING_5;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	or	DWORD PTR [edx+eax+24], 512		; 00000200H
	lea	eax, DWORD PTR [edx+eax+24]

; 2645 :          strcpy(list[listtop].op5.string,symtable[left].name);

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	add	esp, 16					; 00000010H
	imul	edx, 168				; 000000a8H
	mov	edx, DWORD PTR [edx+eax+152]
	mov	ecx, esi
$LL818@makenode:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL818@makenode

; 2646 :          break;

	jmp	$LN878@makenode
$LN71@makenode:

; 2647 : 
; 2648 :     case SINGLE_ELEMENT_NODE: /* generator */
; 2649 :          list[listtop].type = SINGLE_ELEMENT_INIT_NODE; /* for dummy loop */

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], 10474		; 000028eaH

; 2650 :          list[listtop].line_no = line_no;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _line_no
	mov	DWORD PTR [edx+eax+12], ecx

; 2651 :          list[listtop].file_no = file_no;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _file_no
	mov	DWORD PTR [edx+eax+16], ecx

; 2652 :          list[listtop].stack_delta = 3;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], 3

; 2653 :          listtop++;

	mov	eax, DWORD PTR _listtop

; 2654 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _list
	inc	eax
	mov	DWORD PTR _listtop, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], ebx

; 2655 :          list[listtop].left = left-listtop;  /* index value */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 2656 :          list[listtop].right = -1; /* to INIT */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H

; 2657 :          list[listtop].op2.localnum = add_local_var(NULL,1);

	push	1
	push	0
	mov	DWORD PTR [eax+ecx+8], -1
	call	_add_local_var
	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	add	esp, 8
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+ecx+136], eax

; 2658 :                     /* local will hold id at runtime */
; 2659 :          /* op1 will hold jump to end of loop */
; 2660 :          break;

	jmp	$LN878@makenode
$LN70@makenode:

; 2661 : 
; 2662 :     case INDEXED_ELEMENT_NODE: 
; 2663 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 2664 :          list[listtop].left = right-listtop;  /* index value */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, edi
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx

; 2665 :          list[listtop].op1.eltype = left;    /* element type */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+32], esi

; 2666 :          list[listtop].stack_delta = -1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 2667 :          list[listtop].op2.localnum = add_local_var(NULL,1);

	push	1
	push	0
	mov	DWORD PTR [edx+eax+156], -1
	call	_add_local_var

; 2668 :                     /* local will hold id at runtime */
; 2669 :          /* Sanity check on index */
; 2670 :          if ( list[right].type == PUSHCONST_NODE )

	imul	edi, 168				; 000000a8H
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+136], eax
	mov	eax, DWORD PTR _list
	add	esp, 8
	cmp	DWORD PTR [eax+edi], 10095		; 0000276fH
	jne	$LN878@makenode

; 2671 :          { if ( list[right].op1.real == 0.0 ) 

	fld	QWORD PTR [eax+edi+32]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN878@makenode

; 2672 :            kb_error(2228,"Element index must be nonzero.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CA@CBCKOCFL@Element?5index?5must?5be?5nonzero?4?6?$AA@
	push	2228					; 000008b4H
	call	_kb_error

; 2673 :          }
; 2674 :          break;

	jmp	$LN907@makenode
$LN67@makenode:

; 2675 : 
; 2676 :     case INDEXED_SUBTYPE_NODE: 
; 2677 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2678 :          list[listtop].left = left-listtop;  /* single element */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 2679 :          list[listtop].right = right-listtop;  /* index value */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, edi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edx

; 2680 :          list[listtop].op1.eltype = subtype;    /* element type */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _subtype
	mov	DWORD PTR [edx+eax+32], ecx

; 2681 :          list[listtop].stack_delta = -1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 2682 :          list[listtop].op2.localnum = add_local_var(NULL,1);

	push	1
	push	0
	mov	DWORD PTR [edx+eax+156], -1
	call	_add_local_var

; 2683 :                     /* local will hold id at runtime */
; 2684 :          /* Sanity check on index */
; 2685 :          if ( list[right].type == PUSHCONST_NODE )

	imul	edi, 168				; 000000a8H
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+136], eax
	mov	eax, DWORD PTR _list
	add	esp, 8
	cmp	DWORD PTR [eax+edi], 10095		; 0000276fH
	jne	SHORT $LN883@makenode

; 2686 :          { if ( list[right].op1.real <= 0.0 ) 

	fldz
	fcomp	QWORD PTR [eax+edi+32]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN883@makenode

; 2687 :            kb_error(2229,"Element index must be positive.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CB@ODFFJHOG@Element?5index?5must?5be?5positive?4?6@
	push	2229					; 000008b5H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN883@makenode:

; 2688 :          }
; 2689 :          /* some type checking */
; 2690 :          etype = list[left].op1.eltype;

	mov	ecx, DWORD PTR _list
	imul	esi, 168				; 000000a8H
	mov	esi, DWORD PTR [esi+ecx+32]

; 2691 :          if ( etype == subtype )

	mov	eax, DWORD PTR _subtype
	cmp	esi, eax
	jne	SHORT $LN64@makenode

; 2692 :            kb_error(1418,"Cannot do same subtype as type of element.\n",
; 2693 :             COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CM@ELHMDCJI@Cannot?5do?5same?5subtype?5as?5type?5o@
	push	1418					; 0000058aH
	call	_kb_error
	mov	eax, DWORD PTR _subtype
	add	esp, 12					; 0000000cH
$LN64@makenode:

; 2694 :          switch ( etype )

	cmp	esi, 4
	ja	$LN878@makenode
	jmp	DWORD PTR $LN948@makenode[esi*4]
$LN61@makenode:

; 2695 :          { case VERTEX:
; 2696 :              switch ( subtype /* subtype */ )

	add	eax, -3					; fffffffdH
	cmp	eax, 1
	ja	$LN878@makenode

; 2697 :              { case BODY: case FACETEDGE: 
; 2698 :                   kb_error(1419,"Unimplemented subtype of vertex.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CC@IHNNOPLF@Unimplemented?5subtype?5of?5vertex?4@
	push	1419					; 0000058bH
	call	_kb_error

; 2699 :              }
; 2700 :              break;

	jmp	$LN907@makenode
$LN57@makenode:

; 2701 :            case EDGE:
; 2702 :              switch ( subtype /* subtype */ )

	cmp	eax, 3
	jne	$LN878@makenode

; 2703 :              { case BODY:
; 2704 :                   kb_error(1420,"Unimplemented subtype of edge.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CA@EMPJHMEM@Unimplemented?5subtype?5of?5edge?4?6?$AA@
	push	1420					; 0000058cH
	call	_kb_error

; 2705 :              }
; 2706 :              break;

	jmp	$LN907@makenode
$LN53@makenode:

; 2707 :            case FACET:
; 2708 :              switch ( subtype /* subtype */ )

	cmp	eax, 4
	jne	$LN878@makenode

; 2709 :              { case FACETEDGE: 
; 2710 :                   kb_error(1421,"Unimplemented subtype of facet.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CB@FJBLHHOF@Unimplemented?5subtype?5of?5facet?4?6@
	push	1421					; 0000058dH
	call	_kb_error

; 2711 :              }
; 2712 :              break;

	jmp	$LN907@makenode
$LN49@makenode:

; 2713 :            case BODY:
; 2714 :              switch ( subtype /* subtype */ )

	test	eax, eax
	js	$LN878@makenode
	cmp	eax, 1
	jle	SHORT $LN46@makenode
	cmp	eax, 4
	jne	$LN878@makenode
$LN46@makenode:

; 2715 :              { case FACETEDGE: 
; 2716 :                case VERTEX:
; 2717 :                case EDGE:
; 2718 :                   kb_error(1422,"Unimplemented subtype of body.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CA@LOPGCAPG@Unimplemented?5subtype?5of?5body?4?6?$AA@
	push	1422					; 0000058eH
	call	_kb_error

; 2719 :              }
; 2720 :              break;

	jmp	$LN907@makenode
$LN45@makenode:

; 2721 :            case FACETEDGE:
; 2722 :              switch ( subtype /* subtype */ )

	test	eax, eax
	je	SHORT $LN42@makenode
	add	eax, -3					; fffffffdH
	cmp	eax, 1
	ja	$LN878@makenode
$LN42@makenode:

; 2723 :              { case FACETEDGE: 
; 2724 :                case VERTEX:
; 2725 :                case BODY:
; 2726 :                   kb_error(1423,"Unimplemented subtype of facet.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CB@FJBLHHOF@Unimplemented?5subtype?5of?5facet?4?6@
	push	1423					; 0000058fH
	call	_kb_error

; 2727 :              }
; 2728 :              break;
; 2729 :          }
; 2730 :          break;

	jmp	$LN907@makenode
$LN454@makenode:

; 961  : 
; 962  :       case WHERE_NODE:
; 963  :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 964  :          list[listtop].left = left - listtop;  /* generator */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, esi

; 965  :          list[listtop].right = right - listtop;  /* condition expr */
; 966  :          list[listtop].stack_delta = -1;
; 967  :          list[listtop].op2.localnum = list[left].op2.localnum;

	imul	esi, 168				; 000000a8H
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edi
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], -1
	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [ecx+eax+136], edx

; 968  :          /* op1 will hold runtime where count */
; 969  :          break;

	jmp	$LN878@makenode
$LN820@makenode:

; 260  :   switch ( type )

	cmp	edx, 10475				; 000028ebH
	jg	$LN821@makenode
	je	$LN572@makenode
	sub	edx, 10263				; 00002817H
	cmp	edx, 183				; 000000b7H
	ja	$LN2@makenode
	movzx	ecx, BYTE PTR $LN866@makenode[edx]
	jmp	DWORD PTR $LN949@makenode[ecx*4]
$LN546@makenode:

; 422  : 
; 423  :       case SINGLE_ASSIGN_NODE:
; 424  :    /* tree:      SINGLE_ASSIGN
; 425  :                 /          \
; 426  :         SINGLE_ELEMENT_    SET_ATTRIBUTE_A
; 427  :              /              /         \
; 428  :          single            expr          index expr
; 429  :       */
; 430  :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 431  :          list[listtop].op1.assigntype = assigntype;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	edx, DWORD PTR _assigntype
	mov	DWORD PTR [eax+ecx+32], edx
$LN927@makenode:

; 432  :          list[listtop].left = left-listtop;  /* single element */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], esi

; 433  :          list[listtop].right = right-listtop; /* attribute and expression */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi

; 434  :          list[listtop].stack_delta = -3;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+156], -3		; fffffffdH

; 435  :          break;

	jmp	$LN878@makenode
$LN537@makenode:

; 478  : 
; 479  :       case RESET_COUNTS_NODE:  /* set counts back to 0 */
; 480  :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 481  :          break;

	jmp	$LN878@makenode
$LN493@makenode:

; 729  : 
; 730  :       case CREATE_VERTEX_NODE:
; 731  :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 732  :          list[listtop].left = left - listtop; /* expression list for coords */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, esi

; 733  :          if ( list[left].op1.argcount != SDIM )

	imul	esi, 168				; 000000a8H
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx
	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _list
	cmp	DWORD PTR [esi+ecx+32], eax
	je	SHORT $LN492@makenode

; 734  :          { sprintf(msg,
; 735  :           "Need exactly %d coordinates in NEW_VERTEX (...).\n",SDIM);

	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0DC@PFHFLMGE@Need?5exactly?5?$CFd?5coordinates?5in?5N@
	push	edx
	call	_sprintf

; 736  :              kb_error(2217,msg,COMMAND_ERROR);

	mov	eax, DWORD PTR _msg
	push	5
	push	eax
	push	2217					; 000008a9H
	call	_kb_error
	mov	eax, DWORD PTR _web+616
	add	esp, 24					; 00000018H
$LN492@makenode:

; 737  :          }
; 738  :          list[listtop].stack_delta = 1 - SDIM;

	mov	edx, DWORD PTR _listtop
	mov	ecx, 1
	sub	ecx, eax
	imul	edx, 168				; 000000a8H
	mov	eax, DWORD PTR _list
	mov	DWORD PTR [edx+eax+156], ecx
$LN932@makenode:

; 739  :          list[listtop].datatype = REAL_TYPE;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+20], 1

; 740  :          break;

	jmp	$LN878@makenode
$LN491@makenode:

; 741  : 
; 742  :       case CREATE_EDGE_NODE:
; 743  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 744  :          list[listtop].left = left - listtop;    /* id of tail vertex */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 745  :          list[listtop].right = right - listtop;    /* id of head vertex */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edi

; 746  :          list[listtop].stack_delta = -1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], -1

; 747  :          list[listtop].datatype = REAL_TYPE;
; 748  :          break;

	jmp	SHORT $LN932@makenode
$LN490@makenode:

; 749  : 
; 750  :       case FACET_CROSSCUT_NODE:
; 751  :          if ( web.representation != STRING )

	cmp	DWORD PTR _web+624, 1
	je	SHORT $LN489@makenode

; 752  :          { kb_error(5388,"facet_crosscut() only valid in string model.\n",
; 753  :              COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CO@IHGLLACA@facet_crosscut?$CI?$CJ?5only?5valid?5in?5s@
	push	5388					; 0000150cH
	call	_kb_error
	mov	eax, DWORD PTR _list
	add	esp, 12					; 0000000cH
$LN489@makenode:

; 754  :          }
; 755  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 756  :          list[listtop].left = left - listtop;    /* expression list */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 757  :          list[listtop].stack_delta = -2;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+156], -2		; fffffffeH

; 758  :          list[listtop].datatype = REAL_TYPE;
; 759  :          break;

	jmp	$LN924@makenode
$LN488@makenode:

; 760  : 
; 761  :       case CREATE_FACET_NODE:
; 762  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 763  :          list[listtop].left = left - listtop;    /* expression list for edges */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 764  :          if ( (web.representation == SIMPLEX) 
; 765  :              && (list[left].op1.argcount != web.dimension+1) )

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN874@makenode
	mov	eax, DWORD PTR _web+620
	mov	ecx, DWORD PTR _list
	mov	edx, esi
	imul	edx, 168				; 000000a8H
	inc	eax
	cmp	DWORD PTR [edx+ecx+32], eax
	je	SHORT $LN874@makenode

; 766  :          { sprintf(msg,"Need exactly %d vertices in NEW_FACET (...).\n",
; 767  :               web.dimension+1);

	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0CO@PEJKEKJN@Need?5exactly?5?$CFd?5vertices?5in?5NEW_@
	push	edx
	call	_sprintf

; 768  :            kb_error(2218,msg,COMMAND_ERROR);

	mov	eax, DWORD PTR _msg
	push	5
	push	eax
	push	2218					; 000008aaH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN874@makenode:

; 769  :          }
; 770  :          list[listtop].stack_delta = 1 - list[left].op1.argcount;

	mov	eax, DWORD PTR _list
	imul	esi, 168				; 000000a8H
	mov	edx, DWORD PTR _listtop
	mov	ecx, 1
	sub	ecx, DWORD PTR [esi+eax+32]
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], ecx

; 771  :          list[listtop].datatype = REAL_TYPE;
; 772  :          break;

	jmp	$LN931@makenode
$LN486@makenode:

; 773  : 
; 774  :       case CREATE_BODY_NODE:
; 775  :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 776  :          list[listtop].stack_delta = 1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	eax, 1
	mov	DWORD PTR [ecx+edx+156], eax

; 777  :          list[listtop].datatype = REAL_TYPE;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+20], eax

; 778  :          break;

	jmp	$LN878@makenode
$LN464@makenode:

; 894  : 
; 895  :       case MERGE_VERTEX_NODE:
; 896  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 897  :          list[listtop].left = left - listtop;    /* id of first vertex */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 898  :          list[listtop].right = right - listtop;    /* id of second vertex */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edi

; 899  :          list[listtop].stack_delta = -2;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], -2		; fffffffeH

; 900  :          break;

	jmp	$LN878@makenode
$LN382@makenode:

; 1173 : 
; 1174 :       case AGGREGATE_END_NODE:
; 1175 :         { struct treenode *wnode;
; 1176 :           list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1177 :           list[listtop].op1.aggrtype = aggrtype;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _aggrtype
	mov	DWORD PTR [edx+eax+32], ecx

; 1178 :           list[listtop].left = left - listtop;  /* aggr init */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 1179 :           list[listtop].right = right - listtop;  /* aggr op */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, edi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edx

; 1180 :           list[listtop].stack_delta =  -list[left].stack_delta - 3;

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	ebx, esi
	imul	ebx, 168				; 000000a8H
	mov	edx, -3					; fffffffdH
	sub	edx, DWORD PTR [ebx+eax+156]
	mov	DWORD PTR [ecx+eax+156], edx

; 1181 :           list[listtop].datatype = REAL_TYPE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+20], 1

; 1182 :           if ( (aggrtype == SUM_NODE) || (aggrtype == COUNT_NODE) ||
; 1183 :                (aggrtype == AVG_NODE) || (aggrtype == MAX_NODE ) ||
; 1184 :                (aggrtype == MIN_NODE ) ) list[listtop].stack_delta += 1;

	mov	eax, DWORD PTR _aggrtype
	cmp	eax, 10341				; 00002865H
	je	SHORT $LN380@makenode
	cmp	eax, 10343				; 00002867H
	je	SHORT $LN380@makenode
	cmp	eax, 10342				; 00002866H
	je	SHORT $LN380@makenode
	cmp	eax, 10339				; 00002863H
	je	SHORT $LN380@makenode
	cmp	eax, 10340				; 00002864H
	jne	SHORT $LN381@makenode
$LN380@makenode:
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	inc	DWORD PTR [ecx+edx+156]
	lea	eax, DWORD PTR [ecx+edx+156]
$LN381@makenode:

; 1185 :           wnode = list+right + list[right].left;

	mov	ecx, DWORD PTR _list

; 1186 :           list[listtop].flags |= IN_ELEMENT_LOOP;

	mov	edx, DWORD PTR _listtop
	mov	eax, edi
	imul	edx, 168				; 000000a8H
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR tv8548[ebp], eax
	mov	eax, DWORD PTR [eax+ecx+4]
	or	DWORD PTR [edx+ecx+24], 2048		; 00000800H
	add	eax, edi
	imul	eax, 168				; 000000a8H
	add	eax, ecx
	lea	ecx, DWORD PTR [edx+ecx+24]

; 1187 :           if ( wnode[wnode->left].type != SINGLE_ELEMENT_NODE )

	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 168				; 000000a8H
	add	ecx, eax
	cmp	DWORD PTR [ecx], 10241			; 00002801H
	mov	DWORD PTR _wnode$89754[ebp], eax
	je	SHORT $LN902@makenode

; 1188 :           { if ( wnode->type == WHERE_NODE )

	cmp	DWORD PTR [eax], 10262			; 00002816H
	jne	SHORT $LN378@makenode

; 1189 :             { nnode = wnode + wnode->left;
; 1190 :               nnode->op1.skipsize = (int)((list + listtop) - nnode);

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	sub	edx, ecx
	add	edx, DWORD PTR _list
	mov	eax, 818089009				; 30c30c31H
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR [ecx+32], eax

; 1191 :             }  
; 1192 :             else

	jmp	SHORT $LN902@makenode
$LN378@makenode:

; 1193 :               wnode->op1.skipsize = listtop - (right + list[right].left);

	mov	edx, DWORD PTR _list
	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR tv8548[ebp]
	sub	ecx, DWORD PTR [eax+edx+4]
	mov	edx, DWORD PTR _wnode$89754[ebp]
	sub	ecx, edi
	mov	DWORD PTR [edx+32], ecx
$LN902@makenode:

; 1194 :           }
; 1195 :         }
; 1196 :         /* element type in aggr_init node */
; 1197 :         list[left].op2.eltype = list[right].op2.eltype;

	mov	eax, DWORD PTR _list
	mov	ecx, DWORD PTR tv8548[ebp]
	mov	edx, DWORD PTR [ecx+eax+136]
	mov	DWORD PTR [ebx+eax+136], edx

; 1198 :         list[left].op3.breakjump = listtop-left-1; /* break to here */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	eax, esi
	dec	eax
	mov	DWORD PTR [ebx+edx+140], eax

; 1199 :         list[left].op4.contjump = right-left+list[right].op1.skipsize-1;

	mov	eax, DWORD PTR _list
	mov	ecx, DWORD PTR [ecx+eax+32]
	sub	ecx, esi
	lea	edx, DWORD PTR [ecx+edi-1]
	mov	DWORD PTR [ebx+eax+148], edx

; 1200 :         list[loopbase[loopdepth-1]].op3.breakjump = 
; 1201 :             listtop-loopbase[loopdepth-1]-1; /* break to here */

	mov	eax, DWORD PTR _loopdepth
	mov	eax, DWORD PTR _loopbase[eax*4-4]
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	dec	ecx
	mov	DWORD PTR [eax+edx+140], ecx

; 1202 :         loopdepth--;

	dec	DWORD PTR _loopdepth

; 1203 :         if ( loopdepth < 0 )

	jns	$LN878@makenode

; 1204 :           kb_error(1400,"Internal error: loopdepth negative.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CF@NEDBIMHF@Internal?5error?3?5loopdepth?5negati@
	push	1400					; 00000578H
	call	_kb_error

; 1205 :         break;

	jmp	$LN907@makenode
$LN262@makenode:

; 1503 : 
; 1504 :     case SET_AMBIENT_PRESSURE_NODE: case SET_GAP_CONSTANT_NODE:
; 1505 :     case NOTCH_NODE: case SET_AUTOCHOP_NODE: 
; 1506 :     case SET_OPTIMIZE_NODE: case SET_SCALE_NODE:
; 1507 :     case JIGGLE_NODE:  case QUIT_NODE:
; 1508 :     case STRPRINT_NODE:
; 1509 :     case INVOKE_P_MENU_NODE: case SET_MODEL_NODE: case SKINNY_NODE: case TORDUP_NODE:
; 1510 :          list[listtop].type = type;
; 1511 :          list[listtop].left = left - listtop;  /* value expression */
; 1512 :          list[listtop].stack_delta = -1;
; 1513 :          break;
; 1514 : 
; 1515 :     case PRINT_NODE: 
; 1516 :          list[listtop].type = type;
; 1517 :          list[listtop].left = left - listtop;  /* value expression */
; 1518 :          list[listtop].stack_delta = -1;
; 1519 :          break;
; 1520 : 
; 1521 :     case SET_INTERNAL_NODE:
; 1522 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1523 :          list[listtop].left = right - listtop;  /* value expression */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], edi

; 1524 :          list[listtop].op1.name_id = left;  /* variable */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+32], esi

; 1525 :          list[listtop].op2.assigntype = assigntype;  

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _assigntype
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _list
	mov	DWORD PTR [edx+ecx+136], eax

; 1526 :          list[listtop].stack_delta = (assigntype == ASSIGN_OP) ? -1 : 0;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	xor	edx, edx
	cmp	DWORD PTR _assigntype, 30001		; 00007531H
	setne	dl
	imul	eax, 168				; 000000a8H
	dec	edx
	mov	DWORD PTR [eax+ecx+156], edx

; 1527 : 
; 1528 :          switch(left)

	cmp	esi, 1879				; 00000757H
	jg	SHORT $LN592@makenode
	cmp	esi, 1877				; 00000755H
	jge	$LN257@makenode
	lea	eax, DWORD PTR [esi-1610]
	cmp	eax, 251				; 000000fbH
	ja	$LN255@makenode
	movzx	edx, BYTE PTR $LN867@makenode[eax]
	jmp	DWORD PTR $LN950@makenode[edx*4]
$LN256@makenode:

; 1540 :           case V_BACKGROUND: break; case V_LAST_ERROR:
; 1541 :           case V_INTEGRAL_ORDER_1D: case V_INTEGRAL_ORDER_2D: case V_DIFFUSION:
; 1542 :           case V_PS_STRINGWIDTH: case V_PS_FIXEDEDGEWIDTH:
; 1543 :           case V_PS_TRIPLEEDGEWIDTH: case V_PS_GRIDEDGEWIDTH:
; 1544 :           case V_PS_CONEDGEWIDTH: case V_PS_BAREEDGEWIDTH:
; 1545 :           case V_PS_LABELSIZE: case V_MINDEG_MARGIN: case V_MINDEG_DEBUG_LEVEL:
; 1546 :           case V_MINDEG_MIN_REGION_SIZE: case V_WINDOW_ASPECT_RATIO:
; 1547 :           case V_CORONA_STATE: case V_STRING_CURVE_TOLERANCE:
; 1548 :           case V_AUTOCHOP_LENGTH: case GRAV_CONST_TOK:
; 1549 :             break;
; 1550 : 
; 1551 : 
; 1552 :           case V_INTEGRAL_ORDER:
; 1553 :             kb_error(1413,
; 1554 :                "Please use integral_order_1d or integral_order_2d.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0DE@BIBENIGB@Please?5use?5integral_order_1d?5or?5@
	push	1413					; 00000585H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1555 :             break;

	jmp	$LN257@makenode
$LN592@makenode:

; 1527 : 
; 1528 :          switch(left)

	cmp	esi, 2270				; 000008deH
	jg	SHORT $LN593@makenode
	cmp	esi, 2268				; 000008dcH
	jge	$LN257@makenode
	lea	eax, DWORD PTR [esi-1884]
	cmp	eax, 232				; 000000e8H
	ja	SHORT $LN255@makenode
	movzx	eax, BYTE PTR $LN868@makenode[eax]
	jmp	DWORD PTR $LN951@makenode[eax*4]
$LN593@makenode:
	cmp	esi, 2309				; 00000905H
	jg	SHORT $LN594@makenode
	cmp	esi, 2308				; 00000904H
	jge	$LN257@makenode
	lea	eax, DWORD PTR [esi-2277]
	cmp	eax, 26					; 0000001aH
	ja	SHORT $LN255@makenode
	movzx	ecx, BYTE PTR $LN869@makenode[eax]
	jmp	DWORD PTR $LN952@makenode[ecx*4]
$LN594@makenode:
	cmp	esi, 10419				; 000028b3H
	jg	SHORT $LN595@makenode
	cmp	esi, 10417				; 000028b1H
	jge	$LN257@makenode
	cmp	esi, 10415				; 000028afH
	jne	SHORT $LN255@makenode

; 1529 :         { /* break on settable variables */
; 1530 :           case V_AMBIENT_PRESSURE: case V_HESSIAN_SLANT_CUTOFF:
; 1531 :           case GRAV_CONST_NODE: case V_BREAKFLAG_NODE: case V_VISIBILITY_DEBUG_NODE:
; 1532 :           case V_TOLERANCE: case V_HESS_EPSILON:  case V_DETORUS_EPSILON:
; 1533 :           case V_BOUNDING_BOX_COLOR: 
; 1534 :           case V_SCALE_SCALE: case V_TIME: case V_SCALE: 
; 1535 :           case V_JIG_TEMP: case V_SCALE_LIMIT: case V_GAP_CONSTANT:
; 1536 :           case V_THICKNESS: case V_TARGET_TOLERANCE: case V_SCROLLBUFFERSIZE_NODE:
; 1537 :           case V_PICKVNUM: case V_PICKENUM: case V_PICKFNUM:
; 1538 :           case V_LINEAR_METRIC_MIX: case V_QUADRATIC_METRIC_MIX:
; 1539 :           case V_RANDOM_SEED: break; case V_BRIGHTNESS: 

	jmp	$LN257@makenode
$LN595@makenode:

; 1527 : 
; 1528 :          switch(left)

	cmp	esi, 35080				; 00008908H
	je	$LN257@makenode
$LN255@makenode:

; 1556 :           default: 
; 1557 :             sprintf(msg,"Cannot set internal variable '%s'.\n",keywordname(left));

	push	esi
	call	_keywordname
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0CE@GNJOFDDC@Cannot?5set?5internal?5variable?5?8?$CFs@
	push	edx
	call	_sprintf

; 1558 :             kb_error(1414,msg,EXPRESSION_ERROR);

	mov	eax, DWORD PTR _msg
	push	4
	push	eax
	push	1414					; 00000586H
	call	_kb_error
	add	esp, 28					; 0000001cH

; 1559 : 
; 1560 :         }
; 1561 :          list[listtop].stack_delta = -1;
; 1562 :          break;

	jmp	$LN257@makenode
$LN254@makenode:

; 1563 : 
; 1564 :     case FIX_QUANTITY_NODE: case UNFIX_QUANTITY_NODE:
; 1565 :     case SET_Q_FIXED_NODE: case SET_Q_ENERGY_NODE: case SET_Q_INFO_NODE: 
; 1566 :     case SET_Q_CONSERVED_NODE:
; 1567 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1568 :          list[listtop].op1.quant_id = left;  /* named quantity var number */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], esi
$LN252@makenode:

; 1569 :          list[listtop].flags |= EPHEMERAL;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	or	DWORD PTR [ecx+edx+24], 64		; 00000040H
	lea	eax, DWORD PTR [ecx+edx+24]
	jmp	$LN878@makenode
$LN253@makenode:

; 1570 :          break;
; 1571 : 
; 1572 :     case FIX_PARAMETER_NODE:
; 1573 :     case UNFIX_PARAMETER_NODE:
; 1574 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1575 :          list[listtop].op1.name_id = left; /* variable number */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 1576 :          if ( !(globals(left)->flags & ORDINARY_PARAM ) )

	mov	ecx, esi
	mov	DWORD PTR [edx+eax+32], esi
	mov	edx, DWORD PTR _dymem
	mov	edi, DWORD PTR _web+5652
	mov	ebx, DWORD PTR _localbase
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN596@makenode
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN598@makenode
	and	esi, 16777215				; 00ffffffH
	mov	eax, esi
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ebx]
	jmp	SHORT $LN597@makenode
$LN598@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN596@makenode
	mov	eax, DWORD PTR _web+5656
	and	esi, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN597@makenode
$LN596@makenode:
	and	esi, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [eax+edx]
$LN597@makenode:
	test	BYTE PTR [eax+192], 1
	jne	$LN252@makenode

; 1577 :          { sprintf(errmsg,"'%s' cannot be made an optimizing parameter.\n",
; 1578 :               globals(left)->name);

	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN606@makenode
	lea	ecx, DWORD PTR [edi+esi*4]
	mov	esi, DWORD PTR [ecx+edx]
	jmp	SHORT $LN603@makenode
$LN606@makenode:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN604@makenode
	imul	esi, 224				; 000000e0H
	add	esi, DWORD PTR [ebx]
	jmp	SHORT $LN603@makenode
$LN604@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN602@makenode
	mov	edx, DWORD PTR _web+5656
	mov	esi, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN603@makenode
$LN602@makenode:
	lea	eax, DWORD PTR [edi+esi*4]
	mov	esi, DWORD PTR [eax+edx]
$LN603@makenode:
	push	esi
	push	OFFSET ??_C@_0CO@PEOAOHHI@?8?$CFs?8?5cannot?5be?5made?5an?5optimizin@
	push	OFFSET _errmsg
	call	_sprintf

; 1579 :            kb_error(2223,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	2223					; 000008afH
	call	_kb_error
	add	esp, 24					; 00000018H

; 1580 :          }
; 1581 :          list[listtop].flags |= EPHEMERAL;
; 1582 :          break;

	jmp	$LN252@makenode
$LN248@makenode:

; 1583 : 
; 1584 :    
; 1585 :     case ARRAYLIST_NODE:
; 1586 :          list[listtop].type = type;
; 1587 :          list[listtop].left = left-listtop;  /* arraylvalue */
; 1588 :          list[listtop].right = right-listtop;  /* arraylvalue */
; 1589 :          break;
; 1590 : 
; 1591 :     case ARRAYEXPR_NODE:
; 1592 :          list[listtop].type = type;
; 1593 :          if ( left )
; 1594 :            list[listtop].left = left-listtop;  /* arraylvalue */
; 1595 :          break;
; 1596 : 
; 1597 :    
; 1598 :     case ARRAYEXPR_ASSIGN_NODE:
; 1599 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 1600 :          list[listtop].left = left-listtop;  /* arraylvalue */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, esi

; 1601 :          list[listtop].right = right-listtop;  /* arrayrvalue */
; 1602 :          if ( check_recalc_attr(list[left].op2.name_id) )

	imul	esi, 168				; 000000a8H
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edi
	mov	edi, DWORD PTR _list
	mov	edx, DWORD PTR [esi+edi+136]
	push	edx
	call	_check_recalc_attr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN247@makenode

; 1603 :            list[listtop].flags |= RECALC_FLAG;

	mov	eax, DWORD PTR _listtop
	imul	eax, 168				; 000000a8H
	or	DWORD PTR [eax+edi+24], 32768		; 00008000H
	lea	eax, DWORD PTR [eax+edi+24]
$LN247@makenode:

; 1604 :          if ( check_dont_resize_attr(list[left].op2.name_id) )

	mov	edi, DWORD PTR _list
	mov	ecx, DWORD PTR [esi+edi+136]
	push	ecx
	call	_check_dont_resize_attr
	add	esp, 4
	test	eax, eax
	je	$LN878@makenode

; 1605 :            list[listtop].flags |= DONT_RESIZE_FLAG;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	or	DWORD PTR [edx+edi+24], 131072		; 00020000H
	lea	eax, DWORD PTR [edx+edi+24]

; 1606 : 
; 1607 :          break;

	jmp	$LN878@makenode
$LN180@makenode:

; 2022 :        }
; 2023 : 
; 2024 :     case ARRAY_HEAD_NODE:
; 2025 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2026 :          list[listtop].op1.name_id = right; /* global variable number */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], edi

; 2027 :          list[listtop].left = left-listtop;  /* indexset */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, esi

; 2028 :          list[listtop].op5.indexcount = list[left].op5.indexcount; /* # indices */

	imul	esi, 168				; 000000a8H
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx
	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [esi+eax+152]
	mov	DWORD PTR [ecx+eax+152], edx

; 2029 : /*
; 2030 :          if ( list[left].op5.indexcount != globals(right)->dim ) 
; 2031 :          { sprintf(errmsg,
; 2032 :               "Array %s has wrong number of dimensions; should be %d\n",
; 2033 :                  globals(int_val)->name,globals(int_val)->dim);
; 2034 :            kb_error(3360,errmsg,COMMAND_ERROR);
; 2035 :          }
; 2036 : */
; 2037 :          list[listtop].flags |= EPHEMERAL;
; 2038 :          break;

	jmp	$LN939@makenode
$LN179@makenode:

; 2039 : 
; 2040 :     /* whole-array syntax */
; 2041 : 
; 2042 :     case ARRAYIDENT_NODE:  /* push datastart for an array */
; 2043 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 2044 :          list[listtop].op2.name_id = left;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+136], esi

; 2045 :          list[listtop].op5.indexcount = 0;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+152], 0
$LN457@makenode:

; 2046 :          list[listtop].stack_delta = 1;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], 1

; 2047 :          break;

	jmp	$LN878@makenode
$LN178@makenode:

; 2048 : 
; 2049 :     case ATTRIB_LVALUE_NODE:
; 2050 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2051 :          if ( left )

	test	esi, esi
	je	SHORT $LN177@makenode

; 2052 :            list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi
$LN177@makenode:

; 2053 :          if ( right ) 

	test	edi, edi
	je	$LN481@makenode

; 2054 :            list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edi

; 2055 :          list[listtop].stack_delta = 1;
; 2056 :          break;

	jmp	$LN481@makenode
$LN175@makenode:

; 2057 : 
; 2058 :     case ARRAY_LVALUE_INDEXED_NODE: /* nop at execution */
; 2059 :        { struct array *a = 
; 2060 :                 get_name_arrayptr(list[left].op2.name_id,NULL,localbase);

	mov	edx, DWORD PTR _localbase
	mov	ecx, esi
	imul	ecx, 168				; 000000a8H
	mov	eax, DWORD PTR [ecx+eax+136]
	push	edx
	push	0
	push	eax
	mov	DWORD PTR tv8511[ebp], ecx
	call	_get_name_arrayptr

; 2061 :          if ( a->dim < list[right].op5.indexcount ) 

	mov	edx, DWORD PTR _list
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, edi
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR tv8548[ebp], ecx
	mov	ecx, DWORD PTR [ecx+edx+152]
	add	esp, 12					; 0000000cH
	cmp	eax, ecx
	jge	SHORT $LN174@makenode

; 2062 :          { sprintf(errmsg,"Array %s should have at most %d indexes, has %d.\n",
; 2063 :              get_name_name(list[left].op2.name_id,localbase),
; 2064 :              a->dim,list[right].op5.indexcount);

	push	ecx
	mov	ecx, DWORD PTR _localbase
	push	eax
	mov	eax, DWORD PTR tv8511[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+edx+136]
	push	ecx
	call	_get_name_name
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0DC@IPLHDPDE@Array?5?$CFs?5should?5have?5at?5most?5?$CFd?5@
	push	OFFSET _errmsg
	call	_sprintf

; 2065 :            kb_error(3267,errmsg,Q_ERROR);

	push	8
	push	OFFSET _errmsg
	push	3267					; 00000cc3H
	call	_kb_error
	mov	edx, DWORD PTR _list
	add	esp, 32					; 00000020H
$LN174@makenode:

; 2066 :          }
; 2067 :          check_readonly_attr(list[left].op2.name_id);

	mov	eax, DWORD PTR tv8511[ebp]
	mov	ecx, DWORD PTR [eax+edx+136]
	push	ecx
	call	_check_readonly_attr

; 2068 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 2069 :          list[listtop].left = left-listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], esi

; 2070 :          list[listtop].right = right-listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list

; 2071 :          list[listtop].op5.indexcount = list[right].op5.indexcount;

	mov	ecx, DWORD PTR tv8548[ebp]
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR [ecx+eax+152]
	mov	DWORD PTR [edx+eax+152], esi

; 2072 :          list[listtop].op2.name_id = list[left].op2.name_id;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	mov	esi, DWORD PTR tv8511[ebp]
	mov	esi, DWORD PTR [esi+eax+136]
	add	esp, 4
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+136], esi

; 2073 :          list[listtop].stack_delta = list[right].op5.indexcount;

	mov	eax, DWORD PTR _list
	mov	ecx, DWORD PTR [ecx+eax+152]

; 2074 :          break;

	jmp	$LN942@makenode
$LN173@makenode:

; 2075 :       }
; 2076 : 
; 2077 :      case ARRAY_RVALUE_INDEXED_NODE: /* nop at execution */
; 2078 :        { struct array *a = get_name_arrayptr(list[left].op2.name_id,NULL,localbase);

	mov	edx, DWORD PTR _localbase
	mov	ecx, esi
	imul	ecx, 168				; 000000a8H
	mov	eax, DWORD PTR [ecx+eax+136]
	push	edx
	push	0
	push	eax
	mov	DWORD PTR tv8511[ebp], ecx
	call	_get_name_arrayptr

; 2079 : 
; 2080 :          if ( a->dim < list[right].op5.indexcount ) 

	mov	edx, DWORD PTR _list
	mov	ecx, edi
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR _a$90080[ebp], eax
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR tv8548[ebp], ecx
	mov	ecx, DWORD PTR [ecx+edx+152]
	add	esp, 12					; 0000000cH
	cmp	eax, ecx
	jge	SHORT $LN172@makenode

; 2081 :          { sprintf(errmsg,"Array %s should have at most %d indexes, has %d.\n",
; 2082 :              get_name_name(list[left].op2.name_id,localbase),a->dim,list[right].op5.indexcount);

	push	ecx
	mov	ecx, DWORD PTR _localbase
	push	eax
	mov	eax, DWORD PTR tv8511[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+edx+136]
	push	ecx
	call	_get_name_name
	add	esp, 8
	push	eax
	push	OFFSET ??_C@_0DC@IPLHDPDE@Array?5?$CFs?5should?5have?5at?5most?5?$CFd?5@
	push	OFFSET _errmsg
	call	_sprintf

; 2083 :            kb_error(1909,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	1909					; 00000775H
	call	_kb_error
	mov	edx, DWORD PTR _list
	add	esp, 32					; 00000020H
$LN172@makenode:

; 2084 :          }
; 2085 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx], ebx

; 2086 :          list[listtop].left = left-listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], esi

; 2087 :          if ( right )
; 2088 :          { list[listtop].right = right-listtop;

	mov	eax, DWORD PTR _listtop
	test	edi, edi
	je	SHORT $LN171@makenode
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi

; 2089 :            list[listtop].op5.indexcount = list[right].op5.indexcount;

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR tv8548[ebp]
	mov	edx, DWORD PTR [edx+eax+152]
	mov	DWORD PTR [ecx+eax+152], edx

; 2090 :          }
; 2091 :          else

	jmp	SHORT $LN170@makenode
$LN171@makenode:

; 2092 :            list[listtop].op5.indexcount = 0;

	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+152], 0
$LN170@makenode:

; 2093 :          list[listtop].op2.name_id = list[left].op2.name_id;

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR tv8511[ebp]
	mov	esi, DWORD PTR [edx+eax+136]
	mov	DWORD PTR [ecx+eax+136], esi

; 2094 :          list[listtop].datatype = a->datatype;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _a$90080[ebp]
	imul	eax, 168				; 000000a8H
	mov	ecx, DWORD PTR [ecx+8]
	mov	esi, DWORD PTR _list
	mov	DWORD PTR [eax+esi+20], ecx

; 2095 :          if ( (list[left].type == ARRAY_VERTEX_NORMAL_NODE) ||
; 2096 :                  (list[left].type == ARRAY_EDGE_VECTOR_NODE) ||
; 2097 :                  (list[left].type == ARRAY_FACET_NORMAL_NODE) )

	mov	ecx, DWORD PTR _list
	mov	eax, DWORD PTR [edx+ecx]
	cmp	eax, 10354				; 00002872H
	je	SHORT $LN168@makenode
	cmp	eax, 10355				; 00002873H
	je	SHORT $LN168@makenode
	cmp	eax, 10356				; 00002874H
	jne	SHORT $LN169@makenode
$LN168@makenode:

; 2098 :             list[listtop].flags |= IS_VIRTUAL_ATTR;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	or	DWORD PTR [edx+ecx+24], 65536		; 00010000H
	lea	eax, DWORD PTR [edx+ecx+24]
	mov	ecx, DWORD PTR _list
$LN169@makenode:

; 2099 :          list[listtop].stack_delta = list[listtop].op5.indexcount;

	mov	eax, DWORD PTR _listtop
	imul	eax, 168				; 000000a8H
	add	eax, ecx
	mov	ecx, DWORD PTR [eax+152]
	mov	DWORD PTR [eax+156], ecx

; 2100 :          break;

	jmp	$LN878@makenode
$LN166@makenode:

; 2101 :       }
; 2102 : 
; 2103 : 
; 2104 :     case ARRAY_EVAL_NODE: /* rexpr: ARRAY_LVALUE_INDEXED */
; 2105 :        { 
; 2106 :          list[listtop].type = type;
; 2107 :          list[listtop].left = left-listtop;
; 2108 :          list[listtop].datatype = REAL_TYPE; // result after conversion
; 2109 : 
; 2110 :          			  // Backpatch in case of constant indices on fixed dimension local array
; 2111 :          break;
; 2112 :        }
; 2113 : 
; 2114 :     case DOT_NODE:  /* dot product */
; 2115 :          { 
; 2116 :            int name1 = list[left].op2.name_id;

	mov	ecx, esi
	imul	ecx, 168				; 000000a8H
	mov	ecx, DWORD PTR [ecx+eax+136]

; 2117 :            int name2 = list[right].op2.name_id;

	mov	edx, edi
	imul	edx, 168				; 000000a8H
	mov	eax, DWORD PTR [edx+eax+136]

; 2118 :            int adim = get_name_dim(name1,localbase);

	mov	edx, DWORD PTR _localbase
	push	edx
	push	ecx
	mov	DWORD PTR _name1$90089[ebp], ecx
	mov	DWORD PTR _name2$90090[ebp], eax
	call	_get_name_dim

; 2119 :            int bdim = get_name_dim(name2,localbase);

	mov	ecx, DWORD PTR _name2$90090[ebp]
	mov	DWORD PTR _adim$90091[ebp], eax
	mov	eax, DWORD PTR _localbase
	push	eax
	push	ecx
	call	_get_name_dim
	add	esp, 16					; 00000010H

; 2120 :            if ( (adim != 1) || (bdim != 1) )

	cmp	DWORD PTR _adim$90091[ebp], 1
	jne	SHORT $LN164@makenode
	cmp	eax, 1
	je	SHORT $LN165@makenode
$LN164@makenode:

; 2121 :               kb_error(3329,"Dot product operands must be one dimensional.\n",
; 2122 :                  COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CP@LMHOJAKD@Dot?5product?5operands?5must?5be?5one@
	push	3329					; 00000d01H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN165@makenode:

; 2123 :            if ( (get_name_datatype(name1,localbase) != REAL_TYPE) || 
; 2124 :                     (get_name_datatype(name2,localbase) != REAL_TYPE) )  

	mov	edx, DWORD PTR _localbase
	mov	eax, DWORD PTR _name1$90089[ebp]
	push	edx
	push	eax
	call	_get_name_datatype
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN162@makenode
	mov	ecx, DWORD PTR _localbase
	mov	edx, DWORD PTR _name2$90090[ebp]
	push	ecx
	push	edx
	call	_get_name_datatype
	add	esp, 8
	cmp	eax, 1
	je	SHORT $LN163@makenode
$LN162@makenode:

; 2125 :               kb_error(3330,"Dot product operands must be of type real.\n",
; 2126 :                  COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CM@CFLEBAG@Dot?5product?5operands?5must?5be?5of?5@
	push	3330					; 00000d02H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN163@makenode:

; 2127 :            list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], ebx

; 2128 :            list[listtop].left = left-listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 2129 :            list[listtop].right = right-listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edi

; 2130 :            list[listtop].datatype = REAL_TYPE;

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 2131 :            list[listtop].op2.name_id = name1;

	mov	esi, DWORD PTR _name1$90089[ebp]
	mov	eax, 1
	mov	DWORD PTR [edx+ecx+20], eax
	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+ecx+136], esi

; 2132 :            list[listtop].op3.name_id = name2;

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR _name2$90090[ebp]
	mov	DWORD PTR [edx+ecx+140], esi

; 2133 :            list[listtop].stack_delta = 1;

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+ecx+156], eax

; 2134 :          }
; 2135 :          break;

	jmp	$LN878@makenode
$LN161@makenode:

; 2136 : 
; 2137 :     case ARRAY_ASSIGNOP_ARRAY_NODE: /* full array syntax */
; 2138 :          /* see if we have special attributes on right side */
; 2139 :          { 
; 2140 :            check_readonly_attr(list[left].op2.name_id);

	mov	ecx, esi
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [ecx+eax+136]
	push	edx
	mov	DWORD PTR tv8511[ebp], ecx
	call	_check_readonly_attr

; 2141 : 
; 2142 :            list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], ebx

; 2143 : 
; 2144 :            list[listtop].left = left-listtop;  /* lvalue */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 2145 :            list[listtop].right = right-listtop;  /* rvalue */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, edi

; 2146 :            list[listtop].op2.name_id = list[left].op2.name_id;
; 2147 :            list[listtop].op3.name_id = list[right].op2.name_id;

	imul	edi, 168				; 000000a8H
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], ecx
	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	eax, DWORD PTR tv8511[ebp]
	mov	esi, DWORD PTR [eax+ecx+136]
	mov	DWORD PTR [edx+ecx+136], esi
	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	esi, DWORD PTR [edi+ecx+136]
	mov	DWORD PTR [edx+ecx+140], esi

; 2148 :            if ( check_recalc_attr(list[left].op2.name_id) )

	mov	esi, DWORD PTR _list
	mov	eax, DWORD PTR [eax+esi+136]
	push	eax
	call	_check_recalc_attr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN160@makenode

; 2149 :              list[listtop].flags |= RECALC_FLAG;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	or	DWORD PTR [ecx+esi+24], 32768		; 00008000H
	lea	eax, DWORD PTR [ecx+esi+24]
	mov	esi, DWORD PTR _list
$LN160@makenode:

; 2150 :            if ( check_dont_resize_attr(list[left].op2.name_id) )

	mov	ebx, DWORD PTR tv8511[ebp]
	mov	edx, DWORD PTR [ebx+esi+136]
	push	edx
	call	_check_dont_resize_attr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN159@makenode

; 2151 :              list[listtop].flags |= DONT_RESIZE_FLAG;

	mov	eax, DWORD PTR _listtop
	imul	eax, 168				; 000000a8H
	or	DWORD PTR [eax+esi+24], 131072		; 00020000H
	lea	eax, DWORD PTR [eax+esi+24]
	mov	esi, DWORD PTR _list
$LN159@makenode:

; 2152 : 
; 2153 :            /* op1.assigntype will be set back in command.yac */
; 2154 : 
; 2155 :            /* Can do dimension check now */
; 2156 :            if ( check_array_dims_same(list[left].op2.name_id,
; 2157 :                          list[left].op5.indexcount,
; 2158 :                            list[right].op2.name_id,
; 2159 :                          list[right].op5.indexcount) == 0 )

	mov	ecx, DWORD PTR [edi+esi+152]
	mov	edx, DWORD PTR [edi+esi+136]
	mov	eax, DWORD PTR [ebx+esi+152]
	push	ecx
	mov	ecx, DWORD PTR [ebx+esi+136]
	push	edx
	push	eax
	push	ecx
	call	_check_array_dims_same
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN158@makenode

; 2160 :             kb_error(4378,"Arrays don't have same number of dimensions or types different.\n",
; 2161 :                COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0EB@HHJIPDPG@Arrays?5don?8t?5have?5same?5number?5of@
	push	4378					; 0000111aH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN936@makenode:
	mov	esi, DWORD PTR _list
$LN158@makenode:

; 2162 :            list[listtop].stack_delta = -2;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+esi+156], -2		; fffffffeH

; 2163 :          }
; 2164 :          break;

	jmp	$LN878@makenode
$LN157@makenode:

; 2165 : 
; 2166 :     case ARRAY_ASSIGNOP_SCALAR_NODE: /* full array syntax */
; 2167 :     case ARRAY_ASSIGNOP_STRING_NODE: /* full array syntax */
; 2168 :          check_readonly_attr(list[left].op2.name_id);

	mov	ecx, esi
	imul	ecx, 168				; 000000a8H
	mov	eax, DWORD PTR [ecx+eax+136]
	push	eax
	mov	DWORD PTR tv8511[ebp], ecx
	call	_check_readonly_attr

; 2169 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], ebx

; 2170 :          list[listtop].op2.name_id = list[left].op2.name_id;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR tv8511[ebp]
	mov	ebx, DWORD PTR [ecx+eax+136]
	mov	DWORD PTR [edx+eax+136], ebx

; 2171 :          list[listtop].left = left-listtop;  /* lvalue array */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 2172 :          list[listtop].right = right-listtop;  /* rexpr */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi

; 2173 :          if ( check_recalc_attr(list[left].op2.name_id) )

	mov	esi, DWORD PTR _list
	mov	eax, DWORD PTR [ecx+esi+136]
	push	eax
	call	_check_recalc_attr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN156@makenode

; 2174 :            list[listtop].flags |= RECALC_FLAG;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	or	DWORD PTR [ecx+esi+24], 32768		; 00008000H
	lea	eax, DWORD PTR [ecx+esi+24]
	mov	esi, DWORD PTR _list
$LN156@makenode:

; 2175 :          if ( check_dont_resize_attr(list[left].op2.name_id) )

	mov	edx, DWORD PTR tv8511[ebp]
	mov	eax, DWORD PTR [edx+esi+136]
	push	eax
	call	_check_dont_resize_attr
	add	esp, 4
	test	eax, eax
	je	$LN158@makenode

; 2176 :            list[listtop].flags |= DONT_RESIZE_FLAG;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	or	DWORD PTR [ecx+esi+24], 131072		; 00020000H
	lea	eax, DWORD PTR [ecx+esi+24]

; 2177 :          list[listtop].stack_delta = -2;
; 2178 :          /* op1.assigntype will be set back in command.yac */
; 2179 :          break;

	jmp	$LN936@makenode
$LN153@makenode:

; 2180 :  
; 2181 :     case ARRAY_RVALUE_NODE: /* nop needed for tree construction */
; 2182 :          list[listtop].type = type;
; 2183 :          list[listtop].left = left-listtop;  /* lvalue array */
; 2184 :          list[listtop].right = right-listtop;  /* rexpr */
; 2185 :          break;
; 2186 : 
; 2187 :     case ARRAY_ASSIGNOP_S_X_A_NODE: /* full array syntax, scalar times array */
; 2188 :          check_readonly_attr(list[left].op2.name_id);

	mov	ecx, esi
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [ecx+eax+136]
	push	edx
	mov	DWORD PTR tv8511[ebp], ecx
	call	_check_readonly_attr

; 2189 :          list[listtop].type = type;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], ebx

; 2190 :          list[listtop].op2.name_id = list[left].op2.name_id;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR tv8511[ebp]
	mov	ebx, DWORD PTR [ecx+eax+136]
	mov	DWORD PTR [edx+eax+136], ebx

; 2191 :          list[listtop].left = left-listtop;  /* lvalue array */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 2192 :          list[listtop].right = right-listtop;  /* rvalue */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi

; 2193 :          if ( check_recalc_attr(list[left].op2.name_id) )

	mov	esi, DWORD PTR _list
	mov	eax, DWORD PTR [ecx+esi+136]
$LN944@makenode:
	push	eax
	call	_check_recalc_attr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN152@makenode

; 2194 :            list[listtop].flags |= RECALC_FLAG;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	or	DWORD PTR [ecx+esi+24], 32768		; 00008000H
	lea	eax, DWORD PTR [ecx+esi+24]
	mov	esi, DWORD PTR _list
$LN152@makenode:

; 2195 :          if ( check_dont_resize_attr(list[left].op2.name_id) )

	mov	edx, DWORD PTR tv8511[ebp]
	mov	eax, DWORD PTR [edx+esi+136]
	push	eax
	call	_check_dont_resize_attr
	add	esp, 4
	test	eax, eax
	je	SHORT $LN151@makenode

; 2196 :            list[listtop].flags |= DONT_RESIZE_FLAG;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	or	DWORD PTR [ecx+esi+24], 131072		; 00020000H
	lea	eax, DWORD PTR [ecx+esi+24]
	mov	esi, DWORD PTR _list
$LN151@makenode:

; 2197 :          /* op1.assigntype will be set back in command.yac */
; 2198 :          list[listtop].stack_delta = -3;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+esi+156], -3		; fffffffdH

; 2199 :          break;

	jmp	$LN878@makenode
$LN150@makenode:

; 2200 : 
; 2201 : 
; 2202 :     case ARRAY_ADD_NODE: /* array plus array, to temp array */
; 2203 :     case ARRAY_SUBTRACT_NODE: /* array minus array, to temp array */
; 2204 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2205 :          list[listtop].left = left-listtop;  /* addend array */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi

; 2206 :          list[listtop].right = right-listtop;  /* addend array */
; 2207 :          list[listtop].stack_delta = -1;
; 2208 :          { // need temp array to hold result
; 2209 :            char tempname[100];
; 2210 :            ident_t temp_id;
; 2211 :            struct global *g;
; 2212 :            struct array *al =  get_name_arrayptr(list[left].op2.name_id,NULL,localbase);

	imul	esi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, edi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edx
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], -1
	mov	ecx, DWORD PTR _localbase
	mov	edx, DWORD PTR _list
	mov	eax, DWORD PTR [esi+edx+136]
	push	ecx
	push	0
	push	eax
	call	_get_name_arrayptr

; 2213 :            struct array *ar =  get_name_arrayptr(list[right].op2.name_id,NULL,localbase);

	imul	edi, 168				; 000000a8H
	mov	ecx, DWORD PTR _localbase
	mov	edx, DWORD PTR _list
	push	ecx
	mov	DWORD PTR _al$90115[ebp], eax
	mov	eax, DWORD PTR [edi+edx+136]
	push	0
	push	eax
	call	_get_name_arrayptr
	mov	DWORD PTR _ar$90117[ebp], eax

; 2214 :            int i,size,pointercount;
; 2215 :      
; 2216 :            sprintf(tempname,"temp_array_%d",temp_array_number++);

	mov	eax, DWORD PTR _temp_array_number
	push	eax
	lea	ecx, DWORD PTR _tempname$90112[ebp]
	inc	eax
	push	OFFSET ??_C@_0O@ILBCJIOO@temp_array_?$CFd?$AA@
	push	ecx
	mov	DWORD PTR _temp_array_number, eax
	call	_sprintf

; 2217 :            temp_id = add_local_var(tempname,1);

	lea	edx, DWORD PTR _tempname$90112[ebp]
	push	1
	push	edx
	call	_add_local_var
	mov	DWORD PTR _temp_id$90113[ebp], eax

; 2218 :            g = globals(temp_id);

	and	eax, -16777216				; ff000000H
	add	esp, 44					; 0000002cH
	mov	DWORD PTR tv9030[ebp], eax
	cmp	eax, 268435456				; 10000000H
	je	SHORT $LN702@makenode
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN704@makenode
	mov	ebx, DWORD PTR _temp_id$90113[ebp]
	mov	ecx, DWORD PTR _localbase
	and	ebx, 16777215				; 00ffffffH
	mov	DWORD PTR tv9032[ebp], ebx
	imul	ebx, 224				; 000000e0H
	add	ebx, DWORD PTR [ecx]
	jmp	SHORT $LN703@makenode
$LN704@makenode:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN702@makenode
	mov	eax, DWORD PTR _temp_id$90113[ebp]
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	ebx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv9032[ebp], eax
	jmp	SHORT $LN703@makenode
$LN702@makenode:
	mov	eax, DWORD PTR _temp_id$90113[ebp]
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv9032[ebp], eax
	mov	eax, DWORD PTR _dymem
	mov	ebx, DWORD PTR [edx+eax]
$LN703@makenode:

; 2219 :            g->attr.arrayptr = (struct array *)mycalloc(1,sizeof(struct array));

	push	2219					; 000008abH
	push	OFFSET ??_C@_0L@OKHAMMPH@YEXPARSE?4C?$AA@
	push	56					; 00000038H
	push	1
	call	_kb_calloc

; 2220 :            g->flags |= ARRAY_PARAM;

	or	DWORD PTR [ebx+192], 2048		; 00000800H
	mov	DWORD PTR [ebx+168], eax

; 2221 :            list[left].flags |= IS_RVALUE;

	mov	eax, DWORD PTR _list
	mov	ecx, 8192				; 00002000H
	or	DWORD PTR [esi+eax+24], ecx

; 2222 :            list[right].flags |= IS_RVALUE;

	mov	eax, DWORD PTR _list
	or	DWORD PTR [edi+eax+24], ecx

; 2223 : //           check_special_attr(list[left].op2.name_id);
; 2224 :  //          check_special_attr(list[right].op2.name_id);
; 2225 :            // Can do dimension check now
; 2226 :            if ( check_array_dims_same(list[left].op2.name_id,
; 2227 :                        list[left].op5.indexcount,
; 2228 :                        list[right].op2.name_id,
; 2229 :                        list[right].op5.indexcount) == 0 )

	mov	eax, DWORD PTR _list
	mov	ecx, DWORD PTR [edi+eax+152]
	mov	edx, DWORD PTR [edi+eax+136]
	push	ecx
	mov	ecx, DWORD PTR [esi+eax+152]
	push	edx
	mov	edx, DWORD PTR [esi+eax+136]
	push	ecx
	push	edx
	call	_check_array_dims_same
	add	esp, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN149@makenode

; 2230 :              kb_error(4380,
; 2231 :             "Arrays don't have same number of dimensions or types are different.\n",
; 2232 :                        COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0EF@DIIILPA@Arrays?5don?8t?5have?5same?5number?5of@
	push	4380					; 0000111cH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN149@makenode:

; 2233 :            list[listtop].op2.name_id = temp_id;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	ecx, DWORD PTR _temp_id$90113[ebp]
	mov	DWORD PTR [eax+edx+136], ecx

; 2234 :            list[listtop].op3.name_id = list[left].op2.name_id;

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [ecx+eax+140], edx

; 2235 :            list[listtop].op4.name_id = list[right].op2.name_id;

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [edi+eax+136]
	mov	DWORD PTR [ecx+eax+148], edx

; 2236 :            list[listtop].op5.indexcount = 0;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	xor	edx, edx
	mov	DWORD PTR [eax+ecx+152], edx

; 2237 :            g->attr.arrayptr->dim =
; 2238 :                al->dim - list[left].op5.indexcount;

	mov	edi, DWORD PTR _list
	mov	eax, DWORD PTR _al$90115[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [esi+edi+152]
	mov	edi, DWORD PTR [ebx+168]
	mov	DWORD PTR [edi+4], ecx

; 2239 :            g->attr.arrayptr->datatype = REAL_TYPE;

	mov	ecx, DWORD PTR [ebx+168]
	mov	DWORD PTR [ecx+8], 1

; 2240 :            g->attr.arrayptr->itemsize =  sizeof(REAL);

	mov	ecx, DWORD PTR [ebx+168]
	mov	DWORD PTR [ecx+12], 8

; 2241 :      
; 2242 :            // see if can simplify in case of fixed sizes
; 2243 :            if ((al->flags & FIXED_SIZE_ARRAY) || (ar->flags & FIXED_SIZE_ARRAY))

	test	DWORD PTR [eax], 268435456		; 10000000H
	jne	SHORT $LN147@makenode
	mov	eax, DWORD PTR _ar$90117[ebp]
	test	DWORD PTR [eax], 268435456		; 10000000H
	jne	SHORT $LN147@makenode
$LN141@makenode:

; 2256 :            }
; 2257 :            else
; 2258 :            { g->flags |= UNFIXED_SIZE_ARRAY;

	or	DWORD PTR [ebx+192], 536870912		; 20000000H
	jmp	$LN878@makenode
$LN147@makenode:

; 2245 :              g->attr.arrayptr->flags |= FIXED_SIZE_ARRAY;

	mov	eax, DWORD PTR [ebx+168]
	or	DWORD PTR [ebx+192], 268435456		; 10000000H
	or	DWORD PTR [eax], 268435456		; 10000000H

; 2246 :              for ( i=0,size=1,pointercount=0 ; i < g->attr.arrayptr->dim ; i++ )

	mov	ecx, DWORD PTR [ebx+168]
	mov	DWORD PTR _i$90119[ebp], edx
	mov	eax, 1
	mov	DWORD PTR _pointercount$90121[ebp], edx
	cmp	DWORD PTR [ecx+4], edx
	jle	SHORT $LN144@makenode

; 2244 :            { g->flags |= FIXED_SIZE_ARRAY;

	mov	DWORD PTR tv11338[ebp], 24		; 00000018H
	npad	5
$LL900@makenode:

; 2247 :              { pointercount += size;
; 2248 :                g->attr.arrayptr->sizes[i] =
; 2249 :                   al->sizes[list[left].op5.indexcount + i];

	mov	edi, DWORD PTR _list
	mov	edi, DWORD PTR [esi+edi+152]
	add	DWORD PTR _pointercount$90121[ebp], eax
	add	edi, edx
	mov	edx, DWORD PTR _al$90115[ebp]
	mov	edx, DWORD PTR [edx+edi*4+24]
	mov	edi, DWORD PTR tv11338[ebp]
	mov	DWORD PTR [ecx+edi], edx

; 2250 :                size *= g->attr.arrayptr->sizes[i];

	mov	ecx, DWORD PTR [ebx+168]
	mov	edx, DWORD PTR _i$90119[ebp]
	imul	eax, DWORD PTR [ecx+edi]
	inc	edx
	add	edi, 4
	mov	DWORD PTR _i$90119[ebp], edx
	mov	DWORD PTR tv11338[ebp], edi
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LL900@makenode
$LN144@makenode:

; 2251 :              }
; 2252 :              g->attr.arrayptr->datacount = size;
; 2253 :              i = add_local_var(NULL,size+pointercount);

	mov	edx, DWORD PTR _pointercount$90121[ebp]
	mov	ecx, DWORD PTR [ebx+168]
	add	edx, eax
	push	edx
	push	0
	mov	DWORD PTR [ecx+16], eax
	call	_add_local_var

; 2254 :              g = globals(temp_id);  // in case add_local_var reallocated

	mov	ecx, DWORD PTR tv9030[ebp]
	mov	edx, DWORD PTR _localbase
	add	esp, 8
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN708@makenode
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN710@makenode
	mov	ecx, DWORD PTR tv9032[ebp]
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN709@makenode
$LN710@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN708@makenode
	mov	ecx, DWORD PTR _web+5656
	mov	esi, DWORD PTR tv9032[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	jmp	SHORT $LN709@makenode
$LN708@makenode:
	mov	esi, DWORD PTR tv9032[ebp]
$LN938@makenode:
	mov	ecx, DWORD PTR _web+5652
	lea	ecx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+esi]
$LN709@makenode:

; 2255 :              g->attr.arrayptr->datastart = get_local(i).offset;

	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+168]
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	mov	edx, DWORD PTR [eax+edx+216]
	mov	DWORD PTR [ecx+20], edx

; 2259 :            }
; 2260 :      
; 2261 :          } 
; 2262 :          break;

	jmp	$LN878@makenode
$LN142@makenode:

; 2263 : 
; 2264 :     case ARRAY_SCALAR_MULTIPLY_NODE: /* scalar times array, to temp array */
; 2265 :     case ARRAY_SCALAR_DIVIDE_NODE: /* scalar times array, to temp array */
; 2266 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2267 :          list[listtop].left = left-listtop;  /* scalar */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 2268 :          list[listtop].right = right-listtop;  /* array */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, edi

; 2269 :          list[listtop].stack_delta = -1;
; 2270 :          { // need temp array to hold result
; 2271 :            char tempname[100]; 
; 2272 :            ident_t temp_id;
; 2273 :            struct global *g;
; 2274 :            struct array *ar =  get_name_arrayptr(list[right].op2.name_id,NULL,localbase);

	imul	edi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edx
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], -1
	mov	ecx, DWORD PTR _localbase
	mov	edx, DWORD PTR _list
	mov	eax, DWORD PTR [edi+edx+136]
	push	ecx
	push	0
	push	eax
	call	_get_name_arrayptr
	mov	DWORD PTR _ar$90143[ebp], eax

; 2275 :            int i,size,pointercount;
; 2276 :      
; 2277 :            sprintf(tempname,"temp_array_%d",temp_array_number++);

	mov	eax, DWORD PTR _temp_array_number
	push	eax
	lea	ecx, DWORD PTR _tempname$90140[ebp]
	inc	eax
	push	OFFSET ??_C@_0O@ILBCJIOO@temp_array_?$CFd?$AA@
	push	ecx
	mov	DWORD PTR _temp_array_number, eax
	call	_sprintf

; 2278 :            temp_id = add_local_var(tempname,1);

	lea	edx, DWORD PTR _tempname$90140[ebp]
	push	1
	push	edx
	call	_add_local_var
	mov	DWORD PTR _temp_id$90141[ebp], eax

; 2279 :            g = globals(temp_id);

	and	eax, -16777216				; ff000000H
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv9134[ebp], eax
	cmp	eax, 268435456				; 10000000H
	je	SHORT $LN714@makenode
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN716@makenode
	mov	ebx, DWORD PTR _temp_id$90141[ebp]
	mov	ecx, DWORD PTR _localbase
	and	ebx, 16777215				; 00ffffffH
	mov	DWORD PTR tv9136[ebp], ebx
	imul	ebx, 224				; 000000e0H
	add	ebx, DWORD PTR [ecx]
	jmp	SHORT $LN715@makenode
$LN716@makenode:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN714@makenode
	mov	eax, DWORD PTR _temp_id$90141[ebp]
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	ebx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv9136[ebp], eax
	jmp	SHORT $LN715@makenode
$LN714@makenode:
	mov	eax, DWORD PTR _temp_id$90141[ebp]
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv9136[ebp], eax
	mov	eax, DWORD PTR _dymem
	mov	ebx, DWORD PTR [edx+eax]
$LN715@makenode:

; 2280 :            g->attr.arrayptr = (struct array *)mycalloc(1,sizeof(struct array));

	push	2280					; 000008e8H
	push	OFFSET ??_C@_0L@OKHAMMPH@YEXPARSE?4C?$AA@
	push	56					; 00000038H
	push	1
	call	_kb_calloc

; 2281 :            g->flags |= ARRAY_PARAM;
; 2282 :            list[left].flags |= IS_RVALUE;

	imul	esi, 168				; 000000a8H
	or	DWORD PTR [ebx+192], 2048		; 00000800H
	mov	DWORD PTR [ebx+168], eax
	mov	ecx, DWORD PTR _list
	lea	esi, DWORD PTR [esi+ecx+24]
	mov	ecx, 8192				; 00002000H
	or	DWORD PTR [esi], ecx

; 2283 :            list[right].flags |= IS_RVALUE;

	mov	eax, DWORD PTR _list
	or	DWORD PTR [edi+eax+24], ecx

; 2284 : //           check_special_attr(list[right].op2.name_id);
; 2285 :            // Can do dimension check now
; 2286 :            list[listtop].op2.name_id = temp_id;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _temp_id$90141[ebp]
	mov	DWORD PTR [edx+eax+136], ecx

; 2287 :            list[listtop].op3.name_id = list[right].op2.name_id;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [edi+eax+136]
	mov	DWORD PTR [edx+eax+140], ecx

; 2288 :            list[listtop].op5.indexcount = 0;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	xor	edx, edx
	mov	DWORD PTR [eax+ecx+152], edx

; 2289 :            g->attr.arrayptr->dim = ar->dim - list[right].op5.indexcount;

	mov	esi, DWORD PTR _list
	mov	eax, DWORD PTR _ar$90143[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR [edi+esi+152]
	mov	esi, DWORD PTR [ebx+168]
	mov	DWORD PTR [esi+4], ecx

; 2290 :            g->attr.arrayptr->datatype = REAL_TYPE;

	mov	ecx, DWORD PTR [ebx+168]
	mov	DWORD PTR [ecx+8], 1

; 2291 :            g->attr.arrayptr->itemsize =  sizeof(REAL);

	mov	ecx, DWORD PTR [ebx+168]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx+12], 8

; 2292 :      
; 2293 :            // see if can simplify in case of fixed sizes
; 2294 :            if ( ar->flags & FIXED_SIZE_ARRAY )

	test	DWORD PTR [eax], 268435456		; 10000000H
	je	$LN141@makenode

; 2296 :              g->attr.arrayptr->flags |= FIXED_SIZE_ARRAY;

	mov	eax, DWORD PTR [ebx+168]
	or	DWORD PTR [ebx+192], 268435456		; 10000000H
	or	DWORD PTR [eax], 268435456		; 10000000H

; 2297 :              for ( i=0,size=1,pointercount=0 ; i < g->attr.arrayptr->dim ; i++ )

	mov	ecx, DWORD PTR [ebx+168]
	mov	DWORD PTR _i$90145[ebp], edx
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR _pointercount$90147[ebp], edx
	cmp	DWORD PTR [ecx+4], edx
	jle	SHORT $LN138@makenode

; 2295 :            { g->flags |= FIXED_SIZE_ARRAY;

	mov	DWORD PTR tv11371[ebp], 24		; 00000018H
	npad	2
$LL899@makenode:

; 2298 :              { pointercount += size;
; 2299 :                g->attr.arrayptr->sizes[i] =
; 2300 :                   ar->sizes[list[right].op5.indexcount + i];

	mov	esi, DWORD PTR _list
	mov	esi, DWORD PTR [edi+esi+152]
	add	DWORD PTR _pointercount$90147[ebp], eax
	add	esi, edx
	mov	edx, DWORD PTR _ar$90143[ebp]
	mov	edx, DWORD PTR [edx+esi*4+24]
	mov	esi, DWORD PTR tv11371[ebp]
	mov	DWORD PTR [ecx+esi], edx

; 2301 :                size *= g->attr.arrayptr->sizes[i];

	mov	ecx, DWORD PTR [ebx+168]
	mov	edx, DWORD PTR _i$90145[ebp]
	imul	eax, DWORD PTR [ecx+esi]
	inc	edx
	add	esi, 4
	mov	DWORD PTR _i$90145[ebp], edx
	mov	DWORD PTR tv11371[ebp], esi
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LL899@makenode
$LN138@makenode:

; 2302 :              }
; 2303 :              g->attr.arrayptr->datacount = size;

	mov	ecx, DWORD PTR [ebx+168]
	mov	DWORD PTR [ecx+16], eax

; 2304 :              i = add_local_var(NULL,size+pointercount);

	add	eax, DWORD PTR _pointercount$90147[ebp]
	push	eax
	push	0
	call	_add_local_var

; 2305 :              g = globals(temp_id);  // in case add_local_var reallocated

	mov	ecx, DWORD PTR tv9134[ebp]
	mov	edx, DWORD PTR _localbase
	add	esp, 8
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN720@makenode
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN722@makenode
	mov	ecx, DWORD PTR tv9136[ebp]
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	$LN709@makenode
$LN722@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN720@makenode
	mov	ecx, DWORD PTR _web+5656
	mov	esi, DWORD PTR tv9136[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	jmp	$LN709@makenode
$LN720@makenode:
	mov	esi, DWORD PTR tv9136[ebp]

; 2306 :              g->attr.arrayptr->datastart = get_local(i).offset;
; 2307 :            }
; 2308 :            else

	jmp	$LN938@makenode
$LN136@makenode:

; 2309 :            { g->flags |= UNFIXED_SIZE_ARRAY;
; 2310 :            }
; 2311 :      
; 2312 :          }
; 2313 :          break;
; 2314 : 
; 2315 :     case ARRAY_MULTIPLY_NODE: /* array times array, to temp array */
; 2316 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2317 :          list[listtop].left = left-listtop;  /* first factor array */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi

; 2318 :          list[listtop].right = right-listtop;  /* second factor array */
; 2319 :          list[listtop].stack_delta = -1;
; 2320 :          { 
; 2321 :            char tempname[100];
; 2322 :            ident_t temp_id;
; 2323 :            struct global *g;
; 2324 :            struct array *al =  get_name_arrayptr(list[left].op2.name_id,NULL,localbase);

	imul	esi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, edi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edx
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], -1
	mov	ecx, DWORD PTR _localbase
	mov	edx, DWORD PTR _list
	mov	eax, DWORD PTR [esi+edx+136]
	push	ecx
	push	0
	push	eax
	call	_get_name_arrayptr

; 2325 :            struct array *ar =  get_name_arrayptr(list[right].op2.name_id,NULL,localbase);

	imul	edi, 168				; 000000a8H
	mov	ecx, DWORD PTR _localbase
	mov	edx, DWORD PTR _list
	push	ecx
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+edx+136]
	push	0
	push	eax
	mov	DWORD PTR _al$90165[ebp], ebx
	mov	DWORD PTR tv8548[ebp], edi
	call	_get_name_arrayptr

; 2326 :            int i,size,pointercount;
; 2327 : 
; 2328 :            list[listtop].op2.name_id = list[left].op2.name_id;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR _ar$90167[ebp], eax
	mov	eax, DWORD PTR _list
	mov	edx, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [ecx+eax+136], edx

; 2329 :            list[listtop].op3.name_id = list[right].op2.name_id;

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [edi+eax+136]
	mov	DWORD PTR [ecx+eax+140], edx

; 2330 :            if ( (al->dim-list[left].op5.indexcount == 1) && (ar->dim-list[right].op5.indexcount == 1))

	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR _list
	sub	ecx, DWORD PTR [esi+eax+152]
	add	esp, 24					; 00000018H
	cmp	ecx, 1
	jne	SHORT $LN884@makenode
	mov	edx, DWORD PTR _ar$90167[ebp]
	mov	ecx, DWORD PTR [edx+4]
	sub	ecx, DWORD PTR [edi+eax+152]
	cmp	ecx, 1
	jne	SHORT $LN884@makenode

; 2331 :            { // dot product
; 2332 :              list[listtop].type = DOT_NODE;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10361		; 00002879H

; 2333 :            }
; 2334 :            else

	jmp	$LN878@makenode
$LN884@makenode:

; 2335 :            { int j;
; 2336 :              // need temp array to hold result
; 2337 :              sprintf(tempname,"temp_array_%d",temp_array_number++);

	mov	eax, DWORD PTR _temp_array_number
	push	eax
	inc	eax
	mov	DWORD PTR _temp_array_number, eax
	lea	eax, DWORD PTR _tempname$90162[ebp]
	push	OFFSET ??_C@_0O@ILBCJIOO@temp_array_?$CFd?$AA@
	push	eax
	call	_sprintf

; 2338 :              temp_id = add_local_var(tempname,1);

	lea	ecx, DWORD PTR _tempname$90162[ebp]
	push	1
	push	ecx
	call	_add_local_var
	mov	DWORD PTR _temp_id$90163[ebp], eax

; 2339 :              g = globals(temp_id);

	and	eax, -16777216				; ff000000H
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv9247[ebp], eax
	cmp	eax, 268435456				; 10000000H
	je	SHORT $LN726@makenode
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN728@makenode
	mov	ebx, DWORD PTR _temp_id$90163[ebp]
	mov	edx, DWORD PTR _localbase
	and	ebx, 16777215				; 00ffffffH
	mov	DWORD PTR tv9249[ebp], ebx
	imul	ebx, 224				; 000000e0H
	add	ebx, DWORD PTR [edx]
	jmp	SHORT $LN727@makenode
$LN728@makenode:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN726@makenode
	mov	eax, DWORD PTR _temp_id$90163[ebp]
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	ebx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv9249[ebp], eax
	jmp	SHORT $LN727@makenode
$LN726@makenode:
	mov	eax, DWORD PTR _temp_id$90163[ebp]
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR tv9249[ebp], eax
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ebx, DWORD PTR [eax+ecx]
$LN727@makenode:

; 2340 :              g->attr.arrayptr = (struct array *)mycalloc(1,sizeof(struct array));

	push	2340					; 00000924H
	push	OFFSET ??_C@_0L@OKHAMMPH@YEXPARSE?4C?$AA@
	push	56					; 00000038H
	push	1
	call	_kb_calloc

; 2341 :              g->flags |= ARRAY_PARAM;

	or	DWORD PTR [ebx+192], 2048		; 00000800H
	mov	DWORD PTR [ebx+168], eax

; 2342 :              list[left].flags |= IS_RVALUE;

	mov	eax, DWORD PTR _list
	mov	ecx, 8192				; 00002000H
	or	DWORD PTR [esi+eax+24], ecx

; 2343 :              list[right].flags |= IS_RVALUE;

	mov	eax, DWORD PTR _list
	or	DWORD PTR [edi+eax+24], ecx

; 2344 : //             check_special_attr(list[left].op2.name_id);
; 2345 : //             check_special_attr(list[right].op2.name_id);
; 2346 :              list[listtop].op2.name_id = temp_id;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _temp_id$90163[ebp]
	mov	DWORD PTR [edx+eax+136], ecx

; 2347 :              list[listtop].op3.name_id = list[left].op2.name_id;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [edx+eax+140], ecx

; 2348 :              list[listtop].op4.name_id = list[right].op2.name_id;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [edi+eax+136]
	mov	DWORD PTR [edx+eax+148], ecx

; 2349 :              list[listtop].op5.indexcount = 0;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 2350 :              g->attr.arrayptr->dim =
; 2351 :                  al->dim - list[left].op5.indexcount
; 2352 :                + ar->dim - list[right].op5.indexcount - 2;

	mov	ecx, DWORD PTR _al$90165[ebp]
	mov	DWORD PTR [edx+eax+152], 0
	mov	eax, DWORD PTR _list
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, DWORD PTR [edi+eax+152]
	add	esp, 16					; 00000010H
	sub	edx, DWORD PTR [esi+eax+152]
	mov	eax, DWORD PTR _ar$90167[ebp]
	mov	eax, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [edx+eax-2]
	mov	eax, DWORD PTR [ebx+168]
	mov	DWORD PTR [eax+4], edx

; 2353 :              g->attr.arrayptr->datatype = REAL_TYPE;

	mov	edx, DWORD PTR [ebx+168]
	mov	DWORD PTR [edx+8], 1

; 2354 :              g->attr.arrayptr->itemsize =  sizeof(REAL);

	mov	eax, DWORD PTR [ebx+168]
	mov	DWORD PTR [eax+12], 8

; 2355 :        
; 2356 :              // see if can simplify in case of fixed sizes
; 2357 :              if ((al->flags & FIXED_SIZE_ARRAY) || (ar->flags & FIXED_SIZE_ARRAY))

	test	DWORD PTR [ecx], 268435456		; 10000000H
	jne	SHORT $LN896@makenode
	mov	edx, DWORD PTR _ar$90167[ebp]
	test	DWORD PTR [edx], 268435456		; 10000000H
	jne	SHORT $LN896@makenode

; 2377 :                g->attr.arrayptr->datastart = get_local(i).offset;
; 2378 :              }
; 2379 :              else
; 2380 :              { g->flags |= UNFIXED_SIZE_ARRAY;

	or	DWORD PTR [ebx+192], 536870912		; 20000000H
	jmp	$LN878@makenode
$LN896@makenode:

; 2358 :              { g->flags |= FIXED_SIZE_ARRAY;

	or	DWORD PTR [ebx+192], 268435456		; 10000000H

; 2359 :                g->attr.arrayptr->flags |= FIXED_SIZE_ARRAY;

	mov	eax, DWORD PTR [ebx+168]
	or	DWORD PTR [eax], 268435456		; 10000000H

; 2360 :                for ( i=0,size=1,pointercount=0 ; 
; 2361 :                  i + list[left].op5.indexcount < al->dim-1 ; i++ )

	xor	edx, edx
	mov	DWORD PTR _i$90169[ebp], edx
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR _pointercount$90171[ebp], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _list
	dec	edx
	cmp	DWORD PTR [esi+ecx+152], edx
	jge	SHORT $LN897@makenode
	mov	edx, DWORD PTR [esi+ecx+152]
	mov	ecx, DWORD PTR [ebx+168]
	mov	DWORD PTR tv11404[ebp], 24		; 00000018H
$LL894@makenode:

; 2362 :                { pointercount += size;
; 2363 :                  g->attr.arrayptr->sizes[i] =
; 2364 :                     al->sizes[list[left].op5.indexcount + i];

	mov	edi, DWORD PTR _al$90165[ebp]
	mov	edi, DWORD PTR [edi+edx*4+24]
	mov	edx, DWORD PTR tv11404[ebp]
	add	DWORD PTR _pointercount$90171[ebp], eax
	mov	DWORD PTR [edx+ecx], edi

; 2365 :                  size *= g->attr.arrayptr->sizes[i];

	mov	ecx, DWORD PTR [ebx+168]
	imul	eax, DWORD PTR [edx+ecx]
	mov	edi, DWORD PTR _i$90169[ebp]
	add	edx, 4
	inc	edi
	mov	DWORD PTR tv11404[ebp], edx
	mov	edx, DWORD PTR _list
	mov	edx, DWORD PTR [esi+edx+152]
	add	edx, edi
	mov	DWORD PTR _i$90169[ebp], edi
	mov	edi, DWORD PTR _al$90165[ebp]
	mov	edi, DWORD PTR [edi+4]
	dec	edi
	cmp	edx, edi
	jl	SHORT $LL894@makenode

; 2360 :                for ( i=0,size=1,pointercount=0 ; 
; 2361 :                  i + list[left].op5.indexcount < al->dim-1 ; i++ )

	mov	edi, DWORD PTR tv8548[ebp]
	mov	ecx, DWORD PTR _list
$LN897@makenode:

; 2366 :                }
; 2367 :                for ( j = 1 ; 
; 2368 :                  j + list[right].op5.indexcount < ar->dim ; j++,i++ )

	mov	edx, DWORD PTR [edi+ecx+152]
	mov	esi, DWORD PTR _ar$90167[ebp]
	inc	edx
	cmp	edx, DWORD PTR [esi+4]
	jge	SHORT $LN126@makenode
	mov	esi, DWORD PTR _i$90169[ebp]
	mov	edx, DWORD PTR [edi+ecx+152]
	mov	ecx, DWORD PTR [ebx+168]
	lea	esi, DWORD PTR [esi*4+24]
	inc	edx
	mov	DWORD PTR tv11427[ebp], 1
	mov	DWORD PTR tv11449[ebp], esi
	npad	6
$LL898@makenode:

; 2369 :                { pointercount += size;
; 2370 :                  g->attr.arrayptr->sizes[i] =
; 2371 :                     ar->sizes[list[right].op5.indexcount + j];

	mov	esi, DWORD PTR _ar$90167[ebp]
	mov	esi, DWORD PTR [esi+edx*4+24]
	mov	edx, DWORD PTR tv11449[ebp]
	add	DWORD PTR _pointercount$90171[ebp], eax
	mov	DWORD PTR [edx+ecx], esi

; 2372 :                  size *= g->attr.arrayptr->sizes[i];

	mov	ecx, DWORD PTR [ebx+168]
	imul	eax, DWORD PTR [edx+ecx]
	mov	esi, DWORD PTR _list
	mov	esi, DWORD PTR [edi+esi+152]
	add	edx, 4
	mov	DWORD PTR tv11449[ebp], edx
	mov	edx, DWORD PTR tv11427[ebp]
	inc	edx
	mov	DWORD PTR tv11427[ebp], edx
	add	edx, esi
	mov	esi, DWORD PTR _ar$90167[ebp]
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LL898@makenode
$LN126@makenode:

; 2373 :                }
; 2374 :                g->attr.arrayptr->datacount = size;
; 2375 :                i = add_local_var(NULL,size+pointercount);

	mov	edx, DWORD PTR _pointercount$90171[ebp]
	mov	ecx, DWORD PTR [ebx+168]
	add	edx, eax
	push	edx
	push	0
	mov	DWORD PTR [ecx+16], eax
	call	_add_local_var

; 2376 :                g = globals(temp_id);  // in case add_local_var reallocated

	mov	ecx, DWORD PTR tv9247[ebp]
	mov	edx, DWORD PTR _localbase
	add	esp, 8
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN732@makenode
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN734@makenode
	mov	ecx, DWORD PTR tv9249[ebp]
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	$LN709@makenode
$LN734@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN732@makenode
	mov	ecx, DWORD PTR _web+5656
	mov	esi, DWORD PTR tv9249[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	jmp	$LN709@makenode
$LN732@makenode:
	mov	esi, DWORD PTR tv9249[ebp]

; 2381 :              }
; 2382 :            }  // end temp array stuff
; 2383 :          }
; 2384 :          break;

	jmp	$LN938@makenode
$LN124@makenode:

; 2385 : 
; 2386 :     case ARRAY_ASSIGNOP_A_P_A_NODE: /* full array syntax, array plus array */
; 2387 :          check_readonly_attr(list[left].op2.name_id);

	mov	ecx, esi
	imul	ecx, 168				; 000000a8H
	mov	eax, DWORD PTR [ecx+eax+136]
	push	eax
	mov	DWORD PTR tv8511[ebp], ecx
	call	_check_readonly_attr

; 2388 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], ebx

; 2389 :          list[listtop].left = left-listtop;  /* lvalue array */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], esi

; 2390 :          list[listtop].right = right-listtop;  /* rvalue */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi

; 2391 :          list[listtop].op2.name_id = list[left].op2.name_id;

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	eax, DWORD PTR tv8511[ebp]
	mov	esi, DWORD PTR [eax+ecx+136]
	mov	DWORD PTR [edx+ecx+136], esi

; 2392 :          if ( check_recalc_attr(list[left].op2.name_id) )

	mov	esi, DWORD PTR _list
	mov	eax, DWORD PTR [eax+esi+136]

; 2393 :            list[listtop].flags |= RECALC_FLAG;
; 2394 :          if ( check_dont_resize_attr(list[left].op2.name_id) )
; 2395 :            list[listtop].flags |= DONT_RESIZE_FLAG;
; 2396 :          /* op1.assigntype will be set back in command.yac */
; 2397 :          list[listtop].stack_delta = -3;
; 2398 :          break;

	jmp	$LN944@makenode
$LN115@makenode:

; 2399 : 
; 2400 :     case ARRAY_ASSIGNOP_A_S_A_NODE: /* full array syntax, array subtract array */
; 2401 :          check_readonly_attr(list[left].op2.name_id);
; 2402 :          list[listtop].type = type;
; 2403 :          list[listtop].left = left-listtop;  /* lvalue array */
; 2404 :          list[listtop].right = right-listtop;  /* rvalue */
; 2405 :          list[listtop].op2.name_id = list[left].op2.name_id;
; 2406 :          if ( check_recalc_attr(list[left].op2.name_id) )
; 2407 :            list[listtop].flags |= RECALC_FLAG;
; 2408 :          if ( check_dont_resize_attr(list[left].op2.name_id) )
; 2409 :            list[listtop].flags |= DONT_RESIZE_FLAG;
; 2410 :          /* op1.assigntype will be set back in command.yac */
; 2411 :          list[listtop].stack_delta = -3;
; 2412 :          break;
; 2413 : 
; 2414 :      case ARRAY_ASSIGNOP_A_X_A_NODE: /* full array syntax, array multiplication */
; 2415 :           check_readonly_attr(list[left].op2.name_id);
; 2416 :           list[listtop].type = type;
; 2417 :           list[listtop].left = left-listtop;  /* lvalue array */
; 2418 :           list[listtop].right = right-listtop;  /* rvalue */
; 2419 :           list[listtop].op2.name_id = list[left].op2.name_id;
; 2420 :           if ( check_recalc_attr(list[left].op2.name_id) )
; 2421 :             list[listtop].flags |= RECALC_FLAG;
; 2422 :           if ( check_dont_resize_attr(list[left].op2.name_id) )
; 2423 :             list[listtop].flags |= DONT_RESIZE_FLAG;
; 2424 : 
; 2425 :           /* op1.assigntype will be set back in command.yac */
; 2426 :           list[listtop].stack_delta = -3;
; 2427 :           break;
; 2428 :    /* end whole-array syntax */
; 2429 : 
; 2430 :     case ARRAYASSIGN_NODE:
; 2431 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2432 :          list[listtop].left = left-listtop;  /* arrayhead */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi

; 2433 :          list[listtop].right = right-listtop;  /* rhs */
; 2434 :          list[listtop].op1.assigntype = assigntype;
; 2435 :          list[listtop].op2.name_id = list[left].op1.name_id; /* glob var number */

	imul	esi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx
	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	edx, DWORD PTR _assigntype
	mov	DWORD PTR [eax+ecx+32], edx
	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [esi+eax+32]
	mov	DWORD PTR [ecx+eax+136], edx

; 2436 : 
; 2437 :          g =  globals(list[left].op1.name_id);

	mov	edx, DWORD PTR _list
	mov	eax, DWORD PTR [esi+edx+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN738@makenode
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN740@makenode
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	mov	edi, eax
	jmp	SHORT $LN739@makenode
$LN740@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN738@makenode
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	edi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN739@makenode
$LN738@makenode:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	edi, DWORD PTR [eax+ecx]
$LN739@makenode:

; 2438 :          if ( list[left].op5.indexcount != g->attr.arrayptr->dim ) 

	mov	eax, DWORD PTR [edi+168]
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [esi+edx+152], eax
	je	SHORT $LN114@makenode

; 2439 :          { sprintf(errmsg,
; 2440 :               "Array %s has wrong number of dimensions; should be %d\n",
; 2441 :                  g->name,g->attr.arrayptr->dim);

	push	eax
	push	edi
	push	OFFSET ??_C@_0DH@BDIEAHJL@Array?5?$CFs?5has?5wrong?5number?5of?5dim@
	push	OFFSET _errmsg
	call	_sprintf

; 2442 :            kb_error(2226,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	2226					; 000008b2H
	call	_kb_error
	mov	edx, DWORD PTR _list
	add	esp, 28					; 0000001cH
$LN114@makenode:

; 2443 :          } 
; 2444 :          if ( g->flags & READONLY )

	test	DWORD PTR [edi+192], 8388608		; 00800000H
	je	SHORT $LN113@makenode

; 2445 :          { sprintf(errmsg, "Array %s is read-only.\n",g->name);

	push	edi
	push	OFFSET ??_C@_0BI@MJAAACDM@Array?5?$CFs?5is?5read?9only?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 2446 :            kb_error(2846,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	2846					; 00000b1eH
	call	_kb_error
	mov	edx, DWORD PTR _list
	add	esp, 24					; 00000018H
$LN113@makenode:

; 2447 :          }
; 2448 :          list[listtop].stack_delta = -list[left].op5.indexcount-1;

	mov	eax, DWORD PTR _listtop
	imul	eax, 168				; 000000a8H
	or	ecx, -1
	sub	ecx, DWORD PTR [esi+edx+152]
	mov	DWORD PTR [eax+edx+156], ecx

; 2449 :          if ( !(g->flags & PERMANENT) )

	test	BYTE PTR [edi+192], 16			; 00000010H
	jne	$LN878@makenode

; 2450 :            list[listtop].flags |= EPHEMERAL;
; 2451 : 
; 2452 :          break;

	jmp	$LN252@makenode
$LN111@makenode:

; 2453 : 
; 2454 : 
; 2455 :     case ARRAYEVAL_NODE:
; 2456 :        {
; 2457 :          g = globals(list[left].op1.name_id);

	mov	edi, esi
	imul	edi, 168				; 000000a8H
	mov	edx, DWORD PTR [edi+eax+32]
	mov	ecx, edx
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN744@makenode
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN746@makenode
	mov	ecx, DWORD PTR _localbase
	and	edx, 16777215				; 00ffffffH
	imul	edx, 224				; 000000e0H
	add	edx, DWORD PTR [ecx]
	jmp	SHORT $LN911@makenode
$LN746@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN744@makenode
	mov	ecx, DWORD PTR _web+5656
	and	edx, 16777215				; 00ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN911@makenode
$LN744@makenode:
	mov	ecx, DWORD PTR _web+5652
	and	edx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ecx]
$LN911@makenode:

; 2458 : 
; 2459 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2460 :          list[listtop].left = left-listtop;

	mov	eax, DWORD PTR _listtop
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR _g$[ebp], edx
	mov	edx, DWORD PTR _list
	mov	DWORD PTR [eax+edx+4], esi

; 2461 :          list[listtop].op2.name_id = list[left].op1.name_id;

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [edi+eax+32]
	mov	DWORD PTR [ecx+eax+136], edx

; 2462 :          list[listtop].flags |= EPHEMERAL;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	or	DWORD PTR [eax+ecx+24], 64		; 00000040H

; 2463 :          if ( list[left].op5.indexcount != g->attr.arrayptr->dim ) 

	mov	edx, DWORD PTR _g$[ebp]
	lea	eax, DWORD PTR [eax+ecx+24]
	mov	eax, DWORD PTR [edx+168]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _list
	cmp	DWORD PTR [edi+ecx+152], eax
	je	SHORT $LN903@makenode

; 2464 :          { sprintf(errmsg,
; 2465 :               "Array %s has wrong number of dimensions; should be %d\n",
; 2466 :                  g->name, g->attr.arrayptr->dim );

	push	eax
	push	edx
	push	OFFSET ??_C@_0DH@BDIEAHJL@Array?5?$CFs?5has?5wrong?5number?5of?5dim@
	push	OFFSET _errmsg
	call	_sprintf

; 2467 :            kb_error(2608,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	2608					; 00000a30H
	call	_kb_error
	mov	ecx, DWORD PTR _list
	add	esp, 28					; 0000001cH
$LN903@makenode:

; 2468 :          }
; 2469 :          list[listtop].stack_delta = -list[left].op5.indexcount+1;

	mov	eax, DWORD PTR _listtop
	imul	eax, 168				; 000000a8H
	mov	edx, 1
	sub	edx, DWORD PTR [edi+ecx+152]
	mov	DWORD PTR [eax+ecx+156], edx

; 2470 :          list[listtop].datatype = (g->type <= MAX_NUMERIC_TYPE) ? REAL_TYPE:
; 2471 :            g->type;

	mov	ecx, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR [ecx+200]
	cmp	eax, 10					; 0000000aH
	jg	SHORT $LN750@makenode
	mov	eax, 1
$LN750@makenode:
	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+ecx+20], eax

; 2472 :          break;

	jmp	$LN878@makenode
$LN88@makenode:

; 2539 :        }
; 2540 : 
; 2541 :     case SET_GLOBAL_NODE: 
; 2542 :     case PLUSASSIGN_NODE: case SUBASSIGN_NODE: case MULTASSIGN_NODE: case DIVASSIGN_NODE:
; 2543 :       {  
; 2544 :          struct global *g = globals(left);

	mov	ecx, esi
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN792@makenode
	mov	ecx, DWORD PTR _web+5652
	mov	edx, esi
	and	edx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx]
	jmp	SHORT $LN912@makenode
$LN792@makenode:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN790@makenode
	mov	edx, DWORD PTR _localbase
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN912@makenode
$LN790@makenode:
	cmp	ecx, 536870912				; 20000000H
	mov	ecx, esi
	jne	SHORT $LN788@makenode
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN912@makenode
$LN788@makenode:
	mov	edx, DWORD PTR _web+5652
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
$LN912@makenode:

; 2545 : 
; 2546 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 2547 :          list[listtop].op1.name_id = left; /* variable number */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+32], esi

; 2548 :          list[listtop].left = right - listtop;  /* value expression */

	mov	eax, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	mov	edx, edi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+esi+4], edx

; 2549 :          if ( !(g->flags & ANY_TYPE)  )

	mov	eax, DWORD PTR [ecx+192]
	mov	DWORD PTR _g$90255[ebp], ecx
	test	eax, 1990				; 000007c6H
	jne	SHORT $LN87@makenode

; 2550 :             g->flags |= ORDINARY_PARAM;

	or	eax, 1
	mov	DWORD PTR [ecx+192], eax
$LN87@makenode:

; 2551 :          if ( !(g->flags & (ORDINARY_PARAM|GLOB_LOCALVAR)) )

	test	DWORD PTR [ecx+192], 524289		; 00080001H
	jne	SHORT $LN86@makenode

; 2552 :          { sprintf(errmsg, "Variable %s is not proper type for left side of assignment.\n",g->name);

	mov	eax, DWORD PTR _g$90255[ebp]
	push	eax
	push	OFFSET ??_C@_0DN@FPHMDPLJ@Variable?5?$CFs?5is?5not?5proper?5type?5f@
	push	OFFSET _errmsg
	call	_sprintf

; 2553 :            kb_error(3021,errmsg,Q_ERROR);

	push	8
	push	OFFSET _errmsg
	push	3021					; 00000bcdH
	call	_kb_error
	mov	ecx, DWORD PTR _g$90255[ebp]
	add	esp, 24					; 00000018H
$LN86@makenode:

; 2554 :          }
; 2555 :          if ( perm_flag ) g->flags |= PERMANENT;

	cmp	DWORD PTR _perm_flag, 0
	je	SHORT $LN85@makenode
	or	DWORD PTR [ecx+192], 16			; 00000010H
$LN85@makenode:

; 2556 :          list[listtop].flags |= EPHEMERAL;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	or	DWORD PTR [edx+eax+24], 64		; 00000040H
	lea	eax, DWORD PTR [edx+eax+24]

; 2557 :          list[listtop].stack_delta = -1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H

; 2558 :          g->type = list[right].datatype;

	imul	edi, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], -1
	mov	edx, DWORD PTR _list
	mov	eax, DWORD PTR [edi+edx+20]
	mov	DWORD PTR [ecx+200], eax

; 2559 :          break;

	jmp	$LN878@makenode
$LN84@makenode:

; 2560 :       }
; 2561 : 
; 2562 :     case POST_INCREMENT_NODE:
; 2563 :     case PRE_INCREMENT_NODE:
; 2564 :       {  
; 2565 :          struct global *g = globals(left);

	mov	ecx, esi
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN794@makenode
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN796@makenode
	mov	edx, DWORD PTR _localbase
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN913@makenode
$LN796@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN794@makenode
	mov	edx, DWORD PTR _web+5656
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN913@makenode
$LN794@makenode:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
$LN913@makenode:

; 2566 : 
; 2567 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 2568 :          list[listtop].op1.name_id = left; /* variable number */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+32], esi

; 2569 :          list[listtop].op2.assigntype = right;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+136], edi

; 2570 :          if ( !(g->flags & ANY_TYPE)  )

	mov	eax, DWORD PTR [ecx+192]
	mov	DWORD PTR _g$90263[ebp], ecx
	test	eax, 1990				; 000007c6H
	jne	SHORT $LN83@makenode

; 2571 :             g->flags |= ORDINARY_PARAM;

	or	eax, 1
	mov	DWORD PTR [ecx+192], eax
$LN83@makenode:

; 2572 :          if ( !(g->flags & (ORDINARY_PARAM|GLOB_LOCALVAR)) )

	test	DWORD PTR [ecx+192], 524289		; 00080001H
	jne	SHORT $LN82@makenode

; 2573 :          { sprintf(errmsg, "Variable %s is not proper type for assignment.\n",g->name);

	mov	eax, DWORD PTR _g$90263[ebp]
	push	eax
	push	OFFSET ??_C@_0DA@JJBDKLNJ@Variable?5?$CFs?5is?5not?5proper?5type?5f@
	push	OFFSET _errmsg
	call	_sprintf

; 2574 :            kb_error(1944,errmsg,Q_ERROR);

	push	8
	push	OFFSET _errmsg
	push	1944					; 00000798H
	call	_kb_error
	mov	ecx, DWORD PTR _g$90263[ebp]
	add	esp, 24					; 00000018H
$LN82@makenode:

; 2575 :          }
; 2576 :          if ( perm_flag ) g->flags |= PERMANENT;

	cmp	DWORD PTR _perm_flag, 0
	je	$LN252@makenode
	or	DWORD PTR [ecx+192], 16			; 00000010H

; 2577 :          list[listtop].flags |= EPHEMERAL;
; 2578 :          break;

	jmp	$LN252@makenode
$LN80@makenode:

; 2579 :       }
; 2580 : 
; 2581 :     case SET_PERM_GLOBAL_NODE: 
; 2582 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop

; 2583 :          list[listtop].op1.name_id = left; /* variable number */
; 2584 :          list[listtop].left = right - listtop;  /* value expression */
; 2585 :          perm_globals(left)->flags |= ORDINARY_PARAM;
; 2586 :          perm_globals(left)->attr.varstuff.delta = OPTPARAM_DELTA;

	fld	QWORD PTR __real@3f1a36e2eb1c432d
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], esi
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edi
	mov	edx, DWORD PTR _web+5656
	and	esi, 16777215				; 00ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	or	DWORD PTR [eax+192], 1
	mov	eax, DWORD PTR _web+5656
	mov	ecx, DWORD PTR [esi+eax]
	fstp	QWORD PTR [ecx+168]

; 2587 :          perm_globals(left)->attr.varstuff.pscale = 1.0;

	mov	edx, DWORD PTR _web+5656
	fld1
	mov	eax, DWORD PTR [esi+edx]
	fstp	QWORD PTR [eax+176]

; 2588 :          list[listtop].stack_delta = -1;
; 2589 :          break;

	jmp	$LN257@makenode
$LN3@makenode:

; 2939 : 
; 2940 :     case HELP_KEYWORD_NODE:
; 2941 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2942 :          list[listtop].op1.string = 
; 2943 :             (char*)mycalloc(strlen(yytext)+1,sizeof(char));

	mov	eax, DWORD PTR _yytext
	lea	edx, DWORD PTR [eax+1]
$LL870@makenode:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL870@makenode
	push	2943					; 00000b7fH
	sub	eax, edx
	push	OFFSET ??_C@_0L@OKHAMMPH@YEXPARSE?4C?$AA@
	inc	eax
	push	1
	push	eax
	call	_kb_calloc
	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+ecx+32], eax

; 2944 :          list[listtop].flags |= HAS_STRING;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	or	DWORD PTR [edx+eax+24], 32		; 00000020H

; 2945 :          strcpy(list[listtop].op1.string,yytext);

	mov	ecx, DWORD PTR _yytext
	lea	eax, DWORD PTR [edx+eax+24]
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	add	esp, 16					; 00000010H
	imul	edx, 168				; 000000a8H
	mov	edx, DWORD PTR [edx+eax+32]
$LL819@makenode:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL819@makenode

; 2946 :          list[listtop].datatype = STRING_TYPE;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+20], 11		; 0000000bH

; 2947 :          break;

	jmp	$LN878@makenode
$LN572@makenode:

; 269  : 
; 270  :       case NOP_NODE:
; 271  :          list[listtop].type = NOP_NODE;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], 10475		; 000028ebH

; 272  :          break;

	jmp	$LN878@makenode
$LN821@makenode:

; 260  :   switch ( type )

	cmp	edx, 10650				; 0000299aH
	jg	$LN822@makenode
	je	$LN464@makenode
	sub	edx, 10476				; 000028ecH
	cmp	edx, 173				; 000000adH
	ja	$LN2@makenode
	movzx	edx, BYTE PTR $LN871@makenode[edx]
	jmp	DWORD PTR $LN953@makenode[edx*4]
$LN574@makenode:

; 261  :   {
; 262  :       case NULLBLOCK_NODE:
; 263  :          list[listtop].type = NULLBLOCK_NODE;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], 10476		; 000028ecH

; 264  :          break;

	jmp	$LN878@makenode
$LN573@makenode:

; 265  : 
; 266  :       case NULLCMD_NODE:
; 267  :          list[listtop].type = NULLCMD_NODE;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10477		; 000028edH

; 268  :          break;

	jmp	$LN878@makenode
$LN545@makenode:

; 436  : 
; 437  :       case DEFINE_EXTRA_NODE: /* new element attribute */
; 438  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 439  :          if ( left ) list[listtop].left = left-listtop; /* dimension expression */

	test	esi, esi
	je	SHORT $LN544@makenode
	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi
$LN544@makenode:

; 440  :          list[listtop].op2.eltype = right; /* element type */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+136], edi

; 441  :          break;

	jmp	$LN878@makenode
$LN543@makenode:

; 442  : 
; 443  :       case DEFINE_EXTRA_INDEX_NODE:  /* index added to extra attribute */
; 444  :        { struct extra *ex;
; 445  :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 446  :          list[listtop].left = left-listtop;  /* definition header */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, esi

; 447  :          list[listtop].right = right-listtop;  /* indexset expression */
; 448  :          list[listtop].op1.extranum = list[left].op1.extranum; 

	imul	esi, 168				; 000000a8H
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx
	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, edi
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], ecx
	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [esi+eax+32]
	mov	DWORD PTR [ecx+eax+32], edx

; 449  :          list[listtop].op2.eltype = list[left].op2.eltype; 

	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [ecx+eax+136], edx

; 450  :          ex = EXTRAS(list[left].op2.eltype) + list[left].op1.extranum;

	mov	eax, DWORD PTR _list
	mov	ecx, DWORD PTR [esi+eax+136]
	mov	edx, DWORD PTR [esi+eax+32]
	imul	ecx, 112				; 00000070H
	mov	esi, DWORD PTR _web[ecx+104]
	imul	edx, 240				; 000000f0H
	add	esi, edx
	add	esi, DWORD PTR _dymem

; 451  :          if ( (ex->array_spec.datacount > 0) && (ex->array_spec.dim != list[right].op5.indexcount) )

	cmp	DWORD PTR [esi+88], 0
	jle	SHORT $LN542@makenode
	mov	edx, DWORD PTR [esi+76]
	mov	ecx, edi
	imul	ecx, 168				; 000000a8H
	cmp	edx, DWORD PTR [ecx+eax+152]
	je	SHORT $LN542@makenode

; 452  :          { sprintf(errmsg,"Cannot change number of dimensions of %s\n",
; 453  :                 ex->name);

	push	esi
	push	OFFSET ??_C@_0CK@OOLAKBHI@Cannot?5change?5number?5of?5dimensio@
	push	OFFSET _errmsg
	call	_sprintf

; 454  :            kb_error(4562,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	4562					; 000011d2H
	call	_kb_error
	mov	eax, DWORD PTR _list
	add	esp, 24					; 00000018H
$LN542@makenode:

; 455  :          }
; 456  :          ex->array_spec.dim = list[right].op5.indexcount;

	imul	edi, 168				; 000000a8H
	mov	eax, DWORD PTR [edi+eax+152]

; 457  :          ex->flags |= DIMENSIONED_ATTR;

	or	DWORD PTR [esi+232], 4
	mov	DWORD PTR [esi+76], eax

; 458  :          list[listtop].stack_delta = -ex->array_spec.dim;

	mov	ecx, eax
$LN928@makenode:
	mov	eax, DWORD PTR _list
$LN945@makenode:
	neg	ecx
$LN942@makenode:
	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], ecx

; 459  :        }
; 460  :        break;

	jmp	$LN878@makenode
$LN504@makenode:

; 654  : 
; 655  : 
; 656  : /* >> redirection tree:     REDIRECT_END_
; 657  :                              /        \
; 658  :                         REDIRECT_     command
; 659  :                         /
; 660  :                      stringexpr
; 661  : 
; 662  : execution sequence: stringexpr REDIRECT_ command REDIRECT_END_
; 663  : */
; 664  :       case REDIRECT_NODE: /* >> */
; 665  :       case REDIRECTOVER_NODE: /* >>> */
; 666  :          list[listtop].type = type;
; 667  :          list[listtop].left = left - listtop; /* stringexpr */
; 668  :          break;
; 669  : 
; 670  :       case REDIRECT_END_NODE:
; 671  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 672  :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 673  :          if ( right ) 

	test	edi, edi
	je	$LN512@makenode

; 674  :            list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edi

; 675  :          list[listtop].stack_delta = -1;      
; 676  :          break;

	jmp	$LN512@makenode
$LN499@makenode:

; 677  : 
; 678  :       case REDIRECT_ERR_NODE: /* >> */
; 679  :       case REDIRECTOVER_ERR_NODE: /* >>> */
; 680  :          list[listtop].type = type;
; 681  :          list[listtop].left = left - listtop; /* stringexpr */
; 682  :          break;
; 683  : 
; 684  :       case REDIRECT_ERR_END_NODE:
; 685  :          list[listtop].type = type;
; 686  :          list[listtop].left = left - listtop;
; 687  :          if ( right ) 
; 688  :            list[listtop].right = right - listtop;
; 689  :          list[listtop].stack_delta = -1;      
; 690  :          break;
; 691  : 
; 692  : /* piping tree:      PIPE_END_
; 693  :                     /        \
; 694  :                 PIPE_     command
; 695  :                 /
; 696  :              stringexpr
; 697  : 
; 698  : execution sequence: stringexpr PIPE_ command PIPE_END_
; 699  : */
; 700  :       case PIPE_NODE:
; 701  :          list[listtop].type = PIPE_NODE;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], 10487		; 000028f7H

; 702  :          list[listtop].left = left - listtop; /* command */
; 703  :          break;

	jmp	$LN926@makenode
$LN495@makenode:

; 704  : 
; 705  :       case PIPE_END_NODE:
; 706  :          list[listtop].type = type;
; 707  :          list[listtop].left = left - listtop;
; 708  :          if ( right ) list[listtop].right = right - listtop;
; 709  :          list[listtop].stack_delta = -1;
; 710  :          break;
; 711  : 
; 712  :       case TRANSFORM_DEPTH_NODE:
; 713  :          list[listtop].type = type;
; 714  :          list[listtop].left = left - listtop;    /* number of transforms */
; 715  :          list[listtop].stack_delta = -1;
; 716  :          break;
; 717  : 
; 718  :       case VIEW_TRANSFORM_PARITY_NODE:
; 719  :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 720  :          list[listtop].left = left - listtop;    /* index of transform */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], esi

; 721  :          list[listtop].datatype = REAL_TYPE;
; 722  :          break;

	jmp	$LN924@makenode
$LN494@makenode:

; 723  : 
; 724  :       case VIEW_TRANSFORM_SWAP_COLORS_NODE:
; 725  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 726  :          list[listtop].left = left - listtop;    /* index of transform */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi
$LN931@makenode:

; 727  :          list[listtop].datatype = REAL_TYPE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+20], 1

; 728  :          break;

	jmp	$LN878@makenode
$LN283@makenode:

; 1394 :  
; 1395 :       case RITZ_NODE:
; 1396 :          list[listtop].type = type;
; 1397 :          list[listtop].left = left - listtop;
; 1398 :          list[listtop].right = right - listtop;
; 1399 :          list[listtop].stack_delta = -2;
; 1400 :          break;
; 1401 : 
; 1402 :       case WRAP_VERTEX_NODE:
; 1403 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 1404 :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], esi
$LN933@makenode:

; 1405 :          list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi

; 1406 :          list[listtop].stack_delta = -2;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+156], -2		; fffffffeH

; 1407 :          break;

	jmp	$LN878@makenode
$LN280@makenode:

; 1419 : 
; 1420 :       case HESSIAN_SADDLE_NODE:
; 1421 :       case HESSIAN_SEEK_NODE:
; 1422 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 1423 :          if ( left ) 

	test	esi, esi
	je	$LN878@makenode
$LN940@makenode:

; 1424 :          { list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], esi

; 1425 :            list[listtop].stack_delta = -1;
; 1426 :          }     
; 1427 :          break;

	jmp	$LN512@makenode
$LN245@makenode:

; 1608 : 
; 1609 :    
; 1610 :     case PRINT_ARRAY_LVALUE_NODE:
; 1611 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 1612 :          list[listtop].left = left-listtop;  /* arraylvalue */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, esi

; 1613 :          list[listtop].op2.name_id = list[left].op2.name_id;

	imul	esi, 168				; 000000a8H
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx
	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [esi+eax+136]
	mov	DWORD PTR [ecx+eax+136], edx

; 1614 :          list[listtop].stack_delta = -1;
; 1615 :          break;

	jmp	$LN921@makenode
$LN244@makenode:

; 1616 : 
; 1617 :     case PRINT_ARRAYPART_NODE:
; 1618 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 1619 :          list[listtop].left = left-listtop;  /* arrayhead */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, esi

; 1620 :          list[listtop].op5.indexcount = list[left].op5.indexcount;

	imul	esi, 168				; 000000a8H
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx
	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [esi+eax+152]
	mov	DWORD PTR [ecx+eax+152], edx

; 1621 :          list[listtop].flags |= EPHEMERAL;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	or	DWORD PTR [eax+ecx+24], 64		; 00000040H

; 1622 :          list[listtop].stack_delta = -list[listtop].op5.indexcount;

	mov	edx, DWORD PTR _listtop
	lea	eax, DWORD PTR [eax+ecx+24]
	imul	edx, 168				; 000000a8H
	mov	eax, DWORD PTR _list
	mov	ecx, DWORD PTR [eax+edx+152]
	neg	ecx
	mov	DWORD PTR [eax+edx+156], ecx

; 1623 :          break;

	jmp	$LN878@makenode
$LN822@makenode:

; 260  :   switch ( type )

	cmp	edx, 20001				; 00004e21H
	jg	$LN823@makenode
	je	$LN219@makenode
	sub	edx, 10651				; 0000299bH
	cmp	edx, 111				; 0000006fH
	ja	$LN2@makenode
	movzx	edx, BYTE PTR $LN872@makenode[edx]
	jmp	DWORD PTR $LN954@makenode[edx*4]
$LN571@makenode:

; 273  : 
; 274  :       case SUPPRESS_WARNING_NODE:
; 275  :       case UNSUPPRESS_WARNING_NODE:
; 276  :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx
$LN920@makenode:

; 277  :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi
$LN921@makenode:

; 278  :          list[listtop].stack_delta = -1;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+156], -1

; 279  :          break;

	jmp	$LN878@makenode
$LN561@makenode:

; 349  : 
; 350  :       case ELSE_NODE: /* really the continue node at root of IF tree */
; 351  :          list[listtop].type = ELSE_NODE;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10760		; 00002a08H

; 352  :          list[listtop].left = left - listtop; /* IF_ node */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, esi
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx

; 353  :          if ( right ) list[listtop].right = right - listtop; /* command2 */

	test	edi, edi
	je	$LN560@makenode

; 354  :          list[left].op1.skipsize = listtop - left; /* in IF_ node */
; 355  :          break;

	jmp	$LN925@makenode
$LN557@makenode:

; 368  : 
; 369  :       case SET_NO_DUMP_NODE:
; 370  :          list[listtop].type = SET_NO_DUMP_NODE;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], 10654		; 0000299eH

; 371  :          list[listtop].op1.name_id = left;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], esi
$LN14@makenode:

; 372  :          list[listtop].op2.intval = right;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+136], edi

; 373  :          break;

	jmp	$LN878@makenode
$LN282@makenode:

; 1408 : 
; 1409 :       case LANCZOS_NODE:
; 1410 :       case EIGENPROBE_NODE:
; 1411 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1412 :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 1413 :          list[listtop].stack_delta = -1;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+156], -1

; 1414 :          if ( right ) 

	test	edi, edi
	je	$LN878@makenode

; 1415 :          { list[listtop].right = right - listtop;
; 1416 :            list[listtop].stack_delta = -2;
; 1417 :          }
; 1418 :          break;

	jmp	$LN933@makenode
$LN278@makenode:

; 1428 : 
; 1429 :       case MOVE_NODE:
; 1430 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 1431 :          list[listtop].left = left - listtop;
; 1432 :          list[listtop].stack_delta = -1;
; 1433 :          break;

	jmp	$LN940@makenode
$LN275@makenode:

; 1434 : 
; 1435 :       case AREAWEED_NODE:
; 1436 :          list[listtop].type = type;
; 1437 :          list[listtop].left = left - listtop;
; 1438 :          list[listtop].stack_delta = -1;
; 1439 :          break;
; 1440 : 
; 1441 :       case METIS_NODE:
; 1442 :       case METIS_READJUST_NODE:
; 1443 :       case KMETIS_NODE:
; 1444 :       case BODY_METIS_NODE:
; 1445 :          list[listtop].type = type;
; 1446 :          list[listtop].left = left - listtop;
; 1447 :          list[listtop].stack_delta = -1;
; 1448 :          break;
; 1449 : 
; 1450 :       case OMETIS_NODE:
; 1451 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1452 :          if ( left )

	test	esi, esi
	je	$LN878@makenode

; 1453 :          {  list[listtop].left = left - listtop;
; 1454 :             list[listtop].stack_delta = -1;
; 1455 :          }
; 1456 :          break;

	jmp	$LN920@makenode
$LN269@makenode:

; 1457 : 
; 1458 :       case EDGEWEED_NODE:
; 1459 :          list[listtop].type = type;
; 1460 :          list[listtop].left = left - listtop;
; 1461 :          list[listtop].stack_delta = -1;
; 1462 :          break;
; 1463 : 
; 1464 :       case EDGEDIVIDE_NODE:
; 1465 :          list[listtop].type = type;
; 1466 :          list[listtop].left = left - listtop;
; 1467 :          list[listtop].stack_delta = -1;
; 1468 :          break;
; 1469 : 
; 1470 :     case HISTORY_NODE:
; 1471 :          list[listtop].type = type;
; 1472 :          break;
; 1473 :      
; 1474 :     case LAGRANGE_NODE:
; 1475 :          list[listtop].type = type;
; 1476 :          list[listtop].left = left-listtop; /* degree approximation */
; 1477 :          list[listtop].stack_delta = -1;
; 1478 :          break;
; 1479 :      
; 1480 :     case BURCHARD_NODE:
; 1481 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 1482 :          list[listtop].op1.maxsteps = left; /* number of steps */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+32], esi

; 1483 :          break;

	jmp	$LN878@makenode
$LN268@makenode:

; 1484 :      
; 1485 :     case ZOOM_NODE:
; 1486 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 1487 :          if ( left )

	test	esi, esi
	je	SHORT $LN267@makenode

; 1488 :          {  list[listtop].left = left - listtop; /* vertex number */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], esi

; 1489 :             list[listtop].stack_delta = -1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], -1
$LN267@makenode:

; 1490 :          }
; 1491 :          if ( right ) 

	test	edi, edi
	je	$LN878@makenode

; 1492 :          {  list[listtop].left = right - listtop;  /* radius expression */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edi

; 1493 :             list[listtop].stack_delta += -1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	dec	DWORD PTR [edx+eax+156]
	lea	eax, DWORD PTR [edx+eax+156]

; 1494 :          }
; 1495 :          break;

	jmp	$LN878@makenode
$LN265@makenode:

; 1496 :      
; 1497 :     case SET_GRAVITY_NODE: 
; 1498 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1499 :          list[listtop].left = left - listtop;  /* value expression */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 1500 :          list[listtop].op1.assigntype = assigntype;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	edx, DWORD PTR _assigntype
	mov	DWORD PTR [eax+ecx+32], edx

; 1501 :          list[listtop].stack_delta = -1;
; 1502 :          break;

	jmp	$LN921@makenode
$LN243@makenode:

; 1624 : 
; 1625 :     case PRINT_ARRAY_NODE:
; 1626 :     case PRINT_PROCEDURE_NODE:
; 1627 :     case EXPRINT_PROCEDURE_NODE:
; 1628 :     case PRINT_LETTER_NODE:
; 1629 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 1630 :          list[listtop].op1.name_id = left;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+32], esi

; 1631 :          list[listtop].flags |= EPHEMERAL;
; 1632 :          break;

	jmp	$LN567@makenode
$LN242@makenode:

; 1633 : 
; 1634 :     case PRINT_PERM_PROCEDURE_NODE:
; 1635 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1636 :          list[listtop].op1.name_id = left;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], esi

; 1637 :          break;

	jmp	$LN878@makenode
$LN203@makenode:

; 1891 : 
; 1892 :     case DEFINE_IDENT_NODE:
; 1893 :        { struct global *g = globals(left);

	mov	ecx, esi
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN680@makenode
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN682@makenode
	mov	edx, DWORD PTR _localbase
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN681@makenode
$LN682@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN680@makenode
	mov	edx, DWORD PTR _web+5656
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN681@makenode
$LN680@makenode:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
$LN681@makenode:

; 1894 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 1895 :          list[listtop].op1.name_id = left; /* variable number */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+32], esi

; 1896 :          list[listtop].op2.valtype = right; /* type */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+136], edi

; 1897 :          g->type = right;

	mov	DWORD PTR [ecx+200], edi

; 1898 :          if ( right == STRING_TYPE ) g->flags |= STRINGVAL;

	cmp	edi, 11					; 0000000bH
	jne	SHORT $LN202@makenode
	or	DWORD PTR [ecx+192], 8192		; 00002000H
	jmp	$LN878@makenode
$LN202@makenode:

; 1899 :          else if ( !(g->flags & ANY_TYPE)  )

	mov	eax, DWORD PTR [ecx+192]
	test	eax, 1990				; 000007c6H
	jne	$LN878@makenode

; 1900 :          { g->flags |= ORDINARY_PARAM;
; 1901 :            list[listtop].flags |= EPHEMERAL;
; 1902 :            g->attr.varstuff.delta = OPTPARAM_DELTA;

	fld	QWORD PTR __real@3f1a36e2eb1c432d
	or	eax, 1
	mov	DWORD PTR [ecx+192], eax
	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	or	DWORD PTR [eax+edx+24], 64		; 00000040H
	lea	eax, DWORD PTR [eax+edx+24]
	fstp	QWORD PTR [ecx+168]

; 1903 :            g->attr.varstuff.pscale = 1.0;

	fld1
	fstp	QWORD PTR [ecx+176]

; 1904 :          }
; 1905 :          break;

	jmp	$LN878@makenode
$LN199@makenode:

; 1906 :        }
; 1907 :        
; 1908 :     case DEFINE_ARRAY_NODE:
; 1909 :        { struct global *g = globals(left);

	mov	ecx, esi
	and	ecx, -16777216				; ff000000H
	mov	DWORD PTR tv8520[ebp], ecx
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN686@makenode
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN688@makenode
	mov	edx, DWORD PTR _localbase
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	mov	DWORD PTR tv8522[ebp], ecx
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN914@makenode
$LN688@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN686@makenode
	mov	edx, DWORD PTR _web+5656
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	mov	DWORD PTR tv8522[ebp], ecx
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN914@makenode
$LN686@makenode:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	mov	DWORD PTR tv8522[ebp], ecx
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
$LN914@makenode:

; 1910 :          int datatype = int_val; /* kludge due to shortage of arguments */

	mov	edx, DWORD PTR _int_val
	mov	DWORD PTR _datatype$90029[ebp], edx

; 1911 :          int dim = list[right].op5.indexcount;

	mov	edx, edi
	imul	edx, 168				; 000000a8H

; 1912 :          int datastart;
; 1913 : 
; 1914 :          if ( g->flags & ORDINARY_PARAM )

	test	BYTE PTR [ecx+192], 1
	mov	eax, DWORD PTR [edx+eax+152]
	mov	DWORD PTR _g$90026[ebp], ecx
	mov	DWORD PTR tv8548[ebp], edx
	mov	DWORD PTR _dim$90030[ebp], eax
	je	SHORT $LN889@makenode

; 1915 :          { sprintf(errmsg,
; 1916 :              "Illegal to convert ordinary variable \"%s\" into array.\n",
; 1917 :                g->name); 

	push	ecx
	push	OFFSET ??_C@_0DH@IOIJAIMG@Illegal?5to?5convert?5ordinary?5vari@
	push	OFFSET _errmsg
	call	_sprintf

; 1918 :            kb_error(3289,errmsg,Q_ERROR);

	push	8
	push	OFFSET _errmsg
	push	3289					; 00000cd9H
	call	_kb_error
	mov	ecx, DWORD PTR _g$90026[ebp]
	add	esp, 24					; 00000018H
$LN889@makenode:

; 1919 :          }
; 1920 : 
; 1921 :          if ( g->flags & FIXED_SIZE_ARRAY )

	test	DWORD PTR [ecx+192], 268435456		; 10000000H
	je	SHORT $LN197@makenode

; 1922 :          { sprintf(errmsg,"Cannot re-declare a local fixed-size array %s.\n",
; 1923 :                g->name);

	mov	edx, DWORD PTR _g$90026[ebp]
	push	edx
	push	OFFSET ??_C@_0DA@PDJBPEDI@Cannot?5re?9declare?5a?5local?5fixed?9@
	push	OFFSET _errmsg
	call	_sprintf

; 1924 :            kb_error(3176,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	3176					; 00000c68H
	call	_kb_error
	mov	ecx, DWORD PTR _g$90026[ebp]
	add	esp, 24					; 00000018H
$LN197@makenode:

; 1925 :          }
; 1926 : 
; 1927 :          if ( dim > MAXARRAYDIMS )

	cmp	DWORD PTR _dim$90030[ebp], 8
	jle	SHORT $LN196@makenode

; 1928 :          { sprintf(errmsg,
; 1929 :                 "Maximum number of array dimensions is %d; %s has %d.\n",
; 1930 :                    MAXARRAYDIMS,g->name,dim);

	mov	eax, DWORD PTR _dim$90030[ebp]
	mov	ecx, DWORD PTR _g$90026[ebp]
	push	eax
	push	ecx
	push	8
	push	OFFSET ??_C@_0DG@DFGHPACG@Maximum?5number?5of?5array?5dimensio@
	push	OFFSET _errmsg
	call	_sprintf

; 1931 :            kb_error(3177,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	3177					; 00000c69H
	call	_kb_error
	mov	ecx, DWORD PTR _g$90026[ebp]
	add	esp, 32					; 00000020H
$LN196@makenode:

; 1932 :          }
; 1933 :          
; 1934 :          if ( g->type && (g->type != datatype ) )

	mov	eax, DWORD PTR [ecx+200]
	test	eax, eax
	je	SHORT $LN890@makenode
	cmp	eax, DWORD PTR _datatype$90029[ebp]
	je	SHORT $LN890@makenode

; 1935 :          { sprintf(errmsg,"Cannot change type of array %s.\n",g->name);

	mov	edx, DWORD PTR _g$90026[ebp]
	push	edx
	push	OFFSET ??_C@_0CB@FMOFCBKA@Cannot?5change?5type?5of?5array?5?$CFs?4?6@
	push	OFFSET _errmsg
	call	_sprintf

; 1936 :            kb_error(4984,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	4984					; 00001378H
	call	_kb_error
	mov	ecx, DWORD PTR _g$90026[ebp]
	add	esp, 24					; 00000018H
$LN890@makenode:

; 1937 :          }
; 1938 :          if ( !g->attr.arrayptr )

	cmp	DWORD PTR [ecx+168], 0
	jne	SHORT $LN194@makenode

; 1939 :            g->attr.arrayptr = (struct array*)mycalloc(1,sizeof(struct array));

	push	1939					; 00000793H
	push	OFFSET ??_C@_0L@OKHAMMPH@YEXPARSE?4C?$AA@
	push	56					; 00000038H
	push	1
	call	_kb_calloc
	mov	ecx, DWORD PTR _g$90026[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx+168], eax
$LN194@makenode:

; 1940 :          g->type = datatype;

	mov	eax, DWORD PTR _datatype$90029[ebp]

; 1941 :          g->attr.arrayptr->datatype = datatype;    // set when executed; oops, that does't work

	mov	edx, DWORD PTR [ecx+168]
	mov	DWORD PTR [ecx+200], eax
	mov	DWORD PTR [edx+8], eax

; 1942 :          g->attr.arrayptr->itemsize = datatype_size[datatype];

	mov	eax, DWORD PTR _datatype_size[eax*4]
	mov	edx, DWORD PTR [ecx+168]
	mov	DWORD PTR [edx+12], eax

; 1943 :          g->attr.arrayptr->dim = dim;

	mov	eax, DWORD PTR _dim$90030[ebp]
	mov	edx, DWORD PTR [ecx+168]
	mov	DWORD PTR [edx+4], eax

; 1944 :          
; 1945 :          g->flags |= ARRAY_PARAM;
; 1946 :          g->flags &= ~ORDINARY_PARAM;

	mov	eax, DWORD PTR [ecx+192]
	and	eax, -2					; fffffffeH
	or	eax, 2048				; 00000800H
	mov	DWORD PTR tv10982[ebp], eax
	mov	DWORD PTR [ecx+192], eax

; 1947 :    
; 1948 :          /* see if fixed-sized local array, so we can allocate stack space */
; 1949 :          if ( g->flags & GLOB_LOCALVAR && !(g->flags & UNFIXED_SIZE_ARRAY) )

	test	eax, 524288				; 00080000H
	je	$LN183@makenode
	test	eax, 536870912				; 20000000H
	jne	$LN183@makenode

; 1950 :          { /* test previous nodes for fixed sizes */
; 1951 :            int cantflag = 0; /* set if not fixed sizes */
; 1952 :            int indexset_node = right;
; 1953 :            int rexpr_node=0;
; 1954 :            int i;
; 1955 :            for ( i = dim-1 ; i >= 0 ; i-- )

	mov	edx, DWORD PTR _dim$90030[ebp]
	dec	edx
	mov	DWORD PTR _indexset_node$90045[ebp], edi
	mov	DWORD PTR _rexpr_node$90046[ebp], 0
	mov	DWORD PTR tv9525[ebp], edx
	mov	DWORD PTR _i$90047[ebp], edx
	js	SHORT $LN863@makenode
	mov	eax, edi
	npad	7
$LL891@makenode:

; 1956 :            { rexpr_node = indexset_node + 
; 1957 :                (i ? list[indexset_node].right : list[indexset_node].left);

	imul	eax, 168				; 000000a8H
	add	eax, DWORD PTR _list
	mov	DWORD PTR tv9529[ebp], eax
	test	edx, edx
	je	SHORT $LN692@makenode
	mov	eax, DWORD PTR [eax+8]
	jmp	SHORT $LN693@makenode
$LN692@makenode:
	mov	eax, DWORD PTR [eax+4]
$LN693@makenode:
	add	eax, DWORD PTR _indexset_node$90045[ebp]

; 1958 :              if ( list[rexpr_node].type != PUSHCONST_NODE )

	mov	edx, DWORD PTR _list
	mov	DWORD PTR _rexpr_node$90046[ebp], eax
	imul	eax, 168				; 000000a8H
	cmp	DWORD PTR [eax+edx], 10095		; 0000276fH
	jne	$LN188@makenode

; 1959 :              { cantflag = 1;
; 1960 :                break;
; 1961 :              }
; 1962 :              indexset_node += list[indexset_node].left;

	mov	eax, DWORD PTR _indexset_node$90045[ebp]
	mov	edx, DWORD PTR tv9529[ebp]
	add	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$90047[ebp]
	dec	edx
	mov	DWORD PTR _indexset_node$90045[ebp], eax
	mov	DWORD PTR _i$90047[ebp], edx
	jns	SHORT $LL891@makenode

; 1950 :          { /* test previous nodes for fixed sizes */
; 1951 :            int cantflag = 0; /* set if not fixed sizes */
; 1952 :            int indexset_node = right;
; 1953 :            int rexpr_node=0;
; 1954 :            int i;
; 1955 :            for ( i = dim-1 ; i >= 0 ; i-- )

	mov	eax, DWORD PTR tv10982[ebp]
$LN863@makenode:

; 1963 :            }
; 1964 : 
; 1965 :            if ( cantflag == 0 )
; 1966 :            { int datacount = 1; 
; 1967 :              int pointercount = 1; 
; 1968 :              g->flags |= FIXED_SIZE_ARRAY;

	or	eax, 268435456				; 10000000H
	mov	DWORD PTR [ecx+192], eax

; 1969 :              g->attr.arrayptr->flags |= FIXED_SIZE_ARRAY;

	mov	eax, DWORD PTR [ecx+168]
	or	DWORD PTR [eax], 268435456		; 10000000H

; 1970 :              g->attr.arrayptr->datatype = g->type = datatype;

	mov	eax, DWORD PTR _datatype$90029[ebp]
	mov	edx, 1
	mov	DWORD PTR [ecx+200], eax
	mov	DWORD PTR _datacount$90053[ebp], edx
	mov	DWORD PTR _pointercount$90054[ebp], edx
	mov	edx, DWORD PTR [ecx+168]
	mov	DWORD PTR [edx+8], eax

; 1971 :              g->attr.arrayptr->dim = dim;

	mov	eax, DWORD PTR [ecx+168]
	mov	ecx, DWORD PTR _dim$90030[ebp]

; 1972 :              /* gather sizes */
; 1973 :              indexset_node = right;

	mov	ebx, edi

; 1974 :              for ( i = dim-1 ; i >= 0 ; i-- )

	mov	edi, DWORD PTR tv9525[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	eax, DWORD PTR _list
	test	edi, edi
	js	SHORT $LN185@makenode
	npad	8
$LL187@makenode:

; 1975 :              { int size;
; 1976 :                rexpr_node = indexset_node + 
; 1977 :                 (i ? list[indexset_node].right : list[indexset_node].left);

	mov	ecx, ebx
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR tv9528[ebp], ecx
	test	edi, edi
	je	SHORT $LN694@makenode
	mov	ecx, DWORD PTR [ecx+eax+8]
	jmp	SHORT $LN695@makenode
$LN694@makenode:
	mov	ecx, DWORD PTR [ecx+eax+4]
$LN695@makenode:
	add	ecx, ebx
	mov	DWORD PTR _rexpr_node$90046[ebp], ecx

; 1978 :                size = (int)list[rexpr_node].op1.real;

	imul	ecx, 168				; 000000a8H
	fld	QWORD PTR [ecx+eax+32]
	call	__ftol2_sse

; 1979 :                g->attr.arrayptr->sizes[i] = size;

	mov	edx, DWORD PTR _g$90026[ebp]
	mov	ecx, DWORD PTR [edx+168]

; 1980 :                datacount *= size;

	mov	edx, eax
	imul	edx, DWORD PTR _datacount$90053[ebp]
	mov	DWORD PTR [ecx+edi*4+24], eax
	mov	DWORD PTR _datacount$90053[ebp], edx

; 1981 :                if ( i < dim-1 ) pointercount *= size;

	cmp	edi, DWORD PTR tv9525[ebp]
	jge	SHORT $LN184@makenode
	imul	eax, DWORD PTR _pointercount$90054[ebp]
	mov	DWORD PTR _pointercount$90054[ebp], eax
$LN184@makenode:

; 1982 :                indexset_node += list[indexset_node].left;

	mov	eax, DWORD PTR _list
	mov	ecx, DWORD PTR tv9528[ebp]
	add	ebx, DWORD PTR [ecx+eax+4]
	dec	edi
	jns	SHORT $LL187@makenode
$LN185@makenode:

; 1983 :              }
; 1984 :              /* pop index nodes off execution list */
; 1985 :              listtop = rexpr_node;

	mov	ecx, DWORD PTR _rexpr_node$90046[ebp]
	mov	DWORD PTR _listtop, ecx

; 1986 :              memset(list+listtop,0,sizeof(struct treenode));

	imul	ecx, 168				; 000000a8H
	push	168					; 000000a8H
	add	ecx, eax
	push	0
	push	ecx
	call	_memset

; 1987 :  
; 1988 :              g->attr.arrayptr->itemsize = datatype_size[datatype];

	mov	eax, DWORD PTR _g$90026[ebp]
	mov	edx, DWORD PTR [eax+168]
	mov	edi, DWORD PTR _datatype$90029[ebp]
	mov	ecx, DWORD PTR _datatype_size[edi*4]
	mov	DWORD PTR [edx+12], ecx

; 1989 :              g->attr.arrayptr->datacount = datacount;

	mov	edx, DWORD PTR [eax+168]
	mov	eax, DWORD PTR _datacount$90053[ebp]

; 1990 :               
; 1991 :              i = add_local_var(NULL,datacount+pointercount);

	mov	ecx, DWORD PTR _pointercount$90054[ebp]
	add	ecx, eax
	push	ecx
	push	0
	mov	DWORD PTR [edx+16], eax
	call	_add_local_var

; 1992 :              datastart = get_local(i).offset;

	mov	edx, DWORD PTR _localbase
	mov	ecx, DWORD PTR [edx]

; 1993 :              g = globals(left); /* kludge since add_local_var can move things */

	mov	edx, DWORD PTR tv8520[ebp]
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	mov	eax, DWORD PTR [eax+ecx+216]
	add	esp, 20					; 00000014H
	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN696@makenode
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN698@makenode
	mov	edx, DWORD PTR tv8522[ebp]
	imul	edx, 224				; 000000e0H
	add	ecx, edx
	jmp	SHORT $LN697@makenode
$LN698@makenode:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN696@makenode
	mov	ecx, DWORD PTR _web+5656
	mov	edx, DWORD PTR tv8522[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN697@makenode
$LN696@makenode:
	mov	edx, DWORD PTR tv8522[ebp]
	mov	ecx, DWORD PTR _web+5652
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
$LN697@makenode:

; 1994 :              g->attr.arrayptr->datastart = datastart;

	mov	ecx, DWORD PTR [ecx+168]
	mov	DWORD PTR [ecx+20], eax

; 1995 : 
; 1996 :              list[listtop].type = DEFINE_FIXED_LOCAL_ARRAY_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10041		; 00002739H

; 1997 :              list[listtop].op1.name_id = left; /* global variable number */

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+32], esi

; 1998 :              list[listtop].op2.valtype = datatype; /* type */
; 1999 : 
; 2000 :              break;

	jmp	$LN544@makenode
$LN188@makenode:

; 2001 :            }
; 2002 :            else g->flags |= UNFIXED_SIZE_ARRAY;

	mov	eax, DWORD PTR tv10982[ebp]
	or	eax, 536870912				; 20000000H
	mov	DWORD PTR [ecx+192], eax
$LN183@makenode:

; 2003 :          }
; 2004 :          
; 2005 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 2006 :          list[listtop].left = right-listtop; /* index expression list */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], edi

; 2007 :          list[listtop].op1.name_id = left; /* global variable number */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+32], esi

; 2008 :          list[listtop].op2.valtype = datatype;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	esi, DWORD PTR _datatype$90029[ebp]
	mov	DWORD PTR [eax+edx+136], esi

; 2009 :          g->flags |= ARRAY_PARAM;
; 2010 :          g->flags &= ~ORDINARY_PARAM;

	mov	eax, DWORD PTR [ecx+192]
	and	eax, -2					; fffffffeH
	or	eax, 2048				; 00000800H
	mov	DWORD PTR [ecx+192], eax

; 2011 :                 
; 2012 :          if ( (g->attr.arrayptr->dim > 0) &&
; 2013 :                         (g->attr.arrayptr->dim != list[right].op5.indexcount) )

	mov	ecx, DWORD PTR [ecx+168]
	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _list
	test	eax, eax
	jle	SHORT $LN893@makenode
	mov	esi, DWORD PTR tv8548[ebp]
	cmp	eax, DWORD PTR [esi+edx+152]
	je	SHORT $LN893@makenode

; 2014 :          { sprintf(errmsg,"Cannot change the number of dimensions of array %s.\n",
; 2015 :                  g->name);

	mov	ecx, DWORD PTR _g$90026[ebp]
	push	ecx
	push	OFFSET ??_C@_0DF@CMJIKKNE@Cannot?5change?5the?5number?5of?5dime@
	push	OFFSET _errmsg
	call	_sprintf

; 2016 :            kb_error(2225,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	2225					; 000008b1H
	call	_kb_error
	add	esp, 24					; 00000018H
	jmp	SHORT $LN181@makenode
$LN893@makenode:

; 2017 :          }
; 2018 :          else g->attr.arrayptr->dim = list[right].op5.indexcount;

	mov	eax, DWORD PTR tv8548[ebp]
	mov	edx, DWORD PTR [eax+edx+152]
	mov	DWORD PTR [ecx+4], edx
$LN181@makenode:

; 2019 :          list[listtop].flags |= EPHEMERAL;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	or	DWORD PTR [eax+ecx+24], 64		; 00000040H

; 2020 :          list[listtop].stack_delta = -list[right].op5.indexcount;

	mov	edx, DWORD PTR tv8548[ebp]
	lea	eax, DWORD PTR [eax+ecx+24]
	mov	eax, DWORD PTR _list
	mov	ecx, DWORD PTR [edx+eax+152]

; 2021 :          break;

	jmp	$LN945@makenode
$LN109@makenode:

; 2473 :        }
; 2474 : 
; 2475 :     case SET_DELTA_NODE: case SET_PARAM_SCALE_NODE:
; 2476 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2477 :          list[listtop].op1.name_id = left; /* variable number */

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], esi

; 2478 :          if ( right )

	test	edi, edi
	je	SHORT $LN108@makenode

; 2479 :            list[listtop].left = right - listtop;  /* value expression */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edi
$LN108@makenode:

; 2480 :          list[listtop].op2.assigntype = assigntype;

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _assigntype
	imul	edx, 168				; 000000a8H
	mov	eax, DWORD PTR _list
	mov	DWORD PTR [edx+eax+136], ecx

; 2481 :          if ( !(globals(left)->flags & ANY_TYPE)  )

	mov	edx, DWORD PTR _dymem
	mov	edi, DWORD PTR _web+5652
	mov	ebx, DWORD PTR _localbase
	mov	ecx, esi
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN752@makenode
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN754@makenode
	and	esi, 16777215				; 00ffffffH
	mov	eax, esi
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ebx]
	jmp	SHORT $LN753@makenode
$LN754@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN752@makenode
	mov	eax, DWORD PTR _web+5656
	and	esi, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN753@makenode
$LN752@makenode:
	and	esi, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [eax+edx]
$LN753@makenode:
	test	DWORD PTR [eax+192], 1990		; 000007c6H
	jne	SHORT $LN107@makenode

; 2482 :             globals(left)->flags |= ORDINARY_PARAM;

	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN758@makenode
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN760@makenode
	mov	eax, esi
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ebx]
	jmp	SHORT $LN759@makenode
$LN760@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN758@makenode
	mov	edx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN759@makenode
$LN758@makenode:
	lea	eax, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [eax+edx]
$LN759@makenode:
	or	DWORD PTR [eax+192], 1
	mov	edx, DWORD PTR _dymem
	mov	edi, DWORD PTR _web+5652
	mov	ebx, DWORD PTR _localbase
$LN107@makenode:

; 2483 :          if ( perm_flag ) globals(left)->flags |= PERMANENT;

	cmp	DWORD PTR _perm_flag, 0
	je	SHORT $LN106@makenode
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN768@makenode
	lea	ecx, DWORD PTR [edi+esi*4]
	mov	esi, DWORD PTR [ecx+edx]
	jmp	SHORT $LN765@makenode
$LN768@makenode:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN766@makenode
	imul	esi, 224				; 000000e0H
	add	esi, DWORD PTR [ebx]
	jmp	SHORT $LN765@makenode
$LN766@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN764@makenode
	mov	edx, DWORD PTR _web+5656
	mov	esi, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN765@makenode
$LN764@makenode:
	lea	eax, DWORD PTR [edi+esi*4]
	mov	esi, DWORD PTR [eax+edx]
$LN765@makenode:
	or	DWORD PTR [esi+192], 16			; 00000010H
$LN106@makenode:

; 2484 :          list[listtop].flags |= EPHEMERAL;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	or	DWORD PTR [ecx+edx+24], 64		; 00000040H
	lea	eax, DWORD PTR [ecx+edx+24]

; 2485 :          list[listtop].stack_delta = -1;
; 2486 :          break;

	jmp	$LN921@makenode
$LN105@makenode:

; 2487 : 
; 2488 :     case SET_ON_ASSIGN_CALL_NODE:
; 2489 :        { struct global *g = globals(right);

	mov	ecx, edi
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN774@makenode
	mov	ecx, DWORD PTR _web+5652
	mov	edx, edi
	and	edx, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx]
	jmp	SHORT $LN915@makenode
$LN774@makenode:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN772@makenode
	mov	edx, DWORD PTR _localbase
	mov	ecx, edi
	and	ecx, 16777215				; 00ffffffH
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN915@makenode
$LN772@makenode:
	cmp	ecx, 536870912				; 20000000H
	mov	ecx, edi
	jne	SHORT $LN770@makenode
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN915@makenode
$LN770@makenode:
	mov	edx, DWORD PTR _web+5652
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
$LN915@makenode:

; 2490 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 2491 :          list[listtop].op1.name_id = left; /* variable number */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+32], esi

; 2492 :          list[listtop].op2.name_id = right; /* procedure id */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+136], edi

; 2493 :          if ( g->attr.procstuff.argcount > 0 )

	cmp	DWORD PTR [ecx+168], 0
	mov	DWORD PTR _g$90224[ebp], ecx
	jle	SHORT $LN104@makenode

; 2494 :            kb_error(5998,"on_assign_call procedure cannot have arguments.\n",
; 2495 :               RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DB@LABGMEKM@on_assign_call?5procedure?5cannot?5@
	push	5998					; 0000176eH
	call	_kb_error
	mov	ecx, DWORD PTR _g$90224[ebp]
	add	esp, 12					; 0000000cH
$LN104@makenode:

; 2496 :          g->flags |= USED_ON_ASSIGN_CALL;

	or	DWORD PTR [ecx+192], -2147483648	; 80000000H

; 2497 :          break;

	jmp	$LN878@makenode
$LN103@makenode:

; 2498 :        }
; 2499 :          
; 2500 : 
; 2501 :     case SET_ELEMENT_GLOBAL_NODE:
; 2502 :        { struct global *g = globals(left);

	mov	ecx, esi
	and	ecx, -16777216				; ff000000H
	mov	DWORD PTR tv8520[ebp], ecx
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN776@makenode
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN778@makenode
	mov	edx, DWORD PTR _localbase
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	mov	DWORD PTR tv8522[ebp], ecx
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN916@makenode
$LN778@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN776@makenode
	mov	edx, DWORD PTR _web+5656
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	mov	DWORD PTR tv8522[ebp], ecx
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN916@makenode
$LN776@makenode:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	mov	DWORD PTR tv8522[ebp], ecx
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx]
$LN916@makenode:

; 2503 :          int eltype = -1;  /* of right side */
; 2504 : 
; 2505 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 2506 :          list[listtop].op1.name_id = left; /* variable number */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+32], esi

; 2507 :          list[listtop].left = right - listtop;  /* value expression */

	mov	eax, DWORD PTR _listtop
	mov	esi, DWORD PTR _list
	mov	edx, edi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+esi+4], edx

; 2508 :          if ( !(g->flags & ANY_TYPE)  )

	mov	eax, DWORD PTR [ecx+192]
	mov	DWORD PTR _g$90229[ebp], ecx
	mov	DWORD PTR _eltype$90232[ebp], -1
	test	eax, 1990				; 000007c6H
	jne	SHORT $LN102@makenode

; 2509 :             g->flags |= ORDINARY_PARAM;

	or	eax, 1
	mov	DWORD PTR [ecx+192], eax
$LN102@makenode:

; 2510 :          if ( (list[listtop].datatype < VERTEX_TYPE)
; 2511 :                 || (list[listtop].datatype > FACETEDGE_TYPE) )

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	eax, DWORD PTR [eax+edx+20]
	cmp	eax, 13					; 0000000dH
	jl	SHORT $LN100@makenode
	cmp	eax, 17					; 00000011H
	jle	SHORT $LN904@makenode
$LN100@makenode:

; 2512 :             kb_error(2884,"Right side expression must be an element.\n",
; 2513 :                   COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CL@NBJONBCH@Right?5side?5expression?5must?5be?5an@
	push	2884					; 00000b44H
	call	_kb_error
	mov	ecx, DWORD PTR _g$90229[ebp]
	add	esp, 12					; 0000000cH
$LN904@makenode:

; 2514 :          switch ( list[right].op1.eltype )

	mov	edx, DWORD PTR _list
	imul	edi, 168				; 000000a8H
	mov	edi, DWORD PTR [edi+edx+32]
	mov	eax, DWORD PTR tv8522[ebp]
	cmp	edi, 4
	ja	SHORT $LN92@makenode
	jmp	DWORD PTR $LN955@makenode[edi*4]
$LN97@makenode:

; 2515 :          { case VERTEX:
; 2516 :             eltype = VERTEX_TYPE; break;

	mov	edx, 13					; 0000000dH
	mov	DWORD PTR _eltype$90232[ebp], edx
	jmp	SHORT $LN98@makenode
$LN96@makenode:

; 2517 :            case EDGE:
; 2518 :             eltype = EDGE_TYPE; break;

	mov	edx, 14					; 0000000eH
	mov	DWORD PTR _eltype$90232[ebp], edx
	jmp	SHORT $LN98@makenode
$LN95@makenode:

; 2519 :            case FACET:
; 2520 :             eltype = FACET_TYPE; break;

	mov	edx, 15					; 0000000fH
	mov	DWORD PTR _eltype$90232[ebp], edx
	jmp	SHORT $LN98@makenode
$LN94@makenode:

; 2521 :            case BODY:
; 2522 :             eltype = BODY_TYPE; break;

	mov	edx, 16					; 00000010H
	mov	DWORD PTR _eltype$90232[ebp], edx
	jmp	SHORT $LN98@makenode
$LN93@makenode:

; 2523 :            case FACETEDGE:
; 2524 :             eltype = FACETEDGE_TYPE; break;

	mov	edx, 17					; 00000011H
	mov	DWORD PTR _eltype$90232[ebp], edx
	jmp	SHORT $LN98@makenode
$LN92@makenode:

; 2525 :            default:
; 2526 :              kb_error(3684,"Illegal element type.\n",Q_ERROR);

	push	8
	push	OFFSET ??_C@_0BH@PNBBNCCB@Illegal?5element?5type?4?6?$AA@
	push	3684					; 00000e64H
	call	_kb_error
	mov	eax, DWORD PTR tv8522[ebp]
	mov	edx, DWORD PTR _eltype$90232[ebp]
	mov	ecx, DWORD PTR _g$90229[ebp]
	add	esp, 12					; 0000000cH
$LN98@makenode:

; 2527 :          }
; 2528 :          if ( g->type && (g->type != eltype) )

	mov	esi, DWORD PTR [ecx+200]
	test	esi, esi
	je	$LN91@makenode
	cmp	esi, edx
	je	$LN91@makenode

; 2529 :          { sprintf(errmsg,
; 2530 :             "Cannot assign expression of type %s to variable %s of type %s.\n",
; 2531 :              datatype_name[eltype],globals(left)->name,datatype_name[g->type]);

	mov	ecx, DWORD PTR tv8520[ebp]
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN782@makenode
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN784@makenode
	mov	ecx, DWORD PTR _localbase
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN783@makenode
$LN784@makenode:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN782@makenode
	mov	edx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN783@makenode
$LN782@makenode:
	mov	ecx, DWORD PTR _web+5652
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN783@makenode:
	mov	ecx, DWORD PTR _datatype_name[esi*4]
	mov	edx, DWORD PTR _eltype$90232[ebp]
	push	ecx
	push	eax
	mov	eax, DWORD PTR _datatype_name[edx*4]
	push	eax
	push	OFFSET ??_C@_0EA@FFIPKJOG@Cannot?5assign?5expression?5of?5type@
	push	OFFSET _errmsg
	call	_sprintf

; 2532 :            kb_error(3686,errmsg,Q_ERROR);

	push	8
	push	OFFSET _errmsg
	push	3686					; 00000e66H
	call	_kb_error
	add	esp, 32					; 00000020H
	jmp	SHORT $LN90@makenode
$LN91@makenode:

; 2533 :          }
; 2534 :          else g->type = eltype;

	mov	DWORD PTR [ecx+200], edx
$LN90@makenode:

; 2535 :          if ( perm_flag ) g->flags |= PERMANENT;

	cmp	DWORD PTR _perm_flag, 0
	je	$LN106@makenode
	mov	eax, DWORD PTR _g$90229[ebp]
	or	DWORD PTR [eax+192], 16			; 00000010H

; 2536 :          list[listtop].flags |= EPHEMERAL;
; 2537 :          list[listtop].stack_delta = -1;
; 2538 :          break;

	jmp	$LN106@makenode
$LN79@makenode:

; 2590 : 
; 2591 :     case SET_SGLOBAL_NODE:
; 2592 :     case SET_PERM_SGLOBAL_NODE:
; 2593 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 2594 :          list[listtop].op1.name_id = left; /* variable number */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+32], esi

; 2595 :          list[listtop].left = right - listtop;  /* value expression */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], edi

; 2596 :          globals(left)->flags |= STRINGVAL;

	mov	edx, esi
	and	edx, -16777216				; ff000000H
	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN800@makenode
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN802@makenode
	mov	edi, DWORD PTR _localbase
	and	esi, 16777215				; 00ffffffH
	mov	eax, esi
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edi]
	jmp	SHORT $LN801@makenode
$LN802@makenode:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN800@makenode
	mov	eax, DWORD PTR _web+5656
	and	esi, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN801@makenode
$LN800@makenode:
	mov	eax, DWORD PTR _web+5652
	mov	edi, DWORD PTR _dymem
	and	esi, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [eax+edi]
$LN801@makenode:
	or	DWORD PTR [eax+192], 8192		; 00002000H

; 2597 :          globals(left)->flags &= ~ORDINARY_PARAM;

	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN806@makenode
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN808@makenode
	mov	edi, DWORD PTR _localbase
	mov	eax, esi
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edi]
	jmp	SHORT $LN807@makenode
$LN808@makenode:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN806@makenode
	mov	eax, DWORD PTR _web+5656
	mov	eax, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN807@makenode
$LN806@makenode:
	mov	eax, DWORD PTR _web+5652
	mov	edi, DWORD PTR _dymem
	lea	eax, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [eax+edi]
$LN807@makenode:
	and	DWORD PTR [eax+192], -2			; fffffffeH

; 2598 :          if ( type == SET_SGLOBAL_NODE ) list[listtop].flags |= EPHEMERAL;

	mov	eax, 10699				; 000029cbH
	cmp	cx, ax
	jne	SHORT $LN78@makenode
	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	or	DWORD PTR [ecx+eax+24], 64		; 00000040H
	lea	eax, DWORD PTR [ecx+eax+24]
$LN78@makenode:

; 2599 :          if ( perm_flag ) globals(left)->flags |= PERMANENT;

	cmp	DWORD PTR _perm_flag, 0
	je	$LN921@makenode
	cmp	edx, 268435456				; 10000000H
	jne	SHORT $LN816@makenode
	mov	ecx, DWORD PTR _web+5652
	mov	eax, DWORD PTR _dymem
	lea	edx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [edx+eax]
	or	DWORD PTR [esi+192], 16			; 00000010H

; 2600 :          list[listtop].stack_delta = -1;
; 2601 :          break;

	jmp	$LN921@makenode
$LN816@makenode:

; 2599 :          if ( perm_flag ) globals(left)->flags |= PERMANENT;

	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN814@makenode
	mov	ecx, DWORD PTR _localbase
	imul	esi, 224				; 000000e0H
	add	esi, DWORD PTR [ecx]
	or	DWORD PTR [esi+192], 16			; 00000010H

; 2600 :          list[listtop].stack_delta = -1;
; 2601 :          break;

	jmp	$LN921@makenode
$LN814@makenode:

; 2599 :          if ( perm_flag ) globals(left)->flags |= PERMANENT;

	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN812@makenode
	mov	edx, DWORD PTR _web+5656
	mov	esi, DWORD PTR [edx+esi*4]
	or	DWORD PTR [esi+192], 16			; 00000010H

; 2600 :          list[listtop].stack_delta = -1;
; 2601 :          break;

	jmp	$LN921@makenode
$LN812@makenode:

; 2599 :          if ( perm_flag ) globals(left)->flags |= PERMANENT;

	mov	eax, DWORD PTR _web+5652
	mov	edx, DWORD PTR _dymem
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [ecx+edx]
	or	DWORD PTR [esi+192], 16			; 00000010H

; 2600 :          list[listtop].stack_delta = -1;
; 2601 :          break;

	jmp	$LN921@makenode
$LN33@makenode:

; 2731 : 
; 2732 :     case SHOW_VOL_NODE:  case CHECK_NODE: case LONG_JIGGLE_NODE: case RAW_VERAVG_NODE:
; 2733 :     case STABILITY_TEST_NODE: case UTEST_NODE: case GO_NODE: case SHELL_NODE: 
; 2734 :     case ALICE_NODE:      case TOPINFO_NODE: case RECALC_NODE: case COUNTS_NODE:
; 2735 :     case EXTRAPOLATE_NODE: case HESSIAN_NODE: case SOBOLEV_NODE: 
; 2736 :     case SHOWQ_NODE:case RAWEST_VERAVG_NODE: case DIRICHLET_NODE: case BOTTOMINFO_NODE:
; 2737 :     case CLOSE_SHOW_NODE: case REBODY_NODE: case LIST_PROCS_NODE: case HESSIAN_MENU_NODE:
; 2738 :     case DIRICHLET_SEEK_NODE: case SOBOLEV_SEEK_NODE: case CONVERT_TO_QUANTS_NODE:
; 2739 :     case LIST_ATTRIBUTES_NODE: case REORDER_STORAGE_NODE: case RENUMBER_ALL_NODE:
; 2740 :     case DUMP_MEMLIST_NODE: case FREE_DISCARDS_NODE: case REPARTITION_NODE:
; 2741 :     case SUBCOMMAND_NODE: case ABORT_NODE: case SIMPLEX_TO_FE_NODE: case DETORUS_NODE:
; 2742 :     case MAKE_THREAD_LISTS_NODE:
; 2743 :          list[listtop].type = type;
; 2744 :          break;
; 2745 : 
; 2746 :     case LIST_BOUNDARY_NODE: case LIST_CONSTRAINT_NODE:
; 2747 :          list[listtop].type = type;
; 2748 :          list[listtop].left = left - listtop;
; 2749 :          list[listtop].stack_delta = -1;
; 2750 :          break;
; 2751 : 
; 2752 :     case LIST_QUANTITY_NODE: 
; 2753 :          list[listtop].type = type;
; 2754 :          list[listtop].op1.quant_id = left;
; 2755 :          break;
; 2756 :  
; 2757 :     case LIST_METHOD_INSTANCE_NODE: 
; 2758 :          list[listtop].type = type;
; 2759 :          list[listtop].op1.meth_id = left;
; 2760 :          break;
; 2761 :  
; 2762 :     case CONSTRAINT_NORMAL_NODE:
; 2763 :     case CONSTRAINT_FIXED_NODE:
; 2764 :     case CONSTRAINT_NONPOSITIVE_NODE:
; 2765 :     case CONSTRAINT_NONNEGATIVE_NODE:
; 2766 :          list[listtop].type = type;
; 2767 :          list[listtop].left = left - listtop;
; 2768 :          break;
; 2769 : 
; 2770 :     /* toggles */ case LINEAR_NODE: case QUADRATIC_NODE: case QUIETGO_NODE:
; 2771 :     case KUSNER_NODE: case ESTIMATE_NODE: case DETURCK_NODE: case HOMOTHETY_NODE:
; 2772 :     case SQGAUSS_NODE: case AUTOPOP_NODE: case AUTOCHOP_NODE: case QUIET_NODE:
; 2773 :     case OLD_AREA_NODE: case APPROX_CURV_NODE: case RUNGE_KUTTA_NODE: 
; 2774 :     case CHECK_INCREASE_NODE:  case DEBUG_NODE: case MEAN_CURV_NODE: case RIBIERE_CG_NODE:
; 2775 :     case DIFFUSION_NODE: case GRAVITY_NODE: case CONJ_GRAD_NODE: case TRANSFORMS_NODE:
; 2776 :     case CONF_EDGE_SQCURV_NODE: case EFFECTIVE_AREA_NODE: 
; 2777 :     case RAW_CELLS_NODE: case CONNECTED_CELLS_NODE: case CLIPPED_CELLS_NODE:
; 2778 :     case THICKEN_NODE: case SHOW_INNER_NODE: case SHOW_OUTER_NODE: case COLORMAP_NODE: 
; 2779 :     case HESSIAN_DIFF_NODE: case POST_PROJECT_NODE: case MEAN_CURV_INT_NODE:
; 2780 :     case OPTIMIZE_NODE: case NORMAL_CURVATURE_NODE: case DIV_NORMAL_CURVATURE_NODE:
; 2781 :     case SHADING_NODE:  case FACET_COLORS_NODE: case BOUNDARY_CURVATURE_NODE:
; 2782 :     case NORMAL_MOTION_NODE: case PINNING_NODE: case VIEW_4D_NODE: case MEMDEBUG_NODE:
; 2783 :     case METRIC_CONVERSION_NODE: case AUTORECALC_NODE: case GV_BINARY_NODE:
; 2784 :     case SELF_SIMILAR_NODE: case AUTODISPLAY_NODE: case FORCE_POS_DEF_NODE:
; 2785 :     case ASSUME_ORIENTED_NODE: case HESSIAN_QUIET_NODE: case JIGGLE_TOGGLE_NODE:
; 2786 :     case HESSIAN_NORMAL_NODE: case YSMP_NODE: case BUNCH_KAUFMAN_NODE: case MKL_NODE:
; 2787 :     case QUANTITIES_ONLY_NODE: case LINEAR_METRIC_NODE: case GEOMVIEW_TOGGLE_NODE:
; 2788 :     case GEOMPIPE_TOGGLE_NODE: case SQUARED_GRADIENT_NODE: case H_INVERSE_METRIC_NODE:
; 2789 :     case HESSIAN_DOUBLE_NORMAL_NODE: case INTERP_BDRY_PARAM_NODE: case LOGFILE_TOGGLE_NODE:
; 2790 :     case HESSIAN_NORMAL_ONE_NODE: case PSCOLORFLAG_NODE: case GRIDFLAG_NODE:
; 2791 :     case SEPTUM_FLAG_NODE: case BOX_FLAG_NODE: case SHOW_ALL_EDGES_NODE:
; 2792 :     case CROSSINGFLAG_NODE: case LABELFLAG_NODE: case SHOW_ALL_QUANTITIES_NODE:
; 2793 :     case HESSIAN_NORMAL_PERP_NODE: case HESSIAN_SPECIAL_NORMAL_NODE: case ITDEBUG_NODE:
; 2794 :     case METIS_FACTOR_NODE: case VOLGRADS_EVERY_NODE: case ZENER_DRAG_NODE: 
; 2795 :     case BACKCULL_NODE: case INTERP_NORMALS_NODE: case TORUS_FILLED_NODE: case VERBOSE_NODE:
; 2796 :     case AMBIENT_PRESSURE_NODE: case DIRICHLET_MODE_NODE: case SOBOLEV_MODE_NODE:
; 2797 :     case KRAYNIKPOPVERTEX_FLAG_NODE: case KEYLOGFILE_TOGGLE_NODE: case PS_CMYKFLAG_NODE:
; 2798 :     case KRAYNIKPOPEDGE_FLAG_NODE: case VISIBILITY_TEST_NODE: case SPARSE_CONSTRAINTS_NODE:
; 2799 :     case K_ALTITUDE_FLAG_NODE: case FORCE_EDGESWAP_NODE:
; 2800 :     case BLAS_FLAG_NODE: case AUGMENTED_HESSIAN_NODE: case BREAK_AFTER_WARNING_NODE:
; 2801 :     case RGB_COLORS_FLAG_NODE:  case CIRCULAR_ARC_DRAW_NODE: case BEZIER_BASIS_NODE:
; 2802 :     case SMOOTH_GRAPH_NODE: case MPI_DEBUG_NODE: case POP_DISJOIN_NODE:
; 2803 :     case POP_TO_EDGE_NODE: case POP_TO_FACE_NODE: case POP_ENJOIN_NODE:
; 2804 :     case FULL_BOUNDING_BOX_NODE: case BIG_ENDIAN_NODE: case LITTLE_ENDIAN_NODE:
; 2805 :     case QUIETLOAD_NODE: case SLICE_VIEW_NODE: case FUNCTION_QUANTITY_SPARSE_NODE:
; 2806 :     case CLIP_VIEW_NODE: case STAR_FINAGLING_NODE: case FORCE_DELETION_NODE:
; 2807 :     case AUTOPOP_QUARTIC_NODE: case IMMEDIATE_AUTOPOP_NODE: case DETORUS_STICKY_NODE:
; 2808 :     case VIEW_TRANSFORMS_USE_UNIQUE_NODE: case ROTATE_LIGHTS_NODE: case BREAK_ON_WARNING_NODE:
; 2809 :          list[listtop].type = type;
; 2810 :          list[listtop].op1.toggle_state = left; /* toggle state */
; 2811 :          break;
; 2812 :      
; 2813 :     case SYSTEM_NODE: 
; 2814 :     case READ_NODE:
; 2815 :     case EXEC_NODE: case PARALLEL_EXEC_NODE:
; 2816 :     case CHDIR_NODE:
; 2817 :     case SHOW_TRANS_NODE:
; 2818 :     case SET_COLORMAP_NODE:
; 2819 :     case TRANSFORM_EXPR_NODE:  case KEYLOGFILE_NODE: case OOGLFILE_NODE:
; 2820 :     case BINARY_OFF_FILE_NODE:
; 2821 :     case GEOMVIEW_NODE: case GEOMPIPE_NODE: case POSTSCRIPT_NODE: case LOGFILE_NODE:
; 2822 :          list[listtop].type = type;
; 2823 :          list[listtop].left = left - listtop;
; 2824 :          list[listtop].stack_delta = -1;
; 2825 :          break;
; 2826 : 
; 2827 :     case TASK_EXEC_NODE:
; 2828 :          list[listtop].type = type;
; 2829 :          list[listtop].left = left - listtop;
; 2830 :          list[listtop].right = right - listtop;
; 2831 :          list[listtop].stack_delta = -2;
; 2832 :          break;
; 2833 : 
; 2834 :     case TEXT_SPOT_NODE: /* just accumulate two arguments */
; 2835 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 2836 :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], esi

; 2837 :          list[listtop].right = right - listtop;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], edi

; 2838 :          break;

	jmp	$LN878@makenode
$LN31@makenode:

; 2839 : 
; 2840 :     case TEXT_SIZE_NODE:
; 2841 :          list[listtop].type = type;
; 2842 :          list[listtop].left = left - listtop;
; 2843 :          list[listtop].right = right - listtop;
; 2844 :          break;
; 2845 : 
; 2846 :     case DISPLAY_TEXT_NODE:
; 2847 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 2848 :          list[listtop].left = left - listtop;
; 2849 :          list[listtop].right = right - listtop;
; 2850 :          list[listtop].stack_delta = -3;  /* pops 4, leaves string id */
; 2851 :          break;

	jmp	$LN927@makenode
$LN29@makenode:

; 2852 : 
; 2853 :     case DELETE_TEXT_NODE:
; 2854 :          list[listtop].type = type;
; 2855 :          list[listtop].left = left - listtop;
; 2856 :          list[listtop].stack_delta = -1; 
; 2857 :          break;
; 2858 : 
; 2859 : 
; 2860 :     case PRINTFHEAD_NODE:
; 2861 :     case BINARY_PRINTFHEAD_NODE:
; 2862 :     case ERRPRINTFHEAD_NODE:
; 2863 :     case SPRINTFHEAD_NODE:
; 2864 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2865 :          list[listtop].left = left - listtop;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi

; 2866 :          list[listtop].stack_delta = 0; /* since pushes result string */
; 2867 :          // count format arguments
; 2868 :          if ( list[left].type == QUOTATION_NODE )

	imul	esi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], 0
	mov	ecx, DWORD PTR _list
	cmp	DWORD PTR [esi+ecx], 10659		; 000029a3H
	lea	eax, DWORD PTR [esi+ecx]
	jne	$LN878@makenode

; 2869 :          { char *s = list[left].op1.string;

	mov	esi, DWORD PTR [eax+32]

; 2870 :            int fmtcount = 0;
; 2871 :            for ( ; *s ; s++)

	mov	al, BYTE PTR [esi]
	xor	edi, edi
	test	al, al
	je	SHORT $LN25@makenode
$LL27@makenode:

; 2872 :              if ( *s == '%' )

	cmp	al, 37					; 00000025H
	jne	SHORT $LN26@makenode

; 2873 :              { if (s[1] == '%') 

	mov	al, BYTE PTR [esi+1]
	cmp	al, 37					; 00000025H
	jne	SHORT $LN23@makenode

; 2870 :            int fmtcount = 0;
; 2871 :            for ( ; *s ; s++)

	inc	esi

; 2874 :                  s++;

	jmp	SHORT $LN26@makenode
$LN23@makenode:

; 2875 :                else if (s[1] == 'n') 

	cmp	al, 110					; 0000006eH
	jne	SHORT $LN21@makenode

; 2876 :                  kb_error(5789,"Illegal format specifier: %n \n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BP@GOBDCNHG@Illegal?5format?5specifier?3?5?$CFn?5?6?$AA@
	push	5789					; 0000169dH
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN26@makenode
$LN21@makenode:

; 2877 :                else if ( s[1] != '\\' )

	cmp	al, 92					; 0000005cH
	je	SHORT $LN26@makenode

; 2878 :                  fmtcount++;

	inc	edi
$LN26@makenode:

; 2870 :            int fmtcount = 0;
; 2871 :            for ( ; *s ; s++)

	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	jne	SHORT $LL27@makenode
$LN25@makenode:

; 2879 :              }
; 2880 :            list[listtop].op2.argcount = fmtcount;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+136], edi

; 2881 :          }
; 2882 :          break;

	jmp	$LN878@makenode
$LN18@makenode:

; 2883 : 
; 2884 :     case SPRINTF_NODE: /* with expressions */
; 2885 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2886 :          list[listtop].left = left - listtop; /* has string */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi

; 2887 :          list[listtop].right = right - listtop; /* expressions */
; 2888 :          list[left].type = PRESPRINTF_NODE;

	imul	esi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, edi

; 2889 :          list[left].stack_delta = 0;
; 2890 :          list[listtop].stack_delta = -list[right].op1.argcount;

	imul	edi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edx
	mov	edx, DWORD PTR _list
	mov	DWORD PTR [esi+edx], 10546		; 00002932H
	mov	eax, DWORD PTR _list
	mov	DWORD PTR [esi+eax+156], 0
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [edi+eax+32]
	neg	ecx
	mov	DWORD PTR [edx+eax+156], ecx

; 2891 :          list[listtop].datatype = STRING_TYPE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+20], 11		; 0000000bH

; 2892 :          list[listtop].flags |= DEALLOCATE_POINTER; 

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	or	DWORD PTR [edx+eax+24], 1024		; 00000400H
	lea	eax, DWORD PTR [edx+eax+24]

; 2893 :                  // count format arguments
; 2894 :          if ( list[left].type == QUOTATION_NODE )

	mov	eax, DWORD PTR _list
	cmp	DWORD PTR [esi+eax], 10659		; 000029a3H
	jne	$LN878@makenode

; 2895 :          { char *s = list[left].op1.string;

	mov	esi, DWORD PTR [esi+eax+32]

; 2896 :            int fmtcount = 0;
; 2897 :            for ( ; *s ; s++)

	mov	al, BYTE PTR [esi]
	xor	edi, edi
	test	al, al
	je	$LN14@makenode
$LL16@makenode:

; 2898 :              if ( *s == '%' )

	cmp	al, 37					; 00000025H
	jne	SHORT $LN15@makenode

; 2899 :              { if (s[1] == '%') 

	mov	al, BYTE PTR [esi+1]
	cmp	al, 37					; 00000025H
	jne	SHORT $LN12@makenode

; 2896 :            int fmtcount = 0;
; 2897 :            for ( ; *s ; s++)

	inc	esi

; 2900 :                  s++;

	jmp	SHORT $LN15@makenode
$LN12@makenode:

; 2901 :                else if (s[1] == 'n') 

	cmp	al, 110					; 0000006eH
	jne	SHORT $LN10@makenode

; 2902 :                  kb_error(5790,"Illegal format specifier: %n \n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BP@GOBDCNHG@Illegal?5format?5specifier?3?5?$CFn?5?6?$AA@
	push	5790					; 0000169eH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2903 :                else

	jmp	SHORT $LN15@makenode
$LN10@makenode:

; 2904 :                  fmtcount++;

	inc	edi
$LN15@makenode:

; 2896 :            int fmtcount = 0;
; 2897 :            for ( ; *s ; s++)

	mov	al, BYTE PTR [esi+1]
	inc	esi
	test	al, al
	jne	SHORT $LL16@makenode

; 2905 :              }
; 2906 :            list[listtop].op2.argcount = fmtcount;
; 2907 :          }
; 2908 : 
; 2909 :          break;

	jmp	$LN14@makenode
$LN8@makenode:

; 2910 : 
; 2911 :     case PRINTF_NODE: /* with expressions */
; 2912 :     case BINARY_PRINTF_NODE: /* with expressions */
; 2913 :     case ERRPRINTF_NODE:
; 2914 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2915 :          list[listtop].left = left - listtop; /* has string */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi

; 2916 :          list[listtop].right = right - listtop; /* expressions */
; 2917 :          list[left].type = PREPRINTF_NODE;

	imul	esi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx
	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, edi

; 2918 :          list[left].stack_delta = 0;
; 2919 :          list[listtop].stack_delta = -list[right].op1.argcount-1;

	imul	edi, 168				; 000000a8H
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+8], edx
	mov	edx, DWORD PTR _list
	mov	DWORD PTR [esi+edx], 10545		; 00002931H
	mov	eax, DWORD PTR _list
	mov	DWORD PTR [esi+eax+156], 0
	mov	eax, DWORD PTR _list
	or	ecx, -1
	sub	ecx, DWORD PTR [edi+eax+32]

; 2920 :          break;

	jmp	$LN942@makenode
$LN7@makenode:

; 2921 : 
; 2922 :     case EXPRLIST_NODE:
; 2923 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 2924 :          list[listtop].left = left - listtop; /*  expr */ 

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], esi

; 2925 :          if ( right )
; 2926 :          { list[listtop].right = right - listtop; /* exprlist */

	mov	eax, DWORD PTR _listtop
	test	edi, edi
	je	SHORT $LN6@makenode
	mov	edx, DWORD PTR _list
	mov	ecx, edi

; 2927 :            list[listtop].op1.argcount = list[right].op1.argcount+1;

	imul	edi, 168				; 000000a8H
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+8], ecx
	mov	eax, DWORD PTR _list
	mov	ecx, DWORD PTR [edi+eax+32]
	mov	edx, DWORD PTR _listtop
	inc	ecx
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], ecx
	jmp	$LN878@makenode
$LN6@makenode:

; 2928 :          }
; 2929 :          else list[listtop].op1.argcount = 1; /* arg count */

	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+32], 1

; 2930 :          break;

	jmp	$LN878@makenode
$LN4@makenode:

; 2931 : 
; 2932 :     case DATAFILENAME_NODE:
; 2933 :     case WARNING_MESSAGES_NODE:
; 2934 :     case GET_TRANSFORM_EXPR_NODE:
; 2935 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], ebx

; 2936 :          list[listtop].stack_delta = 1;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+156], 1

; 2937 :          list[listtop].datatype = STRING_TYPE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+20], 11		; 0000000bH

; 2938 :          break;

	jmp	$LN878@makenode
$LN219@makenode:

; 1781 : 
; 1782 :     case FUNCTION_PROTO_NODE:
; 1783 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1784 :          list[listtop].left = left - listtop; /* function head */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 1785 :          list[listtop].op1.name_id = list[left].op1.name_id; /* name id */

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	eax, esi
	imul	eax, 168				; 000000a8H
	mov	edi, DWORD PTR [eax+ecx+32]
	mov	DWORD PTR [edx+ecx+32], edi

; 1786 :          n = left + list[left].left;

	mov	edi, DWORD PTR _list
	mov	ecx, DWORD PTR [eax+edi+4]
	add	ecx, esi

; 1787 :          list[n].op2.jumpsize = listtop - n; /* for FUNCTION_PROTO_START_ jump */

	mov	esi, DWORD PTR _listtop
	mov	edx, ecx
	imul	edx, 168				; 000000a8H
	sub	esi, ecx
	mov	DWORD PTR [edx+edi+136], esi

; 1788 :          list[n].type = FUNCTION_PROTO_START_NODE;

	mov	ecx, DWORD PTR _list
	mov	DWORD PTR [edx+ecx], 10052		; 00002744H

; 1789 :          list[listtop].flags |= EPHEMERAL;

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	or	DWORD PTR [edx+ecx+24], 64		; 00000040H
	lea	ecx, DWORD PTR [edx+ecx+24]

; 1790 :          list[listtop].op4.ret_type = list[left].op4.ret_type; /* type */

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	eax, DWORD PTR [eax+ecx+148]
	mov	DWORD PTR [edx+ecx+148], eax

; 1791 :          break;

	jmp	$LN878@makenode
$LN823@makenode:

; 260  :   switch ( type )

	sub	edx, 20002				; 00004e22H
	cmp	edx, 6
	ja	$LN2@makenode
	jmp	DWORD PTR $LN956@makenode[edx*4]
$LN453@makenode:

; 970  :          
; 971  :       case AGGREGATE_NODE:
; 972  :          list[listtop].type = aggrtype;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _aggrtype
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], edx

; 973  :          /* op1 holds offset back to start of loop */
; 974  :          if ( list[left].type == SINGLE_ELEMENT_NODE )

	mov	edx, DWORD PTR _list
	mov	eax, esi
	imul	eax, 168				; 000000a8H
	mov	ecx, DWORD PTR [eax+edx]
	cmp	ecx, 10241				; 00002801H
	jne	SHORT $LN452@makenode

; 975  :          { list[listtop].op1.skipsize = 1; /* don't go back */

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+32], 1

; 976  :            nnode = list+left;
; 977  :            nnode->op1.skipsize = listtop - left; /* in case of WHERE_ */

	mov	ecx, DWORD PTR _listtop
	add	eax, DWORD PTR _list
	sub	ecx, esi
	mov	DWORD PTR [eax+32], ecx
	jmp	SHORT $LN901@makenode
$LN452@makenode:

; 978  :          }
; 979  :          else if ( list[left].type == WHERE_NODE )

	cmp	ecx, 10262				; 00002816H

; 980  :          { list[listtop].op1.skipsize = list[left].left + left - listtop;

	mov	ecx, DWORD PTR _listtop
	jne	SHORT $LN450@makenode
	mov	ebx, DWORD PTR [eax+edx+4]
	sub	ebx, ecx
	imul	ecx, 168				; 000000a8H
	add	ebx, esi
	mov	DWORD PTR [ecx+edx+32], ebx

; 981  :            nnode = list+left+list[left].left;

	mov	edx, DWORD PTR _list
	mov	ecx, DWORD PTR [eax+edx+4]
	lea	eax, DWORD PTR [ecx+esi]
	imul	eax, 168				; 000000a8H
	add	eax, edx

; 982  :            if ( nnode->type == SINGLE_ELEMENT_NODE )

	cmp	DWORD PTR [eax], 10241			; 00002801H
	jne	SHORT $LN901@makenode

; 983  :               nnode->op1.skipsize = listtop - (left+list[left].left);

	mov	edx, DWORD PTR _listtop
	sub	edx, ecx
	sub	edx, esi
	mov	DWORD PTR [eax+32], edx

; 984  :          }
; 985  :          else 

	jmp	SHORT $LN901@makenode
$LN450@makenode:

; 986  :          { list[listtop].op1.skipsize = left - listtop; /* no WHERE_ */

	mov	ebx, esi
	sub	ebx, ecx
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+32], ebx

; 987  :            nnode = list+left;

	add	eax, DWORD PTR _list
$LN901@makenode:

; 988  :          }
; 989  :          list[listtop].left = left - listtop;  /* generator */

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	esi, ecx
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+4], esi

; 990  :          if ( right ) list[listtop].right = right - listtop;  /* value */

	test	edi, edi
	je	SHORT $LN447@makenode
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	edi, ecx
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+8], edi
$LN447@makenode:

; 991  :          /* also handy to have element type */
; 992  :          etype = (nnode+nnode->left)->op1.eltype; /* from INIT */

	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 168				; 000000a8H
	mov	esi, DWORD PTR [ecx+eax+32]

; 993  :          /* some type error checking and stuff */
; 994  :          switch ( aggrtype )

	mov	eax, DWORD PTR _aggrtype
	mov	DWORD PTR _etype$[ebp], esi
	cmp	eax, 10334				; 0000285eH
	jg	$LN587@makenode
	je	$LN395@makenode
	sub	eax, 10078				; 0000275eH
	cmp	eax, 227				; 000000e3H
	ja	$LN445@makenode
	movzx	edx, BYTE PTR $LN873@makenode[eax]
	jmp	DWORD PTR $LN957@makenode[edx*4]
$LN443@makenode:

; 999  : 
; 1000 :            case FIX_NODE: 
; 1001 :             if ( etype == BODY )

	cmp	esi, 3
	jne	$LN445@makenode

; 1002 :              kb_error(2230,
; 1003 :               "Cannot FIX bodies. To fix volume, do \"set body target expr\".\n",
; 1004 :                     COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DO@MGJNCOHG@Cannot?5FIX?5bodies?4?5To?5fix?5volume@
	push	2230					; 000008b6H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1005 :             break;

	jmp	$LN445@makenode
$LN441@makenode:

; 1006 : 
; 1007 :            case UNFIX_NODE: 
; 1008 :             if ( etype == BODY )

	cmp	esi, 3
	jne	$LN445@makenode

; 1009 :              kb_error(2881,
; 1010 :                "Cannot UNFIX bodies. To unfix volume, \"unset body target\".\n",
; 1011 :                     COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DM@MFLGHDJO@Cannot?5UNFIX?5bodies?4?5To?5unfix?5vo@
	push	2881					; 00000b41H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1012 :             break;

	jmp	$LN445@makenode
$LN439@makenode:

; 1013 : 
; 1014 :            case UNSET_CENTEROFMASS_NODE: 
; 1015 :             if ( etype != BODY )

	cmp	esi, 3
	je	$LN445@makenode

; 1016 :              kb_error(5881,
; 1017 :                "Can unset centerofmass for bodies only.\n", COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CJ@NHNHDHGB@Can?5unset?5centerofmass?5for?5bodie@
	push	5881					; 000016f9H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1018 :             break;

	jmp	$LN445@makenode
$LN437@makenode:

; 1019 : 
; 1020 : 
; 1021 :            case VERTEX_AVERAGE_NODE:
; 1022 :            case RAW_VERTEX_AVERAGE_NODE:
; 1023 :            case RAWEST_VERTEX_AVERAGE_NODE:
; 1024 :              if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN436@makenode

; 1025 :                kb_error(2219,"No vertex_average in simplex model yet.\n",
; 1026 :                  COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CJ@LGIFMPGA@No?5vertex_average?5in?5simplex?5mod@
	push	2219					; 000008abH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN436@makenode:

; 1027 :              if ( (etype != VERTEX) )

	cmp	DWORD PTR _etype$[ebp], 0
	je	$LN445@makenode

; 1028 :                kb_error(1238,"Can vertex_average only vertices.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CD@MCCPHKEO@Can?5vertex_average?5only?5vertices@
	push	1238					; 000004d6H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1029 :              break;

	jmp	$LN445@makenode
$LN434@makenode:

; 1030 :            case DELETE_NODE: 
; 1031 :              if ( (etype != EDGE) && (etype != FACET) )

	cmp	esi, 1
	je	$LN445@makenode
	cmp	esi, 2
	je	$LN445@makenode

; 1032 :                kb_error(1392,"Can delete only edges or facets.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CC@GEOLKELN@Can?5delete?5only?5edges?5or?5facets?4@
	push	1392					; 00000570H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1033 :              break;

	jmp	$LN445@makenode
$LN432@makenode:

; 1034 : 
; 1035 :            case REVERSE_ORIENTATION_NODE: 
; 1036 :              if ( (etype != EDGE) && (etype != FACET) )

	cmp	esi, 1
	je	$LN445@makenode
	cmp	esi, 2
	je	$LN445@makenode

; 1037 :                kb_error(4392,"Can reverse_orientation only edges or facets.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CP@NADDAGOO@Can?5reverse_orientation?5only?5edg@
	push	4392					; 00001128H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1038 :              break;

	jmp	$LN445@makenode
$LN430@makenode:

; 1039 : 
; 1040 :            case POP_NODE:
; 1041 :              if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN429@makenode

; 1042 :                 kb_error(2432,"Can pop only in SOAPFILM or STRING model.\n",
; 1043 :                   COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CL@CDLLBBI@Can?5pop?5only?5in?5SOAPFILM?5or?5STRI@
	push	2432					; 00000980H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN429@makenode:

; 1044 :              if ( (etype != EDGE) && (etype != VERTEX) )

	mov	eax, DWORD PTR _etype$[ebp]
	cmp	eax, 1
	je	SHORT $LN862@makenode
	test	eax, eax
	je	$LN445@makenode

; 1045 :                 kb_error(2433,"Can pop only edges or vertices.\n",
; 1046 :                   COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CB@PCAOINFN@Can?5pop?5only?5edges?5or?5vertices?4?6@
	push	2433					; 00000981H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1047 :              if ( (etype == EDGE) && (web.representation==STRING) )

	jmp	$LN445@makenode
$LN862@makenode:
	cmp	DWORD PTR _web+624, 1
	jne	$LN445@makenode

; 1048 :                 kb_error(2434,"Can pop edges only in soapfilm model.\n",
; 1049 :                    COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CH@DOEIMLPB@Can?5pop?5edges?5only?5in?5soapfilm?5m@
	push	2434					; 00000982H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1050 :              break;

	jmp	$LN445@makenode
$LN426@makenode:

; 1051 : 
; 1052 :            case POP_TRI_TO_EDGE_NODE:
; 1053 :              if ( web.representation != SOAPFILM )

	mov	edi, 2
	cmp	DWORD PTR _web+624, edi
	je	SHORT $LN425@makenode

; 1054 :                 kb_error(2803,"Can pop_tri_to_edge only in SOAPFILM model.\n",
; 1055 :                   COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CN@GANONAHP@Can?5pop_tri_to_edge?5only?5in?5SOAP@
	push	2803					; 00000af3H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN425@makenode:

; 1056 :              if ( etype != FACET )

	cmp	DWORD PTR _etype$[ebp], edi
	je	$LN445@makenode

; 1057 :                 kb_error(2804,"Can pop_tri_to_edge only facets.\n",
; 1058 :                   COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CC@LFHDKCIA@Can?5pop_tri_to_edge?5only?5facets?4@
	push	2804					; 00000af4H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1059 :              break;

	jmp	$LN445@makenode
$LN423@makenode:

; 1060 : 
; 1061 :            case POP_EDGE_TO_TRI_NODE:
; 1062 :              if ( web.representation != SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	je	SHORT $LN422@makenode

; 1063 :                 kb_error(2806,"Can pop_edge_to_tro only in SOAPFILM model.\n",
; 1064 :                   COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CN@KBOFAJEK@Can?5pop_edge_to_tro?5only?5in?5SOAP@
	push	2806					; 00000af6H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN422@makenode:

; 1065 :              if ( etype != EDGE )

	cmp	DWORD PTR _etype$[ebp], 1
	je	$LN445@makenode

; 1066 :                 kb_error(2807,"Can pop_edge_to_tri only edges.\n",
; 1067 :                   COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CB@OEOLOLOG@Can?5pop_edge_to_tri?5only?5edges?4?6@
	push	2807					; 00000af7H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1068 :              break;

	jmp	$LN445@makenode
$LN420@makenode:

; 1069 : 
; 1070 :            case POP_QUAD_TO_QUAD_NODE:
; 1071 :              if ( web.representation != SOAPFILM )

	mov	edi, 2
	cmp	DWORD PTR _web+624, edi
	je	SHORT $LN419@makenode

; 1072 :                 kb_error(2808,"Can pop_quad_to_quad only in SOAPFILM model.\n",
; 1073 :                   COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CO@JJDGKHGD@Can?5pop_quad_to_quad?5only?5in?5SOA@
	push	2808					; 00000af8H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN419@makenode:

; 1074 :              if ( etype != FACET )

	cmp	DWORD PTR _etype$[ebp], edi
	je	$LN445@makenode

; 1075 :                 kb_error(2809,"Can pop_quad_to_quad only facets.\n",
; 1076 :                   COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CD@BKBGNKOH@Can?5pop_quad_to_quad?5only?5facets@
	push	2809					; 00000af9H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1077 :              break;

	jmp	$LN445@makenode
$LN417@makenode:

; 1078 : 
; 1079 :            case EDGESWAP_NODE: 
; 1080 :              if ( web.representation != SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	je	SHORT $LN416@makenode

; 1081 :                 kb_error(1393,"Can edgeswap only in the SOAPFILM model. Did you mean t1_edgeswap?\n",
; 1082 :                    COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0EE@OBDAOELG@Can?5edgeswap?5only?5in?5the?5SOAPFIL@
	push	1393					; 00000571H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN416@makenode:

; 1083 :              if ( (etype != EDGE) )

	cmp	DWORD PTR _etype$[ebp], 1
	je	$LN445@makenode

; 1084 :                 kb_error(1394,"Can edgeswap only edges.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BK@IADKNDDN@Can?5edgeswap?5only?5edges?4?6?$AA@
	push	1394					; 00000572H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1085 :              break;

	jmp	$LN445@makenode
$LN414@makenode:

; 1086 : 
; 1087 :            case T1_EDGESWAP_NODE: 
; 1088 :              if ( web.representation != STRING )

	cmp	DWORD PTR _web+624, 1
	je	SHORT $LN413@makenode

; 1089 :                 kb_error(3910,"Can t1_edgeswap only in the STRING model.\n",
; 1090 :                    COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CL@IPOKAHAD@Can?5t1_edgeswap?5only?5in?5the?5STRI@
	push	3910					; 00000f46H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN413@makenode:

; 1091 :              if ( (etype != EDGE) )

	cmp	DWORD PTR _etype$[ebp], 1
	je	$LN445@makenode

; 1092 :                 kb_error(3657,"Can t1_edgeswap only edges.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BN@LIFJJDEB@Can?5t1_edgeswap?5only?5edges?4?6?$AA@
	push	3657					; 00000e49H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1093 :              break;

	jmp	$LN445@makenode
$LN411@makenode:

; 1094 : 
; 1095 :            case EQUIANGULATE_NODE: 
; 1096 :              if ( web.representation != SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	je	SHORT $LN410@makenode

; 1097 :                 kb_error(2500,"Can equiangulate only in the SOAPFILM model.\n",
; 1098 :                    COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CO@ODOECMFJ@Can?5equiangulate?5only?5in?5the?5SOA@
	push	2500					; 000009c4H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN410@makenode:

; 1099 :              if ( (etype != EDGE) )

	cmp	DWORD PTR _etype$[ebp], 1
	je	$LN445@makenode

; 1100 :                 kb_error(2501,"Can edgeswap only edges.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BK@IADKNDDN@Can?5edgeswap?5only?5edges?4?6?$AA@
	push	2501					; 000009c5H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1101 :              break;

	jmp	$LN445@makenode
$LN408@makenode:

; 1102 : 
; 1103 :            case REFINE_NODE: 
; 1104 :              if ( (etype != EDGE) && (etype != FACET) )

	cmp	esi, 1
	je	$LN445@makenode
	cmp	esi, 2
	je	$LN445@makenode

; 1105 :                 kb_error(1241,"Can refine only edges or facets.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CC@NKHDEADJ@Can?5refine?5only?5edges?5or?5facets?4@
	push	1241					; 000004d9H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1106 : 
; 1107 :              break;

	jmp	$LN445@makenode
$LN406@makenode:

; 1108 :            case SET_NO_DISPLAY_NODE: 
; 1109 :              if ( etype != FACET )

	cmp	esi, 2
	je	$LN445@makenode

; 1110 :                 kb_error(1265,"No_display only applies to facets.\n",
; 1111 :                    COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CE@NBPCEGGM@No_display?5only?5applies?5to?5facet@
	push	1265					; 000004f1H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1112 :              break;

	jmp	$LN445@makenode
$LN404@makenode:

; 1113 :            case SET_NONCONTENT_NODE: 
; 1114 :              if ( (etype != EDGE) && (etype != FACET) )

	cmp	esi, 1
	je	$LN445@makenode
	cmp	esi, 2
	je	$LN445@makenode

; 1115 :                 kb_error(2902,"Noncontent only applies to edges or facets.\n",
; 1116 :                    COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CN@BJGPMAKA@Noncontent?5only?5applies?5to?5edges@
	push	2902					; 00000b56H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1117 :              break;

	jmp	$LN445@makenode
$LN402@makenode:

; 1118 :            case SET_HIT_PARTNER_NODE: 
; 1119 :              if ( etype != VERTEX )

	test	esi, esi
	je	$LN445@makenode

; 1120 :                 kb_error(3001,"Hit_partner only applies to vertices.\n",
; 1121 :                    COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CH@BLOJFOKI@Hit_partner?5only?5applies?5to?5vert@
	push	3001					; 00000bb9H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1122 :              break;

	jmp	$LN445@makenode
$LN400@makenode:

; 1123 :            case SET_NO_REFINE_NODE: 
; 1124 :              if ( (etype != EDGE) && (etype != FACET) )

	cmp	esi, 1
	je	$LN445@makenode
	cmp	esi, 2
	je	$LN445@makenode

; 1125 :                 kb_error(1395,"No_refine only applies to edges or facets.\n",
; 1126 :                    COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CM@MKPPBFFJ@No_refine?5only?5applies?5to?5edges?5@
	push	1395					; 00000573H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1127 :              break;

	jmp	$LN445@makenode
$LN398@makenode:

; 1128 :            case SET_NO_TRANSFORM_NODE: 
; 1129 :              if ( (etype != EDGE) && (etype != FACET) )

	cmp	esi, 1
	je	$LN445@makenode
	cmp	esi, 2
	je	$LN445@makenode

; 1130 :                 kb_error(3033,"No_transform only applies to edges or facets.\n",
; 1131 :                    COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CP@MGPBKJPH@No_transform?5only?5applies?5to?5edg@
	push	3033					; 00000bd9H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1132 :              break;

	jmp	$LN445@makenode
$LN396@makenode:

; 1133 :            case SET_CONSTRAINT_NODE:
; 1134 :            case UNSET_CONSTRAINT_NODE:
; 1135 :            case SET_BOUNDARY_NODE:
; 1136 :            case UNSET_BOUNDARY_NODE:
; 1137 :               list[listtop].stack_delta = -1;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+156], -1

; 1138 :               break;

	jmp	$LN445@makenode
$LN395@makenode:

; 1139 :            case SET_EXTRA_ATTR_NODE:
; 1140 :             { struct extra *ex;
; 1141 :               ex = EXTRAS(etype);

	imul	esi, 112				; 00000070H
	mov	edi, DWORD PTR _web[esi+104]
	add	edi, DWORD PTR _dymem

; 1142 :               for ( n = 0 ; n < web.skel[etype].extra_count ; n++,ex++ )

	xor	ebx, ebx
	cmp	ebx, DWORD PTR _web[esi+108]
	jge	SHORT $LN917@makenode
$LL394@makenode:

; 1143 :               if ( stricmp(ex->name,set_extra_name) == 0 ) break;

	push	OFFSET _set_extra_name
	push	edi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN905@makenode

; 1142 :               for ( n = 0 ; n < web.skel[etype].extra_count ; n++,ex++ )

	inc	ebx
	add	edi, 240				; 000000f0H
	cmp	ebx, DWORD PTR _web[esi+108]
	jl	SHORT $LL394@makenode
$LN905@makenode:

; 1144 :               if ( n == web.skel[etype].extra_count )

	cmp	ebx, DWORD PTR _web[esi+108]
$LN917@makenode:
	jne	SHORT $LN390@makenode

; 1145 :                 kb_error(1396,"Internal error: Invalid extra attribute number.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DB@LJLNLDOK@Internal?5error?3?5Invalid?5extra?5at@
	push	1396					; 00000574H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN390@makenode:

; 1146 :               n += etype << ESHIFT; /* handy to have type here */
; 1147 :               list[listtop].op3.extra_info = n;

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _etype$[ebp]
	imul	eax, 168				; 000000a8H
	mov	ecx, DWORD PTR _list
	shl	edx, 12					; 0000000cH
	add	edx, ebx
	mov	DWORD PTR [eax+ecx+140], edx

; 1148 :               list[listtop].flags |= EPHEMERAL;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	or	DWORD PTR [edx+eax+24], 64		; 00000040H
	lea	eax, DWORD PTR [edx+eax+24]

; 1149 :               list[listtop].stack_delta = -ex->array_spec.dim-1;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	or	ecx, -1
	sub	ecx, DWORD PTR [edi+76]
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], ecx

; 1150 :             }
; 1151 :             break;

	jmp	SHORT $LN445@makenode
$LN587@makenode:

; 993  :          /* some type error checking and stuff */
; 994  :          switch ( aggrtype )

	add	eax, -10339				; ffffd79dH
	cmp	eax, 6
	ja	SHORT $LN445@makenode

; 995  :          {
; 996  :            case SUM_NODE: case AVG_NODE: case COUNT_NODE: case HISTOGRAM_NODE:
; 997  :            case LOGHISTOGRAM_NODE: case MAX_NODE: case MIN_NODE:
; 998  :              list[listtop].stack_delta = -1; break;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+156], -1
$LN445@makenode:

; 1152 :           }
; 1153 :         if ( (aggrtype >= SET_COORD_NODE) && (aggrtype <= SET_COORD_NODE + MAXCOORD))

	mov	eax, DWORD PTR _aggrtype
	lea	ecx, DWORD PTR [eax-10314]
	cmp	ecx, 6
	ja	SHORT $LN389@makenode

; 1154 :         { list[listtop].type = SET_COORD_NODE;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax], 10314		; 0000284aH

; 1155 :           n = aggrtype - SET_COORD_NODE - 1; 

	mov	esi, DWORD PTR _aggrtype
	add	esi, -10315				; ffffd7b5H

; 1156 :           if ( n >= SDIM )

	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LN886@makenode

; 1157 :              kb_error(2220,"Coordinate dimension exceeds space dimension.\n",
; 1158 :                COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CP@EEKPMBAG@Coordinate?5dimension?5exceeds?5spa@
	push	2220					; 000008acH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN886@makenode:

; 1159 :           if ( etype != VERTEX )

	cmp	DWORD PTR _etype$[ebp], 0
	je	SHORT $LN387@makenode

; 1160 :              kb_error(1398,"Can set coordinates only for vertices.\n",
; 1161 :                   COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CI@GEMLFPAO@Can?5set?5coordinates?5only?5for?5ver@
	push	1398					; 00000576H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN387@makenode:

; 1162 :           list[listtop].op2.coordnum = n;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+136], esi
	jmp	$LN878@makenode
$LN389@makenode:

; 1163 :         }
; 1164 :         else if ((aggrtype>=SET_PARAM_NODE) && (aggrtype <= SET_PARAM_NODE+MAXPARAM))

	add	eax, -10325				; ffffd7abH
	cmp	eax, 6
	ja	SHORT $LN385@makenode

; 1165 :         { list[listtop].type = SET_PARAM_NODE;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], 10325		; 00002855H

; 1166 :           list[listtop].op2.coordnum = aggrtype - SET_PARAM_NODE - 1; 

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _aggrtype
	imul	eax, 168				; 000000a8H
	mov	ecx, DWORD PTR _list
	add	edx, -10326				; ffffd7aaH

; 1167 :           if ( etype != VERTEX )

	cmp	DWORD PTR _etype$[ebp], 0
	mov	DWORD PTR [eax+ecx+136], edx
	je	$LN878@makenode

; 1168 :              kb_error(1399,"Can set parameters only for vertices.\n",
; 1169 :                   COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CH@DHGEIJOF@Can?5set?5parameters?5only?5for?5vert@
	push	1399					; 00000577H
	call	_kb_error

; 1170 :         }
; 1171 :         else list[listtop].op2.eltype = etype;

	jmp	$LN907@makenode
$LN385@makenode:
	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _etype$[ebp]
	mov	DWORD PTR [edx+eax+136], ecx

; 1172 :         break;

	jmp	$LN878@makenode
$LN375@makenode:

; 1206 :          
; 1207 : 
; 1208 : /* Element generator.
; 1209 : Tree:              WHERE_
; 1210 :                   /      \
; 1211 :            element_gen    expr
; 1212 : 
; 1213 : 
; 1214 :                 SINGLE_ELEMENT_
; 1215 :                 /         
; 1216 :               INDEXED_SUBTYPE_
; 1217 :              /             \
; 1218 :           single        expr
; 1219 : 
; 1220 :              INDEXED_ELEMENT_
; 1221 :              /
; 1222 :           expr
; 1223 : 
; 1224 :          SYMBOL_ELEMENT_
; 1225 : 
; 1226 :               NEXT_ELEMENT_
; 1227 :               /
; 1228 :          INIT_ELEMENT_
; 1229 : 
; 1230 : 
; 1231 : */
; 1232 :       case INIT_ELEMENT_NODE:
; 1233 :         if ( (list[listtop-1].type != AGGREGATE_INIT_NODE)
; 1234 :            && (list[listtop-1].type != SET_INIT_NODE) )

	mov	ebx, DWORD PTR _listtop
	mov	edx, ebx
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [edx+eax-168]
	cmp	ecx, 10240				; 00002800H
	je	$LN371@makenode
	cmp	ecx, 10239				; 000027ffH
	je	$LN371@makenode

; 1235 :         { int k;  /* for break and continue */
; 1236 :           int n;
; 1237 :           i = add_local_var(NULL,1);

	push	1
	push	0
	call	_add_local_var

; 1238 :           n = get_local(i).offset;

	mov	ecx, DWORD PTR _localbase
	mov	edx, DWORD PTR [ecx]

; 1239 :           list[listtop].stackpos = n; 

	mov	ecx, DWORD PTR _listtop
	and	eax, 16777215				; 00ffffffH
	imul	ecx, 168				; 000000a8H
	imul	eax, 224				; 000000e0H
	mov	eax, DWORD PTR [eax+edx+216]
	mov	edx, DWORD PTR _list
	mov	DWORD PTR [ecx+edx+160], eax

; 1240 :           for ( k = listtop-1; k >= 0 ; k-- )

	mov	ebx, DWORD PTR _listtop
	lea	ecx, DWORD PTR [ebx-1]
	add	esp, 8
	mov	DWORD PTR _n$89765[ebp], eax
	mov	eax, DWORD PTR _list
	test	ecx, ecx
	js	SHORT $LN371@makenode

; 1235 :         { int k;  /* for break and continue */
; 1236 :           int n;
; 1237 :           i = add_local_var(NULL,1);

	mov	edx, ecx
	imul	edx, 168				; 000000a8H
	add	edx, eax
	npad	2
$LL373@makenode:

; 1241 :            if ( list[k].type==AGGREGATE_INIT_NODE ||
; 1242 :              list[k].type==SET_INIT_NODE )

	mov	edi, DWORD PTR [edx]
	cmp	edi, 10240				; 00002800H
	je	SHORT $LN844@makenode
	cmp	edi, 10239				; 000027ffH
	je	SHORT $LN844@makenode

; 1240 :           for ( k = listtop-1; k >= 0 ; k-- )

	sub	edx, 168				; 000000a8H
	dec	ecx
	jns	SHORT $LL373@makenode

; 1273 :            if ( list[k].type==AGGREGATE_INIT_NODE ||
; 1274 :             list[k].type==SET_INIT_NODE )

	jmp	SHORT $LN371@makenode
$LN844@makenode:

; 1243 :            { list[k].stackpos = n; break; }

	mov	edx, DWORD PTR _n$89765[ebp]
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax+160], edx
	mov	ebx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
$LN371@makenode:

; 1244 :         }
; 1245 :         list[listtop].op1.eltype = left; /* save type */

	imul	ebx, 168				; 000000a8H
	mov	DWORD PTR [ebx+eax+32], esi

; 1246 :         list[listtop].op2.localnum = use_given_id ? 0 : add_local_var(NULL,1);

	cmp	DWORD PTR _use_given_id, 0
	je	SHORT $LN588@makenode
	xor	eax, eax
	jmp	SHORT $LN589@makenode
$LN588@makenode:
	push	1
	push	0
	call	_add_local_var
	add	esp, 8
$LN589@makenode:
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+136], eax

; 1247 :         /* op5.string will have name, if any */
; 1248 :         switch ( left )

	cmp	esi, 4
	ja	SHORT $LN361@makenode
	jmp	DWORD PTR $LN958@makenode[esi*4]
$LN366@makenode:

; 1249 :         { case VERTEX: etype = INIT_VERTEX_NODE; break;

	mov	eax, 10454				; 000028d6H
	jmp	SHORT $LN367@makenode
$LN365@makenode:

; 1250 :           case EDGE  : etype = INIT_EDGE_NODE  ; break;

	mov	eax, 10458				; 000028daH
	jmp	SHORT $LN367@makenode
$LN364@makenode:

; 1251 :           case FACET : etype = INIT_FACET_NODE ; break;

	mov	eax, 10462				; 000028deH
	jmp	SHORT $LN367@makenode
$LN363@makenode:

; 1252 :           case BODY  : etype = INIT_BODY_NODE  ; break;

	mov	eax, 10469				; 000028e5H
	jmp	SHORT $LN367@makenode
$LN362@makenode:

; 1253 :           case FACETEDGE  : etype = INIT_FACETEDGE_NODE  ; break;

	mov	eax, 10473				; 000028e9H
	jmp	SHORT $LN367@makenode
$LN361@makenode:

; 1254 :           default : kb_error(1401,"Internal error: Bad INIT_ELEMENT_NODE type.\n",
; 1255 :              COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CN@LOKJCEML@Internal?5error?3?5Bad?5INIT_ELEMENT@
	push	1401					; 00000579H
	call	_kb_error
	mov	eax, DWORD PTR _etype$[ebp]
	add	esp, 12					; 0000000cH
$LN367@makenode:

; 1256 : 
; 1257 :         }
; 1258 :         list[listtop].type = etype;

	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx], eax

; 1259 :         list[listtop].stack_delta = 3;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+156], 3

; 1260 :         break;

	jmp	$LN878@makenode
$LN360@makenode:

; 1264 :          list[listtop].op1.eltype = etype; /* save type */

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+32], edi

; 1265 :          list[listtop].left = left - listtop; /* single element */

	mov	eax, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	mov	ecx, esi

; 1266 :          list[listtop].op2.localnum = list[left].op2.localnum;

	imul	esi, 168				; 000000a8H
	sub	ecx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+4], ecx
	mov	ecx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [esi+eax+136]

; 1267 :          { int k;  /* for break and continue */
; 1268 :            int n;
; 1269 :            i = add_local_var(NULL,1);

	push	1
	push	0
	mov	ebx, edi
	mov	DWORD PTR [ecx+eax+136], edx
	call	_add_local_var

; 1270 :            n = get_local(i).offset;

	mov	ecx, DWORD PTR _localbase
	mov	edx, DWORD PTR [ecx]

; 1271 :            list[listtop].stackpos = 0;

	mov	ecx, DWORD PTR _listtop
	and	eax, 16777215				; 00ffffffH
	imul	ecx, 168				; 000000a8H
	imul	eax, 224				; 000000e0H
	mov	eax, DWORD PTR [eax+edx+216]
	mov	edx, DWORD PTR _list
	mov	DWORD PTR [ecx+edx+160], 0

; 1272 :            for ( k = listtop-1; k >= 0 ; k-- )

	mov	ecx, DWORD PTR _listtop
	add	esp, 8
	dec	ecx
	js	SHORT $LN877@makenode

; 1261 :  
; 1262 :       case INIT_SUBELEMENT_NODE: /* subelement of named element */
; 1263 :          etype = right;

	mov	edx, ecx
	imul	edx, 168				; 000000a8H
	add	edx, DWORD PTR _list
	npad	3
$LL359@makenode:

; 1273 :            if ( list[k].type==AGGREGATE_INIT_NODE ||
; 1274 :             list[k].type==SET_INIT_NODE )

	mov	ebx, DWORD PTR [edx]
	cmp	ebx, 10240				; 00002800H
	je	SHORT $LN845@makenode
	cmp	ebx, 10239				; 000027ffH
	je	SHORT $LN845@makenode

; 1272 :            for ( k = listtop-1; k >= 0 ; k-- )

	sub	edx, 168				; 000000a8H
	dec	ecx
	jns	SHORT $LL359@makenode

; 1273 :            if ( list[k].type==AGGREGATE_INIT_NODE ||
; 1274 :             list[k].type==SET_INIT_NODE )

	jmp	SHORT $LN918@makenode
$LN845@makenode:

; 1275 :              { list[k].stackpos = n; break; }

	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+160], eax
$LN918@makenode:
	mov	ebx, edi
$LN877@makenode:

; 1276 :          }
; 1277 :         
; 1278 :          switch ( list[left].op1.eltype ) /* parent type */

	mov	eax, DWORD PTR _list
	mov	esi, DWORD PTR [esi+eax+32]
	mov	ecx, 3
	cmp	esi, 4
	ja	$LN310@makenode
	jmp	DWORD PTR $LN959@makenode[esi*4]
$LN352@makenode:

; 1279 :          { case VERTEX:
; 1280 :              switch ( etype )

	mov	eax, edi
	dec	eax
	je	SHORT $LN349@makenode
	dec	eax
	je	SHORT $LN347@makenode
	dec	eax
	je	SHORT $LN346@makenode

; 1290 :                default : kb_error(1403,"Cannot do vertices of vertex.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BP@JGHIEHPG@Cannot?5do?5vertices?5of?5vertex?4?6?$AA@
	push	1403					; 0000057bH
	jmp	$LN919@makenode
$LN346@makenode:

; 1289 :                case BODY  : etype = INIT_VERTEX_BODY_NODE  ; break;

	mov	ebx, 10471				; 000028e7H
	jmp	$LN906@makenode
$LN347@makenode:

; 1286 :                  break;
; 1287 :                case FACET : etype = INIT_VERTEX_FACET_NODE ;

	mov	ebx, 10463				; 000028dfH

; 1288 :                  break;

	jmp	$LN906@makenode
$LN349@makenode:

; 1281 :              { 
; 1282 :                case EDGE  : etype = INIT_VERTEX_EDGE_NODE  ;

	mov	ebx, 10459				; 000028dbH

; 1283 :                  if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, ecx
	jne	$LN906@makenode

; 1284 :                    kb_error(1402,"Vertex edge iterator not valid in simplex model.\n",
; 1285 :                   COMMAND_ERROR); 

	push	5
	push	OFFSET ??_C@_0DC@MBIBHGFE@Vertex?5edge?5iterator?5not?5valid?5i@
	push	1402					; 0000057aH

; 1291 :              } 
; 1292 :              break;

	jmp	$LN919@makenode
$LN344@makenode:

; 1293 :           case EDGE:
; 1294 :              switch ( etype )

	cmp	edi, 4
	ja	SHORT $LN334@makenode
	jmp	DWORD PTR $LN960@makenode[edi*4]
$LN341@makenode:

; 1295 :              { case VERTEX: etype = INIT_EDGE_VERTEX_NODE; break;

	mov	ebx, 10455				; 000028d7H
	jmp	$LN906@makenode
$LN340@makenode:

; 1296 :                case EDGE : kb_error(1406,"Cannot do edges of edge.\n",
; 1297 :                     COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BK@GMAAKKCE@Cannot?5do?5edges?5of?5edge?4?6?$AA@
	push	1406					; 0000057eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN887@makenode:

; 1298 :                case FACET : etype = INIT_EDGE_FACET_NODE ; 
; 1299 :                   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	mov	ebx, 10466				; 000028e2H
	jne	$LN906@makenode

; 1300 :                     kb_error(1404,"Edge facet iterator not valid in simplex model.\n",
; 1301 :                       COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DB@NGHEKADF@Edge?5facet?5iterator?5not?5valid?5in@
	push	1404					; 0000057cH

; 1302 :                   break;

	jmp	$LN919@makenode
$LN337@makenode:

; 1303 :                case BODY  : etype = INIT_EDGE_BODY_NODE  ;

	mov	ebx, 10472				; 000028e8H

; 1304 :                   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, ecx
	jne	$LN906@makenode

; 1305 :                       kb_error(1405,"Edge body iterator not valid in simplex model.\n",
; 1306 :                         COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DA@BBLKODON@Edge?5body?5iterator?5not?5valid?5in?5@
	push	1405					; 0000057dH

; 1307 :                   break;

	jmp	$LN919@makenode
$LN335@makenode:

; 1308 :                case FACETEDGE: etype = INIT_EDGE_FACETEDGE_NODE ;

	mov	ebx, 10467				; 000028e3H

; 1309 :                   break;

	jmp	$LN906@makenode
$LN334@makenode:

; 1310 :                default : kb_error(2830,"Cannot do facetedges of edge.\n",
; 1311 :                  COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BP@EKOGCLLJ@Cannot?5do?5facetedges?5of?5edge?4?6?$AA@
	push	2830					; 00000b0eH

; 1312 :              } 
; 1313 :              break;

	jmp	$LN919@makenode
$LN333@makenode:

; 1314 :           case FACET:
; 1315 :             switch ( etype )

	cmp	edi, 4
	ja	SHORT $LN888@makenode
	jmp	DWORD PTR $LN961@makenode[edi*4]
$LN330@makenode:

; 1316 :              { case VERTEX: etype = INIT_FACET_VERTEX_NODE; break;

	mov	ebx, 10456				; 000028d8H
	jmp	$LN906@makenode
$LN329@makenode:

; 1317 :                case EDGE  : etype = INIT_FACET_EDGE_NODE  ; 

	mov	ebx, 10460				; 000028dcH

; 1318 :                  if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, ecx
	jne	$LN906@makenode

; 1319 :                    kb_error(1407,"Facet edge iterator not valid in simplex model.\n",
; 1320 :                   COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DB@CEOGHBOA@Facet?5edge?5iterator?5not?5valid?5in@
	push	1407					; 0000057fH

; 1321 :                  break;

	jmp	$LN919@makenode
$LN327@makenode:

; 1322 :                case BODY  : etype = INIT_FACET_BODY_NODE  ;

	mov	ebx, 10470				; 000028e6H

; 1323 :                  if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, ecx
	jne	$LN906@makenode

; 1324 :                     kb_error(1408,"Facet body iterator not valid in simplex model.\n",
; 1325 :                       COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DB@KGBAHOPI@Facet?5body?5iterator?5not?5valid?5in@
	push	1408					; 00000580H

; 1326 :                  break;

	jmp	$LN919@makenode
$LN325@makenode:

; 1327 :                case FACETEDGE : kb_error(3755,"Cannot do facetedges of facet.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CA@JEMKGOCB@Cannot?5do?5facetedges?5of?5facet?4?6?$AA@
	push	3755					; 00000eabH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN888@makenode:

; 1328 :                default : kb_error(1409,"Cannot do facets of facet.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BM@HJDHIACA@Cannot?5do?5facets?5of?5facet?4?6?$AA@
	push	1409					; 00000581H

; 1329 :              } 
; 1330 :              break;

	jmp	SHORT $LN919@makenode
$LN323@makenode:

; 1331 :           case BODY:
; 1332 :             switch ( etype )

	mov	eax, edi
	sub	eax, 0
	je	SHORT $LN320@makenode
	dec	eax
	je	SHORT $LN319@makenode
	dec	eax
	je	SHORT $LN318@makenode

; 1336 :                default : kb_error(1410,"Internal error: Bad INIT_ELEMENT_NODE type.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0CN@LOKJCEML@Internal?5error?3?5Bad?5INIT_ELEMENT@
	push	1410					; 00000582H
	jmp	SHORT $LN919@makenode
$LN318@makenode:

; 1335 :                case FACET : etype = INIT_BODY_FACET_NODE ; break;

	mov	ebx, 10468				; 000028e4H
	jmp	SHORT $LN906@makenode
$LN319@makenode:

; 1334 :                case EDGE  : etype = INIT_BODY_EDGE_NODE  ; break;

	mov	ebx, 10461				; 000028ddH
	jmp	SHORT $LN906@makenode
$LN320@makenode:

; 1333 :              { case VERTEX: etype = INIT_BODY_VERTEX_NODE; break;

	mov	ebx, 10457				; 000028d9H

; 1337 :              } 
; 1338 :              break;

	jmp	SHORT $LN906@makenode
$LN316@makenode:

; 1339 :           case FACETEDGE:
; 1340 :             switch ( etype )

	mov	eax, edi
	dec	eax
	je	SHORT $LN313@makenode
	dec	eax
	je	SHORT $LN312@makenode

; 1344 :                default : kb_error(3914,"Facetedge can only have edge or facet subelement.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0DD@IKPOJIMJ@Facetedge?5can?5only?5have?5edge?5or?5@
	push	3914					; 00000f4aH
	jmp	SHORT $LN919@makenode
$LN312@makenode:

; 1343 :                case FACET : etype = INIT_FACETEDGE_FACET_NODE ; break;

	mov	ebx, 10465				; 000028e1H
	jmp	SHORT $LN906@makenode
$LN313@makenode:

; 1341 :              { 
; 1342 :                case EDGE  : etype = INIT_FACETEDGE_EDGE_NODE  ; break;

	mov	ebx, 10464				; 000028e0H

; 1345 :              } 
; 1346 :              break;

	jmp	SHORT $LN906@makenode
$LN310@makenode:

; 1347 : 
; 1348 :           default: kb_error(1411,"Cannot do bodies of body.\n",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BL@HGGLGGIP@Cannot?5do?5bodies?5of?5body?4?6?$AA@
	push	1411					; 00000583H
$LN919@makenode:
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN906@makenode:

; 1349 : 
; 1350 :          }  
; 1351 :          list[listtop].type = etype;

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx], ebx

; 1352 :          list[listtop].stack_delta = 3;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	DWORD PTR [edx+eax+156], 3

; 1353 :          break;

	jmp	$LN878@makenode
$LN309@makenode:

; 1354 :  
; 1355 :       case NEXT_ELEMENT_NODE:
; 1356 :          list[listtop].left = left - listtop;  /* element initializer */

	mov	ecx, DWORD PTR _listtop
	mov	edx, esi
	sub	edx, ecx
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax+4], edx

; 1357 :          /* op5.string will have name, if any */
; 1358 :          /* op2.localnum will point to iteration local variable */
; 1359 :          /* op1 reserved for jump to end of loop */
; 1360 :          /* left->op2.localnum will point to parent */
; 1361 :          list[listtop].op2.localnum = (use_given_id && (loopdepth==0)) ? 0 : add_local_var(NULL,1);

	cmp	DWORD PTR _use_given_id, 0
	je	SHORT $LN590@makenode
	cmp	DWORD PTR _loopdepth, 0
	jne	SHORT $LN590@makenode
	xor	eax, eax
	jmp	SHORT $LN591@makenode
$LN590@makenode:
	push	1
	push	0
	call	_add_local_var
	add	esp, 8
$LN591@makenode:
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+edx+136], eax

; 1362 :          if ( loopdepth > 0 ) 

	mov	eax, DWORD PTR _loopdepth
	test	eax, eax
	jle	SHORT $LN308@makenode

; 1363 :            list[loopbase[loopdepth-1]].op4.contjump = 
; 1364 :              listtop-loopbase[loopdepth-1]-1;  /* CONTINUE to here */

	mov	eax, DWORD PTR _loopbase[eax*4-4]
	mov	ecx, DWORD PTR _listtop
	mov	edx, DWORD PTR _list
	sub	ecx, eax
	dec	ecx
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+edx+148], ecx
$LN308@makenode:

; 1365 :          switch ( list[left].type ) /* parent type */

	mov	eax, DWORD PTR _list
	imul	esi, 168				; 000000a8H
	mov	esi, DWORD PTR [esi+eax]
	lea	eax, DWORD PTR [esi-10454]
	cmp	eax, 19					; 00000013H
	ja	$LN285@makenode
	jmp	DWORD PTR $LN962@makenode[eax*4]
$LN305@makenode:

; 1366 :         { 
; 1367 :           case INIT_VERTEX_EDGE_NODE  : type = NEXT_VERTEX_EDGE_NODE  ; break;

	mov	eax, 10247				; 00002807H
	jmp	$LN306@makenode
$LN304@makenode:

; 1368 :           case INIT_VERTEX_FACET_NODE : type = NEXT_VERTEX_FACET_NODE ; break;

	mov	eax, 10253				; 0000280dH
	jmp	$LN306@makenode
$LN303@makenode:

; 1369 :           case INIT_VERTEX_BODY_NODE  : type = NEXT_VERTEX_BODY_NODE  ; break;

	mov	eax, 10257				; 00002811H
	jmp	$LN306@makenode
$LN302@makenode:

; 1370 :           case INIT_EDGE_VERTEX_NODE : type = NEXT_EDGE_VERTEX_NODE ; break;

	mov	eax, 10243				; 00002803H
	jmp	$LN306@makenode
$LN301@makenode:

; 1371 :           case INIT_EDGE_FACET_NODE : type = NEXT_EDGE_FACET_NODE ; break;

	mov	eax, 10251				; 0000280bH
	jmp	$LN306@makenode
$LN300@makenode:

; 1372 :           case INIT_EDGE_FACETEDGE_NODE : type = NEXT_EDGE_FACETEDGE_NODE ; break;

	mov	eax, 10252				; 0000280cH
	jmp	$LN306@makenode
$LN299@makenode:

; 1373 :           case INIT_EDGE_BODY_NODE  : type = NEXT_EDGE_BODY_NODE  ; break;

	mov	eax, 10258				; 00002812H
	jmp	$LN306@makenode
$LN298@makenode:

; 1374 :           case INIT_FACET_VERTEX_NODE: type = NEXT_FACET_VERTEX_NODE; break;

	mov	eax, 10244				; 00002804H
	jmp	$LN306@makenode
$LN297@makenode:

; 1375 :           case INIT_FACET_EDGE_NODE  : type = NEXT_FACET_EDGE_NODE  ; break;

	mov	eax, 10248				; 00002808H
	jmp	SHORT $LN306@makenode
$LN296@makenode:

; 1376 :           case INIT_FACET_BODY_NODE  : type = NEXT_FACET_BODY_NODE  ; break;

	mov	eax, 10256				; 00002810H
	jmp	SHORT $LN306@makenode
$LN295@makenode:

; 1377 :           case INIT_BODY_VERTEX_NODE: type = NEXT_BODY_VERTEX_NODE; break;

	mov	eax, 10245				; 00002805H
	jmp	SHORT $LN306@makenode
$LN294@makenode:

; 1378 :           case INIT_BODY_EDGE_NODE  : type = NEXT_BODY_EDGE_NODE  ; break;

	mov	eax, 10249				; 00002809H
	jmp	SHORT $LN306@makenode
$LN293@makenode:

; 1379 :           case INIT_BODY_FACET_NODE : type = NEXT_BODY_FACET_NODE ; break;

	mov	eax, 10254				; 0000280eH
	jmp	SHORT $LN306@makenode
$LN292@makenode:

; 1380 :           case INIT_VERTEX_NODE: type = NEXT_VERTEX_NODE; break;

	mov	eax, 10242				; 00002802H
	jmp	SHORT $LN306@makenode
$LN291@makenode:

; 1381 :           case INIT_EDGE_NODE  : type = NEXT_EDGE_NODE  ; break;

	mov	eax, 10246				; 00002806H
	jmp	SHORT $LN306@makenode
$LN290@makenode:

; 1382 :           case INIT_FACET_NODE: type = NEXT_FACET_NODE ; break;

	mov	eax, 10250				; 0000280aH
	jmp	SHORT $LN306@makenode
$LN289@makenode:

; 1383 :           case INIT_BODY_NODE  : type = NEXT_BODY_NODE  ; break;

	mov	eax, 10255				; 0000280fH
	jmp	SHORT $LN306@makenode
$LN288@makenode:

; 1384 :           case INIT_FACETEDGE_NODE : type = NEXT_FACETEDGE_NODE; break;

	mov	eax, 10259				; 00002813H
	jmp	SHORT $LN306@makenode
$LN287@makenode:

; 1385 :           case INIT_FACETEDGE_EDGE_NODE: type = NEXT_FACETEDGE_EDGE_NODE; break;

	mov	eax, 10260				; 00002814H
	jmp	SHORT $LN306@makenode
$LN286@makenode:

; 1386 :           case INIT_FACETEDGE_FACET_NODE : type = NEXT_FACETEDGE_FACET_NODE; break;

	mov	eax, 10261				; 00002815H
	jmp	SHORT $LN306@makenode
$LN285@makenode:

; 1387 :           default : 
; 1388 :               sprintf(errmsg,"Internal error: Bad NEXT_ELEMENT_NODE type %d.\n",list[left].type);

	push	esi
	push	OFFSET ??_C@_0DA@POKLEMJB@Internal?5error?3?5Bad?5NEXT_ELEMENT@
	push	OFFSET _errmsg
	call	_sprintf

; 1389 :               kb_error(1412,errmsg,COMMAND_ERROR);

	push	5
	push	OFFSET _errmsg
	push	1412					; 00000584H
	call	_kb_error
	mov	eax, DWORD PTR _type$[ebp]
	add	esp, 24					; 00000018H
$LN306@makenode:

; 1390 : 
; 1391 :         }
; 1392 :          list[listtop].type = type;

	mov	edx, DWORD PTR _listtop
	imul	edx, 168				; 000000a8H
	movsx	ecx, ax
	mov	eax, DWORD PTR _list
	mov	DWORD PTR [edx+eax], ecx

; 1393 :          break;

	jmp	$LN878@makenode
$LN208@makenode:

; 1858 :          break;
; 1859 : 
; 1860 :     case PROCEDURE_PROTO_NODE:
; 1861 :          list[listtop].type = type;

	mov	ecx, DWORD PTR _listtop
	imul	ecx, 168				; 000000a8H
	mov	DWORD PTR [ecx+eax], ebx

; 1862 :          list[listtop].left = left - listtop; /* function head */

	mov	eax, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	mov	edx, esi
	sub	edx, eax
	imul	eax, 168				; 000000a8H
	mov	DWORD PTR [eax+ecx+4], edx

; 1863 :          list[listtop].op1.name_id = list[left].op1.name_id; /* name id */

	mov	edx, DWORD PTR _listtop
	mov	ecx, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	eax, esi
	imul	eax, 168				; 000000a8H
	mov	edi, DWORD PTR [eax+ecx+32]
	mov	DWORD PTR [edx+ecx+32], edi

; 1864 :          n = left + list[left].left;

	mov	edx, DWORD PTR _list
	mov	eax, DWORD PTR [eax+edx+4]
	add	eax, esi

; 1865 :          list[n].op2.jumpsize = listtop - n; /* for PROCEDURE_PROTO_START_ jump */

	mov	esi, DWORD PTR _listtop
	mov	ecx, eax
	imul	ecx, 168				; 000000a8H
	sub	esi, eax
	mov	DWORD PTR [ecx+edx+136], esi

; 1866 :          list[n].type = PROCEDURE_PROTO_START_NODE;

	mov	eax, DWORD PTR _list
	mov	DWORD PTR [ecx+eax], 10057		; 00002749H

; 1867 :          list[listtop].flags |= EPHEMERAL;
; 1868 :          break;

	jmp	$LN252@makenode
$LN2@makenode:

; 2948 : 
; 2949 :     default:
; 2950 :       more_makenode(type,left,right);

	push	edi
	push	esi
	push	ebx
	call	_more_makenode
$LN907@makenode:
	add	esp, 12					; 0000000cH
$LN878@makenode:

; 2951 :       break;
; 2952 :     }
; 2953 : 
; 2954 :   if ( listtop > listmax-2 )

	mov	ecx, DWORD PTR _listmax
	mov	eax, DWORD PTR _listtop
	pop	edi
	add	ecx, -2					; fffffffeH
	pop	esi
	pop	ebx
	cmp	eax, ecx
	jle	SHORT $LN1@makenode

; 2955 :         kb_error(1336,"Expression too long",COMMAND_ERROR);

	push	5
	push	OFFSET ??_C@_0BE@DDBLPGGI@Expression?5too?5long?$AA@
	push	1336					; 00000538H
	call	_kb_error
	mov	eax, DWORD PTR _listtop
	add	esp, 12					; 0000000cH
$LN1@makenode:

; 2956 : 
; 2957 : 
; 2958 :   list[listtop].line_no = line_no;

	mov	edx, DWORD PTR _line_no
	imul	eax, 168				; 000000a8H
	mov	ecx, DWORD PTR _list
	mov	DWORD PTR [eax+ecx+12], edx

; 2959 :   list[listtop].file_no = file_no;

	mov	edx, DWORD PTR _listtop
	mov	eax, DWORD PTR _list
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR _file_no
	mov	DWORD PTR [edx+eax+16], ecx

; 2960 :   return listtop++;

	mov	ecx, DWORD PTR _listtop
	mov	eax, ecx
	inc	ecx
	mov	DWORD PTR _listtop, ecx

; 2961 : 
; 2962 : } // end makenode()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN946@makenode:
	DD	$LN537@makenode
	DD	$LN569@makenode
	DD	$LN568@makenode
	DD	$LN570@makenode
	DD	$LN242@makenode
	DD	$LN571@makenode
	DD	$LN485@makenode
	DD	$LN483@makenode
	DD	$LN480@makenode
	DD	$LN494@makenode
	DD	$LN495@makenode
	DD	$LN218@makenode
	DD	$LN215@makenode
	DD	$LN207@makenode
	DD	$LN204@makenode
	DD	$LN559@makenode
	DD	$LN558@makenode
	DD	$LN471@makenode
	DD	$LN477@makenode
	DD	$LN466@makenode
	DD	$LN566@makenode
	DD	$LN565@makenode
	DD	$LN564@makenode
	DD	$LN556@makenode
	DD	$LN551@makenode
	DD	$LN76@makenode
	DD	$LN241@makenode
	DD	$LN239@makenode
	DD	$LN236@makenode
	DD	$LN233@makenode
	DD	$LN221@makenode
	DD	$LN222@makenode
	DD	$LN226@makenode
	DD	$LN224@makenode
	DD	$LN210@makenode
	DD	$LN212@makenode
	DD	$LN214@makenode
	DD	$LN539@makenode
	DD	$LN563@makenode
	DD	$LN562@makenode
	DD	$LN533@makenode
	DD	$LN530@makenode
	DD	$LN526@makenode
	DD	$LN520@makenode
	DD	$LN521@makenode
	DD	$LN519@makenode
	DD	$LN511@makenode
	DD	$LN510@makenode
	DD	$LN509@makenode
	DD	$LN508@makenode
	DD	$LN541@makenode
	DD	$LN540@makenode
	DD	$LN75@makenode
	DD	$LN72@makenode
	DD	$LN74@makenode
	DD	$LN73@makenode
	DD	$LN67@makenode
	DD	$LN70@makenode
	DD	$LN460@makenode
	DD	$LN71@makenode
	DD	$LN2@makenode
$LN864@makenode:
	DB	0
	DB	0
	DB	1
	DB	2
	DB	0
	DB	3
	DB	0
	DB	60					; 0000003cH
	DB	4
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	60					; 0000003cH
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	60					; 0000003cH
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	33					; 00000021H
	DB	60					; 0000003cH
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	36					; 00000024H
	DB	60					; 0000003cH
	DB	37					; 00000025H
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	38					; 00000026H
	DB	60					; 0000003cH
	DB	39					; 00000027H
	DB	60					; 0000003cH
	DB	40					; 00000028H
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	46					; 0000002eH
	DB	47					; 0000002fH
	DB	48					; 00000030H
	DB	49					; 00000031H
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	50					; 00000032H
	DB	51					; 00000033H
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	60					; 0000003cH
	DB	52					; 00000034H
	DB	53					; 00000035H
	DB	54					; 00000036H
	DB	55					; 00000037H
	DB	56					; 00000038H
	DB	57					; 00000039H
	DB	60					; 0000003cH
	DB	44					; 0000002cH
	DB	58					; 0000003aH
	DB	59					; 0000003bH
$LN947@makenode:
	DD	$LN457@makenode
	DD	$LN457@makenode
	DD	$LN457@makenode
	DD	$LN456@makenode
	DD	$LN457@makenode
	DD	$LN455@makenode
	DD	$LN455@makenode
$LN948@makenode:
	DD	$LN61@makenode
	DD	$LN57@makenode
	DD	$LN53@makenode
	DD	$LN49@makenode
	DD	$LN45@makenode
$LN949@makenode:
	DD	$LN546@makenode
	DD	$LN382@makenode
	DD	$LN180@makenode
	DD	$LN115@makenode
	DD	$LN111@makenode
	DD	$LN179@makenode
	DD	$LN178@makenode
	DD	$LN175@makenode
	DD	$LN173@makenode
	DD	$LN540@makenode
	DD	$LN166@makenode
	DD	$LN495@makenode
	DD	$LN161@makenode
	DD	$LN157@makenode
	DD	$LN539@makenode
	DD	$LN248@makenode
	DD	$LN153@makenode
	DD	$LN124@makenode
	DD	$LN150@makenode
	DD	$LN142@makenode
	DD	$LN136@makenode
	DD	$LN88@makenode
	DD	$LN84@makenode
	DD	$LN80@makenode
	DD	$LN541@makenode
	DD	$LN537@makenode
	DD	$LN566@makenode
	DD	$LN3@makenode
	DD	$LN493@makenode
	DD	$LN490@makenode
	DD	$LN491@makenode
	DD	$LN488@makenode
	DD	$LN486@makenode
	DD	$LN464@makenode
	DD	$LN278@makenode
	DD	$LN262@makenode
	DD	$LN254@makenode
	DD	$LN253@makenode
	DD	$LN2@makenode
$LN866@makenode:
	DB	0
	DB	1
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	2
	DB	3
	DB	4
	DB	5
	DB	38					; 00000026H
	DB	6
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	9
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	17					; 00000011H
	DB	21					; 00000015H
	DB	21					; 00000015H
	DB	21					; 00000015H
	DB	21					; 00000015H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	38					; 00000026H
	DB	24					; 00000018H
	DB	24					; 00000018H
	DB	24					; 00000018H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	25					; 00000019H
	DB	38					; 00000026H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	25					; 00000019H
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	33					; 00000021H
	DB	33					; 00000021H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	34					; 00000022H
	DB	38					; 00000026H
	DB	35					; 00000023H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	34					; 00000022H
	DB	34					; 00000022H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	38					; 00000026H
	DB	36					; 00000024H
	DB	36					; 00000024H
	DB	36					; 00000024H
	DB	36					; 00000024H
	DB	36					; 00000024H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	37					; 00000025H
$LN950@makenode:
	DD	$LN257@makenode
	DD	$LN256@makenode
	DD	$LN255@makenode
$LN867@makenode:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	0
	DB	0
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	0
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
$LN951@makenode:
	DD	$LN257@makenode
	DD	$LN255@makenode
$LN868@makenode:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	npad	3
$LN952@makenode:
	DD	$LN257@makenode
	DD	$LN255@makenode
$LN869@makenode:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	npad	1
$LN953@makenode:
	DD	$LN574@makenode
	DD	$LN573@makenode
	DD	$LN545@makenode
	DD	$LN543@makenode
	DD	$LN566@makenode
	DD	$LN541@makenode
	DD	$LN504@makenode
	DD	$LN499@makenode
	DD	$LN242@makenode
	DD	$LN537@makenode
	DD	$LN278@makenode
	DD	$LN243@makenode
	DD	$LN245@makenode
	DD	$LN244@makenode
	DD	$LN280@makenode
	DD	$LN571@makenode
	DD	$LN464@makenode
	DD	$LN494@makenode
	DD	$LN495@makenode
	DD	$LN283@makenode
	DD	$LN2@makenode
$LN871@makenode:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	5
	DB	6
	DB	5
	DB	5
	DB	6
	DB	7
	DB	6
	DB	8
	DB	8
	DB	8
	DB	9
	DB	9
	DB	9
	DB	9
	DB	8
	DB	8
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	9
	DB	9
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	20					; 00000014H
	DB	9
	DB	9
	DB	9
	DB	9
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	9
	DB	9
	DB	9
	DB	15					; 0000000fH
	DB	9
	DB	9
	DB	9
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	20					; 00000014H
	DB	9
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	8
	DB	20					; 00000014H
	DB	8
	DB	8
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	9
	DB	19					; 00000013H
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	9
	DB	8
	DB	8
	DB	8
	DB	8
	DB	9
	DB	8
	DB	8
	DB	8
	DB	8
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	15					; 0000000fH
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	20					; 00000014H
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	npad	2
$LN954@makenode:
	DD	$LN282@makenode
	DD	$LN278@makenode
	DD	$LN557@makenode
	DD	$LN7@makenode
	DD	$LN4@makenode
	DD	$LN29@makenode
	DD	$LN8@makenode
	DD	$LN18@makenode
	DD	$LN571@makenode
	DD	$LN243@makenode
	DD	$LN242@makenode
	DD	$LN537@makenode
	DD	$LN275@makenode
	DD	$LN265@makenode
	DD	$LN79@makenode
	DD	$LN109@makenode
	DD	$LN105@makenode
	DD	$LN203@makenode
	DD	$LN199@makenode
	DD	$LN103@makenode
	DD	$LN268@makenode
	DD	$LN33@makenode
	DD	$LN540@makenode
	DD	$LN31@makenode
	DD	$LN269@makenode
	DD	$LN561@makenode
	DD	$LN2@makenode
$LN872@makenode:
	DB	0
	DB	1
	DB	0
	DB	2
	DB	3
	DB	4
	DB	4
	DB	4
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	5
	DB	5
	DB	5
	DB	5
	DB	6
	DB	6
	DB	7
	DB	6
	DB	8
	DB	1
	DB	9
	DB	9
	DB	10					; 0000000aH
	DB	9
	DB	26					; 0000001aH
	DB	11					; 0000000bH
	DB	26					; 0000001aH
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	26					; 0000001aH
	DB	8
	DB	1
	DB	1
	DB	1
	DB	1
	DB	12					; 0000000cH
	DB	1
	DB	10					; 0000000aH
	DB	1
	DB	1
	DB	13					; 0000000dH
	DB	1
	DB	1
	DB	8
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	1
	DB	11					; 0000000bH
	DB	8
	DB	8
	DB	11					; 0000000bH
	DB	24					; 00000018H
	DB	26					; 0000001aH
	DB	8
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	26					; 0000001aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	26					; 0000001aH
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	11					; 0000000bH
$LN955@makenode:
	DD	$LN97@makenode
	DD	$LN96@makenode
	DD	$LN95@makenode
	DD	$LN94@makenode
	DD	$LN93@makenode
$LN956@makenode:
	DD	$LN208@makenode
	DD	$LN2@makenode
	DD	$LN375@makenode
	DD	$LN309@makenode
	DD	$LN360@makenode
	DD	$LN2@makenode
	DD	$LN453@makenode
$LN957@makenode:
	DD	$LN408@makenode
	DD	$LN430@makenode
	DD	$LN426@makenode
	DD	$LN423@makenode
	DD	$LN420@makenode
	DD	$LN417@makenode
	DD	$LN414@makenode
	DD	$LN411@makenode
	DD	$LN432@makenode
	DD	$LN443@makenode
	DD	$LN441@makenode
	DD	$LN437@makenode
	DD	$LN434@makenode
	DD	$LN439@makenode
	DD	$LN406@makenode
	DD	$LN404@makenode
	DD	$LN402@makenode
	DD	$LN400@makenode
	DD	$LN398@makenode
	DD	$LN396@makenode
	DD	$LN445@makenode
$LN873@makenode:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	20					; 00000014H
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	13					; 0000000dH
	DB	20					; 00000014H
	DB	14					; 0000000eH
	DB	20					; 00000014H
	DB	15					; 0000000fH
	DB	20					; 00000014H
	DB	16					; 00000010H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	17					; 00000011H
	DB	20					; 00000014H
	DB	18					; 00000012H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	19					; 00000013H
$LN958@makenode:
	DD	$LN366@makenode
	DD	$LN365@makenode
	DD	$LN364@makenode
	DD	$LN363@makenode
	DD	$LN362@makenode
$LN959@makenode:
	DD	$LN352@makenode
	DD	$LN344@makenode
	DD	$LN333@makenode
	DD	$LN323@makenode
	DD	$LN316@makenode
$LN960@makenode:
	DD	$LN341@makenode
	DD	$LN340@makenode
	DD	$LN887@makenode
	DD	$LN337@makenode
	DD	$LN335@makenode
$LN961@makenode:
	DD	$LN330@makenode
	DD	$LN329@makenode
	DD	$LN888@makenode
	DD	$LN327@makenode
	DD	$LN325@makenode
$LN962@makenode:
	DD	$LN292@makenode
	DD	$LN302@makenode
	DD	$LN298@makenode
	DD	$LN295@makenode
	DD	$LN291@makenode
	DD	$LN305@makenode
	DD	$LN297@makenode
	DD	$LN294@makenode
	DD	$LN290@makenode
	DD	$LN304@makenode
	DD	$LN287@makenode
	DD	$LN286@makenode
	DD	$LN301@makenode
	DD	$LN300@makenode
	DD	$LN293@makenode
	DD	$LN289@makenode
	DD	$LN296@makenode
	DD	$LN303@makenode
	DD	$LN299@makenode
	DD	$LN288@makenode
_makenode ENDP
_TEXT	ENDS
END
