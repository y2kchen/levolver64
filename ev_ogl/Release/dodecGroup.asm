; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\dodecGroup.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_gen:QWORD:0200H
_DATA	ENDS
_BSS	SEGMENT
_q_init_flag DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_ident_mat DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
_centerRotate DQ 03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	0bff0000000000000r		; -1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
_rotates DQ	03ff0000000000000r		; 1
	DQ	03ca21065890daa02r		; 1.25345e-016
	DQ	0bca6ac542ac35021r		; -1.57327e-016
	DQ	0bcab6a9b1c15cfccr		; -1.9024e-016
	DQ	03caa4bf5d988519ar		; 1.8247e-016
	DQ	0c024f1c03ed8f5fdr		; -10.4722
	DQ	04028f000650c2ed4r		; 12.4688
	DQ	0403040947d6a0015r		; 16.2523
	DQ	0bc9866ea387ee4e6r		; -8.46615e-017
	DQ	0400ff910dc3971adr		; 3.99661
	DQ	0c019e371e8778656r		; -6.47211
	DQ	0c01e299c6a534dacr		; -7.54064
	DQ	03cab6a9b1c15cf9cr		; 1.9024e-016
	DQ	0c02654117645d90br		; -11.1642
	DQ	0402c068b6253c31fr		; 14.0128
	DQ	04031f1bc998a5c64r		; 17.9443
	DQ	0bff9e3873efcdb6dr		; -1.61805
	DQ	0c010772a96543191r		; -4.11637
	DQ	04009e3811903093cr		; 3.23609
	DQ	040158db8fd8b1560r		; 5.3884
	DQ	0bef03d114b527380r		; -1.54863e-005
	DQ	0c001e387c724a1e6r		; -2.2361
	DQ	040045a3efdd850e2r		; 2.54407
	DQ	04009e38d90475ba9r		; 3.23611
	DQ	03ecadd10b737ea00r		; 3.20238e-006
	DQ	040045a37987075c0r		; 2.54405
	DQ	0bff0000b8388260dr		; -1.00001
	DQ	0c0045a39dbbdb65cr		; -2.54406
	DQ	0bff45a452b10f0a7r		; -1.27204
	DQ	0c014f1c74027c3b4r		; -5.23611
	DQ	04010772b0a177ef0r		; 4.11638
	DQ	0401b6aa894339159r		; 6.85416
	DQ	0bff9e37e1a95324fr		; -1.61804
	DQ	040107729c99da3c2r		; 4.11637
	DQ	0c009e375c08b6f7dr		; -3.23606
	DQ	0c0158db4494ced10r		; -5.38838
	DQ	03ed769679a0ee600r		; 5.58179e-006
	DQ	0c001e38ae9da520ar		; -2.2361
	DQ	040045a35d3dfe221r		; 2.54405
	DQ	04009e38886a7e4aer		; 3.2361
	DQ	0bed267af922abb00r		; -4.3881e-006
	DQ	040045a35d3dfe22ar		; 2.54405
	DQ	0bfefffece66c23e6r		; -0.999991
	DQ	0c0045a33f36290e8r		; -2.54404
	DQ	03ff45a398a041c1dr		; 1.27203
	DQ	0c014f1c6dcad5ce9r		; -5.23611
	DQ	04010772277fa5d82r		; 4.11634
	DQ	0401b6aa2985ffa22r		; 6.85414
	DQ	0bd97073f98489368r		; -5.23603e-012
	DQ	040022d165486ff98r		; 2.27202
	DQ	03fd168f3556ca1d5r		; 0.272031
	DQ	0c00077209673a896r		; -2.05817
	DQ	0c0022d116d4744e4r		; -2.27201
	DQ	0c010a5ebb9f1bd02r		; -4.16203
	DQ	0bfe3c71be2e5cf22r		; -0.618055
	DQ	04012b46472ff83b3r		; 4.67616
	DQ	0bfd168eea3162b0cr		; -0.27203
	DQ	0bfe3c71be2e5cf2dr		; -0.618055
	DQ	03feda1c9f39f053br		; 0.926
	DQ	03fe1ea8d636f52c7r		; 0.559882
	DQ	0c000771b18ea401er		; -2.05816
	DQ	0c012b465a3f1340br		; -4.67617
	DQ	0bfe1ea8e87866418r		; -0.559882
	DQ	04014f1b27b7df35fr		; 5.23603
_DATA	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\dodecgroup.c
;	COMDAT _copy
_TEXT	SEGMENT
_copy	PROC						; COMDAT
; _z$ = ecx
; _w$ = eax

; 98   :      int j;
; 99   : 
; 100  :      for (j=0; j<PDIM; j++)
; 101  :           w[j]=z[j];

	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [eax]
	fld	QWORD PTR [ecx+8]
	fstp	QWORD PTR [eax+8]
	fld	QWORD PTR [ecx+16]
	fstp	QWORD PTR [eax+16]
	fld	QWORD PTR [ecx+24]
	fstp	QWORD PTR [eax+24]

; 102  : 
; 103  : } // end copy()

	ret	0
_copy	ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _copyMat
_TEXT	SEGMENT
_copyMat PROC						; COMDAT
; _mat1$ = ecx
; _mat2$ = eax

; 110  :   int i,j;
; 111  : 
; 112  :   for(i=0;i<PDIM;i++)
; 113  :      for(j=0;j<PDIM;j++)
; 114  :         mat2[i][j] = mat1[i][j];

	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [eax]
	fld	QWORD PTR [ecx+8]
	fstp	QWORD PTR [eax+8]
	fld	QWORD PTR [ecx+16]
	fstp	QWORD PTR [eax+16]
	fld	QWORD PTR [ecx+24]
	fstp	QWORD PTR [eax+24]
	fld	QWORD PTR [ecx+32]
	fstp	QWORD PTR [eax+32]
	fld	QWORD PTR [ecx+40]
	fstp	QWORD PTR [eax+40]
	fld	QWORD PTR [ecx+48]
	fstp	QWORD PTR [eax+48]
	fld	QWORD PTR [ecx+56]
	fstp	QWORD PTR [eax+56]
	fld	QWORD PTR [ecx+64]
	fstp	QWORD PTR [eax+64]
	fld	QWORD PTR [ecx+72]
	fstp	QWORD PTR [eax+72]
	fld	QWORD PTR [ecx+80]
	fstp	QWORD PTR [eax+80]
	fld	QWORD PTR [ecx+88]
	fstp	QWORD PTR [eax+88]
	fld	QWORD PTR [ecx+96]
	fstp	QWORD PTR [eax+96]
	fld	QWORD PTR [ecx+104]
	fstp	QWORD PTR [eax+104]
	fld	QWORD PTR [ecx+112]
	fstp	QWORD PTR [eax+112]
	fld	QWORD PTR [ecx+120]
	fstp	QWORD PTR [eax+120]

; 115  : 
; 116  : } // end copyMat()

	ret	0
_copyMat ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	__$ArrayPad$
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _matMult
_TEXT	SEGMENT
_temp1$ = -260						; size = 128
_temp2$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_mat2$ = 8						; size = 4
_matMult PROC						; COMDAT
; _mat1$ = ecx
; _newMat$ = edx

; 123  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 124  :   int i, j, k;
; 125  :   REAL temp1[PDIM][PDIM], temp2[PDIM][PDIM];
; 126  : 
; 127  :   copyMat(mat1, temp1);

	lea	eax, DWORD PTR _temp1$[ebp]
	call	_copyMat

; 128  :   copyMat(mat2, temp2);

	mov	ecx, DWORD PTR _mat2$[ebp]
	lea	eax, DWORD PTR _temp2$[ebp]
	call	_copyMat

; 129  : 
; 130  :   for(i=0;i<PDIM;i++)

	fldz

; 131  :      for(j=0;j<PDIM;j++) {

	mov	ecx, edx
	lea	edx, DWORD PTR _temp1$[ebp+8]
	mov	esi, 4
$LN9@matMult:
	xor	eax, eax
$LN6@matMult:

; 132  :         newMat[i][j] = 0;

	fst	QWORD PTR [ecx]
	inc	eax

; 133  :         for(k=0;k<PDIM;k++)
; 134  :           newMat[i][j] += temp1[i][k] * temp2[k][j];

	fld	QWORD PTR _temp2$[ebp+eax*8-8]
	add	ecx, 8
	fmul	QWORD PTR [edx-8]
	fadd	QWORD PTR [ecx-8]
	fld	QWORD PTR _temp2$[ebp+eax*8+24]
	fmul	QWORD PTR [edx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _temp2$[ebp+eax*8+56]
	fmul	QWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _temp2$[ebp+eax*8+88]
	fmul	QWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx-8]
	cmp	eax, 4
	jl	SHORT $LN6@matMult

; 129  : 
; 130  :   for(i=0;i<PDIM;i++)

	add	edx, 32					; 00000020H
	dec	esi
	jne	SHORT $LN9@matMult

; 135  :      }
; 136  : } // end matMult()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_matMult ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtp
;	COMDAT _matVecMult
_TEXT	SEGMENT
_temp$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_matVecMult PROC					; COMDAT
; _mat$ = esi
; _x$ = ecx
; _y$ = edx

; 143  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 144  :   int i, j;
; 145  :   REAL temp[PDIM];
; 146  : 
; 147  :   copy(x, temp);

	lea	eax, DWORD PTR _temp$[ebp]
	call	_copy

; 148  :   for(i=0;i<PDIM;i++) {
; 149  :      y[i] = 0;

	fldz
	fst	QWORD PTR [edx]

; 150  :      for(j=0;j<PDIM;j++)
; 151  :         y[i] += temp[j]*mat[j][i];

	fld	QWORD PTR [esi]
	fld	QWORD PTR _temp$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR [edx]
	fst	QWORD PTR [edx]
	fld	QWORD PTR [esi+32]
	fld	QWORD PTR _temp$[ebp+8]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR [edx]
	fld	QWORD PTR [esi+64]
	fld	QWORD PTR _temp$[ebp+16]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR [edx]
	fld	QWORD PTR [esi+96]
	fld	QWORD PTR _temp$[ebp+24]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [edx]
	fxch	ST(4)
	fst	QWORD PTR [edx+8]
	fld	QWORD PTR [esi+8]
	fmul	ST(0), ST(4)
	fadd	QWORD PTR [edx+8]
	fst	QWORD PTR [edx+8]
	fld	QWORD PTR [esi+40]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fst	QWORD PTR [edx+8]
	fld	QWORD PTR [esi+72]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fst	QWORD PTR [edx+8]
	fld	QWORD PTR [esi+104]
	fmul	ST(0), ST(6)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx+8]
	fst	QWORD PTR [edx+16]
	fld	QWORD PTR [esi+16]
	fmul	ST(0), ST(4)
	fadd	QWORD PTR [edx+16]
	fst	QWORD PTR [edx+16]
	fld	QWORD PTR [esi+48]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fst	QWORD PTR [edx+16]
	fld	QWORD PTR [esi+80]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fst	QWORD PTR [edx+16]
	fld	QWORD PTR [esi+112]
	fmul	ST(0), ST(6)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx+16]
	fstp	QWORD PTR [edx+24]
	fld	QWORD PTR [esi+24]
	fmulp	ST(3), ST(0)
	fxch	ST(2)
	fadd	QWORD PTR [edx+24]
	fst	QWORD PTR [edx+24]
	fld	QWORD PTR [esi+56]
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fst	QWORD PTR [edx+24]
	fld	QWORD PTR [esi+88]
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fst	QWORD PTR [edx+24]
	fld	QWORD PTR [esi+120]

; 152  :   }
; 153  : } // end matVecMult()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fmulp	ST(2), ST(0)
	xor	ecx, ebp
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx+24]
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_matVecMult ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
EXTRN	__CIsqrt:PROC
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _convertToHyp
_TEXT	SEGMENT
_convertToHyp PROC					; COMDAT
; _x$ = esi
; _y$ = edi

; 160  :   REAL ww;
; 161  : 
; 162  :   ww = 1/sqrt(1 - x[0]*x[0] - x[1]*x[1] - x[2]*x[2]);

	fld	QWORD PTR [esi]
	fld	QWORD PTR [esi+8]
	fld	QWORD PTR [esi+16]
	fld	ST(2)
	fmulp	ST(3), ST(0)
	fld1
	fsubrp	ST(3), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(2)
	fsubrp	ST(1), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	call	__CIsqrt
	fld1
	fdivrp	ST(1), ST(0)

; 163  : 
; 164  :   y[0] = x[0]*ww;

	fld	QWORD PTR [esi]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edi]

; 165  :   y[1] = x[1]*ww;

	fld	ST(0)
	fmul	QWORD PTR [esi+8]
	fstp	QWORD PTR [edi+8]

; 166  :   y[2] = x[2]*ww;

	fld	QWORD PTR [esi+16]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edi+16]

; 167  :   y[3] = ww;

	fstp	QWORD PTR [edi+24]

; 168  : 
; 169  : } // end convertToHyp()

	ret	0
_convertToHyp ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _calcGen
_TEXT	SEGMENT
tv202 = -4						; size = 4
tv187 = -4						; size = 4
tv91 = -4						; size = 4
_calcGen PROC						; COMDAT
; _ggen$ = eax
; _mat$ = esi

; 177  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, eax
	push	edi

; 178  :   int i;
; 179  :   
; 180  :   copyMat(ident_mat,mat);

	mov	eax, esi
	mov	ecx, OFFSET _ident_mat
	call	_copyMat

; 181  :   if(((ggen&16)>>4)==0) {
; 182  :      for(i=0;i<(ggen&3);i++)

	mov	edi, ebx
	test	bl, 16					; 00000010H
	jne	SHORT $LN17@calcGen
	and	edi, 3
	jle	SHORT $LN14@calcGen
	mov	DWORD PTR tv91[ebp], edi
$LL16@calcGen:

; 183  :         matMult(mat,centerRotate,mat);

	push	OFFSET _centerRotate
	mov	edx, esi
	mov	ecx, esi
	call	_matMult
	add	esp, 4
	dec	DWORD PTR tv91[ebp]
	jne	SHORT $LL16@calcGen
$LN14@calcGen:

; 184  :      matMult(mat, rotates[((ggen&12)>>2)], mat);

	sar	ebx, 2
	and	ebx, 3
	shl	ebx, 7
	add	ebx, OFFSET _rotates
	push	ebx
	mov	edx, esi
	mov	ecx, esi
	call	_matMult

; 185  :      for(i=0;i<((5-(ggen&3))%4);i++)

	mov	eax, 5
	sub	eax, edi
	add	esp, 4
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN31@calcGen
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN31@calcGen:
	test	eax, eax
	jle	$LN1@calcGen

; 184  :      matMult(mat, rotates[((ggen&12)>>2)], mat);

	mov	edi, eax
$LL13@calcGen:

; 186  :         matMult(mat, centerRotate, mat);

	push	OFFSET _centerRotate
	mov	edx, esi
	mov	ecx, esi
	call	_matMult
	add	esp, 4
	dec	edi
	jne	SHORT $LL13@calcGen
	pop	edi
	pop	ebx

; 194  :   }
; 195  : } // end calcGen()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@calcGen:

; 187  :   } else {
; 188  :      for(i=0;i<(((ggen&3)+3)%4);i++)

	and	edi, 3
	lea	eax, DWORD PTR [edi+3]
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN32@calcGen
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN32@calcGen:
	test	eax, eax
	jle	SHORT $LN7@calcGen
	mov	DWORD PTR tv187[ebp], eax
$LL9@calcGen:

; 189  :         matMult(mat, centerRotate, mat);

	push	OFFSET _centerRotate
	mov	edx, esi
	mov	ecx, esi
	call	_matMult
	add	esp, 4
	dec	DWORD PTR tv187[ebp]
	jne	SHORT $LL9@calcGen
$LN7@calcGen:

; 187  :   } else {
; 188  :      for(i=0;i<(((ggen&3)+3)%4);i++)

	sar	ebx, 2
	and	ebx, 3
	shl	ebx, 7

; 190  :      for(i=0;i<3;i++)

	lea	eax, DWORD PTR _rotates[ebx]
	mov	DWORD PTR tv202[ebp], eax
	mov	ebx, 3
$LL30@calcGen:

; 191  :         matMult(mat, rotates[((ggen&12)>>2)], mat);

	mov	ecx, DWORD PTR tv202[ebp]
	push	ecx
	mov	edx, esi
	mov	ecx, esi
	call	_matMult
	add	esp, 4
	dec	ebx
	jne	SHORT $LL30@calcGen

; 192  :      for(i=0;i<((4-(ggen&3))%4);i++)

	mov	eax, 4
	sub	eax, edi
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN33@calcGen
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN33@calcGen:
	test	eax, eax
	jle	SHORT $LN1@calcGen
	mov	edi, eax
	npad	2
$LL3@calcGen:

; 193  :         matMult(mat, centerRotate, mat);

	push	OFFSET _centerRotate
	mov	edx, esi
	mov	ecx, esi
	call	_matMult
	add	esp, 4
	dec	edi
	jne	SHORT $LL3@calcGen
$LN1@calcGen:
	pop	edi
	pop	ebx

; 194  :   }
; 195  : } // end calcGen()

	mov	esp, ebp
	pop	ebp
	ret	0
_calcGen ENDP
_TEXT	ENDS
PUBLIC	_mat$GSCopy$
PUBLIC	__$ArrayPad$
; Function compile flags: /Ogtp
;	COMDAT _calcElem
_TEXT	SEGMENT
_mat$GSCopy$ = -140					; size = 4
tv86 = -136						; size = 4
_genMat$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_mat$ = 8						; size = 4
_calcElem PROC						; COMDAT
; _element$ = ecx

; 203  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _mat$[ebp]
	push	ebx
	mov	ebx, ecx

; 204  :   int i, numGens;
; 205  :   REAL genMat[PDIM][PDIM];
; 206  : 
; 207  :   numGens = NUMGEN(element);

	mov	edx, ebx

; 208  :   element >>= 3;
; 209  :   copyMat(ident_mat, mat);

	mov	ecx, OFFSET _ident_mat

; 211  :      calcGen(FINDGEN(element), genMat);

	mov	DWORD PTR _mat$GSCopy$[ebp], eax
	and	edx, 7
	sar	ebx, 3
	call	_copyMat
	test	edx, edx
	jle	SHORT $LN1@calcElem

; 210  :   for(i=0;i<numGens;i++) {

	push	esi
	mov	DWORD PTR tv86[ebp], edx
	push	edi
	npad	3
$LL3@calcElem:

; 211  :      calcGen(FINDGEN(element), genMat);

	mov	edi, ebx
	and	edi, 31					; 0000001fH
	lea	esi, DWORD PTR _genMat$[ebp]
	mov	eax, edi
	call	_calcGen

; 212  :      matMult(mat, gen[FINDGEN(element)], mat);

	mov	ecx, DWORD PTR _mat$GSCopy$[ebp]
	shl	edi, 7
	add	edi, OFFSET _gen
	push	edi
	mov	edx, ecx
	call	_matMult
	add	esp, 4

; 213  :      element = CHOP(element);

	sar	ebx, 5
	dec	DWORD PTR tv86[ebp]
	jne	SHORT $LL3@calcElem
	pop	edi
	pop	esi
$LN1@calcElem:

; 214  :   }
; 215  : } // end calcElem()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_calcElem ENDP
_TEXT	ENDS
EXTRN	_free:PROC
EXTRN	_malloc:PROC
; Function compile flags: /Ogtp
;	COMDAT _check_inverse
_TEXT	SEGMENT
tv196 = -4						; size = 4
_elem1$ = 8						; size = 4
_elem2$ = 12						; size = 4
_check_inverse PROC					; COMDAT

; 221  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 222  :   int i;
; 223  :   int numgen1, numgen2;
; 224  :   WRAPTYPE pres, next;
; 225  :   WRAPTYPE endelem;
; 226  :   WRAPTYPE *gens;
; 227  : 
; 228  :   endelem = 0;
; 229  :   numgen1=NUMGEN(elem1);

	mov	eax, DWORD PTR _elem1$[ebp]
	push	ebx
	mov	ebx, eax

; 230  :   elem1 >>= 3;

	sar	eax, 3
	mov	DWORD PTR _elem1$[ebp], eax

; 231  :   numgen2=NUMGEN(elem2);

	mov	eax, DWORD PTR _elem2$[ebp]
	push	esi
	mov	esi, eax

; 232  :   elem2 >>= 3;

	sar	eax, 3
	mov	DWORD PTR _elem2$[ebp], eax
	and	ebx, 7
	and	esi, 7

; 233  :   gens = (WRAPTYPE*) malloc(sizeof(WRAPTYPE)*(numgen1+numgen2));

	lea	eax, DWORD PTR [esi+ebx]
	mov	DWORD PTR tv196[ebp], eax
	add	eax, eax
	push	edi
	add	eax, eax
	push	eax
	xor	edi, edi
	call	_malloc
	add	esp, 4

; 234  :   for(i=0;i<numgen2;i++) {

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN25@check_inve
	npad	2
$LL24@check_inve:

; 235  :      gens[i] = FINDGEN(elem2);

	mov	edx, DWORD PTR _elem2$[ebp]

; 236  :      elem2 = CHOP(elem2);

	sar	DWORD PTR _elem2$[ebp], 5
	and	edx, 31					; 0000001fH
	mov	DWORD PTR [eax+ecx*4], edx
	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LL24@check_inve
$LN25@check_inve:

; 237  :   }
; 238  :   for(i=0;i<numgen1;i++) {

	test	ebx, ebx
	jle	SHORT $LN26@check_inve
	lea	esi, DWORD PTR [eax+esi*4]
	npad	7
$LL12@check_inve:

; 239  :      gens[i+numgen2] = FINDGEN(elem1);

	mov	ecx, DWORD PTR _elem1$[ebp]
	mov	edx, ecx
	and	edx, 31					; 0000001fH
	mov	DWORD PTR [esi], edx

; 240  :      elem1 = CHOP(elem1);

	sar	ecx, 5
	add	esi, 4
	dec	ebx
	mov	DWORD PTR _elem1$[ebp], ecx
	jne	SHORT $LL12@check_inve
$LN26@check_inve:

; 241  :   }
; 242  :   pres = gens[0];

	mov	esi, DWORD PTR [eax]

; 243  :   for(i=1;i<(numgen1+numgen2);i++) {

	mov	edx, 1
	cmp	DWORD PTR tv196[ebp], edx
	jle	SHORT $LN7@check_inve
$LL9@check_inve:

; 244  :      next = gens[i];

	mov	ebx, DWORD PTR [eax+edx*4]

; 245  :      if((pres^next)==16) {

	mov	ecx, ebx
	xor	ecx, esi
	cmp	ecx, 16					; 00000010H

; 246  :         if(NUMGEN(endelem)==0) {

	mov	ecx, edi
	jne	SHORT $LN6@check_inve
	and	ecx, 7
	jne	SHORT $LN5@check_inve

; 247  :           if(i<(numgen1+numgen2-1)) {

	mov	ecx, DWORD PTR tv196[ebp]
	dec	ecx
	cmp	edx, ecx
	jge	SHORT $LN4@check_inve

; 248  :              pres = gens[i+1];

	mov	esi, DWORD PTR [eax+edx*4+4]

; 249  :              i++;

	inc	edx

; 253  :           }
; 254  :         } else {

	jmp	SHORT $LN8@check_inve
$LN5@check_inve:

; 255  :           pres = FINDGEN(endelem>>(3+5*(NUMGEN(endelem)-1)));

	mov	esi, edi
	lea	ecx, DWORD PTR [ecx+ecx*4-2]
	sar	esi, cl
	and	esi, 31					; 0000001fH

; 256  :           endelem = (endelem&(~(pres<<(3+5*(NUMGEN(endelem)-1))))) - 1;

	mov	ebx, esi
	shl	ebx, cl
	not	ebx
	and	edi, ebx
	dec	edi

; 257  :         }
; 258  :      } else {

	jmp	SHORT $LN8@check_inve
$LN6@check_inve:

; 259  :         endelem += 1 + (pres<<(3+NUMGEN(endelem)*5));

	and	ecx, 7
	lea	ecx, DWORD PTR [ecx+ecx*4+3]
	shl	esi, cl
	lea	edi, DWORD PTR [edi+esi+1]

; 260  :         pres = next;

	mov	esi, ebx
$LN8@check_inve:

; 243  :   for(i=1;i<(numgen1+numgen2);i++) {

	inc	edx
	cmp	edx, DWORD PTR tv196[ebp]
	jl	SHORT $LL9@check_inve
$LN7@check_inve:

; 261  :      }
; 262  :   }
; 263  :   endelem += 1 + (pres<<(3+NUMGEN(endelem)*5));
; 264  :   free((char*)gens);

	push	eax
	call	_free
	mov	eax, edi
	and	eax, 7
	add	esp, 4
	lea	ecx, DWORD PTR [eax+eax*4+3]
	shl	esi, cl
	lea	eax, DWORD PTR [esi+edi+1]
	pop	edi
	pop	esi
	pop	ebx

; 265  :   return(endelem);
; 266  : 
; 267  : } // check_inverse()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@check_inve:

; 250  :           } else {
; 251  :              free((char*)gens);

	push	eax
	call	_free
	add	esp, 4

; 252  :              return(endelem);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 265  :   return(endelem);
; 266  : 
; 267  : } // check_inverse()

	mov	esp, ebp
	pop	ebp
	ret	0
_check_inverse ENDP
_TEXT	ENDS
PUBLIC	_dodec_inverse
; Function compile flags: /Ogtp
;	COMDAT _dodec_inverse
_TEXT	SEGMENT
_element$ = 8						; size = 4
_dodec_inverse PROC					; COMDAT

; 272  : {

	push	ebp
	mov	ebp, esp

; 273  :   int i, numGens;
; 274  :   WRAPTYPE inverse;
; 275  : 
; 276  :   numGens = NUMGEN(element);

	mov	ecx, DWORD PTR _element$[ebp]
	mov	edx, ecx
	and	edx, 7

; 277  :   element >>= 3;

	sar	ecx, 3

; 278  :   inverse = 0;

	xor	eax, eax

; 279  :   for(i=0;i<numGens;i++) {

	test	edx, edx
	jle	SHORT $LN8@dodec_inve

; 273  :   int i, numGens;
; 274  :   WRAPTYPE inverse;
; 275  : 
; 276  :   numGens = NUMGEN(element);

	push	esi
	push	edi
	mov	esi, edx
	npad	8
$LL3@dodec_inve:

; 280  :      inverse = inverse*32 + GENINV(FINDGEN(element));

	lea	edi, DWORD PTR [ecx-16]
	and	edi, 31					; 0000001fH
	shl	eax, 5
	add	eax, edi

; 281  :      element = CHOP(element);

	sar	ecx, 5
	dec	esi
	jne	SHORT $LL3@dodec_inve
	pop	edi
	pop	esi
$LN8@dodec_inve:

; 282  :   }
; 283  :   inverse = (inverse<<3) + numGens;

	lea	eax, DWORD PTR [edx+eax*8]

; 284  :   return(inverse);
; 285  : 
; 286  : } // end dodec_inverse()

	pop	ebp
	ret	0
_dodec_inverse ENDP
_TEXT	ENDS
PUBLIC	_init_gen
; Function compile flags: /Ogtp
;	COMDAT _init_gen
_TEXT	SEGMENT
_init_gen PROC						; COMDAT

; 290  : {

	push	esi
	push	edi

; 291  :   WRAPTYPE i;
; 292  : 
; 293  :   for(i=0;i<32;i++)

	xor	edi, edi
	mov	esi, OFFSET _gen
	npad	7
$LL3@init_gen:

; 294  :      calcGen(i, gen[i]);

	mov	eax, edi
	call	_calcGen
	sub	esi, -128				; ffffff80H
	inc	edi
	cmp	esi, OFFSET _gen+4096
	jl	SHORT $LL3@init_gen

; 295  : 
; 296  :   q_init_flag = 1;

	pop	edi
	mov	DWORD PTR _q_init_flag, 1
	pop	esi

; 297  : 
; 298  : } // end init_gen()

	ret	0
_init_gen ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_dodec_wrap
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
;	COMDAT _dodec_wrap
_TEXT	SEGMENT
_mat$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_element$ = 16						; size = 4
_dodec_wrap PROC					; COMDAT

; 307  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 308  :   REAL mat[PDIM][PDIM];
; 309  :   int i;
; 310  : 
; 311  :   if(q_init_flag==0) init_gen();

	cmp	DWORD PTR _q_init_flag, 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR _x$[ebp]
	push	edi
	mov	edi, DWORD PTR _y$[ebp]
	jne	SHORT $LN9@dodec_wrap
	call	_init_gen
$LN9@dodec_wrap:

; 312  :   
; 313  :   if(element==0)

	mov	ebx, DWORD PTR _element$[ebp]
	test	ebx, ebx
	jne	SHORT $LN8@dodec_wrap

; 314  :      for(i=0;i<SDIM;i++)

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN1@dodec_wrap
	mov	edx, esi
	mov	eax, edi
	sub	edx, edi
$LL7@dodec_wrap:

; 315  :         y[i] = x[i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL7@dodec_wrap
	pop	edi
	pop	esi
	pop	ebx

; 322  :   }
; 323  : }  // end dodec_wrap()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@dodec_wrap:

; 316  :   else {
; 317  :      convertToHyp(x, y);

	call	_convertToHyp

; 318  :      calcElem(element, mat);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	mov	ecx, ebx
	call	_calcElem
	add	esp, 4

; 319  :      matVecMult(mat, y, y);

	mov	edx, edi
	mov	ecx, edi
	lea	esi, DWORD PTR _mat$[ebp]
	call	_matVecMult

; 320  :      for(i=0;i<SDIM;i++)

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN1@dodec_wrap
$LL3@dodec_wrap:

; 321  :         y[i] /= y[3];

	fld	QWORD PTR [edi+eax*8]
	inc	eax
	fdiv	QWORD PTR [edi+24]
	fstp	QWORD PTR [edi+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL3@dodec_wrap
$LN1@dodec_wrap:

; 322  :   }
; 323  : }  // end dodec_wrap()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_dodec_wrap ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@BDGOMHNG@too?5many?5generators?5?6?$AA@ ; `string'
PUBLIC	_dodec_compose
EXTRN	_printf:PROC
;	COMDAT ??_C@_0BG@BDGOMHNG@too?5many?5generators?5?6?$AA@
CONST	SEGMENT
??_C@_0BG@BDGOMHNG@too?5many?5generators?5?6?$AA@ DB 'too many generators'
	DB	' ', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _dodec_compose
_TEXT	SEGMENT
_elem1$ = 8						; size = 4
_elem2$ = 12						; size = 4
_dodec_compose PROC					; COMDAT

; 331  : {

	push	ebp
	mov	ebp, esp

; 332  :   int numGens;
; 333  :   WRAPTYPE compp;
; 334  :   numGens = NUMGEN(elem1);

	mov	eax, DWORD PTR _elem1$[ebp]
	push	esi

; 335  :   if((numGens+NUMGEN(elem2)>5))

	mov	esi, DWORD PTR _elem2$[ebp]
	mov	edx, eax
	mov	ecx, esi
	and	edx, 7
	and	ecx, 7
	push	edi
	lea	edi, DWORD PTR [ecx+edx]
	cmp	edi, 5
	jle	SHORT $LN3@dodec_comp

; 336  :      compp = (check_inverse(elem1,elem2));

	push	esi
	push	eax
	call	_check_inverse
	add	esp, 8
	mov	esi, eax

; 337  :   else {

	jmp	SHORT $LN2@dodec_comp
$LN3@dodec_comp:

; 338  :      elem1 >>= 3;

	sar	eax, 3

; 339  :      elem1 <<= 3+(NUMGEN(elem2)*5);

	lea	ecx, DWORD PTR [ecx+ecx*4+3]
	shl	eax, cl

; 340  :      compp = (elem1 + elem2 + numGens);

	add	eax, edx
	add	esi, eax
$LN2@dodec_comp:

; 341  :   }
; 342  :   if(NUMGEN(compp)>5)

	mov	eax, esi
	and	eax, 7
	cmp	al, 5
	jle	SHORT $LN6@dodec_comp

; 343  :      printf("too many generators \n");

	push	OFFSET ??_C@_0BG@BDGOMHNG@too?5many?5generators?5?6?$AA@
	call	_printf
	add	esp, 4
$LN6@dodec_comp:

; 344  : 
; 345  :      return(compp);

	pop	edi
	mov	eax, esi
	pop	esi

; 346  : 
; 347  : } // end dodec_compose()

	pop	ebp
	ret	0
_dodec_compose ENDP
_TEXT	ENDS
PUBLIC	_yform$GSCopy$
PUBLIC	_xform$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_dodec_form_pullback
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT _dodec_form_pullback
_TEXT	SEGMENT
_yform$GSCopy$ = -344					; size = 4
tv367 = -340						; size = 4
tv1202 = -336						; size = 4
_i$ = -332						; size = 4
tv1378 = -328						; size = 4
_xform$GSCopy$ = -328					; size = 4
_jac$ = -324						; size = 128
_trans$ = -196						; size = 128
_w$ = -68						; size = 32
_y$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_xform$ = 12						; size = 4
_yform$ = 16						; size = 4
_wrap$ = 20						; size = 4
_dodec_form_pullback PROC				; COMDAT

; 364  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 365  :   int i,j;
; 366  :   REAL trans[PDIM][PDIM];
; 367  :   REAL jac[PDIM][PDIM];  /* Jacobian matrix */
; 368  :   REAL y[PDIM];
; 369  :   REAL w[PDIM];  /* Minkowski coord of x */
; 370  : 
; 371  :   if ( wrap == 0 ) /* just copy */

	mov	ecx, DWORD PTR _wrap$[ebp]
	mov	eax, DWORD PTR _xform$[ebp]
	push	esi
	mov	esi, DWORD PTR _x$[ebp]
	push	edi
	mov	edi, DWORD PTR _yform$[ebp]

; 382  : 
; 383  :   /* set up Jacobian */
; 384  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _xform$GSCopy$[ebp], eax
	mov	DWORD PTR _yform$GSCopy$[ebp], edi
	test	ecx, ecx
	jne	SHORT $LN13@dodec_form

; 372  :      { memcpy((char *)xform,(char*)yform,SDIM*sizeof(REAL));

	mov	ecx, DWORD PTR _web+616
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	push	edi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 392  : 
; 393  : } // end dodec_form_pullback()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@dodec_form:

; 373  :         return;
; 374  :      }
; 375  : 
; 376  :   calcElem(wrap, trans);

	lea	eax, DWORD PTR _trans$[ebp]
	push	ebx
	push	eax
	call	_calcElem

; 377  : 
; 378  :   /* get transformed point in Minkowski */
; 379  :   memcpy((char *)(w),(char*)x,SDIM*sizeof(REAL));

	mov	ecx, DWORD PTR _web+616
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	lea	eax, DWORD PTR _w$[ebp]
	push	esi
	push	eax
	call	_memcpy

; 380  :   w[3] = 1.0;

	fld1
	add	esp, 16					; 00000010H
	fstp	QWORD PTR _w$[ebp+24]

; 381  :   matVecMult(trans,w,y);

	lea	edx, DWORD PTR _y$[ebp]
	lea	ecx, DWORD PTR _w$[ebp]
	lea	esi, DWORD PTR _trans$[ebp]
	call	_matVecMult

; 382  : 
; 383  :   /* set up Jacobian */
; 384  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _web+616
	xor	ebx, ebx
	mov	DWORD PTR _i$[ebp], ebx
	test	esi, esi
	jle	$LN10@dodec_form

; 373  :         return;
; 374  :      }
; 375  : 
; 376  :   calcElem(wrap, trans);

	fld	QWORD PTR _y$[ebp+24]
	lea	eax, DWORD PTR _jac$[ebp+8]
	mov	DWORD PTR tv1202[ebp], eax
$LN27@dodec_form:

; 385  :     for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	cmp	esi, 4
	jl	$LC25@dodec_form
	add	esi, -4					; fffffffcH
	lea	ecx, DWORD PTR _y$[ebp+ebx*8]
	shr	esi, 2
	inc	esi
	mov	DWORD PTR tv367[ebp], ecx
	lea	edx, DWORD PTR _trans$[ebp+56]
	lea	ecx, DWORD PTR _trans$[ebp+ebx*8+32]
	lea	edi, DWORD PTR [esi*4]
$LN26@dodec_form:

; 386  :       jac[i][j] = (trans[j][i] - y[i]*trans[j][3]/y[3])/y[3];

	mov	ebx, DWORD PTR tv367[ebp]
	fld	QWORD PTR [edx-32]
	fmul	QWORD PTR [ebx]
	add	eax, 32					; 00000020H
	sub	ecx, -128				; ffffff80H
	sub	edx, -128				; ffffff80H
	dec	esi
	fdiv	ST(0), ST(1)
	fsubr	QWORD PTR [ecx-160]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [ebx]
	fmul	QWORD PTR [edx-128]
	fdiv	ST(0), ST(1)
	fsubr	QWORD PTR [ecx-128]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-96]
	fmul	QWORD PTR [ebx]
	fdiv	ST(0), ST(1)
	fsubr	QWORD PTR [ecx-96]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-64]
	fmul	QWORD PTR [ebx]
	fdiv	ST(0), ST(1)
	fsubr	QWORD PTR [ecx-64]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN26@dodec_form

; 385  :     for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _web+616
$LC25@dodec_form:
	cmp	edi, esi
	jge	SHORT $LN11@dodec_form
	mov	edx, edi
	shl	edx, 5
	lea	eax, DWORD PTR [edi+ebx*4]
	lea	ecx, DWORD PTR [ebx+edi*4]
	lea	edx, DWORD PTR _trans$[ebp+edx+24]
	lea	eax, DWORD PTR _jac$[ebp+eax*8]
	lea	ecx, DWORD PTR _trans$[ebp+ecx*8]
	sub	esi, edi
$LC9@dodec_form:

; 386  :       jac[i][j] = (trans[j][i] - y[i]*trans[j][3]/y[3])/y[3];

	fld	QWORD PTR _y$[ebp+ebx*8]
	add	eax, 8
	fmul	QWORD PTR [edx]
	add	ecx, 32					; 00000020H
	add	edx, 32					; 00000020H
	dec	esi
	fdiv	ST(0), ST(1)
	fsubr	QWORD PTR [ecx-32]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC9@dodec_form

; 385  :     for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _web+616
$LN11@dodec_form:

; 382  : 
; 383  :   /* set up Jacobian */
; 384  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR tv1202[ebp]
	inc	ebx
	add	eax, 32					; 00000020H
	mov	DWORD PTR _i$[ebp], ebx
	mov	DWORD PTR tv1202[ebp], eax
	cmp	ebx, esi
	jl	$LN27@dodec_form
	mov	edi, DWORD PTR _yform$GSCopy$[ebp]
	fstp	ST(0)
$LN10@dodec_form:

; 387  : 
; 388  :   /* pull back form with transpose of jacobian */
; 389  :   for ( i = 0 ; i < SDIM ; i++ )

	xor	ebx, ebx
	test	esi, esi
	jle	SHORT $LN29@dodec_form
	mov	ecx, DWORD PTR _xform$GSCopy$[ebp]
	fldz
	lea	edx, DWORD PTR _jac$[ebp]
	sub	edx, ecx
	mov	DWORD PTR tv1378[ebp], edx
$LN6@dodec_form:

; 390  :      for ( j = 0, xform[i] = 0. ; j < SDIM ; j++ )

	fst	QWORD PTR [ecx]
	mov	esi, DWORD PTR _web+616
	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN5@dodec_form

; 387  : 
; 388  :   /* pull back form with transpose of jacobian */
; 389  :   for ( i = 0 ; i < SDIM ; i++ )

	add	edx, ecx
$LN3@dodec_form:

; 391  :         xform[i] += jac[j][i]*yform[j];

	fld	QWORD PTR [edi+eax*8]
	inc	eax
	fmul	QWORD PTR [edx]
	add	edx, 32					; 00000020H
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	esi, DWORD PTR _web+616
	cmp	eax, esi
	jl	SHORT $LN3@dodec_form

; 390  :      for ( j = 0, xform[i] = 0. ; j < SDIM ; j++ )

	mov	edx, DWORD PTR tv1378[ebp]
$LN5@dodec_form:

; 387  : 
; 388  :   /* pull back form with transpose of jacobian */
; 389  :   for ( i = 0 ; i < SDIM ; i++ )

	inc	ebx
	add	ecx, 8
	cmp	ebx, esi
	jl	SHORT $LN6@dodec_form
	fstp	ST(0)
$LN29@dodec_form:

; 392  : 
; 393  : } // end dodec_form_pullback()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	ebx
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_dodec_form_pullback ENDP
_TEXT	ENDS
END
