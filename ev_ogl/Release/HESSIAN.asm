; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\HESSIAN.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_vhead
PUBLIC	_conrhs
_DATA	SEGMENT
COMM	_ritzvecs:DWORD
COMM	_vertex_rows:DWORD
COMM	_vhead_count:DWORD
COMM	_hmode:DWORD
COMM	_hess_debug:DWORD
COMM	_rhs_norm:QWORD
COMM	_vproj_space:DWORD
COMM	_conhess_base:DWORD
COMM	_vproj_base:DWORD
_DATA	ENDS
_BSS	SEGMENT
_vhead	DD	01H DUP (?)
_conrhs	DD	01H DUP (?)
_BSS	ENDS
PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_unset_attr
; Function compile flags: /Ogtp
;	COMDAT _unset_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_unset_attr PROC					; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp

; 29   :   elptr(id)->attr &= ~attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	not	ecx
	and	DWORD PTR [eax+8], ecx
	not	edx
	and	DWORD PTR [eax+12], edx

; 30   : }

	pop	ebp
	ret	0
_unset_attr ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_get_body_volume
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_body_volume
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_volume PROC					; COMDAT

; 308  :     { return    ( valid_id(b_id) ?  bptr(b_id)->volume : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_v
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+40]
	pop	ebp
	ret	0
$LN3@get_body_v:
	fldz
	pop	ebp
	ret	0
_get_body_volume ENDP
_TEXT	ENDS
PUBLIC	_get_body_fixvol
; Function compile flags: /Ogtp
;	COMDAT _get_body_fixvol
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_fixvol PROC					; COMDAT

; 311  :      { return ( valid_id(b_id) ?  bptr(b_id)->fixvol : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_f
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+32]
	pop	ebp
	ret	0
$LN3@get_body_f:
	fldz
	pop	ebp
	ret	0
_get_body_fixvol ENDP
_TEXT	ENDS
PUBLIC	_grad$GSCopy$
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_fill_grad
EXTRN	_sp_hash_search:PROC
EXTRN	_dot:PROC
EXTRN	_hess_flag:DWORD
EXTRN	_vec_mat_mul:PROC
EXTRN	_rhs_flag:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\hessian.c
;	COMDAT _fill_grad
_TEXT	SEGMENT
_grad$GSCopy$ = -64					; size = 4
_S$GSCopy$ = -60					; size = 4
tv275 = -56						; size = 4
_g$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_v$ = 12						; size = 4
_grad$ = 16						; size = 4
_rhs$ = 20						; size = 4
_fill_grad PROC						; COMDAT

; 107  : { REAL g[MAXCOORD];

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 108  :   int k,a,b;
; 109  : 
; 110  :   if ( rhs_flag )

	cmp	DWORD PTR _rhs_flag, 0
	mov	eax, DWORD PTR _S$[ebp]
	mov	edx, DWORD PTR _grad$[ebp]
	push	esi
	mov	esi, DWORD PTR _v$[ebp]
	push	edi
	mov	edi, DWORD PTR _rhs$[ebp]

; 122  :   { 
; 123  :     for ( a = 0 ; a < v->freedom ; a++ )

	mov	DWORD PTR _S$GSCopy$[ebp], eax
	mov	DWORD PTR _grad$GSCopy$[ebp], edx
	je	SHORT $LN8@fill_grad

; 111  :   { if ( v->proj )

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN15@fill_grad

; 112  :     { vec_mat_mul(grad,v->proj,g,SDIM,v->freedom);

	mov	ecx, DWORD PTR [esi+8]
	push	ecx
	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	ecx, DWORD PTR _g$[ebp]
	push	ecx
	push	eax
	push	edx
	call	_vec_mat_mul

; 113  :       for ( k = 0 ; k < v->freedom ; k++ )

	xor	eax, eax
	add	esp, 20					; 00000014H
	cmp	DWORD PTR [esi+8], eax
	jle	SHORT $LN8@fill_grad
$LL14@fill_grad:

; 114  :           rhs[v->rownum+k] -= g[k];

	mov	edx, DWORD PTR [esi+12]
	add	edx, eax
	fld	QWORD PTR [edi+edx*8]
	lea	ecx, DWORD PTR [edi+edx*8]
	fsub	QWORD PTR _g$[ebp+eax*8]
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR [esi+8]
	jl	SHORT $LL14@fill_grad

; 115  :     }
; 116  :     else

	jmp	SHORT $LN8@fill_grad
$LN15@fill_grad:

; 117  :       for ( k = 0 ; k < v->freedom ; k++ )

	xor	eax, eax
	cmp	DWORD PTR [esi+8], eax
	jle	SHORT $LN8@fill_grad
$LL10@fill_grad:

; 118  :          rhs[v->rownum+k] -= grad[k];

	mov	ecx, DWORD PTR [esi+12]
	add	ecx, eax
	fld	QWORD PTR [edi+ecx*8]
	lea	ecx, DWORD PTR [edi+ecx*8]
	fsub	QWORD PTR [edx+eax*8]
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR [esi+8]
	jl	SHORT $LL10@fill_grad
$LN8@fill_grad:

; 119  :   }
; 120  : 
; 121  :   if ( hess_flag && v->conhess )

	cmp	DWORD PTR _hess_flag, 0
	je	SHORT $LN4@fill_grad
	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN4@fill_grad

; 122  :   { 
; 123  :     for ( a = 0 ; a < v->freedom ; a++ )

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+8], ebx
	jle	SHORT $LN28@fill_grad
$LL27@fill_grad:

; 124  :      for ( b = 0 ; b <= a ; b++ )

	xor	edi, edi
	test	ebx, ebx
	js	SHORT $LN5@fill_grad
	npad	9
$LL3@fill_grad:

; 125  :        sp_hash_search(S,v->rownum+b,v->rownum+a,
; 126  :           SDIM_dot(grad,v->conhess[a][b]));

	mov	edx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+20]
	mov	eax, DWORD PTR _web+616
	mov	DWORD PTR tv275[ebp], edx
	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR _grad$GSCopy$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+edi*4]
	push	eax
	push	ecx
	call	_dot
	fstp	QWORD PTR [esp+4]
	mov	eax, DWORD PTR tv275[ebp]
	add	esp, 4
	lea	edx, DWORD PTR [eax+ebx]
	push	edx
	add	eax, edi
	push	eax
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	push	eax
	call	_sp_hash_search
	inc	edi
	add	esp, 20					; 00000014H
	cmp	edi, ebx
	jle	SHORT $LL3@fill_grad
$LN5@fill_grad:

; 122  :   { 
; 123  :     for ( a = 0 ; a < v->freedom ; a++ )

	inc	ebx
	cmp	ebx, DWORD PTR [esi+8]
	jl	SHORT $LL27@fill_grad
$LN28@fill_grad:
	pop	ebx
$LN4@fill_grad:

; 127  :   }
; 128  : } // end fill_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fill_grad ENDP
_TEXT	ENDS
PUBLIC	_self$GSCopy$
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_fill_self_entry
EXTRN	_mat_mult:PROC
EXTRN	_tr_mat_mul:PROC
EXTRN	_mat2d_setup:PROC
EXTRN	_dymem:DWORD
EXTRN	_vhead_attr:DWORD
; Function compile flags: /Ogtp
;	COMDAT _fill_self_entry
_TEXT	SEGMENT
_temp_mat2qXvS$89304 = -636				; size = 24
_temp_matqXvS$89300 = -612				; size = 24
_S$GSCopy$ = -588					; size = 4
tv336 = -584						; size = 4
tv313 = -584						; size = 4
_self$GSCopy$ = -584					; size = 4
_temp_matxJ$89301 = -580				; size = 288
_temp_mat2xJ$89305 = -292				; size = 288
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_v_id$ = 12						; size = 4
_self$ = 16						; size = 4
_fill_self_entry PROC					; COMDAT

; 142  : { int j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 636				; 0000027cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 143  :   struct hess_verlist *v;
; 144  : 
; 145  :   v = get_vertex_vhead(v_id);

	mov	edx, DWORD PTR _vhead_attr
	mov	eax, DWORD PTR _S$[ebp]
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR _self$[ebp]

; 152  :     for ( j = 0 ; j < v->freedom ; j++ )

	mov	DWORD PTR _S$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _v_id$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+64]
	mov	esi, DWORD PTR [eax+edx]
	shl	esi, 5
	add	esi, DWORD PTR _vhead
	push	edi
	cmp	DWORD PTR [esi+16], 0
	mov	DWORD PTR _self$GSCopy$[ebp], ecx
	je	$LN14@fill_self_

; 146  : 
; 147  :   if ( v->proj )
; 148  :   { MAT2D(temp_mat,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _temp_matxJ$89301[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp_matqXvS$89300[ebp]
	push	ecx
	call	_mat2d_setup

; 149  :     MAT2D(temp_mat2,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	edx, DWORD PTR _temp_mat2xJ$89305[ebp]
	mov	ebx, eax
	push	edx
	lea	eax, DWORD PTR _temp_mat2qXvS$89304[ebp]
	push	eax
	call	_mat2d_setup

; 150  :     tr_mat_mul(v->proj,self,temp_mat,SDIM,v->freedom,SDIM);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _self$GSCopy$[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR _web+616
	push	eax
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+16]
	push	ebx
	push	edx
	push	eax
	call	_tr_mat_mul

; 151  :     mat_mult(temp_mat,v->proj,temp_mat2,v->freedom,SDIM,v->freedom);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [esi+16]
	push	eax
	push	ecx
	push	eax
	push	edi
	push	edx
	push	ebx
	call	_mat_mult

; 152  :     for ( j = 0 ; j < v->freedom ; j++ )

	xor	ebx, ebx
	add	esp, 80					; 00000050H
	cmp	DWORD PTR [esi+8], ebx
	jle	$LN4@fill_self_

; 146  : 
; 147  :   if ( v->proj )
; 148  :   { MAT2D(temp_mat,MAXCOORD,MAXCOORD);

	mov	DWORD PTR tv313[ebp], edi
$LL25@fill_self_:

; 153  :       for ( k = 0 ; k <= j ; k++ )

	xor	edi, edi
	test	ebx, ebx
	js	SHORT $LN12@fill_self_
	npad	6
$LL26@fill_self_:

; 154  :          sp_hash_search(S,v->rownum+k,v->rownum+j, temp_mat2[j][k]);

	mov	ecx, DWORD PTR tv313[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi+12]
	fld	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	sub	esp, 8
	lea	ecx, DWORD PTR [eax+ebx]
	fstp	QWORD PTR [esp]
	push	ecx
	add	eax, edi
	push	eax
	push	edx
	call	_sp_hash_search
	inc	edi
	add	esp, 20					; 00000014H
	cmp	edi, ebx
	jle	SHORT $LL26@fill_self_
$LN12@fill_self_:

; 152  :     for ( j = 0 ; j < v->freedom ; j++ )

	add	DWORD PTR tv313[ebp], 4
	inc	ebx
	cmp	ebx, DWORD PTR [esi+8]
	jl	SHORT $LL25@fill_self_
	pop	edi
	pop	esi
	pop	ebx

; 160  :   }
; 161  : } // end fill_self_entry()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@fill_self_:

; 155  :   }
; 156  :   else 
; 157  :   { for ( j = 0 ; j < v->freedom ; j++ )

	xor	ebx, ebx
	cmp	DWORD PTR [esi+8], ebx
	jle	SHORT $LN4@fill_self_
	mov	DWORD PTR tv336[ebp], ecx
	npad	6
$LL27@fill_self_:

; 158  :       for ( k = 0 ; k <= j ; k++ )

	xor	edi, edi
	test	ebx, ebx
	js	SHORT $LN5@fill_self_
	npad	10
$LL28@fill_self_:

; 159  :         sp_hash_search(S,v->rownum+k,v->rownum+j,self[j][k]);

	mov	ecx, DWORD PTR tv336[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi+12]
	fld	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	sub	esp, 8
	lea	ecx, DWORD PTR [eax+ebx]
	fstp	QWORD PTR [esp]
	push	ecx
	add	eax, edi
	push	eax
	push	edx
	call	_sp_hash_search
	inc	edi
	add	esp, 20					; 00000014H
	cmp	edi, ebx
	jle	SHORT $LL28@fill_self_
$LN5@fill_self_:

; 155  :   }
; 156  :   else 
; 157  :   { for ( j = 0 ; j < v->freedom ; j++ )

	add	DWORD PTR tv336[ebp], 4
	inc	ebx
	cmp	ebx, DWORD PTR [esi+8]
	jl	SHORT $LL27@fill_self_
$LN4@fill_self_:

; 160  :   }
; 161  : } // end fill_self_entry()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fill_self_entry ENDP
_TEXT	ENDS
PUBLIC	_mixed$GSCopy$
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_fill_mixed_entry
; Function compile flags: /Ogtp
;	COMDAT _fill_mixed_entry
_TEXT	SEGMENT
_temp_mat2qXvS$ = -644					; size = 24
_temp_matqXvS$ = -620					; size = 24
_temp_mat$ = -596					; size = 4
_S$GSCopy$ = -592					; size = 4
tv385 = -588						; size = 4
tv363 = -588						; size = 4
_temp_mat2$ = -588					; size = 4
_mixed$GSCopy$ = -584					; size = 4
_j$ = -584						; size = 4
_temp_mat2xJ$ = -580					; size = 288
_temp_matxJ$ = -292					; size = 288
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_v_id1$ = 12						; size = 4
_v_id2$ = 16						; size = 4
_mixed$ = 20						; size = 4
_fill_mixed_entry PROC					; COMDAT

; 177  : { int k,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 644				; 00000284H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 185  :     return;

	mov	eax, DWORD PTR _mixed$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _v_id2$[ebp]
	push	esi
	mov	esi, DWORD PTR _v_id1$[ebp]
	push	edi
	mov	edi, DWORD PTR _S$[ebp]
	push	6
	push	6
	lea	ecx, DWORD PTR _temp_matxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _temp_matqXvS$[ebp]
	push	edx

; 207  :         sp_hash_search(S,v2->rownum+k,v1->rownum+j,oo[j][k]);

	mov	DWORD PTR _S$GSCopy$[ebp], edi
	mov	DWORD PTR _mixed$GSCopy$[ebp], eax
	call	_mat2d_setup
	push	6
	mov	DWORD PTR _temp_mat$[ebp], eax
	push	6
	lea	eax, DWORD PTR _temp_mat2xJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp_mat2qXvS$[ebp]
	push	ecx
	call	_mat2d_setup
	add	esp, 32					; 00000020H
	mov	DWORD PTR _temp_mat2$[ebp], eax
	cmp	esi, ebx
	jne	SHORT $LN18@fill_mixed

; 178  :   REAL **oo;
; 179  :   MAT2D(temp_mat,MAXCOORD,MAXCOORD);
; 180  :   MAT2D(temp_mat2,MAXCOORD,MAXCOORD);
; 181  :   struct hess_verlist *v1,*v2;
; 182  :   
; 183  :   if ( equal_id(v_id1,v_id2) )
; 184  :   { fill_self_entry(S,v_id1,mixed);

	mov	edx, DWORD PTR _mixed$GSCopy$[ebp]
	push	edx
	push	esi
	push	edi
	call	_fill_self_entry
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 208  : 
; 209  : } // end fill_mixed_entry(

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@fill_mixed:

; 186  :   }
; 187  : 
; 188  :   v1 = get_vertex_vhead(v_id1); 

	mov	eax, DWORD PTR _vhead_attr
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	edi, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR _vhead

; 189  :   v2 = get_vertex_vhead(v_id2);

	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	esi, DWORD PTR [eax+ecx]
	shl	edi, 5

; 190  :   if ( v1->proj )

	mov	eax, DWORD PTR [edi+edx+16]
	add	edi, edx
	shl	esi, 5
	add	esi, edx
	test	eax, eax
	je	SHORT $LN17@fill_mixed

; 191  :   { tr_mat_mul(v1->proj,mixed,temp_mat,SDIM,v1->freedom,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR [edi+8]
	mov	ebx, DWORD PTR _temp_mat$[ebp]
	push	ecx
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _mixed$GSCopy$[ebp]
	push	ebx
	push	ecx
	push	eax
	call	_tr_mat_mul
	add	esp, 24					; 00000018H

; 192  :     oo = temp_mat;

	mov	ecx, ebx
	jmp	SHORT $LN16@fill_mixed
$LN17@fill_mixed:

; 193  :   }
; 194  :   else oo = mixed;

	mov	ecx, DWORD PTR _mixed$GSCopy$[ebp]
$LN16@fill_mixed:

; 195  :   if ( v2->proj )

	mov	eax, DWORD PTR [esi+16]
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $LN15@fill_mixed

; 196  :   { mat_mult(oo,v2->proj,temp_mat2,v1->freedom,SDIM,v2->freedom);

	mov	edx, DWORD PTR [esi+8]
	push	edx
	mov	edx, DWORD PTR _web+616
	push	edx
	mov	edx, DWORD PTR [edi+8]
	push	edx
	mov	edx, DWORD PTR _temp_mat2$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_mat_mult

; 197  :     oo = temp_mat2;

	mov	ecx, DWORD PTR _temp_mat2$[ebp]
	add	esp, 24					; 00000018H
$LN15@fill_mixed:

; 198  :   }
; 199  : 
; 200  :   if ( v1->rownum < v2->rownum )

	mov	eax, DWORD PTR [edi+12]

; 201  :     for ( j = 0 ; j < v1->freedom ; j++ )

	mov	DWORD PTR _j$[ebp], ebx
	cmp	eax, DWORD PTR [esi+12]
	jge	$LN14@fill_mixed
	cmp	DWORD PTR [edi+8], ebx
	jle	$LN4@fill_mixed
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR tv363[ebp], ecx
$LL31@fill_mixed:

; 202  :      for ( k = 0 ; k < v2->freedom ; k++ )

	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN12@fill_mixed
	npad	8
$LL32@fill_mixed:

; 203  :         sp_hash_search(S,v1->rownum+j,v2->rownum+k,oo[j][k]);

	mov	ecx, DWORD PTR tv363[ebp]
	mov	edx, DWORD PTR [ecx]
	fld	QWORD PTR [edx+ebx*8]
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi+12]
	add	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	add	eax, ebx
	push	eax
	push	ecx
	push	edx
	call	_sp_hash_search
	mov	eax, DWORD PTR [esi+8]
	inc	ebx
	add	esp, 20					; 00000014H
	cmp	ebx, eax
	jl	SHORT $LL32@fill_mixed
$LN12@fill_mixed:

; 201  :     for ( j = 0 ; j < v1->freedom ; j++ )

	mov	ecx, DWORD PTR _j$[ebp]
	add	DWORD PTR tv363[ebp], 4
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+8]
	jl	SHORT $LL31@fill_mixed
	pop	edi
	pop	esi
	pop	ebx

; 208  : 
; 209  : } // end fill_mixed_entry(

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@fill_mixed:

; 204  :   else 
; 205  :     for ( j = 0 ; j < v1->freedom ; j++ )

	cmp	DWORD PTR [edi+8], ebx
	jle	SHORT $LN4@fill_mixed
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR tv385[ebp], ecx
$LL29@fill_mixed:

; 206  :       for ( k = 0 ; k < v2->freedom ; k++ )

	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN5@fill_mixed
	npad	10
$LL30@fill_mixed:

; 207  :         sp_hash_search(S,v2->rownum+k,v1->rownum+j,oo[j][k]);

	mov	eax, DWORD PTR tv385[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edi+12]
	fld	QWORD PTR [ecx+ebx*8]
	add	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	add	eax, ebx
	push	eax
	push	ecx
	call	_sp_hash_search
	mov	eax, DWORD PTR [esi+8]
	inc	ebx
	add	esp, 20					; 00000014H
	cmp	ebx, eax
	jl	SHORT $LL30@fill_mixed
$LN5@fill_mixed:

; 204  :   else 
; 205  :     for ( j = 0 ; j < v1->freedom ; j++ )

	mov	ecx, DWORD PTR _j$[ebp]
	add	DWORD PTR tv385[ebp], 4
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+8]
	jl	SHORT $LL29@fill_mixed
$LN4@fill_mixed:

; 208  : 
; 209  : } // end fill_mixed_entry(

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fill_mixed_entry ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_square_grad
EXTRN	_optparam:BYTE
EXTRN	_optparamcount:DWORD
EXTRN	_hessian_normal_flag:DWORD
EXTRN	_Met:BYTE
EXTRN	_hessian_linear_metric_flag:DWORD
EXTRN	_vgrad_end:PROC
EXTRN	_lagrange_adjust:PROC
EXTRN	_calc_lagrange:PROC
EXTRN	_fix_vertices:PROC
EXTRN	_pressure_forces:PROC
EXTRN	_calc_force:PROC
EXTRN	_volume_restore:PROC
EXTRN	_calc_all_grads:PROC
EXTRN	_min_square_grad_flag:DWORD
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _square_grad
_TEXT	SEGMENT
_sum$ = -68						; size = 8
_star$89412 = -60					; size = 8
tv481 = -56						; size = 4
_r$89425 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_square_grad PROC					; COMDAT

; 395  : { REAL sum;

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 396  :   vertex_id v_id;
; 397  :   REAL *f;
; 398  :   int i;
; 399  :   int oldflag = min_square_grad_flag;

	mov	esi, DWORD PTR _min_square_grad_flag

; 400  :  
; 401  :   calc_all_grads(CALC_VOLGRADS);

	push	2
	call	_calc_all_grads

; 402  :   volume_restore(1.,ACTUAL_MOVE);

	fld1
	add	esp, 4
	push	1
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_volume_restore
	add	esp, 12					; 0000000cH

; 403  :   min_square_grad_flag = 0; /* so calc_force does regular forces */

	mov	DWORD PTR _min_square_grad_flag, 0

; 404  :   calc_force();

	call	_calc_force

; 405  :   min_square_grad_flag = oldflag;

	mov	DWORD PTR _min_square_grad_flag, esi

; 406  :   pressure_forces();

	call	_pressure_forces

; 407  :   fix_vertices(); /* project forces to constraints, etc */

	call	_fix_vertices

; 408  :   calc_lagrange();

	call	_calc_lagrange

; 409  :   lagrange_adjust();

	call	_lagrange_adjust

; 410  :   vgrad_end();

	call	_vgrad_end

; 411  :   sum = 0.0;

	fldz

; 412  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	fst	QWORD PTR _sum$[ebp]
	test	eax, 268435456				; 10000000H
	je	$LN10@square_gra
	push	ebx
	push	edi
$LN23@square_gra:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _web+12
	mov	edx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN11@square_gra

; 413  :   { REAL star;
; 414  :      f = get_force(v_id);

	mov	esi, DWORD PTR _web+104
	fstp	ST(0)
	mov	ebx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [esi+ebx+784]

; 415  :      if ( hessian_linear_metric_flag )

	mov	eax, DWORD PTR _vhead_attr
	add	ecx, edx
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $LN7@square_gra

; 416  :         star = Met.apinv[get_vertex_vhead(v_id)->rownum];

	mov	ebx, eax
	imul	ebx, 240				; 000000f0H
	add	ebx, esi
	mov	esi, ebx
	mov	ebx, DWORD PTR _dymem
	mov	esi, DWORD PTR [esi+ebx+64]
	mov	edx, DWORD PTR [edx+esi]
	mov	esi, DWORD PTR _vhead
	shl	edx, 5
	mov	edx, DWORD PTR [edx+esi+12]
	mov	esi, DWORD PTR _Met+200
	fld	QWORD PTR [esi+edx*8]
	mov	esi, DWORD PTR _web+104
	jmp	SHORT $LN44@square_gra
$LN7@square_gra:

; 417  :      else star = 1.0;

	fld1
$LN44@square_gra:

; 418  :      if ( hessian_normal_flag )

	cmp	DWORD PTR _hessian_normal_flag, 0
	fstp	QWORD PTR _star$89412[ebp]
	je	SHORT $LN5@square_gra

; 419  :      { struct hess_verlist *v;              /* current  vertex */
; 420  :         REAL r[MAXCOORD];
; 421  :         REAL *rr = r;
; 422  :         v = get_vertex_vhead(v_id);

	mov	edx, DWORD PTR _web+12
	imul	eax, 240				; 000000f0H
	mov	edx, DWORD PTR [edi+edx]
	add	eax, esi
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	esi, DWORD PTR [eax+edx]

; 423  :         vec_mat_mul(f,v->proj,rr,SDIM,v->freedom);

	mov	edx, DWORD PTR _web+616
	shl	esi, 5
	add	esi, DWORD PTR _vhead
	mov	eax, DWORD PTR [esi+8]
	push	eax
	push	edx
	mov	edx, DWORD PTR [esi+16]
	lea	eax, DWORD PTR _r$89425[ebp]
	push	eax
	push	edx
	push	ecx
	call	_vec_mat_mul

; 424  :         sum += dot(r,r,v->freedom)*star;

	mov	eax, DWORD PTR [esi+8]
	push	eax
	lea	ecx, DWORD PTR _r$89425[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	add	esp, 32					; 00000020H
	jmp	SHORT $LN45@square_gra
$LN5@square_gra:

; 425  :      }
; 426  :      else sum += SDIM_dot(f,f)*star;

	mov	eax, DWORD PTR _web+616
	push	eax
	push	ecx
	push	ecx
	call	_dot
	add	esp, 12					; 0000000cH
$LN45@square_gra:
	fmul	QWORD PTR _star$89412[ebp]
	fadd	QWORD PTR _sum$[ebp]
	fst	QWORD PTR _sum$[ebp]
$LN11@square_gra:

; 412  :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	$LN23@square_gra
	pop	edi
	pop	ebx
$LN10@square_gra:

; 427  :   }
; 428  :   for ( i = 0 ; i < optparamcount ; i++ )

	mov	esi, DWORD PTR _optparamcount
	xor	edx, edx
	cmp	esi, 4
	jl	SHORT $LN24@square_gra
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	inc	ecx
	mov	eax, OFFSET _optparam+64
	lea	edx, DWORD PTR [ecx*4]
$LN21@square_gra:

; 429  :      sum += optparam[i].grad*optparam[i].grad;

	fld	QWORD PTR [eax-56]
	add	eax, 224				; 000000e0H
	dec	ecx
	fld	QWORD PTR [eax-224]
	fld	QWORD PTR [eax-168]
	fld	QWORD PTR [eax-112]
	fld	ST(3)
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	faddp	ST(4), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(3)
	faddp	ST(1), ST(0)
	fld	ST(2)
	fmulp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LN21@square_gra
$LN24@square_gra:

; 427  :   }
; 428  :   for ( i = 0 ; i < optparamcount ; i++ )

	cmp	edx, esi
	jge	SHORT $LN19@square_gra
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	lea	eax, DWORD PTR _optparam[eax*8+8]
	sub	esi, edx
$LC3@square_gra:

; 429  :      sum += optparam[i].grad*optparam[i].grad;

	fld	QWORD PTR [eax]
	add	eax, 56					; 00000038H
	dec	esi
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LC3@square_gra
$LN19@square_gra:

; 430  :   return sum;
; 431  : 
; 432  : } // end square_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_square_grad ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@CILCDHHB@0?4?5Exit?5hessian?4?6?$AA@	; `string'
PUBLIC	??_C@_0CL@HNPAIDFM@?$DN?4?5Execute?5Evolver?5commands?5in?5s@ ; `string'
PUBLIC	??_C@_0DM@HOBDGICL@K?4?5Dump?5Hessian?5to?5text?5file?5in?5@ ; `string'
PUBLIC	??_C@_0DH@CJOEHPIL@D?4?5Dump?5Hessian?5to?5text?5file?5in?5@ ; `string'
PUBLIC	??_C@_0CP@ONBDLACE@G?4?5Toggle?5minimizing?5square?5grad@ ; `string'
PUBLIC	??_C@_0EJ@HDJKIGGC@M?4?5Toggle?5projecting?5to?5global?5c@ ; `string'
PUBLIC	??_C@_0CN@NHLKFBIM@U?4?5Toggle?5Bunch?9Kaufman?5version?5@ ; `string'
PUBLIC	??_C@_0DE@FDDHPKFI@Y?4?5Toggle?5YSMP?1alternate?5minimal@ ; `string'
PUBLIC	??_C@_0DG@GHFILFHB@S?4?5Seek?5along?5direction?4?5?$CIDo?53?0V@ ; `string'
PUBLIC	??_C@_0EC@JMGDDLLM@V?4?5Eigenvalue?5probe?5with?5eigenve@ ; `string'
PUBLIC	??_C@_0DB@ONHHAKN@P?4?5Eigenvalue?5probe?4?5?$CIBy?5factori@ ; `string'
PUBLIC	??_C@_0CO@HBHLANLH@X?4?5Pick?5Ritz?5vector?5for?5motion?4?5@ ; `string'
PUBLIC	??_C@_0DK@FOBPFPHN@Z?4?5Ritz?5subspace?5iteration?5for?5e@ ; `string'
PUBLIC	??_C@_0DA@KDCMDIEA@R?4?5Lanczos?5with?5selective?5reorth@ ; `string'
PUBLIC	??_C@_0DE@NPMIGBLP@L?4?5Lanczos?4?5?$CIFinds?5eigenvalues?5n@ ; `string'
PUBLIC	??_C@_0DL@ICPMKFFM@F?4?5Lowest?5eigenvalue?4?5?$CIBy?5conjug@ ; `string'
PUBLIC	??_C@_0DC@JIAHCKBE@E?4?5Lowest?5eigenvalue?4?5?$CIBy?5factor@ ; `string'
PUBLIC	??_C@_0DK@KGMHAPII@C?4?5Chebychev?5?$CIFor?5most?5negative?5@ ; `string'
PUBLIC	??_C@_0CH@KMCHCIPN@B?4?5Chebychev?5?$CIFor?5Hessian?5soluti@ ; `string'
PUBLIC	??_C@_0CH@BEKCFHJP@9?4?5Toggle?5debugging?4?5?$CIDon?8t?5do?5t@ ; `string'
PUBLIC	??_C@_0CC@GEPPGDIH@7?4?5Restore?5original?5coordinates?4@ ; `string'
PUBLIC	??_C@_0CH@DBDKCENG@4?4?5Move?4?5?$CIDo?53?0V?0E?0F?0C?0B?5or?5X?5?5f@ ; `string'
PUBLIC	??_C@_0BI@GJMOEAAD@3?4?5Solve?4?5?$CIDo?52?5first?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@PGEGMJGC@2?4?5Fill?5in?5right?5side?4?5?$CIDo?51?5fir@ ; `string'
PUBLIC	??_C@_0BM@DKEOJPOI@1?4?5Fill?5in?5hessian?5matrix?4?6?$AA@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	_print_hessian_menu
EXTRN	_outstring:PROC
;	COMDAT ??_C@_0BC@CILCDHHB@0?4?5Exit?5hessian?4?6?$AA@
CONST	SEGMENT
??_C@_0BC@CILCDHHB@0?4?5Exit?5hessian?4?6?$AA@ DB '0. Exit hessian.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HNPAIDFM@?$DN?4?5Execute?5Evolver?5commands?5in?5s@
CONST	SEGMENT
??_C@_0CL@HNPAIDFM@?$DN?4?5Execute?5Evolver?5commands?5in?5s@ DB '=. Exec'
	DB	'ute Evolver commands in subprompt.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@HOBDGICL@K?4?5Dump?5Hessian?5to?5text?5file?5in?5@
CONST	SEGMENT
??_C@_0DM@HOBDGICL@K?4?5Dump?5Hessian?5to?5text?5file?5in?5@ DB 'K. Dump '
	DB	'Hessian to text file in Mathematica sparse format.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@CJOEHPIL@D?4?5Dump?5Hessian?5to?5text?5file?5in?5@
CONST	SEGMENT
??_C@_0DH@CJOEHPIL@D?4?5Dump?5Hessian?5to?5text?5file?5in?5@ DB 'D. Dump '
	DB	'Hessian to text file in Matlab sparse format.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@ONBDLACE@G?4?5Toggle?5minimizing?5square?5grad@
CONST	SEGMENT
??_C@_0CP@ONBDLACE@G?4?5Toggle?5minimizing?5square?5grad@ DB 'G. Toggle m'
	DB	'inimizing square gradient in seek.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@HDJKIGGC@M?4?5Toggle?5projecting?5to?5global?5c@
CONST	SEGMENT
??_C@_0EJ@HDJKIGGC@M?4?5Toggle?5projecting?5to?5global?5c@ DB 'M. Toggle '
	DB	'projecting to global constraints in move. (Leave this alone!)'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NHLKFBIM@U?4?5Toggle?5Bunch?9Kaufman?5version?5@
CONST	SEGMENT
??_C@_0CN@NHLKFBIM@U?4?5Toggle?5Bunch?9Kaufman?5version?5@ DB 'U. Toggle '
	DB	'Bunch-Kaufman version of min deg.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FDDHPKFI@Y?4?5Toggle?5YSMP?1alternate?5minimal@
CONST	SEGMENT
??_C@_0DE@FDDHPKFI@Y?4?5Toggle?5YSMP?1alternate?5minimal@ DB 'Y. Toggle Y'
	DB	'SMP/alternate minimal degree factoring.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@GHFILFHB@S?4?5Seek?5along?5direction?4?5?$CIDo?53?0V@
CONST	SEGMENT
??_C@_0DG@GHFILFHB@S?4?5Seek?5along?5direction?4?5?$CIDo?53?0V@ DB 'S. Se'
	DB	'ek along direction. (Do 3,V,E,F,C,B or X first)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@JMGDDLLM@V?4?5Eigenvalue?5probe?5with?5eigenve@
CONST	SEGMENT
??_C@_0EC@JMGDDLLM@V?4?5Eigenvalue?5probe?5with?5eigenve@ DB 'V. Eigenval'
	DB	'ue probe with eigenvector. (By factoring. Do 1 first)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@ONHHAKN@P?4?5Eigenvalue?5probe?4?5?$CIBy?5factori@
CONST	SEGMENT
??_C@_0DB@ONHHAKN@P?4?5Eigenvalue?5probe?4?5?$CIBy?5factori@ DB 'P. Eigen'
	DB	'value probe. (By factoring. Do 1 first)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HBHLANLH@X?4?5Pick?5Ritz?5vector?5for?5motion?4?5@
CONST	SEGMENT
??_C@_0CO@HBHLANLH@X?4?5Pick?5Ritz?5vector?5for?5motion?4?5@ DB 'X. Pick '
	DB	'Ritz vector for motion. (Do Z first)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@FOBPFPHN@Z?4?5Ritz?5subspace?5iteration?5for?5e@
CONST	SEGMENT
??_C@_0DK@FOBPFPHN@Z?4?5Ritz?5subspace?5iteration?5for?5e@ DB 'Z. Ritz su'
	DB	'bspace iteration for eigenvalues. (Do 1 first)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KDCMDIEA@R?4?5Lanczos?5with?5selective?5reorth@
CONST	SEGMENT
??_C@_0DA@KDCMDIEA@R?4?5Lanczos?5with?5selective?5reorth@ DB 'R. Lanczos '
	DB	'with selective reorthogonalization.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NPMIGBLP@L?4?5Lanczos?4?5?$CIFinds?5eigenvalues?5n@
CONST	SEGMENT
??_C@_0DE@NPMIGBLP@L?4?5Lanczos?4?5?$CIFinds?5eigenvalues?5n@ DB 'L. Lanc'
	DB	'zos. (Finds eigenvalues near probe value. )', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@ICPMKFFM@F?4?5Lowest?5eigenvalue?4?5?$CIBy?5conjug@
CONST	SEGMENT
??_C@_0DL@ICPMKFFM@F?4?5Lowest?5eigenvalue?4?5?$CIBy?5conjug@ DB 'F. Lowe'
	DB	'st eigenvalue. (By conjugate gradient. Do 1 first)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@JIAHCKBE@E?4?5Lowest?5eigenvalue?4?5?$CIBy?5factor@
CONST	SEGMENT
??_C@_0DC@JIAHCKBE@E?4?5Lowest?5eigenvalue?4?5?$CIBy?5factor@ DB 'E. Lowe'
	DB	'st eigenvalue. (By factoring. Do 1 first)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@KGMHAPII@C?4?5Chebychev?5?$CIFor?5most?5negative?5@
CONST	SEGMENT
??_C@_0DK@KGMHAPII@C?4?5Chebychev?5?$CIFor?5most?5negative?5@ DB 'C. Cheb'
	DB	'ychev (For most negative eigenvalue eigenvector).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KMCHCIPN@B?4?5Chebychev?5?$CIFor?5Hessian?5soluti@
CONST	SEGMENT
??_C@_0CH@KMCHCIPN@B?4?5Chebychev?5?$CIFor?5Hessian?5soluti@ DB 'B. Cheby'
	DB	'chev (For Hessian solution ).', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BEKCFHJP@9?4?5Toggle?5debugging?4?5?$CIDon?8t?5do?5t@
CONST	SEGMENT
??_C@_0CH@BEKCFHJP@9?4?5Toggle?5debugging?4?5?$CIDon?8t?5do?5t@ DB '9. To'
	DB	'ggle debugging. (Don''t do this!)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GEPPGDIH@7?4?5Restore?5original?5coordinates?4@
CONST	SEGMENT
??_C@_0CC@GEPPGDIH@7?4?5Restore?5original?5coordinates?4@ DB '7. Restore '
	DB	'original coordinates.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DBDKCENG@4?4?5Move?4?5?$CIDo?53?0V?0E?0F?0C?0B?5or?5X?5?5f@
CONST	SEGMENT
??_C@_0CH@DBDKCENG@4?4?5Move?4?5?$CIDo?53?0V?0E?0F?0C?0B?5or?5X?5?5f@ DB '4'
	DB	'. Move. (Do 3,V,E,F,C,B or X  first)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GJMOEAAD@3?4?5Solve?4?5?$CIDo?52?5first?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BI@GJMOEAAD@3?4?5Solve?4?5?$CIDo?52?5first?$CJ?6?$AA@ DB '3. Solve'
	DB	'. (Do 2 first)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PGEGMJGC@2?4?5Fill?5in?5right?5side?4?5?$CIDo?51?5fir@
CONST	SEGMENT
??_C@_0CF@PGEGMJGC@2?4?5Fill?5in?5right?5side?4?5?$CIDo?51?5fir@ DB '2. F'
	DB	'ill in right side. (Do 1 first)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DKEOJPOI@1?4?5Fill?5in?5hessian?5matrix?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@DKEOJPOI@1?4?5Fill?5in?5hessian?5matrix?4?6?$AA@ DB '1. Fill in'
	DB	' hessian matrix.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _print_hessian_menu
_TEXT	SEGMENT
_print_hessian_menu PROC				; COMDAT

; 725  :   outstring("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_outstring

; 726  :   outstring("1. Fill in hessian matrix.\n");

	push	OFFSET ??_C@_0BM@DKEOJPOI@1?4?5Fill?5in?5hessian?5matrix?4?6?$AA@
	call	_outstring

; 727  :   outstring("2. Fill in right side. (Do 1 first)\n");

	push	OFFSET ??_C@_0CF@PGEGMJGC@2?4?5Fill?5in?5right?5side?4?5?$CIDo?51?5fir@
	call	_outstring

; 728  :   outstring("3. Solve. (Do 2 first)\n");

	push	OFFSET ??_C@_0BI@GJMOEAAD@3?4?5Solve?4?5?$CIDo?52?5first?$CJ?6?$AA@
	call	_outstring

; 729  :   outstring("4. Move. (Do 3,V,E,F,C,B or X  first)\n");

	push	OFFSET ??_C@_0CH@DBDKCENG@4?4?5Move?4?5?$CIDo?53?0V?0E?0F?0C?0B?5or?5X?5?5f@
	call	_outstring

; 730  :   outstring("7. Restore original coordinates.\n");

	push	OFFSET ??_C@_0CC@GEPPGDIH@7?4?5Restore?5original?5coordinates?4@
	call	_outstring

; 731  :   outstring("9. Toggle debugging. (Don't do this!)\n");

	push	OFFSET ??_C@_0CH@BEKCFHJP@9?4?5Toggle?5debugging?4?5?$CIDon?8t?5do?5t@
	call	_outstring

; 732  :   outstring("B. Chebychev (For Hessian solution ).\n");

	push	OFFSET ??_C@_0CH@KMCHCIPN@B?4?5Chebychev?5?$CIFor?5Hessian?5soluti@
	call	_outstring

; 733  :   outstring("C. Chebychev (For most negative eigenvalue eigenvector).\n");

	push	OFFSET ??_C@_0DK@KGMHAPII@C?4?5Chebychev?5?$CIFor?5most?5negative?5@
	call	_outstring

; 734  :   outstring("E. Lowest eigenvalue. (By factoring. Do 1 first)\n");

	push	OFFSET ??_C@_0DC@JIAHCKBE@E?4?5Lowest?5eigenvalue?4?5?$CIBy?5factor@
	call	_outstring

; 735  :   outstring("F. Lowest eigenvalue. (By conjugate gradient. Do 1 first)\n");

	push	OFFSET ??_C@_0DL@ICPMKFFM@F?4?5Lowest?5eigenvalue?4?5?$CIBy?5conjug@
	call	_outstring

; 736  :   outstring("L. Lanczos. (Finds eigenvalues near probe value. )\n");

	push	OFFSET ??_C@_0DE@NPMIGBLP@L?4?5Lanczos?4?5?$CIFinds?5eigenvalues?5n@
	call	_outstring

; 737  :   outstring("R. Lanczos with selective reorthogonalization.\n");

	push	OFFSET ??_C@_0DA@KDCMDIEA@R?4?5Lanczos?5with?5selective?5reorth@
	call	_outstring

; 738  :   outstring("Z. Ritz subspace iteration for eigenvalues. (Do 1 first)\n");

	push	OFFSET ??_C@_0DK@FOBPFPHN@Z?4?5Ritz?5subspace?5iteration?5for?5e@
	call	_outstring

; 739  :   outstring("X. Pick Ritz vector for motion. (Do Z first)\n");

	push	OFFSET ??_C@_0CO@HBHLANLH@X?4?5Pick?5Ritz?5vector?5for?5motion?4?5@
	call	_outstring

; 740  :   outstring("P. Eigenvalue probe. (By factoring. Do 1 first)\n");

	push	OFFSET ??_C@_0DB@ONHHAKN@P?4?5Eigenvalue?5probe?4?5?$CIBy?5factori@
	call	_outstring
	add	esp, 64					; 00000040H

; 741  :   outstring("V. Eigenvalue probe with eigenvector. (By factoring. Do 1 first)\n");

	push	OFFSET ??_C@_0EC@JMGDDLLM@V?4?5Eigenvalue?5probe?5with?5eigenve@
	call	_outstring

; 742  :   outstring("S. Seek along direction. (Do 3,V,E,F,C,B or X first)\n");

	push	OFFSET ??_C@_0DG@GHFILFHB@S?4?5Seek?5along?5direction?4?5?$CIDo?53?0V@
	call	_outstring

; 743  :   outstring("Y. Toggle YSMP/alternate minimal degree factoring.\n");

	push	OFFSET ??_C@_0DE@FDDHPKFI@Y?4?5Toggle?5YSMP?1alternate?5minimal@
	call	_outstring

; 744  :   outstring("U. Toggle Bunch-Kaufman version of min deg.\n");

	push	OFFSET ??_C@_0CN@NHLKFBIM@U?4?5Toggle?5Bunch?9Kaufman?5version?5@
	call	_outstring

; 745  :   outstring("M. Toggle projecting to global constraints in move. (Leave this alone!)\n");

	push	OFFSET ??_C@_0EJ@HDJKIGGC@M?4?5Toggle?5projecting?5to?5global?5c@
	call	_outstring

; 746  :   outstring("G. Toggle minimizing square gradient in seek.\n");

	push	OFFSET ??_C@_0CP@ONBDLACE@G?4?5Toggle?5minimizing?5square?5grad@
	call	_outstring

; 747  :   outstring("D. Dump Hessian to text file in Matlab sparse format.\n");

	push	OFFSET ??_C@_0DH@CJOEHPIL@D?4?5Dump?5Hessian?5to?5text?5file?5in?5@
	call	_outstring

; 748  :   outstring("K. Dump Hessian to text file in Mathematica sparse format.\n");

	push	OFFSET ??_C@_0DM@HOBDGICL@K?4?5Dump?5Hessian?5to?5text?5file?5in?5@
	call	_outstring

; 749  :   outstring("=. Execute Evolver commands in subprompt.\n");

	push	OFFSET ??_C@_0CL@HNPAIDFM@?$DN?4?5Execute?5Evolver?5commands?5in?5s@
	call	_outstring

; 750  : #ifdef MPI_EVOLVER
; 751  :   outstring("A. Build corona (MPI version only).\n");
; 752  :   outstring("J. Dissolve corona (MPI version only).\n");
; 753  :   outstring("I. Free discard lists (MPI version only).\n");
; 754  : #endif
; 755  :   outstring("0. Exit hessian.\n");

	push	OFFSET ??_C@_0BC@CILCDHHB@0?4?5Exit?5hessian?4?6?$AA@
	call	_outstring
	add	esp, 40					; 00000028H

; 756  : 
; 757  : } // end print_hessian_menu()

	ret	0
_print_hessian_menu ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EK@IINLFNAA@Pressures?5invalid?4?5Do?5regular?5it@ ; `string'
PUBLIC	??_C@_0EA@GLCAFAG@Hessian?5with?5Riemannian?5metric?5r@ ; `string'
PUBLIC	??_C@_0EG@OLHOBHIP@Cannot?5do?5gap?5energy?5Hessian?0?5si@ ; `string'
PUBLIC	??_C@_0DG@HIJHNLGA@Cannot?5do?5Hessian?5method?5with?5cr@ ; `string'
PUBLIC	??_C@_0EB@BCEDDIBP@Hessian?5with?5pressure?5in?5energy?5@ ; `string'
PUBLIC	??_C@_0DM@BOHAIAKN@Hessian?5method?5for?5gravity?5requi@ ; `string'
PUBLIC	??_C@_0DK@HOCAEIGI@Hessian?5for?5string?5model?5require@ ; `string'
PUBLIC	??_C@_0DP@PCIILACM@Hessian?5for?5non?9LINEAR?5models?5re@ ; `string'
PUBLIC	??_C@_0EG@JJBOAEAF@Cannot?5do?5torus?5body?5volumes?5wit@ ; `string'
PUBLIC	??_C@_0EA@BKEKHLAC@Hessian?5for?5constraint?5content?5r@ ; `string'
PUBLIC	??_C@_0DL@JBFFLGG@Hessian?5for?5simplex?5model?5requir@ ; `string'
PUBLIC	??_C@_0ED@INBDPNCL@Hessian?5for?5optimizing?5parameter@ ; `string'
PUBLIC	??_C@_0EH@MLMCMNG@The?5type?5of?5squared?5mean?5curvatu@ ; `string'
PUBLIC	_hessian_legal
EXTRN	_pressure_set_flag:DWORD
EXTRN	_count_fixed_vol:PROC
EXTRN	_kb_error:PROC
EXTRN	_convert_to_quantities:PROC
EXTRN	_auto_convert_flag:DWORD
EXTRN	_square_curvature_flag:DWORD
EXTRN	_quantities_only_flag:DWORD
;	COMDAT ??_C@_0EK@IINLFNAA@Pressures?5invalid?4?5Do?5regular?5it@
CONST	SEGMENT
??_C@_0EK@IINLFNAA@Pressures?5invalid?4?5Do?5regular?5it@ DB 'Pressures i'
	DB	'nvalid. Do regular iteration before Hessian to set pressures.'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@GLCAFAG@Hessian?5with?5Riemannian?5metric?5r@
CONST	SEGMENT
??_C@_0EA@GLCAFAG@Hessian?5with?5Riemannian?5metric?5r@ DB 'Hessian with '
	DB	'Riemannian metric requires convert_to_quantities.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@OLHOBHIP@Cannot?5do?5gap?5energy?5Hessian?0?5si@
CONST	SEGMENT
??_C@_0EG@OLHOBHIP@Cannot?5do?5gap?5energy?5Hessian?0?5si@ DB 'Cannot do '
	DB	'gap energy Hessian, since it would need third derivatives.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HIJHNLGA@Cannot?5do?5Hessian?5method?5with?5cr@
CONST	SEGMENT
??_C@_0DG@HIJHNLGA@Cannot?5do?5Hessian?5method?5with?5cr@ DB 'Cannot do H'
	DB	'essian method with crystalline integrand.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@BCEDDIBP@Hessian?5with?5pressure?5in?5energy?5@
CONST	SEGMENT
??_C@_0EB@BCEDDIBP@Hessian?5with?5pressure?5in?5energy?5@ DB 'Hessian wit'
	DB	'h pressure in energy requires convert_to_quantities.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@BOHAIAKN@Hessian?5method?5for?5gravity?5requi@
CONST	SEGMENT
??_C@_0DM@BOHAIAKN@Hessian?5method?5for?5gravity?5requi@ DB 'Hessian meth'
	DB	'od for gravity requires convert_to_quantities.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HOCAEIGI@Hessian?5for?5string?5model?5require@
CONST	SEGMENT
??_C@_0DK@HOCAEIGI@Hessian?5for?5string?5model?5require@ DB 'Hessian for '
	DB	'string model requires convert_to_quantities.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@PCIILACM@Hessian?5for?5non?9LINEAR?5models?5re@
CONST	SEGMENT
??_C@_0DP@PCIILACM@Hessian?5for?5non?9LINEAR?5models?5re@ DB 'Hessian for'
	DB	' non-LINEAR models requires convert_to_quantities.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@JJBOAEAF@Cannot?5do?5torus?5body?5volumes?5wit@
CONST	SEGMENT
??_C@_0EG@JJBOAEAF@Cannot?5do?5torus?5body?5volumes?5wit@ DB 'Cannot do t'
	DB	'orus body volumes with hessian. Do convert_to_quantities.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@BKEKHLAC@Hessian?5for?5constraint?5content?5r@
CONST	SEGMENT
??_C@_0EA@BKEKHLAC@Hessian?5for?5constraint?5content?5r@ DB 'Hessian for '
	DB	'constraint content requires convert_to_quantities.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@JBFFLGG@Hessian?5for?5simplex?5model?5requir@
CONST	SEGMENT
??_C@_0DL@JBFFLGG@Hessian?5for?5simplex?5model?5requir@ DB 'Hessian for s'
	DB	'implex model requires convert_to_quantities.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@INBDPNCL@Hessian?5for?5optimizing?5parameter@
CONST	SEGMENT
??_C@_0ED@INBDPNCL@Hessian?5for?5optimizing?5parameter@ DB 'Hessian for o'
	DB	'ptimizing parameters requires convert_to_quantities.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@MLMCMNG@The?5type?5of?5squared?5mean?5curvatu@
CONST	SEGMENT
??_C@_0EH@MLMCMNG@The?5type?5of?5squared?5mean?5curvatu@ DB 'The type of '
	DB	'squared mean curvature in effect does not permit Hessian.', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _hessian_legal
_TEXT	SEGMENT
tv316 = -8						; size = 8
_hessian_legal PROC					; COMDAT

; 1637 : { int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1638 :   body_id b_id;
; 1639 : 
; 1640 :   if ( !quantities_only_flag )

	cmp	DWORD PTR _quantities_only_flag, 0
	jne	$LN2@hessian_le

; 1641 :   {
; 1642 :      if ( square_curvature_flag )

	cmp	DWORD PTR _square_curvature_flag, 0
	je	SHORT $LN41@hessian_le

; 1643 :      { if ( auto_convert_flag ) convert_to_quantities(); else

	cmp	DWORD PTR _auto_convert_flag, 0
	je	SHORT $LN42@hessian_le
	call	_convert_to_quantities
	jmp	SHORT $LN41@hessian_le
$LN42@hessian_le:

; 1644 :        kb_error(2077,"The type of squared mean curvature in effect does not permit Hessian.\n", RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EH@MLMCMNG@The?5type?5of?5squared?5mean?5curvatu@
	push	2077					; 0000081dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN41@hessian_le:

; 1645 :      }
; 1646 : 
; 1647 :      if ( optparamcount > 0 ) 

	cmp	DWORD PTR _optparamcount, 0
	jle	SHORT $LN38@hessian_le

; 1648 :      { if ( auto_convert_flag ) convert_to_quantities(); else

	cmp	DWORD PTR _auto_convert_flag, 0
	je	SHORT $LN39@hessian_le
	call	_convert_to_quantities
	jmp	SHORT $LN38@hessian_le
$LN39@hessian_le:

; 1649 :      kb_error(2078,
; 1650 :         "Hessian for optimizing parameters requires convert_to_quantities.\n",
; 1651 :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0ED@INBDPNCL@Hessian?5for?5optimizing?5parameter@
	push	2078					; 0000081eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN38@hessian_le:

; 1652 :      }
; 1653 : 
; 1654 :      if ( web.representation == SIMPLEX ) 

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN35@hessian_le

; 1655 :      {  if ( auto_convert_flag ) convert_to_quantities(); else

	cmp	DWORD PTR _auto_convert_flag, 0
	je	SHORT $LN36@hessian_le
	call	_convert_to_quantities
	jmp	SHORT $LN35@hessian_le
$LN36@hessian_le:

; 1656 :         kb_error(1597,"Hessian for simplex model requires convert_to_quantities.\n", RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DL@JBFFLGG@Hessian?5for?5simplex?5model?5requir@
	push	1597					; 0000063dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN35@hessian_le:

; 1657 :      }
; 1658 : 
; 1659 :     for ( i = 0 ; i < web.maxcon ; i++ )

	push	esi
	xor	esi, esi
	cmp	DWORD PTR _web+644, esi
	jle	SHORT $LN32@hessian_le
	npad	11
$LL34@hessian_le:

; 1660 :      if ( get_constraint(i)->attr & CON_CONTENT )

	mov	ecx, DWORD PTR _web+652
	mov	eax, esi
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	mov	eax, DWORD PTR [eax+ecx+32]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN33@hessian_le

; 1661 :      { if ( auto_convert_flag ) { convert_to_quantities(); break; }

	cmp	DWORD PTR _auto_convert_flag, ecx
	jne	SHORT $LN49@hessian_le

; 1662 :         else kb_error(1843,"Hessian for constraint content requires convert_to_quantities.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EA@BKEKHLAC@Hessian?5for?5constraint?5content?5r@
	push	1843					; 00000733H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN33@hessian_le:

; 1657 :      }
; 1658 : 
; 1659 :     for ( i = 0 ; i < web.maxcon ; i++ )

	inc	esi
	cmp	esi, DWORD PTR _web+644
	jl	SHORT $LL34@hessian_le

; 1668 :         { if ( auto_convert_flag ) { convert_to_quantities(); break; }

	jmp	SHORT $LN32@hessian_le
$LN49@hessian_le:

; 1661 :      { if ( auto_convert_flag ) { convert_to_quantities(); break; }

	call	_convert_to_quantities
$LN32@hessian_le:

; 1663 :      }
; 1664 :  
; 1665 :     if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN25@hessian_le

; 1666 :     { FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+384
	test	eax, 268435456				; 10000000H
	je	SHORT $LN25@hessian_le
	push	edi
	mov	edi, DWORD PTR _web+348
	npad	6
$LL27@hessian_le:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR [esi+edi]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, ecx
	mov	DWORD PTR tv316[ebp+4], edx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN26@hessian_le

; 1667 :       { if ( get_battr(b_id) & FIXEDVOL )

	and	ecx, 32					; 00000020H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN26@hessian_le

; 1668 :         { if ( auto_convert_flag ) { convert_to_quantities(); break; }

	cmp	DWORD PTR _auto_convert_flag, eax
	jne	SHORT $LN50@hessian_le

; 1669 :           else 
; 1670 :             kb_error(1844,"Cannot do torus body volumes with hessian. Do convert_to_quantities.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EG@JJBOAEAF@Cannot?5do?5torus?5body?5volumes?5wit@
	push	1844					; 00000734H
	call	_kb_error
	mov	edi, DWORD PTR _web+348
	add	esp, 12					; 0000000cH
$LN26@hessian_le:

; 1666 :     { FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL27@hessian_le

; 1668 :         { if ( auto_convert_flag ) { convert_to_quantities(); break; }

	jmp	SHORT $LN53@hessian_le
$LN50@hessian_le:
	call	_convert_to_quantities
$LN53@hessian_le:
	pop	edi
$LN25@hessian_le:

; 1671 :         }
; 1672 :       }
; 1673 :     }
; 1674 : 
; 1675 :      if ( web.modeltype != LINEAR )

	cmp	DWORD PTR _web+628, 1
	pop	esi
	je	SHORT $LN17@hessian_le

; 1676 :      { 
; 1677 :           if ( auto_convert_flag ) convert_to_quantities(); else

	cmp	DWORD PTR _auto_convert_flag, 0
	je	SHORT $LN18@hessian_le
	call	_convert_to_quantities
	jmp	SHORT $LN17@hessian_le
$LN18@hessian_le:

; 1678 :           kb_error(1598,"Hessian for non-LINEAR models requires convert_to_quantities.\n",
; 1679 :             RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DP@PCIILACM@Hessian?5for?5non?9LINEAR?5models?5re@
	push	1598					; 0000063eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN17@hessian_le:

; 1680 :      }
; 1681 :      if ( web.representation == STRING ) 

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN14@hessian_le

; 1682 :      {  if ( auto_convert_flag ) convert_to_quantities(); else

	cmp	DWORD PTR _auto_convert_flag, 0
	je	SHORT $LN15@hessian_le
	call	_convert_to_quantities
	jmp	SHORT $LN14@hessian_le
$LN15@hessian_le:

; 1683 :         kb_error(1599,
; 1684 :           "Hessian for string model requires convert_to_quantities.\n", 
; 1685 :              RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DK@HOCAEIGI@Hessian?5for?5string?5model?5require@
	push	1599					; 0000063fH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN14@hessian_le:

; 1686 :      }
; 1687 : 
; 1688 :      if ( web.gravflag && (web.grav_const != 0.0))

	cmp	DWORD PTR _web+824, 0
	je	SHORT $LN11@hessian_le
	fld	QWORD PTR _web+832
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@hessian_le

; 1689 :      {  if ( auto_convert_flag ) convert_to_quantities(); else

	cmp	DWORD PTR _auto_convert_flag, 0
	je	SHORT $LN12@hessian_le
	call	_convert_to_quantities
	jmp	SHORT $LN11@hessian_le
$LN12@hessian_le:

; 1690 :         kb_error(1601,
; 1691 :          "Hessian method for gravity requires convert_to_quantities.\n",
; 1692 :           RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DM@BOHAIAKN@Hessian?5method?5for?5gravity?5requi@
	push	1601					; 00000641H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN11@hessian_le:

; 1693 :      }
; 1694 :      if ( web.pressflag ||  web.pressure_flag )

	cmp	DWORD PTR _web+844, 0
	jne	SHORT $LN9@hessian_le
	cmp	DWORD PTR _web+868, 0
	je	SHORT $LN7@hessian_le
$LN9@hessian_le:

; 1695 :      {  if ( auto_convert_flag ) convert_to_quantities(); else

	cmp	DWORD PTR _auto_convert_flag, 0
	je	SHORT $LN8@hessian_le
	call	_convert_to_quantities
	jmp	SHORT $LN7@hessian_le
$LN8@hessian_le:

; 1696 :         kb_error(1602,"Hessian with pressure in energy requires convert_to_quantities.\n", RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EB@BCEDDIBP@Hessian?5with?5pressure?5in?5energy?5@
	push	1602					; 00000642H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN7@hessian_le:

; 1697 :      }
; 1698 : 
; 1699 :      if ( web.wulff_flag )

	cmp	DWORD PTR _web+908, 0
	je	SHORT $LN6@hessian_le

; 1700 :      kb_error(1603,"Cannot do Hessian method with crystalline integrand.\n", RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DG@HIJHNLGA@Cannot?5do?5Hessian?5method?5with?5cr@
	push	1603					; 00000643H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN6@hessian_le:

; 1701 : 
; 1702 :      if ( web.convex_flag )

	cmp	DWORD PTR _web+840, 0
	je	SHORT $LN5@hessian_le

; 1703 :         kb_error(1604,"Cannot do gap energy Hessian, since it would need third derivatives.\n", RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EG@OLHOBHIP@Cannot?5do?5gap?5energy?5Hessian?0?5si@
	push	1604					; 00000644H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN5@hessian_le:

; 1704 : 
; 1705 :      if ( web.metric_flag )

	cmp	DWORD PTR _web+1676, 0
	je	SHORT $LN2@hessian_le

; 1706 :      {  if ( auto_convert_flag ) convert_to_quantities(); else

	cmp	DWORD PTR _auto_convert_flag, 0
	je	SHORT $LN3@hessian_le
	call	_convert_to_quantities
	jmp	SHORT $LN2@hessian_le
$LN3@hessian_le:

; 1707 :         kb_error(1605,"Hessian with Riemannian metric requires convert_to_quantities.\n", RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EA@GLCAFAG@Hessian?5with?5Riemannian?5metric?5r@
	push	1605					; 00000645H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN2@hessian_le:

; 1708 :      }
; 1709 :    }
; 1710 : 
; 1711 :   if ( count_fixed_vol() && !pressure_set_flag && !web.pressure_flag )

	call	_count_fixed_vol
	test	eax, eax
	je	SHORT $LN1@hessian_le
	cmp	DWORD PTR _pressure_set_flag, 0
	jne	SHORT $LN1@hessian_le
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN1@hessian_le

; 1712 :       kb_error(1606,"Pressures invalid. Do regular iteration before Hessian to set pressures.\n",
; 1713 :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EK@IINLFNAA@Pressures?5invalid?4?5Do?5regular?5it@
	push	1606					; 00000646H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@hessian_le:

; 1714 : 
; 1715 : } // end hessian_legal()

	mov	esp, ebp
	pop	ebp
	ret	0
_hessian_legal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EF@PLGFHGJB@Internal?5error?0?5hessian_init?$CI?$CJ?3?5@ ; `string'
PUBLIC	??_C@_03JAIJOMNP@?$CFf?5?$AA@			; `string'
PUBLIC	??_C@_0O@HJGGLLDI@v_id?5?$CFs?5proj?6?$AA@	; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	__real@3eb0c6f7a0b5ed8d
PUBLIC	??_C@_09BDABODOF@HESSIAN?4C?$AA@		; `string'
PUBLIC	??_C@_0O@LGPCPOOO@__bhead_index?$AA@		; `string'
PUBLIC	??_C@_0O@LJOMCIGN@__vhead_index?$AA@		; `string'
PUBLIC	_rhs$GSCopy$
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_hessian_init
EXTRN	_sp_hash_init:PROC
EXTRN	_pressures:DWORD
EXTRN	_augmented_hessian_mode:DWORD
EXTRN	_sparse_constraints_flag:DWORD
EXTRN	_augmented_hessian_flag:DWORD
EXTRN	_kb_dmatrix:PROC
EXTRN	_gen_quant_list:DWORD
EXTRN	_meth_inst_list:DWORD
EXTRN	_quantity_function_sparse_flag:DWORD
EXTRN	_free_matrix3:PROC
EXTRN	_printf:PROC
EXTRN	_mat_tsquare:PROC
EXTRN	_hessian_slant_cutoff:QWORD
EXTRN	_hessian_epsilon:QWORD
EXTRN	_kernel_basis:PROC
EXTRN	_mat_inv:PROC
EXTRN	_mat_mul_tr:PROC
EXTRN	_sprintf:PROC
EXTRN	_elnames:BYTE
EXTRN	_hessian_double_normal_flag:DWORD
EXTRN	_eval_second:PROC
EXTRN	_kb_calloc:PROC
EXTRN	_nullcon:QWORD
EXTRN	_project_vertex_normals:PROC
EXTRN	_new_calc_vertex_normal:PROC
EXTRN	_V_BOUNDARY_ATTR:DWORD
EXTRN	_kb_dmatrix3:PROC
EXTRN	_kb_temp_calloc:PROC
EXTRN	_bhead_attr:DWORD
EXTRN	_everything_quantities_flag:DWORD
EXTRN	_add_attribute:PROC
EXTRN	_find_attribute:PROC
EXTRN	_local_save_coords:PROC
EXTRN	_saved:BYTE
EXTRN	_mat3d_setup:PROC
EXTRN	__CIsqrt:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0EF@PLGFHGJB@Internal?5error?0?5hessian_init?$CI?$CJ?3?5@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EF@PLGFHGJB@Internal?5error?0?5hessian_init?$CI?$CJ?3?5@ DB 'Inter'
	DB	'nal error, hessian_init(): Overflow of vproj or conhess arena'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03JAIJOMNP@?$CFf?5?$AA@
CONST	SEGMENT
??_C@_03JAIJOMNP@?$CFf?5?$AA@ DB '%f ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HJGGLLDI@v_id?5?$CFs?5proj?6?$AA@
CONST	SEGMENT
??_C@_0O@HJGGLLDI@v_id?5?$CFs?5proj?6?$AA@ DB 'v_id %s proj', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT __real@3eb0c6f7a0b5ed8d
CONST	SEGMENT
__real@3eb0c6f7a0b5ed8d DQ 03eb0c6f7a0b5ed8dr	; 1e-006
CONST	ENDS
;	COMDAT ??_C@_09BDABODOF@HESSIAN?4C?$AA@
CONST	SEGMENT
??_C@_09BDABODOF@HESSIAN?4C?$AA@ DB 'HESSIAN.C', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LGPCPOOO@__bhead_index?$AA@
CONST	SEGMENT
??_C@_0O@LGPCPOOO@__bhead_index?$AA@ DB '__bhead_index', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LJOMCIGN@__vhead_index?$AA@
CONST	SEGMENT
??_C@_0O@LJOMCIGN@__vhead_index?$AA@ DB '__vhead_index', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\hessian.c
CONST	ENDS
;	COMDAT _hessian_init
_TEXT	SEGMENT
_secondqXvS$ = -3892					; size = 168
_gradqXvS$ = -3724					; size = 24
_ggqXvS$ = -3700					; size = 24
_ccqXvS$ = -3676					; size = 24
_gradcopyqXvS$ = -3652					; size = 24
_qqqXvS$ = -3628					; size = 24
_ppqXvS$ = -3604					; size = 24
_dummy$ = -3580						; size = 8
_rhs$GSCopy$ = -3572					; size = 4
tv1033 = -3568						; size = 4
_v$ = -3564						; size = 4
_qq$ = -3560						; size = 4
_gradcopy$ = -3556					; size = 4
_gg$ = -3552						; size = 4
_cc$ = -3548						; size = 4
_pp$ = -3544						; size = 4
_second$ = -3540					; size = 4
tv2845 = -3536						; size = 8
tv2589 = -3536						; size = 8
_a$90499 = -3536					; size = 8
_attr$90195 = -3536					; size = 8
tv4545 = -3532						; size = 4
tv4278 = -3532						; size = 4
$T91569 = -3532						; size = 4
_oncount$90257 = -3528					; size = 4
_grad$ = -3524						; size = 4
_v_normal$ = -3520					; size = 4
_conhess_alloc$ = -3516					; size = 4
_total_conhess$ = -3512					; size = 4
_vproj_spot$ = -3508					; size = 4
_vproj_alloc$ = -3504					; size = 4
_vproj_count$ = -3500					; size = 4
_total_proj$ = -3496					; size = 4
tv4252 = -3492						; size = 4
tv1588 = -3492						; size = 4
_conmap$90256 = -3492					; size = 4
_S$GSCopy$ = -3488					; size = 4
tv3805 = -3484						; size = 4
tv3660 = -3484						; size = 4
tv1654 = -3484						; size = 4
_k$90407 = -3484					; size = 4
_b$ = -3484						; size = 4
_i$ = -3480						; size = 4
_j$ = -3480						; size = 4
tv4956 = -3476						; size = 4
_gam$ = -3476						; size = 4
_v_id$ = -3476						; size = 4
tv2285 = -3472						; size = 4
_currow$ = -3472					; size = 4
tv5113 = -3468						; size = 4
tv2283 = -3468						; size = 4
_b_id$90489 = -3468					; size = 4
_found$90459 = -3468					; size = 4
_norm$90220 = -3468					; size = 4
_one$90178 = -3468					; size = 4
_one$90173 = -3468					; size = 4
tv3790 = -3464						; size = 4
tv3633 = -3464						; size = 4
tv2913 = -3464						; size = 4
tv2204 = -3464						; size = 4
_a$ = -3464						; size = 4
_bdry$90268 = -3464					; size = 4
_vcount$ = -3464					; size = 4
_secondxJ$ = -3460					; size = 1728
_ccxJ$ = -1732						; size = 288
_ppxJ$ = -1444						; size = 288
_gradcopyxJ$ = -1156					; size = 288
_qqxJ$ = -868						; size = 288
_gradxJ$ = -580						; size = 288
_ggxJ$ = -292						; size = 288
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_rhs$ = 12						; size = 4
_hessian_init PROC					; COMDAT

; 1728 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3892				; 00000f34H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1729 :   vertex_id v_id;
; 1730 :   int j,i,gam,a,b,m,n;
; 1731 :   struct hess_verlist *v;              /* current  vertex */
; 1732 :   int currow = 0;
; 1733 :   MAT2D(grad,MAXCOORD,MAXCOORD);
; 1734 :   MAT2D(gradcopy,MAXCOORD,MAXCOORD);
; 1735 :   MAT2D(cc,MAXCOORD,MAXCOORD);

	mov	eax, DWORD PTR _rhs$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _S$[ebp]
	push	esi
	push	edi
	push	6
	push	6
	lea	ecx, DWORD PTR _gradxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _gradqXvS$[ebp]
	push	edx

; 1974 :           { REAL sum;
; 1975 :             for ( sum = 0.0, i = 0 ; i < oncount ; i++ )

	mov	DWORD PTR _S$GSCopy$[ebp], ebx
	mov	DWORD PTR _rhs$GSCopy$[ebp], eax
	call	_mat2d_setup
	push	6
	mov	DWORD PTR _grad$[ebp], eax
	push	6
	lea	eax, DWORD PTR _gradcopyxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _gradcopyqXvS$[ebp]
	push	ecx
	call	_mat2d_setup
	push	6
	push	6
	lea	edx, DWORD PTR _ccxJ$[ebp]
	mov	DWORD PTR _gradcopy$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _ccqXvS$[ebp]
	push	eax
	call	_mat2d_setup
	push	6
	push	6
	lea	ecx, DWORD PTR _ppxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ppqXvS$[ebp]
	push	edx
	mov	DWORD PTR _cc$[ebp], eax
	call	_mat2d_setup
	add	esp, 64					; 00000040H
	push	6
	mov	DWORD PTR _pp$[ebp], eax
	push	6
	lea	eax, DWORD PTR _qqxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _qqqXvS$[ebp]
	push	ecx
	call	_mat2d_setup
	push	6
	push	6
	lea	edx, DWORD PTR _ggxJ$[ebp]
	mov	DWORD PTR _qq$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _ggqXvS$[ebp]
	push	eax
	call	_mat2d_setup
	push	6
	push	6
	push	6
	lea	ecx, DWORD PTR _secondxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _secondqXvS$[ebp]
	push	edx
	mov	DWORD PTR _gg$[ebp], eax
	call	_mat3d_setup
	xor	esi, esi
	push	232					; 000000e8H
	push	esi
	push	ebx
	mov	DWORD PTR _second$[ebp], eax
	mov	DWORD PTR _v_normal$[ebp], esi
	call	_memset
	add	esp, 64					; 00000040H
	call	_hessian_legal
	lea	edi, DWORD PTR [esi+1]
	cmp	DWORD PTR _saved, esi
	jne	SHORT $LN213@hessian_in

; 1736 :   MAT2D(pp,MAXCOORD,MAXCOORD);
; 1737 :   MAT2D(qq,MAXCOORD,MAXCOORD);
; 1738 :   MAT2D(gg,MAXCOORD,MAXCOORD);
; 1739 :   MAT3D(second,MAXCOORD,MAXCOORD,MAXCOORD);
; 1740 :   REAL dummy;
; 1741 :   int total_proj,vproj_count,total_conhess,vproj_alloc,conhess_alloc;
; 1742 :   int vproj_spot,vcount;
; 1743 :   REAL ***v_normal = NULL;
; 1744 : 
; 1745 :   memset(S,0,sizeof(struct linsys));
; 1746 : 
; 1747 :   hessian_legal();
; 1748 : 
; 1749 :   /* in case this doesn't work */
; 1750 :   if ( saved.coord == NULL ) 
; 1751 : 	  local_save_coords(&saved,SAVE_IN_ATTR);  

	push	edi
	push	OFFSET _saved
	call	_local_save_coords
	add	esp, 8
$LN213@hessian_in:

; 1752 : 
; 1753 :   /* vertex attribute to hold vhead index */
; 1754 :   vhead_attr = find_attribute(VERTEX,VHEAD_ATTR_NAME);

	push	OFFSET ??_C@_0O@LJOMCIGN@__vhead_index?$AA@
	push	esi
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _vhead_attr, eax

; 1755 :   if ( vhead_attr < 0 )

	cmp	eax, esi
	jge	SHORT $LN212@hessian_in

; 1756 :   { int one = 1;
; 1757 :     vhead_attr = add_attribute(VERTEX,VHEAD_ATTR_NAME,INTEGER_TYPE,
; 1758 :                     0,&one,0,NULL,MPI_PROPAGATE);

	push	edi
	push	esi
	push	esi
	lea	eax, DWORD PTR _one$90173[ebp]
	push	eax
	push	esi
	push	2
	push	OFFSET ??_C@_0O@LJOMCIGN@__vhead_index?$AA@
	push	esi
	mov	DWORD PTR _one$90173[ebp], edi
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _vhead_attr, eax
$LN212@hessian_in:

; 1759 :   }
; 1760 : 
; 1761 :   vhead_count = web.skel[VERTEX].max_ord+1;
; 1762 :   vhead_count += optparamcount;
; 1763 :   vhead_count += gen_quant_count;

	mov	edx, DWORD PTR _web+5528
	add	edx, DWORD PTR _optparamcount
	mov	eax, DWORD PTR _web+68
	lea	eax, DWORD PTR [edx+eax+1]
	mov	DWORD PTR _vhead_count, eax

; 1764 :   if ( !everything_quantities_flag ) 

	cmp	DWORD PTR _everything_quantities_flag, esi
	jne	SHORT $LN339@hessian_in

; 1765 :   { vhead_count += web.skel[BODY].max_ord+1;

	mov	ecx, DWORD PTR _web+404
	lea	edx, DWORD PTR [eax+ecx+1]

; 1766 :     bhead_attr = find_attribute(BODY,BHEAD_ATTR_NAME);

	push	OFFSET ??_C@_0O@LGPCPOOO@__bhead_index?$AA@
	push	3
	mov	DWORD PTR _vhead_count, edx
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _bhead_attr, eax

; 1767 :     if ( bhead_attr < 0 )

	cmp	eax, esi
	jge	SHORT $LN339@hessian_in

; 1768 :     { int one = 1;
; 1769 :       bhead_attr = add_attribute(BODY,BHEAD_ATTR_NAME,INTEGER_TYPE,
; 1770 :                       0,&one,0,NULL,MPI_PROPAGATE);

	push	edi
	push	esi
	push	esi
	lea	eax, DWORD PTR _one$90178[ebp]
	push	eax
	push	esi
	push	2
	push	OFFSET ??_C@_0O@LGPCPOOO@__bhead_index?$AA@
	push	3
	mov	DWORD PTR _one$90178[ebp], edi
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _bhead_attr, eax
$LN339@hessian_in:

; 1771 :     }
; 1772 :   }
; 1773 : 
; 1774 : 
; 1775 :   vhead = (struct hess_verlist*)temp_calloc(vhead_count,
; 1776 :         sizeof(struct hess_verlist));

	mov	ecx, DWORD PTR _vhead_count
	push	1776					; 000006f0H
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	32					; 00000020H
	push	ecx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vhead, eax

; 1777 :   if ( hmode == NORMAL_MOTION ) v_normal = dmatrix3(vhead_count,SDIM,SDIM);

	cmp	DWORD PTR _hmode, edi
	jne	SHORT $LN209@hessian_in
	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR _vhead_count
	push	1777					; 000006f1H
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	eax
	push	eax
	push	edx
	call	_kb_dmatrix3
	add	esp, 20					; 00000014H
	mov	DWORD PTR _v_normal$[ebp], eax
$LN209@hessian_in:

; 1778 :       /* v_normal will use vhead_attr as index */
; 1779 : 
; 1780 :   /* populate vertex list and count degrees of freedom */
; 1781 :   total_proj = 0;    /* count columns needed */
; 1782 :   vproj_count = 0;  /* number of vertices needing projection */
; 1783 :   total_conhess = 0;    /* count rows needed */
; 1784 :   vcount = 0;
; 1785 :   MFOR_ALL_VERTICES(v_id)

	mov	edi, DWORD PTR _web+48
	mov	DWORD PTR _total_proj$[ebp], esi
	mov	DWORD PTR _vproj_count$[ebp], esi
	mov	DWORD PTR _total_conhess$[ebp], esi
	mov	DWORD PTR _vcount$[ebp], esi
	test	edi, 268435456				; 10000000H
	je	$LN342@hessian_in
	npad	13
$LL208@hessian_in:
	mov	edx, DWORD PTR _web+12
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN207@hessian_in

; 1786 :   { conmap_t * conmap;
; 1787 :     int oncount;
; 1788 :     int kk;
; 1789 :     ATTR attr = get_vattr(v_id);

	mov	eax, DWORD PTR [esi+edx]
	mov	edx, DWORD PTR [eax+12]

; 1790 : 
; 1791 :     set_vertex_vhead(v_id,vcount); /* new way */

	mov	ebx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _attr$90195[ebp+4], edx
	mov	edx, DWORD PTR _vhead_attr
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	ebx, DWORD PTR [edx+ebx+64]
	mov	edx, DWORD PTR _vcount$[ebp]
	mov	DWORD PTR [eax+ebx], edx

; 1792 :     vcount++;

	inc	edx

; 1793 :     if ( attr & FIXED ) continue;

	mov	eax, ecx
	mov	DWORD PTR _vcount$[ebp], edx
	and	eax, 64					; 00000040H
	xor	edx, edx
	or	eax, edx
	jne	$LN207@hessian_in

; 1794 :     v = get_vertex_vhead(v_id);   /* old way */

	mov	eax, DWORD PTR _vhead_attr
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]
	mov	edx, DWORD PTR _web+12
	mov	edx, DWORD PTR [esi+edx]
	mov	ebx, DWORD PTR [eax+edx]
	shl	ebx, 5
	add	ebx, DWORD PTR _vhead

; 1795 :     v->v_id = v_id;

	mov	DWORD PTR [ebx], edi

; 1796 : 
; 1797 :     if ( hmode == SINGLE_DEGREE )

	cmp	DWORD PTR _hmode, 2
	jne	SHORT $LN202@hessian_in

; 1798 :         v->freedom = 1;

	mov	DWORD PTR [ebx+8], 1
	jmp	$LN207@hessian_in
$LN202@hessian_in:

; 1799 :     else if ( attr & BOUNDARY )

	mov	eax, ecx
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN200@hessian_in

; 1800 :     { struct boundary *bdry = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN216@hessian_in
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104

; 1801 :       v->freedom = bdry->pcount;
; 1802 :       total_proj += v->freedom;
; 1803 :       vproj_count++;

	inc	DWORD PTR _vproj_count$[ebp]
	mov	edx, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [edx+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	mov	eax, DWORD PTR [eax+40]
	add	DWORD PTR _total_proj$[ebp], eax

; 1804 :       total_conhess += v->freedom;

	add	DWORD PTR _total_conhess$[ebp], eax
	mov	DWORD PTR [ebx+8], eax

; 1805 :     }
; 1806 :     else /* possible level set constraints */

	jmp	$LN207@hessian_in
$LN216@hessian_in:

; 1801 :       v->freedom = bdry->pcount;
; 1802 :       total_proj += v->freedom;
; 1803 :       vproj_count++;

	inc	DWORD PTR _vproj_count$[ebp]
	xor	eax, eax
	mov	eax, DWORD PTR [eax+40]
	add	DWORD PTR _total_proj$[ebp], eax

; 1804 :       total_conhess += v->freedom;

	add	DWORD PTR _total_conhess$[ebp], eax
	mov	DWORD PTR [ebx+8], eax

; 1805 :     }
; 1806 :     else /* possible level set constraints */

	jmp	$LN207@hessian_in
$LN200@hessian_in:

; 1807 :     { 
; 1808 :       if ( (hmode == NORMAL_MOTION) && !( attr & NO_HESSIAN_NORMAL_ATTR) ) 

	cmp	DWORD PTR _hmode, 1
	jne	SHORT $LN372@hessian_in
	and	ecx, -2147483648			; 80000000H
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN372@hessian_in

; 1809 :       { REAL **norm;
; 1810 :         norm = get_vertex_v_normal(v_id);

	mov	edx, DWORD PTR _vhead_attr
	mov	eax, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [edx+eax+64]
	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [esi+edx]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR _v_normal$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]

; 1811 :         kk = new_calc_vertex_normal(v_id,norm);

	push	eax
	push	edi
	mov	DWORD PTR _norm$90220[ebp], eax
	call	_new_calc_vertex_normal

; 1812 :         kk = project_vertex_normals(v_id,norm,kk);

	push	eax
	mov	eax, DWORD PTR _norm$90220[ebp]
	push	eax
	push	edi
	call	_project_vertex_normals

; 1813 :         if ( kk < SDIM )

	mov	ecx, DWORD PTR _web+616
	add	esp, 20					; 00000014H
	cmp	eax, ecx
	jge	SHORT $LN197@hessian_in

; 1814 :         { v->freedom = kk;
; 1815 :           total_proj += kk;

	add	DWORD PTR _total_proj$[ebp], eax

; 1816 :           vproj_count++;

	inc	DWORD PTR _vproj_count$[ebp]
	mov	DWORD PTR [ebx+8], eax
	jmp	SHORT $LN195@hessian_in
$LN372@hessian_in:

; 1817 :         }
; 1818 :         else v->freedom = SDIM;
; 1819 :       }
; 1820 :       else /* v-proj still identity */
; 1821 :         v->freedom = SDIM;

	mov	ecx, DWORD PTR _web+616
$LN197@hessian_in:
	mov	DWORD PTR [ebx+8], ecx
$LN195@hessian_in:

; 1822 : 
; 1823 :       conmap = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	cmp	DWORD PTR [eax+edx+1288], 0
	je	SHORT $LN218@hessian_in
	mov	ecx, DWORD PTR _web+12
	mov	ecx, DWORD PTR [esi+ecx]
	add	ecx, DWORD PTR [eax+edx+1264]
	jmp	SHORT $LN219@hessian_in
$LN218@hessian_in:
	mov	ecx, OFFSET _nullcon
$LN219@hessian_in:

; 1824 :       if ( conmap[0] )

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN207@hessian_in

; 1825 :       { /* calculate size of projection matrix to fewer degrees of freedom */
; 1826 :         for ( j = 1, oncount = 0; j <= (int)conmap[0] ; j++ )

	mov	eax, 1
	xor	edi, edi
	cmp	edx, eax
	jl	SHORT $LN191@hessian_in
	npad	7
$LL193@hessian_in:

; 1827 :         { if ( !(conmap[j] & CON_HIT_BIT) ) continue;

	test	DWORD PTR [ecx+eax*4], -2147483648	; 80000000H
	je	SHORT $LN192@hessian_in

; 1828 :           oncount++;

	inc	edi
$LN192@hessian_in:

; 1825 :       { /* calculate size of projection matrix to fewer degrees of freedom */
; 1826 :         for ( j = 1, oncount = 0; j <= (int)conmap[0] ; j++ )

	inc	eax
	cmp	eax, edx
	jle	SHORT $LL193@hessian_in
$LN191@hessian_in:

; 1829 :         }
; 1830 : 
; 1831 :         if ( v->freedom + oncount > SDIM ) 

	mov	ebx, DWORD PTR [ebx+8]
	lea	edx, DWORD PTR [ebx+edi]
	cmp	edx, DWORD PTR _web+616
	jle	SHORT $LN189@hessian_in

; 1832 :         { 
; 1833 :           total_proj += v->freedom;

	add	DWORD PTR _total_proj$[ebp], ebx

; 1834 :           vproj_count++;

	inc	DWORD PTR _vproj_count$[ebp]
$LN189@hessian_in:

; 1835 :         }
; 1836 :         /* now constraint hessian */
; 1837 :         if ( oncount ) total_conhess += v->freedom;

	test	edi, edi
	je	SHORT $LN207@hessian_in
	add	DWORD PTR _total_conhess$[ebp], ebx
$LN207@hessian_in:

; 1778 :       /* v_normal will use vhead_attr as index */
; 1779 : 
; 1780 :   /* populate vertex list and count degrees of freedom */
; 1781 :   total_proj = 0;    /* count columns needed */
; 1782 :   vproj_count = 0;  /* number of vertices needing projection */
; 1783 :   total_conhess = 0;    /* count rows needed */
; 1784 :   vcount = 0;
; 1785 :   MFOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [ecx]
	test	edi, 268435456				; 10000000H
	jne	$LL208@hessian_in
	mov	ebx, DWORD PTR _S$GSCopy$[ebp]
	xor	esi, esi
$LN342@hessian_in:

; 1838 :       }
; 1839 :     }
; 1840 :   } /* end FOR_ALL_VERTICES first time through */
; 1841 : 
; 1842 : 
; 1843 :   vproj_base = (REAL**)mycalloc(vproj_count*SDIM,sizeof(REAL*));

	mov	eax, DWORD PTR _web+616
	imul	eax, DWORD PTR _vproj_count$[ebp]
	push	1843					; 00000733H
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	4
	push	eax
	call	_kb_calloc

; 1844 :   vproj_space = (REAL*)mycalloc(total_proj*SDIM,sizeof(REAL));;

	mov	edx, DWORD PTR _web+616
	imul	edx, DWORD PTR _total_proj$[ebp]
	push	1844					; 00000734H
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	8
	push	edx
	mov	DWORD PTR _vproj_base, eax
	call	_kb_calloc

; 1845 :   conhess_base = dmatrix3(total_conhess,SDIM-1,SDIM);

	push	1845					; 00000735H
	mov	DWORD PTR _vproj_space, eax
	mov	eax, DWORD PTR _web+616
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	eax
	dec	eax
	push	eax
	mov	eax, DWORD PTR _total_conhess$[ebp]
	push	eax
	call	_kb_dmatrix3
	mov	DWORD PTR _conhess_base, eax

; 1846 :   vproj_spot = vproj_alloc = conhess_alloc = 0;
; 1847 : 
; 1848 :   /* populate vertex list vproj and conhess */
; 1849 :   MFOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	DWORD PTR _v_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	add	esp, 52					; 00000034H
	and	eax, 1
	mov	DWORD PTR _conhess_alloc$[ebp], esi
	mov	DWORD PTR _vproj_alloc$[ebp], esi
	mov	DWORD PTR _vproj_spot$[ebp], esi
	mov	DWORD PTR tv2283[ebp], eax
	je	$LN352@hessian_in
	fldz
$LN187@hessian_in:
	mov	eax, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv2285[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN186@hessian_in

; 1850 :   { conmap_t * conmap;
; 1851 :     int oncount;
; 1852 : 
; 1853 :     v = get_vertex_vhead(v_id);

	mov	edx, DWORD PTR _vhead_attr

; 1854 : /*    v->rownum  = currow; */
; 1855 :     v->slant = 1.0;

	fld1
	mov	eax, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+eax+64]
	mov	edi, DWORD PTR [ecx+edx]
	shl	edi, 5
	add	edi, DWORD PTR _vhead

; 1856 :     if ( v->freedom == 0 ) continue;

	mov	esi, DWORD PTR [edi+8]
	fstp	QWORD PTR [edi+24]
	mov	DWORD PTR _v$[ebp], edi
	test	esi, esi
	je	$LN186@hessian_in

; 1857 :     if ( hmode == SINGLE_DEGREE )

	cmp	DWORD PTR _hmode, 2
	je	$LN349@hessian_in

; 1858 :      {} 
; 1859 :     else if ( get_vattr(v_id) & BOUNDARY )

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR tv2285[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	$LN179@hessian_in

; 1860 :     { struct boundary *bdry = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN220@hessian_in
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]
	mov	ebx, DWORD PTR [eax+ecx]
	imul	ebx, 136				; 00000088H
	add	ebx, DWORD PTR _web+776
	jmp	SHORT $LN538@hessian_in
$LN220@hessian_in:
	xor	ebx, ebx
$LN538@hessian_in:

; 1861 :       v->proj = vproj_base + vproj_alloc; vproj_alloc += SDIM;

	mov	ecx, DWORD PTR _vproj_base
	mov	eax, DWORD PTR _vproj_alloc$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edi+16], edx
	mov	ecx, DWORD PTR _web+616
	add	eax, ecx
	mov	DWORD PTR _vproj_alloc$[ebp], eax

; 1862 :       for ( j = 0 ; j < SDIM ; j++ ) 

	xor	eax, eax
	mov	DWORD PTR _bdry$90268[ebp], ebx
	test	ecx, ecx
	jle	SHORT $LN176@hessian_in
	mov	ecx, DWORD PTR _vproj_spot$[ebp]
$LN178@hessian_in:

; 1863 :       { v->proj[j] = vproj_space + vproj_spot;

	mov	edx, DWORD PTR _vproj_space
	mov	esi, DWORD PTR [edi+16]
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR [esi+eax*4], edx

; 1864 :         vproj_spot+= v->freedom;

	add	ecx, DWORD PTR [edi+8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN178@hessian_in
	mov	DWORD PTR _vproj_spot$[ebp], ecx
$LN176@hessian_in:

; 1865 :       }
; 1866 :       v->conhess = conhess_base + conhess_alloc;

	mov	eax, DWORD PTR _conhess_alloc$[ebp]
	mov	ecx, DWORD PTR _conhess_base
	lea	edx, DWORD PTR [ecx+eax*4]

; 1867 :       conhess_alloc += v->freedom;

	add	eax, DWORD PTR [edi+8]

; 1868 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	mov	DWORD PTR [edi+20], edx
	mov	DWORD PTR _conhess_alloc$[ebp], eax
	cmp	DWORD PTR _web+616, esi
	jle	$LN349@hessian_in
	mov	ecx, DWORD PTR [ebx+40]
	fstp	ST(0)
	npad	10
$LL175@hessian_in:

; 1869 :       { eval_second(bdry->coordf[j],get_param(v_id),bdry->pcount,&dummy,
; 1870 :             v->proj[j],second[j],v_id);

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	edx, DWORD PTR _second$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [edi+16]
	push	eax
	mov	eax, DWORD PTR [edx+esi*4]
	push	eax
	mov	eax, DWORD PTR _web+12
	lea	edx, DWORD PTR _dummy$[ebp]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR tv2285[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+544]
	push	edx
	mov	edx, DWORD PTR [ebx+esi*4+48]
	push	edx
	call	_eval_second

; 1871 :         for ( m = 0 ; m < bdry->pcount ; m++ )

	mov	ecx, DWORD PTR [ebx+40]
	add	esp, 28					; 0000001cH
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN174@hessian_in
$LL172@hessian_in:

; 1872 :           for ( n = 0 ; n < bdry->pcount ; n++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN171@hessian_in
	mov	ecx, DWORD PTR _second$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR [ecx+edx*4]
	npad	7
$LL169@hessian_in:

; 1873 :              v->conhess[m][n][j] = second[j][m][n];

	mov	ebx, DWORD PTR [edi+20]
	fld	QWORD PTR [ecx]
	mov	ebx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR [ebx+eax*4]
	fstp	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR _bdry$90268[ebp]
	inc	eax
	add	ecx, 8
	cmp	eax, DWORD PTR [ebx+40]
	jl	SHORT $LL169@hessian_in
$LN171@hessian_in:

; 1871 :         for ( m = 0 ; m < bdry->pcount ; m++ )

	mov	ecx, DWORD PTR [ebx+40]
	inc	edx
	cmp	edx, ecx
	jl	SHORT $LL172@hessian_in
$LN174@hessian_in:

; 1868 :       for ( j = 0 ; j < SDIM ; j++ )

	inc	esi
	cmp	esi, DWORD PTR _web+616
	jl	$LL175@hessian_in
$LN348@hessian_in:

; 1971 :         for ( gam = 0 ; gam < SDIM ; gam++ )

	fldz
$LN349@hessian_in:

; 1982 :           }
; 1983 :        }
; 1984 :     } /* end level set constraints */
; 1985 :  
; 1986 :     if ( hessian_double_normal_flag && v->proj )

	cmp	DWORD PTR _hessian_double_normal_flag, 0
	je	$LN78@hessian_in
	cmp	DWORD PTR [edi+16], 0
	je	$LN78@hessian_in

; 1987 :     { REAL sum;
; 1988 :       int k;
; 1989 :       /* special kludge to give double-dimension perturbations the
; 1990 :          same normal space as regular dimensions. See spin4d.fe
; 1991 :          for example of use. */
; 1992 :       for ( i =  0 ; i < v->freedom ; i++ )

	xor	esi, esi
	cmp	DWORD PTR [edi+8], esi
	jle	$LN288@hessian_in
	mov	eax, DWORD PTR _web+616
	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1

; 1995 :            sum += v->proj[j][i]*v->proj[j][i];

	mov	DWORD PTR $T91569[ebp], ebx
$LN77@hessian_in:

; 1993 :       { /* assume low dim normals are first */
; 1994 :         for ( j = 0, sum = 0.0 ; j < SDIM/2 ; j++ )

	xor	edx, edx
	fld	ST(0)
	cmp	ebx, 4
	jl	SHORT $LC337@hessian_in
	mov	eax, DWORD PTR [edi+16]
	lea	ecx, DWORD PTR [ebx-4]
	shr	ecx, 2
	inc	ecx
	mov	DWORD PTR tv1654[ebp], ecx
	add	ecx, ecx
	add	eax, 8
	add	ecx, ecx
	mov	DWORD PTR _j$[ebp], ecx
$LN338@hessian_in:

; 1995 :            sum += v->proj[j][i]*v->proj[j][i];

	mov	edx, DWORD PTR [eax-8]
	fld	QWORD PTR [edx+esi*8]
	mov	ecx, DWORD PTR [eax-4]
	mov	edx, DWORD PTR [eax]
	fmul	ST(0), ST(0)
	mov	ebx, DWORD PTR [eax+4]
	lea	ecx, DWORD PTR [ecx+esi*8]
	faddp	ST(1), ST(0)
	lea	edx, DWORD PTR [edx+esi*8]
	fld	QWORD PTR [ecx]
	lea	ebx, DWORD PTR [ebx+esi*8]
	fmul	QWORD PTR [ecx]
	add	eax, 16					; 00000010H
	dec	DWORD PTR tv1654[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx]
	fmul	QWORD PTR [edx]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx]
	fmul	QWORD PTR [ebx]
	faddp	ST(1), ST(0)
	jne	SHORT $LN338@hessian_in

; 1993 :       { /* assume low dim normals are first */
; 1994 :         for ( j = 0, sum = 0.0 ; j < SDIM/2 ; j++ )

	mov	edx, DWORD PTR _j$[ebp]
	mov	ebx, DWORD PTR $T91569[ebp]
$LC337@hessian_in:
	cmp	edx, ebx
	jge	SHORT $LN370@hessian_in
	mov	eax, DWORD PTR [edi+16]
	mov	ecx, ebx
	lea	eax, DWORD PTR [eax+edx*4]
	sub	ecx, edx
$LC74@hessian_in:

; 1995 :            sum += v->proj[j][i]*v->proj[j][i];

	mov	edx, DWORD PTR [eax]
	fld	QWORD PTR [edx+esi*8]
	add	eax, 4
	dec	ecx
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LC74@hessian_in
$LN370@hessian_in:

; 1996 :         if ( sum < 1e-6 ) break;

	fcomp	QWORD PTR __real@3eb0c6f7a0b5ed8d
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN288@hessian_in

; 1987 :     { REAL sum;
; 1988 :       int k;
; 1989 :       /* special kludge to give double-dimension perturbations the
; 1990 :          same normal space as regular dimensions. See spin4d.fe
; 1991 :          for example of use. */
; 1992 :       for ( i =  0 ; i < v->freedom ; i++ )

	inc	esi
	cmp	esi, DWORD PTR [edi+8]
	jl	$LN77@hessian_in
$LN288@hessian_in:

; 1997 :       }
; 1998 :       /* copy over low dim basis to high dim, with transform */
; 1999 :       for ( k = 0 ; k < i ; k++ )

	xor	ebx, ebx
	mov	DWORD PTR _k$90407[ebp], ebx
	test	esi, esi
	jle	$LN68@hessian_in
	mov	eax, DWORD PTR _web+616
	cdq
	sub	eax, edx
	lea	ecx, DWORD PTR [esi*8]
	sar	eax, 1
	mov	DWORD PTR tv4956[ebp], ecx
$LN70@hessian_in:

; 2000 :          for ( j = 0 ; j < SDIM/2 ; j++ ) 

	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN69@hessian_in
$LN67@hessian_in:

; 2001 :          { v->proj[j][i+k] = v->proj[j+SDIM/2][k];

	mov	edx, DWORD PTR [edi+16]
	add	eax, ecx
	mov	eax, DWORD PTR [edx+eax*4]
	fld	QWORD PTR [eax+ebx*8]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR tv4956[ebp]
	fstp	QWORD PTR [eax+edx]

; 2002 :            v->proj[j+SDIM/2][i+k] = v->proj[j][k];

	mov	eax, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ebx, DWORD PTR _k$90407[ebp]
	mov	DWORD PTR tv4545[ebp], eax
	mov	eax, DWORD PTR _web+616
	cdq
	sub	eax, edx
	mov	edx, eax
	mov	eax, DWORD PTR [edi+16]
	sar	edx, 1
	add	edx, ecx
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR tv4545[ebp]
	inc	ecx
	fld	QWORD PTR [edx+ebx*8]
	mov	edx, DWORD PTR tv4956[ebp]
	fstp	QWORD PTR [edx+eax]
	mov	eax, DWORD PTR _web+616
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jl	SHORT $LN67@hessian_in
$LN69@hessian_in:

; 1997 :       }
; 1998 :       /* copy over low dim basis to high dim, with transform */
; 1999 :       for ( k = 0 ; k < i ; k++ )

	add	DWORD PTR tv4956[ebp], 8
	inc	ebx
	mov	DWORD PTR _k$90407[ebp], ebx
	cmp	ebx, esi
	jl	SHORT $LN70@hessian_in
$LN68@hessian_in:

; 2003 :          } 
; 2004 :       v->freedom = 2*i;  

	lea	eax, DWORD PTR [esi+esi]
	mov	DWORD PTR [edi+8], eax
$LN78@hessian_in:

; 2005 :     } 
; 2006 : 
; 2007 :     if ( hess_debug && v->proj )

	cmp	DWORD PTR _hess_debug, 0
	je	$LN186@hessian_in
	cmp	DWORD PTR [edi+16], 0
	je	$LN186@hessian_in

; 2008 :     { printf("v_id %s proj\n",ELNAME(v_id));

	cmp	DWORD PTR tv2283[ebp], 0
	fstp	ST(0)
	je	$LN224@hessian_in
	mov	ecx, DWORD PTR tv2285[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	$LN225@hessian_in
$LN179@hessian_in:

; 1874 :       }
; 1875 :     }
; 1876 :     else /* possible level set constraints */
; 1877 :     { 
; 1878 :       if (v->freedom < SDIM)  /* copy over normal basis */

	mov	edx, DWORD PTR _web+616
	cmp	esi, edx
	jge	$LN343@hessian_in

; 1879 :       { REAL **vn = get_vertex_v_normal(v_id);

	mov	edx, DWORD PTR _vhead_attr
	mov	eax, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR _v_normal$[ebp]
	mov	esi, DWORD PTR [ecx+eax*4]

; 1880 :         v->proj = vproj_base + vproj_alloc; vproj_alloc += SDIM;

	mov	edx, DWORD PTR _vproj_base
	mov	eax, DWORD PTR _vproj_alloc$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edi+16], ecx
	mov	edx, DWORD PTR _web+616
	add	eax, edx
	mov	DWORD PTR _vproj_alloc$[ebp], eax

; 1881 :         for ( j = 0 ; j < SDIM ; j++ ) 

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN367@hessian_in
	mov	ecx, DWORD PTR _vproj_spot$[ebp]
$LN164@hessian_in:

; 1882 :         { v->proj[j] = vproj_space + vproj_spot;

	mov	edx, DWORD PTR _vproj_space
	mov	ebx, DWORD PTR [edi+16]
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR [ebx+eax*4], edx
	mov	edx, DWORD PTR _web+616

; 1883 :           vproj_spot += v->freedom;

	add	ecx, DWORD PTR [edi+8]
	inc	eax
	cmp	eax, edx
	jl	SHORT $LN164@hessian_in
	mov	DWORD PTR _vproj_spot$[ebp], ecx
$LN367@hessian_in:

; 1884 :         }
; 1885 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN343@hessian_in
$LN383@hessian_in:

; 1886 :           for ( i = 0 ; i < v->freedom ; i++ )

	xor	eax, eax
	cmp	DWORD PTR [edi+8], eax
	jle	SHORT $LN160@hessian_in
$LN158@hessian_in:

; 1887 :             v->proj[j][i] = vn[i][j];

	mov	edx, DWORD PTR [esi+eax*4]
	mov	ebx, DWORD PTR [edi+16]
	fld	QWORD PTR [edx+ecx*8]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	fstp	QWORD PTR [ebx+eax*8]
	inc	eax
	cmp	eax, DWORD PTR [edi+8]
	jl	SHORT $LN158@hessian_in

; 1886 :           for ( i = 0 ; i < v->freedom ; i++ )

	mov	edx, DWORD PTR _web+616
$LN160@hessian_in:

; 1884 :         }
; 1885 :         for ( j = 0 ; j < SDIM ; j++ )

	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LN383@hessian_in
$LN343@hessian_in:

; 1888 :       }
; 1889 :       conmap = get_v_constraint_map(v_id);     

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	cmp	DWORD PTR [eax+ecx+1288], 0
	je	SHORT $LN222@hessian_in
	mov	esi, DWORD PTR _web+12
	mov	ebx, DWORD PTR tv2285[ebp]
	mov	ebx, DWORD PTR [esi+ebx*4]
	add	ebx, DWORD PTR [eax+ecx+1264]
	jmp	SHORT $LN539@hessian_in
$LN222@hessian_in:
	mov	ebx, OFFSET _nullcon
$LN539@hessian_in:

; 1890 :       oncount = 0;
; 1891 :       if ( conmap[0] )

	mov	eax, DWORD PTR [ebx]
	xor	esi, esi
	mov	DWORD PTR _conmap$90256[ebp], ebx
	mov	DWORD PTR _oncount$90257[ebp], esi
	test	eax, eax
	je	$LN142@hessian_in

; 1892 :       { /* calculate projection matrix to fewer degrees of freedom */
; 1893 :         for ( j = 1; j <= (int)conmap[0] ; j++ )

	mov	DWORD PTR _j$[ebp], 1
	cmp	eax, 1
	jl	$LN152@hessian_in
	mov	ecx, DWORD PTR _grad$[ebp]
	mov	edx, DWORD PTR _second$[ebp]
	sub	edx, ecx
	mov	DWORD PTR tv3633[ebp], ecx
	mov	DWORD PTR tv3660[ebp], edx
$LN154@hessian_in:

; 1894 :         { struct constraint *constr;
; 1895 :           if ( !(conmap[j] & CON_HIT_BIT) ) continue;

	mov	eax, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ebx+eax*4]
	test	eax, eax
	jns	SHORT $LN153@hessian_in

; 1896 :           constr = get_constraint(conmap[j]);
; 1897 :           eval_second(constr->formula,get_coord(v_id),SDIM,
; 1898 :             &dummy, grad[oncount],second[oncount],v_id);  

	mov	edx, DWORD PTR [edx+ecx]
	fstp	ST(0)
	mov	ebx, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR [ecx]
	push	ebx
	mov	ebx, DWORD PTR _dymem
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _web+616
	lea	edx, DWORD PTR _dummy$[ebp]
	push	edx
	mov	edx, DWORD PTR _web+12
	push	ecx
	mov	ecx, DWORD PTR tv2285[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+104
	add	edx, DWORD PTR [ecx+ebx+64]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	push	edx
	mov	edx, DWORD PTR _web+652
	mov	eax, DWORD PTR [eax+edx+40]
	push	eax
	call	_eval_second

; 1899 :            /* constraint value and derivs and hessian */
; 1900 :           oncount++;

	mov	ecx, DWORD PTR tv3633[ebp]
	fldz
	mov	edx, DWORD PTR tv3660[ebp]
	mov	ebx, DWORD PTR _conmap$90256[ebp]
	add	esp, 28					; 0000001cH
	inc	esi
	add	ecx, 4
	mov	DWORD PTR tv3633[ebp], ecx
$LN153@hessian_in:

; 1892 :       { /* calculate projection matrix to fewer degrees of freedom */
; 1893 :         for ( j = 1; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR [ebx]
	jle	$LN154@hessian_in
	mov	edx, DWORD PTR _web+616

; 1899 :            /* constraint value and derivs and hessian */
; 1900 :           oncount++;

	mov	DWORD PTR _oncount$90257[ebp], esi
$LN152@hessian_in:

; 1901 :         }
; 1902 : //        oncount = gram_schmidt(grad,oncount,SDIM);   // meant to get rid of redundant gradients, but messes up grad for conhess
; 1903 :         if ( (v->freedom < SDIM) && (oncount > 0) ) /* normal or something */

	cmp	DWORD PTR [edi+8], edx
	jge	$LN150@hessian_in
	test	esi, esi
	jle	$LN142@hessian_in

; 1904 :         { 
; 1905 :           /* project basis to constraints */
; 1906 :           mat_mul_tr(grad,grad,gg,oncount,SDIM,oncount);

	mov	ecx, DWORD PTR _gg$[ebp]
	fstp	ST(0)
	mov	ebx, DWORD PTR _grad$[ebp]
	push	esi
	push	edx
	push	esi
	push	ecx
	push	ebx
	push	ebx
	call	_mat_mul_tr

; 1907 :           mat_inv(gg,oncount);

	mov	edx, DWORD PTR _gg$[ebp]
	push	esi
	push	edx
	call	_mat_inv

; 1908 :           mat_mult(grad,v->proj,pp,oncount,SDIM,v->freedom);

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _pp$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+16]
	push	ecx
	push	esi
	push	edx
	push	eax
	push	ebx
	call	_mat_mult

; 1909 :           mat_mult(gg,pp,qq,oncount,oncount,v->freedom);

	mov	ecx, DWORD PTR [edi+8]
	mov	edx, DWORD PTR _qq$[ebp]
	mov	eax, DWORD PTR _pp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _gg$[ebp]
	push	esi
	push	esi
	push	edx
	push	eax
	push	ecx
	call	_mat_mult

; 1910 :           tr_mat_mul(grad,qq,pp,oncount,SDIM,v->freedom);

	mov	edx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _pp$[ebp]
	add	esp, 80					; 00000050H
	push	edx
	mov	edx, DWORD PTR _qq$[ebp]
	push	eax
	push	esi
	push	ecx
	push	edx
	push	ebx
	call	_tr_mat_mul

; 1911 :           for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	add	esp, 24					; 00000018H
	cmp	DWORD PTR _web+616, edx
	jle	$LN344@hessian_in
	mov	ebx, DWORD PTR _pp$[ebp]
$LL149@hessian_in:

; 1912 :            for ( j = 0 ; j < v->freedom ; j++ )

	xor	eax, eax
	cmp	DWORD PTR [edi+8], eax
	jle	SHORT $LN148@hessian_in
	mov	esi, DWORD PTR [ebx+edx*4]
	npad	6
$LL146@hessian_in:
	mov	ecx, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [ecx+edx*4]

; 1913 :              v->proj[i][j] -= pp[i][j];

	fld	QWORD PTR [ecx+eax*8]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fsub	QWORD PTR [esi+eax*8]
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR [edi+8]
	jl	SHORT $LL146@hessian_in
$LN148@hessian_in:

; 1911 :           for ( i = 0 ; i < SDIM ; i++ )

	inc	edx
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL149@hessian_in

; 1914 :         
; 1915 :         }
; 1916 :         else if ( oncount > 0 )

	jmp	$LN344@hessian_in
$LN150@hessian_in:
	test	esi, esi
	jle	$LN142@hessian_in

; 1917 :         { v->freedom = SDIM - oncount;

	sub	edx, esi
	mov	DWORD PTR [edi+8], edx

; 1918 :           if ( v->freedom <= 0 ) continue;

	test	edx, edx
	jle	$LN186@hessian_in

; 1919 :           v->proj = vproj_base + vproj_alloc; vproj_alloc += SDIM;

	mov	eax, DWORD PTR _vproj_alloc$[ebp]
	fstp	ST(0)
	mov	edx, DWORD PTR _vproj_base
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edi+16], ecx
	mov	ecx, DWORD PTR _web+616
	add	eax, ecx
	mov	DWORD PTR _vproj_alloc$[ebp], eax

; 1920 :           for ( j = 0 ; j < SDIM ; j++ ) 

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN368@hessian_in
	mov	edx, DWORD PTR _vproj_spot$[ebp]
	npad	8
$LL140@hessian_in:

; 1921 :           { v->proj[j] = vproj_space + vproj_spot;

	mov	ecx, DWORD PTR _vproj_space
	mov	ebx, DWORD PTR [edi+16]
	lea	ecx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR [ebx+eax*4], ecx
	mov	ecx, DWORD PTR _web+616

; 1922 :             vproj_spot += v->freedom;

	add	edx, DWORD PTR [edi+8]
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL140@hessian_in
	mov	DWORD PTR _vproj_spot$[ebp], edx
$LN368@hessian_in:

; 1923 :           }
; 1924 :           for ( m = 0 ; m < oncount ; m++ )

	test	esi, esi
	jle	SHORT $LN369@hessian_in
	mov	ebx, DWORD PTR _gradcopy$[ebp]
	mov	eax, DWORD PTR _grad$[ebp]
	sub	eax, ebx
	mov	DWORD PTR tv3790[ebp], ebx
	mov	DWORD PTR tv3805[ebp], eax
	mov	DWORD PTR tv1588[ebp], esi
$LL137@hessian_in:

; 1925 :             for ( n = 0 ; n < SDIM ; n++ ) gradcopy[m][n] = grad[m][n];

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN136@hessian_in
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR tv3805[ebp]
	mov	ebx, DWORD PTR [ecx+ebx]
	sub	ebx, eax
	npad	6
$LL134@hessian_in:
	fld	QWORD PTR [ebx+eax]
	inc	edx
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR _web+616
	add	eax, 8
	cmp	edx, ecx
	jl	SHORT $LL134@hessian_in
	mov	ebx, DWORD PTR tv3790[ebp]
$LN136@hessian_in:

; 1923 :           }
; 1924 :           for ( m = 0 ; m < oncount ; m++ )

	add	ebx, 4
	dec	DWORD PTR tv1588[ebp]
	mov	DWORD PTR tv3790[ebp], ebx
	jne	SHORT $LL137@hessian_in
$LN369@hessian_in:

; 1926 :           kernel_basis(gradcopy,v->proj,oncount,SDIM); 

	mov	edx, DWORD PTR [edi+16]
	mov	eax, DWORD PTR _gradcopy$[ebp]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	_kernel_basis
	add	esp, 16					; 00000010H
$LN344@hessian_in:

; 1914 :         
; 1915 :         }
; 1916 :         else if ( oncount > 0 )

	fldz
$LN142@hessian_in:

; 1927 :         }
; 1928 :       }
; 1929 :       /* orthonormalize proj */
; 1930 :       if ( v->proj )

	cmp	DWORD PTR [edi+16], 0
	je	$LN346@hessian_in

; 1931 :       { for ( i = 0 ; i < v->freedom ; i++ )

	xor	esi, esi
	cmp	DWORD PTR [edi+8], esi
	jle	$LN128@hessian_in
	mov	ebx, DWORD PTR _web+616
	npad	4
$LL130@hessian_in:

; 1932 :         { /* subtract previous components */
; 1933 :           REAL sum;
; 1934 :           for ( j = 0 ; j < i ; j++ ) 

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN125@hessian_in
$LN127@hessian_in:

; 1935 :           { for ( n = 0, sum = 0.0 ; n < SDIM ; n++ ) 

	fld	ST(0)
	test	ebx, ebx
	jle	SHORT $LN122@hessian_in
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR tv2204[ebp], ebx
$LN124@hessian_in:

; 1936 :                sum += v->proj[n][j]*v->proj[n][i];

	mov	eax, DWORD PTR [ecx]
	fld	QWORD PTR [eax+esi*8]
	add	ecx, 4
	dec	DWORD PTR tv2204[ebp]
	fmul	QWORD PTR [eax+edx*8]
	faddp	ST(1), ST(0)
	jne	SHORT $LN124@hessian_in
$LN122@hessian_in:

; 1937 :             for ( n = 0 ; n < SDIM ; n++ ) 

	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN463@hessian_in
$LN121@hessian_in:

; 1938 :                v->proj[n][i] -= sum*v->proj[n][j];

	mov	eax, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [eax+ecx*4]
	fld	QWORD PTR [eax+edx*8]
	inc	ecx
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax+esi*8]
	fstp	QWORD PTR [eax+esi*8]
	mov	ebx, DWORD PTR _web+616
	cmp	ecx, ebx
	jl	SHORT $LN121@hessian_in
$LN463@hessian_in:

; 1932 :         { /* subtract previous components */
; 1933 :           REAL sum;
; 1934 :           for ( j = 0 ; j < i ; j++ ) 

	inc	edx

; 1937 :             for ( n = 0 ; n < SDIM ; n++ ) 

	fstp	ST(0)
	cmp	edx, esi
	jl	SHORT $LN127@hessian_in
$LN125@hessian_in:

; 1939 :           }
; 1940 :           /* normalize */
; 1941 :           for ( n = 0, sum = 0.0 ; n < SDIM ; n++ ) 

	test	ebx, ebx
	jle	SHORT $LN116@hessian_in
	mov	eax, DWORD PTR [edi+16]
	mov	ecx, ebx
$LN118@hessian_in:

; 1942 :              sum += v->proj[n][i]*v->proj[n][i];

	mov	edx, DWORD PTR [eax]
	fld	QWORD PTR [edx+esi*8]
	add	eax, 4
	dec	ecx
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LN118@hessian_in
$LN116@hessian_in:

; 1943 :           sum = sqrt(sum);

	call	__CIsqrt

; 1944 :           if ( sum > hessian_epsilon )

	fld	QWORD PTR _hessian_epsilon
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	$LN469@hessian_in

; 1945 :              for ( n = 0 ; n < SDIM ; n++ ) v->proj[n][i] /= sum;

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN471@hessian_in
$LN114@hessian_in:

; 1931 :       { for ( i = 0 ; i < v->freedom ; i++ )

	mov	ecx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+eax*4]

; 1945 :              for ( n = 0 ; n < SDIM ; n++ ) v->proj[n][i] /= sum;

	fld	QWORD PTR [edx+esi*8]
	lea	ecx, DWORD PTR [edx+esi*8]
	fdiv	ST(0), ST(1)
	inc	eax
	fstp	QWORD PTR [ecx]
	mov	ebx, DWORD PTR _web+616
	cmp	eax, ebx
	jl	SHORT $LN114@hessian_in
$LN471@hessian_in:

; 1950 :             i--;

	fstp	ST(0)
$LN129@hessian_in:

; 1931 :       { for ( i = 0 ; i < v->freedom ; i++ )

	fldz
	inc	esi
	cmp	esi, DWORD PTR [edi+8]
	jl	$LL130@hessian_in
$LN128@hessian_in:

; 1951 :           }
; 1952 :         }
; 1953 :         if ( (hessian_normal_flag && (v->freedom == 1)) || hessian_double_normal_flag)

	cmp	DWORD PTR _hessian_normal_flag, 0
	je	SHORT $LN105@hessian_in
	cmp	DWORD PTR [edi+8], 1
	je	SHORT $LN106@hessian_in
$LN105@hessian_in:
	cmp	DWORD PTR _hessian_double_normal_flag, 0
	je	$LN346@hessian_in
$LN106@hessian_in:

; 1954 :         { /* get cosine of normal and degree of freedom */
; 1955 :           REAL *nor = get_vertex_v_normal(v_id)[0];

	mov	eax, DWORD PTR _vhead_attr
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR [eax+ecx+64]
	mov	ecx, DWORD PTR _web+12
	mov	eax, DWORD PTR tv2285[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR _v_normal$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax]

; 1956 :           v->slant = 0.0;

	fstp	QWORD PTR [edi+24]

; 1957 :           for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _web+616
	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN102@hessian_in

; 1954 :         { /* get cosine of normal and degree of freedom */
; 1955 :           REAL *nor = get_vertex_v_normal(v_id)[0];

	mov	ecx, DWORD PTR [edi+16]
$LL104@hessian_in:

; 1958 :              v->slant += v->proj[i][0]*nor[i];

	mov	esi, DWORD PTR [ecx]
	fld	QWORD PTR [edx+eax*8]
	fmul	QWORD PTR [esi]
	inc	eax
	add	ecx, 4
	fadd	QWORD PTR [edi+24]
	fstp	QWORD PTR [edi+24]
	mov	esi, DWORD PTR _web+616
	cmp	eax, esi
	jl	SHORT $LL104@hessian_in
$LN102@hessian_in:

; 1959 :           v->slant /= sqrt(SDIM_dot(nor,nor));

	fld	QWORD PTR [edi+24]
	push	esi
	push	edx
	fstp	QWORD PTR tv2589[ebp]
	push	edx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fdivr	QWORD PTR tv2589[ebp]
	fst	QWORD PTR [edi+24]

; 1960 :           if ( v->slant < hessian_slant_cutoff ) 

	fcomp	QWORD PTR _hessian_slant_cutoff
	fnstsw	ax

; 1961 :                 v->freedom = 0;

	fldz
	test	ah, 5
	jp	SHORT $LN346@hessian_in
	mov	DWORD PTR [edi+8], 0
$LN346@hessian_in:

; 1962 :         }
; 1963 :       }
; 1964 :         
; 1965 :       /* now constraint hessian */
; 1966 :       if ( oncount )

	mov	esi, DWORD PTR _oncount$90257[ebp]
	test	esi, esi
	je	$LN349@hessian_in

; 1967 :       { v->conhess = conhess_base + conhess_alloc;

	mov	ecx, DWORD PTR _conhess_base
	fstp	ST(0)
	mov	eax, DWORD PTR _conhess_alloc$[ebp]

; 1968 :         conhess_alloc += v->freedom;
; 1969 :         mat_tsquare(grad,cc,oncount,SDIM);

	mov	ebx, DWORD PTR _cc$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	add	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR _grad$[ebp]
	mov	DWORD PTR [edi+20], edx
	mov	DWORD PTR _conhess_alloc$[ebp], eax
	mov	eax, DWORD PTR _web+616
	push	eax
	push	esi
	push	ebx
	push	ecx
	call	_mat_tsquare

; 1970 :         mat_inv(cc,oncount);

	push	esi
	push	ebx
	call	_mat_inv
	add	esp, 24					; 00000018H

; 1971 :         for ( gam = 0 ; gam < SDIM ; gam++ )

	cmp	DWORD PTR _web+616, 0
	mov	DWORD PTR _gam$[ebp], 0
	jle	$LN348@hessian_in
	fldz
$LN99@hessian_in:

; 1972 :          for ( a = 0 ; a < v->freedom ; a++ )

	xor	eax, eax
	mov	DWORD PTR _a$[ebp], eax
	cmp	DWORD PTR [edi+8], eax
	jle	$LN98@hessian_in
$LN96@hessian_in:

; 1973 :           for ( b = 0 ; b < v->freedom ; b++ )

	xor	ebx, ebx
	mov	DWORD PTR _b$[ebp], ebx
	cmp	DWORD PTR [edi+8], ebx
	jle	$LN95@hessian_in
$LN347@hessian_in:

; 1974 :           { REAL sum;
; 1975 :             for ( sum = 0.0, i = 0 ; i < oncount ; i++ )

	xor	edx, edx
	fld	ST(0)
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _oncount$90257[ebp], edx
	jle	$LN88@hessian_in
$LN90@hessian_in:

; 1976 :              for ( j = 0 ; j < oncount ; j++ )

	mov	eax, DWORD PTR _cc$[ebp]
	mov	ecx, DWORD PTR _grad$[ebp]
	sub	ecx, eax
	mov	DWORD PTR tv4278[ebp], ecx
	mov	ecx, DWORD PTR _oncount$90257[ebp]
	mov	DWORD PTR tv4252[ebp], eax
	mov	DWORD PTR tv1033[ebp], ecx
$LN87@hessian_in:

; 1977 :                for ( m = 0 ; m < SDIM ; m++ )

	xor	esi, esi
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN86@hessian_in
$LN84@hessian_in:
	mov	ecx, DWORD PTR [edi+16]

; 1978 :                 for ( n = 0 ; n < SDIM ; n++ )

	mov	edi, DWORD PTR tv4278[ebp]
	mov	edi, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [eax]
	mov	ebx, DWORD PTR _gam$[ebp]
	fld	QWORD PTR [edi+ebx*8]
	mov	edi, DWORD PTR _a$[ebp]
	fmul	QWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	ebx, DWORD PTR _b$[ebp]
	fmul	QWORD PTR [eax+edi*8]
	mov	eax, DWORD PTR _second$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _web+616
$LN81@hessian_in:

; 1979 :                   sum += grad[j][gam]*cc[j][i]*v->proj[m][a]*second[i][m][n]
; 1980 :                               *v->proj[n][b];

	mov	edi, DWORD PTR [ecx]
	fld	ST(0)
	fmul	QWORD PTR [eax]
	add	eax, 8
	add	ecx, 4
	dec	edx
	fmul	QWORD PTR [edi+ebx*8]
	faddp	ST(2), ST(0)
	jne	SHORT $LN81@hessian_in

; 1978 :                 for ( n = 0 ; n < SDIM ; n++ )

	mov	eax, DWORD PTR tv4252[ebp]
	fstp	ST(0)
	mov	edx, DWORD PTR _i$[ebp]
	mov	edi, DWORD PTR _v$[ebp]
	inc	esi
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LN84@hessian_in
$LN86@hessian_in:

; 1976 :              for ( j = 0 ; j < oncount ; j++ )

	add	eax, 4
	dec	DWORD PTR tv1033[ebp]
	mov	DWORD PTR tv4252[ebp], eax
	jne	$LN87@hessian_in

; 1974 :           { REAL sum;
; 1975 :             for ( sum = 0.0, i = 0 ; i < oncount ; i++ )

	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, DWORD PTR _oncount$90257[ebp]
	jl	$LN90@hessian_in
	mov	eax, DWORD PTR _a$[ebp]
$LN88@hessian_in:

; 1981 :             v->conhess[a][b][gam] = -sum;

	mov	ecx, DWORD PTR [edi+20]
	fchs
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR _gam$[ebp]
	inc	ebx
	fstp	QWORD PTR [ecx+edx*8]
	mov	DWORD PTR _b$[ebp], ebx
	cmp	ebx, DWORD PTR [edi+8]
	jl	$LN347@hessian_in
$LN95@hessian_in:

; 1972 :          for ( a = 0 ; a < v->freedom ; a++ )

	inc	eax
	mov	DWORD PTR _a$[ebp], eax
	cmp	eax, DWORD PTR [edi+8]
	jl	$LN96@hessian_in
$LN98@hessian_in:

; 1971 :         for ( gam = 0 ; gam < SDIM ; gam++ )

	mov	eax, DWORD PTR _gam$[ebp]
	inc	eax
	mov	DWORD PTR _gam$[ebp], eax
	cmp	eax, DWORD PTR _web+616
	jl	$LN99@hessian_in
	jmp	$LN349@hessian_in
$LN469@hessian_in:

; 1946 :           else /* have to skip this direction */
; 1947 :           { for ( n = 0 ; n < SDIM ; n++ )

	xor	eax, eax
	fstp	ST(0)
	test	ebx, ebx
	jle	SHORT $LN362@hessian_in
$LL110@hessian_in:

; 1948 :               v->proj[n][i] = v->proj[n][v->freedom-1];

	mov	ecx, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [edi+8]
	fld	QWORD PTR [ecx+edx*8-8]
	inc	eax
	fstp	QWORD PTR [ecx+esi*8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL110@hessian_in
$LN362@hessian_in:

; 1949 :             v->freedom--;

	dec	DWORD PTR [edi+8]

; 1950 :             i--;

	mov	ebx, DWORD PTR _web+616
	dec	esi
	jmp	$LN129@hessian_in
$LN224@hessian_in:

; 2008 :     { printf("v_id %s proj\n",ELNAME(v_id));

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN225@hessian_in:
	push	eax
	push	OFFSET ??_C@_0O@HJGGLLDI@v_id?5?$CFs?5proj?6?$AA@
	call	_printf

; 2009 :       for ( j = 0 ; j < v->freedom ; j++ )

	xor	ebx, ebx
	add	esp, 8
	cmp	DWORD PTR [edi+8], ebx
	jle	SHORT $LN356@hessian_in
$LL371@hessian_in:

; 2010 :       { for ( m = 0 ; m < SDIM ; m++ ) printf("%f ",(DOUBLE)v->proj[m][j]);

	xor	esi, esi
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN58@hessian_in
	npad	2
$LL60@hessian_in:
	mov	edx, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [edx+esi*4]
	fld	QWORD PTR [eax+ebx*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_03JAIJOMNP@?$CFf?5?$AA@
	call	_printf
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL60@hessian_in
$LN58@hessian_in:

; 2011 :         printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	inc	ebx
	add	esp, 4
	cmp	ebx, DWORD PTR [edi+8]
	jl	SHORT $LL371@hessian_in
$LN356@hessian_in:

; 2009 :       for ( j = 0 ; j < v->freedom ; j++ )

	fldz
$LN186@hessian_in:

; 1846 :   vproj_spot = vproj_alloc = conhess_alloc = 0;
; 1847 : 
; 1848 :   /* populate vertex list vproj and conhess */
; 1849 :   MFOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR tv2285[ebp]
	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _v_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv2283[ebp], eax
	jne	$LN187@hessian_in
	mov	ebx, DWORD PTR _S$GSCopy$[ebp]
	fstp	ST(0)
	xor	esi, esi
$LN352@hessian_in:

; 2012 :       }
; 2013 :     }
; 2014 : 
; 2015 :   } /* end FOR_ALL_VERTICES second time through */
; 2016 : 
; 2017 :   if ( v_normal ) free_matrix3(v_normal); 

	mov	eax, DWORD PTR _v_normal$[ebp]
	cmp	eax, esi
	je	SHORT $LN57@hessian_in
	push	eax
	call	_free_matrix3
	add	esp, 4
$LN57@hessian_in:

; 2018 : 
; 2019 :   /* assign row numbers */
; 2020 :   for ( i = 0, v = vhead, currow = 0 ; i < vhead_count ; i++,v++ )

	mov	eax, DWORD PTR _vhead
	xor	ecx, ecx
	xor	esi, esi
	mov	DWORD PTR _currow$[ebp], esi
	lea	edi, DWORD PTR [ecx+1]
	cmp	DWORD PTR _vhead_count, ecx
	jle	SHORT $LN54@hessian_in
	add	eax, 8
	npad	3
$LL56@hessian_in:

; 2021 :   { v->rownum = currow;

	mov	DWORD PTR [eax+4], esi

; 2022 :     currow += v->freedom;

	add	esi, DWORD PTR [eax]
	add	ecx, edi
	add	eax, 32					; 00000020H
	cmp	ecx, DWORD PTR _vhead_count
	jl	SHORT $LL56@hessian_in
	mov	DWORD PTR _currow$[ebp], esi
$LN54@hessian_in:

; 2023 :   }
; 2024 : 
; 2025 :   /* check */
; 2026 :   if ( (vproj_alloc > vproj_count*SDIM) || (vproj_spot > total_proj*SDIM) ||
; 2027 :       (conhess_alloc > total_conhess) )

	mov	eax, DWORD PTR _web+616
	mov	ecx, eax
	imul	ecx, DWORD PTR _vproj_count$[ebp]
	cmp	DWORD PTR _vproj_alloc$[ebp], ecx
	jg	SHORT $LN52@hessian_in
	imul	eax, DWORD PTR _total_proj$[ebp]
	cmp	DWORD PTR _vproj_spot$[ebp], eax
	jg	SHORT $LN52@hessian_in
	mov	edx, DWORD PTR _conhess_alloc$[ebp]
	cmp	edx, DWORD PTR _total_conhess$[ebp]
	jle	SHORT $LN53@hessian_in
$LN52@hessian_in:

; 2028 :      kb_error(1608,"Internal error, hessian_init(): Overflow of vproj or conhess arena.\n",RECOVERABLE);

	push	edi
	push	OFFSET ??_C@_0EF@PLGFHGJB@Internal?5error?0?5hessian_init?$CI?$CJ?3?5@
	push	1608					; 00000648H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN53@hessian_in:

; 2029 : 
; 2030 : 
; 2031 :   /* low_rank update stuff */
; 2032 :   if ( quantity_function_sparse_flag )

	cmp	DWORD PTR _quantity_function_sparse_flag, 0
	je	$LN51@hessian_in

; 2033 :   {
; 2034 :     for ( i = LOW_INST ; i < meth_inst_count ; i++ )

	mov	DWORD PTR _i$[ebp], edi
	cmp	DWORD PTR _web+5560, edi
	jle	$LN48@hessian_in
	npad	3
$LL50@hessian_in:

; 2035 :     { struct method_instance *mi = METH_INSTANCE(i);

	mov	eax, DWORD PTR _i$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 2036 :       if ( mi->flags & Q_COMPOUND )

	test	DWORD PTR [eax+140], 256		; 00000100H
	je	SHORT $LN49@hessian_in

; 2037 :          for ( j = 0 ; j < MMAXQUANTS ; j++ )

	xor	edx, edx
	lea	edi, DWORD PTR [eax+152]
	npad	5
$LL46@hessian_in:

; 2038 :           if ( (mi->quants[j] >= 0) && (GEN_QUANT(mi->quants[j])->flags & (Q_ENERGY|Q_FIXED|Q_CONSERVED)) )

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	js	SHORT $LN45@hessian_in
	mov	ebx, DWORD PTR _gen_quant_list
	imul	ecx, 368				; 00000170H
	test	BYTE PTR [ecx+ebx+136], 11		; 0000000bH
	mov	ebx, DWORD PTR _S$GSCopy$[ebp]
	jne	SHORT $LN289@hessian_in
$LN45@hessian_in:

; 2037 :          for ( j = 0 ; j < MMAXQUANTS ; j++ )

	inc	edx
	add	edi, 4
	cmp	edx, 8
	jl	SHORT $LL46@hessian_in

; 2038 :           if ( (mi->quants[j] >= 0) && (GEN_QUANT(mi->quants[j])->flags & (Q_ENERGY|Q_FIXED|Q_CONSERVED)) )

	jmp	SHORT $LN49@hessian_in
$LN289@hessian_in:

; 2039 :           {
; 2040 :             mi->global_low_rank = S->low_rank;

	mov	ecx, DWORD PTR [ebx+208]
	mov	DWORD PTR [eax+220], ecx

; 2041 :             S->low_rank++;

	inc	DWORD PTR [ebx+208]
$LN49@hessian_in:

; 2033 :   {
; 2034 :     for ( i = LOW_INST ; i < meth_inst_count ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _web+5560
	jl	$LL50@hessian_in
	mov	edi, 1
$LN48@hessian_in:

; 2042 :             break;
; 2043 :           }
; 2044 :     }
; 2045 :     S->low_rank_vecsize = currow;
; 2046 :     S->low_rank_vectors = dmatrix(0,S->low_rank,0,currow);

	mov	edx, DWORD PTR [ebx+208]
	push	2046					; 000007feH
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	esi
	push	0
	push	edx
	push	0
	mov	DWORD PTR [ebx+212], esi
	call	_kb_dmatrix

; 2047 :     S->low_rank_form = dmatrix(0,S->low_rank,0,S->low_rank);

	push	2047					; 000007ffH
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	mov	DWORD PTR [ebx+216], eax
	mov	eax, DWORD PTR [ebx+208]
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 2048 :     S->low_rank_inverse_form = dmatrix(0,S->low_rank,0,S->low_rank);

	push	2048					; 00000800H
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	mov	DWORD PTR [ebx+220], eax
	mov	eax, DWORD PTR [ebx+208]
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix
	add	esp, 72					; 00000048H
	mov	DWORD PTR [ebx+224], eax
$LN51@hessian_in:

; 2049 :   }
; 2050 : 
; 2051 :   /* rows for optimizing parameters */
; 2052 :   S->optparamrowstart = vertex_rows = currow;

	mov	DWORD PTR _vertex_rows, esi

; 2053 :   for ( i = 0 ; i < optparamcount ; i++)

	xor	ecx, ecx
	mov	DWORD PTR [ebx+16], esi
	cmp	DWORD PTR _optparamcount, ecx
	jle	SHORT $LN40@hessian_in

; 2049 :   }
; 2050 : 
; 2051 :   /* rows for optimizing parameters */
; 2052 :   S->optparamrowstart = vertex_rows = currow;

	mov	edx, OFFSET _optparam+48
$LL42@hessian_in:

; 2054 :   { 
; 2055 :     optparam[i].vhead_index = i + web.skel[VERTEX].max_ord+1;

	mov	eax, DWORD PTR _web+68
	lea	eax, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR [edx+4], eax

; 2056 :     v = vhead + optparam[i].vhead_index;

	shl	eax, 5
	add	eax, DWORD PTR _vhead
	add	ecx, edi

; 2057 :     v->rownum = currow;

	mov	DWORD PTR [eax+12], esi

; 2058 :     v->freedom = 1;

	mov	DWORD PTR [eax+8], edi

; 2059 :     optparam[i].rownum = currow++;

	mov	DWORD PTR [edx], esi
	add	esi, edi
	add	edx, 56					; 00000038H
	cmp	ecx, DWORD PTR _optparamcount
	jl	SHORT $LL42@hessian_in
	mov	DWORD PTR _currow$[ebp], esi
$LN40@hessian_in:

; 2060 :   }
; 2061 : 
; 2062 :   /* allocate matrix */
; 2063 :   S->A_rows = S->bodyrowstart = currow; 

	mov	DWORD PTR [ebx+20], esi
	mov	DWORD PTR [ebx+12], esi

; 2064 :   /* S->A_rows is variables, before constraints */
; 2065 : 
; 2066 :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN39@hessian_in

; 2067 :     S->quanrowstart = currow;

	mov	DWORD PTR [ebx+24], esi

; 2068 :   else

	jmp	SHORT $LN38@hessian_in
$LN39@hessian_in:

; 2069 :     S->quanrowstart = currow + web.skel[BODY].max_ord+1;

	mov	ecx, DWORD PTR _web+404
	lea	edx, DWORD PTR [ecx+esi+1]
	mov	DWORD PTR [ebx+24], edx
$LN38@hessian_in:

; 2070 :   S->total_rows = S->quanrowstart + gen_quant_count;

	mov	eax, DWORD PTR [ebx+24]
	add	eax, DWORD PTR _web+5528
	mov	DWORD PTR [ebx+28], eax

; 2071 : 
; 2072 :   /* take care of torus_filled */
; 2073 :   if ( web.full_flag )  /* pretend one body info only */

	cmp	DWORD PTR _web+864, 0
	je	$LN34@hessian_in

; 2074 :   { body_id b_id;
; 2075 :     int found = 0;
; 2076 :     FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR _web+384
	mov	DWORD PTR _found$90459[ebp], 0
	test	ecx, 268435456				; 10000000H
	je	$LN34@hessian_in
	mov	ebx, DWORD PTR _web+348
	npad	1
$LL36@hessian_in:
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ebx]
	mov	esi, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR tv2845[ebp+4], edx
	mov	edx, esi
	and	edx, 1
	xor	edi, edi
	or	edx, edi
	je	$LN35@hessian_in

; 2077 :     { if ( (get_battr(b_id) & FIXEDVOL) && !found )

	and	esi, 32					; 00000020H
	xor	edx, edx
	or	esi, edx
	je	SHORT $LN31@hessian_in
	cmp	DWORD PTR _found$90459[ebp], edx
	jne	SHORT $LN31@hessian_in

; 2078 :       { if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, edx
	je	SHORT $LN30@hessian_in

; 2079 :           GEN_QUANT(get_body_volquant(b_id))->flags |= Q_REDUNDANT;

	mov	ecx, DWORD PTR [eax+ebx]
	mov	edx, DWORD PTR [ecx+404]
	mov	ecx, DWORD PTR _gen_quant_list
	imul	edx, 368				; 00000170H
	or	DWORD PTR [edx+ecx+136], 65536		; 00010000H
	lea	ecx, DWORD PTR [edx+ecx+136]

; 2081 :         found = 1; 

	mov	DWORD PTR _found$90459[ebp], 1

; 2082 :       }
; 2083 :       else

	jmp	SHORT $LN540@hessian_in
$LN30@hessian_in:

; 2080 :         else set_attr(b_id,REDUNDANT_BIT);

	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 268435456		; 10000000H
	mov	DWORD PTR [ecx+12], edx

; 2081 :         found = 1; 

	mov	DWORD PTR _found$90459[ebp], 1

; 2082 :       }
; 2083 :       else

	jmp	SHORT $LN540@hessian_in
$LN31@hessian_in:

; 2084 :       { if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, edx
	je	SHORT $LN27@hessian_in

; 2085 :           GEN_QUANT(get_body_volquant(b_id))->flags &= ~Q_REDUNDANT;

	mov	ecx, DWORD PTR [eax+ebx]
	mov	edx, DWORD PTR [ecx+404]
	mov	ecx, DWORD PTR _gen_quant_list
	imul	edx, 368				; 00000170H
	and	DWORD PTR [edx+ecx+136], -65537		; fffeffffH
	lea	ecx, DWORD PTR [edx+ecx+136]
	jmp	SHORT $LN540@hessian_in
$LN27@hessian_in:

; 2086 :         else unset_attr(b_id,REDUNDANT_BIT);

	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [ecx+12]
	and	DWORD PTR [ecx+8], -268435457		; efffffffH
	mov	DWORD PTR [ecx+12], edx
$LN540@hessian_in:
	mov	ebx, DWORD PTR _web+348
$LN35@hessian_in:

; 2074 :   { body_id b_id;
; 2075 :     int found = 0;
; 2076 :     FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [eax]
	test	ecx, 268435456				; 10000000H
	jne	$LL36@hessian_in
$LN34@hessian_in:

; 2087 :       }
; 2088 :     }
; 2089 :   }
; 2090 : 
; 2091 :   /* figure out which bodies and quantities are constraints */
; 2092 :   S->concount = web.skel[BODY].max_ord+1 + gen_quant_count;

	mov	ecx, DWORD PTR _web+5528
	mov	edx, DWORD PTR _web+404
	mov	esi, DWORD PTR _S$GSCopy$[ebp]

; 2093 :   S->coninx = (int*)temp_calloc(S->concount,sizeof(int));

	push	2093					; 0000082dH
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	lea	eax, DWORD PTR [edx+ecx+1]
	push	4
	push	eax
	mov	DWORD PTR [esi+144], eax
	call	_kb_temp_calloc
	mov	DWORD PTR [esi+152], eax

; 2094 :   for ( i = 0 ; i < S->concount ; i++ ) S->coninx[i] = -1;  // indicate unused index

	xor	eax, eax
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [esi+144], eax
	jle	SHORT $LN23@hessian_in
$LL25@hessian_in:
	mov	ecx, DWORD PTR [esi+152]
	mov	DWORD PTR [ecx+eax*4], -1
	inc	eax
	cmp	eax, DWORD PTR [esi+144]
	jl	SHORT $LL25@hessian_in
$LN23@hessian_in:

; 2095 :   S->coninxinv = (int*)temp_calloc(S->concount,sizeof(int));

	mov	edx, DWORD PTR [esi+144]
	push	2095					; 0000082fH
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	4
	push	edx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+156], eax

; 2096 :   S->CN = 0;

	mov	DWORD PTR [esi+148], 0

; 2097 :   { if ( !everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	$LN22@hessian_in

; 2098 :     { body_id b_id;
; 2099 :       FOR_ALL_BODIES(b_id)

	mov	edx, DWORD PTR _web+384
	mov	edi, edx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	mov	DWORD PTR _b_id$90489[ebp], edx
	mov	DWORD PTR tv2913[ebp], edi
	je	$LN353@hessian_in
$LL21@hessian_in:
	mov	eax, DWORD PTR _web+348
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	esi, DWORD PTR [ecx+8]
	mov	eax, esi
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	$LN20@hessian_in

; 2100 :       { ATTR a = get_battr(b_id);

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _a$90499[ebp+4], eax

; 2101 :       
; 2102 :         set_body_vhead(b_id,web.skel[VERTEX].max_ord+1 + loc_ordinal(b_id));

	test	edi, edi
	je	SHORT $LN226@hessian_in
	mov	eax, edx
	jmp	SHORT $LN227@hessian_in
$LN226@hessian_in:
	or	eax, -1
$LN227@hessian_in:
	mov	edi, DWORD PTR _web+68
	mov	ebx, DWORD PTR _dymem
	lea	eax, DWORD PTR [eax+edi+1]
	mov	edi, DWORD PTR _bhead_attr
	imul	edi, 240				; 000000f0H
	add	edi, DWORD PTR _web+440
	mov	edi, DWORD PTR [edi+ebx+64]
	mov	DWORD PTR [ecx+edi], eax

; 2103 :         v = get_body_vhead(b_id);

	mov	ecx, DWORD PTR _bhead_attr
	mov	eax, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+440

; 2104 :         if ( (a & (FIXEDVOL|PRESSURE)) && !(a & REDUNDANT_BIT)  )

	xor	edi, edi
	mov	ecx, DWORD PTR [ecx+eax+64]
	mov	eax, DWORD PTR _web+348
	mov	eax, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR [ecx+eax]
	shl	ecx, 5
	add	ecx, DWORD PTR _vhead
	mov	eax, esi
	and	eax, 2080				; 00000820H
	or	eax, edi
	je	SHORT $LN374@hessian_in
	and	esi, 268435456				; 10000000H
	xor	eax, eax
	or	esi, eax
	jne	SHORT $LN374@hessian_in

; 2105 :         { 
; 2106 :           v->v_id = b_id;
; 2107 :           v->freedom = 1;
; 2108 :           S->coninx[loc_ordinal(b_id)] = S->CN;

	mov	esi, DWORD PTR tv2913[ebp]
	mov	eax, DWORD PTR _b_id$90489[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+8], 1
	test	esi, esi
	je	SHORT $LN228@hessian_in
	mov	ecx, edx
	jmp	SHORT $LN229@hessian_in
$LN228@hessian_in:
	or	ecx, -1
$LN229@hessian_in:
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	mov	edi, DWORD PTR [eax+152]
	mov	ebx, DWORD PTR [eax+148]
	mov	DWORD PTR [edi+ecx*4], ebx

; 2109 :           S->coninxinv[S->CN] = loc_ordinal(b_id);

	test	esi, esi
	je	SHORT $LN230@hessian_in
	mov	ecx, edx
	jmp	SHORT $LN231@hessian_in
$LN230@hessian_in:
	or	ecx, -1
$LN231@hessian_in:
	mov	esi, DWORD PTR [eax+148]
	mov	edi, DWORD PTR [eax+156]
	mov	DWORD PTR [edi+esi*4], ecx

; 2110 :           S->CN++;

	inc	DWORD PTR [eax+148]
	jmp	SHORT $LN20@hessian_in
$LN374@hessian_in:

; 2111 :         }
; 2112 :         else S->coninx[loc_ordinal(b_id)] = -1;

	cmp	DWORD PTR tv2913[ebp], edi
	je	SHORT $LN232@hessian_in
	mov	eax, edx
	jmp	SHORT $LN233@hessian_in
$LN232@hessian_in:
	or	eax, -1
$LN233@hessian_in:
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ecx+152]
	mov	DWORD PTR [ecx+eax*4], -1
$LN20@hessian_in:

; 2098 :     { body_id b_id;
; 2099 :       FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx]
	mov	edi, edx
	shr	edi, 28					; 0000001cH
	and	edi, 1
	mov	DWORD PTR _b_id$90489[ebp], edx
	mov	DWORD PTR tv2913[ebp], edi
	jne	$LL21@hessian_in
$LN353@hessian_in:

; 2113 :       }
; 2114 :       FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+384
	test	eax, 268435456				; 10000000H
	je	$LN379@hessian_in
	mov	edi, DWORD PTR _currow$[ebp]
	mov	ecx, DWORD PTR _web+348
	npad	2
$LL14@hessian_in:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edx, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN13@hessian_in

; 2115 :       { v = get_body_vhead(b_id);

	mov	eax, DWORD PTR _bhead_attr
	mov	esi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+440
	mov	eax, DWORD PTR [eax+esi+64]
	mov	eax, DWORD PTR [ecx+eax]
	shl	eax, 5
	add	eax, DWORD PTR _vhead

; 2116 :         v->rownum = currow;

	mov	DWORD PTR [eax+12], edi

; 2117 :         currow += v->freedom;      

	add	edi, DWORD PTR [eax+8]
$LN13@hessian_in:

; 2113 :       }
; 2114 :       FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL14@hessian_in

; 2117 :         currow += v->freedom;      

	mov	DWORD PTR _currow$[ebp], edi

; 2118 :       }
; 2119 :     }
; 2120 :     else  S->concount = gen_quant_count;

	jmp	SHORT $LN379@hessian_in
$LN22@hessian_in:
	mov	eax, DWORD PTR _web+5528
	mov	DWORD PTR [esi+144], eax
$LN379@hessian_in:

; 2121 :     for ( n = 0 ; n < gen_quant_count ; n++,v++ )

	mov	eax, DWORD PTR _web+5528
	xor	edi, edi
	test	eax, eax
	jle	$LN6@hessian_in
	mov	esi, DWORD PTR _S$GSCopy$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR tv5113[ebp], ecx
	npad	8
$LL354@hessian_in:

; 2122 :     { int nn = everything_quantities_flag ? n : web.skel[BODY].max_ord+1 + n ;

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN234@hessian_in
	mov	edx, edi
	jmp	SHORT $LN235@hessian_in
$LN234@hessian_in:
	mov	edx, DWORD PTR _web+404
	lea	edx, DWORD PTR [edi+edx+1]
$LN235@hessian_in:

; 2123 :       struct gen_quant *q = GEN_QUANT(n);
; 2124 :       q->vhead_index = web.skel[VERTEX].max_ord+1+optparamcount+nn;

	mov	eax, DWORD PTR _optparamcount
	mov	ebx, DWORD PTR _web+68
	add	ecx, DWORD PTR _gen_quant_list
	add	eax, edx
	lea	eax, DWORD PTR [eax+ebx+1]

; 2125 :       v = vhead + q->vhead_index;
; 2126 :       v->rownum = currow;

	mov	ebx, DWORD PTR _currow$[ebp]
	mov	DWORD PTR [ecx+236], eax
	shl	eax, 5
	add	eax, DWORD PTR _vhead
	mov	DWORD PTR [eax+12], ebx

; 2127 :       v->v_id = n;

	mov	DWORD PTR [eax], edi

; 2128 :       if ( (q->flags & (Q_FIXED|Q_CONSERVED) ) &&
; 2129 :          !(q->flags & (Q_REDUNDANT|Q_DELETED))  )

	mov	ecx, DWORD PTR [ecx+136]
	test	cl, 10					; 0000000aH
	je	SHORT $LN5@hessian_in
	test	ecx, 589824				; 00090000H
	jne	SHORT $LN5@hessian_in

; 2130 :       { 
; 2131 :         v->freedom = 1;

	mov	ecx, 1

; 2132 :         currow++;

	add	DWORD PTR _currow$[ebp], ecx
	mov	DWORD PTR [eax+8], ecx

; 2133 :         S->coninx[nn] = S->CN;

	mov	ebx, DWORD PTR [esi+148]
	mov	eax, DWORD PTR [esi+152]
	mov	DWORD PTR [eax+edx*4], ebx

; 2134 :         S->coninxinv[S->CN] = nn;

	mov	eax, DWORD PTR [esi+148]
	mov	ebx, DWORD PTR [esi+156]
	mov	DWORD PTR [ebx+eax*4], edx

; 2135 :         S->CN++;

	add	DWORD PTR [esi+148], ecx
	jmp	SHORT $LN7@hessian_in
$LN5@hessian_in:

; 2136 :       }
; 2137 :       else S->coninx[nn] = -1;

	mov	ecx, DWORD PTR [esi+152]
	mov	DWORD PTR [ecx+edx*4], -1
	mov	ecx, 1
$LN7@hessian_in:

; 2121 :     for ( n = 0 ; n < gen_quant_count ; n++,v++ )

	mov	eax, DWORD PTR _web+5528
	add	edi, ecx
	mov	ecx, DWORD PTR tv5113[ebp]
	add	ecx, 368				; 00000170H
	mov	DWORD PTR tv5113[ebp], ecx
	cmp	edi, eax
	jl	$LL354@hessian_in
$LN6@hessian_in:

; 2138 :     }
; 2139 :   }
; 2140 : 
; 2141 :   /* figure whether to do constraints as augmentation or separately */
; 2142 :   if ( augmented_hessian_flag < 0 )

	mov	ecx, DWORD PTR _augmented_hessian_flag

; 2143 :   { augmented_hessian_mode = (sparse_constraints_flag && (S->CN >= 50)) ? 1 : 0;

	mov	esi, DWORD PTR _S$GSCopy$[ebp]
	test	ecx, ecx
	jns	SHORT $LN3@hessian_in
	cmp	DWORD PTR _sparse_constraints_flag, 0
	je	SHORT $LN236@hessian_in
	cmp	DWORD PTR [esi+148], 50			; 00000032H
	jl	SHORT $LN236@hessian_in
	mov	DWORD PTR _augmented_hessian_mode, 1
	jmp	SHORT $LN2@hessian_in
$LN236@hessian_in:
	mov	DWORD PTR _augmented_hessian_mode, 0
	jmp	SHORT $LN2@hessian_in
$LN3@hessian_in:

; 2144 :   }
; 2145 :   else augmented_hessian_mode = augmented_hessian_flag;

	mov	DWORD PTR _augmented_hessian_mode, ecx
$LN2@hessian_in:

; 2146 : 
; 2147 :   pressures = (REAL*)temp_calloc(web.skel[BODY].max_ord+1+gen_quant_count,
; 2148 :                 sizeof(REAL));

	mov	edx, DWORD PTR _web+404
	push	2148					; 00000864H
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	lea	eax, DWORD PTR [edx+eax+1]
	push	8
	push	eax
	call	_kb_temp_calloc

; 2149 :   conrhs = (REAL*)temp_calloc(web.skel[BODY].max_ord+1+gen_quant_count,
; 2150 :                 sizeof(REAL));

	mov	ecx, DWORD PTR _web+5528
	mov	edx, DWORD PTR _web+404
	push	2150					; 00000866H
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	mov	DWORD PTR _pressures, eax
	lea	eax, DWORD PTR [edx+ecx+1]
	push	8
	push	eax
	call	_kb_temp_calloc

; 2151 : 
; 2152 :   /* allocate right hand side and solution of augmented matrix */
; 2153 :   if ( rhs ) *rhs = (REAL *)temp_calloc(S->total_rows,sizeof(REAL));

	mov	edi, DWORD PTR _rhs$GSCopy$[ebp]
	add	esp, 32					; 00000020H
	mov	DWORD PTR _conrhs, eax
	test	edi, edi
	je	SHORT $LN1@hessian_in
	mov	ecx, DWORD PTR [esi+28]
	push	2153					; 00000869H
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	8
	push	ecx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [edi], eax
$LN1@hessian_in:

; 2154 : 
; 2155 :   S->P = (int *)temp_calloc(S->total_rows,sizeof(int));

	mov	edx, DWORD PTR [esi+28]
	push	2155					; 0000086bH
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	4
	push	edx
	call	_kb_temp_calloc

; 2156 :   S->IP = (int *)temp_calloc(S->total_rows,sizeof(int));

	push	2156					; 0000086cH
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	mov	DWORD PTR [esi+68], eax
	mov	eax, DWORD PTR [esi+28]
	push	4
	push	eax
	call	_kb_temp_calloc

; 2157 : 
; 2158 :   /* initialize hash table */
; 2159 :   sp_hash_init(S,0);

	push	0
	push	esi
	mov	DWORD PTR [esi+72], eax
	call	_sp_hash_init

; 2160 : 
; 2161 :   /* tell solvers element data is appropriate */
; 2162 :   S->flags |= S_USE_ELEMENTS;

	or	DWORD PTR [esi], 128			; 00000080H

; 2163 : 
; 2164 : } /* end hessian_init */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 40					; 00000028H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_hessian_init ENDP
_TEXT	ENDS
PUBLIC	_hessian_move
EXTRN	_calc_energy:PROC
EXTRN	_global_timestamp:DWORD
EXTRN	_project_all:PROC
EXTRN	_hess_move_con_flag:DWORD
EXTRN	_eval:PROC
EXTRN	_localbase:DWORD
EXTRN	_last_hessian_scale:QWORD
; Function compile flags: /Ogtp
;	COMDAT _hessian_move
_TEXT	SEGMENT
_coord$90643 = -32					; size = 4
_param$90668 = -28					; size = 4
tv1480 = -24						; size = 4
_v_id$ = -24						; size = 4
_velocity$90644 = -20					; size = 4
_boundary$90661 = -16					; size = 4
tv1311 = -12						; size = 4
tv767 = -8						; size = 4
_pcount$90667 = -4					; size = 4
_stepsize$ = 8						; size = 8
_mode$ = 16						; size = 4
_X$ = 20						; size = 4
_hessian_move PROC					; COMDAT

; 2276 : {

	push	ebp
	mov	ebp, esp

; 2277 :   int i,j;
; 2278 :   struct hess_verlist *vc;              /* current  vertex */
; 2279 :   vertex_id v_id;
; 2280 : 
; 2281 :   last_hessian_scale = stepsize;

	fld	QWORD PTR _stepsize$[ebp]
	sub	esp, 32					; 00000020H
	push	esi
	fst	QWORD PTR _last_hessian_scale
	push	edi

; 2282 : 
; 2283 :   /* change optimizing parameters */
; 2284 :   for ( i = 0 ; i < optparamcount ; i++ )

	xor	edi, edi
	cmp	DWORD PTR _optparamcount, edi
	jle	$LN67@hessian_mo

; 2277 :   int i,j;
; 2278 :   struct hess_verlist *vc;              /* current  vertex */
; 2279 :   vertex_id v_id;
; 2280 : 
; 2281 :   last_hessian_scale = stepsize;

	mov	esi, OFFSET _optparam
$LN31@hessian_mo:

; 2285 :   { optparam[i].velocity = X[optparam[i].rownum];
; 2286 :     if ( mode != SET_VELOCITY )

	cmp	DWORD PTR _mode$[ebp], 2
	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR _X$[ebp]
	fld	QWORD PTR [ecx+eax*8]
	lea	edx, DWORD PTR [ecx+eax*8]
	fstp	QWORD PTR [esi+16]
	je	$LN30@hessian_mo

; 2287 :     { struct global *g = globals(optparam[i].pnum);

	mov	eax, DWORD PTR [esi]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN34@hessian_mo
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN36@hessian_mo
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN35@hessian_mo
$LN36@hessian_mo:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN34@hessian_mo
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN35@hessian_mo
$LN34@hessian_mo:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx]
$LN35@hessian_mo:

; 2288 :       g->value.real += stepsize*X[optparam[i].rownum];

	fld	QWORD PTR [edx]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax+64]
	fstp	QWORD PTR [eax+64]

; 2289 :       if ( g->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [eax+188]
	test	eax, eax
	je	SHORT $LN30@hessian_mo

; 2290 :       { struct  global *gg = globals(g->attr.varstuff.on_assign_call);

	mov	ecx, eax
	fstp	ST(0)
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN40@hessian_mo
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN42@hessian_mo
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN41@hessian_mo
$LN42@hessian_mo:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN40@hessian_mo
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN41@hessian_mo
$LN40@hessian_mo:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN41@hessian_mo:

; 2291 :         eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	fld	QWORD PTR _stepsize$[ebp]
	add	esp, 16					; 00000010H
$LN30@hessian_mo:

; 2282 : 
; 2283 :   /* change optimizing parameters */
; 2284 :   for ( i = 0 ; i < optparamcount ; i++ )

	inc	edi
	add	esi, 56					; 00000038H
	cmp	edi, DWORD PTR _optparamcount
	jl	$LN31@hessian_mo
$LN67@hessian_mo:

; 2292 :       }
; 2293 :     }
; 2294 :   }
; 2295 :   /* move vertices */
; 2296 :   #ifdef MPI_EVOLVER
; 2297 :   if ( this_task == 0 ) 
; 2298 :     mpi_hessian_move(stepsize,mode,X);
; 2299 :   else
; 2300 :   #endif 
; 2301 : 
; 2302 :   FOR_ALL_VERTICES(v_id)

	mov	edi, DWORD PTR _web+48
	mov	DWORD PTR _v_id$[ebp], edi
	test	edi, 268435456				; 10000000H
	je	$LN95@hessian_mo
	push	ebx
	jmp	SHORT $LN26@hessian_mo
$LN68@hessian_mo:
	mov	edi, DWORD PTR _v_id$[ebp]
$LN26@hessian_mo:
	mov	edx, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv767[ebp], edi
	je	$LN25@hessian_mo

; 2303 :   {
; 2304 :      REAL *coord;
; 2305 :      REAL *velocity;
; 2306 : 
; 2307 :      vc = get_vertex_vhead(v_id);

	mov	eax, DWORD PTR _vhead_attr
	mov	ebx, DWORD PTR _web+104
	imul	eax, 240				; 000000f0H
	mov	edx, DWORD PTR _dymem
	add	eax, ebx
	mov	eax, DWORD PTR [eax+edx+64]
	mov	esi, DWORD PTR [ecx+eax]
	shl	esi, 5
	add	esi, DWORD PTR _vhead

; 2308 :      if ( vc->freedom <= 0 ) continue;

	cmp	DWORD PTR [esi+8], 0
	jle	$LN25@hessian_mo

; 2309 :      coord = get_coord(v_id);

	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [edi+eax]
	mov	edi, DWORD PTR [ebx+edx+64]

; 2310 :      velocity = get_velocity(v_id);

	mov	ebx, DWORD PTR [ebx+edx+1024]
	add	ebx, eax
	add	edi, eax

; 2311 :      if ( get_vattr(v_id) & BOUNDARY )

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _velocity$90644[ebp], ebx
	and	eax, 128				; 00000080H
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR _coord$90643[ebp], edi
	je	$LN20@hessian_mo

; 2312 :      { struct boundary *boundary = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN46@hessian_mo
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]
	mov	ebx, DWORD PTR [eax+ecx]
	imul	ebx, 136				; 00000088H
	add	ebx, DWORD PTR _web+776
	jmp	SHORT $LN159@hessian_mo
$LN46@hessian_mo:
	xor	ebx, ebx
$LN159@hessian_mo:

; 2313 :        int pcount = boundary->pcount;

	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR _pcount$90667[ebp], eax

; 2314 :        REAL *param = get_param(v_id);

	mov	eax, DWORD PTR _web+104
	mov	edi, DWORD PTR [eax+edx+544]
	add	edi, ecx

; 2315 : 
; 2316 :        for ( i = 0 ; i < pcount ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _pcount$90667[ebp], 4
	mov	DWORD PTR _boundary$90661[ebp], ebx
	mov	DWORD PTR _param$90668[ebp], edi
	jl	$LN69@hessian_mo

; 2313 :        int pcount = boundary->pcount;

	mov	edx, DWORD PTR _velocity$90644[ebp]
	lea	ebx, DWORD PTR [edx+24]
	sub	edx, edi
	lea	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR tv1311[ebp], edx

; 2315 : 
; 2316 :        for ( i = 0 ; i < pcount ; i++ )

$LN64@hessian_mo:

; 2317 :        { velocity[i] = X[vc->rownum + i];

	mov	edi, DWORD PTR [esi+12]
	mov	edx, DWORD PTR _X$[ebp]
	add	edi, eax

; 2318 :          if ( mode != SET_VELOCITY )

	cmp	DWORD PTR _mode$[ebp], 2
	fld	QWORD PTR [edx+edi*8]
	fstp	QWORD PTR [ebx-24]
	je	SHORT $LN60@hessian_mo

; 2319 :            param[i] += stepsize*X[vc->rownum + i];

	mov	edi, DWORD PTR [esi+12]
	add	edi, eax
	fld	QWORD PTR [edx+edi*8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
$LN60@hessian_mo:

; 2317 :        { velocity[i] = X[vc->rownum + i];

	mov	edi, DWORD PTR [esi+12]
	add	edi, eax

; 2318 :          if ( mode != SET_VELOCITY )

	cmp	DWORD PTR _mode$[ebp], 2
	fld	QWORD PTR [edx+edi*8+8]
	mov	edi, DWORD PTR tv1311[ebp]
	fstp	QWORD PTR [edi+ecx]
	je	SHORT $LN61@hessian_mo

; 2319 :            param[i] += stepsize*X[vc->rownum + i];

	mov	edi, DWORD PTR [esi+12]
	add	edi, eax
	fld	QWORD PTR [edx+edi*8+8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
$LN61@hessian_mo:

; 2317 :        { velocity[i] = X[vc->rownum + i];

	mov	edi, DWORD PTR [esi+12]
	add	edi, eax

; 2318 :          if ( mode != SET_VELOCITY )

	cmp	DWORD PTR _mode$[ebp], 2
	fld	QWORD PTR [edx+edi*8+16]
	fstp	QWORD PTR [ebx-8]
	je	SHORT $LN62@hessian_mo

; 2319 :            param[i] += stepsize*X[vc->rownum + i];

	mov	edi, DWORD PTR [esi+12]
	add	edi, eax
	fld	QWORD PTR [edx+edi*8+16]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ecx+8]
	fstp	QWORD PTR [ecx+8]
$LN62@hessian_mo:

; 2317 :        { velocity[i] = X[vc->rownum + i];

	mov	edi, DWORD PTR [esi+12]
	add	edi, eax

; 2318 :          if ( mode != SET_VELOCITY )

	cmp	DWORD PTR _mode$[ebp], 2
	fld	QWORD PTR [edx+edi*8+24]
	fstp	QWORD PTR [ebx]
	je	SHORT $LN63@hessian_mo

; 2319 :            param[i] += stepsize*X[vc->rownum + i];

	mov	edi, DWORD PTR [esi+12]
	add	edi, eax
	fld	QWORD PTR [edx+edi*8+24]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ecx+16]
	fstp	QWORD PTR [ecx+16]
$LN63@hessian_mo:

; 2313 :        int pcount = boundary->pcount;

	mov	edi, DWORD PTR _pcount$90667[ebp]
	add	eax, 4
	add	edi, -3					; fffffffdH
	add	ecx, 32					; 00000020H
	add	ebx, 32					; 00000020H
	cmp	eax, edi
	jl	$LN64@hessian_mo
	mov	edi, DWORD PTR _param$90668[ebp]
	mov	ebx, DWORD PTR _boundary$90661[ebp]
	jmp	SHORT $LC59@hessian_mo
$LN69@hessian_mo:
	mov	edx, DWORD PTR _X$[ebp]
$LC59@hessian_mo:

; 2315 : 
; 2316 :        for ( i = 0 ; i < pcount ; i++ )

	cmp	eax, DWORD PTR _pcount$90667[ebp]
	jge	SHORT $LN58@hessian_mo
	mov	ebx, DWORD PTR _velocity$90644[ebp]
	sub	ebx, edi
	lea	ecx, DWORD PTR [edi+eax*8]
	mov	DWORD PTR tv1311[ebp], ebx
$LC19@hessian_mo:

; 2317 :        { velocity[i] = X[vc->rownum + i];

	mov	ebx, DWORD PTR [esi+12]
	add	ebx, eax

; 2318 :          if ( mode != SET_VELOCITY )

	cmp	DWORD PTR _mode$[ebp], 2
	fld	QWORD PTR [edx+ebx*8]
	mov	ebx, DWORD PTR tv1311[ebp]
	fstp	QWORD PTR [ecx+ebx]
	je	SHORT $LN18@hessian_mo

; 2319 :            param[i] += stepsize*X[vc->rownum + i];

	mov	ebx, DWORD PTR [esi+12]
	add	ebx, eax
	fld	QWORD PTR [edx+ebx*8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
$LN18@hessian_mo:

; 2315 : 
; 2316 :        for ( i = 0 ; i < pcount ; i++ )

	inc	eax
	add	ecx, 8
	cmp	eax, DWORD PTR _pcount$90667[ebp]
	jl	SHORT $LC19@hessian_mo
	mov	ebx, DWORD PTR _boundary$90661[ebp]
$LN58@hessian_mo:

; 2320 :        }
; 2321 :        if ( mode != SET_VELOCITY )

	cmp	DWORD PTR _mode$[ebp], 2
	je	$LN72@hessian_mo

; 2322 :         for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _web+616, esi
	jle	$LN72@hessian_mo
	fstp	ST(0)
	add	ebx, 48					; 00000030H
$LL70@hessian_mo:

; 2323 :          coord[i] = eval(boundary->coordf[i],param,v_id,NULL);

	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	edx, DWORD PTR [ebx]
	push	0
	push	ecx
	push	edi
	push	edx
	call	_eval
	mov	eax, DWORD PTR _coord$90643[ebp]
	fstp	QWORD PTR [eax+esi*8]
	inc	esi
	add	esp, 16					; 00000010H
	add	ebx, 4
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL70@hessian_mo

; 2324 :      }
; 2325 :      else

	fld	QWORD PTR _stepsize$[ebp]
	jmp	$LN72@hessian_mo
$LN20@hessian_mo:

; 2326 :      { for ( j = 0 ; j < SDIM ; j++ )

	xor	ebx, ebx
	cmp	DWORD PTR _web+616, ebx
	jle	$LN72@hessian_mo
	mov	ecx, DWORD PTR _velocity$90644[ebp]
	sub	ecx, edi
	mov	DWORD PTR tv1480[ebp], ecx
	jmp	SHORT $LN10@hessian_mo
$LN74@hessian_mo:
	mov	ecx, DWORD PTR tv1480[ebp]
$LN10@hessian_mo:

; 2327 :          if ( vc->proj )

	mov	eax, DWORD PTR [esi+16]

; 2328 :          { velocity[j] = dot(vc->proj[j],X+vc->rownum,vc->freedom);

	mov	edx, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN7@hessian_mo
	mov	ecx, DWORD PTR [esi+8]
	fstp	ST(0)
	mov	eax, DWORD PTR [eax+ebx*4]
	push	ecx
	mov	ecx, DWORD PTR _X$[ebp]
	lea	edx, DWORD PTR [ecx+edx*8]
	push	edx
	push	eax
	call	_dot
	mov	ecx, DWORD PTR tv1480[ebp]
	add	esp, 12					; 0000000cH
	fstp	QWORD PTR [ecx+edi]

; 2329 :            if ( mode != SET_VELOCITY )

	cmp	DWORD PTR _mode$[ebp], 2
	je	SHORT $LN66@hessian_mo

; 2330 :              coord[j] += stepsize*dot(vc->proj[j],X+vc->rownum,vc->freedom);

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR _X$[ebp]
	push	edx
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax+ebx*4]
	push	edx
	push	ecx
	call	_dot
	fld	QWORD PTR _stepsize$[ebp]
	fmul	ST(1), ST(0)
	add	esp, 12					; 0000000cH
	fxch	ST(1)
	fadd	QWORD PTR [edi]
	fstp	QWORD PTR [edi]

; 2331 :          }
; 2332 :          else

	jmp	SHORT $LN9@hessian_mo
$LN7@hessian_mo:

; 2333 :          { velocity[j] = X[vc->rownum + j]; 

	mov	eax, DWORD PTR _X$[ebp]
	add	edx, ebx

; 2334 :            if ( mode != SET_VELOCITY )

	cmp	DWORD PTR _mode$[ebp], 2
	fld	QWORD PTR [eax+edx*8]
	fstp	QWORD PTR [ecx+edi]
	je	SHORT $LN9@hessian_mo

; 2335 :              coord[j] += stepsize*X[vc->rownum + j];

	mov	ecx, DWORD PTR [esi+12]
	add	ecx, ebx
	fld	QWORD PTR [eax+ecx*8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	jmp	SHORT $LN9@hessian_mo
$LN66@hessian_mo:
	fld	QWORD PTR _stepsize$[ebp]
$LN9@hessian_mo:

; 2326 :      { for ( j = 0 ; j < SDIM ; j++ )

	inc	ebx
	add	edi, 8
	cmp	ebx, DWORD PTR _web+616
	jl	$LN74@hessian_mo
$LN72@hessian_mo:
	mov	edi, DWORD PTR tv767[ebp]
$LN25@hessian_mo:

; 2292 :       }
; 2293 :     }
; 2294 :   }
; 2295 :   /* move vertices */
; 2296 :   #ifdef MPI_EVOLVER
; 2297 :   if ( this_task == 0 ) 
; 2298 :     mpi_hessian_move(stepsize,mode,X);
; 2299 :   else
; 2300 :   #endif 
; 2301 : 
; 2302 :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _v_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LN68@hessian_mo
	pop	ebx
$LN95@hessian_mo:

; 2336 :          }
; 2337 :      }
; 2338 :   }
; 2339 : 
; 2340 :   #ifdef MPI_EVOLVER
; 2341 :   if ( this_task != 0 ) return;
; 2342 :   #endif
; 2343 : 
; 2344 :   if ( mode == SET_VELOCITY ) return;

	mov	esi, DWORD PTR _mode$[ebp]
	fstp	ST(0)
	cmp	esi, 2
	je	SHORT $LN32@hessian_mo

; 2345 :   if ( hess_move_con_flag )

	cmp	DWORD PTR _hess_move_con_flag, 0
	je	SHORT $LN2@hessian_mo

; 2346 :   {
; 2347 :      calc_all_grads(CALC_VOLGRADS);

	push	2
	call	_calc_all_grads

; 2348 :      project_all(hess_move_con_flag /* all constraints */,mode);

	mov	ecx, DWORD PTR _hess_move_con_flag
	push	esi
	push	ecx
	call	_project_all
	add	esp, 12					; 0000000cH

; 2349 :      vgrad_end();

	call	_vgrad_end

; 2353 : 
; 2354 :   global_timestamp++;

	inc	DWORD PTR _global_timestamp

; 2355 :   calc_energy();  /* energy after motion */

	call	_calc_energy
	pop	edi
	pop	esi

; 2356 : }  /* end hessian_move() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@hessian_mo:

; 2350 :   }
; 2351 :   else
; 2352 :      project_all(hess_move_con_flag /* all constraints ? */,mode);

	push	esi
	push	0
	call	_project_all

; 2353 : 
; 2354 :   global_timestamp++;

	inc	DWORD PTR _global_timestamp
	add	esp, 8

; 2355 :   calc_energy();  /* energy after motion */

	call	_calc_energy
$LN32@hessian_mo:
	pop	edi
	pop	esi

; 2356 : }  /* end hessian_move() */

	mov	esp, ebp
	pop	ebp
	ret	0
_hessian_move ENDP
_TEXT	ENDS
PUBLIC	_sp_hessian_mult
EXTRN	_temp_free:PROC
EXTRN	_matvec_mul:PROC
; Function compile flags: /Ogtp
;	COMDAT _sp_hessian_mult
_TEXT	SEGMENT
_Z$90787 = -4						; size = 4
tv674 = 8						; size = 4
_W$90784 = 8						; size = 4
_S$ = 8							; size = 4
_B$ = 12						; size = 4
_C$ = 16						; size = 4
_sp_hessian_mult PROC					; COMDAT

; 2413 : { int i,j;

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 2414 : 
; 2415 :   if ( S->lambda != 0.0 )

	mov	ebx, DWORD PTR _C$[ebp]
	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	fld	QWORD PTR [esi+112]
	push	edi
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	$LN79@sp_hessian

; 2416 :   {
; 2417 :     if ( hessian_linear_metric_flag )

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	$LN34@sp_hessian

; 2418 :     { for ( j = 0 ; j < Met.N ; j++ ) C[j] = 0.0;

	mov	ecx, DWORD PTR _Met+4
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN71@sp_hessian
$LN33@sp_hessian:
	fst	QWORD PTR [ebx+eax*8]
	mov	ecx, DWORD PTR _Met+4
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LN33@sp_hessian
$LN71@sp_hessian:

; 2419 :       for ( i = 0 ; i < Met.N ; i++ )

	xor	edi, edi
	fstp	ST(0)
	test	ecx, ecx
	jle	$LN60@sp_hessian
	mov	edx, DWORD PTR _B$[ebp]
	mov	eax, ebx
	sub	eax, edx
	mov	DWORD PTR tv674[ebp], eax
	mov	eax, DWORD PTR _Met+52
$LL30@sp_hessian:

; 2420 :       { for ( j = Met.IA[i] ; j < Met.IA[i+1] ; j++ )

	mov	ecx, DWORD PTR [eax+edi*4]
	cmp	ecx, DWORD PTR [eax+edi*4+4]
	jge	SHORT $LN29@sp_hessian
	npad	2
$LL57@sp_hessian:

; 2421 :         { int jj = Met.JA[j-A_OFF] - A_OFF;
; 2422 :           C[i] -= S->lambda*Met.A[j-A_OFF]*B[jj];

	mov	ebx, DWORD PTR _Met+60
	fld	QWORD PTR [ebx+ecx*8-8]
	mov	eax, DWORD PTR _Met+56
	fmul	QWORD PTR [esi+112]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	mov	ebx, DWORD PTR _B$[ebp]
	dec	eax
	fmul	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR tv674[ebp]
	fsubr	QWORD PTR [ebx+edx]
	fstp	QWORD PTR [ebx+edx]

; 2423 :           if ( i != jj )

	cmp	edi, eax
	je	SHORT $LN26@sp_hessian

; 2424 :              C[jj] -= S->lambda*Met.A[j-A_OFF]*B[i];

	mov	ebx, DWORD PTR _Met+60
	fld	QWORD PTR [ebx+ecx*8-8]
	mov	ebx, DWORD PTR _C$[ebp]
	fmul	QWORD PTR [esi+112]
	fmul	QWORD PTR [edx]
	fsubr	QWORD PTR [ebx+eax*8]
	fstp	QWORD PTR [ebx+eax*8]
$LN26@sp_hessian:

; 2420 :       { for ( j = Met.IA[i] ; j < Met.IA[i+1] ; j++ )

	mov	eax, DWORD PTR _Met+52
	inc	ecx
	cmp	ecx, DWORD PTR [eax+edi*4+4]
	jl	SHORT $LL57@sp_hessian
	mov	ebx, DWORD PTR _C$[ebp]
$LN29@sp_hessian:

; 2419 :       for ( i = 0 ; i < Met.N ; i++ )

	inc	edi
	add	edx, 8
	cmp	edi, DWORD PTR _Met+4
	jl	SHORT $LL30@sp_hessian

; 2425 :         }
; 2426 :       }
; 2427 :     }
; 2428 :     else if ( augmented_hessian_mode )

	jmp	SHORT $LN60@sp_hessian
$LN34@sp_hessian:
	cmp	DWORD PTR _augmented_hessian_mode, 0
	je	$LN73@sp_hessian

; 2429 :     { for ( i = 0 ; i < S->A_rows ; i++ )

	xor	eax, eax
	cmp	DWORD PTR [esi+12], eax
	jle	SHORT $LN59@sp_hessian
	mov	edx, DWORD PTR _B$[ebp]
	mov	ecx, ebx
	sub	edx, ebx
$LN21@sp_hessian:

; 2430 :         C[i] = -S->lambda*B[i];

	fld	QWORD PTR [edx+ecx]
	inc	eax
	fmul	QWORD PTR [esi+112]
	add	ecx, 8
	fchs
	fstp	QWORD PTR [ecx-8]
	cmp	eax, DWORD PTR [esi+12]
	jl	SHORT $LN21@sp_hessian
$LN59@sp_hessian:

; 2431 :       for (  ; i < S->N ; i++ )

	cmp	eax, DWORD PTR [esi+4]
	jge	SHORT $LN79@sp_hessian
$LN18@sp_hessian:

; 2432 :         C[i] = 0.0;

	fst	QWORD PTR [ebx+eax*8]
	inc	eax
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LN18@sp_hessian
$LN79@sp_hessian:

; 2431 :       for (  ; i < S->N ; i++ )

	fstp	ST(0)
$LN60@sp_hessian:

; 2437 :     }
; 2438 : 
; 2439 :   for ( i = 0 ; i < S->N ; i++ )

	xor	edi, edi
	cmp	DWORD PTR [esi+4], edi
	jle	$LN9@sp_hessian
	mov	edx, DWORD PTR _B$[ebp]
	mov	eax, ebx
	sub	eax, edx
	mov	DWORD PTR tv674[ebp], eax
$LL11@sp_hessian:
	mov	ecx, DWORD PTR [esi+52]
	lea	eax, DWORD PTR [ecx+edi*4]

; 2440 :   { for ( j = S->IA[i] ; j < S->IA[i+1] ; j++ )

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $LN10@sp_hessian
$LL8@sp_hessian:

; 2441 :     { int jj = S->JA[j-A_OFF] - A_OFF;

	mov	eax, DWORD PTR [esi+56]

; 2442 :       C[i] += S->A[j-A_OFF]*B[jj];

	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+ecx*8-8]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	mov	ebx, DWORD PTR _B$[ebp]
	fmul	QWORD PTR [ebx+eax*8-8]
	mov	ebx, DWORD PTR tv674[ebp]
	dec	eax
	fadd	QWORD PTR [edx+ebx]
	fstp	QWORD PTR [edx+ebx]

; 2443 :       if ( i != jj )

	cmp	edi, eax
	je	SHORT $LN56@sp_hessian

; 2444 :          C[jj] += S->A[j-A_OFF]*B[i];

	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+ecx*8-8]
	mov	ebx, DWORD PTR _C$[ebp]
	fmul	QWORD PTR [edx]
	fadd	QWORD PTR [ebx+eax*8]
	fstp	QWORD PTR [ebx+eax*8]
	jmp	SHORT $LN7@sp_hessian
$LN73@sp_hessian:

; 2433 :     }
; 2434 :     else
; 2435 :      for ( i = 0 ; i < S->N ; i++ )

	xor	ecx, ecx
	fstp	ST(0)
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN60@sp_hessian
	mov	edx, DWORD PTR _B$[ebp]
	mov	eax, ebx
	sub	edx, ebx
$LL14@sp_hessian:

; 2436 :       C[i] = -S->lambda*B[i];

	fld	QWORD PTR [eax+edx]
	inc	ecx
	fmul	QWORD PTR [esi+112]
	add	eax, 8
	fchs
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LL14@sp_hessian

; 2433 :     }
; 2434 :     else
; 2435 :      for ( i = 0 ; i < S->N ; i++ )

	jmp	SHORT $LN60@sp_hessian
$LN56@sp_hessian:

; 2444 :          C[jj] += S->A[j-A_OFF]*B[i];

	mov	ebx, DWORD PTR _C$[ebp]
$LN7@sp_hessian:

; 2440 :   { for ( j = S->IA[i] ; j < S->IA[i+1] ; j++ )

	mov	eax, DWORD PTR [esi+52]
	inc	ecx
	cmp	ecx, DWORD PTR [eax+edi*4+4]
	jl	SHORT $LL8@sp_hessian
$LN10@sp_hessian:

; 2437 :     }
; 2438 : 
; 2439 :   for ( i = 0 ; i < S->N ; i++ )

	inc	edi
	add	edx, 8
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL11@sp_hessian
$LN9@sp_hessian:

; 2445 :     }
; 2446 :   }
; 2447 : 
; 2448 :   /* Add low-rank stuff */
; 2449 :   if ( S->low_rank )

	mov	eax, DWORD PTR [esi+208]
	test	eax, eax
	je	$LN4@sp_hessian

; 2450 :   { REAL *Y = (REAL*)temp_calloc(S->low_rank,sizeof(REAL));

	push	2450					; 00000992H
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc

; 2451 :     REAL *W = (REAL*)temp_calloc(S->low_rank,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+208]
	push	2451					; 00000993H
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	8
	push	ecx
	mov	edi, eax
	call	_kb_temp_calloc

; 2452 :     REAL *Z = (REAL*)temp_calloc(S->N,sizeof(REAL));

	mov	edx, DWORD PTR [esi+4]
	push	2452					; 00000994H
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	8
	push	edx
	mov	DWORD PTR _W$90784[ebp], eax
	call	_kb_temp_calloc

; 2453 :     matvec_mul(S->low_rank_vectors,B,Y,S->low_rank,S->low_rank_vecsize);

	mov	ecx, DWORD PTR [esi+208]
	mov	edx, DWORD PTR _B$[ebp]
	mov	DWORD PTR _Z$90787[ebp], eax
	mov	eax, DWORD PTR [esi+212]
	push	eax
	mov	eax, DWORD PTR [esi+216]
	push	ecx
	push	edi
	push	edx
	push	eax
	call	_matvec_mul

; 2454 :     matvec_mul(S->low_rank_form,Y,W,S->low_rank,S->low_rank);

	mov	eax, DWORD PTR [esi+208]
	mov	ecx, DWORD PTR _W$90784[ebp]
	mov	edx, DWORD PTR [esi+220]
	add	esp, 68					; 00000044H
	push	eax
	push	eax
	push	ecx
	push	edi
	push	edx
	call	_matvec_mul

; 2455 :     vec_mat_mul(W,S->low_rank_vectors,Z,S->low_rank,S->low_rank_vecsize);

	mov	eax, DWORD PTR [esi+212]
	mov	ecx, DWORD PTR [esi+208]
	mov	edx, DWORD PTR _Z$90787[ebp]
	push	eax
	mov	eax, DWORD PTR [esi+216]
	push	ecx
	mov	ecx, DWORD PTR _W$90784[ebp]
	push	edx
	push	eax
	push	ecx
	call	_vec_mat_mul

; 2456 :     for ( i = 0 ; i < S->low_rank_vecsize ; i++ )

	xor	ecx, ecx
	add	esp, 40					; 00000028H
	cmp	DWORD PTR [esi+212], ecx
	jle	SHORT $LN1@sp_hessian
	mov	edx, DWORD PTR _Z$90787[ebp]
	mov	eax, ebx
	sub	edx, ebx
	npad	7
$LL3@sp_hessian:

; 2457 :       C[i] += Z[i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+212]
	jl	SHORT $LL3@sp_hessian
$LN1@sp_hessian:

; 2458 :     temp_free((char*)Y);

	push	edi
	call	_temp_free

; 2459 :     temp_free((char*)W);

	mov	edx, DWORD PTR _W$90784[ebp]
	push	edx
	call	_temp_free

; 2460 :     temp_free((char*)Z);

	mov	eax, DWORD PTR _Z$90787[ebp]
	push	eax
	call	_temp_free
	add	esp, 12					; 0000000cH
$LN4@sp_hessian:
	pop	edi
	pop	esi
	pop	ebx

; 2461 :   }
; 2462 : } // end sp_hessian_mult()

	mov	esp, ebp
	pop	ebp
	ret	0
_sp_hessian_mult ENDP
_TEXT	ENDS
PUBLIC	_hessian_cleanup
EXTRN	_free_matrix:PROC
EXTRN	_local_unsave_coords:PROC
EXTRN	_myfree:PROC
_BSS	SEGMENT
_ritz_done_flag DD 01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _hessian_cleanup
_TEXT	SEGMENT
_hessian_cleanup PROC					; COMDAT

; 2474 :   #ifdef MPI_EVOLVER
; 2475 :   if ( this_task == 0 )
; 2476 :   { mpi_hessian_cleanup();
; 2477 :   }
; 2478 :   #endif
; 2479 :   
; 2480 :   if ( vhead ) temp_free((char *)vhead); vhead = NULL;

	mov	eax, DWORD PTR _vhead
	push	esi
	xor	esi, esi
	cmp	eax, esi
	je	SHORT $LN7@hessian_cl
	push	eax
	call	_temp_free
	add	esp, 4
$LN7@hessian_cl:

; 2481 :   if ( vproj_base ) myfree((char*)vproj_base); vproj_base = NULL;

	mov	eax, DWORD PTR _vproj_base
	mov	DWORD PTR _vhead, esi
	cmp	eax, esi
	je	SHORT $LN6@hessian_cl
	push	eax
	call	_myfree
	add	esp, 4
$LN6@hessian_cl:

; 2482 :   if ( vproj_space ) myfree((char*)vproj_space); vproj_space = NULL;

	mov	eax, DWORD PTR _vproj_space
	mov	DWORD PTR _vproj_base, esi
	cmp	eax, esi
	je	SHORT $LN5@hessian_cl
	push	eax
	call	_myfree
	add	esp, 4
$LN5@hessian_cl:

; 2483 :   if ( conhess_base ) free_matrix3(conhess_base); conhess_base = NULL;

	mov	eax, DWORD PTR _conhess_base
	mov	DWORD PTR _vproj_space, esi
	cmp	eax, esi
	je	SHORT $LN4@hessian_cl
	push	eax
	call	_free_matrix3
	add	esp, 4
$LN4@hessian_cl:

; 2484 :   local_unsave_coords(&saved,SAVE_IN_ATTR);

	push	1
	push	OFFSET _saved
	mov	DWORD PTR _conhess_base, esi
	call	_local_unsave_coords

; 2485 :   if ( pressures ) temp_free((char*)pressures); pressures = NULL;

	mov	eax, DWORD PTR _pressures
	add	esp, 8
	cmp	eax, esi
	je	SHORT $LN3@hessian_cl
	push	eax
	call	_temp_free
	add	esp, 4
$LN3@hessian_cl:

; 2486 :   if ( conrhs ) temp_free((char*)conrhs); conrhs = NULL;

	mov	eax, DWORD PTR _conrhs
	mov	DWORD PTR _pressures, esi
	cmp	eax, esi
	je	SHORT $LN2@hessian_cl
	push	eax
	call	_temp_free
	add	esp, 4
$LN2@hessian_cl:

; 2487 :   if ( ritzvecs ) free_matrix(ritzvecs); ritz_done_flag = 0; ritzvecs = NULL;

	mov	eax, DWORD PTR _ritzvecs
	mov	DWORD PTR _conrhs, esi
	cmp	eax, esi
	je	SHORT $LN10@hessian_cl
	push	eax
	call	_free_matrix
	add	esp, 4
$LN10@hessian_cl:
	mov	DWORD PTR _ritzvecs, esi
	mov	DWORD PTR _ritz_done_flag, esi
	pop	esi

; 2488 :   return;
; 2489 : 
; 2490 : } // end hessian_cleanup()

	ret	0
_hessian_cleanup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@EJNIFMOA@?$CFd?5?$CFd?5?$CF21?415e?6?$AA@ ; `string'
PUBLIC	??_C@_03EBJOKFHF@?5?$CFd?$AA@			; `string'
PUBLIC	??_C@_08NGAHNDIL@?5?$CF21?415e?$AA@		; `string'
PUBLIC	??_C@_03JDANDILB@?$CFd?5?$AA@			; `string'
PUBLIC	??_C@_0BA@KCCAFBEG@?$CFd?5constraints?6?$AA@	; `string'
PUBLIC	??_C@_0BD@BNKKIGNL@?$CFd?5metric?5entries?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@FIEMNMLO@?$CFd?5metric?5rows?6?$AA@	; `string'
PUBLIC	??_C@_0M@BCDCHBAM@?$CFd?5entries?6?$AA@		; `string'
PUBLIC	??_C@_08ENLEFBJA@?$CFd?5rows?6?$AA@		; `string'
PUBLIC	??_C@_0BE@BHAENNBI@?$CFd?5space?5dimension?6?$AA@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	_S$GSCopy$
PUBLIC	??_C@_0BK@MDIMJEO@Enter?5hessian?5file?5name?3?5?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_write_hessian
EXTRN	_fclose:PROC
EXTRN	_fprintf:PROC
EXTRN	_erroutstring:PROC
EXTRN	_perror:PROC
EXTRN	_l_evolver_mode:DWORD
EXTRN	_l_redirect:DWORD
EXTRN	_fopen:PROC
EXTRN	_prompt:PROC
;	COMDAT ??_C@_0P@EJNIFMOA@?$CFd?5?$CFd?5?$CF21?415e?6?$AA@
CONST	SEGMENT
??_C@_0P@EJNIFMOA@?$CFd?5?$CFd?5?$CF21?415e?6?$AA@ DB '%d %d %21.15e', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03EBJOKFHF@?5?$CFd?$AA@
CONST	SEGMENT
??_C@_03EBJOKFHF@?5?$CFd?$AA@ DB ' %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NGAHNDIL@?5?$CF21?415e?$AA@
CONST	SEGMENT
??_C@_08NGAHNDIL@?5?$CF21?415e?$AA@ DB ' %21.15e', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JDANDILB@?$CFd?5?$AA@
CONST	SEGMENT
??_C@_03JDANDILB@?$CFd?5?$AA@ DB '%d ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KCCAFBEG@?$CFd?5constraints?6?$AA@
CONST	SEGMENT
??_C@_0BA@KCCAFBEG@?$CFd?5constraints?6?$AA@ DB '%d constraints', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BNKKIGNL@?$CFd?5metric?5entries?6?$AA@
CONST	SEGMENT
??_C@_0BD@BNKKIGNL@?$CFd?5metric?5entries?6?$AA@ DB '%d metric entries', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FIEMNMLO@?$CFd?5metric?5rows?6?$AA@
CONST	SEGMENT
??_C@_0BA@FIEMNMLO@?$CFd?5metric?5rows?6?$AA@ DB '%d metric rows', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BCDCHBAM@?$CFd?5entries?6?$AA@
CONST	SEGMENT
??_C@_0M@BCDCHBAM@?$CFd?5entries?6?$AA@ DB '%d entries', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08ENLEFBJA@?$CFd?5rows?6?$AA@
CONST	SEGMENT
??_C@_08ENLEFBJA@?$CFd?5rows?6?$AA@ DB '%d rows', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BHAENNBI@?$CFd?5space?5dimension?6?$AA@
CONST	SEGMENT
??_C@_0BE@BHAENNBI@?$CFd?5space?5dimension?6?$AA@ DB '%d space dimension', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MDIMJEO@Enter?5hessian?5file?5name?3?5?$AA@
CONST	SEGMENT
??_C@_0BK@MDIMJEO@Enter?5hessian?5file?5name?3?5?$AA@ DB 'Enter hessian f'
	DB	'ile name: ', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _write_hessian
_TEXT	SEGMENT
_v$ = -120						; size = 4
_x$90850 = -120						; size = 4
tv538 = -116						; size = 4
_S$GSCopy$ = -112					; size = 4
_end$90921 = -108					; size = 4
_row$ = -108						; size = 4
_j$ = -108						; size = 4
_name$ = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_write_hessian PROC					; COMDAT

; 2501 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	push	edi

; 2502 :   FILE *fd;
; 2503 :   char name[100];
; 2504 :   int i,j,n,row;
; 2505 :   struct hess_verlist *v;
; 2506 :   vertex_id v_id;
; 2507 : 
; 2508 :   prompt("Enter hessian file name: ",name,sizeof(name));

	push	100					; 00000064H
	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BK@MDIMJEO@Enter?5hessian?5file?5name?3?5?$AA@

; 2552 :       fprintf(fd,"\n");

	mov	DWORD PTR _S$GSCopy$[ebp], esi
	call	_prompt
	lea	ecx, DWORD PTR _name$[ebp]
	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	ecx
	call	_fopen
	mov	edi, eax
	add	esp, 20					; 00000014H
	test	edi, edi
	jne	SHORT $LN56@write_hess

; 2509 :   fd = fopen(name,"w");
; 2510 :   if ( fd == NULL )
; 2511 :   { 
; 2512 : #ifdef __L_EVOLVER__		 
; 2513 : 		   		     if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, eax
	jne	SHORT $LN54@write_hess
	cmp	DWORD PTR _l_evolver_mode, eax
	jne	SHORT $LN54@write_hess

; 2515 : 		   		     else
; 2516 : 					   perror(name);

	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	call	_perror
	add	esp, 4
	pop	edi
	pop	esi

; 2588 : 
; 2589 : } // end write_hessian()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@write_hess:

; 2514 : 			   		   erroutstring(name);

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	call	_erroutstring
	add	esp, 4
	pop	edi
	pop	esi

; 2588 : 
; 2589 : } // end write_hessian()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@write_hess:

; 2517 : #else
; 2518 : 					 perror(name);
; 2519 : #endif
; 2520 :     return; 
; 2521 :   }
; 2522 : 
; 2523 :   /* size info */
; 2524 :   fprintf(fd,"%d space dimension\n",SDIM);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	push	OFFSET ??_C@_0BE@BHAENNBI@?$CFd?5space?5dimension?6?$AA@
	push	edi
	call	_fprintf

; 2525 :   fprintf(fd,"%d rows\n",S->N);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	push	OFFSET ??_C@_08ENLEFBJA@?$CFd?5rows?6?$AA@
	push	edi
	call	_fprintf

; 2526 :   fprintf(fd,"%d entries\n",S->IA[S->N]-A_OFF);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+eax*4]
	dec	edx
	push	edx
	push	OFFSET ??_C@_0M@BCDCHBAM@?$CFd?5entries?6?$AA@
	push	edi
	call	_fprintf
	add	esp, 36					; 00000024H

; 2527 :   if ( hessian_linear_metric_flag )

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $LN52@write_hess

; 2528 :   {  fprintf(fd,"%d metric rows\n",Met.N);

	mov	eax, DWORD PTR _Met+4
	push	eax
	push	OFFSET ??_C@_0BA@FIEMNMLO@?$CFd?5metric?5rows?6?$AA@
	push	edi
	call	_fprintf

; 2529 :       fprintf(fd,"%d metric entries\n",Met.IA[S->N]-A_OFF);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _Met+52
	mov	eax, DWORD PTR [edx+ecx*4]
	dec	eax
	push	eax

; 2530 :   }
; 2531 :   else

	jmp	SHORT $LN99@write_hess
$LN52@write_hess:

; 2532 :   {  fprintf(fd,"%d metric rows\n",0);

	push	0
	push	OFFSET ??_C@_0BA@FIEMNMLO@?$CFd?5metric?5rows?6?$AA@
	push	edi
	call	_fprintf

; 2533 :       fprintf(fd,"%d metric entries\n",0);

	push	0
$LN99@write_hess:
	push	OFFSET ??_C@_0BD@BNKKIGNL@?$CFd?5metric?5entries?6?$AA@
	push	edi
	call	_fprintf

; 2534 :   }
; 2535 :   fprintf(fd,"%d constraints\n",S->CN);

	mov	ecx, DWORD PTR [esi+148]
	add	esp, 24					; 00000018H
	push	ebx
	push	ecx
	push	OFFSET ??_C@_0BA@KCCAFBEG@?$CFd?5constraints?6?$AA@
	push	edi
	call	_fprintf

; 2536 : 
; 2537 :   /* per row info:
; 2538 :       point coords, basis vectors for each degree of freedom,
; 2539 :    */
; 2540 :   
; 2541 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	edx, DWORD PTR _web+12
	add	esp, 12					; 0000000cH
	test	eax, 268435456				; 10000000H
	je	$LN48@write_hess
$LL97@write_hess:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	mov	DWORD PTR tv538[ebp], esi
	je	$LN49@write_hess

; 2542 :   { REAL *x = get_coord(v_id);

	mov	ebx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+ebx+64]
	mov	eax, DWORD PTR [esi+edx]
	add	ecx, eax
	mov	DWORD PTR _x$90850[ebp], ecx

; 2543 :     v = get_vertex_vhead(v_id);

	mov	ecx, DWORD PTR _vhead_attr
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+104

; 2544 :     for ( j = 0 ; j < v->freedom ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	mov	ecx, DWORD PTR [ecx+ebx+64]
	mov	ebx, DWORD PTR [eax+ecx]
	shl	ebx, 5
	add	ebx, DWORD PTR _vhead
	cmp	DWORD PTR [ebx+8], 0
	jle	$LN49@write_hess
	npad	1
$LL86@write_hess:

; 2545 :     { fprintf(fd,"%d ",v->rownum+j);

	mov	edx, DWORD PTR [ebx+12]
	add	edx, DWORD PTR _j$[ebp]
	push	edx
	push	OFFSET ??_C@_03JDANDILB@?$CFd?5?$AA@
	push	edi
	call	_fprintf

; 2546 :       for ( n = 0 ; n < SDIM ; n++ ) fprintf(fd," %21.15e",(DOUBLE)x[n]);

	mov	eax, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN40@write_hess
$LL42@write_hess:
	mov	eax, DWORD PTR _x$90850[ebp]
	fld	QWORD PTR [eax+esi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_08NGAHNDIL@?5?$CF21?415e?$AA@
	push	edi
	call	_fprintf
	mov	eax, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, eax
	jl	SHORT $LL42@write_hess
$LN40@write_hess:

; 2547 :       if ( v->proj )
; 2548 :         for ( n = 0 ; n < SDIM ; n++ ) 

	xor	esi, esi
	cmp	DWORD PTR [ebx+16], esi
	je	SHORT $LN39@write_hess
	test	eax, eax
	jle	SHORT $LN32@write_hess
	npad	1
$LL38@write_hess:

; 2549 :           fprintf(fd," %21.15e",(DOUBLE)v->proj[n][j]);

	mov	ecx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR _j$[ebp]
	fld	QWORD PTR [edx+eax*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_08NGAHNDIL@?5?$CF21?415e?$AA@
	push	edi
	call	_fprintf
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL38@write_hess

; 2550 :       else

	jmp	SHORT $LN32@write_hess
$LN39@write_hess:

; 2551 :         for ( n = 0 ; n < SDIM ; n++ ) fprintf(fd," %d",n==j);

	test	eax, eax
	jle	SHORT $LN32@write_hess
	npad	1
$LL34@write_hess:
	xor	ecx, ecx
	cmp	esi, DWORD PTR _j$[ebp]
	sete	cl
	push	ecx
	push	OFFSET ??_C@_03EBJOKFHF@?5?$CFd?$AA@
	push	edi
	call	_fprintf
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL34@write_hess
$LN32@write_hess:

; 2552 :       fprintf(fd,"\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	push	edi
	call	_fprintf
	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	add	esp, 8
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR [ebx+8]
	jl	$LL86@write_hess

; 2544 :     for ( j = 0 ; j < v->freedom ; j++ )

	mov	edx, DWORD PTR _web+12
	mov	esi, DWORD PTR tv538[ebp]
$LN49@write_hess:

; 2536 : 
; 2537 :   /* per row info:
; 2538 :       point coords, basis vectors for each degree of freedom,
; 2539 :    */
; 2540 :   
; 2541 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LL97@write_hess
$LN48@write_hess:

; 2553 :     }
; 2554 :   }
; 2555 : 
; 2556 :   /* the Hessian */
; 2557 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	$LN29@write_hess
	npad	9
$LL96@write_hess:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	ebx, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [ebx+edx]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv538[ebp], ebx
	je	$LN30@write_hess

; 2558 :   { 
; 2559 :     v = get_vertex_vhead(v_id);

	mov	eax, DWORD PTR _vhead_attr
	mov	esi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+esi+64]
	mov	ecx, DWORD PTR [ecx+eax]
	shl	ecx, 5
	add	ecx, DWORD PTR _vhead

; 2560 :     if ( v->freedom == 0 ) continue;

	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR _v$[ebp], ecx
	test	esi, esi
	je	SHORT $LN30@write_hess

; 2561 :     for ( row = v->rownum ; row < v->rownum + v->freedom ; row++ )

	mov	eax, DWORD PTR [ecx+12]
	add	esi, eax
	mov	DWORD PTR _row$[ebp], eax
	cmp	eax, esi
	jge	SHORT $LN30@write_hess
	npad	3
$LL87@write_hess:
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	mov	edx, DWORD PTR [edx+52]

; 2562 :     { int start = S->IA[row]-A_OFF;
; 2563 :       int end = S->IA[row+1] - A_OFF;

	mov	ebx, DWORD PTR [edx+eax*4+4]
	mov	esi, DWORD PTR [edx+eax*4]
	lea	edx, DWORD PTR [edx+eax*4]
	dec	ebx
	dec	esi

; 2564 :       for ( j = start ; j < end ; j++ )

	cmp	esi, ebx
	jge	SHORT $LN24@write_hess
$LL89@write_hess:

; 2565 :         fprintf(fd,"%d %d %21.15e\n",row,S->JA[j]-A_OFF,(DOUBLE)S->A[j]);

	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	fld	QWORD PTR [edx+esi*8]
	mov	ecx, DWORD PTR [ecx+56]
	mov	edx, DWORD PTR [ecx+esi*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	dec	edx
	push	edx
	push	eax
	push	OFFSET ??_C@_0P@EJNIFMOA@?$CFd?5?$CFd?5?$CF21?415e?6?$AA@
	push	edi
	call	_fprintf
	mov	eax, DWORD PTR _row$[ebp]
	inc	esi
	add	esp, 24					; 00000018H
	cmp	esi, ebx
	jl	SHORT $LL89@write_hess

; 2564 :       for ( j = start ; j < end ; j++ )

	mov	ecx, DWORD PTR _v$[ebp]
$LN24@write_hess:

; 2561 :     for ( row = v->rownum ; row < v->rownum + v->freedom ; row++ )

	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR [ecx+8]
	inc	eax
	mov	DWORD PTR _row$[ebp], eax
	cmp	eax, edx
	jl	SHORT $LL87@write_hess
	mov	edx, DWORD PTR _web+12
	mov	ebx, DWORD PTR tv538[ebp]
$LN30@write_hess:

; 2553 :     }
; 2554 :   }
; 2555 : 
; 2556 :   /* the Hessian */
; 2557 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [ebx+edx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LL96@write_hess
$LN29@write_hess:

; 2566 :     }
; 2567 :   }
; 2568 :   /* the metric */
; 2569 :   if (hessian_linear_metric_flag)

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	$LN16@write_hess

; 2570 :   { FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	$LN16@write_hess
	npad	5
$LL94@write_hess:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv538[ebp], esi
	je	$LN17@write_hess

; 2571 :     { 
; 2572 :      v = get_vertex_vhead(v_id);

	mov	eax, DWORD PTR _vhead_attr
	mov	ebx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	ecx, DWORD PTR [ecx+eax]
	shl	ecx, 5
	add	ecx, DWORD PTR _vhead

; 2573 :      if ( v->freedom == 0 ) continue;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR _v$[ebp], ecx
	test	eax, eax
	je	SHORT $LN17@write_hess

; 2574 :      for ( row = v->rownum ; row < v->rownum + v->freedom ; row++ )

	mov	ebx, DWORD PTR [ecx+12]
	add	eax, ebx
	cmp	ebx, eax
	jge	SHORT $LN17@write_hess
	npad	6
$LL88@write_hess:

; 2575 :      { int start = Met.IA[row]-A_OFF;
; 2576 :         int end = Met.IA[row+1] - A_OFF;

	mov	edx, DWORD PTR _Met+52
	mov	eax, DWORD PTR [edx+ebx*4+4]
	mov	esi, DWORD PTR [edx+ebx*4]
	dec	eax
	dec	esi
	mov	DWORD PTR _end$90921[ebp], eax

; 2577 :         for ( j = start ; j < end ; j++ )

	cmp	esi, eax
	jge	SHORT $LN11@write_hess
	npad	10
$LL90@write_hess:

; 2578 :           fprintf(fd,"%d %d %21.15e\n",row,Met.JA[j]-A_OFF,(DOUBLE)Met.A[j]);

	mov	edx, DWORD PTR _Met+56
	mov	ecx, DWORD PTR _Met+60
	mov	eax, DWORD PTR [edx+esi*4]
	fld	QWORD PTR [ecx+esi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	dec	eax
	push	eax
	push	ebx
	push	OFFSET ??_C@_0P@EJNIFMOA@?$CFd?5?$CFd?5?$CF21?415e?6?$AA@
	push	edi
	call	_fprintf
	inc	esi
	add	esp, 24					; 00000018H
	cmp	esi, DWORD PTR _end$90921[ebp]
	jl	SHORT $LL90@write_hess

; 2577 :         for ( j = start ; j < end ; j++ )

	mov	ecx, DWORD PTR _v$[ebp]
$LN11@write_hess:

; 2574 :      for ( row = v->rownum ; row < v->rownum + v->freedom ; row++ )

	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR [ecx+8]
	inc	ebx
	cmp	ebx, edx
	jl	SHORT $LL88@write_hess
	mov	edx, DWORD PTR _web+12
	mov	esi, DWORD PTR tv538[ebp]
$LN17@write_hess:

; 2570 :   { FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LL94@write_hess
$LN16@write_hess:

; 2579 :      }
; 2580 :     }
; 2581 :   }
; 2582 : 
; 2583 :   /* constraints */
; 2584 :   for ( i = 0 ; i < S->CN ; i++ )

	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	xor	esi, esi
	cmp	DWORD PTR [ecx+148], esi
	jle	SHORT $LN4@write_hess
	mov	eax, DWORD PTR [ecx+4]
$LL98@write_hess:

; 2585 :      for ( j = 0 ; j < S->N ; j++ )

	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN5@write_hess
	npad	4
$LL91@write_hess:

; 2586 :         fprintf(fd,"%d %d %21.15e\n",i,j,(DOUBLE)S->C[i][j]);

	mov	ecx, DWORD PTR [ecx+160]
	mov	edx, DWORD PTR [ecx+esi*4]
	fld	QWORD PTR [edx+ebx*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ebx
	push	esi
	push	OFFSET ??_C@_0P@EJNIFMOA@?$CFd?5?$CFd?5?$CF21?415e?6?$AA@
	push	edi
	call	_fprintf
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	inc	ebx
	add	esp, 24					; 00000018H
	cmp	ebx, eax
	jl	SHORT $LL91@write_hess
$LN5@write_hess:

; 2579 :      }
; 2580 :     }
; 2581 :   }
; 2582 : 
; 2583 :   /* constraints */
; 2584 :   for ( i = 0 ; i < S->CN ; i++ )

	inc	esi
	cmp	esi, DWORD PTR [ecx+148]
	jl	SHORT $LL98@write_hess
$LN4@write_hess:

; 2587 :   fclose(fd);

	push	edi
	call	_fclose

; 2588 : 
; 2589 : } // end write_hessian()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 4
	pop	ebx
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_write_hessian ENDP
_TEXT	ENDS
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@bfd0000000000000
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	__real@bfe0000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@c000000000000000
PUBLIC	_rhs$GSCopy$
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_optparamhess
EXTRN	_unsave_coords:PROC
EXTRN	_calc_volgrads:PROC
EXTRN	_calc_quant_hess:PROC
EXTRN	_fixed_constraint_flag:DWORD
EXTRN	_calc_content:PROC
EXTRN	_restore_coords:PROC
EXTRN	_save_coords:PROC
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@bfd0000000000000
CONST	SEGMENT
__real@bfd0000000000000 DQ 0bfd0000000000000r	; -0.25
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
CONST	ENDS
;	COMDAT __real@bfe0000000000000
CONST	SEGMENT
__real@bfe0000000000000 DQ 0bfe0000000000000r	; -0.5
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@c000000000000000
CONST	SEGMENT
__real@c000000000000000 DQ 0c000000000000000r	; -2
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _optparamhess
_TEXT	SEGMENT
_ehilo$91018 = -920					; size = 8
_old_rhs_flag$ = -916					; size = 4
_ehihi$91017 = -912					; size = 8
_emid$90957 = -912					; size = 8
_emid$91016 = -904					; size = 8
_eright$90959 = -904					; size = 8
_elohi$91019 = -896					; size = 8
_fake_rhs$ = -892					; size = 4
_eleft$90958 = -888					; size = 8
tv1581 = -884						; size = 4
_g$90960 = -884						; size = 4
_j$ = -880						; size = 4
_temprow$ = -880					; size = 4
_i$ = -876						; size = 4
_elolo$91020 = -872					; size = 8
tv1937 = -868						; size = 4
tv1889 = -868						; size = 4
tv1848 = -868						; size = 4
_gi$91021 = -868					; size = 4
tv1446 = -864						; size = 4
_rhs$GSCopy$ = -864					; size = 4
_dp$91012 = -860					; size = 8
_dp$90956 = -860					; size = 8
_S$GSCopy$ = -852					; size = 4
_gj$91024 = -848					; size = 4
_m$ = -848						; size = 4
_csaved$ = -844						; size = 840
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_rhs$ = 12						; size = 4
_optparamhess PROC					; COMDAT

; 2604 : { int i,j,m;

	push	ebp
	mov	ebp, esp
	sub	esp, 920				; 00000398H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _rhs$[ebp]

; 2605 :   struct oldcoord csaved;
; 2606 :   REAL *fake_rhs;    /* for grad differences */
; 2607 :   REAL *temprow;     /* for accumulating row values */
; 2608 :   struct gen_quant *q;
; 2609 :   int old_rhs_flag = rhs_flag;

	mov	ecx, DWORD PTR _rhs_flag
	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	push	edi

; 2610 : 
; 2611 :   if ( optparamcount <= 0 ) return;

	xor	edi, edi
	mov	DWORD PTR _S$GSCopy$[ebp], esi
	mov	DWORD PTR _rhs$GSCopy$[ebp], eax
	mov	DWORD PTR _old_rhs_flag$[ebp], ecx
	cmp	DWORD PTR _optparamcount, edi
	jle	$LN77@optparamhe

; 2612 :   if ( !everything_quantities_flag ) 

	cmp	DWORD PTR _everything_quantities_flag, edi
	jne	SHORT $LN75@optparamhe

; 2613 :      kb_error(2080,"Hessian for optimizing parameters requires convert_to_quantities.\n",
; 2614 :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0ED@INBDPNCL@Hessian?5for?5optimizing?5parameter@
	push	2080					; 00000820H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN75@optparamhe:

; 2615 : 
; 2616 :   fake_rhs = (REAL*)temp_calloc(S->total_rows,sizeof(REAL));

	mov	edx, DWORD PTR [esi+28]
	push	ebx
	push	2616					; 00000a38H
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	8
	push	edx
	call	_kb_temp_calloc

; 2617 :   temprow  = (REAL*)temp_calloc(S->total_rows,sizeof(REAL));

	push	2617					; 00000a39H
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	mov	DWORD PTR _fake_rhs$[ebp], eax
	mov	eax, DWORD PTR [esi+28]
	push	8
	push	eax
	call	_kb_temp_calloc

; 2618 :   rhs_flag = 1;
; 2619 : 
; 2620 :   csaved.coord = NULL;
; 2621 :   save_coords(&csaved,SAVE_SEPARATE);

	lea	ecx, DWORD PTR _csaved$[ebp]
	push	2
	push	ecx
	mov	DWORD PTR _temprow$[ebp], eax
	mov	DWORD PTR _rhs_flag, 1
	mov	DWORD PTR _csaved$[ebp], edi
	call	_save_coords
	add	esp, 40					; 00000028H

; 2622 :   for ( i = 0 ; i < optparamcount ; i++ )

	mov	DWORD PTR _i$[ebp], edi
	cmp	DWORD PTR _optparamcount, edi
	jle	$LN72@optparamhe

; 2615 : 
; 2616 :   fake_rhs = (REAL*)temp_calloc(S->total_rows,sizeof(REAL));

	mov	edi, OFFSET _optparam+48
	npad	4
$LL74@optparamhe:

; 2623 :   { REAL dp;
; 2624 :     REAL emid = web.total_energy;
; 2625 :     REAL eleft,eright;
; 2626 :     struct global *g = globals(optparam[i].pnum);

	mov	eax, DWORD PTR [edi-48]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN79@optparamhe
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN81@optparamhe
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	mov	esi, eax
	mov	DWORD PTR _g$90960[ebp], eax
	jmp	SHORT $LN80@optparamhe
$LN81@optparamhe:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN79@optparamhe
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN269@optparamhe
$LN79@optparamhe:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	esi, DWORD PTR [eax+ecx]
$LN269@optparamhe:
	mov	DWORD PTR _g$90960[ebp], esi
$LN80@optparamhe:

; 2627 : 
; 2628 :     restore_coords(&csaved,SAVE_SEPARATE);

	lea	edx, DWORD PTR _csaved$[ebp]
	push	2
	push	edx
	call	_restore_coords

; 2629 :     calc_energy(); calc_content(Q_FIXED);

	call	_calc_energy
	push	2
	call	_calc_content
	fstp	ST(0)

; 2630 :     emid = web.total_energy;
; 2631 : 
; 2632 :     dp = g->attr.varstuff.delta;
; 2633 : 
; 2634 :     memset((char*)fake_rhs,0,S->total_rows*sizeof(REAL));

	mov	ebx, DWORD PTR _S$GSCopy$[ebp]
	fld	QWORD PTR _web+1240
	mov	eax, DWORD PTR [ebx+28]
	fstp	QWORD PTR _emid$90957[ebp]
	mov	ecx, DWORD PTR _fake_rhs$[ebp]
	fld	QWORD PTR [esi+168]
	add	eax, eax
	fstp	QWORD PTR _dp$90956[ebp]
	add	eax, eax
	add	eax, eax
	push	eax
	push	0
	push	ecx
	call	_memset

; 2635 :     memset((char*)temprow ,0,S->total_rows*sizeof(REAL));

	mov	edx, DWORD PTR [ebx+28]
	mov	eax, DWORD PTR _temprow$[ebp]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	push	0
	push	eax
	call	_memset

; 2636 : 
; 2637 :     /* for optimizing parameter self hessian */
; 2638 :     for ( m = 0 ; m < gen_quant_count ; m++ )

	xor	ebx, ebx
	add	esp, 36					; 00000024H
	cmp	DWORD PTR _web+5528, ebx
	jle	SHORT $LN202@optparamhe

; 2627 : 
; 2628 :     restore_coords(&csaved,SAVE_SEPARATE);

	mov	ecx, DWORD PTR _gen_quant_list
	xor	esi, esi
	npad	4
$LL71@optparamhe:

; 2639 :     { q = GEN_QUANT(m);
; 2640 :       if ( q->flags & Q_DELETED ) continue;

	mov	eax, DWORD PTR [esi+ecx+136]
	test	eax, 524288				; 00080000H
	jne	SHORT $LN70@optparamhe

; 2641 :       if ( q->flags & Q_FIXED )

	test	al, 2
	je	SHORT $LN70@optparamhe

; 2642 :       { sp_hash_search(S,optparam[i].rownum,optparam[i].rownum,
; 2643 :             -q->pressure*( - 2*q->value )/dp/dp);

	fld	QWORD PTR [esi+ecx+152]
	mov	eax, DWORD PTR [edi]
	fmul	QWORD PTR __real@c000000000000000
	sub	esp, 8
	fmul	QWORD PTR [esi+ecx+192]
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	fld	QWORD PTR _dp$90956[ebp]
	fdiv	ST(1), ST(0)
	fdivp	ST(1), ST(0)
	fchs
	fstp	QWORD PTR [esp]
	push	eax
	push	eax
	push	ecx
	call	_sp_hash_search
	mov	ecx, DWORD PTR _gen_quant_list
	add	esp, 20					; 00000014H
$LN70@optparamhe:

; 2636 : 
; 2637 :     /* for optimizing parameter self hessian */
; 2638 :     for ( m = 0 ; m < gen_quant_count ; m++ )

	inc	ebx
	add	esi, 368				; 00000170H
	cmp	ebx, DWORD PTR _web+5528
	jl	SHORT $LL71@optparamhe
	mov	esi, DWORD PTR _g$90960[ebp]
$LN202@optparamhe:

; 2644 :       }             
; 2645 :     }
; 2646 : 
; 2647 :     /* right difference */
; 2648 :     g->value.real += dp;

	fld	QWORD PTR [esi+64]

; 2649 :     if ( g->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [esi+188]
	fadd	QWORD PTR _dp$90956[ebp]
	fstp	QWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN66@optparamhe

; 2650 :     { struct  global *gg = globals(g->attr.varstuff.on_assign_call);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN85@optparamhe
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN87@optparamhe
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN86@optparamhe
$LN87@optparamhe:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN85@optparamhe
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN86@optparamhe
$LN85@optparamhe:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN86@optparamhe:

; 2651 :       eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	add	esp, 16					; 00000010H
$LN66@optparamhe:

; 2652 :     }
; 2653 :     project_all(0, TEST_MOVE);

	push	0
	push	0
	call	_project_all
	add	esp, 8

; 2654 :     if ( fixed_constraint_flag || web.pressure_flag || web.pressflag )

	cmp	DWORD PTR _fixed_constraint_flag, 0
	jne	SHORT $LN64@optparamhe
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN64@optparamhe
	cmp	DWORD PTR _web+844, 0
	je	SHORT $LN65@optparamhe
$LN64@optparamhe:

; 2655 :         calc_content(Q_FIXED);

	push	2
	call	_calc_content
	fstp	ST(0)
	add	esp, 4
$LN65@optparamhe:

; 2656 :     calc_energy();  /* energy after motion */

	call	_calc_energy

; 2657 :     calc_quant_hess(S,1,0,temprow);

	mov	edx, DWORD PTR _temprow$[ebp]
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	push	edx
	push	0
	push	1
	push	eax
	call	_calc_quant_hess

; 2658 :     eright = web.total_energy;

	fld	QWORD PTR _web+1240

; 2659 :     calc_volgrads(NO_OPTS); /* global constraint hessians */

	push	0
	fstp	QWORD PTR _eright$90959[ebp]
	call	_calc_volgrads
	add	esp, 20					; 00000014H

; 2660 : 
; 2661 :     /* for global constraints */
; 2662 :     for ( m = 0 ; m < gen_quant_count ; m++ )

	cmp	DWORD PTR _web+5528, 0
	mov	DWORD PTR _m$[ebp], 0
	jle	$LN61@optparamhe

; 2656 :     calc_energy();  /* energy after motion */

	mov	eax, DWORD PTR _gen_quant_list
	fld	QWORD PTR _dp$90956[ebp]
	mov	DWORD PTR tv1848[ebp], 0
$LN63@optparamhe:

; 2663 :     { q = GEN_QUANT(m);
; 2664 :       if ( q->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR tv1848[ebp]
	mov	ecx, DWORD PTR [ecx+eax+136]
	test	ecx, 524288				; 00080000H
	jne	$LN62@optparamhe

; 2665 :       if ( q->flags & Q_FIXED )

	test	cl, 2
	je	$LN62@optparamhe

; 2666 :       { sp_hash_search(S,optparam[i].rownum,optparam[i].rownum,
; 2667 :             -q->pressure*( q->value )/dp/dp);

	mov	esi, DWORD PTR tv1848[ebp]
	fld	QWORD PTR [esi+eax+192]
	lea	ebx, DWORD PTR [esi+eax+192]
	fmul	QWORD PTR [esi+eax+152]
	lea	esi, DWORD PTR [esi+eax+152]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	fdiv	ST(0), ST(1)
	sub	esp, 8
	fdivrp	ST(1), ST(0)
	fchs
	fstp	QWORD PTR [esp]
	push	eax
	push	eax
	push	edx
	call	_sp_hash_search

; 2668 :         sp_hash_search(S,optparam[i].rownum,S->quanrowstart+m,
; 2669 :              q->value/dp/2);

	fld	QWORD PTR [esi]
	fdiv	QWORD PTR _dp$90956[ebp]
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [edi]
	add	esp, 12					; 0000000cH
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [esp]
	push	ecx
	push	edx
	push	eax
	call	_sp_hash_search
	add	esp, 20					; 00000014H

; 2670 :          if ( rhs ) rhs[optparam[i].rownum] += q->pressure*q->value/dp/2;

	cmp	DWORD PTR _rhs$GSCopy$[ebp], 0
	je	SHORT $LN197@optparamhe
	fld	QWORD PTR [ebx]
	mov	eax, DWORD PTR [edi]
	fmul	QWORD PTR [esi]
	mov	ecx, DWORD PTR _rhs$GSCopy$[ebp]
	fld	QWORD PTR _dp$90956[ebp]
	lea	eax, DWORD PTR [ecx+eax*8]
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@3fe0000000000000
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	jmp	SHORT $LN270@optparamhe
$LN197@optparamhe:
	fld	QWORD PTR _dp$90956[ebp]
$LN270@optparamhe:
	mov	eax, DWORD PTR _gen_quant_list
$LN62@optparamhe:

; 2660 : 
; 2661 :     /* for global constraints */
; 2662 :     for ( m = 0 ; m < gen_quant_count ; m++ )

	mov	ecx, DWORD PTR _m$[ebp]
	add	DWORD PTR tv1848[ebp], 368		; 00000170H
	inc	ecx
	mov	DWORD PTR _m$[ebp], ecx
	cmp	ecx, DWORD PTR _web+5528
	jl	$LN63@optparamhe
	fstp	ST(0)
$LN61@optparamhe:

; 2671 :       } 
; 2672 :     }
; 2673 :     restore_coords(&csaved,SAVE_SEPARATE);  /* also restores opt params */

	lea	edx, DWORD PTR _csaved$[ebp]
	push	2
	push	edx
	call	_restore_coords

; 2674 : 
; 2675 :     /* left difference */
; 2676 :     g->value.real -= dp;

	mov	eax, DWORD PTR _g$90960[ebp]
	fld	QWORD PTR [eax+64]
	add	esp, 8
	fsub	QWORD PTR _dp$90956[ebp]
	fstp	QWORD PTR [eax+64]

; 2677 :     if ( g->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [eax+188]
	test	eax, eax
	je	SHORT $LN57@optparamhe

; 2678 :     { struct  global *gg = globals(g->attr.varstuff.on_assign_call);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN91@optparamhe
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN93@optparamhe
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN92@optparamhe
$LN93@optparamhe:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN91@optparamhe
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN92@optparamhe
$LN91@optparamhe:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN92@optparamhe:

; 2679 :       eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	add	esp, 16					; 00000010H
$LN57@optparamhe:

; 2680 :     }
; 2681 :     project_all(0, TEST_MOVE);

	push	0
	push	0
	call	_project_all
	add	esp, 8

; 2682 :     if ( fixed_constraint_flag || web.pressure_flag || web.pressflag )

	cmp	DWORD PTR _fixed_constraint_flag, 0
	jne	SHORT $LN55@optparamhe
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN55@optparamhe
	cmp	DWORD PTR _web+844, 0
	je	SHORT $LN56@optparamhe
$LN55@optparamhe:

; 2683 :         calc_content(Q_FIXED);

	push	2
	call	_calc_content
	fstp	ST(0)
	add	esp, 4
$LN56@optparamhe:

; 2684 :     calc_energy();  /* energy after motion */

	call	_calc_energy

; 2685 :     calc_quant_hess(S,1,0,fake_rhs);

	mov	ecx, DWORD PTR _fake_rhs$[ebp]
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	push	ecx
	push	0
	push	1
	push	edx
	call	_calc_quant_hess

; 2686 :     eleft = web.total_energy;

	fld	QWORD PTR _web+1240

; 2687 :     calc_volgrads(NO_OPTS); /* global constraint hessians */

	push	0
	fstp	QWORD PTR _eleft$90958[ebp]
	call	_calc_volgrads
	add	esp, 20					; 00000014H

; 2688 : 
; 2689 :     /* for global constraints */
; 2690 :     for ( m = 0 ; m < gen_quant_count ; m++ )

	cmp	DWORD PTR _web+5528, 0
	mov	DWORD PTR _m$[ebp], 0
	jle	$LN52@optparamhe

; 2684 :     calc_energy();  /* energy after motion */

	mov	eax, DWORD PTR _gen_quant_list
	fld	QWORD PTR _dp$90956[ebp]
	mov	DWORD PTR tv1889[ebp], 0
$LN54@optparamhe:

; 2691 :     { q = GEN_QUANT(m);
; 2692 :       if ( q->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR tv1889[ebp]
	mov	ecx, DWORD PTR [ecx+eax+136]
	test	ecx, 524288				; 00080000H
	jne	$LN53@optparamhe

; 2693 :       if ( q->flags & Q_FIXED )

	test	cl, 2
	je	$LN53@optparamhe

; 2694 :       { sp_hash_search(S,optparam[i].rownum,optparam[i].rownum,
; 2695 :             -q->pressure*( q->value )/dp/dp);

	mov	esi, DWORD PTR tv1889[ebp]
	fld	QWORD PTR [esi+eax+192]
	lea	ebx, DWORD PTR [esi+eax+192]
	fmul	QWORD PTR [esi+eax+152]
	lea	esi, DWORD PTR [esi+eax+152]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	fdiv	ST(0), ST(1)
	sub	esp, 8
	fdivrp	ST(1), ST(0)
	fchs
	fstp	QWORD PTR [esp]
	push	eax
	push	eax
	push	edx
	call	_sp_hash_search

; 2696 :         sp_hash_search(S,optparam[i].rownum,S->quanrowstart+m,
; 2697 :              -q->value/dp/2);

	fld	QWORD PTR [esi]
	fdiv	QWORD PTR _dp$90956[ebp]
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _m$[ebp]
	mov	edx, DWORD PTR [edi]
	add	esp, 12					; 0000000cH
	fmul	QWORD PTR __real@bfe0000000000000
	fstp	QWORD PTR [esp]
	push	ecx
	push	edx
	push	eax
	call	_sp_hash_search
	add	esp, 20					; 00000014H

; 2698 :          if ( rhs )  rhs[optparam[i].rownum] -= q->pressure*q->value/dp/2;

	cmp	DWORD PTR _rhs$GSCopy$[ebp], 0
	je	SHORT $LN198@optparamhe
	fld	QWORD PTR [ebx]
	mov	eax, DWORD PTR [edi]
	fmul	QWORD PTR [esi]
	mov	ecx, DWORD PTR _rhs$GSCopy$[ebp]
	fld	QWORD PTR _dp$90956[ebp]
	lea	eax, DWORD PTR [ecx+eax*8]
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@3fe0000000000000
	fsubr	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	jmp	SHORT $LN271@optparamhe
$LN198@optparamhe:
	fld	QWORD PTR _dp$90956[ebp]
$LN271@optparamhe:
	mov	eax, DWORD PTR _gen_quant_list
$LN53@optparamhe:

; 2688 : 
; 2689 :     /* for global constraints */
; 2690 :     for ( m = 0 ; m < gen_quant_count ; m++ )

	mov	ecx, DWORD PTR _m$[ebp]
	add	DWORD PTR tv1889[ebp], 368		; 00000170H
	inc	ecx
	mov	DWORD PTR _m$[ebp], ecx
	cmp	ecx, DWORD PTR _web+5528
	jl	$LN54@optparamhe
	fstp	ST(0)
$LN52@optparamhe:

; 2699 :       } 
; 2700 :     }
; 2701 :  
; 2702 :     vgrad_end();

	call	_vgrad_end

; 2703 :     restore_coords(&csaved,SAVE_SEPARATE);  /* also restores opt params */

	lea	edx, DWORD PTR _csaved$[ebp]
	push	2
	push	edx
	call	_restore_coords

; 2704 :     web.total_energy = emid; /* restore */

	fld	QWORD PTR _emid$90957[ebp]

; 2705 : 
; 2706 :     if ( rhs )

	mov	eax, DWORD PTR _rhs$GSCopy$[ebp]
	fstp	QWORD PTR _web+1240
	add	esp, 8
	test	eax, eax
	je	SHORT $LN199@optparamhe

; 2707 :       rhs[optparam[i].rownum] += -(eright - eleft)/2/dp; /* rhs is neg grad */

	fld	QWORD PTR _eright$90959[ebp]
	mov	ecx, DWORD PTR [edi]
	fsub	QWORD PTR _eleft$90958[ebp]
	lea	eax, DWORD PTR [eax+ecx*8]
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _dp$90956[ebp]
	fsubr	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
$LN199@optparamhe:

; 2708 : 
; 2709 :     /* vertex-param cross terms */
; 2710 :     for ( j = 0 ; j < vertex_rows ; j++ )

	xor	ebx, ebx
	cmp	DWORD PTR _vertex_rows, ebx
	jle	SHORT $LN45@optparamhe
	mov	esi, DWORD PTR _temprow$[ebp]
	mov	eax, DWORD PTR _fake_rhs$[ebp]
	sub	eax, esi
	mov	DWORD PTR tv1937[ebp], eax
	jmp	SHORT $LN47@optparamhe
$LL200@optparamhe:
	mov	eax, DWORD PTR tv1937[ebp]
$LN47@optparamhe:

; 2711 :       sp_hash_search(S,j,optparam[i].rownum,(fake_rhs[j]-temprow[j])/2/dp);

	fld	QWORD PTR [eax+esi]
	mov	edx, DWORD PTR [edi]
	fsub	QWORD PTR [esi]
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	sub	esp, 8
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _dp$90956[ebp]
	fstp	QWORD PTR [esp]
	push	edx
	push	ebx
	push	eax
	call	_sp_hash_search
	inc	ebx
	add	esp, 20					; 00000014H
	add	esi, 8
	cmp	ebx, DWORD PTR _vertex_rows
	jl	SHORT $LL200@optparamhe
$LN45@optparamhe:

; 2712 :     sp_hash_search(S,optparam[i].rownum,optparam[i].rownum,
; 2713 :             (eright - 2*emid + eleft)/dp/dp);

	fld	QWORD PTR _emid$90957[ebp]
	mov	eax, DWORD PTR [edi]
	fadd	ST(0), ST(0)
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	sub	esp, 8
	fsubr	QWORD PTR _eright$90959[ebp]
	fadd	QWORD PTR _eleft$90958[ebp]
	fld	QWORD PTR _dp$90956[ebp]
	fdiv	ST(1), ST(0)
	fdivp	ST(1), ST(0)
	fstp	QWORD PTR [esp]
	push	eax
	push	eax
	push	ecx
	call	_sp_hash_search
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	esp, 20					; 00000014H
	add	edi, 56					; 00000038H
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _optparamcount
	jl	$LL74@optparamhe
$LN72@optparamhe:

; 2714 :   }
; 2715 :   temp_free((char*)fake_rhs);

	mov	edx, DWORD PTR _fake_rhs$[ebp]
	push	edx
	call	_temp_free

; 2716 :   temp_free((char*)temprow);

	mov	eax, DWORD PTR _temprow$[ebp]
	push	eax
	call	_temp_free

; 2717 :   rhs_flag = old_rhs_flag;

	mov	ecx, DWORD PTR _old_rhs_flag$[ebp]
	add	esp, 8

; 2718 : 
; 2719 :   /* optimizing parameter mixed terms */
; 2720 :   for ( i = 0 ; i < optparamcount ; i++ )

	cmp	DWORD PTR _optparamcount, 0
	mov	DWORD PTR _rhs_flag, ecx
	mov	DWORD PTR _i$[ebp], 0
	jle	$LN42@optparamhe
	fld	QWORD PTR __real@3f50624dd2f1a9fc
$LN203@optparamhe:

; 2721 :     for ( j = 0 ; j < i ; j++ )

	cmp	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	jle	$LN43@optparamhe
	mov	ecx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	add	eax, eax
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1446[ebp], eax
	npad	8
$LL41@optparamhe:

; 2722 :       { REAL dp;
; 2723 :         REAL vmid = globals(optparam[i].pnum)->value.real;

	mov	edx, DWORD PTR tv1446[ebp]
	mov	eax, DWORD PTR _optparam[edx]
	mov	esi, DWORD PTR _web+5652
	mov	edi, DWORD PTR _dymem
	mov	ebx, DWORD PTR _web+5656
	mov	edx, eax
	and	edx, -16777216				; ff000000H
	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN97@optparamhe
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN99@optparamhe
	mov	ebx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 5
	add	ecx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR _web+5656
	jmp	SHORT $LN98@optparamhe
$LN99@optparamhe:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN97@optparamhe
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [ebx+eax*4]
	jmp	SHORT $LN98@optparamhe
$LN97@optparamhe:
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [esi+eax*4]
	mov	ecx, DWORD PTR [ecx+edi]
$LN98@optparamhe:
	fld	QWORD PTR [ecx+64]

; 2724 :         REAL emid = web.total_energy;

	fld	QWORD PTR _web+1240
	fstp	QWORD PTR _emid$91016[ebp]

; 2725 :         REAL ehihi,ehilo,elohi,elolo;
; 2726 :         struct global *gi = globals(optparam[i].pnum);

	cmp	edx, 268435456				; 10000000H
	jne	SHORT $LN107@optparamhe
	lea	edx, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [edx+edi]
	mov	DWORD PTR _gi$91021[ebp], eax
	jmp	SHORT $LN104@optparamhe
$LN107@optparamhe:
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN105@optparamhe
	mov	edx, DWORD PTR _localbase
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 5
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR _gi$91021[ebp], ecx
	jmp	SHORT $LN104@optparamhe
$LN105@optparamhe:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN103@optparamhe
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR _gi$91021[ebp], eax
	jmp	SHORT $LN104@optparamhe
$LN103@optparamhe:
	lea	ecx, DWORD PTR [esi+eax*4]
	mov	edx, DWORD PTR [ecx+edi]
	mov	DWORD PTR _gi$91021[ebp], edx
$LN104@optparamhe:

; 2727 :         struct global *gj = globals(optparam[j].pnum);

	mov	ecx, DWORD PTR _j$[ebp]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	add	eax, eax
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1581[ebp], eax
	mov	eax, DWORD PTR _optparam[eax]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN109@optparamhe
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN111@optparamhe
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 5
	add	ecx, DWORD PTR [edx]
	jmp	SHORT $LN272@optparamhe
$LN111@optparamhe:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN109@optparamhe
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR _gj$91024[ebp], esi
	jmp	SHORT $LN110@optparamhe
$LN109@optparamhe:
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [esi+eax*4]
	mov	ecx, DWORD PTR [eax+edi]
$LN272@optparamhe:
	mov	DWORD PTR _gj$91024[ebp], ecx
	mov	esi, ecx
$LN110@optparamhe:

; 2728 : 
; 2729 :         if ( fabs(vmid) > 1. ) dp = fabs(vmid)*1e-3;

	fabs
	fld1
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN244@optparamhe
	fmulp	ST(1), ST(0)
	jmp	SHORT $LN273@optparamhe
$LN244@optparamhe:
	fstp	ST(0)
$LN273@optparamhe:

; 2730 :         else dp = 1e-3;
; 2731 : 
; 2732 :         /* + + difference */
; 2733 :         gi->value.real += dp;

	mov	eax, DWORD PTR _gi$91021[ebp]
	fst	QWORD PTR _dp$91012[ebp]
	fld	QWORD PTR [eax+64]
	fadd	ST(0), ST(1)
	fstp	QWORD PTR [eax+64]

; 2734 :         if ( gi->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [eax+188]
	test	eax, eax
	je	$LN36@optparamhe

; 2735 :         { struct  global *gg = globals(gi->attr.varstuff.on_assign_call);

	mov	ecx, eax
	fstp	ST(0)
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN115@optparamhe
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN117@optparamhe
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 5
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN116@optparamhe
$LN117@optparamhe:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN115@optparamhe
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN116@optparamhe
$LN115@optparamhe:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN116@optparamhe:

; 2736 :           eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	fld	QWORD PTR _dp$91012[ebp]
	add	esp, 16					; 00000010H
$LN36@optparamhe:

; 2737 :         }
; 2738 :         gj->value.real += dp;

	fadd	QWORD PTR [esi+64]

; 2739 :         if ( gj->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [esi+188]
	fstp	QWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN35@optparamhe

; 2740 :         { struct  global *gg = globals(gj->attr.varstuff.on_assign_call);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN121@optparamhe
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN123@optparamhe
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 5
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN122@optparamhe
$LN123@optparamhe:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN121@optparamhe
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN122@optparamhe
$LN121@optparamhe:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN122@optparamhe:

; 2741 :           eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	add	esp, 16					; 00000010H
$LN35@optparamhe:

; 2742 :         }
; 2743 :         project_all(0, TEST_MOVE);

	push	0
	push	0
	call	_project_all
	add	esp, 8

; 2744 :         if ( fixed_constraint_flag || web.pressure_flag || web.pressflag )

	cmp	DWORD PTR _fixed_constraint_flag, 0
	jne	SHORT $LN33@optparamhe
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN33@optparamhe
	cmp	DWORD PTR _web+844, 0
	je	SHORT $LN204@optparamhe
$LN33@optparamhe:

; 2745 :             calc_content(Q_FIXED);

	push	2
	call	_calc_content
	fstp	ST(0)
	add	esp, 4
$LN204@optparamhe:

; 2746 :         calc_energy();  /* energy after motion */

	call	_calc_energy

; 2747 :         ehihi = web.total_energy;

	fld	QWORD PTR _web+1240

; 2748 :         for ( m = 0 ; m < gen_quant_count ; m++ )

	xor	edi, edi
	fstp	QWORD PTR _ehihi$91017[ebp]
	cmp	DWORD PTR _web+5528, edi
	jle	$LN205@optparamhe

; 2746 :         calc_energy();  /* energy after motion */

	mov	eax, DWORD PTR _gen_quant_list
	mov	ebx, DWORD PTR tv1581[ebp]
	xor	esi, esi
	npad	9
$LL32@optparamhe:

; 2749 :         { q = GEN_QUANT(m);
; 2750 :           if ( q->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [esi+eax+136]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN31@optparamhe

; 2751 :           if ( q->flags & Q_FIXED )

	test	cl, 2
	je	SHORT $LN31@optparamhe

; 2752 :              sp_hash_search(S,optparam[j].rownum,optparam[i].rownum,
; 2753 :                 -q->pressure*( q->value )/dp/dp/4);

	fld	QWORD PTR [esi+eax+192]
	mov	edx, DWORD PTR tv1446[ebp]
	fmul	QWORD PTR [esi+eax+152]
	mov	eax, DWORD PTR _optparam[edx+48]
	fld	QWORD PTR _dp$91012[ebp]
	mov	ecx, DWORD PTR _optparam[ebx+48]
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	fdiv	ST(1), ST(0)
	sub	esp, 8
	fdivp	ST(1), ST(0)
	fmul	QWORD PTR __real@bfd0000000000000
	fstp	QWORD PTR [esp]
	push	eax
	push	ecx
	push	edx
	call	_sp_hash_search
	mov	eax, DWORD PTR _gen_quant_list
	add	esp, 20					; 00000014H
$LN31@optparamhe:

; 2748 :         for ( m = 0 ; m < gen_quant_count ; m++ )

	inc	edi
	add	esi, 368				; 00000170H
	cmp	edi, DWORD PTR _web+5528
	jl	SHORT $LL32@optparamhe
	mov	esi, DWORD PTR _gj$91024[ebp]
$LN205@optparamhe:

; 2754 :         } 
; 2755 :         restore_coords(&csaved,SAVE_SEPARATE);  /* also restores opt params */

	lea	eax, DWORD PTR _csaved$[ebp]
	push	2
	push	eax
	call	_restore_coords

; 2756 : 
; 2757 :         /* + - difference */
; 2758 :         gi->value.real += dp;

	mov	ebx, DWORD PTR _gi$91021[ebp]
	fld	QWORD PTR [ebx+64]

; 2759 :         if ( gi->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [ebx+188]
	fadd	QWORD PTR _dp$91012[ebp]
	add	esp, 8
	fstp	QWORD PTR [ebx+64]
	test	eax, eax
	je	SHORT $LN206@optparamhe

; 2760 :         { struct  global *gg = globals(gi->attr.varstuff.on_assign_call);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN127@optparamhe
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN129@optparamhe
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _localbase
	shl	eax, 5
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN128@optparamhe
$LN129@optparamhe:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN127@optparamhe
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN128@optparamhe
$LN127@optparamhe:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN128@optparamhe:

; 2761 :           eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	add	esp, 16					; 00000010H
$LN206@optparamhe:

; 2762 :         }
; 2763 :         gj->value.real -= dp;

	fld	QWORD PTR [esi+64]

; 2764 :         if ( gj->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [esi+188]
	fsub	QWORD PTR _dp$91012[ebp]
	fstp	QWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN26@optparamhe

; 2765 :         { struct  global *gg = globals(gj->attr.varstuff.on_assign_call);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN133@optparamhe
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN135@optparamhe
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _localbase
	shl	eax, 5
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN134@optparamhe
$LN135@optparamhe:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN133@optparamhe
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN134@optparamhe
$LN133@optparamhe:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN134@optparamhe:

; 2766 :           eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	add	esp, 16					; 00000010H
$LN26@optparamhe:

; 2767 :         }
; 2768 :         project_all(0, TEST_MOVE);

	push	0
	push	0
	call	_project_all
	add	esp, 8

; 2769 :         if ( fixed_constraint_flag || web.pressure_flag || web.pressflag )

	cmp	DWORD PTR _fixed_constraint_flag, 0
	jne	SHORT $LN24@optparamhe
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN24@optparamhe
	cmp	DWORD PTR _web+844, 0
	je	SHORT $LN25@optparamhe
$LN24@optparamhe:

; 2770 :             calc_content(Q_FIXED);

	push	2
	call	_calc_content
	fstp	ST(0)
	add	esp, 4
$LN25@optparamhe:

; 2771 :         calc_energy();  /* energy after motion */

	call	_calc_energy

; 2772 :         ehilo = web.total_energy;

	fld	QWORD PTR _web+1240

; 2773 :         for ( m = 0 ; m < gen_quant_count ; m++ )

	xor	edi, edi
	fstp	QWORD PTR _ehilo$91018[ebp]
	cmp	DWORD PTR _web+5528, edi
	jle	$LN208@optparamhe

; 2771 :         calc_energy();  /* energy after motion */

	mov	eax, DWORD PTR _gen_quant_list
	xor	esi, esi
	npad	1
$LL23@optparamhe:

; 2774 :         { q = GEN_QUANT(m);
; 2775 :           if ( q->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [esi+eax+136]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN22@optparamhe

; 2776 :           if ( q->flags & Q_FIXED )

	test	cl, 2
	je	SHORT $LN22@optparamhe

; 2777 :              sp_hash_search(S,optparam[j].rownum,optparam[i].rownum,
; 2778 :                 -q->pressure*(-q->value )/dp/dp/4);

	fld	QWORD PTR [esi+eax+152]
	mov	ecx, DWORD PTR tv1446[ebp]
	fchs
	mov	edx, DWORD PTR _optparam[ecx+48]
	fmul	QWORD PTR [esi+eax+192]
	mov	eax, DWORD PTR tv1581[ebp]
	fld	QWORD PTR _dp$91012[ebp]
	mov	ecx, DWORD PTR _optparam[eax+48]
	sub	esp, 8
	fdiv	ST(1), ST(0)
	fdivp	ST(1), ST(0)
	fmul	QWORD PTR __real@bfd0000000000000
	fstp	QWORD PTR [esp]
	push	edx
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	push	ecx
	push	edx
	call	_sp_hash_search
	mov	eax, DWORD PTR _gen_quant_list
	add	esp, 20					; 00000014H
$LN22@optparamhe:

; 2773 :         for ( m = 0 ; m < gen_quant_count ; m++ )

	inc	edi
	add	esi, 368				; 00000170H
	cmp	edi, DWORD PTR _web+5528
	jl	SHORT $LL23@optparamhe
	mov	esi, DWORD PTR _gj$91024[ebp]
$LN208@optparamhe:

; 2779 :         }
; 2780 :         restore_coords(&csaved,SAVE_SEPARATE);  /* also restores opt params */

	lea	eax, DWORD PTR _csaved$[ebp]
	push	2
	push	eax
	call	_restore_coords

; 2781 : 
; 2782 :         /* - + difference */
; 2783 :         gi->value.real -= dp;

	fld	QWORD PTR [ebx+64]
	fsub	QWORD PTR _dp$91012[ebp]

; 2784 :         if ( gi->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [ebx+188]
	add	esp, 8
	fstp	QWORD PTR [ebx+64]
	test	eax, eax
	je	SHORT $LN210@optparamhe

; 2785 :         { struct  global *gg = globals(gi->attr.varstuff.on_assign_call);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN139@optparamhe
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN141@optparamhe
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _localbase
	shl	eax, 5
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN140@optparamhe
$LN141@optparamhe:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN139@optparamhe
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN140@optparamhe
$LN139@optparamhe:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN140@optparamhe:

; 2786 :           eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	add	esp, 16					; 00000010H
$LN210@optparamhe:

; 2787 :         }
; 2788 :         gj->value.real += dp;

	fld	QWORD PTR [esi+64]

; 2789 :         if ( gj->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [esi+188]
	fadd	QWORD PTR _dp$91012[ebp]
	fstp	QWORD PTR [esi+64]
	test	eax, eax
	je	SHORT $LN17@optparamhe

; 2790 :         { struct  global *gg = globals(gj->attr.varstuff.on_assign_call);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN145@optparamhe
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN147@optparamhe
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _localbase
	shl	eax, 5
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN146@optparamhe
$LN147@optparamhe:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN145@optparamhe
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN146@optparamhe
$LN145@optparamhe:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN146@optparamhe:

; 2791 :           eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	add	esp, 16					; 00000010H
$LN17@optparamhe:

; 2792 :         }
; 2793 :         project_all(0, TEST_MOVE);

	push	0
	push	0
	call	_project_all
	add	esp, 8

; 2794 :         if ( fixed_constraint_flag || web.pressure_flag || web.pressflag )

	cmp	DWORD PTR _fixed_constraint_flag, 0
	jne	SHORT $LN15@optparamhe
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN15@optparamhe
	cmp	DWORD PTR _web+844, 0
	je	SHORT $LN16@optparamhe
$LN15@optparamhe:

; 2795 :             calc_content(Q_FIXED);

	push	2
	call	_calc_content
	fstp	ST(0)
	add	esp, 4
$LN16@optparamhe:

; 2796 :         calc_energy();  /* energy after motion */

	call	_calc_energy

; 2797 :         elohi = web.total_energy;

	fld	QWORD PTR _web+1240

; 2798 :         for ( m = 0 ; m < gen_quant_count ; m++ )

	xor	edi, edi
	fstp	QWORD PTR _elohi$91019[ebp]
	cmp	DWORD PTR _web+5528, edi
	jle	$LN209@optparamhe

; 2796 :         calc_energy();  /* energy after motion */

	mov	eax, DWORD PTR _gen_quant_list
	xor	esi, esi
$LL14@optparamhe:

; 2799 :         { q = GEN_QUANT(m);
; 2800 :           if ( q->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [esi+eax+136]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN13@optparamhe

; 2801 :           if ( q->flags & Q_FIXED )

	test	cl, 2
	je	SHORT $LN13@optparamhe

; 2802 :              sp_hash_search(S,optparam[j].rownum,optparam[i].rownum,
; 2803 :                 -q->pressure*(-q->value )/dp/dp/4);

	fld	QWORD PTR [esi+eax+152]
	mov	ecx, DWORD PTR tv1446[ebp]
	fchs
	mov	edx, DWORD PTR _optparam[ecx+48]
	fmul	QWORD PTR [esi+eax+192]
	mov	eax, DWORD PTR tv1581[ebp]
	fld	QWORD PTR _dp$91012[ebp]
	mov	ecx, DWORD PTR _optparam[eax+48]
	sub	esp, 8
	fdiv	ST(1), ST(0)
	fdivp	ST(1), ST(0)
	fmul	QWORD PTR __real@bfd0000000000000
	fstp	QWORD PTR [esp]
	push	edx
	mov	edx, DWORD PTR _S$GSCopy$[ebp]
	push	ecx
	push	edx
	call	_sp_hash_search
	mov	eax, DWORD PTR _gen_quant_list
	add	esp, 20					; 00000014H
$LN13@optparamhe:

; 2798 :         for ( m = 0 ; m < gen_quant_count ; m++ )

	inc	edi
	add	esi, 368				; 00000170H
	cmp	edi, DWORD PTR _web+5528
	jl	SHORT $LL14@optparamhe
	mov	esi, DWORD PTR _gj$91024[ebp]
$LN209@optparamhe:

; 2804 :         }
; 2805 :         restore_coords(&csaved,SAVE_SEPARATE);  /* also restores opt params */

	lea	eax, DWORD PTR _csaved$[ebp]
	push	2
	push	eax
	call	_restore_coords

; 2806 : 
; 2807 :         /* - - difference */
; 2808 :         globals(optparam[i].pnum)->value.real -= dp;

	mov	ecx, DWORD PTR tv1446[ebp]
	mov	eax, DWORD PTR _optparam[ecx]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 8
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN151@optparamhe
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN153@optparamhe
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 5
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN152@optparamhe
$LN153@optparamhe:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN151@optparamhe
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN152@optparamhe
$LN151@optparamhe:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN152@optparamhe:
	fld	QWORD PTR [eax+64]
	fsub	QWORD PTR _dp$91012[ebp]
	fstp	QWORD PTR [eax+64]

; 2809 :         if ( gi->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [ebx+188]
	test	eax, eax
	je	SHORT $LN211@optparamhe

; 2810 :         { struct  global *gg = globals(gi->attr.varstuff.on_assign_call);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN157@optparamhe
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN159@optparamhe
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 5
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN158@optparamhe
$LN159@optparamhe:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN157@optparamhe
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN158@optparamhe
$LN157@optparamhe:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN158@optparamhe:

; 2811 :           eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	add	esp, 16					; 00000010H
$LN211@optparamhe:

; 2812 :         }
; 2813 :         globals(optparam[j].pnum)->value.real -= dp;

	mov	edx, DWORD PTR tv1581[ebp]
	mov	eax, DWORD PTR _optparam[edx]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN163@optparamhe
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN165@optparamhe
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _localbase
	shl	eax, 5
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN164@optparamhe
$LN165@optparamhe:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN163@optparamhe
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN164@optparamhe
$LN163@optparamhe:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN164@optparamhe:
	fld	QWORD PTR [eax+64]
	fsub	QWORD PTR _dp$91012[ebp]
	fstp	QWORD PTR [eax+64]

; 2814 :         if ( gj->attr.varstuff.on_assign_call )

	mov	eax, DWORD PTR [esi+188]
	test	eax, eax
	je	SHORT $LN8@optparamhe

; 2815 :         { struct  global *gg = globals(gj->attr.varstuff.on_assign_call);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN169@optparamhe
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN171@optparamhe
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _localbase
	shl	eax, 5
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN170@optparamhe
$LN171@optparamhe:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN169@optparamhe
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN170@optparamhe
$LN169@optparamhe:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN170@optparamhe:

; 2816 :           eval(&gg->value.proc,NULL,NULLID,NULL);

	push	0
	push	0
	add	eax, 64					; 00000040H
	push	0
	push	eax
	call	_eval
	fstp	ST(0)
	add	esp, 16					; 00000010H
$LN8@optparamhe:

; 2817 :         }
; 2818 :         project_all(0, TEST_MOVE);

	push	0
	push	0
	call	_project_all
	add	esp, 8

; 2819 :         if ( fixed_constraint_flag || web.pressure_flag || web.pressflag )

	cmp	DWORD PTR _fixed_constraint_flag, 0
	jne	SHORT $LN6@optparamhe
	cmp	DWORD PTR _web+868, 0
	jne	SHORT $LN6@optparamhe
	cmp	DWORD PTR _web+844, 0
	je	SHORT $LN7@optparamhe
$LN6@optparamhe:

; 2820 :             calc_content(Q_FIXED);

	push	2
	call	_calc_content
	fstp	ST(0)
	add	esp, 4
$LN7@optparamhe:

; 2821 :         calc_energy();  /* energy after motion */

	call	_calc_energy

; 2822 :         elolo = web.total_energy;

	fld	QWORD PTR _web+1240
	mov	ebx, DWORD PTR tv1581[ebp]
	fstp	QWORD PTR _elolo$91020[ebp]

; 2823 :         for ( m = 0 ; m < gen_quant_count ; m++ )

	xor	edi, edi
	cmp	DWORD PTR _web+5528, edi
	jle	$LN3@optparamhe

; 2821 :         calc_energy();  /* energy after motion */

	mov	eax, DWORD PTR _gen_quant_list
	xor	esi, esi
	npad	8
$LL5@optparamhe:

; 2824 :         { q = GEN_QUANT(m);
; 2825 :           if ( q->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [esi+eax+136]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN4@optparamhe

; 2826 :           if ( q->flags & Q_FIXED )

	test	cl, 2
	je	SHORT $LN4@optparamhe

; 2827 :              sp_hash_search(S,optparam[j].rownum,optparam[i].rownum,
; 2828 :                 -q->pressure*( q->value )/dp/dp/4);

	fld	QWORD PTR [esi+eax+192]
	mov	ecx, DWORD PTR tv1446[ebp]
	fmul	QWORD PTR [esi+eax+152]
	mov	edx, DWORD PTR _optparam[ecx+48]
	fld	QWORD PTR _dp$91012[ebp]
	mov	eax, DWORD PTR _optparam[ebx+48]
	mov	ecx, DWORD PTR _S$GSCopy$[ebp]
	fdiv	ST(1), ST(0)
	sub	esp, 8
	fdivp	ST(1), ST(0)
	fmul	QWORD PTR __real@bfd0000000000000
	fstp	QWORD PTR [esp]
	push	edx
	push	eax
	push	ecx
	call	_sp_hash_search
	mov	eax, DWORD PTR _gen_quant_list
	add	esp, 20					; 00000014H
$LN4@optparamhe:

; 2823 :         for ( m = 0 ; m < gen_quant_count ; m++ )

	inc	edi
	add	esi, 368				; 00000170H
	cmp	edi, DWORD PTR _web+5528
	jl	SHORT $LL5@optparamhe
$LN3@optparamhe:

; 2829 :         }
; 2830 :         restore_coords(&csaved,SAVE_SEPARATE);  /* also restores opt params */

	lea	edx, DWORD PTR _csaved$[ebp]
	push	2
	push	edx
	call	_restore_coords

; 2831 : 
; 2832 :         web.total_energy = emid; /* restore */

	fld	QWORD PTR _emid$91016[ebp]
	fstp	QWORD PTR _web+1240

; 2833 : 
; 2834 :         sp_hash_search(S,optparam[j].rownum,optparam[i].rownum,
; 2835 :                 (ehihi-ehilo-elohi+elolo)/dp/dp/4);

	mov	eax, DWORD PTR tv1446[ebp]
	fld	QWORD PTR _ehihi$91017[ebp]
	mov	ecx, DWORD PTR _optparam[eax+48]
	fsub	QWORD PTR _ehilo$91018[ebp]
	mov	edx, DWORD PTR _optparam[ebx+48]
	mov	eax, DWORD PTR _S$GSCopy$[ebp]
	fsub	QWORD PTR _elohi$91019[ebp]
	fadd	QWORD PTR _elolo$91020[ebp]
	fld	QWORD PTR _dp$91012[ebp]
	fdiv	ST(1), ST(0)
	fdivp	ST(1), ST(0)
	fmul	QWORD PTR __real@3fd0000000000000
	fstp	QWORD PTR [esp]
	push	ecx
	push	edx
	push	eax
	call	_sp_hash_search
	fld	QWORD PTR __real@3f50624dd2f1a9fc
	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	add	esp, 20					; 00000014H
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _i$[ebp]
	jl	$LL41@optparamhe
$LN43@optparamhe:

; 2718 : 
; 2719 :   /* optimizing parameter mixed terms */
; 2720 :   for ( i = 0 ; i < optparamcount ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _optparamcount
	jl	$LN203@optparamhe
	fstp	ST(0)
$LN42@optparamhe:

; 2836 :      }
; 2837 : 
; 2838 :   unsave_coords(&csaved,SAVE_SEPARATE);

	lea	ecx, DWORD PTR _csaved$[ebp]
	push	2
	push	ecx
	call	_unsave_coords
	add	esp, 8
	pop	ebx
$LN77@optparamhe:

; 2839 : } /* end optparamhess() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_optparamhess ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@CDJECHEC@square?5gradient?3?5?$CF3?415g?6?$AA@ ; `string'
PUBLIC	__real@4024000000000000
PUBLIC	??_C@_0BP@GKMHLKEM@stepsize?5?$CFg?5?5?5energy2?5?$CF18?415g?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@PDCFNMEN@stepsize?5?$CFg?5?5?5energy1?5?$CF18?415g?6?$AA@ ; `string'
PUBLIC	__real@3cd203af9ee75616
PUBLIC	__real@4059000000000000
PUBLIC	??_C@_0BO@EJBLKNLL@stepsize?50?5?5?5energy0?5?$CF18?415g?6?$AA@ ; `string'
PUBLIC	_hessian_line_seek
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	_msg:DWORD
EXTRN	_itdebug:DWORD
EXTRN	_hessian_iterate_flag:DWORD
EXTRN	__imp__MsgWaitForMultipleObjects@20:PROC
EXTRN	_graphmutex:DWORD
EXTRN	_locking_thread:DWORD
EXTRN	__imp__GetCurrentThreadId@0:PROC
;	COMDAT ??_C@_0BJ@CDJECHEC@square?5gradient?3?5?$CF3?415g?6?$AA@
CONST	SEGMENT
??_C@_0BJ@CDJECHEC@square?5gradient?3?5?$CF3?415g?6?$AA@ DB 'square gradi'
	DB	'ent: %3.15g', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT ??_C@_0BP@GKMHLKEM@stepsize?5?$CFg?5?5?5energy2?5?$CF18?415g?6?$AA@
CONST	SEGMENT
??_C@_0BP@GKMHLKEM@stepsize?5?$CFg?5?5?5energy2?5?$CF18?415g?6?$AA@ DB 's'
	DB	'tepsize %g   energy2 %18.15g', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PDCFNMEN@stepsize?5?$CFg?5?5?5energy1?5?$CF18?415g?6?$AA@
CONST	SEGMENT
??_C@_0BP@PDCFNMEN@stepsize?5?$CFg?5?5?5energy1?5?$CF18?415g?6?$AA@ DB 's'
	DB	'tepsize %g   energy1 %18.15g', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@3cd203af9ee75616
CONST	SEGMENT
__real@3cd203af9ee75616 DQ 03cd203af9ee75616r	; 1e-015
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT ??_C@_0BO@EJBLKNLL@stepsize?50?5?5?5energy0?5?$CF18?415g?6?$AA@
CONST	SEGMENT
??_C@_0BO@EJBLKNLL@stepsize?50?5?5?5energy0?5?$CF18?415g?6?$AA@ DB 'steps'
	DB	'ize 0   energy0 %18.15g', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _hessian_line_seek
_TEXT	SEGMENT
_scale2$ = -76						; size = 8
tv335 = -68						; size = 8
_scale0$ = -60						; size = 8
_scale1$ = -52						; size = 8
_energy0$ = -44						; size = 8
_energy2$ = -36						; size = 8
_energy1$ = -28						; size = 8
_stepsize$ = -20					; size = 8
_did_graphlock_here$89488 = -12				; size = 4
_did_graphlock_here$89465 = -12				; size = 4
tv336 = -8						; size = 8
_dirflag$ = -4						; size = 4
_S$ = 8							; size = 4
_denom$89513 = 12					; size = 8
_maxscale$ = 12						; size = 8
_X$ = 20						; size = 4
_hessian_line_seek PROC					; COMDAT

; 492  : { REAL scale0=0.0,scale1,scale2=0.0;

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	fldz
	push	edi
	fst	QWORD PTR _scale0$[ebp]

; 493  :   REAL energy0,energy1,energy2=0.0;
; 494  :   int seekcount = 0;
; 495  :   int dirflag = 0; /* for positive or negative direction */

	xor	edi, edi

; 496  :   REAL stepsize;
; 497  :   
; 498  :   if ( maxscale <= 0.0 ) return 0.0;

	fcom	QWORD PTR _maxscale$[ebp]
	mov	DWORD PTR _dirflag$[ebp], edi
	fnstsw	ax
	test	ah, 1
	je	$LN44@hessian_li
	push	ebx
	fstp	ST(0)
	push	esi

; 499  : 
; 500  :   ENTER_GRAPH_MUTEX;

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	lea	ebx, DWORD PTR [edi+1]
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN42@hessian_li
	push	edi
	push	100000					; 000186a0H
	push	edi
	push	OFFSET _graphmutex
	push	ebx
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89465[ebp], ebx
	jmp	SHORT $LN41@hessian_li
$LN42@hessian_li:
	mov	DWORD PTR _did_graphlock_here$89465[ebp], edi
$LN41@hessian_li:

; 501  : 
; 502  :   save_coords(&saved,SAVE_IN_ATTR);

	push	ebx
	push	OFFSET _saved
	call	_save_coords

; 503  : 
; 504  :   /* base energy; may be volume adjustments, so can't just take current values */
; 505  :   hessian_iterate_flag = 1;
; 506  :   hessian_move(0.0,ACTUAL_MOVE/*TEST_MOVE*/,X); 

	fldz
	mov	esi, DWORD PTR _X$[ebp]
	add	esp, 8
	push	esi
	push	ebx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR _hessian_iterate_flag, ebx
	call	_hessian_move
	add	esp, 16					; 00000010H

; 507  :   energy0 = min_square_grad_flag ? square_grad(): web.total_energy;

	cmp	DWORD PTR _min_square_grad_flag, edi
	je	SHORT $LN46@hessian_li
	call	_square_grad
	jmp	SHORT $LN130@hessian_li
$LN46@hessian_li:
	fld	QWORD PTR _web+1240
$LN130@hessian_li:

; 508  :   restore_coords(&saved,SAVE_IN_ATTR);

	push	ebx
	fstp	QWORD PTR _energy0$[ebp]
	push	OFFSET _saved
	call	_restore_coords
	add	esp, 8

; 509  :   hessian_iterate_flag = 0;

	mov	DWORD PTR _hessian_iterate_flag, edi

; 510  :   if ( itdebug )

	cmp	DWORD PTR _itdebug, edi
	je	SHORT $LN40@hessian_li

; 511  :   { sprintf(msg,"stepsize 0   energy0 %18.15g\n",(DOUBLE)energy0);

	fld	QWORD PTR _energy0$[ebp]
	mov	eax, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BO@EJBLKNLL@stepsize?50?5?5?5energy0?5?$CF18?415g?6?$AA@
	push	eax
	call	_sprintf

; 512  :     outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 20					; 00000014H
$LN40@hessian_li:

; 513  :   }
; 514  : 
; 515  :   // seek some move that reduces energy
; 516  :   for ( stepsize = maxscale/100 ; stepsize > 1e-15 ; stepsize /= 10 )

	fld	QWORD PTR _maxscale$[ebp]
	fdiv	QWORD PTR __real@4059000000000000
	fst	QWORD PTR _stepsize$[ebp]
	fld	QWORD PTR __real@3cd203af9ee75616
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	$LN76@hessian_li
$LN39@hessian_li:

; 517  :   { hessian_iterate_flag = 1;  // so CTRL-C doesn't break while surface moved
; 518  :     hessian_move(stepsize,ACTUAL_MOVE/*TEST_MOVE*/,X);

	push	esi
	push	ebx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR _hessian_iterate_flag, ebx
	call	_hessian_move
	add	esp, 16					; 00000010H

; 519  :     energy1 = min_square_grad_flag ? square_grad(): web.total_energy;

	cmp	DWORD PTR _min_square_grad_flag, edi
	je	SHORT $LN48@hessian_li
	call	_square_grad
	jmp	SHORT $LN131@hessian_li
$LN48@hessian_li:
	fld	QWORD PTR _web+1240
$LN131@hessian_li:

; 520  :     restore_coords(&saved,SAVE_IN_ATTR);

	push	ebx
	fstp	QWORD PTR _energy1$[ebp]
	push	OFFSET _saved
	call	_restore_coords
	add	esp, 8

; 521  :     hessian_iterate_flag = 0;

	mov	DWORD PTR _hessian_iterate_flag, edi

; 522  :     if ( itdebug )

	cmp	DWORD PTR _itdebug, edi
	je	SHORT $LN68@hessian_li

; 523  :     { sprintf(msg,"stepsize %g   energy1 %18.15g\n",(DOUBLE)stepsize,
; 524  :         (DOUBLE)energy1);

	fld	QWORD PTR _energy1$[ebp]
	mov	edx, DWORD PTR _msg
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _stepsize$[ebp]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BP@PDCFNMEN@stepsize?5?$CFg?5?5?5energy1?5?$CF18?415g?6?$AA@
	push	edx
	call	_sprintf

; 525  :       outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 28					; 0000001cH
$LN68@hessian_li:

; 526  :     }
; 527  : 
; 528  :     hessian_iterate_flag = 1;  // so CTRL-C doesn't break while surface partially moved
; 529  :     hessian_move(-stepsize,ACTUAL_MOVE/*TEST_MOVE*/,X);

	fld	QWORD PTR _stepsize$[ebp]
	push	esi
	push	ebx
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR _hessian_iterate_flag, ebx
	call	_hessian_move
	add	esp, 16					; 00000010H

; 530  :     energy2 = min_square_grad_flag ? square_grad(): web.total_energy;

	cmp	DWORD PTR _min_square_grad_flag, edi
	je	SHORT $LN50@hessian_li
	call	_square_grad
	jmp	SHORT $LN132@hessian_li
$LN50@hessian_li:
	fld	QWORD PTR _web+1240
$LN132@hessian_li:

; 531  :     restore_coords(&saved,SAVE_IN_ATTR);

	push	ebx
	fstp	QWORD PTR _energy2$[ebp]
	push	OFFSET _saved
	call	_restore_coords
	add	esp, 8

; 532  :     if ( itdebug )

	cmp	DWORD PTR _itdebug, edi
	je	SHORT $LN35@hessian_li

; 533  :     { sprintf(msg,"stepsize %g   energy2 %18.15g\n",(DOUBLE)stepsize,
; 534  :         (DOUBLE)energy2);

	fld	QWORD PTR _energy2$[ebp]
	mov	ecx, DWORD PTR _msg
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _stepsize$[ebp]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BP@GKMHLKEM@stepsize?5?$CFg?5?5?5energy2?5?$CF18?415g?6?$AA@
	push	ecx
	call	_sprintf

; 535  :       outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 28					; 0000001cH
$LN35@hessian_li:

; 536  :     }
; 537  :     hessian_iterate_flag = 0;
; 538  : 
; 539  :     if ( (energy1 < energy0) || (energy2 < energy0) )

	fld	QWORD PTR _energy0$[ebp]
	mov	DWORD PTR _hessian_iterate_flag, edi
	fld	QWORD PTR _energy1$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN79@hessian_li
	fxch	ST(1)
	fcomp	QWORD PTR _energy2$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN65@hessian_li
	fstp	ST(0)
	fld	QWORD PTR _stepsize$[ebp]
	fdiv	QWORD PTR __real@4024000000000000
	fst	QWORD PTR _stepsize$[ebp]
	fld	QWORD PTR __real@3cd203af9ee75616
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	$LN39@hessian_li
$LN76@hessian_li:

; 541  :       else dirflag = 1;

	fstp	ST(0)
$LN69@hessian_li:

; 542  :       break;
; 543  :     }
; 544  :      
; 545  :   }
; 546  :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89465[ebp], edi
	je	SHORT $LN70@hessian_li
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, edi
	call	DWORD PTR __imp__ReleaseMutex@4
$LN70@hessian_li:

; 547  : 
; 548  :   if ( dirflag == 0 )

	cmp	DWORD PTR _dirflag$[ebp], edi
	jne	SHORT $LN29@hessian_li

; 549  :      return 0;

	fldz
	pop	esi
	pop	ebx
	pop	edi

; 641  : } /* end hessian_line_seek() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN79@hessian_li:

; 536  :     }
; 537  :     hessian_iterate_flag = 0;
; 538  : 
; 539  :     if ( (energy1 < energy0) || (energy2 < energy0) )

	fstp	ST(1)
$LN65@hessian_li:

; 540  :     { if ( energy1 > energy2 ) dirflag = -1;

	fcomp	QWORD PTR _energy2$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN32@hessian_li
	mov	DWORD PTR _dirflag$[ebp], -1
	jmp	SHORT $LN69@hessian_li
$LN32@hessian_li:

; 541  :       else dirflag = 1;

	mov	DWORD PTR _dirflag$[ebp], ebx
	jmp	SHORT $LN69@hessian_li
$LN29@hessian_li:

; 550  : 
; 551  :   ENTER_GRAPH_MUTEX;

	call	DWORD PTR __imp__GetCurrentThreadId@0
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN28@hessian_li
	push	edi
	push	100000					; 000186a0H
	push	edi
	push	OFFSET _graphmutex
	push	ebx
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89488[ebp], ebx
	jmp	SHORT $LN27@hessian_li
$LN28@hessian_li:
	mov	DWORD PTR _did_graphlock_here$89488[ebp], edi
$LN27@hessian_li:

; 552  : 
; 553  :   scale1 = stepsize;

	fld	QWORD PTR _stepsize$[ebp]

; 554  :   hessian_iterate_flag = 1;  // so CTRL-C doesn't break while surface moved
; 555  :   hessian_move(dirflag*stepsize,ACTUAL_MOVE/*TEST_MOVE*/,X);

	push	esi
	fst	QWORD PTR _scale1$[ebp]
	push	ebx
	fild	DWORD PTR _dirflag$[ebp]
	sub	esp, 8
	mov	DWORD PTR _hessian_iterate_flag, ebx
	fst	QWORD PTR tv335[ebp]
	fmulp	ST(1), ST(0)
	fst	QWORD PTR tv336[ebp]
	fstp	QWORD PTR [esp]
	call	_hessian_move
	add	esp, 16					; 00000010H

; 556  :   energy1 = min_square_grad_flag ? square_grad(): web.total_energy;

	cmp	DWORD PTR _min_square_grad_flag, edi
	je	SHORT $LN52@hessian_li
	call	_square_grad
	jmp	SHORT $LN133@hessian_li
$LN52@hessian_li:
	fld	QWORD PTR _web+1240
$LN133@hessian_li:

; 557  :   restore_coords(&saved,SAVE_IN_ATTR);

	push	ebx
	fstp	QWORD PTR _energy1$[ebp]
	push	OFFSET _saved
	call	_restore_coords
	add	esp, 8

; 558  :   hessian_iterate_flag = 0;

	mov	DWORD PTR _hessian_iterate_flag, edi

; 559  :   if ( itdebug )

	cmp	DWORD PTR _itdebug, edi
	je	SHORT $LN26@hessian_li

; 560  :   { sprintf(msg,"stepsize %g   energy1 %18.15g\n",(DOUBLE)(dirflag*stepsize),
; 561  :        (DOUBLE)energy1);

	fld	QWORD PTR _energy1$[ebp]
	mov	ecx, DWORD PTR _msg
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR tv336[ebp]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BP@PDCFNMEN@stepsize?5?$CFg?5?5?5energy1?5?$CF18?415g?6?$AA@
	push	ecx
	call	_sprintf

; 562  :     outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 28					; 0000001cH
$LN26@hessian_li:

; 563  :   }
; 564  :   if ( energy1 < energy0 )

	fld	QWORD PTR _energy0$[ebp]
	fld	QWORD PTR _energy1$[ebp]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	$LN25@hessian_li
	fstp	ST(0)
	fld	QWORD PTR _maxscale$[ebp]
	fld	QWORD PTR _stepsize$[ebp]
$LN24@hessian_li:

; 565  :   { do
; 566  :      { stepsize *= 2;

	fadd	ST(0), ST(0)
	fst	QWORD PTR _stepsize$[ebp]

; 567  :         if ( stepsize > maxscale ) { stepsize = maxscale; /*break;*/ }

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN94@hessian_li
	fstp	ST(0)
	fst	QWORD PTR _stepsize$[ebp]
	jmp	SHORT $LN21@hessian_li
$LN94@hessian_li:
	fstp	ST(1)
$LN21@hessian_li:

; 568  :         hessian_iterate_flag = 1;
; 569  :         hessian_move(dirflag*stepsize,ACTUAL_MOVE/*TEST_MOVE*/,X);

	fmul	QWORD PTR tv335[ebp]
	push	esi
	push	ebx
	sub	esp, 8
	fst	QWORD PTR tv336[ebp]
	mov	DWORD PTR _hessian_iterate_flag, ebx
	fstp	QWORD PTR [esp]
	call	_hessian_move
	add	esp, 16					; 00000010H

; 570  :         energy2 = min_square_grad_flag ? square_grad(): web.total_energy;

	cmp	DWORD PTR _min_square_grad_flag, edi
	je	SHORT $LN54@hessian_li
	call	_square_grad
	jmp	SHORT $LN134@hessian_li
$LN54@hessian_li:
	fld	QWORD PTR _web+1240
$LN134@hessian_li:
	fstp	QWORD PTR _energy2$[ebp]

; 571  :         scale2 = stepsize;
; 572  :         restore_coords(&saved,SAVE_IN_ATTR);

	push	ebx
	fld	QWORD PTR _stepsize$[ebp]
	push	OFFSET _saved
	fstp	QWORD PTR _scale2$[ebp]
	call	_restore_coords
	add	esp, 8

; 573  :         hessian_iterate_flag = 0;

	mov	DWORD PTR _hessian_iterate_flag, edi

; 574  :         if ( itdebug )

	cmp	DWORD PTR _itdebug, edi
	je	SHORT $LN20@hessian_li

; 575  :         { sprintf(msg,"stepsize %g   energy2 %18.15g\n",
; 576  :               (DOUBLE)(dirflag*stepsize),(DOUBLE)energy2);

	fld	QWORD PTR _energy2$[ebp]
	mov	eax, DWORD PTR _msg
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR tv336[ebp]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BP@GKMHLKEM@stepsize?5?$CFg?5?5?5energy2?5?$CF18?415g?6?$AA@
	push	eax
	call	_sprintf

; 577  :           outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 28					; 0000001cH
$LN20@hessian_li:

; 578  :         }
; 579  :         if ( energy2 > energy1 )

	fld	QWORD PTR _energy1$[ebp]
	fld	QWORD PTR _energy2$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN62@hessian_li

; 581  :         else 
; 582  :         { energy0 = energy1; scale0 = scale1;

	fxch	ST(1)
	fst	QWORD PTR _energy0$[ebp]
	fld	QWORD PTR _scale1$[ebp]
	fst	QWORD PTR _scale0$[ebp]

; 583  :           energy1 = energy2; scale1 = scale2;

	fld	ST(2)
	fst	QWORD PTR _energy1$[ebp]
	fld	QWORD PTR _stepsize$[ebp]
	fld	ST(0)
	fst	QWORD PTR _scale1$[ebp]

; 584  :         }
; 585  :      } while ( stepsize < maxscale );

	fld	QWORD PTR _maxscale$[ebp]
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN14@hessian_li

; 586  :   }
; 587  :   else /* energy1 >= energy0 */

	fstp	ST(3)
	fstp	ST(3)
	fstp	ST(2)
	fstp	ST(3)
	fstp	ST(1)
	jmp	$LN24@hessian_li
$LN62@hessian_li:

; 580  :         { stepsize /= 2; break; }

	fld	QWORD PTR _stepsize$[ebp]
	fmul	QWORD PTR __real@3fe0000000000000

; 586  :   }
; 587  :   else /* energy1 >= energy0 */

	fld	QWORD PTR _scale0$[ebp]
	fld	QWORD PTR _maxscale$[ebp]
	fld	QWORD PTR _energy0$[ebp]
	fld	QWORD PTR _scale1$[ebp]
	fxch	ST(5)
	fxch	ST(6)
	fxch	ST(1)
	fxch	ST(5)
	fxch	ST(3)
	fxch	ST(4)
	fxch	ST(1)
	fxch	ST(3)
	fxch	ST(1)
	fxch	ST(2)
	jmp	$LN14@hessian_li
$LN25@hessian_li:

; 588  :   { seekcount = 0;

	xor	esi, esi
$LN16@hessian_li:

; 589  :      do
; 590  :      { if ( seekcount++ > 20 ) { stepsize = 0.0; break; }

	mov	edx, esi
	add	esi, ebx
	cmp	edx, 20					; 00000014H
	jg	$LN90@hessian_li

; 591  :         energy2 = energy1; scale2 = scale1;
; 592  :         stepsize = scale2/2;
; 593  :         hessian_iterate_flag = 1;
; 594  :         hessian_move(dirflag*stepsize,ACTUAL_MOVE/*TEST_MOVE*/,X);

	mov	eax, DWORD PTR _X$[ebp]
	fstp	QWORD PTR _energy2$[ebp]
	fld	QWORD PTR _stepsize$[ebp]
	push	eax
	fst	QWORD PTR _scale2$[ebp]
	push	ebx
	fmul	QWORD PTR __real@3fe0000000000000
	sub	esp, 8
	mov	DWORD PTR _hessian_iterate_flag, ebx
	fst	QWORD PTR _stepsize$[ebp]
	fmul	QWORD PTR tv335[ebp]
	fst	QWORD PTR tv336[ebp]
	fstp	QWORD PTR [esp]
	call	_hessian_move
	add	esp, 16					; 00000010H

; 595  :         energy1 = min_square_grad_flag ? square_grad(): web.total_energy;

	cmp	DWORD PTR _min_square_grad_flag, edi
	je	SHORT $LN56@hessian_li
	call	_square_grad
	jmp	SHORT $LN135@hessian_li
$LN56@hessian_li:
	fld	QWORD PTR _web+1240
$LN135@hessian_li:
	fstp	QWORD PTR _energy1$[ebp]

; 596  :         scale1 = stepsize;
; 597  :         restore_coords(&saved,SAVE_IN_ATTR);

	push	ebx
	fld	QWORD PTR _stepsize$[ebp]
	push	OFFSET _saved
	fstp	QWORD PTR _scale1$[ebp]
	call	_restore_coords
	add	esp, 8

; 598  :         hessian_iterate_flag = 0;

	mov	DWORD PTR _hessian_iterate_flag, edi

; 599  :         if ( itdebug )

	cmp	DWORD PTR _itdebug, edi
	je	SHORT $LN15@hessian_li

; 600  :         { sprintf(msg,"stepsize %g   energy1 %18.15g\n",
; 601  :             (DOUBLE)(dirflag*stepsize),(DOUBLE)(energy1));

	fld	QWORD PTR _energy1$[ebp]
	mov	ecx, DWORD PTR _msg
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR tv336[ebp]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BP@PDCFNMEN@stepsize?5?$CFg?5?5?5energy1?5?$CF18?415g?6?$AA@
	push	ecx
	call	_sprintf

; 602  :           outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 28					; 0000001cH
$LN15@hessian_li:

; 603  :         }
; 604  :      } while ( energy1 > energy0 );

	fld	QWORD PTR _energy0$[ebp]
	fld	QWORD PTR _energy1$[ebp]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN66@hessian_li
	fstp	ST(1)
	jmp	$LN16@hessian_li
$LN90@hessian_li:

; 605  :   }
; 606  :   if ( (stepsize > 0.0) && (energy2 > energy1) /*(stepsize < maxscale)*/ )

	mov	esi, DWORD PTR _X$[ebp]
	fstp	ST(0)
	fldz
	fld	QWORD PTR _maxscale$[ebp]
	fxch	ST(1)
$LN5@hessian_li:

; 621  :   else if ( stepsize > maxscale ) stepsize = maxscale;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN122@hessian_li
	fstp	ST(0)
	jmp	$LN3@hessian_li
$LN66@hessian_li:

; 586  :   }
; 587  :   else /* energy1 >= energy0 */

	fld	QWORD PTR _scale0$[ebp]
	mov	esi, DWORD PTR _X$[ebp]
	fld	QWORD PTR _maxscale$[ebp]
	fld	QWORD PTR _energy2$[ebp]
	fld	QWORD PTR _stepsize$[ebp]
	fld	QWORD PTR _scale1$[ebp]
	fxch	ST(2)
	fxch	ST(6)
	fxch	ST(5)
	fxch	ST(3)
	fxch	ST(1)
	fxch	ST(2)
	fxch	ST(1)
$LN14@hessian_li:

; 605  :   }
; 606  :   if ( (stepsize > 0.0) && (energy2 > energy1) /*(stepsize < maxscale)*/ )

	fldz
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jp	$LN103@hessian_li
	fxch	ST(6)
	fcom	ST(3)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN106@hessian_li
	fstp	ST(2)
	fstp	ST(5)

; 607  :   { REAL denom;
; 608  :     /* now quadratic interpolation for minimum energy */
; 609  :     denom = energy0*(scale1-scale2)+energy1*(scale2-scale0)
; 610  :                  + energy2*(scale0 - scale1);

	fld	ST(4)
	fld	QWORD PTR _scale2$[ebp]
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(5)
	fld	ST(1)
	fsub	ST(0), ST(5)
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fld	ST(4)
	fsub	ST(0), ST(7)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fst	QWORD PTR _denom$89513[ebp]

; 611  :     if ( denom == 0.0 ) stepsize = 0.0;

	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@hessian_li
	fstp	ST(2)
	fstp	ST(4)
	fstp	ST(3)
	fstp	ST(1)
	fldz

; 612  :     else

	jmp	SHORT $LN9@hessian_li
$LN10@hessian_li:

; 613  :     { stepsize = ((energy0-energy2)*scale1*scale1
; 614  :             +(energy1-energy0)*scale2*scale2
; 615  :             +(energy2-energy1)*scale0*scale0)/2/denom;

	fld	ST(4)
	fsub	ST(0), ST(2)
	fmul	ST(0), ST(6)
	fmulp	ST(6), ST(0)
	fld	ST(2)
	fsubrp	ST(5), ST(0)
	fmul	ST(4), ST(0)
	fmul	ST(4), ST(0)
	fxch	ST(5)
	faddp	ST(4), ST(0)
	fsubrp	ST(1), ST(0)
	fmul	ST(0), ST(1)
	fmul	ST(0), ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR _denom$89513[ebp]
$LN9@hessian_li:

; 616  :     }
; 617  :     if ( stepsize < scale0 ) stepsize = scale0;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN113@hessian_li
	fstp	ST(0)
	jmp	SHORT $LN8@hessian_li
$LN113@hessian_li:
	fstp	ST(1)
$LN8@hessian_li:

; 618  :     if ( stepsize > scale2 ) stepsize = scale2;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN122@hessian_li

; 621  :   else if ( stepsize > maxscale ) stepsize = maxscale;

	fstp	ST(0)

; 619  :   }
; 620  :   else if ( stepsize < 0.0 ) stepsize = 0.0;

	jmp	SHORT $LN3@hessian_li
$LN103@hessian_li:

; 605  :   }
; 606  :   if ( (stepsize > 0.0) && (energy2 > energy1) /*(stepsize < maxscale)*/ )

	fstp	ST(3)
	fstp	ST(3)
	fstp	ST(2)
	fstp	ST(3)
	jmp	SHORT $LN136@hessian_li
$LN106@hessian_li:
	fstp	ST(3)
	fstp	ST(3)
	fstp	ST(2)
	fstp	ST(0)
$LN136@hessian_li:
	fstp	ST(1)

; 619  :   }
; 620  :   else if ( stepsize < 0.0 ) stepsize = 0.0;

	fldz
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN119@hessian_li
	fstp	ST(1)
$LN122@hessian_li:

; 621  :   else if ( stepsize > maxscale ) stepsize = maxscale;

	fstp	ST(1)
$LN3@hessian_li:

; 622  :   hessian_iterate_flag = 1;
; 623  :   hessian_move(dirflag*stepsize,ACTUAL_MOVE,X);

	fmul	QWORD PTR tv335[ebp]
	push	esi
	push	ebx
	sub	esp, 8
	fst	QWORD PTR tv336[ebp]
	mov	DWORD PTR _hessian_iterate_flag, ebx
	fstp	QWORD PTR [esp]
	call	_hessian_move
	add	esp, 16					; 00000010H

; 624  :   hessian_iterate_flag = 0;

	mov	DWORD PTR _hessian_iterate_flag, edi

; 625  : 
; 626  :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$89488[ebp], edi
	je	SHORT $LN2@hessian_li
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, edi
	call	DWORD PTR __imp__ReleaseMutex@4
$LN2@hessian_li:

; 627  : 
; 628  :   if ( min_square_grad_flag )

	cmp	DWORD PTR _min_square_grad_flag, edi
	je	SHORT $LN1@hessian_li

; 629  :   { energy1 =  square_grad();

	call	_square_grad

; 630  : #ifdef FLOAT128
; 631  :      sprintf(msg,"square gradient: %3.*Qg\n",DPREC,energy1);
; 632  : #elif defined(LONGDOUBLE)
; 633  :      sprintf(msg,"square gradient: %3.*Lg\n",DPREC,energy1);
; 634  : #else
; 635  :      sprintf(msg,"square gradient: %3.15g\n",energy1);

	mov	ecx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BJ@CDJECHEC@square?5gradient?3?5?$CF3?415g?6?$AA@
	push	ecx
	call	_sprintf

; 636  : #endif 
; 637  :      outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 20					; 00000014H
$LN1@hessian_li:

; 638  :   }
; 639  : 
; 640  :   return dirflag*stepsize;

	fld	QWORD PTR tv336[ebp]
	pop	esi
	pop	ebx
$LN44@hessian_li:
	pop	edi

; 641  : } /* end hessian_line_seek() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN119@hessian_li:

; 619  :   }
; 620  :   else if ( stepsize < 0.0 ) stepsize = 0.0;

	fstp	ST(0)
	jmp	$LN5@hessian_li
_hessian_line_seek ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@HHAHGECJ@Must?5do?5convert_to_quantities?5to@ ; `string'
PUBLIC	_hessian_fill
EXTRN	_sp_hash_end:PROC
EXTRN	_body_hessian:PROC
EXTRN	_edge_energy_hessian:PROC
EXTRN	_area_hessian:PROC
EXTRN	_simplex_hessian:PROC
EXTRN	_difference_hessian:PROC
EXTRN	_hessian_by_diff_flag:DWORD
;	COMDAT ??_C@_0EC@HHAHGECJ@Must?5do?5convert_to_quantities?5to@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EC@HHAHGECJ@Must?5do?5convert_to_quantities?5to@ DB 'Must do conve'
	DB	'rt_to_quantities to do Hessian with symmetry group.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\hessian.c
CONST	ENDS
;	COMDAT _hessian_fill
_TEXT	SEGMENT
tv357 = -8						; size = 8
_S$ = 8							; size = 4
_rhs$ = 12						; size = 4
_rhsptr$ = 12						; size = 4
_hessian_fill PROC					; COMDAT

; 2176 : { int k;

	push	ebp
	mov	ebp, esp

; 2177 :   body_id b_id;
; 2178 :   REAL *rhs = rhsptr ? *rhsptr : NULL;

	mov	eax, DWORD PTR _rhsptr$[ebp]
	sub	esp, 8
	push	esi
	push	edi
	test	eax, eax
	je	SHORT $LN34@hessian_fi
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR _rhs$[ebp], edi
	jmp	SHORT $LN35@hessian_fi
$LN34@hessian_fi:
	mov	DWORD PTR _rhs$[ebp], 0
	mov	edi, DWORD PTR _rhs$[ebp]
$LN35@hessian_fi:

; 2179 : 
; 2180 :   #ifdef MPI_EVOLVER
; 2181 :   if ( this_task == 0 )
; 2182 :   { mpi_hessian_fill(S,rhsptr);
; 2183 :     temp_free((char*)S->hashtable); /* since not calling hash_end() */
; 2184 :     rhs = rhsptr ? *rhsptr : NULL;  /* mpi_hessian_fill reallocates it */
; 2185 :     goto rhs_constraints;
; 2186 :   }
; 2187 :   #endif
; 2188 :  
; 2189 :   /* clear entries */
; 2190 :   if ( rhs_flag ) memset((char*)rhs,0,S->total_rows*sizeof(REAL));

	cmp	DWORD PTR _rhs_flag, 0
	mov	esi, DWORD PTR _S$[ebp]
	je	SHORT $LN31@hessian_fi
	mov	eax, DWORD PTR [esi+28]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH
$LN31@hessian_fi:

; 2191 : 
; 2192 :   /* fill in hessian */
; 2193 :   if ( hessian_by_diff_flag )

	cmp	DWORD PTR _hessian_by_diff_flag, 0
	je	SHORT $LN30@hessian_fi

; 2194 :   { /* hessian by crude numeric difference formulas */
; 2195 :     difference_hessian(S,vhead,rhs);

	mov	ecx, DWORD PTR _vhead
	push	edi
	push	ecx
	push	esi
	call	_difference_hessian
	add	esp, 12					; 0000000cH

; 2196 :     if ( optparamcount ) optparamhess(S,rhs);
; 2197 :   }
; 2198 :   else /* hessian by explicit formulas */

	jmp	$LN18@hessian_fi
$LN30@hessian_fi:

; 2199 :   {
; 2200 :     if ( !quantities_only_flag )

	cmp	DWORD PTR _quantities_only_flag, 0
	jne	SHORT $quantplace$90574

; 2201 :     { 
; 2202 :       if ( web.symmetry_flag && !web.torus_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN52@hessian_fi
	cmp	DWORD PTR _web+860, 0
	jne	SHORT $LN52@hessian_fi

; 2203 :       { if ( auto_convert_flag ) {convert_to_quantities(); goto quantplace;}

	cmp	DWORD PTR _auto_convert_flag, 0
	je	SHORT $LN25@hessian_fi
	call	_convert_to_quantities
	jmp	SHORT $quantplace$90574
$LN25@hessian_fi:

; 2204 :         else
; 2205 :         kb_error(2079,
; 2206 :           "Must do convert_to_quantities to do Hessian with symmetry group.\n",
; 2207 :                     RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EC@HHAHGECJ@Must?5do?5convert_to_quantities?5to@
	push	2079					; 0000081fH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN52@hessian_fi:

; 2208 :       }
; 2209 :       if ( web.representation == SIMPLEX )

	mov	eax, DWORD PTR _web+624
	cmp	eax, 3
	jne	SHORT $LN23@hessian_fi

; 2210 :          simplex_hessian(S,rhs);

	push	edi
	push	esi
	call	_simplex_hessian

; 2211 :       else 

	jmp	SHORT $LN77@hessian_fi
$LN23@hessian_fi:

; 2212 :       { if ( web.representation == SOAPFILM ) 

	cmp	eax, 2
	jne	SHORT $LN21@hessian_fi

; 2213 :           area_hessian(S,rhs);

	push	edi
	push	esi
	call	_area_hessian
	add	esp, 8
$LN21@hessian_fi:

; 2214 :         edge_energy_hessian(S,rhs);

	push	edi
	push	esi
	call	_edge_energy_hessian
$LN77@hessian_fi:
	add	esp, 8
$quantplace$90574:

; 2215 :       }
; 2216 : 
; 2217 :     }
; 2218 : quantplace:
; 2219 :     if ( gen_quant_count )

	cmp	DWORD PTR _web+5528, 0
	je	SHORT $LN20@hessian_fi

; 2220 :        calc_quant_hess(S,rhs_flag,hess_flag,rhs);

	mov	edx, DWORD PTR _hess_flag
	mov	eax, DWORD PTR _rhs_flag
	push	edi
	push	edx
	push	eax
	push	esi
	call	_calc_quant_hess
	add	esp, 16					; 00000010H
$LN20@hessian_fi:

; 2221 :         
; 2222 :     if ( !quantities_only_flag )

	cmp	DWORD PTR _quantities_only_flag, 0
	jne	SHORT $LN18@hessian_fi

; 2223 :        if ( web.bodycount > web.full_flag  )

	mov	ecx, DWORD PTR _web+1500
	cmp	ecx, DWORD PTR _web+864
	jle	SHORT $LN18@hessian_fi

; 2224 :           body_hessian(S,rhs);

	push	edi
	push	esi
	call	_body_hessian
	add	esp, 8
$LN18@hessian_fi:

; 2225 : 
; 2226 :     if ( optparamcount ) optparamhess(S,rhs);

	cmp	DWORD PTR _optparamcount, 0
	je	SHORT $LN50@hessian_fi
	push	edi
	push	esi
	call	_optparamhess
	add	esp, 8
$LN50@hessian_fi:

; 2227 :   } 
; 2228 : 
; 2229 :   if ( hess_flag )

	cmp	DWORD PTR _hess_flag, 0
	je	SHORT $LN14@hessian_fi

; 2230 :   {
; 2231 :     /* extract stuff from hash table */
; 2232 :     if ( sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, 0

; 2233 :       sp_hash_end(S,S->total_rows,S->total_rows,A_OFF);

	push	1
	je	SHORT $LN15@hessian_fi
	mov	eax, DWORD PTR [esi+28]
	push	eax

; 2234 :     else

	jmp	SHORT $LN78@hessian_fi
$LN15@hessian_fi:

; 2235 :       sp_hash_end(S,S->A_rows,S->total_rows,A_OFF);

	mov	edx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [esi+12]
	push	edx
$LN78@hessian_fi:
	push	eax
	push	esi
	call	_sp_hash_end
	add	esp, 16					; 00000010H
$LN14@hessian_fi:

; 2236 : 
; 2237 :   }
; 2238 : 
; 2239 : #ifdef MPI_EVOLVER
; 2240 : rhs_constraints:
; 2241 : #endif
; 2242 : 
; 2243 :   /* rhs for body constraint rows */
; 2244 :   if ( rhs && !everything_quantities_flag )

	test	edi, edi
	je	$LN3@hessian_fi
	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	$LN56@hessian_fi

; 2245 :   { FOR_ALL_BODIES(b_id)

	mov	edx, DWORD PTR _web+384
	push	ebx
	mov	ebx, edx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	je	SHORT $LN57@hessian_fi
	fldz
$LN54@hessian_fi:
	mov	ecx, DWORD PTR _web+348
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR tv357[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN11@hessian_fi

; 2246 :     { REAL *current = rhs + S->bodyrowstart + loc_ordinal(b_id);

	test	ebx, ebx
	je	SHORT $LN36@hessian_fi
	mov	eax, edx
	jmp	SHORT $LN37@hessian_fi
$LN36@hessian_fi:
	or	eax, -1
$LN37@hessian_fi:
	mov	edi, DWORD PTR _S$[ebp]
	mov	edi, DWORD PTR [edi+20]
	add	edi, eax
	mov	eax, DWORD PTR _rhs$[ebp]
	lea	edi, DWORD PTR [eax+edi*8]

; 2247 :       if ( get_battr(b_id) & FIXEDVOL )

	and	ecx, 32					; 00000020H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN11@hessian_fi

; 2248 :          *current = -(get_body_fixvol(b_id) - get_body_volume(b_id));

	test	ebx, ebx
	je	SHORT $LN40@hessian_fi
	fld	QWORD PTR [esi+32]
	fld	QWORD PTR [esi+40]
	jmp	SHORT $LN45@hessian_fi
$LN40@hessian_fi:
	fld	ST(0)
	fld	ST(1)
$LN45@hessian_fi:
	fsubp	ST(1), ST(0)
	fchs
	fstp	QWORD PTR [edi]
$LN11@hessian_fi:

; 2245 :   { FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [edx]
	mov	ebx, edx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	jne	SHORT $LN54@hessian_fi
	mov	edi, DWORD PTR _rhs$[ebp]
	fstp	ST(0)
	mov	esi, DWORD PTR _S$[ebp]
$LN57@hessian_fi:
	pop	ebx
$LN56@hessian_fi:

; 2249 :     }
; 2250 :   }
; 2251 : 
; 2252 :   /* rhs for quantity constraint rows */
; 2253 :   if ( rhs )
; 2254 :   for ( k = 0 ; k < gen_quant_count ; k++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+5528, ecx
	jle	SHORT $LN3@hessian_fi
	mov	eax, DWORD PTR _gen_quant_list
	add	eax, 136				; 00000088H
	npad	1
$LL5@hessian_fi:

; 2255 :   { struct gen_quant *q = GEN_QUANT(k);
; 2256 :     if ( q->flags & (Q_DELETED|Q_REDUNDANT) ) continue;

	mov	edx, DWORD PTR [eax]
	test	edx, 589824				; 00090000H
	jne	SHORT $LN4@hessian_fi

; 2257 :     if ( q->flags & Q_FIXED )

	test	dl, 2
	je	SHORT $LN4@hessian_fi

; 2258 :       rhs[S->quanrowstart + k] = -(q->target - q->value);

	fld	QWORD PTR [eax+8]
	mov	edx, DWORD PTR [esi+24]
	fsub	QWORD PTR [eax+16]
	add	edx, ecx
	fchs
	fstp	QWORD PTR [edi+edx*8]
$LN4@hessian_fi:

; 2249 :     }
; 2250 :   }
; 2251 : 
; 2252 :   /* rhs for quantity constraint rows */
; 2253 :   if ( rhs )
; 2254 :   for ( k = 0 ; k < gen_quant_count ; k++ )

	inc	ecx
	add	eax, 368				; 00000170H
	cmp	ecx, DWORD PTR _web+5528
	jl	SHORT $LL5@hessian_fi
$LN3@hessian_fi:
	pop	edi
	pop	esi

; 2259 :   }
; 2260 : 
; 2261 : }  /* end hessian_fill() */

	mov	esp, ebp
	pop	ebp
	ret	0
_hessian_fill ENDP
_TEXT	ENDS
PUBLIC	_hessian_exit
; Function compile flags: /Ogtp
;	COMDAT _hessian_exit
_TEXT	SEGMENT
tv326 = -4						; size = 4
_pcount$90728 = 8					; size = 4
_f$90709 = 8						; size = 4
_X$ = 8							; size = 4
_hessian_exit PROC					; COMDAT

; 2367 : { int j;

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 2368 :   struct hess_verlist *vc;              /* current  vertex */
; 2369 :   vertex_id v_id;
; 2370 : 
; 2371 :   hess_debug = 0;
; 2372 :   
; 2373 :   /* store move in vertex force */
; 2374 :   if ( X && vhead )

	mov	ebx, DWORD PTR _X$[ebp]
	mov	DWORD PTR _hess_debug, 0
	test	ebx, ebx
	je	$LN14@hessian_ex
	cmp	DWORD PTR _vhead, 0
	je	$LN14@hessian_ex

; 2375 :   { FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	$LN14@hessian_ex
	push	esi
	push	edi
	npad	7
$LL32@hessian_ex:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv326[ebp], edi
	je	$LN15@hessian_ex

; 2376 :     {
; 2377 :       REAL *f;
; 2378 :       vc = get_vertex_vhead(v_id);

	mov	eax, DWORD PTR _vhead_attr
	mov	edx, DWORD PTR _web+104
	imul	eax, 240				; 000000f0H
	mov	esi, DWORD PTR _dymem
	add	eax, edx
	mov	eax, DWORD PTR [eax+esi+64]
	mov	esi, DWORD PTR [ecx+eax]
	shl	esi, 5
	add	esi, DWORD PTR _vhead

; 2379 :       if ( vc->freedom <= 0 ) continue;

	cmp	DWORD PTR [esi+8], 0
	jle	$LN15@hessian_ex

; 2380 :       f = get_force(v_id);

	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [edi+eax]
	mov	edi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+edi+784]
	add	edx, eax

; 2381 :       if ( get_vattr(v_id) & BOUNDARY )

	mov	eax, DWORD PTR [eax+8]
	and	eax, 128				; 00000080H
	xor	edi, edi
	or	eax, edi
	mov	DWORD PTR _f$90709[ebp], edx
	je	$LN10@hessian_ex

; 2382 :       { struct boundary *boundary = get_boundary(v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN20@hessian_ex
	mov	edi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edi+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN21@hessian_ex
$LN20@hessian_ex:
	xor	eax, eax
$LN21@hessian_ex:

; 2383 :         int pcount = boundary->pcount;

	mov	ecx, DWORD PTR [eax+40]

; 2384 : 
; 2385 :         for ( j = 0 ; j < pcount ; j++ )

	xor	eax, eax
	mov	DWORD PTR _pcount$90728[ebp], ecx
	cmp	ecx, 4
	jl	SHORT $LC29@hessian_ex

; 2383 :         int pcount = boundary->pcount;

	lea	ecx, DWORD PTR [edx+16]

; 2384 : 
; 2385 :         for ( j = 0 ; j < pcount ; j++ )

$LL30@hessian_ex:

; 2386 :           f[j] = X[vc->rownum + j];

	mov	edi, DWORD PTR [esi+12]
	add	edi, eax
	fld	QWORD PTR [ebx+edi*8]
	add	ecx, 32					; 00000020H
	fstp	QWORD PTR [ecx-48]
	mov	edi, DWORD PTR [esi+12]
	add	edi, eax
	fld	QWORD PTR [ebx+edi*8+8]
	fstp	QWORD PTR [ecx-40]
	mov	edi, DWORD PTR [esi+12]
	add	edi, eax
	fld	QWORD PTR [ebx+edi*8+16]
	fstp	QWORD PTR [ecx-32]
	mov	edi, DWORD PTR [esi+12]
	add	edi, eax
	fld	QWORD PTR [ebx+edi*8+24]
	mov	edi, DWORD PTR _pcount$90728[ebp]
	fstp	QWORD PTR [ecx-24]
	add	eax, 4
	add	edi, -3					; fffffffdH
	cmp	eax, edi
	jl	SHORT $LL30@hessian_ex
	mov	ecx, DWORD PTR _pcount$90728[ebp]
$LC29@hessian_ex:

; 2384 : 
; 2385 :         for ( j = 0 ; j < pcount ; j++ )

	cmp	eax, ecx
	jge	SHORT $LN15@hessian_ex
	npad	4
$LC9@hessian_ex:

; 2386 :           f[j] = X[vc->rownum + j];

	mov	edi, DWORD PTR [esi+12]
	add	edi, eax
	fld	QWORD PTR [ebx+edi*8]
	inc	eax
	fstp	QWORD PTR [edx+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LC9@hessian_ex

; 2387 :       }
; 2388 :       else

	jmp	SHORT $LN15@hessian_ex
$LN10@hessian_ex:

; 2389 :       { for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	cmp	DWORD PTR _web+616, edi
	jle	SHORT $LN15@hessian_ex
	npad	3
$LL5@hessian_ex:

; 2390 :           if ( vc->proj )

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN2@hessian_ex

; 2391 :              f[j] = dot(vc->proj[j],X+vc->rownum,vc->freedom);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+12]
	push	ecx
	lea	ecx, DWORD PTR [ebx+edx*8]
	mov	edx, DWORD PTR [eax+edi*4]
	push	ecx
	push	edx
	call	_dot
	mov	eax, DWORD PTR _f$90709[ebp]
	fstp	QWORD PTR [eax+edi*8]
	add	esp, 12					; 0000000cH

; 2392 :           else

	mov	edx, eax
	jmp	SHORT $LN4@hessian_ex
$LN2@hessian_ex:

; 2393 :         f[j] = X[vc->rownum + j];

	mov	ecx, DWORD PTR [esi+12]
	add	ecx, edi
	fld	QWORD PTR [ebx+ecx*8]
	fstp	QWORD PTR [edx+edi*8]
$LN4@hessian_ex:

; 2389 :       { for ( j = 0 ; j < SDIM ; j++ )

	inc	edi
	cmp	edi, DWORD PTR _web+616
	jl	SHORT $LL5@hessian_ex
$LN15@hessian_ex:

; 2375 :   { FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	edx, DWORD PTR tv326[ebp]
	mov	ecx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	jne	$LL32@hessian_ex
	pop	edi
	pop	esi
$LN14@hessian_ex:

; 2394 :       }
; 2395 :     }
; 2396 :   }
; 2397 :   hessian_cleanup(); 

	call	_hessian_cleanup
	pop	ebx

; 2398 : 
; 2399 : } // end hessian_exit()

	mov	esp, ebp
	pop	ebp
	ret	0
_hessian_exit ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@JPBMOMJN@Hessian?5move?5would?5have?5raised?5e@ ; `string'
PUBLIC	_hessian_auto
EXTRN	_free_system:PROC
EXTRN	_machine_eps:QWORD
EXTRN	_check_increase_flag:DWORD
EXTRN	_sp_Hessian_solver:PROC
;	COMDAT ??_C@_0DL@JPBMOMJN@Hessian?5move?5would?5have?5raised?5e@
CONST	SEGMENT
??_C@_0DL@JPBMOMJN@Hessian?5move?5would?5have?5raised?5e@ DB 'Hessian mov'
	DB	'e would have raised energy.  Restoring coords.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _hessian_auto
_TEXT	SEGMENT
_S$ = -248						; size = 232
_old_energy$ = -16					; size = 8
_rhs$ = -8						; size = 4
_X$ = -4						; size = 4
_hessian_auto PROC					; COMDAT

; 321  : { REAL old_energy = web.total_energy;

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	fld	QWORD PTR _web+1240

; 322  :   REAL *rhs = NULL;
; 323  :   REAL *X = NULL;
; 324  :   struct linsys S;
; 325  : 
; 326  :   hmode = hessian_normal_flag;

	mov	eax, DWORD PTR _hessian_normal_flag
	push	ebx
	fstp	QWORD PTR _old_energy$[ebp]
	mov	DWORD PTR _rhs$[ebp], 0
	mov	DWORD PTR _X$[ebp], 0
	mov	DWORD PTR _hmode, eax

; 327  :   hessian_cleanup(); /* cleanup from previous round */

	call	_hessian_cleanup

; 328  :   hessian_init(&S,&rhs);

	lea	ecx, DWORD PTR _rhs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	call	_hessian_init

; 329  :   hess_flag = 1; rhs_flag = 1;
; 330  : 
; 331  :   hessian_fill(&S,&rhs); 

	lea	eax, DWORD PTR _rhs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	mov	DWORD PTR _hess_flag, 1
	mov	DWORD PTR _rhs_flag, 1
	call	_hessian_fill

; 332  : 
; 333  :   sp_Hessian_solver(&S,rhs,&X);

	mov	ebx, DWORD PTR _rhs$[ebp]
	lea	edx, DWORD PTR _X$[ebp]
	push	edx
	lea	eax, DWORD PTR _S$[ebp]
	push	ebx
	push	eax
	call	_sp_Hessian_solver

; 334  : 
; 335  :   hessian_iterate_flag = 1;
; 336  :   hessian_move((REAL)1.0,ACTUAL_MOVE,X);

	fld1
	mov	ecx, DWORD PTR _X$[ebp]
	add	esp, 28					; 0000001cH
	push	ecx
	push	1
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR _hessian_iterate_flag, 1
	call	_hessian_move
	add	esp, 16					; 00000010H

; 337  :   hessian_iterate_flag = 0;
; 338  : 
; 339  :   if ( check_increase_flag && 
; 340  :          (web.total_energy > (1+100*machine_eps)*old_energy) )

	cmp	DWORD PTR _check_increase_flag, 0
	mov	DWORD PTR _hessian_iterate_flag, 0
	je	SHORT $LN1@hessian_au
	fld	QWORD PTR _machine_eps
	fmul	QWORD PTR __real@4059000000000000
	fadd	QWORD PTR __real@3ff0000000000000
	fmul	QWORD PTR _old_energy$[ebp]
	fcomp	QWORD PTR _web+1240
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@hessian_au

; 341  :   { kb_error(1596,"Hessian move would have raised energy.  Restoring coords.\n",
; 342  :           WARNING);

	push	2
	push	OFFSET ??_C@_0DL@JPBMOMJN@Hessian?5move?5would?5have?5raised?5e@
	push	1596					; 0000063cH
	call	_kb_error

; 343  :     restore_coords(&saved,SAVE_IN_ATTR);

	push	1
	push	OFFSET _saved
	call	_restore_coords
	add	esp, 20					; 00000014H
$LN1@hessian_au:

; 344  :   }
; 345  :   hessian_exit(X);

	mov	edx, DWORD PTR _X$[ebp]
	push	edx
	call	_hessian_exit

; 346  :   free_system(&S);

	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	call	_free_system

; 347  :   temp_free((char*)rhs);

	push	ebx
	call	_temp_free

; 348  :   temp_free((char*)X);

	mov	ecx, DWORD PTR _X$[ebp]
	push	ecx
	call	_temp_free
	add	esp, 16					; 00000010H
	pop	ebx

; 349  : 
; 350  : } // end hessian_auto()

	mov	esp, ebp
	pop	ebp
	ret	0
_hessian_auto ENDP
_TEXT	ENDS
PUBLIC	_hessian_seek
EXTRN	_star_metric_setup:PROC
EXTRN	_linear_metric_setup:PROC
; Function compile flags: /Ogtp
;	COMDAT _hessian_seek
_TEXT	SEGMENT
_S$ = -244						; size = 232
_best_scale$ = -12					; size = 8
_rhs$ = -8						; size = 4
_X$ = -4						; size = 4
_maxscale$ = 8						; size = 8
_hessian_seek PROC					; COMDAT

; 363  : { REAL best_scale;

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H

; 364  :   REAL *rhs=NULL,*X=NULL;
; 365  :   struct linsys S;
; 366  :  
; 367  :   hmode = hessian_normal_flag;

	mov	eax, DWORD PTR _hessian_normal_flag

; 368  :   hessian_init(&S,&rhs); 

	lea	ecx, DWORD PTR _rhs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	mov	DWORD PTR _rhs$[ebp], 0
	mov	DWORD PTR _X$[ebp], 0
	mov	DWORD PTR _hmode, eax
	call	_hessian_init

; 369  :   hess_flag = 1; rhs_flag = 1; 

	mov	eax, 1
	mov	DWORD PTR _hess_flag, eax
	mov	DWORD PTR _rhs_flag, eax

; 370  :   hessian_fill(&S,&rhs); 

	lea	eax, DWORD PTR _rhs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	_hessian_fill
	add	esp, 16					; 00000010H

; 371  :   if ( hessian_linear_metric_flag )

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $LN5@hessian_se

; 372  :     linear_metric_setup(&S,&Met);

	lea	edx, DWORD PTR _S$[ebp]
	push	OFFSET _Met
	push	edx
	call	_linear_metric_setup
	jmp	SHORT $LN8@hessian_se
$LN5@hessian_se:

; 373  :   else if ( web.area_norm_flag )

	cmp	DWORD PTR _web+876, 0
	je	SHORT $LN3@hessian_se

; 374  :     star_metric_setup(&S,&Met);

	lea	eax, DWORD PTR _S$[ebp]
	push	OFFSET _Met
	push	eax
	call	_star_metric_setup
$LN8@hessian_se:
	add	esp, 8
$LN3@hessian_se:
	push	esi

; 375  :   sp_Hessian_solver(&S,rhs,&X);

	mov	esi, DWORD PTR _rhs$[ebp]
	lea	ecx, DWORD PTR _X$[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$[ebp]
	push	esi
	push	edx
	call	_sp_Hessian_solver

; 376  :   best_scale = hessian_line_seek(&S,maxscale,X);

	fld	QWORD PTR _maxscale$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	add	esp, 12					; 0000000cH
	push	eax
	sub	esp, 8
	lea	ecx, DWORD PTR _S$[ebp]
	fstp	QWORD PTR [esp]
	push	ecx
	call	_hessian_line_seek
	fstp	QWORD PTR _best_scale$[ebp]

; 377  :   hessian_exit(X);

	mov	edx, DWORD PTR _X$[ebp]
	push	edx
	call	_hessian_exit

; 378  :   free_system(&S);

	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	call	_free_system
	add	esp, 24					; 00000018H

; 379  :   if ( hessian_linear_metric_flag || web.area_norm_flag ) free_system(&Met);

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN1@hessian_se
	cmp	DWORD PTR _web+876, 0
	je	SHORT $LN2@hessian_se
$LN1@hessian_se:
	push	OFFSET _Met
	call	_free_system
	add	esp, 4
$LN2@hessian_se:

; 380  :   temp_free((char*)rhs);

	push	esi
	call	_temp_free

; 381  :   temp_free((char*)X);

	mov	ecx, DWORD PTR _X$[ebp]
	push	ecx
	call	_temp_free

; 382  :   return best_scale;

	fld	QWORD PTR _best_scale$[ebp]
	add	esp, 8
	pop	esi

; 383  : 
; 384  : } // end hessian_seek()

	mov	esp, ebp
	pop	ebp
	ret	0
_hessian_seek ENDP
_TEXT	ENDS
PUBLIC	_square_grad_forces
; Function compile flags: /Ogtp
;	COMDAT _square_grad_forces
_TEXT	SEGMENT
_S$ = -236						; size = 232
_rhs$ = -4						; size = 4
_square_grad_forces PROC				; COMDAT

; 445  : { REAL *rhs=NULL,*X=NULL;

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH

; 446  :   struct linsys S;
; 447  :  
; 448  :   hmode = hessian_normal_flag;

	mov	eax, DWORD PTR _hessian_normal_flag
	push	ebx
	push	esi

; 449  :   hessian_init(&S,&rhs);

	lea	ecx, DWORD PTR _rhs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	mov	DWORD PTR _rhs$[ebp], 0
	mov	DWORD PTR _hmode, eax
	call	_hessian_init

; 450  :   hess_flag = 1; rhs_flag = 1; 
; 451  :   hessian_fill(&S,&rhs); 

	lea	eax, DWORD PTR _rhs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	mov	DWORD PTR _hess_flag, 1
	mov	DWORD PTR _rhs_flag, 1
	call	_hessian_fill

; 452  : 
; 453  :   /* ?
; 454  :   if ( hessian_linear_metric_flag )
; 455  :     linear_metric_setup(&S,&Met);
; 456  :   else if ( web.area_norm_flag )
; 457  :     star_metric_setup(&S,&Met);
; 458  :   */
; 459  : 
; 460  :   X = (REAL*)temp_calloc(S.N,sizeof(REAL));

	mov	edx, DWORD PTR _S$[ebp+4]
	push	460					; 000001ccH
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	8
	push	edx
	call	_kb_temp_calloc

; 461  :   sp_hessian_mult(&S,rhs,X);

	mov	ebx, DWORD PTR _rhs$[ebp]
	mov	esi, eax
	push	esi
	lea	eax, DWORD PTR _S$[ebp]
	push	ebx
	push	eax
	call	_sp_hessian_mult

; 462  :   hessian_iterate_flag = 1;
; 463  :   hessian_move(0,SET_VELOCITY,X);

	fldz
	add	esp, 44					; 0000002cH
	push	esi
	push	2
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR _hessian_iterate_flag, 1
	call	_hessian_move

; 464  :   hessian_iterate_flag = 0;
; 465  : 
; 466  :   hessian_exit(X);

	push	esi
	mov	DWORD PTR _hessian_iterate_flag, 0
	call	_hessian_exit

; 467  :   free_system(&S);

	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	_free_system
	add	esp, 24					; 00000018H

; 468  :   if ( hessian_linear_metric_flag || web.area_norm_flag ) free_system(&Met);

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN1@square_gra@2
	cmp	DWORD PTR _web+876, 0
	je	SHORT $LN2@square_gra@2
$LN1@square_gra@2:
	push	OFFSET _Met
	call	_free_system
	add	esp, 4
$LN2@square_gra@2:

; 469  :   temp_free((char*)rhs);

	push	ebx
	call	_temp_free

; 470  :   temp_free((char*)X);

	push	esi
	call	_temp_free
	add	esp, 8
	pop	esi
	pop	ebx

; 471  : 
; 472  : } // end square_grad_forces()

	mov	esp, ebp
	pop	ebp
	ret	0
_square_grad_forces ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@EIMIDHFM@1?4?5?$CFs?3?5?$CF17?415g?5energy?3?5?$CF17?415g?5?6@ ; `string'
PUBLIC	??_C@_0N@PAMCLMHF@stepsize?5?$CFg?6?$AA@	; `string'
PUBLIC	??_C@_0BK@IGPKNFNH@Lowest?5eigenvalue?5?$CF2?415g?6?$AA@ ; `string'
PUBLIC	??_C@_0CP@GHOMBEEF@Lowest?5eigenvalue?5?$CF2?415g?4?5Not?5a?5@ ; `string'
PUBLIC	_hessian_saddle
EXTRN	_reset_conj_grad:PROC
EXTRN	_update_display:PROC
EXTRN	_areaname:DWORD
EXTRN	_lowest_eigenpair:PROC
EXTRN	_sp_ordering_func:DWORD
EXTRN	_sp_constraint_setup_func:DWORD
EXTRN	_sp_AIJ_setup_func:DWORD
;	COMDAT ??_C@_0CB@EIMIDHFM@1?4?5?$CFs?3?5?$CF17?415g?5energy?3?5?$CF17?415g?5?6@
CONST	SEGMENT
??_C@_0CB@EIMIDHFM@1?4?5?$CFs?3?5?$CF17?415g?5energy?3?5?$CF17?415g?5?6@ DB '1'
	DB	'. %s: %17.15g energy: %17.15g ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PAMCLMHF@stepsize?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0N@PAMCLMHF@stepsize?5?$CFg?6?$AA@ DB 'stepsize %g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IGPKNFNH@Lowest?5eigenvalue?5?$CF2?415g?6?$AA@
CONST	SEGMENT
??_C@_0BK@IGPKNFNH@Lowest?5eigenvalue?5?$CF2?415g?6?$AA@ DB 'Lowest eigen'
	DB	'value %2.15g', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GHOMBEEF@Lowest?5eigenvalue?5?$CF2?415g?4?5Not?5a?5@
CONST	SEGMENT
??_C@_0CP@GHOMBEEF@Lowest?5eigenvalue?5?$CF2?415g?4?5Not?5a?5@ DB 'Lowest'
	DB	' eigenvalue %2.15g. Not a saddle point.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _hessian_saddle
_TEXT	SEGMENT
_S$ = -236						; size = 232
_rhs$ = -4						; size = 4
_maxscale$ = 8						; size = 8
_hessian_saddle PROC					; COMDAT

; 651  : { REAL low;

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH

; 652  :   REAL stepsize;
; 653  :   REAL *rhs=NULL,*X=NULL;
; 654  :   struct linsys S;
; 655  : 
; 656  :   hmode = hessian_normal_flag;

	mov	eax, DWORD PTR _hessian_normal_flag

; 657  :   hessian_init(&S,&rhs);

	lea	ecx, DWORD PTR _rhs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	mov	DWORD PTR _rhs$[ebp], 0
	mov	DWORD PTR _hmode, eax
	call	_hessian_init

; 658  :   hess_flag = 1; rhs_flag = 1; 

	mov	eax, 1
	mov	DWORD PTR _hess_flag, eax
	mov	DWORD PTR _rhs_flag, eax

; 659  :   hessian_fill(&S,&rhs); 

	lea	eax, DWORD PTR _rhs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	_hessian_fill

; 660  :   (*sp_AIJ_setup_func)(S.A_rows,&S);

	mov	eax, DWORD PTR _S$[ebp+12]
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	push	eax
	call	DWORD PTR _sp_AIJ_setup_func

; 661  :   (*sp_constraint_setup_func)
; 662  :          (web.skel[BODY].max_ord+1 + gen_quant_count,&S);

	mov	edx, DWORD PTR _web+404
	mov	eax, DWORD PTR _web+5528
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	lea	ecx, DWORD PTR [eax+edx+1]
	push	ecx
	call	DWORD PTR _sp_constraint_setup_func

; 663  :   if ( sp_ordering_func ) (*sp_ordering_func)(&S);

	mov	eax, DWORD PTR _sp_ordering_func
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN7@hessian_sa
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	call	eax
	add	esp, 4
$LN7@hessian_sa:

; 664  :   if ( hessian_linear_metric_flag )

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $LN6@hessian_sa

; 665  :      { 
; 666  :        linear_metric_setup(&S,&Met);

	lea	eax, DWORD PTR _S$[ebp]
	push	OFFSET _Met
	push	eax
	call	_linear_metric_setup
	jmp	SHORT $LN13@hessian_sa
$LN6@hessian_sa:

; 667  :      }
; 668  :   else if ( web.area_norm_flag )

	cmp	DWORD PTR _web+876, 0
	je	SHORT $LN4@hessian_sa

; 669  :      { 
; 670  :        star_metric_setup(&S,&Met);

	lea	ecx, DWORD PTR _S$[ebp]
	push	OFFSET _Met
	push	ecx
	call	_star_metric_setup
$LN13@hessian_sa:
	add	esp, 8
$LN4@hessian_sa:

; 671  :      }
; 672  : 
; 673  :   X = (REAL*)temp_calloc(S.N+S.concount,sizeof(REAL));

	mov	edx, DWORD PTR _S$[ebp+144]
	add	edx, DWORD PTR _S$[ebp+4]
	push	esi
	push	673					; 000002a1H
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	8
	push	edx
	call	_kb_temp_calloc
	mov	esi, eax

; 674  :   low =  lowest_eigenpair(&S,X);

	lea	ecx, DWORD PTR _S$[ebp]
	push	esi
	push	ecx
	call	_lowest_eigenpair

; 675  :   if ( low >= 0.0 )

	fldz
	fcomp	ST(1)
	add	esp, 24					; 00000018H

; 676  :      { 
; 677  : #ifdef FLOAT128
; 678  :         sprintf(msg,"Lowest eigenvalue %2.*Qg. Not a saddle point.\n",DPREC,low); 
; 679  : #elif defined(LONGDOUBLE)
; 680  :         sprintf(msg,"Lowest eigenvalue %2.*Lg. Not a saddle point.\n",DPREC,low); 
; 681  : #else
; 682  :         sprintf(msg,"Lowest eigenvalue %2.15g. Not a saddle point.\n",low); 

	sub	esp, 8
	fnstsw	ax
	fstp	QWORD PTR [esp]
	test	ah, 65					; 00000041H
	jp	SHORT $LN3@hessian_sa
	mov	edx, DWORD PTR _msg
	push	OFFSET ??_C@_0CP@GHOMBEEF@Lowest?5eigenvalue?5?$CF2?415g?4?5Not?5a?5@
	push	edx
	call	_sprintf

; 683  : #endif 
; 684  :         outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H

; 685  :         goto saddle_exit;

	jmp	$saddle_exit$89543
$LN3@hessian_sa:

; 686  :      }
; 687  : #ifdef FLOAT128
; 688  :   sprintf(msg,"Lowest eigenvalue %2.*Qg\n",DPREC,low);
; 689  : #elif defined(LONGDOUBLE)
; 690  :   sprintf(msg,"Lowest eigenvalue %2.*Lg\n",DPREC,low);
; 691  : #else
; 692  :   sprintf(msg,"Lowest eigenvalue %2.15g\n",low);

	mov	ecx, DWORD PTR _msg
	push	OFFSET ??_C@_0BK@IGPKNFNH@Lowest?5eigenvalue?5?$CF2?415g?6?$AA@
	push	ecx
	call	_sprintf

; 693  : #endif 
; 694  :   outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 695  :   stepsize = hessian_line_seek(&S,maxscale,X);

	fld	QWORD PTR _maxscale$[ebp]
	add	esp, 20					; 00000014H
	push	esi
	sub	esp, 8
	lea	eax, DWORD PTR _S$[ebp]
	fstp	QWORD PTR [esp]
	push	eax
	call	_hessian_line_seek

; 696  :   sprintf(msg,"stepsize %g\n",(DOUBLE)stepsize);

	fstp	QWORD PTR [esp+8]
	mov	ecx, DWORD PTR _msg
	add	esp, 8
	push	OFFSET ??_C@_0N@PAMCLMHF@stepsize?5?$CFg?6?$AA@
	push	ecx
	call	_sprintf

; 697  :   outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 698  : #ifdef FLOAT128
; 699  :   sprintf(msg,"1.  energy: %17.*Qg \n", DPREC,web.total_energy);
; 700  : #elif defined(LONGDOUBLE)
; 701  :   sprintf(msg,"1.  energy: %17.*Lg \n", DPREC,web.total_energy);
; 702  : #else
; 703  :   sprintf(msg,"1. %s: %17.15g energy: %17.15g \n",
; 704  :                 areaname,web.total_area,web.total_energy);

	fld	QWORD PTR _web+1240
	mov	eax, DWORD PTR _areaname
	fstp	QWORD PTR [esp+12]
	fld	QWORD PTR _web+992
	mov	ecx, DWORD PTR _msg
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	eax
	push	OFFSET ??_C@_0CB@EIMIDHFM@1?4?5?$CFs?3?5?$CF17?415g?5energy?3?5?$CF17?415g?5?6@
	push	ecx
	call	_sprintf

; 705  : #endif 
; 706  :   outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 32					; 00000020H

; 707  :   update_display();

	call	_update_display

; 708  :   reset_conj_grad();

	call	_reset_conj_grad
$saddle_exit$89543:

; 709  : saddle_exit:
; 710  :   hessian_exit(X); /* cleanup */

	push	esi
	call	_hessian_exit

; 711  :   free_system(&S);

	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	call	_free_system
	add	esp, 8

; 712  :   if ( hessian_linear_metric_flag || web.area_norm_flag ) free_system(&Met);

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN1@hessian_sa
	cmp	DWORD PTR _web+876, 0
	je	SHORT $LN2@hessian_sa
$LN1@hessian_sa:
	push	OFFSET _Met
	call	_free_system
	add	esp, 4
$LN2@hessian_sa:

; 713  :   temp_free((char*)rhs);

	mov	ecx, DWORD PTR _rhs$[ebp]
	push	ecx
	call	_temp_free

; 714  :   temp_free((char*)X);

	push	esi
	call	_temp_free
	add	esp, 8
	pop	esi

; 715  : } /* end hessian_saddle() */

	mov	esp, ebp
	pop	ebp
	ret	0
_hessian_saddle ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@GAGBKKBE@Illegal?5choice?4?6?$AA@	; `string'
PUBLIC	??_C@_0BL@GDGKLNK@?5?5?5?$CFsx?5?$DN?5invH?5?4?5?$CFsRHS?$DL?6?$FN?$DL?6?$AA@ ; `string'
PUBLIC	??_C@_0P@DMJEFINF@?5?5?5?$CI?$CK?5else?5?$CK?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0DK@EAHBBGHF@?5?5?5?$CFsx?5?$DN?5?$CI?5invH?5?4?5?$CFsRHS?$CJ?5?9?5?$CITran@ ; `string'
PUBLIC	??_C@_0CJ@IHFCIBCD@?5?5?5gamma?5?$DN?5cthinvcinv?5?4?5cthinv?5?4@ ; `string'
PUBLIC	??_C@_0CD@DIPFIJHI@?5?5?5cthinvcinv?5?$DN?5Inverse?$FLcthinvc?$FN@ ; `string'
PUBLIC	??_C@_0CH@HFGGDBDO@?5?5?5cthinvc?5?$DN?5cthinv?5?4?5Transpose?$FL@ ; `string'
PUBLIC	??_C@_0BJ@FDDAHBAB@?5?5?5cthinv?5?$DN?5?$CFsC?5?4?5invH?$DL?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@GMKHIPMI@If?$FLLength?$FL?$CFsC?$FN?5?$DO?50?0?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@JFEILLGB@invH?5?$DN?5Inverse?$FLh?$FN?$DL?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@IKLGBGDK@For?$FLn?$DN1?0n?$DM?$DNLength?$FL?$CFsH?$FN?0n?$CL?$CL?0h?$FL?$FLn?0@ ; `string'
PUBLIC	??_C@_0BL@COMGBIHK@h?5?$DN?5?$CFsH?5?$CL?5Transpose?$FL?$CFsH?$FN?$DL?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@GHCDBMBC@?$CI?$CK?5get?5both?5halves?5of?5H?5?$CK?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@HBKDMHCF@?$CI?$CK?5Solving?5constrained?5Hessian?5?$CK@ ; `string'
PUBLIC	??_C@_08FNNCFELH@?6?$CFsS?5?$DN?5?$HL?$AA@	; `string'
PUBLIC	??_C@_0CB@BKEBKIBO@Dumping?5solution?5to?5vector?5?$CFsS?4?6@ ; `string'
PUBLIC	??_C@_03IOBBOKCP@?6?$CFd?$AA@			; `string'
PUBLIC	??_C@_08NLEGCGBJ@?6?$CFsP?5?$DN?5?$HL?$AA@	; `string'
PUBLIC	??_C@_0CE@FGHLLAAO@Dumping?5permutation?5to?5vector?5?$CFs@ ; `string'
PUBLIC	??_C@_0BF@KCNMOPPD@?6?$CFsC?5?$DN?5SparseArray?$FL?$HL?$AA@ ; `string'
PUBLIC	??_C@_0CI@GFBPNNCD@Dumping?5constraint?5matrix?5to?5arr@ ; `string'
PUBLIC	??_C@_0BB@MIOEIIEK@?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@ ; `string'
PUBLIC	??_C@_0BD@CCENDDHH@?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?0?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@KAIFMBKL@?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?0?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@EDPCOFJH@?6?$CFsD?5?$DN?5SparseArray?$FL?$HL?$AA@ ; `string'
PUBLIC	??_C@_0CH@LPPKGEM@Dumping?5diagonal?5factor?5to?5array@ ; `string'
PUBLIC	??_C@_0BD@PMLBDGE@?0?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@ ; `string'
PUBLIC	??_C@_0BF@FEKDELJL@?6?$CFsL?5?$DN?5SparseArray?$FL?$HL?$AA@ ; `string'
PUBLIC	??_C@_0CA@DOJIMNCP@Dumping?5L?5factor?5to?5array?5?$CFsL?4?6?$AA@ ; `string'
PUBLIC	??_C@_03JFDPLKFJ@?$HN?$DL?6?$AA@		; `string'
PUBLIC	??_C@_08NEEHBPF@?6?$CF17?415f?$AA@		; `string'
PUBLIC	??_C@_0M@FFCADFPL@?6?5?$CFsRHS?5?$DN?5?$HL?$AA@	; `string'
PUBLIC	??_C@_0CK@HNILOEID@Dumping?5right?5hand?5side?5to?5vecto@ ; `string'
PUBLIC	??_C@_0BG@JDDBELEC@?6?5?$CFsM?5?$DN?5SparseArray?$FL?$HL?$AA@ ; `string'
PUBLIC	??_C@_0DF@MEGEBEKI@Dumping?5Hessian?5metric?5upper?5tri@ ; `string'
PUBLIC	??_C@_0N@CPFNMDOB@?$HN?0?$HL?$CFd?0?$CFd?$HN?$FN?$DL?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@HEJFHDDF@?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@ ; `string'
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
PUBLIC	??_C@_0BE@NAOMMKJA@?$CFsH?5?$DN?5SparseArray?$FL?$HL?$AA@ ; `string'
PUBLIC	??_C@_0CO@HNNPEHDN@Dumping?5Hessian?5upper?5triangle?5t@ ; `string'
PUBLIC	??_C@_0DG@FHAHJGJH@Mathematica?5names?5must?5have?5only@ ; `string'
PUBLIC	??_C@_0CL@BHLGBODB@Mathematica?5names?5must?5start?5wit@ ; `string'
PUBLIC	??_C@_0BN@GNGDDCN@Enter?5base?5name?5for?5arrays?3?5?$AA@ ; `string'
PUBLIC	??_C@_0BB@LODAAEGK@Enter?5filename?3?5?$AA@	; `string'
PUBLIC	??_C@_0CM@OLLMODMJ@Hessian?5dump?5in?5Mathematica?5spar@ ; `string'
PUBLIC	??_C@_0CA@GCAAOKAE@Dumping?5solution?5vector?5to?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0O@KNJFMHPI@_solution?4dat?$AA@		; `string'
PUBLIC	??_C@_03GICAEIGO@?$CF6d?$AA@			; `string'
PUBLIC	??_C@_0CP@KHFHKCOA@Dumping?5permutation?5in?5one?5line?5@ ; `string'
PUBLIC	??_C@_06HDHDFNPM@_P?4dat?$AA@			; `string'
PUBLIC	??_C@_0DK@KGGNGGBI@Dumping?5constraint?5matrix?5in?5row@ ; `string'
PUBLIC	??_C@_06PGDBCNMJ@_C?4dat?$AA@			; `string'
PUBLIC	??_C@_0DI@OCIBNFFO@Dumping?5diagonal?5factor?5in?5row?5c@ ; `string'
PUBLIC	??_C@_06OLDEBNHB@_D?4dat?$AA@			; `string'
PUBLIC	??_C@_0DB@HCNMBGLI@Dumping?5L?5factor?5in?5row?5col?5valu@ ; `string'
PUBLIC	??_C@_06HGHJPBM@_L?4dat?$AA@			; `string'
PUBLIC	??_C@_0DH@CGFLGEDD@Need?5to?5do?5step?53?0?5P?0?5V?0?5or?5Z?5be@ ; `string'
PUBLIC	??_C@_0EE@NENMBAIG@Further?5dumping?5of?5factors?5in?5mi@ ; `string'
PUBLIC	??_C@_08GOLMHPBE@?$CF20?415f?6?$AA@		; `string'
PUBLIC	??_C@_0CA@DOOHECOM@Dumping?5right?5hand?5side?5to?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_08KHHEGCCC@_rhs?4dat?$AA@			; `string'
PUBLIC	??_C@_0EG@IIMCAMAE@Dumping?5Hessian?5metric?5upper?5tri@ ; `string'
PUBLIC	??_C@_06MMDLEMLJ@_M?4dat?$AA@			; `string'
PUBLIC	??_C@_0BB@MGONLNEG@?$CF6d?5?$CF6d?5?$CF20?415f?6?$AA@ ; `string'
PUBLIC	??_C@_0DP@GHCEOKCM@Dumping?5Hessian?5upper?5triangle?5i@ ; `string'
PUBLIC	??_C@_06JMPGNNAK@_H?4dat?$AA@			; `string'
PUBLIC	??_C@_0DB@FLPHPIAP@Enter?5path?5and?5base?5name?5of?5Hess@ ; `string'
PUBLIC	??_C@_0CJ@OOJNHDJC@Hessian?5dump?4?5Note?5indexing?5is?51@ ; `string'
PUBLIC	??_C@_0DB@PIKAKACN@Need?5to?5do?5step?51?5first?5before?5d@ ; `string'
PUBLIC	??_C@_0CE@IDHGJPPA@Minimizing?5regular?5energy?5in?5see@ ; `string'
PUBLIC	??_C@_0CF@EMGEJCJA@Minimizing?5square?5gradient?5in?5se@ ; `string'
PUBLIC	??_C@_0CM@NMONBFB@Not?5projecting?5global?5constraint@ ; `string'
PUBLIC	??_C@_0CI@JNHOPMJO@Projecting?5global?5constraints?5in@ ; `string'
PUBLIC	??_C@_0DE@NBALCHDO@Using?5non?9Bunch?9Kaufman?5version?5@ ; `string'
PUBLIC	??_C@_0DA@HPHGACOG@Using?5Bunch?9Kaufman?5version?5of?5m@ ; `string'
PUBLIC	??_C@_0N@NDMLKFJ@Using?5YSMP?4?6?$AA@		; `string'
PUBLIC	??_C@_0BH@EPNIGAFB@Must?5do?5step?51?5again?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CL@FCGKHGED@Using?5alternate?5minimal?5degree?5f@ ; `string'
PUBLIC	??_C@_0CC@GMPCAKGN@Error?3?5Must?5get?5direction?5first?4@ ; `string'
PUBLIC	??_C@_0N@MLAFAOKO@?$CFd?5?5?$CF20?415f?6?$AA@	; `string'
PUBLIC	??_C@_0CE@JNGKEIFD@Error?3?5Invalid?5eigenvector?5numbe@ ; `string'
PUBLIC	??_C@_0BP@DHLDIAGC@Eigenvector?5number?5?$CI1?5to?5?$CFd?$CJ?3?5?$AA@ ; `string'
PUBLIC	??_C@_0BO@PIPPHMCA@Error?3?5Must?5do?5step?5Z?5first?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DA@NKKPEDBD@Error?3?5Number?5of?5eigenvalues?5mus@ ; `string'
PUBLIC	??_C@_0BI@JPMIFIJK@Number?5of?5eigenvalues?3?5?$AA@ ; `string'
PUBLIC	??_C@_0BD@MKJBDOHJ@Ritz?5probe?5value?3?5?$AA@	; `string'
PUBLIC	??_C@_0BE@NNJEGLLG@Hessian?5debug?5OFF?4?6?$AA@	; `string'
PUBLIC	??_C@_0BD@LFKMFKA@Hessian?5debug?5ON?4?6?$AA@	; `string'
PUBLIC	??_C@_0BK@JLIMGEEC@hessian_menu?5subcommand?3?5?$AA@ ; `string'
PUBLIC	??_C@_0CB@JFBDGLHP@1?4?5?$CFs?3?5?$CF17?415f?5energy?3?5?$CF17?415f?5?6@ ; `string'
PUBLIC	??_C@_0M@EOLGNBDF@Step?5size?3?5?$AA@		; `string'
PUBLIC	??_C@_0CN@GENPMKBC@Error?3?5Must?5do?5step?53?0V?0E?0F?0C?0B?5@ ; `string'
PUBLIC	??_C@_0BA@LLLFLHN@Motion?5found?4?5?6?$AA@	; `string'
PUBLIC	??_C@_0CE@OEBIHIGH@Motion?5found?4?5?5Pressures?5adjuste@ ; `string'
PUBLIC	??_C@_0BO@DKMPDIKE@Error?3?5Must?5do?5step?52?5first?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@EGCGMJAF@RHS?5norm?3?5?$CF20?415g?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@HBCFMACC@B?$FL?$CFd?$FN?5?5?$CF20?415f?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@ ; `string'
PUBLIC	??_C@_0EA@JNPGEMLK@Choice?$CI?$DP?01?02?03?04?07?09?0B?0C?0E?0F?0L?0R@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_hessian_menu
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_BK_flag:DWORD
EXTRN	_ysmp_solve_multi:PROC
EXTRN	_ysmp_solve:PROC
EXTRN	_ysmp_factor:PROC
EXTRN	_sp_CHinvC:PROC
EXTRN	_sp_CHinvC_func:DWORD
EXTRN	_xmd_solve_multi:PROC
EXTRN	_sp_solve_multi_func:DWORD
EXTRN	_xmd_solve:PROC
EXTRN	_sp_solve_func:DWORD
EXTRN	_xmd_factor:PROC
EXTRN	_sp_factor_func:DWORD
EXTRN	_ysmp_flag:DWORD
EXTRN	_BK_hess_project_setup:PROC
EXTRN	_bk_constraint_setup:PROC
EXTRN	_bk_AIJ_setup:PROC
EXTRN	_bk_mul:PROC
EXTRN	_sp_mul_func:DWORD
EXTRN	_cg_lowest_eigenpair:PROC
EXTRN	_old_cg_lowest_eigenpair:PROC
EXTRN	_bk_inverse_it:PROC
EXTRN	_bk_eigenprobe:PROC
EXTRN	_chebychev_hess:PROC
EXTRN	_chebychev_ev:PROC
EXTRN	_selective_lanczos:PROC
EXTRN	_lanczos:PROC
EXTRN	_isdigit:PROC
EXTRN	_strchr:PROC
EXTRN	_kb_lower_array:BYTE
EXTRN	_do_ritz:PROC
EXTRN	_atoi:PROC
EXTRN	_do_multigrid:PROC
EXTRN	_exec_commands:PROC
EXTRN	_hessian_subshell_flag:DWORD
EXTRN	_jumpbuf:BYTE
EXTRN	_subshell_depth:DWORD
EXTRN	_atof:PROC
EXTRN	_sp_hessian_solve:PROC
EXTRN	_sp_hess_project_setup_func:DWORD
EXTRN	_sp_factor:PROC
EXTRN	_kb_upper_array:BYTE
EXTRN	__setjmp3:PROC
_BSS	SEGMENT
_ritzdim DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BB@GAGBKKBE@Illegal?5choice?4?6?$AA@
CONST	SEGMENT
??_C@_0BB@GAGBKKBE@Illegal?5choice?4?6?$AA@ DB 'Illegal choice.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GDGKLNK@?5?5?5?$CFsx?5?$DN?5invH?5?4?5?$CFsRHS?$DL?6?$FN?$DL?6?$AA@
CONST	SEGMENT
??_C@_0BL@GDGKLNK@?5?5?5?$CFsx?5?$DN?5invH?5?4?5?$CFsRHS?$DL?6?$FN?$DL?6?$AA@ DB ' '
	DB	'  %sx = invH . %sRHS;', 0aH, '];', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DMJEFINF@?5?5?5?$CI?$CK?5else?5?$CK?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0P@DMJEFINF@?5?5?5?$CI?$CK?5else?5?$CK?$CJ?6?$AA@ DB '   (* else *)'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@EAHBBGHF@?5?5?5?$CFsx?5?$DN?5?$CI?5invH?5?4?5?$CFsRHS?$CJ?5?9?5?$CITran@
CONST	SEGMENT
??_C@_0DK@EAHBBGHF@?5?5?5?$CFsx?5?$DN?5?$CI?5invH?5?4?5?$CFsRHS?$CJ?5?9?5?$CITran@ DB ' '
	DB	'  %sx = ( invH . %sRHS) - (Transpose[cthinv] . gamma);,', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IHFCIBCD@?5?5?5gamma?5?$DN?5cthinvcinv?5?4?5cthinv?5?4@
CONST	SEGMENT
??_C@_0CJ@IHFCIBCD@?5?5?5gamma?5?$DN?5cthinvcinv?5?4?5cthinv?5?4@ DB '   '
	DB	'gamma = cthinvcinv . cthinv . %sRHS;', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DIPFIJHI@?5?5?5cthinvcinv?5?$DN?5Inverse?$FLcthinvc?$FN@
CONST	SEGMENT
??_C@_0CD@DIPFIJHI@?5?5?5cthinvcinv?5?$DN?5Inverse?$FLcthinvc?$FN@ DB '  '
	DB	' cthinvcinv = Inverse[cthinvc];', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HFGGDBDO@?5?5?5cthinvc?5?$DN?5cthinv?5?4?5Transpose?$FL@
CONST	SEGMENT
??_C@_0CH@HFGGDBDO@?5?5?5cthinvc?5?$DN?5cthinv?5?4?5Transpose?$FL@ DB '  '
	DB	' cthinvc = cthinv . Transpose[%sC];', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FDDAHBAB@?5?5?5cthinv?5?$DN?5?$CFsC?5?4?5invH?$DL?6?$AA@
CONST	SEGMENT
??_C@_0BJ@FDDAHBAB@?5?5?5cthinv?5?$DN?5?$CFsC?5?4?5invH?$DL?6?$AA@ DB '  '
	DB	' cthinv = %sC . invH;', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GMKHIPMI@If?$FLLength?$FL?$CFsC?$FN?5?$DO?50?0?6?$AA@
CONST	SEGMENT
??_C@_0BF@GMKHIPMI@If?$FLLength?$FL?$CFsC?$FN?5?$DO?50?0?6?$AA@ DB 'If[Le'
	DB	'ngth[%sC] > 0,', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JFEILLGB@invH?5?$DN?5Inverse?$FLh?$FN?$DL?6?$AA@
CONST	SEGMENT
??_C@_0BE@JFEILLGB@invH?5?$DN?5Inverse?$FLh?$FN?$DL?6?$AA@ DB 'invH = Inv'
	DB	'erse[h];', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IKLGBGDK@For?$FLn?$DN1?0n?$DM?$DNLength?$FL?$CFsH?$FN?0n?$CL?$CL?0h?$FL?$FLn?0@
CONST	SEGMENT
??_C@_0CN@IKLGBGDK@For?$FLn?$DN1?0n?$DM?$DNLength?$FL?$CFsH?$FN?0n?$CL?$CL?0h?$FL?$FLn?0@ DB 'F'
	DB	'or[n=1,n<=Length[%sH],n++,h[[n,n]] /= 2;];', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@COMGBIHK@h?5?$DN?5?$CFsH?5?$CL?5Transpose?$FL?$CFsH?$FN?$DL?6?$AA@
CONST	SEGMENT
??_C@_0BL@COMGBIHK@h?5?$DN?5?$CFsH?5?$CL?5Transpose?$FL?$CFsH?$FN?$DL?6?$AA@ DB 'h'
	DB	' = %sH + Transpose[%sH];', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GHCDBMBC@?$CI?$CK?5get?5both?5halves?5of?5H?5?$CK?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BM@GHCDBMBC@?$CI?$CK?5get?5both?5halves?5of?5H?5?$CK?$CJ?6?$AA@ DB '('
	DB	'* get both halves of H *)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HBKDMHCF@?$CI?$CK?5Solving?5constrained?5Hessian?5?$CK@
CONST	SEGMENT
??_C@_0CD@HBKDMHCF@?$CI?$CK?5Solving?5constrained?5Hessian?5?$CK@ DB '(* '
	DB	'Solving constrained Hessian *)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FNNCFELH@?6?$CFsS?5?$DN?5?$HL?$AA@
CONST	SEGMENT
??_C@_08FNNCFELH@?6?$CFsS?5?$DN?5?$HL?$AA@ DB 0aH, '%sS = {', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BKEBKIBO@Dumping?5solution?5to?5vector?5?$CFsS?4?6@
CONST	SEGMENT
??_C@_0CB@BKEBKIBO@Dumping?5solution?5to?5vector?5?$CFsS?4?6@ DB 'Dumping'
	DB	' solution to vector %sS.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IOBBOKCP@?6?$CFd?$AA@
CONST	SEGMENT
??_C@_03IOBBOKCP@?6?$CFd?$AA@ DB 0aH, '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLEGCGBJ@?6?$CFsP?5?$DN?5?$HL?$AA@
CONST	SEGMENT
??_C@_08NLEGCGBJ@?6?$CFsP?5?$DN?5?$HL?$AA@ DB 0aH, '%sP = {', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FGHLLAAO@Dumping?5permutation?5to?5vector?5?$CFs@
CONST	SEGMENT
??_C@_0CE@FGHLLAAO@Dumping?5permutation?5to?5vector?5?$CFs@ DB 'Dumping p'
	DB	'ermutation to vector %sP.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KCNMOPPD@?6?$CFsC?5?$DN?5SparseArray?$FL?$HL?$AA@
CONST	SEGMENT
??_C@_0BF@KCNMOPPD@?6?$CFsC?5?$DN?5SparseArray?$FL?$HL?$AA@ DB 0aH, '%sC '
	DB	'= SparseArray[{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GFBPNNCD@Dumping?5constraint?5matrix?5to?5arr@
CONST	SEGMENT
??_C@_0CI@GFBPNNCD@Dumping?5constraint?5matrix?5to?5arr@ DB 'Dumping cons'
	DB	'traint matrix to array %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MIOEIIEK@?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@
CONST	SEGMENT
??_C@_0BB@MIOEIIEK@?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@ DB '{%d,%d}'
	DB	'->%17.15f', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CCENDDHH@?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?0?6?$AA@
CONST	SEGMENT
??_C@_0BD@CCENDDHH@?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?0?6?$AA@ DB '{%d'
	DB	',%d}->%17.15f,', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KAIFMBKL@?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?0?6?$AA@
CONST	SEGMENT
??_C@_0BE@KAIFMBKL@?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?0?6?$AA@ DB 0aH
	DB	'{%d,%d}->%17.15f,', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EDPCOFJH@?6?$CFsD?5?$DN?5SparseArray?$FL?$HL?$AA@
CONST	SEGMENT
??_C@_0BF@EDPCOFJH@?6?$CFsD?5?$DN?5SparseArray?$FL?$HL?$AA@ DB 0aH, '%sD '
	DB	'= SparseArray[{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LPPKGEM@Dumping?5diagonal?5factor?5to?5array@
CONST	SEGMENT
??_C@_0CH@LPPKGEM@Dumping?5diagonal?5factor?5to?5array@ DB 'Dumping diago'
	DB	'nal factor to array %sD.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PMLBDGE@?0?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@
CONST	SEGMENT
??_C@_0BD@PMLBDGE@?0?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@ DB ',', 0aH
	DB	'{%d,%d}->%17.15f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FEKDELJL@?6?$CFsL?5?$DN?5SparseArray?$FL?$HL?$AA@
CONST	SEGMENT
??_C@_0BF@FEKDELJL@?6?$CFsL?5?$DN?5SparseArray?$FL?$HL?$AA@ DB 0aH, '%sL '
	DB	'= SparseArray[{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DOJIMNCP@Dumping?5L?5factor?5to?5array?5?$CFsL?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@DOJIMNCP@Dumping?5L?5factor?5to?5array?5?$CFsL?4?6?$AA@ DB 'Dum'
	DB	'ping L factor to array %sL.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03JFDPLKFJ@?$HN?$DL?6?$AA@
CONST	SEGMENT
??_C@_03JFDPLKFJ@?$HN?$DL?6?$AA@ DB '};', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NEEHBPF@?6?$CF17?415f?$AA@
CONST	SEGMENT
??_C@_08NEEHBPF@?6?$CF17?415f?$AA@ DB 0aH, '%17.15f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FFCADFPL@?6?5?$CFsRHS?5?$DN?5?$HL?$AA@
CONST	SEGMENT
??_C@_0M@FFCADFPL@?6?5?$CFsRHS?5?$DN?5?$HL?$AA@ DB 0aH, ' %sRHS = {', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@HNILOEID@Dumping?5right?5hand?5side?5to?5vecto@
CONST	SEGMENT
??_C@_0CK@HNILOEID@Dumping?5right?5hand?5side?5to?5vecto@ DB 'Dumping rig'
	DB	'ht hand side to vector %sRHS.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JDDBELEC@?6?5?$CFsM?5?$DN?5SparseArray?$FL?$HL?$AA@
CONST	SEGMENT
??_C@_0BG@JDDBELEC@?6?5?$CFsM?5?$DN?5SparseArray?$FL?$HL?$AA@ DB 0aH, ' %'
	DB	'sM = SparseArray[{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@MEGEBEKI@Dumping?5Hessian?5metric?5upper?5tri@
CONST	SEGMENT
??_C@_0DF@MEGEBEKI@Dumping?5Hessian?5metric?5upper?5tri@ DB 'Dumping Hess'
	DB	'ian metric upper triangle to array %sM.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CPFNMDOB@?$HN?0?$HL?$CFd?0?$CFd?$HN?$FN?$DL?6?$AA@
CONST	SEGMENT
??_C@_0N@CPFNMDOB@?$HN?0?$HL?$CFd?0?$CFd?$HN?$FN?$DL?6?$AA@ DB '},{%d,%d}'
	DB	'];', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HEJFHDDF@?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@
CONST	SEGMENT
??_C@_0BC@HEJFHDDF@?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@ DB 0aH, '{'
	DB	'%d,%d}->%17.15f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NAOMMKJA@?$CFsH?5?$DN?5SparseArray?$FL?$HL?$AA@
CONST	SEGMENT
??_C@_0BE@NAOMMKJA@?$CFsH?5?$DN?5SparseArray?$FL?$HL?$AA@ DB '%sH = Spars'
	DB	'eArray[{', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HNNPEHDN@Dumping?5Hessian?5upper?5triangle?5t@
CONST	SEGMENT
??_C@_0CO@HNNPEHDN@Dumping?5Hessian?5upper?5triangle?5t@ DB 'Dumping Hess'
	DB	'ian upper triangle to array %sH.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@FHAHJGJH@Mathematica?5names?5must?5have?5only@
CONST	SEGMENT
??_C@_0DG@FHAHJGJH@Mathematica?5names?5must?5have?5only@ DB 'Mathematica '
	DB	'names must have only letters and digits.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BHLGBODB@Mathematica?5names?5must?5start?5wit@
CONST	SEGMENT
??_C@_0CL@BHLGBODB@Mathematica?5names?5must?5start?5wit@ DB 'Mathematica '
	DB	'names must start with letter.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GNGDDCN@Enter?5base?5name?5for?5arrays?3?5?$AA@
CONST	SEGMENT
??_C@_0BN@GNGDDCN@Enter?5base?5name?5for?5arrays?3?5?$AA@ DB 'Enter base '
	DB	'name for arrays: ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LODAAEGK@Enter?5filename?3?5?$AA@
CONST	SEGMENT
??_C@_0BB@LODAAEGK@Enter?5filename?3?5?$AA@ DB 'Enter filename: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OLLMODMJ@Hessian?5dump?5in?5Mathematica?5spar@
CONST	SEGMENT
??_C@_0CM@OLLMODMJ@Hessian?5dump?5in?5Mathematica?5spar@ DB 'Hessian dump'
	DB	' in Mathematica sparse format.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GCAAOKAE@Dumping?5solution?5vector?5to?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@GCAAOKAE@Dumping?5solution?5vector?5to?5?$CFs?4?6?$AA@ DB 'Dump'
	DB	'ing solution vector to %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KNJFMHPI@_solution?4dat?$AA@
CONST	SEGMENT
??_C@_0O@KNJFMHPI@_solution?4dat?$AA@ DB '_solution.dat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GICAEIGO@?$CF6d?$AA@
CONST	SEGMENT
??_C@_03GICAEIGO@?$CF6d?$AA@ DB '%6d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@KHFHKCOA@Dumping?5permutation?5in?5one?5line?5@
CONST	SEGMENT
??_C@_0CP@KHFHKCOA@Dumping?5permutation?5in?5one?5line?5@ DB 'Dumping per'
	DB	'mutation in one line format to %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HDHDFNPM@_P?4dat?$AA@
CONST	SEGMENT
??_C@_06HDHDFNPM@_P?4dat?$AA@ DB '_P.dat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@KGGNGGBI@Dumping?5constraint?5matrix?5in?5row@
CONST	SEGMENT
??_C@_0DK@KGGNGGBI@Dumping?5constraint?5matrix?5in?5row@ DB 'Dumping cons'
	DB	'traint matrix in row col value format to %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PGDBCNMJ@_C?4dat?$AA@
CONST	SEGMENT
??_C@_06PGDBCNMJ@_C?4dat?$AA@ DB '_C.dat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@OCIBNFFO@Dumping?5diagonal?5factor?5in?5row?5c@
CONST	SEGMENT
??_C@_0DI@OCIBNFFO@Dumping?5diagonal?5factor?5in?5row?5c@ DB 'Dumping dia'
	DB	'gonal factor in row col value format to %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OLDEBNHB@_D?4dat?$AA@
CONST	SEGMENT
??_C@_06OLDEBNHB@_D?4dat?$AA@ DB '_D.dat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HCNMBGLI@Dumping?5L?5factor?5in?5row?5col?5valu@
CONST	SEGMENT
??_C@_0DB@HCNMBGLI@Dumping?5L?5factor?5in?5row?5col?5valu@ DB 'Dumping L '
	DB	'factor in row col value format to %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HGHJPBM@_L?4dat?$AA@
CONST	SEGMENT
??_C@_06HGHJPBM@_L?4dat?$AA@ DB '_L.dat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@CGFLGEDD@Need?5to?5do?5step?53?0?5P?0?5V?0?5or?5Z?5be@
CONST	SEGMENT
??_C@_0DH@CGFLGEDD@Need?5to?5do?5step?53?0?5P?0?5V?0?5or?5Z?5be@ DB 'Need'
	DB	' to do step 3, P, V, or Z before dumping factors.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@NENMBAIG@Further?5dumping?5of?5factors?5in?5mi@
CONST	SEGMENT
??_C@_0EE@NENMBAIG@Further?5dumping?5of?5factors?5in?5mi@ DB 'Further dum'
	DB	'ping of factors in minimal degree mode (ysmp off) only.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08GOLMHPBE@?$CF20?415f?6?$AA@
CONST	SEGMENT
??_C@_08GOLMHPBE@?$CF20?415f?6?$AA@ DB '%20.15f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DOOHECOM@Dumping?5right?5hand?5side?5to?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@DOOHECOM@Dumping?5right?5hand?5side?5to?5?$CFs?4?6?$AA@ DB 'Dum'
	DB	'ping right hand side to %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KHHEGCCC@_rhs?4dat?$AA@
CONST	SEGMENT
??_C@_08KHHEGCCC@_rhs?4dat?$AA@ DB '_rhs.dat', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@IIMCAMAE@Dumping?5Hessian?5metric?5upper?5tri@
CONST	SEGMENT
??_C@_0EG@IIMCAMAE@Dumping?5Hessian?5metric?5upper?5tri@ DB 'Dumping Hess'
	DB	'ian metric upper triangle in row col value format to %s.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06MMDLEMLJ@_M?4dat?$AA@
CONST	SEGMENT
??_C@_06MMDLEMLJ@_M?4dat?$AA@ DB '_M.dat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MGONLNEG@?$CF6d?5?$CF6d?5?$CF20?415f?6?$AA@
CONST	SEGMENT
??_C@_0BB@MGONLNEG@?$CF6d?5?$CF6d?5?$CF20?415f?6?$AA@ DB '%6d %6d %20.15f'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@GHCEOKCM@Dumping?5Hessian?5upper?5triangle?5i@
CONST	SEGMENT
??_C@_0DP@GHCEOKCM@Dumping?5Hessian?5upper?5triangle?5i@ DB 'Dumping Hess'
	DB	'ian upper triangle in row col value format to %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JMPGNNAK@_H?4dat?$AA@
CONST	SEGMENT
??_C@_06JMPGNNAK@_H?4dat?$AA@ DB '_H.dat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@FLPHPIAP@Enter?5path?5and?5base?5name?5of?5Hess@
CONST	SEGMENT
??_C@_0DB@FLPHPIAP@Enter?5path?5and?5base?5name?5of?5Hess@ DB 'Enter path'
	DB	' and base name of Hessian dump files: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@OOJNHDJC@Hessian?5dump?4?5Note?5indexing?5is?51@
CONST	SEGMENT
??_C@_0CJ@OOJNHDJC@Hessian?5dump?4?5Note?5indexing?5is?51@ DB 'Hessian du'
	DB	'mp. Note indexing is 1-based.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@PIKAKACN@Need?5to?5do?5step?51?5first?5before?5d@
CONST	SEGMENT
??_C@_0DB@PIKAKACN@Need?5to?5do?5step?51?5first?5before?5d@ DB 'Need to d'
	DB	'o step 1 first before dumping Hessian.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IDHGJPPA@Minimizing?5regular?5energy?5in?5see@
CONST	SEGMENT
??_C@_0CE@IDHGJPPA@Minimizing?5regular?5energy?5in?5see@ DB 'Minimizing r'
	DB	'egular energy in seek.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@EMGEJCJA@Minimizing?5square?5gradient?5in?5se@
CONST	SEGMENT
??_C@_0CF@EMGEJCJA@Minimizing?5square?5gradient?5in?5se@ DB 'Minimizing s'
	DB	'quare gradient in seek.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NMONBFB@Not?5projecting?5global?5constraint@
CONST	SEGMENT
??_C@_0CM@NMONBFB@Not?5projecting?5global?5constraint@ DB 'Not projecting'
	DB	' global constraints in move.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JNHOPMJO@Projecting?5global?5constraints?5in@
CONST	SEGMENT
??_C@_0CI@JNHOPMJO@Projecting?5global?5constraints?5in@ DB 'Projecting gl'
	DB	'obal constraints in move.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NBALCHDO@Using?5non?9Bunch?9Kaufman?5version?5@
CONST	SEGMENT
??_C@_0DE@NBALCHDO@Using?5non?9Bunch?9Kaufman?5version?5@ DB 'Using non-B'
	DB	'unch-Kaufman version of minimal degree.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HPHGACOG@Using?5Bunch?9Kaufman?5version?5of?5m@
CONST	SEGMENT
??_C@_0DA@HPHGACOG@Using?5Bunch?9Kaufman?5version?5of?5m@ DB 'Using Bunch'
	DB	'-Kaufman version of minimal degree.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NDMLKFJ@Using?5YSMP?4?6?$AA@
CONST	SEGMENT
??_C@_0N@NDMLKFJ@Using?5YSMP?4?6?$AA@ DB 'Using YSMP.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EPNIGAFB@Must?5do?5step?51?5again?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@EPNIGAFB@Must?5do?5step?51?5again?4?6?$AA@ DB 'Must do step 1 a'
	DB	'gain.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FCGKHGED@Using?5alternate?5minimal?5degree?5f@
CONST	SEGMENT
??_C@_0CL@FCGKHGED@Using?5alternate?5minimal?5degree?5f@ DB 'Using altern'
	DB	'ate minimal degree factoring.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GMPCAKGN@Error?3?5Must?5get?5direction?5first?4@
CONST	SEGMENT
??_C@_0CC@GMPCAKGN@Error?3?5Must?5get?5direction?5first?4@ DB 'Error: Mus'
	DB	't get direction first.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MLAFAOKO@?$CFd?5?5?$CF20?415f?6?$AA@
CONST	SEGMENT
??_C@_0N@MLAFAOKO@?$CFd?5?5?$CF20?415f?6?$AA@ DB '%d  %20.15f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JNGKEIFD@Error?3?5Invalid?5eigenvector?5numbe@
CONST	SEGMENT
??_C@_0CE@JNGKEIFD@Error?3?5Invalid?5eigenvector?5numbe@ DB 'Error: Inval'
	DB	'id eigenvector number.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DHLDIAGC@Eigenvector?5number?5?$CI1?5to?5?$CFd?$CJ?3?5?$AA@
CONST	SEGMENT
??_C@_0BP@DHLDIAGC@Eigenvector?5number?5?$CI1?5to?5?$CFd?$CJ?3?5?$AA@ DB 'E'
	DB	'igenvector number (1 to %d): ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PIPPHMCA@Error?3?5Must?5do?5step?5Z?5first?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@PIPPHMCA@Error?3?5Must?5do?5step?5Z?5first?4?6?$AA@ DB 'Error: '
	DB	'Must do step Z first.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NKKPEDBD@Error?3?5Number?5of?5eigenvalues?5mus@
CONST	SEGMENT
??_C@_0DA@NKKPEDBD@Error?3?5Number?5of?5eigenvalues?5mus@ DB 'Error: Numb'
	DB	'er of eigenvalues must be positive.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JPMIFIJK@Number?5of?5eigenvalues?3?5?$AA@
CONST	SEGMENT
??_C@_0BI@JPMIFIJK@Number?5of?5eigenvalues?3?5?$AA@ DB 'Number of eigenva'
	DB	'lues: ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MKJBDOHJ@Ritz?5probe?5value?3?5?$AA@
CONST	SEGMENT
??_C@_0BD@MKJBDOHJ@Ritz?5probe?5value?3?5?$AA@ DB 'Ritz probe value: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NNJEGLLG@Hessian?5debug?5OFF?4?6?$AA@
CONST	SEGMENT
??_C@_0BE@NNJEGLLG@Hessian?5debug?5OFF?4?6?$AA@ DB 'Hessian debug OFF.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LFKMFKA@Hessian?5debug?5ON?4?6?$AA@
CONST	SEGMENT
??_C@_0BD@LFKMFKA@Hessian?5debug?5ON?4?6?$AA@ DB 'Hessian debug ON.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JLIMGEEC@hessian_menu?5subcommand?3?5?$AA@
CONST	SEGMENT
??_C@_0BK@JLIMGEEC@hessian_menu?5subcommand?3?5?$AA@ DB 'hessian_menu sub'
	DB	'command: ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JFBDGLHP@1?4?5?$CFs?3?5?$CF17?415f?5energy?3?5?$CF17?415f?5?6@
CONST	SEGMENT
??_C@_0CB@JFBDGLHP@1?4?5?$CFs?3?5?$CF17?415f?5energy?3?5?$CF17?415f?5?6@ DB '1'
	DB	'. %s: %17.15f energy: %17.15f ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EOLGNBDF@Step?5size?3?5?$AA@
CONST	SEGMENT
??_C@_0M@EOLGNBDF@Step?5size?3?5?$AA@ DB 'Step size: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GENPMKBC@Error?3?5Must?5do?5step?53?0V?0E?0F?0C?0B?5@
CONST	SEGMENT
??_C@_0CN@GENPMKBC@Error?3?5Must?5do?5step?53?0V?0E?0F?0C?0B?5@ DB 'Error'
	DB	': Must do step 3,V,E,F,C,B or X first.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LLLFLHN@Motion?5found?4?5?6?$AA@
CONST	SEGMENT
??_C@_0BA@LLLFLHN@Motion?5found?4?5?6?$AA@ DB 'Motion found. ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OEBIHIGH@Motion?5found?4?5?5Pressures?5adjuste@
CONST	SEGMENT
??_C@_0CE@OEBIHIGH@Motion?5found?4?5?5Pressures?5adjuste@ DB 'Motion foun'
	DB	'd.  Pressures adjusted.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DKMPDIKE@Error?3?5Must?5do?5step?52?5first?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@DKMPDIKE@Error?3?5Must?5do?5step?52?5first?4?6?$AA@ DB 'Error: '
	DB	'Must do step 2 first.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EGCGMJAF@RHS?5norm?3?5?$CF20?415g?6?$AA@
CONST	SEGMENT
??_C@_0BD@EGCGMJAF@RHS?5norm?3?5?$CF20?415g?6?$AA@ DB 'RHS norm: %20.15g', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HBCFMACC@B?$FL?$CFd?$FN?5?5?$CF20?415f?6?$AA@
CONST	SEGMENT
??_C@_0BA@HBCFMACC@B?$FL?$CFd?$FN?5?5?$CF20?415f?6?$AA@ DB 'B[%d]  %20.15'
	DB	'f', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@ DB 'Error: '
	DB	'Must do step 1 first.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@JNPGEMLK@Choice?$CI?$DP?01?02?03?04?07?09?0B?0C?0E?0F?0L?0R@
CONST	SEGMENT
??_C@_0EA@JNPGEMLK@Choice?$CI?$DP?01?02?03?04?07?09?0B?0C?0E?0F?0L?0R@ DB 'C'
	DB	'hoice(?,1,2,3,4,7,9,B,C,E,F,L,R,Z,X,P,V,S,Y,U,M,G,D,K,=,0,q):'
	DB	' ', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _hessian_menu
_TEXT	SEGMENT
_coeff$89678 = -1372					; size = 8
_probe$89655 = -1364					; size = 8
_S$ = -1356						; size = 232
_j$89903 = -1124					; size = 4
_j$89773 = -1120					; size = 4
tv1741 = -1116						; size = 4
_sign$89679 = -1116					; size = 4
_fd$89768 = -1112					; size = 4
_right_flag$ = -1108					; size = 4
tv2845 = -1104						; size = 4
_k$89774 = -1104					; size = 4
_rhs$ = -1100						; size = 4
tv2819 = -1096						; size = 4
tv2557 = -1096						; size = 4
_k$89904 = -1096					; size = 4
_X$ = -1092						; size = 4
_dir_flag$ = -1088					; size = 4
_left_flag$ = -1084					; size = 4
tv1793 = -1080						; size = 4
_comma_flag$89905 = -1080				; size = 4
_evalues$89703 = -1076					; size = 120
_evalues$89714 = -956					; size = 120
_mname$89770 = -836					; size = 200
_hname$89900 = -636					; size = 200
_bname$89901 = -436					; size = 200
_hname$89769 = -236					; size = 200
_response$ = -36					; size = 30
__$ArrayPad$ = -4					; size = 4
_hessian_menu PROC					; COMDAT

; 768  : {   char response[30];

	push	ebp
	mov	ebp, esp
	sub	esp, 1372				; 0000055cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi

; 769  :     int left_flag = 0; /* whether hessian filled */

	xor	esi, esi
	push	edi
	mov	DWORD PTR _left_flag$[ebp], esi

; 770  :     int right_flag = 0; /* whether rhs filled in */

	mov	DWORD PTR _right_flag$[ebp], esi

; 771  :     int dir_flag = 0 ; /* whether direction filled in */

	mov	DWORD PTR _dir_flag$[ebp], esi

; 772  :     REAL stepsize;
; 773  :     REAL *rhs = NULL,*X = NULL;

	mov	DWORD PTR _rhs$[ebp], esi
	mov	DWORD PTR _X$[ebp], esi

; 774  :     struct linsys S;
; 775  :     
; 776  :     hessian_legal();

	call	_hessian_legal

; 777  :     save_coords(&saved,SAVE_IN_ATTR);

	push	1
	push	OFFSET _saved
	call	_save_coords

; 778  : 
; 779  :     memset(&S,0,sizeof(struct linsys)); 

	push	232					; 000000e8H
	lea	eax, DWORD PTR _S$[ebp]
	push	esi
	push	eax
	call	_memset

; 780  :     hess_debug = 0;
; 781  :     hmode = hessian_normal_flag;

	mov	ecx, DWORD PTR _hessian_normal_flag
	mov	DWORD PTR _hess_debug, esi
	mov	DWORD PTR _hmode, ecx
$LN384@hessian_me:

; 778  : 
; 779  :     memset(&S,0,sizeof(struct linsys)); 

	add	esp, 20					; 00000014H
	npad	2
$LL271@hessian_me:

; 782  :     for(;;)
; 783  :      {
; 784  : #ifdef MPI_EVOLVER
; 785  :         prompt("Choice(?,1,2,3,4,7,9,B,C,E,F,L,R,Z,X,P,V,S,Y,U,M,G,D,K,A,=,0,q): ",
; 786  : 		 response,sizeof(response));
; 787  : #else
; 788  :         prompt("Choice(?,1,2,3,4,7,9,B,C,E,F,L,R,Z,X,P,V,S,Y,U,M,G,D,K,=,0,q): ",
; 789  : 		 response,sizeof(response));

	push	30					; 0000001eH
	lea	edx, DWORD PTR _response$[ebp]
	push	edx
	push	OFFSET ??_C@_0EA@JNPGEMLK@Choice?$CI?$DP?01?02?03?04?07?09?0B?0C?0E?0F?0L?0R@
	call	_prompt

; 790  : #endif
; 791  :         switch ( toupper(response[0]) )

	movsx	eax, BYTE PTR _response$[ebp]
	movsx	eax, BYTE PTR _kb_upper_array[eax]
	add	esp, 12					; 0000000cH
	cmp	eax, 100				; 00000064H
	ja	$LN1@hessian_me
	movzx	ecx, BYTE PTR $LN359@hessian_me[eax]
	jmp	DWORD PTR $LN390@hessian_me[ecx*4]
$LN267@hessian_me:

; 792  :           { case '?': print_hessian_menu(); break;

	call	_print_hessian_menu
	jmp	SHORT $LL271@hessian_me
$LN266@hessian_me:

; 793  :              case '1': 
; 794  :                  hessian_cleanup(); /* cleanup from previous round */

	call	_hessian_cleanup

; 795  :                  hessian_init(&S,&rhs);

	lea	edx, DWORD PTR _rhs$[ebp]
	push	edx
	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	call	_hessian_init

; 796  :                  hess_flag = 1; rhs_flag = 1; 
; 797  :                  hessian_fill(&S,&rhs); 

	lea	ecx, DWORD PTR _rhs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$[ebp]
	mov	esi, 1
	push	edx
	mov	DWORD PTR _hess_flag, esi
	mov	DWORD PTR _rhs_flag, esi
	call	_hessian_fill

; 798  :                  X = (REAL*)temp_calloc(S.N,sizeof(REAL));

	mov	eax, DWORD PTR _S$[ebp+4]
	push	798					; 0000031eH
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc

; 799  :                  (*sp_AIJ_setup_func)(S.A_rows,&S);

	mov	edx, DWORD PTR _S$[ebp+12]
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	push	edx
	mov	DWORD PTR _X$[ebp], eax
	call	DWORD PTR _sp_AIJ_setup_func

; 800  :                  (*sp_constraint_setup_func) (
; 801  :                            web.skel[BODY].max_ord+1 + gen_quant_count,&S);

	mov	ecx, DWORD PTR _web+404
	mov	edx, DWORD PTR _web+5528
	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	lea	eax, DWORD PTR [edx+ecx+1]
	push	eax
	call	DWORD PTR _sp_constraint_setup_func

; 802  :                  if ( sp_ordering_func ) (*sp_ordering_func)(&S);

	mov	eax, DWORD PTR _sp_ordering_func
	add	esp, 48					; 00000030H
	test	eax, eax
	je	SHORT $LN265@hessian_me
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	eax
	add	esp, 4
$LN265@hessian_me:

; 803  :                  if ( hessian_linear_metric_flag )

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $LN264@hessian_me

; 804  :                  {
; 805  :                     linear_metric_setup(&S,&Met);

	lea	edx, DWORD PTR _S$[ebp]
	push	OFFSET _Met
	push	edx
	call	_linear_metric_setup

; 808  :                  { 
; 809  :                     star_metric_setup(&S,&Met);

	add	esp, 8

; 810  :                  }
; 811  :                  left_flag = 1;

	mov	DWORD PTR _left_flag$[ebp], esi

; 812  :                  break;

	jmp	$LL271@hessian_me
$LN264@hessian_me:

; 806  :                  }
; 807  :                  else if ( web.area_norm_flag )

	cmp	DWORD PTR _web+876, 0
	je	SHORT $LN262@hessian_me

; 808  :                  { 
; 809  :                     star_metric_setup(&S,&Met);

	lea	eax, DWORD PTR _S$[ebp]
	push	OFFSET _Met
	push	eax
	call	_star_metric_setup
	add	esp, 8
$LN262@hessian_me:

; 810  :                  }
; 811  :                  left_flag = 1;

	mov	DWORD PTR _left_flag$[ebp], esi

; 812  :                  break;

	jmp	$LL271@hessian_me
$LN261@hessian_me:

; 813  : 
; 814  :              case '2': 
; 815  :                   if ( left_flag == 0 )

	cmp	DWORD PTR _left_flag$[ebp], 0
	jne	SHORT $LN260@hessian_me

; 816  :                      { erroutstring("Error: Must do step 1 first.\n"); break; }

	push	OFFSET ??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN260@hessian_me:

; 817  :                   if ( hess_debug )

	cmp	DWORD PTR _hess_debug, 0

; 818  :                   { int i;
; 819  :                     for ( i = 0 ; i < S.N ; i++ )

	mov	edi, DWORD PTR _rhs$[ebp]
	je	SHORT $LN256@hessian_me
	xor	esi, esi
	cmp	DWORD PTR _S$[ebp+4], esi
	jle	SHORT $LN256@hessian_me
$LL258@hessian_me:

; 820  :                       printf("B[%d]  %20.15f\n",i,(DOUBLE)(rhs[i]));

	fld	QWORD PTR [edi+esi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	esi
	push	OFFSET ??_C@_0BA@HBCFMACC@B?$FL?$CFd?$FN?5?5?$CF20?415f?6?$AA@
	call	_printf
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR _S$[ebp+4]
	jl	SHORT $LL258@hessian_me
$LN256@hessian_me:

; 821  :                   }
; 822  :                   rhs_norm = dot(rhs,rhs,S.N);

	mov	ecx, DWORD PTR _S$[ebp+4]
	push	ecx
	push	edi
	push	edi
	call	_dot
	fst	QWORD PTR _rhs_norm

; 823  : #ifdef FLOAT128
; 824  :                   sprintf(msg,"RHS norm: %20.*Qg\n",DPREC, rhs_norm);
; 825  : #elif defined(LONGDOUBLE)
; 826  :                   sprintf(msg,"RHS norm: %20.*Lg\n",DPREC, rhs_norm);
; 827  : #else
; 828  :                   sprintf(msg,"RHS norm: %20.15g\n", rhs_norm);

	mov	edx, DWORD PTR _msg
	fstp	QWORD PTR [esp+4]
	add	esp, 4
	push	OFFSET ??_C@_0BD@EGCGMJAF@RHS?5norm?3?5?$CF20?415g?6?$AA@
	push	edx
	call	_sprintf

; 829  : #endif 
; 830  :                   outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring

; 831  :                   right_flag = 1;

	mov	DWORD PTR _right_flag$[ebp], 1

; 832  :                   break;

	jmp	$LN384@hessian_me
$LN255@hessian_me:

; 833  :                 
; 834  :              case '3': 
; 835  :                  if ( left_flag == 0 )

	cmp	DWORD PTR _left_flag$[ebp], 0
	jne	SHORT $LN254@hessian_me

; 836  :                      { erroutstring("Error: Must do step 1 first.\n"); break; }

	push	OFFSET ??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN254@hessian_me:

; 837  :                  if ( right_flag == 0 )

	cmp	DWORD PTR _right_flag$[ebp], 0
	jne	SHORT $LN253@hessian_me

; 838  :                      { erroutstring("Error: Must do step 2 first.\n"); break; }

	push	OFFSET ??_C@_0BO@DKMPDIKE@Error?3?5Must?5do?5step?52?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN253@hessian_me:

; 839  :                  if ( !(S.flags & S_FACTORED) ) sp_factor(&S,MKL_INDEF);

	test	BYTE PTR _S$[ebp], 4
	jne	SHORT $LN252@hessian_me
	lea	ecx, DWORD PTR _S$[ebp]
	push	-2					; fffffffeH
	push	ecx
	call	_sp_factor
	add	esp, 8
$LN252@hessian_me:

; 840  :                  if ( !(S.flags & S_PROJECTED)) (*sp_hess_project_setup_func)(&S);

	test	BYTE PTR _S$[ebp], 8
	jne	SHORT $LN251@hessian_me
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	call	DWORD PTR _sp_hess_project_setup_func
	add	esp, 4
$LN251@hessian_me:

; 841  :                  sp_hessian_solve(&S,rhs,X,SET_PRESSURE);

	mov	eax, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	push	1
	push	eax
	push	ecx
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	call	_sp_hessian_solve
	add	esp, 16					; 00000010H

; 842  :                  if ( S.CN )

	cmp	DWORD PTR _S$[ebp+148], 0
	je	SHORT $LN250@hessian_me

; 843  :                    outstring("Motion found.  Pressures adjusted.\n");

	push	OFFSET ??_C@_0CE@OEBIHIGH@Motion?5found?4?5?5Pressures?5adjuste@

; 844  :                  else
; 845  :                    outstring("Motion found. \n");

	call	_outstring
	add	esp, 4

; 846  :                  dir_flag = 1;

	mov	DWORD PTR _dir_flag$[ebp], 1

; 847  :                  break;

	jmp	$LL271@hessian_me
$LN250@hessian_me:

; 844  :                  else
; 845  :                    outstring("Motion found. \n");

	push	OFFSET ??_C@_0BA@LLLFLHN@Motion?5found?4?5?6?$AA@
	call	_outstring
	add	esp, 4

; 846  :                  dir_flag = 1;

	mov	DWORD PTR _dir_flag$[ebp], 1

; 847  :                  break;

	jmp	$LL271@hessian_me
$LN248@hessian_me:

; 848  : 
; 849  :              case '4': 
; 850  :                   if ( dir_flag == 0 )

	cmp	DWORD PTR _dir_flag$[ebp], 0
	jne	SHORT $LN247@hessian_me

; 851  :                   { erroutstring("Error: Must do step 3,V,E,F,C,B or X first.\n"); 

	push	OFFSET ??_C@_0CN@GENPMKBC@Error?3?5Must?5do?5step?53?0V?0E?0F?0C?0B?5@
	call	_erroutstring
	add	esp, 4

; 852  :                     break; 

	jmp	$LL271@hessian_me
$LN247@hessian_me:

; 853  :                   }
; 854  :                  prompt("Step size: ",response,sizeof(response));

	push	30					; 0000001eH
	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	push	OFFSET ??_C@_0M@EOLGNBDF@Step?5size?3?5?$AA@
	call	_prompt

; 855  :                  stepsize = atof(response);

	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	call	_atof

; 856  :                  hessian_iterate_flag = 1;
; 857  :                  hessian_move(stepsize,ACTUAL_MOVE,X);

	mov	edx, DWORD PTR _X$[ebp]
	add	esp, 16					; 00000010H
	push	edx
	push	1
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR _hessian_iterate_flag, 1
	call	_hessian_move

; 858  :                  hessian_iterate_flag = 0;
; 859  : #ifdef FLOAT128
; 860  :                  sprintf(msg,"1. energy: %*.*Qg \n",DWIDTH,DPREC,web.total_energy);
; 861  : #elif defined(LONGDOUBLE)
; 862  :                  sprintf(msg,"1. energy: %*.*Lg \n",DWIDTH,DPREC,web.total_energy);
; 863  : #else
; 864  :                  sprintf(msg,"1. %s: %17.15f energy: %17.15f \n",
; 865  :                         areaname,web.total_area,web.total_energy);

	fld	QWORD PTR _web+1240
	mov	eax, DWORD PTR _areaname
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _web+992
	mov	ecx, DWORD PTR _msg
	fstp	QWORD PTR [esp]
	push	eax
	push	OFFSET ??_C@_0CB@JFBDGLHP@1?4?5?$CFs?3?5?$CF17?415f?5energy?3?5?$CF17?415f?5?6@
	push	ecx
	mov	DWORD PTR _hessian_iterate_flag, 0
	call	_sprintf

; 866  : #endif 
; 867  :                  outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 32					; 00000020H

; 868  :                  update_display();

	call	_update_display

; 869  :                  break;

	jmp	$LL271@hessian_me
$LN246@hessian_me:

; 870  : 
; 871  :              case '7': restore_coords(&saved,SAVE_IN_ATTR); update_display(); break;

	push	1
	push	OFFSET _saved
	call	_restore_coords
	add	esp, 8
	call	_update_display
	jmp	$LL271@hessian_me
$LN245@hessian_me:

; 872  : 
; 873  :              case '8': 
; 874  :                        if ( left_flag == 0 )

	cmp	DWORD PTR _left_flag$[ebp], 0
	jne	SHORT $LN244@hessian_me

; 875  :                          { erroutstring("Error: Must do step 1 first.\n"); break; }

	push	OFFSET ??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN244@hessian_me:

; 876  :                        write_hessian(&S); break;

	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	call	_write_hessian
	add	esp, 4
	jmp	$LL271@hessian_me
$LN243@hessian_me:

; 877  : 
; 878  :              case '=': 
; 879  :                    hessian_subshell_flag = 1;
; 880  :                    subshell_depth++;

	mov	eax, DWORD PTR _subshell_depth
	mov	esi, 1
	add	eax, esi
	mov	DWORD PTR _subshell_depth, eax

; 881  :                    setjmp(jumpbuf[subshell_depth]);

	shl	eax, 6
	add	eax, OFFSET _jumpbuf
	push	0
	push	eax
	mov	DWORD PTR _hessian_subshell_flag, esi
	call	__setjmp3

; 882  :                    /* command read and execute loop */
; 883  :                    exec_commands(NULL,"hessian_menu subcommand: "); 

	push	OFFSET ??_C@_0BK@JLIMGEEC@hessian_menu?5subcommand?3?5?$AA@
	push	0
	call	_exec_commands
	add	esp, 16					; 00000010H

; 884  :                    subshell_depth-- ;

	sub	DWORD PTR _subshell_depth, esi

; 885  :                    hessian_subshell_flag = 0;

	mov	DWORD PTR _hessian_subshell_flag, 0

; 886  :                    break;

	jmp	$LL271@hessian_me
$LN237@hessian_me:

; 895  :                    return;
; 896  :              case '9': hess_debug = !hess_debug;

	xor	eax, eax
	cmp	DWORD PTR _hess_debug, eax
	sete	al
	mov	DWORD PTR _hess_debug, eax

; 897  :                        if ( hess_debug ) 

	test	eax, eax
	je	SHORT $LN236@hessian_me

; 898  :                              outstring("Hessian debug ON.\n");

	push	OFFSET ??_C@_0BD@LFKMFKA@Hessian?5debug?5ON?4?6?$AA@
	call	_outstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN236@hessian_me:

; 899  :                        else outstring("Hessian debug OFF.\n");

	push	OFFSET ??_C@_0BE@NNJEGLLG@Hessian?5debug?5OFF?4?6?$AA@
	call	_outstring
	add	esp, 4

; 900  :                        break;

	jmp	$LL271@hessian_me
$LN234@hessian_me:

; 901  : 
; 902  :              case 'T': /* experimdntal multigrid */
; 903  :                  if ( left_flag == 0 )

	cmp	DWORD PTR _left_flag$[ebp], 0
	jne	SHORT $LN233@hessian_me

; 904  :                      { erroutstring("Error: Must do step 1 first.\n"); break; }

	push	OFFSET ??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN233@hessian_me:

; 905  :                  if ( right_flag == 0 )

	cmp	DWORD PTR _right_flag$[ebp], 0
	jne	SHORT $LN232@hessian_me

; 906  :                      { erroutstring("Error: Must do step 2 first.\n"); break; }

	push	OFFSET ??_C@_0BO@DKMPDIKE@Error?3?5Must?5do?5step?52?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN232@hessian_me:

; 907  :                  do_multigrid(&S);

	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	_do_multigrid
	add	esp, 4

; 908  :                  break;

	jmp	$LL271@hessian_me
$LN231@hessian_me:

; 909  : 
; 910  :              case 'Z': /* ritz */
; 911  :               { 
; 912  :                  REAL probe;
; 913  :                  if ( left_flag == 0 )

	cmp	DWORD PTR _left_flag$[ebp], 0
	jne	SHORT $LN230@hessian_me

; 914  :                      { erroutstring("Error: Must do step 1 first.\n"); break; }

	push	OFFSET ??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN230@hessian_me:

; 915  :                  prompt("Ritz probe value: ",response,sizeof(response));

	push	30					; 0000001eH
	lea	edx, DWORD PTR _response$[ebp]
	push	edx
	push	OFFSET ??_C@_0BD@MKJBDOHJ@Ritz?5probe?5value?3?5?$AA@
	call	_prompt

; 916  :                  probe = atof(response);

	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	call	_atof
	fstp	QWORD PTR _probe$89655[ebp]

; 917  :                  prompt("Number of eigenvalues: ",response,sizeof(response));

	push	30					; 0000001eH
	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BI@JPMIFIJK@Number?5of?5eigenvalues?3?5?$AA@
	call	_prompt

; 918  :                  ritzdim = atoi(response);

	lea	edx, DWORD PTR _response$[ebp]
	push	edx
	call	_atoi
	add	esp, 32					; 00000020H
	mov	DWORD PTR _ritzdim, eax

; 919  :                  if ( ritzdim <= 0 )

	test	eax, eax
	jg	SHORT $LN229@hessian_me

; 920  :                  { erroutstring("Error: Number of eigenvalues must be positive.\n");

	push	OFFSET ??_C@_0DA@NKKPEDBD@Error?3?5Number?5of?5eigenvalues?5mus@
	call	_erroutstring
	add	esp, 4

; 921  :                    break;

	jmp	$LL271@hessian_me
$LN229@hessian_me:

; 922  :                  }
; 923  :                  if ( ritzvecs ) free_matrix(ritzvecs);

	mov	ecx, DWORD PTR _ritzvecs
	test	ecx, ecx
	je	SHORT $LN228@hessian_me
	push	ecx
	call	_free_matrix
	mov	eax, DWORD PTR _ritzdim
	add	esp, 4
$LN228@hessian_me:

; 924  :                  ritzvecs = dmatrix(0,ritzdim-1,0,S.N+S.concount);

	mov	edx, DWORD PTR _S$[ebp+144]
	add	edx, DWORD PTR _S$[ebp+4]
	push	924					; 0000039cH
	push	OFFSET ??_C@_09BDABODOF@HESSIAN?4C?$AA@
	push	edx
	push	0
	dec	eax
	push	eax
	push	0
	call	_kb_dmatrix

; 925  :                  do_ritz(&S,probe,ritzdim,ritzvecs);

	fld	QWORD PTR _probe$89655[ebp]
	add	esp, 24					; 00000018H
	push	eax
	mov	DWORD PTR _ritzvecs, eax
	mov	eax, DWORD PTR _ritzdim
	push	eax
	sub	esp, 8
	lea	ecx, DWORD PTR _S$[ebp]
	fstp	QWORD PTR [esp]
	push	ecx
	call	_do_ritz

; 926  :                  ritz_done_flag = 1;

	mov	DWORD PTR _ritz_done_flag, 1

; 927  :                  break;

	jmp	$LN384@hessian_me
$LN227@hessian_me:

; 928  :               }
; 929  :              case 'X': /* pick ritz vector for motion */
; 930  :               { int ritznum;
; 931  :                 char *spot;
; 932  :                  int i;
; 933  :                  if ( ritz_done_flag == 0 )

	cmp	DWORD PTR _ritz_done_flag, 0
	jne	SHORT $LN226@hessian_me

; 934  :                      { erroutstring("Error: Must do step Z first.\n"); break; }

	push	OFFSET ??_C@_0BO@PIPPHMCA@Error?3?5Must?5do?5step?5Z?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN226@hessian_me:

; 935  :                  sprintf(msg,"Eigenvector number (1 to %d): ",ritzdim);

	mov	edx, DWORD PTR _ritzdim
	mov	eax, DWORD PTR _msg
	push	edx
	push	OFFSET ??_C@_0BP@DHLDIAGC@Eigenvector?5number?5?$CI1?5to?5?$CFd?$CJ?3?5?$AA@
	push	eax
	call	_sprintf

; 936  :                  prompt(msg,response,sizeof(response));

	mov	edx, DWORD PTR _msg
	push	30					; 0000001eH
	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	push	edx
	call	_prompt

; 937  :                  /* parse response for possible linear combo of vectors */
; 938  :                  for ( spot = response ; *spot ; spot++ ) 

	mov	cl, BYTE PTR _response$[ebp]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR _response$[ebp]
	test	cl, cl
	je	SHORT $LN223@hessian_me
	npad	4
$LL225@hessian_me:

; 939  :                    *spot = tolower(*spot);

	movsx	ecx, cl
	mov	dl, BYTE PTR _kb_lower_array[ecx]
	mov	BYTE PTR [eax], dl
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL225@hessian_me
$LN223@hessian_me:

; 940  :                  if ( strchr(response,'v') )

	lea	eax, DWORD PTR _response$[ebp]
	push	118					; 00000076H
	push	eax
	call	_strchr
	add	esp, 8
	test	eax, eax
	je	$LN222@hessian_me

; 941  :                  { spot = response;
; 942  :                    memset((char*)X,0,S.N*sizeof(REAL));

	mov	ecx, DWORD PTR _S$[ebp+4]
	mov	ebx, DWORD PTR _X$[ebp]
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	push	0
	push	ebx
	lea	esi, DWORD PTR _response$[ebp]
	call	_memset

; 943  :                    while ( strchr(spot,'v') )

	mov	eax, esi
	push	118					; 00000076H
	push	eax
	call	_strchr
	add	esp, 20					; 00000014H
	test	eax, eax
	je	$LN203@hessian_me
	npad	3
$LL221@hessian_me:

; 944  :                    { REAL coeff;
; 945  :                      int sign = 1;

	mov	ecx, 1
	mov	DWORD PTR _sign$89679[ebp], ecx
	npad	5
$LL219@hessian_me:

; 946  :                      while ( *spot==' ' || *spot=='+' || *spot=='-' )

	mov	al, BYTE PTR [esi]
	cmp	al, 32					; 00000020H
	je	SHORT $LN217@hessian_me
	cmp	al, 43					; 0000002bH
	je	SHORT $LN217@hessian_me
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN218@hessian_me
$LN217@hessian_me:

; 947  :                      { if ( *spot=='-' ) sign = -sign;

	cmp	al, 45					; 0000002dH
	jne	SHORT $LN216@hessian_me
	neg	ecx
$LN216@hessian_me:

; 948  :                        spot++;

	inc	esi

; 949  :                      }

	jmp	SHORT $LL219@hessian_me
$LN218@hessian_me:

; 950  :                      coeff = sign*atof(spot);

	push	esi
	mov	DWORD PTR _sign$89679[ebp], ecx
	call	_atof
	fimul	DWORD PTR _sign$89679[ebp]

; 951  :                      spot  = strchr(spot,'v')+1;

	push	118					; 00000076H
	push	esi
	fstp	QWORD PTR _coeff$89678[ebp]
	call	_strchr
	lea	esi, DWORD PTR [eax+1]

; 952  :                      ritznum = atoi(spot); 

	push	esi
	call	_atoi

; 953  :                      while ( isdigit(*spot) ) spot++;

	movsx	ecx, BYTE PTR [esi]
	push	ecx
	mov	edi, eax
	call	_isdigit
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN214@hessian_me
$LL215@hessian_me:
	movsx	edx, BYTE PTR [esi+1]
	inc	esi
	push	edx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LL215@hessian_me
$LN214@hessian_me:

; 954  :                      if ( (ritznum < 0) || (ritznum > ritzdim) )

	test	edi, edi
	js	SHORT $LN319@hessian_me
	cmp	edi, DWORD PTR _ritzdim
	jg	SHORT $LN319@hessian_me

; 956  :                        break; 
; 957  :                      }
; 958  :                      ritznum--;
; 959  :                      for ( i = 0 ; i < S.N ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _S$[ebp+4], ecx
	jle	SHORT $LN209@hessian_me
	mov	edx, DWORD PTR _ritzvecs
	fld	QWORD PTR _coeff$89678[ebp]
	mov	edx, DWORD PTR [edx+edi*4-4]
	mov	eax, ebx
	sub	edx, ebx
$LN211@hessian_me:

; 960  :                        X[i] += coeff*ritzvecs[ritznum][i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _S$[ebp+4]
	jl	SHORT $LN211@hessian_me

; 956  :                        break; 
; 957  :                      }
; 958  :                      ritznum--;
; 959  :                      for ( i = 0 ; i < S.N ; i++ )

	fstp	ST(0)
$LN209@hessian_me:

; 943  :                    while ( strchr(spot,'v') )

	push	118					; 00000076H
	push	esi
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	$LL221@hessian_me

; 970  :                  }
; 971  :                  dir_flag = 1;

	mov	DWORD PTR _dir_flag$[ebp], 1

; 972  :                  break;

	jmp	$LL271@hessian_me
$LN319@hessian_me:

; 955  :                      { erroutstring("Error: Invalid eigenvector number.\n"); 

	push	OFFSET ??_C@_0CE@JNGKEIFD@Error?3?5Invalid?5eigenvector?5numbe@
	call	_erroutstring
	add	esp, 4

; 970  :                  }
; 971  :                  dir_flag = 1;

	mov	DWORD PTR _dir_flag$[ebp], 1

; 972  :                  break;

	jmp	$LL271@hessian_me
$LN222@hessian_me:

; 961  :                    }
; 962  :                    
; 963  :                  }
; 964  :                  else
; 965  :                  { ritznum = atoi(response);

	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	call	_atoi
	add	esp, 4

; 966  :                    if ( (ritznum < 0) || (ritznum > ritzdim) )

	test	eax, eax
	js	SHORT $LN206@hessian_me
	cmp	eax, DWORD PTR _ritzdim
	jg	SHORT $LN206@hessian_me

; 968  :                    ritznum--;
; 969  :                    for ( i = 0 ; i < S.N ; i++ ) X[i] = ritzvecs[ritznum][i];

	xor	edx, edx
	cmp	DWORD PTR _S$[ebp+4], edx
	jle	SHORT $LN203@hessian_me
	mov	esi, DWORD PTR _ritzvecs
	mov	ecx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [esi+eax*4-4]
	sub	eax, ecx
	npad	7
$LL205@hessian_me:
	fld	QWORD PTR [ecx+eax]
	inc	edx
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	cmp	edx, DWORD PTR _S$[ebp+4]
	jl	SHORT $LL205@hessian_me
$LN203@hessian_me:

; 970  :                  }
; 971  :                  dir_flag = 1;

	mov	DWORD PTR _dir_flag$[ebp], 1

; 972  :                  break;

	jmp	$LL271@hessian_me
$LN206@hessian_me:

; 967  :                    { erroutstring("Error: Invalid eigenvector number.\n"); break; }

	push	OFFSET ??_C@_0CE@JNGKEIFD@Error?3?5Invalid?5eigenvector?5numbe@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN202@hessian_me:

; 973  :               }
; 974  :              case 'L': 
; 975  :              { int nprint,i;
; 976  :                 REAL evalues[NPRINT];
; 977  :                  if ( left_flag == 0 )

	cmp	DWORD PTR _left_flag$[ebp], 0
	jne	SHORT $LN201@hessian_me

; 978  :                      { erroutstring("Error: Must do step 1 first.\n"); break; }

	push	OFFSET ??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN201@hessian_me:

; 979  :                  if ( !(S.flags & S_FACTORED) ) sp_factor(&S,MKL_INDEF);

	test	BYTE PTR _S$[ebp], 4
	jne	SHORT $LN200@hessian_me
	lea	ecx, DWORD PTR _S$[ebp]
	push	-2					; fffffffeH
	push	ecx
	call	_sp_factor
	add	esp, 8
$LN200@hessian_me:

; 980  :                  if ( !(S.flags & S_PROJECTED)) (*sp_hess_project_setup_func)(&S);

	test	BYTE PTR _S$[ebp], 8
	jne	SHORT $LN199@hessian_me
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	call	DWORD PTR _sp_hess_project_setup_func
	add	esp, 4
$LN199@hessian_me:

; 981  :                  nprint = lanczos(&S,KRYLOVDIM,evalues,NPRINT);

	push	15					; 0000000fH
	lea	eax, DWORD PTR _evalues$89703[ebp]
	push	eax
	lea	ecx, DWORD PTR _S$[ebp]
	push	100					; 00000064H
	push	ecx
	call	_lanczos
	mov	edi, eax
	add	esp, 16					; 00000010H

; 982  :                  /* list, ones near probe value */
; 983  :                  for ( i = 0 ; i < nprint ; i++ )

	xor	eax, eax
	test	edi, edi
	jle	$LL271@hessian_me
	npad	10
$LL198@hessian_me:

; 984  :                  {
; 985  : #ifdef FLOAT128
; 986  :                     sprintf(msg,"%d  %*.*Qf\n",i+1,DWIDTH,DPREC,evalues[i]);
; 987  : #elif defined(LONGDOUBLE)
; 988  :                     sprintf(msg,"%d  %*.*Lf\n",i+1,DWIDTH,DPREC,evalues[i]);
; 989  : #else
; 990  :                     sprintf(msg,"%d  %20.15f\n",i+1,evalues[i]);

	fld	QWORD PTR _evalues$89703[ebp+eax*8]
	mov	edx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	esi, DWORD PTR [eax+1]
	push	esi
	push	OFFSET ??_C@_0N@MLAFAOKO@?$CFd?5?5?$CF20?415f?6?$AA@
	push	edx
	call	_sprintf

; 991  : #endif 
; 992  :                     outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	mov	eax, esi
	add	esp, 24					; 00000018H
	cmp	eax, edi
	jl	SHORT $LL198@hessian_me

; 993  :                  }
; 994  :               }
; 995  :                  break;

	jmp	$LL271@hessian_me
$LN195@hessian_me:

; 996  : 
; 997  :              case 'R': 
; 998  :              { int nprint,i;
; 999  :                 REAL evalues[NPRINT];
; 1000 :                  if ( left_flag == 0 )

	cmp	DWORD PTR _left_flag$[ebp], 0
	jne	SHORT $LN194@hessian_me

; 1001 :                      { erroutstring("Error: Must do step 1 first.\n"); break; }

	push	OFFSET ??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN194@hessian_me:

; 1002 :                  if ( !(S.flags & S_FACTORED) ) sp_factor(&S,MKL_INDEF);

	test	BYTE PTR _S$[ebp], 4
	jne	SHORT $LN193@hessian_me
	lea	ecx, DWORD PTR _S$[ebp]
	push	-2					; fffffffeH
	push	ecx
	call	_sp_factor
	add	esp, 8
$LN193@hessian_me:

; 1003 :                  if ( !(S.flags & S_PROJECTED)) (*sp_hess_project_setup_func)(&S);

	test	BYTE PTR _S$[ebp], 8
	jne	SHORT $LN192@hessian_me
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	call	DWORD PTR _sp_hess_project_setup_func
	add	esp, 4
$LN192@hessian_me:

; 1004 :                  nprint = selective_lanczos(&S,KRYLOVDIM,evalues,NPRINT);

	push	15					; 0000000fH
	lea	eax, DWORD PTR _evalues$89714[ebp]
	push	eax
	lea	ecx, DWORD PTR _S$[ebp]
	push	100					; 00000064H
	push	ecx
	call	_selective_lanczos
	mov	edi, eax
	add	esp, 16					; 00000010H

; 1005 :                  /* list, ones near probe value */
; 1006 :                  for ( i = 0 ; i < nprint ; i++ )

	xor	eax, eax
	test	edi, edi
	jle	$LL271@hessian_me
	npad	1
$LL191@hessian_me:

; 1007 :                  { 
; 1008 : #ifdef FLOAT128
; 1009 :                     sprintf(msg,"%d  %*.*Qf\n",i+1,DWIDTH,DPREC,evalues[i]);
; 1010 : #elif defined(LONGDOUBLE)
; 1011 :                     sprintf(msg,"%d  %*.*Lf\n",i+1,DWIDTH,DPREC,evalues[i]);
; 1012 : #else
; 1013 :                     sprintf(msg,"%d  %20.15f\n",i+1,evalues[i]);

	fld	QWORD PTR _evalues$89714[ebp+eax*8]
	mov	edx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	esi, DWORD PTR [eax+1]
	push	esi
	push	OFFSET ??_C@_0N@MLAFAOKO@?$CFd?5?5?$CF20?415f?6?$AA@
	push	edx
	call	_sprintf

; 1014 : #endif 
; 1015 :                     outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	mov	eax, esi
	add	esp, 24					; 00000018H
	cmp	eax, edi
	jl	SHORT $LL191@hessian_me

; 1016 :                  }
; 1017 :               }
; 1018 :               break;

	jmp	$LL271@hessian_me
$LN188@hessian_me:

; 1019 : 
; 1020 :              case 'C': 
; 1021 :                  if ( left_flag == 0 )

	cmp	DWORD PTR _left_flag$[ebp], 0
	jne	SHORT $LN187@hessian_me

; 1022 :                      { erroutstring("Error: Must do step 1 first.\n"); break; }

	push	OFFSET ??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN187@hessian_me:

; 1023 :                  chebychev_ev(&S);

	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	_chebychev_ev
	add	esp, 4

; 1024 :                  dir_flag = 1;

	mov	DWORD PTR _dir_flag$[ebp], 1

; 1025 :                  break;

	jmp	$LL271@hessian_me
$LN186@hessian_me:

; 1026 : 
; 1027 :              case 'B': 
; 1028 :                  if ( left_flag == 0 )

	cmp	DWORD PTR _left_flag$[ebp], 0
	jne	SHORT $LN185@hessian_me

; 1029 :                      { erroutstring("Error: Must do step 1 first.\n"); break; }

	push	OFFSET ??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN185@hessian_me:

; 1030 :                  chebychev_hess(&S);

	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	call	_chebychev_hess
	add	esp, 4

; 1031 :                  dir_flag = 1;

	mov	DWORD PTR _dir_flag$[ebp], 1

; 1032 :                  break;

	jmp	$LL271@hessian_me
$LN184@hessian_me:

; 1033 : 
; 1034 :              case 'P':  /* probe for eigenvalues */
; 1035 :                  if ( left_flag == 0 )

	cmp	DWORD PTR _left_flag$[ebp], 0
	jne	SHORT $LN183@hessian_me

; 1036 :                      { erroutstring("Error: Must do step 1 first.\n"); break; }

	push	OFFSET ??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN183@hessian_me:

; 1037 :                  bk_eigenprobe(&S);

	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	call	_bk_eigenprobe
	add	esp, 4

; 1038 :                  break;

	jmp	$LL271@hessian_me
$LN182@hessian_me:

; 1039 : 
; 1040 :              case 'V':  /* probe for eigenvalues, with eigenvector */
; 1041 :                  if ( left_flag == 0 )

	cmp	DWORD PTR _left_flag$[ebp], 0
	jne	SHORT $LN181@hessian_me

; 1042 :                      { erroutstring("Error: Must do step 1 first.\n"); break; }

	push	OFFSET ??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN181@hessian_me:

; 1043 :                  bk_inverse_it(&S,X);

	mov	ecx, DWORD PTR _X$[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	call	_bk_inverse_it
	add	esp, 8

; 1044 :                  dir_flag = 1;

	mov	DWORD PTR _dir_flag$[ebp], 1

; 1045 :                  break;

	jmp	$LL271@hessian_me
$LN180@hessian_me:

; 1046 : 
; 1047 :              case 'E':  /* lowest eigenvalue */ 
; 1048 :               { REAL low;
; 1049 :                  if ( left_flag == 0 )

	cmp	DWORD PTR _left_flag$[ebp], 0
	jne	SHORT $LN179@hessian_me

; 1050 :                      { erroutstring("Error: Must do step 1 first.\n"); break; }

	push	OFFSET ??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN179@hessian_me:

; 1051 :                  low = lowest_eigenpair(&S,X); 

	mov	eax, DWORD PTR _X$[ebp]
	push	eax
	lea	ecx, DWORD PTR _S$[ebp]
	push	ecx
	call	_lowest_eigenpair

; 1052 : #ifdef FLOAT128
; 1053 :                  sprintf(msg,"Lowest eigenvalue %2.*Qg\n",DPREC,low);
; 1054 : #elif defined(LONGDOUBLE)
; 1055 :                  sprintf(msg,"Lowest eigenvalue %2.*Lg\n",DPREC,low);
; 1056 : #else
; 1057 :                  sprintf(msg,"Lowest eigenvalue %2.15g\n",low);

	fstp	QWORD PTR [esp]
	mov	edx, DWORD PTR _msg
	push	OFFSET ??_C@_0BK@IGPKNFNH@Lowest?5eigenvalue?5?$CF2?415g?6?$AA@
	push	edx
	call	_sprintf

; 1058 : #endif 
; 1059 :                  outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring

; 1060 :                  dir_flag = 1;

	mov	DWORD PTR _dir_flag$[ebp], 1

; 1061 :                  break;

	jmp	$LN384@hessian_me
$LN178@hessian_me:

; 1062 :               }
; 1063 :              case 'd':  /* lowest eigenvalue, by old conjugate gradient */ 
; 1064 :               { REAL low;
; 1065 :                  if ( left_flag == 0 )

	cmp	DWORD PTR _left_flag$[ebp], 0
	jne	SHORT $LN177@hessian_me

; 1066 :                      { erroutstring("Error: Must do step 1 first.\n"); break; }

	push	OFFSET ??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN177@hessian_me:

; 1067 :                  low = old_cg_lowest_eigenpair(&S,X); 

	mov	ecx, DWORD PTR _X$[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	call	_old_cg_lowest_eigenpair

; 1068 : #ifdef FLOAT128
; 1069 :                  sprintf(msg,"Lowest eigenvalue %2.*Qg\n",DPREC,low);
; 1070 : #elif defined(LONGDOUBLE)
; 1071 :                  sprintf(msg,"Lowest eigenvalue %2.*Lg\n",DPREC,low);
; 1072 : #else
; 1073 :                  sprintf(msg,"Lowest eigenvalue %2.15g\n",low);

	fstp	QWORD PTR [esp]
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0BK@IGPKNFNH@Lowest?5eigenvalue?5?$CF2?415g?6?$AA@
	push	eax
	call	_sprintf

; 1074 : #endif 
; 1075 :                  outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring

; 1076 :                  dir_flag = 1;

	mov	DWORD PTR _dir_flag$[ebp], 1

; 1077 :                  break;

	jmp	$LN384@hessian_me
$LN176@hessian_me:

; 1078 :               }
; 1079 :              case 'F':  /* lowest eigenvalue, by conjugate gradient */ 
; 1080 :               { REAL low;
; 1081 :                  if ( left_flag == 0 )

	cmp	DWORD PTR _left_flag$[ebp], 0
	jne	SHORT $LN175@hessian_me

; 1082 :                      { erroutstring("Error: Must do step 1 first.\n"); break; }

	push	OFFSET ??_C@_0BO@NBPIIDKH@Error?3?5Must?5do?5step?51?5first?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN175@hessian_me:

; 1083 :                  low = cg_lowest_eigenpair(&S,X); 

	mov	edx, DWORD PTR _X$[ebp]
	push	edx
	lea	eax, DWORD PTR _S$[ebp]
	push	eax
	call	_cg_lowest_eigenpair

; 1084 : #ifdef FLOAT128
; 1085 :                  sprintf(msg,"Lowest eigenvalue %2.*Qg\n",DPREC,low);
; 1086 : #elif defined(LONGDOUBLE)
; 1087 :                  sprintf(msg,"Lowest eigenvalue %2.*Lg\n",DPREC,low);
; 1088 : #else
; 1089 :                  sprintf(msg,"Lowest eigenvalue %2.15g\n",low);

	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _msg
	push	OFFSET ??_C@_0BK@IGPKNFNH@Lowest?5eigenvalue?5?$CF2?415g?6?$AA@
	push	ecx
	call	_sprintf

; 1090 : #endif 
; 1091 :                  outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 1092 :                  dir_flag = 1;

	mov	DWORD PTR _dir_flag$[ebp], 1

; 1093 :                  break;

	jmp	$LN384@hessian_me
$LN174@hessian_me:

; 1094 :               }
; 1095 :              case 'S':
; 1096 :                  if ( dir_flag == 0 )

	cmp	DWORD PTR _dir_flag$[ebp], 0
	jne	SHORT $LN173@hessian_me

; 1097 :                      { erroutstring("Error: Must get direction first.\n"); break; }

	push	OFFSET ??_C@_0CC@GMPCAKGN@Error?3?5Must?5get?5direction?5first?4@
	call	_erroutstring
	add	esp, 4
	jmp	$LL271@hessian_me
$LN173@hessian_me:

; 1098 :                  stepsize = hessian_line_seek(&S,10.0,X);

	mov	eax, DWORD PTR _X$[ebp]
	fld	QWORD PTR __real@4024000000000000
	push	eax
	sub	esp, 8
	lea	ecx, DWORD PTR _S$[ebp]
	fstp	QWORD PTR [esp]
	push	ecx
	call	_hessian_line_seek

; 1099 :                  sprintf(msg,"stepsize %g\n",(DOUBLE)stepsize);

	fstp	QWORD PTR [esp+8]
	mov	edx, DWORD PTR _msg
	add	esp, 8
	push	OFFSET ??_C@_0N@PAMCLMHF@stepsize?5?$CFg?6?$AA@
	push	edx
	call	_sprintf

; 1100 :                  outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring

; 1101 : #ifdef FLOAT128
; 1102 :                  sprintf(msg,"1.  energy: %*.*Qg \n",DWIDTH,DPREC,web.total_energy);
; 1103 : #elif defined(LONGDOUBLE)
; 1104 :                  sprintf(msg,"1.  energy: %*.*Lg \n",DWIDTH,DPREC,web.total_energy);
; 1105 : #else
; 1106 :                  sprintf(msg,"1. %s: %17.15g energy: %17.15g \n",
; 1107 :                         areaname,web.total_area,web.total_energy);

	fld	QWORD PTR _web+1240
	mov	ecx, DWORD PTR _areaname
	fstp	QWORD PTR [esp+12]
	fld	QWORD PTR _web+992
	mov	edx, DWORD PTR _msg
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	ecx
	push	OFFSET ??_C@_0CB@EIMIDHFM@1?4?5?$CFs?3?5?$CF17?415g?5energy?3?5?$CF17?415g?5?6@
	push	edx
	call	_sprintf

; 1108 : #endif 
; 1109 :                  outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 32					; 00000020H

; 1110 :                  update_display();

	call	_update_display

; 1111 :                  break;

	jmp	$LL271@hessian_me
$LN172@hessian_me:

; 1112 : 
; 1113 :              case 'Y': /* toggle YSMP */
; 1114 :                  if ( ysmp_flag != MINDEG_FACTORING )

	xor	esi, esi

; 1115 :                  { ysmp_flag = MINDEG_FACTORING;
; 1116 :                     sp_mul_func = bk_mul;

	mov	DWORD PTR _sp_mul_func, OFFSET _bk_mul

; 1117 :                     sp_AIJ_setup_func= bk_AIJ_setup;

	mov	DWORD PTR _sp_AIJ_setup_func, OFFSET _bk_AIJ_setup

; 1118 :                     sp_constraint_setup_func = bk_constraint_setup;

	mov	DWORD PTR _sp_constraint_setup_func, OFFSET _bk_constraint_setup

; 1119 :                     sp_hess_project_setup_func= BK_hess_project_setup;

	mov	DWORD PTR _sp_hess_project_setup_func, OFFSET _BK_hess_project_setup

; 1120 :                     sp_factor_func = xmd_factor;
; 1121 :                     sp_solve_func = xmd_solve;
; 1122 :                     sp_solve_multi_func = xmd_solve_multi;
; 1123 :                     sp_ordering_func = NULL;

	mov	DWORD PTR _sp_ordering_func, esi
	cmp	DWORD PTR _ysmp_flag, esi
	je	SHORT $LN171@hessian_me

; 1124 :                     sp_CHinvC_func = sp_CHinvC;
; 1125 :                     outstring("Using alternate minimal degree factoring.\n");

	push	OFFSET ??_C@_0CL@FCGKHGED@Using?5alternate?5minimal?5degree?5f@
	mov	DWORD PTR _ysmp_flag, esi
	mov	DWORD PTR _sp_factor_func, OFFSET _xmd_factor
	mov	DWORD PTR _sp_solve_func, OFFSET _xmd_solve
	mov	DWORD PTR _sp_solve_multi_func, OFFSET _xmd_solve_multi
	mov	DWORD PTR _sp_CHinvC_func, OFFSET _sp_CHinvC
	call	_outstring
	add	esp, 4

; 1126 :                     if ( left_flag ) outstring("Must do step 1 again.\n");

	cmp	DWORD PTR _left_flag$[ebp], esi
	je	SHORT $LN170@hessian_me
	push	OFFSET ??_C@_0BH@EPNIGAFB@Must?5do?5step?51?5again?4?6?$AA@
	call	_outstring
	add	esp, 4
$LN170@hessian_me:

; 1127 :                     dir_flag = left_flag = right_flag = 0;

	mov	DWORD PTR _right_flag$[ebp], esi
	mov	DWORD PTR _left_flag$[ebp], esi
	mov	DWORD PTR _dir_flag$[ebp], esi

; 1128 :                  }
; 1129 :                  else

	jmp	$LL271@hessian_me
$LN171@hessian_me:

; 1130 :                  { ysmp_flag = YSMP_FACTORING;
; 1131 :                     sp_mul_func = bk_mul;
; 1132 :                     sp_AIJ_setup_func= bk_AIJ_setup;
; 1133 :                     sp_constraint_setup_func = bk_constraint_setup;
; 1134 :                     sp_hess_project_setup_func= BK_hess_project_setup;
; 1135 :                     sp_factor_func = ysmp_factor;
; 1136 :                     sp_CHinvC_func = NULL;
; 1137 :                     sp_solve_func = ysmp_solve;
; 1138 :                     sp_solve_multi_func = ysmp_solve_multi;
; 1139 :                     sp_ordering_func = NULL;
; 1140 :                     outstring("Using YSMP.\n");

	push	OFFSET ??_C@_0N@NDMLKFJ@Using?5YSMP?4?6?$AA@
	mov	DWORD PTR _ysmp_flag, 1
	mov	DWORD PTR _sp_factor_func, OFFSET _ysmp_factor
	mov	DWORD PTR _sp_CHinvC_func, esi
	mov	DWORD PTR _sp_solve_func, OFFSET _ysmp_solve
	mov	DWORD PTR _sp_solve_multi_func, OFFSET _ysmp_solve_multi
	call	_outstring
	add	esp, 4

; 1141 :                  }
; 1142 :                  break;

	jmp	$LL271@hessian_me
$LN168@hessian_me:

; 1143 : 
; 1144 :              case 'U': /* toggle BK version of min degree */
; 1145 :                  BK_flag = !BK_flag;

	xor	eax, eax
	cmp	DWORD PTR _BK_flag, eax
	sete	al
	mov	DWORD PTR _BK_flag, eax

; 1146 :                  if ( BK_flag )

	test	eax, eax
	je	SHORT $LN167@hessian_me

; 1147 :                     outstring("Using Bunch-Kaufman version of minimal degree.\n");

	push	OFFSET ??_C@_0DA@HPHGACOG@Using?5Bunch?9Kaufman?5version?5of?5m@
	call	_outstring
	add	esp, 4

; 1148 :                  else

	jmp	$LL271@hessian_me
$LN167@hessian_me:

; 1149 :                  outstring("Using non-Bunch-Kaufman version of minimal degree.\n");

	push	OFFSET ??_C@_0DE@NBALCHDO@Using?5non?9Bunch?9Kaufman?5version?5@
	call	_outstring
	add	esp, 4

; 1150 :                  break;

	jmp	$LL271@hessian_me
$LN165@hessian_me:

; 1151 : 
; 1152 :              case 'M':
; 1153 :                  hess_move_con_flag = !hess_move_con_flag;

	xor	eax, eax
	cmp	DWORD PTR _hess_move_con_flag, eax
	sete	al
	mov	DWORD PTR _hess_move_con_flag, eax

; 1154 :                  if ( hess_move_con_flag )

	test	eax, eax
	je	SHORT $LN164@hessian_me

; 1155 :                     outstring("Projecting global constraints in move.\n");

	push	OFFSET ??_C@_0CI@JNHOPMJO@Projecting?5global?5constraints?5in@
	call	_outstring
	add	esp, 4

; 1156 :                  else

	jmp	$LL271@hessian_me
$LN164@hessian_me:

; 1157 :                  outstring("Not projecting global constraints in move.\n");

	push	OFFSET ??_C@_0CM@NMONBFB@Not?5projecting?5global?5constraint@
	call	_outstring
	add	esp, 4

; 1158 :                  break;

	jmp	$LL271@hessian_me
$LN162@hessian_me:

; 1159 :              case 'G':
; 1160 :                  min_square_grad_flag = !min_square_grad_flag;

	xor	eax, eax
	cmp	DWORD PTR _min_square_grad_flag, eax
	sete	al
	mov	DWORD PTR _min_square_grad_flag, eax

; 1161 :                  if ( min_square_grad_flag )

	test	eax, eax
	je	SHORT $LN161@hessian_me

; 1162 :                     outstring("Minimizing square gradient in seek.\n");

	push	OFFSET ??_C@_0CF@EMGEJCJA@Minimizing?5square?5gradient?5in?5se@
	call	_outstring
	add	esp, 4

; 1163 :                  else

	jmp	$LL271@hessian_me
$LN161@hessian_me:

; 1164 :                     outstring("Minimizing regular energy in seek.\n");

	push	OFFSET ??_C@_0CE@IDHGJPPA@Minimizing?5regular?5energy?5in?5see@
	call	_outstring
	add	esp, 4

; 1165 :                  break;

	jmp	$LL271@hessian_me
$LN159@hessian_me:

; 1166 : 
; 1167 :              case 'D': /* dump Hessian, 1-based indexing, matlab format. */
; 1168 :                  { FILE *fd;
; 1169 :                    char hname[200],mname[200];
; 1170 :                    size_t baselength;
; 1171 :                    int i,j,k;
; 1172 : 
; 1173 :                    if ( S.N == 0 )

	cmp	DWORD PTR _S$[ebp+4], 0
	jne	SHORT $LN287@hessian_me

; 1174 :                    { outstring("Need to do step 1 first before dumping Hessian.\n");

	push	OFFSET ??_C@_0DB@PIKAKACN@Need?5to?5do?5step?51?5first?5before?5d@
	call	_outstring
	add	esp, 4

; 1175 :                      break;

	jmp	$LL271@hessian_me
$LN287@hessian_me:

; 1176 :                    }
; 1177 : 
; 1178 : gethname:
; 1179 :                    outstring("Hessian dump. Note indexing is 1-based.\n");

	push	OFFSET ??_C@_0CJ@OOJNHDJC@Hessian?5dump?4?5Note?5indexing?5is?51@
	call	_outstring

; 1180 :                    prompt("Enter path and base name of Hessian dump files: ",
; 1181 :                       hname,200);

	push	200					; 000000c8H
	lea	ecx, DWORD PTR _hname$89769[ebp]
	push	ecx
	push	OFFSET ??_C@_0DB@FLPHPIAP@Enter?5path?5and?5base?5name?5of?5Hess@
	call	_prompt
	add	esp, 16					; 00000010H

; 1182 :                    if ( hname[0] == 0 ) break;

	cmp	BYTE PTR _hname$89769[ebp], 0
	je	$LL271@hessian_me
$gethname$89777:

; 1183 :                    strcpy(mname,hname);

	xor	eax, eax
	npad	8
$LL274@hessian_me:
	mov	cl, BYTE PTR _hname$89769[ebp+eax]
	mov	BYTE PTR _mname$89770[ebp+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL274@hessian_me

; 1184 :                    baselength = strlen(hname);

	lea	eax, DWORD PTR _hname$89769[ebp]
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL360@hessian_me:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL360@hessian_me
	sub	eax, edx
	mov	DWORD PTR tv1741[ebp], eax

; 1185 :                    strcat(hname,"_H.dat");

	lea	eax, DWORD PTR _hname$89769[ebp]
	dec	eax
$LL361@hessian_me:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL361@hessian_me
	mov	edx, DWORD PTR ??_C@_06JMPGNNAK@_H?4dat?$AA@
	mov	cx, WORD PTR ??_C@_06JMPGNNAK@_H?4dat?$AA@+4
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR ??_C@_06JMPGNNAK@_H?4dat?$AA@+6
	mov	WORD PTR [eax+4], cx
	mov	BYTE PTR [eax+6], dl

; 1186 :                    fd = fopen(hname,"w");

	lea	eax, DWORD PTR _hname$89769[ebp]
	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	eax
	call	_fopen
	mov	ebx, eax
	add	esp, 8

; 1187 :                    if ( fd == NULL )

	test	ebx, ebx
	jne	SHORT $LN156@hessian_me

; 1188 :                    {
; 1189 : #ifdef __L_EVOLVER__		 
; 1190 : 		   		     if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, eax
	jne	SHORT $LN154@hessian_me
	cmp	DWORD PTR _l_evolver_mode, eax
	jne	SHORT $LN154@hessian_me

; 1192 : 		   		     else
; 1193 : 					   perror(hname);

	lea	ecx, DWORD PTR _hname$89769[ebp]
	jmp	$LN386@hessian_me
$LN154@hessian_me:

; 1191 : 			   		   erroutstring(hname);

	lea	edx, DWORD PTR _hname$89769[ebp]
	push	edx
	call	_erroutstring

; 1194 : #else
; 1195 : 					 perror(hname);
; 1196 : #endif			  
; 1197 : 					 goto gethname; 

	jmp	$LN387@hessian_me
$LN156@hessian_me:

; 1198 : 				   }
; 1199 :                    sprintf(msg,
; 1200 :             "Dumping Hessian upper triangle in row col value format to %s.\n",
; 1201 :                        hname);

	mov	ecx, DWORD PTR _msg
	lea	eax, DWORD PTR _hname$89769[ebp]
	push	eax
	push	OFFSET ??_C@_0DP@GHCEOKCM@Dumping?5Hessian?5upper?5triangle?5i@
	push	ecx
	call	_sprintf

; 1202 :                    outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 1203 :                    for ( i = 0 ; i < S.N ; i++ )

	xor	edi, edi
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _S$[ebp+4], edi
	jle	SHORT $LN150@hessian_me
	mov	eax, DWORD PTR _S$[ebp+52]
$LL152@hessian_me:

; 1204 :                      for ( j = S.IA[i]-A_OFF ; j < S.IA[i+1]-A_OFF ; j++ )

	mov	esi, DWORD PTR [eax+edi*4]
	mov	ecx, DWORD PTR [eax+edi*4+4]
	dec	esi
	dec	ecx
	cmp	esi, ecx
	jge	SHORT $LN151@hessian_me
	npad	12
$LL149@hessian_me:

; 1205 :                      { fprintf(fd,"%6d %6d %20.15f\n",i+1,S.JA[j]-A_OFF+1,
; 1206 :                              (DOUBLE)S.A[j]);

	mov	edx, DWORD PTR _S$[ebp+60]
	fld	QWORD PTR [edx+esi*8]
	mov	eax, DWORD PTR _S$[ebp+56]
	mov	ecx, DWORD PTR [eax+esi*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	lea	edx, DWORD PTR [edi+1]
	push	edx
	push	OFFSET ??_C@_0BB@MGONLNEG@?$CF6d?5?$CF6d?5?$CF20?415f?6?$AA@
	push	ebx
	call	_fprintf
	mov	eax, DWORD PTR _S$[ebp+52]
	mov	ecx, DWORD PTR [eax+edi*4+4]
	inc	esi
	dec	ecx
	add	esp, 24					; 00000018H
	cmp	esi, ecx
	jl	SHORT $LL149@hessian_me
$LN151@hessian_me:

; 1203 :                    for ( i = 0 ; i < S.N ; i++ )

	inc	edi
	cmp	edi, DWORD PTR _S$[ebp+4]
	jl	SHORT $LL152@hessian_me
$LN150@hessian_me:

; 1207 :                      }
; 1208 :                    fclose(fd);

	push	ebx
	call	_fclose
	add	esp, 4

; 1209 : 
; 1210 :                    if ( hessian_linear_metric_flag )

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	$LN146@hessian_me

; 1211 :                    {
; 1212 :                      strcat(mname,"_M.dat");

	lea	eax, DWORD PTR _mname$89770[ebp]
	dec	eax
$LL362@hessian_me:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL362@hessian_me
	mov	edx, DWORD PTR ??_C@_06MMDLEMLJ@_M?4dat?$AA@
	mov	cx, WORD PTR ??_C@_06MMDLEMLJ@_M?4dat?$AA@+4
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR ??_C@_06MMDLEMLJ@_M?4dat?$AA@+6
	mov	WORD PTR [eax+4], cx
	mov	BYTE PTR [eax+6], dl

; 1213 :                      fd = fopen(mname,"w");

	lea	eax, DWORD PTR _mname$89770[ebp]
	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	eax
	call	_fopen
	mov	ebx, eax
	add	esp, 8

; 1214 :                      if ( fd == NULL )

	test	ebx, ebx
	jne	SHORT $LN145@hessian_me

; 1215 :                      { perror(mname); goto gethname; }

	lea	ecx, DWORD PTR _mname$89770[ebp]
$LN386@hessian_me:
	push	ecx
	call	_perror
$LN387@hessian_me:
	add	esp, 4
	push	OFFSET ??_C@_0CJ@OOJNHDJC@Hessian?5dump?4?5Note?5indexing?5is?51@
	call	_outstring
	push	200					; 000000c8H
	lea	edx, DWORD PTR _hname$89769[ebp]
	push	edx
	push	OFFSET ??_C@_0DB@FLPHPIAP@Enter?5path?5and?5base?5name?5of?5Hess@
	call	_prompt
	add	esp, 16					; 00000010H
	cmp	BYTE PTR _hname$89769[ebp], 0
	jne	$gethname$89777

; 1182 :                    if ( hname[0] == 0 ) break;

	jmp	$LL271@hessian_me
$LN145@hessian_me:

; 1216 :                      sprintf(msg, "Dumping Hessian metric upper triangle in row col value format to %s.\n", mname);

	mov	ecx, DWORD PTR _msg
	lea	eax, DWORD PTR _mname$89770[ebp]
	push	eax
	push	OFFSET ??_C@_0EG@IIMCAMAE@Dumping?5Hessian?5metric?5upper?5tri@
	push	ecx
	call	_sprintf

; 1217 :                      outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 1218 :                      for ( i = 0 ; i < Met.N ; i++ )

	xor	edi, edi
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _Met+4, edi
	jle	SHORT $LN142@hessian_me
	mov	eax, DWORD PTR _Met+52
	npad	7
$LL144@hessian_me:

; 1219 :                        for ( j = Met.IA[i]-A_OFF ; j < Met.IA[i+1]-A_OFF ; j++ )

	mov	esi, DWORD PTR [eax+edi*4]
	mov	ecx, DWORD PTR [eax+edi*4+4]
	dec	esi
	dec	ecx
	cmp	esi, ecx
	jge	SHORT $LN143@hessian_me
	npad	3
$LL141@hessian_me:

; 1220 :                        { fprintf(fd,"%6d %6d %20.15f\n",i+1,Met.JA[j]-A_OFF+1,
; 1221 :                             (DOUBLE)Met.A[j]);

	mov	edx, DWORD PTR _Met+60
	fld	QWORD PTR [edx+esi*8]
	mov	eax, DWORD PTR _Met+56
	mov	ecx, DWORD PTR [eax+esi*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	lea	edx, DWORD PTR [edi+1]
	push	edx
	push	OFFSET ??_C@_0BB@MGONLNEG@?$CF6d?5?$CF6d?5?$CF20?415f?6?$AA@
	push	ebx
	call	_fprintf
	mov	eax, DWORD PTR _Met+52
	mov	ecx, DWORD PTR [eax+edi*4+4]
	inc	esi
	dec	ecx
	add	esp, 24					; 00000018H
	cmp	esi, ecx
	jl	SHORT $LL141@hessian_me
$LN143@hessian_me:

; 1218 :                      for ( i = 0 ; i < Met.N ; i++ )

	inc	edi
	cmp	edi, DWORD PTR _Met+4
	jl	SHORT $LL144@hessian_me
$LN142@hessian_me:

; 1222 :                        }
; 1223 :                      fclose(fd);

	push	ebx
	call	_fclose
	add	esp, 4
$LN146@hessian_me:

; 1224 :                    }
; 1225 : 
; 1226 :                    if ( right_flag )

	cmp	DWORD PTR _right_flag$[ebp], 0
	je	$LN138@hessian_me

; 1227 :                    { strcpy(hname+baselength,"_rhs.dat");

	mov	eax, DWORD PTR tv1741[ebp]
	mov	edx, DWORD PTR ??_C@_08KHHEGCCC@_rhs?4dat?$AA@
	mov	ecx, DWORD PTR ??_C@_08KHHEGCCC@_rhs?4dat?$AA@+4
	lea	eax, DWORD PTR _hname$89769[ebp+eax]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR ??_C@_08KHHEGCCC@_rhs?4dat?$AA@+8
	mov	DWORD PTR [eax+4], ecx

; 1228 :                      sprintf(msg,"Dumping right hand side to %s.\n",hname);

	mov	ecx, DWORD PTR _msg
	mov	BYTE PTR [eax+8], dl
	lea	eax, DWORD PTR _hname$89769[ebp]
	push	eax
	push	OFFSET ??_C@_0CA@DOOHECOM@Dumping?5right?5hand?5side?5to?5?$CFs?4?6?$AA@
	push	ecx
	call	_sprintf

; 1229 :                      outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 1230 :                      fd = fopen(hname,"w");

	lea	eax, DWORD PTR _hname$89769[ebp]
	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	eax
	call	_fopen
	mov	edi, eax
	add	esp, 24					; 00000018H

; 1231 :                      if ( fd == NULL )

	test	edi, edi
	jne	SHORT $LN137@hessian_me

; 1232 :                      { perror(hname);

	lea	ecx, DWORD PTR _hname$89769[ebp]
	push	ecx
	call	_perror
	add	esp, 4

; 1233 :                        break;

	jmp	$LL271@hessian_me
$LN137@hessian_me:

; 1234 :                      }
; 1235 :                      for ( i = 0 ; i < S.N ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _S$[ebp+4], esi
	jle	SHORT $LN134@hessian_me
	mov	ebx, DWORD PTR _rhs$[ebp]
$LL136@hessian_me:

; 1236 :                        fprintf(fd,"%20.15f\n",(DOUBLE)(rhs[i]));

	fld	QWORD PTR [ebx+esi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_08GOLMHPBE@?$CF20?415f?6?$AA@
	push	edi
	call	_fprintf
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR _S$[ebp+4]
	jl	SHORT $LL136@hessian_me
$LN134@hessian_me:

; 1237 :                      fclose(fd);

	push	edi
	call	_fclose
	add	esp, 4
$LN138@hessian_me:

; 1238 :                    }
; 1239 : 
; 1240 :                    if ( ysmp_flag != MINDEG_FACTORING )

	cmp	DWORD PTR _ysmp_flag, 0
	je	SHORT $LN133@hessian_me

; 1241 :                    { outstring("Further dumping of factors in minimal degree mode (ysmp off) only.\n");

	push	OFFSET ??_C@_0EE@NENMBAIG@Further?5dumping?5of?5factors?5in?5mi@
	call	_outstring
	add	esp, 4

; 1242 :                      break;

	jmp	$LL271@hessian_me
$LN133@hessian_me:

; 1243 :                    }
; 1244 : 
; 1245 :                    if ( !S.LA )

	cmp	DWORD PTR _S$[ebp+140], 0
	jne	SHORT $LN132@hessian_me

; 1246 :                    { outstring("Need to do step 3, P, V, or Z before dumping factors.\n");

	push	OFFSET ??_C@_0DH@CGFLGEDD@Need?5to?5do?5step?53?0?5P?0?5V?0?5or?5Z?5be@
	call	_outstring
	add	esp, 4

; 1247 :                      break;

	jmp	$LL271@hessian_me
$LN132@hessian_me:

; 1248 :                    }
; 1249 :                    strcpy(hname+baselength,"_L.dat");

	mov	eax, DWORD PTR tv1741[ebp]
	mov	edx, DWORD PTR ??_C@_06HGHJPBM@_L?4dat?$AA@
	mov	cx, WORD PTR ??_C@_06HGHJPBM@_L?4dat?$AA@+4
	lea	eax, DWORD PTR _hname$89769[ebp+eax]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR ??_C@_06HGHJPBM@_L?4dat?$AA@+6
	mov	WORD PTR [eax+4], cx

; 1250 :                    sprintf(msg,
; 1251 :             "Dumping L factor in row col value format to %s.\n",hname);

	mov	ecx, DWORD PTR _msg
	mov	DWORD PTR tv1793[ebp], eax
	mov	BYTE PTR [eax+6], dl
	lea	eax, DWORD PTR _hname$89769[ebp]
	push	eax
	push	OFFSET ??_C@_0DB@HCNMBGLI@Dumping?5L?5factor?5in?5row?5col?5valu@
	push	ecx
	call	_sprintf

; 1252 :                    outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H

; 1253 :                    if ( hname[0] == 0 ) break;

	cmp	BYTE PTR _hname$89769[ebp], 0
	je	$LL271@hessian_me

; 1254 :                    fd = fopen(hname,"w");

	lea	eax, DWORD PTR _hname$89769[ebp]
	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fd$89768[ebp], eax

; 1255 :                    if ( fd == NULL )

	test	eax, eax
	jne	SHORT $LN130@hessian_me

; 1256 :                    {
; 1257 : #ifdef __L_EVOLVER__		 
; 1258 : 		   		     if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, eax
	jne	SHORT $LN128@hessian_me
	cmp	DWORD PTR _l_evolver_mode, eax
	jne	SHORT $LN128@hessian_me

; 1260 : 		   		     else
; 1261 : 					   perror(hname);

	lea	ecx, DWORD PTR _hname$89769[ebp]
	push	ecx
	call	_perror
	add	esp, 4
	jmp	$LL271@hessian_me
$LN128@hessian_me:

; 1259 : 			   		   erroutstring(hname);

	lea	edx, DWORD PTR _hname$89769[ebp]
	push	edx
	call	_erroutstring
	add	esp, 4

; 1262 : #else
; 1263 : 					 perror(hname);
; 1264 : #endif
; 1265 : 					 break; 

	jmp	$LL271@hessian_me
$LN130@hessian_me:

; 1266 : 				   }
; 1267 :                    for ( i = 0 ; i < S.N ; i++ )

	cmp	DWORD PTR _S$[ebp+4], 0
	jle	$LN124@hessian_me
	xor	edi, edi
	mov	ebx, 1
	npad	3
$LL126@hessian_me:

; 1268 :                    { fprintf(fd,"%6d %6d %20.15f\n",i+1,i+1,1.0);

	fld1
	mov	eax, DWORD PTR _fd$89768[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ebx
	push	ebx
	push	OFFSET ??_C@_0BB@MGONLNEG@?$CF6d?5?$CF6d?5?$CF20?415f?6?$AA@
	push	eax
	call	_fprintf

; 1269 :                      for ( j = S.LIA[i]+S.psize[i], k = S.LIJA[i]+S.psize[i] ;
; 1270 :                         j < S.LIA[i+1] ; j++,k++ )

	mov	edx, DWORD PTR _S$[ebp+128]
	mov	ecx, DWORD PTR _S$[ebp+120]
	mov	ecx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR _S$[ebp+136]
	mov	esi, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [edi+eax]
	add	esi, ecx
	add	esp, 24					; 00000018H
	add	eax, ecx
	cmp	esi, DWORD PTR [edi+edx+4]
	jge	SHORT $LN125@hessian_me

; 1268 :                    { fprintf(fd,"%6d %6d %20.15f\n",i+1,i+1,1.0);

	lea	ecx, DWORD PTR [eax*4]
	mov	DWORD PTR tv2557[ebp], ecx
$LL123@hessian_me:

; 1271 :                      { fprintf(fd,"%6d %6d %20.15f\n",i+1,S.LJA[k]+1,(DOUBLE)(S.LA[j]));

	mov	edx, DWORD PTR _S$[ebp+140]
	fld	QWORD PTR [edx+esi*8]
	mov	eax, DWORD PTR _S$[ebp+132]
	mov	ecx, DWORD PTR tv2557[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _fd$89768[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	inc	edx
	push	edx
	push	ebx
	push	OFFSET ??_C@_0BB@MGONLNEG@?$CF6d?5?$CF6d?5?$CF20?415f?6?$AA@
	push	eax
	call	_fprintf
	mov	ecx, DWORD PTR _S$[ebp+128]
	add	DWORD PTR tv2557[ebp], 4
	inc	esi
	add	esp, 24					; 00000018H
	cmp	esi, DWORD PTR [edi+ecx+4]
	jl	SHORT $LL123@hessian_me
$LN125@hessian_me:

; 1266 : 				   }
; 1267 :                    for ( i = 0 ; i < S.N ; i++ )

	inc	ebx
	lea	edx, DWORD PTR [ebx-1]
	add	edi, 4
	cmp	edx, DWORD PTR _S$[ebp+4]
	jl	$LL126@hessian_me
$LN124@hessian_me:

; 1272 :                      }
; 1273 :                    }
; 1274 :                    fclose(fd);

	mov	eax, DWORD PTR _fd$89768[ebp]
	push	eax
	call	_fclose

; 1275 : 
; 1276 :                    strcpy(hname+baselength,"_D.dat");

	mov	eax, DWORD PTR tv1793[ebp]
	mov	ecx, DWORD PTR ??_C@_06OLDEBNHB@_D?4dat?$AA@
	mov	dx, WORD PTR ??_C@_06OLDEBNHB@_D?4dat?$AA@+4
	mov	DWORD PTR [eax], ecx
	mov	cl, BYTE PTR ??_C@_06OLDEBNHB@_D?4dat?$AA@+6
	mov	WORD PTR [eax+4], dx

; 1277 :                    sprintf(msg,
; 1278 :             "Dumping diagonal factor in row col value format to %s.\n",hname);

	lea	edx, DWORD PTR _hname$89769[ebp]
	push	edx
	mov	BYTE PTR [eax+6], cl
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0DI@OCIBNFFO@Dumping?5diagonal?5factor?5in?5row?5c@
	push	eax
	call	_sprintf

; 1279 :                    outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 20					; 00000014H

; 1280 :                    if ( hname[0] == 0 ) break;

	cmp	BYTE PTR _hname$89769[ebp], 0
	je	$LL271@hessian_me

; 1281 :                    fd = fopen(hname,"w");

	lea	edx, DWORD PTR _hname$89769[ebp]
	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	edx
	call	_fopen
	mov	ebx, eax
	add	esp, 8

; 1282 :                    if ( fd == NULL )

	test	ebx, ebx
	jne	SHORT $LN119@hessian_me

; 1283 :                    { 
; 1284 : #ifdef __L_EVOLVER__		 
; 1285 : 		   		     if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, eax
	jne	SHORT $LN117@hessian_me
	cmp	DWORD PTR _l_evolver_mode, eax
	jne	SHORT $LN117@hessian_me

; 1287 : 		   		     else
; 1288 : 					   perror(hname);

	lea	eax, DWORD PTR _hname$89769[ebp]
	push	eax
	call	_perror
	add	esp, 4
	jmp	$LL271@hessian_me
$LN117@hessian_me:

; 1286 : 			   		   erroutstring(hname);

	lea	ecx, DWORD PTR _hname$89769[ebp]
	push	ecx
	call	_erroutstring
	add	esp, 4

; 1289 : #else
; 1290 : 					 perror(hname);
; 1291 : #endif
; 1292 : 
; 1293 : 				     break; 

	jmp	$LL271@hessian_me
$LN119@hessian_me:

; 1294 : 				   }
; 1295 :                    for ( i = 0 ; i < S.N ; i++ )

	xor	edi, edi
	cmp	DWORD PTR _S$[ebp+4], edi
	jle	$LN113@hessian_me
	lea	esi, DWORD PTR [edi+1]
$LL115@hessian_me:

; 1296 :                    { j = S.LIA[i]; k = S.LIJA[i]; 

	mov	edx, DWORD PTR _S$[ebp+128]
	mov	eax, DWORD PTR [edx+edi*4]
	mov	ecx, DWORD PTR _S$[ebp+136]
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	DWORD PTR _j$89773[ebp], eax

; 1297 :                      if ( S.psize[i] == 1 )

	mov	eax, DWORD PTR _S$[ebp+120]

; 1298 :                      { fprintf(fd,"%6d %6d %20.15f\n",i+1,S.LJA[k]+1,
; 1299 :                           (DOUBLE)S.LA[j]);

	sub	esp, 8
	cmp	DWORD PTR [eax+edi*4], 1
	mov	DWORD PTR _k$89774[ebp], edx
	jne	SHORT $LN112@hessian_me
	mov	ecx, DWORD PTR _S$[ebp+140]
	mov	edx, DWORD PTR _j$89773[ebp]
	fld	QWORD PTR [ecx+edx*8]
	mov	eax, DWORD PTR _S$[ebp+132]
	mov	ecx, DWORD PTR _k$89774[ebp]
	fstp	QWORD PTR [esp]
	mov	edx, DWORD PTR [eax+ecx*4]
	inc	edx
	push	edx

; 1300 :                      }
; 1301 :                      else

	jmp	$LN388@hessian_me
$LN112@hessian_me:

; 1302 :                      { fprintf(fd,"%6d %6d %20.15f\n",i+1,S.LJA[k]+1,
; 1303 :                           (DOUBLE)S.LA[j]);

	mov	eax, DWORD PTR _S$[ebp+140]
	mov	ecx, DWORD PTR _j$89773[ebp]
	fld	QWORD PTR [eax+ecx*8]
	mov	edx, DWORD PTR _S$[ebp+132]
	mov	eax, DWORD PTR _k$89774[ebp]
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR [edx+eax*4]
	inc	ecx
	push	ecx
	push	esi
	push	OFFSET ??_C@_0BB@MGONLNEG@?$CF6d?5?$CF6d?5?$CF20?415f?6?$AA@
	push	ebx
	call	_fprintf

; 1304 :                        fprintf(fd,"%6d %6d %20.15f\n",i+1,S.LJA[k+1]+1,
; 1305 :                           (DOUBLE)S.LA[j+1]);

	mov	edx, DWORD PTR _S$[ebp+140]
	mov	eax, DWORD PTR _j$89773[ebp]
	fld	QWORD PTR [edx+eax*8+8]
	mov	ecx, DWORD PTR _S$[ebp+132]
	mov	edx, DWORD PTR _k$89774[ebp]
	fstp	QWORD PTR [esp+16]
	mov	eax, DWORD PTR [ecx+edx*4+4]
	add	esp, 16					; 00000010H
	inc	eax
	push	eax
	push	esi
	push	OFFSET ??_C@_0BB@MGONLNEG@?$CF6d?5?$CF6d?5?$CF20?415f?6?$AA@
	push	ebx
	call	_fprintf

; 1306 :                        fprintf(fd,"%6d %6d %20.15f\n",S.LJA[k+1]+1,i+1,
; 1307 :                           (DOUBLE)S.LA[j+1]);

	mov	ecx, DWORD PTR _S$[ebp+140]
	mov	edx, DWORD PTR _j$89773[ebp]
	fld	QWORD PTR [ecx+edx*8+8]
	mov	eax, DWORD PTR _S$[ebp+132]
	mov	ecx, DWORD PTR _k$89774[ebp]
	fstp	QWORD PTR [esp+16]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	add	esp, 16					; 00000010H
	push	esi
	inc	edx
	push	edx
	push	OFFSET ??_C@_0BB@MGONLNEG@?$CF6d?5?$CF6d?5?$CF20?415f?6?$AA@
	push	ebx
	call	_fprintf

; 1308 :                        i++;
; 1309 :                        j = S.LIA[i]; k = S.LIJA[i]; 

	mov	eax, DWORD PTR _S$[ebp+128]
	mov	eax, DWORD PTR [eax+edi*4+4]

; 1310 :                        fprintf(fd,"%6d %6d %20.15f\n",i+1,S.LJA[k]+1,
; 1311 :                           (DOUBLE)S.LA[j]);

	mov	edx, DWORD PTR _S$[ebp+140]
	mov	ecx, DWORD PTR _S$[ebp+136]
	fld	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR [ecx+edi*4+4]
	fstp	QWORD PTR [esp+16]
	mov	eax, DWORD PTR _S$[ebp+132]
	mov	ecx, DWORD PTR [eax+ecx*4]
	inc	edi
	add	esp, 16					; 00000010H
	inc	esi
	inc	ecx
	push	ecx
$LN388@hessian_me:
	push	esi
	push	OFFSET ??_C@_0BB@MGONLNEG@?$CF6d?5?$CF6d?5?$CF20?415f?6?$AA@
	push	ebx
	call	_fprintf
	inc	edi
	add	esp, 24					; 00000018H
	inc	esi
	cmp	edi, DWORD PTR _S$[ebp+4]
	jl	$LL115@hessian_me
$LN113@hessian_me:

; 1312 :                      }
; 1313 :                    }
; 1314 :                    fclose(fd);

	push	ebx
	call	_fclose

; 1315 :                    if ( !augmented_hessian_mode )
; 1316 :                    { strcpy(hname+baselength,"_C.dat");

	mov	esi, DWORD PTR tv1793[ebp]
	add	esp, 4
	cmp	DWORD PTR _augmented_hessian_mode, 0
	jne	$LN110@hessian_me
	mov	edx, DWORD PTR ??_C@_06PGDBCNMJ@_C?4dat?$AA@
	mov	ax, WORD PTR ??_C@_06PGDBCNMJ@_C?4dat?$AA@+4
	mov	cl, BYTE PTR ??_C@_06PGDBCNMJ@_C?4dat?$AA@+6
	mov	DWORD PTR [esi], edx

; 1317 :                      sprintf(msg,
; 1318 :             "Dumping constraint matrix in row col value format to %s.\n",hname);

	lea	edx, DWORD PTR _hname$89769[ebp]
	push	edx
	mov	WORD PTR [esi+4], ax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0DK@KGGNGGBI@Dumping?5constraint?5matrix?5in?5row@
	push	eax
	mov	BYTE PTR [esi+6], cl
	call	_sprintf

; 1319 :                      outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring

; 1320 :                      fd = fopen(hname,"w");

	lea	edx, DWORD PTR _hname$89769[ebp]
	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	edx
	call	_fopen
	mov	ebx, eax
	add	esp, 24					; 00000018H
	mov	DWORD PTR _fd$89768[ebp], ebx

; 1321 :                      if ( fd == NULL )

	test	ebx, ebx
	jne	SHORT $LN109@hessian_me

; 1322 :                      { 
; 1323 : #ifdef __L_EVOLVER__		 
; 1324 : 		   		       if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, eax
	jne	$LN117@hessian_me
	cmp	DWORD PTR _l_evolver_mode, eax
	jne	$LN117@hessian_me

; 1325 : 			   		     erroutstring(hname);
; 1326 : 		   		       else
; 1327 : 					     perror(hname);

	lea	eax, DWORD PTR _hname$89769[ebp]
	push	eax
	call	_perror
	add	esp, 4
	jmp	$LL271@hessian_me
$LN109@hessian_me:

; 1328 : #else
; 1329 :                        perror(hname);
; 1330 : #endif
; 1331 : 					   break; 
; 1332 : 					 }
; 1333 :                      for ( i = 0 ; i < S.CN ; i++ )

	xor	edi, edi
	cmp	DWORD PTR _S$[ebp+148], edi
	jle	$LN103@hessian_me
	mov	eax, DWORD PTR _S$[ebp+172]
$LN105@hessian_me:

; 1334 :                      { if ( S.CIA )

	test	eax, eax
	je	SHORT $LN102@hessian_me

; 1335 :                        for ( j = S.CIA[i] ; j < S.CIA[i+1] ; j++ )

	mov	esi, DWORD PTR [eax+edi*4]
	cmp	esi, DWORD PTR [eax+edi*4+4]
	jge	$LN104@hessian_me
	lea	ebx, DWORD PTR [edi+1]
	npad	6
$LL101@hessian_me:

; 1336 :                        { fprintf(fd,"%6d %6d %20.15f\n",i+1,S.CJA[j]+1,
; 1337 :                           (DOUBLE)S.CA[j]);

	mov	edx, DWORD PTR _S$[ebp+180]
	mov	eax, DWORD PTR _S$[ebp+176]
	fld	QWORD PTR [edx+esi*8]
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	edx, DWORD PTR _fd$89768[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	inc	ecx
	push	ecx
	push	ebx
	push	OFFSET ??_C@_0BB@MGONLNEG@?$CF6d?5?$CF6d?5?$CF20?415f?6?$AA@
	push	edx
	call	_fprintf
	mov	eax, DWORD PTR _S$[ebp+172]
	inc	esi
	add	esp, 24					; 00000018H
	cmp	esi, DWORD PTR [eax+edi*4+4]
	jl	SHORT $LL101@hessian_me

; 1338 :                        }
; 1339 :                        else /* dense */

	mov	ebx, DWORD PTR _fd$89768[ebp]
	jmp	SHORT $LN104@hessian_me
$LN102@hessian_me:

; 1340 :                        for ( j = 0 ; j < S.N ; j++ )

	xor	esi, esi
	cmp	DWORD PTR _S$[ebp+4], esi
	jle	SHORT $LN104@hessian_me
	npad	2
$LL97@hessian_me:
	mov	eax, DWORD PTR _S$[ebp+160]
	mov	ecx, DWORD PTR [eax+edi*4]

; 1341 :                          if ( S.C[i][j] )

	fld	QWORD PTR [ecx+esi*8]
	lea	ecx, DWORD PTR [ecx+esi*8]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN96@hessian_me

; 1342 :                            fprintf(fd,"%6d %6d %20.15f\n",i+1,j+1,
; 1343 :                           (DOUBLE)S.C[i][j]);

	fld	QWORD PTR [ecx]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	edx, DWORD PTR [esi+1]
	push	edx
	lea	eax, DWORD PTR [edi+1]
	push	eax
	push	OFFSET ??_C@_0BB@MGONLNEG@?$CF6d?5?$CF6d?5?$CF20?415f?6?$AA@
	push	ebx
	call	_fprintf
	add	esp, 24					; 00000018H
$LN96@hessian_me:

; 1340 :                        for ( j = 0 ; j < S.N ; j++ )

	inc	esi
	cmp	esi, DWORD PTR _S$[ebp+4]
	jl	SHORT $LL97@hessian_me
	mov	eax, DWORD PTR _S$[ebp+172]
$LN104@hessian_me:

; 1328 : #else
; 1329 :                        perror(hname);
; 1330 : #endif
; 1331 : 					   break; 
; 1332 : 					 }
; 1333 :                      for ( i = 0 ; i < S.CN ; i++ )

	inc	edi
	cmp	edi, DWORD PTR _S$[ebp+148]
	jl	$LN105@hessian_me
	mov	esi, DWORD PTR tv1793[ebp]
$LN103@hessian_me:

; 1344 :                      }
; 1345 :                      fclose(fd);

	push	ebx
	call	_fclose
	add	esp, 4
$LN110@hessian_me:

; 1346 :                    }
; 1347 :                    strcpy(hname+baselength,"_P.dat");

	mov	ecx, DWORD PTR ??_C@_06HDHDFNPM@_P?4dat?$AA@
	mov	dx, WORD PTR ??_C@_06HDHDFNPM@_P?4dat?$AA@+4
	mov	al, BYTE PTR ??_C@_06HDHDFNPM@_P?4dat?$AA@+6
	mov	DWORD PTR [esi], ecx

; 1348 :                    sprintf(msg,
; 1349 :             "Dumping permutation in one line format to %s.\n",hname);

	lea	ecx, DWORD PTR _hname$89769[ebp]
	push	ecx
	mov	WORD PTR [esi+4], dx
	mov	edx, DWORD PTR _msg
	push	OFFSET ??_C@_0CP@KHFHKCOA@Dumping?5permutation?5in?5one?5line?5@
	push	edx
	mov	BYTE PTR [esi+6], al
	call	_sprintf

; 1350 :                    outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring

; 1351 :                    fd = fopen(hname,"w");

	lea	ecx, DWORD PTR _hname$89769[ebp]
	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	ecx
	call	_fopen
	mov	edi, eax
	add	esp, 24					; 00000018H

; 1352 :                    if ( fd == NULL )

	test	edi, edi
	jne	SHORT $LN93@hessian_me

; 1353 :                      { 
; 1354 : #ifdef __L_EVOLVER__		 
; 1355 : 		   		       if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, eax
	jne	SHORT $LN91@hessian_me
	cmp	DWORD PTR _l_evolver_mode, eax
	jne	SHORT $LN91@hessian_me

; 1357 : 		   		       else
; 1358 : 					     perror(hname);

	lea	edx, DWORD PTR _hname$89769[ebp]
	push	edx
	call	_perror
	add	esp, 4
	jmp	$LL271@hessian_me
$LN91@hessian_me:

; 1356 : 			   		     erroutstring(hname);

	lea	eax, DWORD PTR _hname$89769[ebp]
	push	eax
	call	_erroutstring
	add	esp, 4

; 1359 : #else
; 1360 :                        perror(hname);
; 1361 : #endif
; 1362 : 					   break; 

	jmp	$LL271@hessian_me
$LN93@hessian_me:

; 1363 : 					 }
; 1364 :                    for ( i = 0 ; i < S.N ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _S$[ebp+4], esi
	jle	SHORT $LN87@hessian_me
	npad	3
$LL89@hessian_me:

; 1365 :                    { fprintf(fd,"%6d",S.P[i]+1);

	mov	ecx, DWORD PTR _S$[ebp+68]
	mov	edx, DWORD PTR [ecx+esi*4]
	inc	edx
	push	edx
	push	OFFSET ??_C@_03GICAEIGO@?$CF6d?$AA@
	push	edi
	call	_fprintf
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, DWORD PTR _S$[ebp+4]
	jl	SHORT $LL89@hessian_me
$LN87@hessian_me:

; 1366 :                    }
; 1367 :                    fprintf(fd,"\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	push	edi
	call	_fprintf

; 1368 :                    fclose(fd);

	push	edi
	call	_fclose
	add	esp, 12					; 0000000cH

; 1369 : 
; 1370 :                    if ( dir_flag )

	cmp	DWORD PTR _dir_flag$[ebp], 0
	je	$LL271@hessian_me

; 1371 :                    { strcpy(hname+baselength,"_solution.dat");

	mov	eax, DWORD PTR tv1793[ebp]
	mov	ecx, DWORD PTR ??_C@_0O@KNJFMHPI@_solution?4dat?$AA@
	mov	edx, DWORD PTR ??_C@_0O@KNJFMHPI@_solution?4dat?$AA@+4
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR ??_C@_0O@KNJFMHPI@_solution?4dat?$AA@+8
	mov	DWORD PTR [eax+4], edx
	mov	dx, WORD PTR ??_C@_0O@KNJFMHPI@_solution?4dat?$AA@+12
	mov	DWORD PTR [eax+8], ecx

; 1372 :                      sprintf(msg,"Dumping solution vector to %s.\n",hname);

	mov	ecx, DWORD PTR _msg
	mov	WORD PTR [eax+12], dx
	lea	eax, DWORD PTR _hname$89769[ebp]
	push	eax
	push	OFFSET ??_C@_0CA@GCAAOKAE@Dumping?5solution?5vector?5to?5?$CFs?4?6?$AA@
	push	ecx
	call	_sprintf

; 1373 :                      outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 1374 :                      fd = fopen(hname,"w");

	lea	eax, DWORD PTR _hname$89769[ebp]
	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	eax
	call	_fopen
	mov	edi, eax
	add	esp, 24					; 00000018H

; 1375 :                      if ( fd == NULL )

	test	edi, edi
	jne	SHORT $LN85@hessian_me

; 1376 :                      { perror(hname);

	lea	ecx, DWORD PTR _hname$89769[ebp]
	push	ecx
	call	_perror
	add	esp, 4

; 1377 :                        break;

	jmp	$LL271@hessian_me
$LN85@hessian_me:

; 1378 :                      }
; 1379 :                      for ( i = 0 ; i < S.N ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _S$[ebp+4], esi
	jle	SHORT $LN82@hessian_me
	mov	ebx, DWORD PTR _X$[ebp]
$LL84@hessian_me:

; 1380 :                        fprintf(fd,"%20.15f\n",(DOUBLE)(X[i]));

	fld	QWORD PTR [ebx+esi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_08GOLMHPBE@?$CF20?415f?6?$AA@
	push	edi
	call	_fprintf
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR _S$[ebp+4]
	jl	SHORT $LL84@hessian_me
$LN82@hessian_me:

; 1381 :                      fclose(fd);

	push	edi
	call	_fclose
	add	esp, 4

; 1382 :                    }
; 1383 : 
; 1384 :                  }
; 1385 :                break;

	jmp	$LL271@hessian_me
$LN81@hessian_me:

; 1386 : 
; 1387 : 
; 1388 :              case 'K': /* dump Hessian, 1-based indexing, mathematica format. */
; 1389 :                  { FILE *fd;
; 1390 :                    char hname[200],bname[200];
; 1391 :                    int i,j,k,comma_flag;
; 1392 :                    bname[0] = 0;
; 1393 : 
; 1394 :                    if ( S.N == 0 )

	xor	ebx, ebx
	mov	BYTE PTR _bname$89901[ebp], 0
	cmp	DWORD PTR _S$[ebp+4], ebx
	jne	SHORT $LN80@hessian_me

; 1395 :                    { outstring("Need to do step 1 first before dumping Hessian.\n");

	push	OFFSET ??_C@_0DB@PIKAKACN@Need?5to?5do?5step?51?5first?5before?5d@
	call	_outstring
	add	esp, 4

; 1396 :                      break;

	jmp	$LL271@hessian_me
$LN80@hessian_me:

; 1397 :                    }
; 1398 : 
; 1399 :                    outstring("Hessian dump in Mathematica sparse format.\n");

	push	OFFSET ??_C@_0CM@OLLMODMJ@Hessian?5dump?5in?5Mathematica?5spar@
	call	_outstring

; 1400 : getkname:
; 1401 :                    prompt("Enter filename: ", hname,200);

	push	200					; 000000c8H
	lea	edx, DWORD PTR _hname$89900[ebp]
	push	edx
	push	OFFSET ??_C@_0BB@LODAAEGK@Enter?5filename?3?5?$AA@
	call	_prompt
	add	esp, 16					; 00000010H

; 1402 :                    if ( hname[0] == 0 ) break;

	cmp	BYTE PTR _hname$89900[ebp], bl
	je	$LL271@hessian_me
$getkname$89908:

; 1403 : 
; 1404 :                    while ( bname[0] == 0 )

	cmp	BYTE PTR _bname$89901[ebp], bl
	jne	$LN321@hessian_me
	npad	4
$LL78@hessian_me:

; 1405 :                    { char *cp;
; 1406 :                      prompt("Enter base name for arrays: ",bname,200);

	push	200					; 000000c8H
	lea	eax, DWORD PTR _bname$89901[ebp]
	push	eax
	push	OFFSET ??_C@_0BN@GNGDDCN@Enter?5base?5name?5for?5arrays?3?5?$AA@
	call	_prompt

; 1407 :                      if ( bname[0] == 0 ) break;

	mov	al, BYTE PTR _bname$89901[ebp]
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN321@hessian_me

; 1408 :                      if ( !isalpha(bname[0]) )

	movsx	ecx, al
	push	ecx
	call	_isalpha
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN75@hessian_me

; 1409 :                      { outstring("Mathematica names must start with letter.\n");

	push	OFFSET ??_C@_0CL@BHLGBODB@Mathematica?5names?5must?5start?5wit@
	call	_outstring
	add	esp, 4

; 1410 :                        bname[0] = 0;

	mov	BYTE PTR _bname$89901[ebp], bl
$LN75@hessian_me:

; 1411 :                      }
; 1412 :                      for( cp = bname+1 ; *cp ; cp++ )

	lea	esi, DWORD PTR _bname$89901[ebp+1]
	cmp	BYTE PTR _bname$89901[ebp+1], bl
	je	SHORT $LN72@hessian_me
$LL74@hessian_me:

; 1413 :                        if ( !isalnum(*cp) )

	movsx	edx, BYTE PTR [esi]
	push	edx
	call	_isalnum
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN73@hessian_me

; 1414 :                        { outstring("Mathematica names must have only letters and digits.\n");

	push	OFFSET ??_C@_0DG@FHAHJGJH@Mathematica?5names?5must?5have?5only@
	call	_outstring
	add	esp, 4

; 1415 :                          bname[0] = 0;

	mov	BYTE PTR _bname$89901[ebp], bl
$LN73@hessian_me:

; 1411 :                      }
; 1412 :                      for( cp = bname+1 ; *cp ; cp++ )

	inc	esi
	cmp	BYTE PTR [esi], bl
	jne	SHORT $LL74@hessian_me
$LN72@hessian_me:

; 1403 : 
; 1404 :                    while ( bname[0] == 0 )

	cmp	BYTE PTR _bname$89901[ebp], bl
	je	$LL78@hessian_me
$LN321@hessian_me:

; 1416 :                      }
; 1417 :                    }
; 1418 : 
; 1419 :                    fd = fopen(hname,"w");

	lea	eax, DWORD PTR _hname$89900[ebp]
	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	eax
	call	_fopen
	mov	esi, eax
	add	esp, 8

; 1420 :                    if ( fd == NULL )

	cmp	esi, ebx
	jne	SHORT $LN70@hessian_me

; 1421 :                    { perror(hname); goto getkname; }

	lea	ecx, DWORD PTR _hname$89900[ebp]
	push	ecx
	call	_perror
	push	200					; 000000c8H
	lea	edx, DWORD PTR _hname$89900[ebp]
	push	edx
	push	OFFSET ??_C@_0BB@LODAAEGK@Enter?5filename?3?5?$AA@
	call	_prompt
	add	esp, 16					; 00000010H
	cmp	BYTE PTR _hname$89900[ebp], bl
	jne	$getkname$89908

; 1402 :                    if ( hname[0] == 0 ) break;

	jmp	$LL271@hessian_me
$LN70@hessian_me:

; 1422 : 
; 1423 :                    sprintf(msg,
; 1424 :                      "Dumping Hessian upper triangle to array %sH.\n",bname);

	mov	ecx, DWORD PTR _msg
	lea	eax, DWORD PTR _bname$89901[ebp]
	push	eax
	push	OFFSET ??_C@_0CO@HNNPEHDN@Dumping?5Hessian?5upper?5triangle?5t@
	push	ecx
	call	_sprintf

; 1425 :                    outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 1426 :                    fprintf(fd,"%sH = SparseArray[{",bname);

	lea	eax, DWORD PTR _bname$89901[ebp]
	push	eax
	push	OFFSET ??_C@_0BE@NAOMMKJA@?$CFsH?5?$DN?5SparseArray?$FL?$HL?$AA@
	push	esi
	call	_fprintf

; 1427 :                    comma_flag = 0; 
; 1428 :                    for ( i = 0 ; i < S.N ; i++ )

	mov	ecx, DWORD PTR _S$[ebp+4]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _comma_flag$89905[ebp], ebx
	cmp	ecx, ebx
	jle	$LN67@hessian_me
	mov	eax, DWORD PTR _S$[ebp+52]
	npad	5
$LL69@hessian_me:

; 1429 :                      for ( j = S.IA[i]-A_OFF ; j < S.IA[i+1]-A_OFF ; j++ )

	mov	edi, DWORD PTR [eax+ebx*4]
	mov	edx, DWORD PTR [eax+ebx*4+4]
	dec	edi
	dec	edx
	cmp	edi, edx
	jge	SHORT $LN68@hessian_me
	npad	3
$LL66@hessian_me:

; 1430 :                      { if ( comma_flag )

	cmp	DWORD PTR _comma_flag$89905[ebp], 0
	je	SHORT $LN63@hessian_me

; 1431 :                          fprintf(fd,",");

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	esi
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN62@hessian_me
$LN63@hessian_me:

; 1432 :                        else comma_flag = 1;

	mov	DWORD PTR _comma_flag$89905[ebp], 1
$LN62@hessian_me:

; 1433 :                        fprintf(fd,"\n{%d,%d}->%17.15f",i+1,S.JA[j]-A_OFF+1,
; 1434 :                           (DOUBLE)S.A[j]);

	mov	eax, DWORD PTR _S$[ebp+60]
	fld	QWORD PTR [eax+edi*8]
	mov	ecx, DWORD PTR _S$[ebp+56]
	mov	edx, DWORD PTR [ecx+edi*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	OFFSET ??_C@_0BC@HEJFHDDF@?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@
	push	esi
	call	_fprintf
	mov	eax, DWORD PTR _S$[ebp+52]
	mov	ecx, DWORD PTR [eax+ebx*4+4]
	inc	edi
	dec	ecx
	add	esp, 24					; 00000018H
	cmp	edi, ecx
	jl	SHORT $LL66@hessian_me

; 1429 :                      for ( j = S.IA[i]-A_OFF ; j < S.IA[i+1]-A_OFF ; j++ )

	mov	ecx, DWORD PTR _S$[ebp+4]
$LN68@hessian_me:

; 1427 :                    comma_flag = 0; 
; 1428 :                    for ( i = 0 ; i < S.N ; i++ )

	inc	ebx
	cmp	ebx, ecx
	jl	SHORT $LL69@hessian_me
$LN67@hessian_me:

; 1435 :                      }
; 1436 :                      fprintf(fd,"},{%d,%d}];\n",S.N,S.N);

	push	ecx
	push	ecx
	push	OFFSET ??_C@_0N@CPFNMDOB@?$HN?0?$HL?$CFd?0?$CFd?$HN?$FN?$DL?6?$AA@
	push	esi
	call	_fprintf
	add	esp, 16					; 00000010H

; 1437 : 
; 1438 :                    if ( hessian_linear_metric_flag )

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	$LN61@hessian_me

; 1439 :                    {
; 1440 :                      sprintf(msg, "Dumping Hessian metric upper triangle to array %sM.\n", bname);

	mov	eax, DWORD PTR _msg
	lea	edx, DWORD PTR _bname$89901[ebp]
	push	edx
	push	OFFSET ??_C@_0DF@MEGEBEKI@Dumping?5Hessian?5metric?5upper?5tri@
	push	eax
	call	_sprintf

; 1441 :                      outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring

; 1442 :                      fprintf(fd,"\n %sM = SparseArray[{",bname);

	lea	edx, DWORD PTR _bname$89901[ebp]
	push	edx
	push	OFFSET ??_C@_0BG@JDDBELEC@?6?5?$CFsM?5?$DN?5SparseArray?$FL?$HL?$AA@
	push	esi
	call	_fprintf

; 1443 :                      comma_flag = 0; 
; 1444 :                      for ( i = 0 ; i < Met.N ; i++ )

	mov	ecx, DWORD PTR _Met+4
	xor	ebx, ebx
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _comma_flag$89905[ebp], ebx
	cmp	ecx, ebx
	jle	SHORT $LN58@hessian_me
	mov	eax, DWORD PTR _Met+52
$LL60@hessian_me:

; 1445 :                        for ( j = Met.IA[i]-A_OFF ; j < Met.IA[i+1]-A_OFF ; j++ )

	mov	edi, DWORD PTR [eax+ebx*4]
	mov	edx, DWORD PTR [eax+ebx*4+4]
	dec	edi
	dec	edx
	cmp	edi, edx
	jge	SHORT $LN59@hessian_me
$LL57@hessian_me:

; 1446 :                        { if ( comma_flag )

	cmp	DWORD PTR _comma_flag$89905[ebp], 0
	je	SHORT $LN54@hessian_me

; 1447 :                            fprintf(fd,",");

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	esi
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN53@hessian_me
$LN54@hessian_me:

; 1448 :                          else comma_flag = 1;

	mov	DWORD PTR _comma_flag$89905[ebp], 1
$LN53@hessian_me:

; 1449 :                          fprintf(fd,"\n{%d,%d}->%17.15f",i+1,Met.JA[j]-A_OFF+1,
; 1450 :                           (DOUBLE)Met.A[j]);

	mov	eax, DWORD PTR _Met+60
	fld	QWORD PTR [eax+edi*8]
	mov	ecx, DWORD PTR _Met+56
	mov	edx, DWORD PTR [ecx+edi*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	OFFSET ??_C@_0BC@HEJFHDDF@?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@
	push	esi
	call	_fprintf
	mov	eax, DWORD PTR _Met+52
	mov	ecx, DWORD PTR [eax+ebx*4+4]
	inc	edi
	dec	ecx
	add	esp, 24					; 00000018H
	cmp	edi, ecx
	jl	SHORT $LL57@hessian_me

; 1445 :                        for ( j = Met.IA[i]-A_OFF ; j < Met.IA[i+1]-A_OFF ; j++ )

	mov	ecx, DWORD PTR _Met+4
$LN59@hessian_me:

; 1443 :                      comma_flag = 0; 
; 1444 :                      for ( i = 0 ; i < Met.N ; i++ )

	inc	ebx
	cmp	ebx, ecx
	jl	SHORT $LL60@hessian_me
$LN58@hessian_me:

; 1451 :                        }
; 1452 :                      fprintf(fd,"},{%d,%d}];\n",Met.N,Met.N);

	push	ecx
	push	ecx
	push	OFFSET ??_C@_0N@CPFNMDOB@?$HN?0?$HL?$CFd?0?$CFd?$HN?$FN?$DL?6?$AA@
	push	esi
	call	_fprintf
	add	esp, 16					; 00000010H
$LN61@hessian_me:

; 1453 :                    }
; 1454 : 
; 1455 :                    if ( right_flag )

	cmp	DWORD PTR _right_flag$[ebp], 0
	je	$LN52@hessian_me

; 1456 :                    { 
; 1457 :                      sprintf(msg,"Dumping right hand side to vector %sRHS.\n",bname);

	mov	eax, DWORD PTR _msg
	lea	edx, DWORD PTR _bname$89901[ebp]
	push	edx
	push	OFFSET ??_C@_0CK@HNILOEID@Dumping?5right?5hand?5side?5to?5vecto@
	push	eax
	call	_sprintf

; 1458 :                      outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring

; 1459 :                      comma_flag = 0; 
; 1460 :                      fprintf(fd,"\n %sRHS = {",bname);

	lea	edx, DWORD PTR _bname$89901[ebp]
	push	edx
	push	OFFSET ??_C@_0M@FFCADFPL@?6?5?$CFsRHS?5?$DN?5?$HL?$AA@
	push	esi
	xor	ebx, ebx
	call	_fprintf
	add	esp, 28					; 0000001cH

; 1461 :                      for ( i = 0 ; i < S.N ; i++ )

	xor	edi, edi
	cmp	DWORD PTR _S$[ebp+4], ebx
	jle	SHORT $LN49@hessian_me
	npad	6
$LL51@hessian_me:

; 1462 :                      { if ( comma_flag )

	test	ebx, ebx
	je	SHORT $LN48@hessian_me

; 1463 :                          fprintf(fd,",");

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	esi
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN47@hessian_me
$LN48@hessian_me:

; 1464 :                        else comma_flag = 1;                      

	mov	ebx, 1
$LN47@hessian_me:

; 1465 :                        fprintf(fd,"\n%17.15f",(DOUBLE)(rhs[i]));

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	QWORD PTR [eax+edi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_08NEEHBPF@?6?$CF17?415f?$AA@
	push	esi
	call	_fprintf
	inc	edi
	add	esp, 16					; 00000010H
	cmp	edi, DWORD PTR _S$[ebp+4]
	jl	SHORT $LL51@hessian_me
$LN49@hessian_me:

; 1466 :                      }
; 1467 :                      fprintf(fd,"};\n");

	push	OFFSET ??_C@_03JFDPLKFJ@?$HN?$DL?6?$AA@
	push	esi
	call	_fprintf
	add	esp, 8
$LN52@hessian_me:

; 1468 :                    }
; 1469 : 
; 1470 :                    if ( ysmp_flag != MINDEG_FACTORING )

	cmp	DWORD PTR _ysmp_flag, 0
	je	SHORT $LN46@hessian_me

; 1471 :                    { outstring("Further dumping of factors in minimal degree mode (ysmp off) only.\n");

	push	OFFSET ??_C@_0EE@NENMBAIG@Further?5dumping?5of?5factors?5in?5mi@
	call	_outstring

; 1472 :                      fclose(fd);

	push	esi
	call	_fclose
	add	esp, 8

; 1473 :                      break;

	jmp	$LL271@hessian_me
$LN46@hessian_me:

; 1474 :                    }
; 1475 : 
; 1476 :                    if ( !S.LA )

	cmp	DWORD PTR _S$[ebp+140], 0
	jne	SHORT $LN45@hessian_me

; 1477 :                    { outstring("Need to do step 3, P, V, or Z before dumping factors.\n");

	push	OFFSET ??_C@_0DH@CGFLGEDD@Need?5to?5do?5step?53?0?5P?0?5V?0?5or?5Z?5be@
	call	_outstring

; 1478 :                      fclose(fd);

	push	esi
	call	_fclose
	add	esp, 8

; 1479 :                      break;

	jmp	$LL271@hessian_me
$LN45@hessian_me:

; 1480 :                    }
; 1481 :                    sprintf(msg, "Dumping L factor to array %sL.\n",bname);

	mov	edx, DWORD PTR _msg
	lea	ecx, DWORD PTR _bname$89901[ebp]
	push	ecx
	push	OFFSET ??_C@_0CA@DOJIMNCP@Dumping?5L?5factor?5to?5array?5?$CFsL?4?6?$AA@
	push	edx
	call	_sprintf

; 1482 :                    outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring

; 1483 :                    fprintf(fd,"\n%sL = SparseArray[{",bname);

	lea	ecx, DWORD PTR _bname$89901[ebp]
	push	ecx
	push	OFFSET ??_C@_0BF@FEKDELJL@?6?$CFsL?5?$DN?5SparseArray?$FL?$HL?$AA@
	push	esi
	call	_fprintf

; 1484 :                    comma_flag = 0; 
; 1485 :                    for ( i = 0 ; i < S.N ; i++ )

	mov	eax, DWORD PTR _S$[ebp+4]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _comma_flag$89905[ebp], 0
	test	eax, eax
	jle	$LN42@hessian_me

; 1480 :                    }
; 1481 :                    sprintf(msg, "Dumping L factor to array %sL.\n",bname);

	xor	ebx, ebx
	mov	DWORD PTR tv2845[ebp], 1
$LN44@hessian_me:

; 1486 :                    { if ( comma_flag )

	cmp	DWORD PTR _comma_flag$89905[ebp], 0
	je	SHORT $LN41@hessian_me

; 1487 :                          fprintf(fd,",");

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	esi
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN40@hessian_me
$LN41@hessian_me:

; 1488 :                      else comma_flag = 1;

	mov	DWORD PTR _comma_flag$89905[ebp], 1
$LN40@hessian_me:

; 1489 :                      fprintf(fd,"\n{%d,%d}->%17.15f",i+1,i+1,1.0);

	fld1
	mov	eax, DWORD PTR tv2845[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	push	eax
	push	OFFSET ??_C@_0BC@HEJFHDDF@?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@
	push	esi
	call	_fprintf

; 1490 :                      for ( j = S.LIA[i]+S.psize[i], k = S.LIJA[i]+S.psize[i] ;
; 1491 :                         j < S.LIA[i+1] ; j++,k++ )

	mov	eax, DWORD PTR _S$[ebp+120]
	mov	ecx, DWORD PTR [ebx+eax]
	mov	edx, DWORD PTR _S$[ebp+128]
	mov	eax, DWORD PTR _S$[ebp+136]
	mov	edi, DWORD PTR [ebx+edx]
	mov	eax, DWORD PTR [ebx+eax]
	add	edi, ecx
	add	esp, 24					; 00000018H
	add	eax, ecx
	cmp	edi, DWORD PTR [ebx+edx+4]
	jge	SHORT $LN43@hessian_me

; 1489 :                      fprintf(fd,"\n{%d,%d}->%17.15f",i+1,i+1,1.0);

	lea	ecx, DWORD PTR [eax*4]
	mov	DWORD PTR tv2819[ebp], ecx
	npad	2
$LL39@hessian_me:

; 1492 :                      { 
; 1493 :                        fprintf(fd,",\n{%d,%d}->%17.15f",i+1,S.LJA[k]+1,(DOUBLE)(S.LA[j]));

	mov	edx, DWORD PTR _S$[ebp+140]
	fld	QWORD PTR [edx+edi*8]
	mov	eax, DWORD PTR _S$[ebp+132]
	mov	ecx, DWORD PTR tv2819[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR tv2845[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	inc	edx
	push	edx
	push	eax
	push	OFFSET ??_C@_0BD@PMLBDGE@?0?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@
	push	esi
	call	_fprintf
	mov	ecx, DWORD PTR _S$[ebp+128]
	add	DWORD PTR tv2819[ebp], 4
	inc	edi
	add	esp, 24					; 00000018H
	cmp	edi, DWORD PTR [ebx+ecx+4]
	jl	SHORT $LL39@hessian_me
$LN43@hessian_me:

; 1484 :                    comma_flag = 0; 
; 1485 :                    for ( i = 0 ; i < S.N ; i++ )

	mov	eax, DWORD PTR tv2845[ebp]
	inc	eax
	lea	edx, DWORD PTR [eax-1]
	mov	DWORD PTR tv2845[ebp], eax
	mov	eax, DWORD PTR _S$[ebp+4]
	add	ebx, 4
	cmp	edx, eax
	jl	$LN44@hessian_me
$LN42@hessian_me:

; 1494 :                      }
; 1495 :                    }
; 1496 :                    fprintf(fd,"},{%d,%d}];\n",S.N,S.N);

	push	eax
	push	eax
	push	OFFSET ??_C@_0N@CPFNMDOB@?$HN?0?$HL?$CFd?0?$CFd?$HN?$FN?$DL?6?$AA@
	push	esi
	call	_fprintf

; 1497 : 
; 1498 :                    sprintf(msg,"Dumping diagonal factor to array %sD.\n",bname);

	mov	ecx, DWORD PTR _msg
	lea	eax, DWORD PTR _bname$89901[ebp]
	push	eax
	push	OFFSET ??_C@_0CH@LPPKGEM@Dumping?5diagonal?5factor?5to?5array@
	push	ecx
	call	_sprintf

; 1499 :                    outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 1500 :                    fprintf(fd,"\n%sD = SparseArray[{",bname);

	lea	eax, DWORD PTR _bname$89901[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@EDPCOFJH@?6?$CFsD?5?$DN?5SparseArray?$FL?$HL?$AA@
	push	esi
	call	_fprintf

; 1501 :                    comma_flag = 0; 
; 1502 :                    for ( i = 0 ; i < S.N ; i++ )

	mov	eax, DWORD PTR _S$[ebp+4]
	xor	ebx, ebx
	add	esp, 44					; 0000002cH
	mov	DWORD PTR _comma_flag$89905[ebp], ebx
	cmp	eax, ebx
	jle	$LN34@hessian_me

; 1494 :                      }
; 1495 :                    }
; 1496 :                    fprintf(fd,"},{%d,%d}];\n",S.N,S.N);

	lea	edi, DWORD PTR [ebx+1]
	npad	7
$LL36@hessian_me:

; 1503 :                    { if ( comma_flag )

	cmp	DWORD PTR _comma_flag$89905[ebp], 0
	je	SHORT $LN33@hessian_me

; 1504 :                        fprintf(fd,",");

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	esi
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN32@hessian_me
$LN33@hessian_me:

; 1505 :                      else comma_flag = 1;

	mov	DWORD PTR _comma_flag$89905[ebp], 1
$LN32@hessian_me:

; 1506 :                      j = S.LIA[i]; k = S.LIJA[i]; 

	mov	ecx, DWORD PTR _S$[ebp+128]
	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	eax, DWORD PTR _S$[ebp+136]
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _j$89903[ebp], edx

; 1507 :                      if ( S.psize[i] == 1 )

	mov	edx, DWORD PTR _S$[ebp+120]

; 1508 :                      { fprintf(fd,"\n{%d,%d}->%17.15f",i+1,S.LJA[k]+1,
; 1509 :                           (DOUBLE)S.LA[j]);

	sub	esp, 8
	cmp	DWORD PTR [edx+ebx*4], 1
	mov	DWORD PTR _k$89904[ebp], ecx
	jne	SHORT $LN31@hessian_me
	mov	eax, DWORD PTR _S$[ebp+140]
	mov	ecx, DWORD PTR _j$89903[ebp]
	fld	QWORD PTR [eax+ecx*8]
	mov	edx, DWORD PTR _S$[ebp+132]
	mov	eax, DWORD PTR _k$89904[ebp]
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR [edx+eax*4]
	inc	ecx
	push	ecx
	push	edi
	push	OFFSET ??_C@_0BC@HEJFHDDF@?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@

; 1510 :                      }
; 1511 :                      else

	jmp	$LN389@hessian_me
$LN31@hessian_me:

; 1512 :                      { fprintf(fd,"\n{%d,%d}->%17.15f,\n",i+1,S.LJA[k]+1,
; 1513 :                           (DOUBLE)S.LA[j]);

	mov	edx, DWORD PTR _S$[ebp+140]
	mov	eax, DWORD PTR _j$89903[ebp]
	fld	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _S$[ebp+132]
	mov	edx, DWORD PTR _k$89904[ebp]
	fstp	QWORD PTR [esp]
	mov	eax, DWORD PTR [ecx+edx*4]
	inc	eax
	push	eax
	push	edi
	push	OFFSET ??_C@_0BE@KAIFMBKL@?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?0?6?$AA@
	push	esi
	call	_fprintf

; 1514 :                        fprintf(fd,"{%d,%d}->%17.15f,\n",i+1,S.LJA[k+1]+1,
; 1515 :                           (DOUBLE)S.LA[j+1]);

	mov	ecx, DWORD PTR _S$[ebp+140]
	mov	edx, DWORD PTR _j$89903[ebp]
	fld	QWORD PTR [ecx+edx*8+8]
	mov	eax, DWORD PTR _S$[ebp+132]
	mov	ecx, DWORD PTR _k$89904[ebp]
	fstp	QWORD PTR [esp+16]
	mov	edx, DWORD PTR [eax+ecx*4+4]
	add	esp, 16					; 00000010H
	inc	edx
	push	edx
	push	edi
	push	OFFSET ??_C@_0BD@CCENDDHH@?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?0?6?$AA@
	push	esi
	call	_fprintf

; 1516 :                        fprintf(fd,"{%d,%d}->%17.15f,\n",S.LJA[k+1]+1,i+1,
; 1517 :                           (DOUBLE)S.LA[j+1]);

	mov	eax, DWORD PTR _S$[ebp+140]
	mov	ecx, DWORD PTR _j$89903[ebp]
	fld	QWORD PTR [eax+ecx*8+8]
	mov	edx, DWORD PTR _S$[ebp+132]
	mov	eax, DWORD PTR _k$89904[ebp]
	fstp	QWORD PTR [esp+16]
	mov	ecx, DWORD PTR [edx+eax*4+4]
	add	esp, 16					; 00000010H
	push	edi
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_0BD@CCENDDHH@?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?0?6?$AA@
	push	esi
	call	_fprintf

; 1518 :                        i++;
; 1519 :                        j = S.LIA[i]; k = S.LIJA[i]; 

	mov	edx, DWORD PTR _S$[ebp+128]
	mov	eax, DWORD PTR [edx+ebx*4+4]

; 1520 :                        fprintf(fd,"{%d,%d}->%17.15f",i+1,S.LJA[k]+1,
; 1521 :                           (DOUBLE)S.LA[j]);

	mov	edx, DWORD PTR _S$[ebp+140]
	mov	ecx, DWORD PTR _S$[ebp+136]
	fld	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR [ecx+ebx*4+4]
	fstp	QWORD PTR [esp+16]
	mov	eax, DWORD PTR _S$[ebp+132]
	mov	ecx, DWORD PTR [eax+ecx*4]
	inc	ebx
	add	esp, 16					; 00000010H
	inc	edi
	inc	ecx
	push	ecx
	push	edi
	push	OFFSET ??_C@_0BB@MIOEIIEK@?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@
$LN389@hessian_me:
	push	esi
	call	_fprintf
	mov	eax, DWORD PTR _S$[ebp+4]
	inc	ebx
	add	esp, 24					; 00000018H
	inc	edi
	cmp	ebx, eax
	jl	$LL36@hessian_me
$LN34@hessian_me:

; 1522 :                      }
; 1523 :                    }
; 1524 :                    fprintf(fd,"},{%d,%d}];\n",S.N,S.N);

	push	eax
	push	eax
	push	OFFSET ??_C@_0N@CPFNMDOB@?$HN?0?$HL?$CFd?0?$CFd?$HN?$FN?$DL?6?$AA@
	push	esi
	call	_fprintf

; 1525 : 
; 1526 :                    if ( !augmented_hessian_mode && S.CN )

	xor	ebx, ebx
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _augmented_hessian_mode, ebx
	jne	$LN29@hessian_me
	cmp	DWORD PTR _S$[ebp+148], ebx
	je	$LN29@hessian_me

; 1527 :                    { 
; 1528 :                      sprintf(msg, "Dumping constraint matrix to array %s.\n",bname);

	mov	eax, DWORD PTR _msg
	lea	edx, DWORD PTR _bname$89901[ebp]
	push	edx
	push	OFFSET ??_C@_0CI@GFBPNNCD@Dumping?5constraint?5matrix?5to?5arr@
	push	eax
	call	_sprintf

; 1529 :                      outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring

; 1530 :                      fprintf(fd,"\n%sC = SparseArray[{",bname);

	lea	edx, DWORD PTR _bname$89901[ebp]
	push	edx
	push	OFFSET ??_C@_0BF@KCNMOPPD@?6?$CFsC?5?$DN?5SparseArray?$FL?$HL?$AA@
	push	esi
	call	_fprintf

; 1531 :                      comma_flag = 0; 
; 1532 :                      for ( i = 0 ; i < S.CN ; i++ )

	mov	ecx, DWORD PTR _S$[ebp+148]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _comma_flag$89905[ebp], ebx
	cmp	ecx, ebx
	jle	$LN26@hessian_me
	mov	eax, DWORD PTR _S$[ebp+172]
$LN28@hessian_me:

; 1533 :                      { if ( S.CIA )

	test	eax, eax
	je	SHORT $LN25@hessian_me

; 1534 :                        for ( j = S.CIA[i] ; j < S.CIA[i+1] ; j++ )

	mov	edi, DWORD PTR [eax+ebx*4]
	cmp	edi, DWORD PTR [eax+ebx*4+4]
	jge	$LN27@hessian_me
$LN24@hessian_me:

; 1535 :                        { if ( comma_flag )

	cmp	DWORD PTR _comma_flag$89905[ebp], 0
	je	SHORT $LN21@hessian_me

; 1536 :                            fprintf(fd,",");

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	esi
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN20@hessian_me
$LN21@hessian_me:

; 1537 :                          else comma_flag = 1;

	mov	DWORD PTR _comma_flag$89905[ebp], 1
$LN20@hessian_me:

; 1538 :                          fprintf(fd,"\n{%d,%d}->%17.15f",i+1,S.CJA[j]+1,
; 1539 :                           (DOUBLE)S.CA[j]);

	mov	eax, DWORD PTR _S$[ebp+180]
	mov	ecx, DWORD PTR _S$[ebp+176]
	fld	QWORD PTR [eax+edi*8]
	mov	edx, DWORD PTR [ecx+edi*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	inc	edx
	push	edx
	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	OFFSET ??_C@_0BC@HEJFHDDF@?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@
	push	esi
	call	_fprintf
	mov	eax, DWORD PTR _S$[ebp+172]
	inc	edi
	add	esp, 24					; 00000018H
	cmp	edi, DWORD PTR [eax+ebx*4+4]
	jl	SHORT $LN24@hessian_me

; 1540 :                        }
; 1541 :                        else /* dense */

	jmp	SHORT $LN27@hessian_me
$LN25@hessian_me:

; 1542 :                        for ( j = 0 ; j < S.N ; j++ )

	xor	edi, edi
	cmp	DWORD PTR _S$[ebp+4], edi
	jle	SHORT $LN27@hessian_me
$LN18@hessian_me:

; 1543 :                          if ( S.C[i][j] )

	mov	eax, DWORD PTR _S$[ebp+160]
	mov	ecx, DWORD PTR [eax+ebx*4]
	fld	QWORD PTR [ecx+edi*8]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN17@hessian_me

; 1544 :                          { if ( comma_flag )

	cmp	DWORD PTR _comma_flag$89905[ebp], 0
	je	SHORT $LN14@hessian_me

; 1545 :                              fprintf(fd,",");

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	esi
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN13@hessian_me
$LN14@hessian_me:

; 1546 :                            else comma_flag = 1;

	mov	DWORD PTR _comma_flag$89905[ebp], 1
$LN13@hessian_me:

; 1547 :                            fprintf(fd,"\n{%d,%d}->%17.15f",i+1,j+1,
; 1548 :                              (DOUBLE)S.C[i][j]);

	mov	edx, DWORD PTR _S$[ebp+160]
	mov	eax, DWORD PTR [edx+ebx*4]
	fld	QWORD PTR [eax+edi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	ecx, DWORD PTR [edi+1]
	push	ecx
	lea	edx, DWORD PTR [ebx+1]
	push	edx
	push	OFFSET ??_C@_0BC@HEJFHDDF@?6?$HL?$CFd?0?$CFd?$HN?9?$DO?$CF17?415f?$AA@
	push	esi
	call	_fprintf
	add	esp, 24					; 00000018H
$LN17@hessian_me:

; 1542 :                        for ( j = 0 ; j < S.N ; j++ )

	inc	edi
	cmp	edi, DWORD PTR _S$[ebp+4]
	jl	SHORT $LN18@hessian_me
	mov	eax, DWORD PTR _S$[ebp+172]
$LN27@hessian_me:

; 1531 :                      comma_flag = 0; 
; 1532 :                      for ( i = 0 ; i < S.CN ; i++ )

	mov	ecx, DWORD PTR _S$[ebp+148]
	inc	ebx
	cmp	ebx, ecx
	jl	$LN28@hessian_me
$LN26@hessian_me:

; 1549 :                          }
; 1550 :                      }
; 1551 :                      fprintf(fd,"},{%d,%d}];\n",S.CN,S.N);

	mov	eax, DWORD PTR _S$[ebp+4]
	push	eax
	push	ecx
	push	OFFSET ??_C@_0N@CPFNMDOB@?$HN?0?$HL?$CFd?0?$CFd?$HN?$FN?$DL?6?$AA@
	push	esi
	call	_fprintf
	add	esp, 16					; 00000010H
$LN29@hessian_me:

; 1552 :                    }
; 1553 : 
; 1554 :                    sprintf(msg, "Dumping permutation to vector %sP.\n",bname);

	mov	edx, DWORD PTR _msg
	lea	ecx, DWORD PTR _bname$89901[ebp]
	push	ecx
	push	OFFSET ??_C@_0CE@FGHLLAAO@Dumping?5permutation?5to?5vector?5?$CFs@
	push	edx
	call	_sprintf

; 1555 :                    outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring

; 1556 :                    fprintf(fd,"\n%sP = {",bname);

	lea	ecx, DWORD PTR _bname$89901[ebp]
	push	ecx
	push	OFFSET ??_C@_08NLEGCGBJ@?6?$CFsP?5?$DN?5?$HL?$AA@
	push	esi
	call	_fprintf

; 1557 :                    comma_flag = 0; 

	xor	ebx, ebx
	add	esp, 28					; 0000001cH

; 1558 :                    for ( i = 0 ; i < S.N ; i++ )

	xor	edi, edi
	cmp	DWORD PTR _S$[ebp+4], ebx
	jle	SHORT $LN10@hessian_me
$LL12@hessian_me:

; 1559 :                    { if ( comma_flag )

	test	ebx, ebx
	je	SHORT $LN9@hessian_me

; 1560 :                        fprintf(fd,",");

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	esi
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN8@hessian_me
$LN9@hessian_me:

; 1561 :                      else comma_flag = 1;

	mov	ebx, 1
$LN8@hessian_me:

; 1562 :                      fprintf(fd,"\n%d",S.P[i]+1);

	mov	edx, DWORD PTR _S$[ebp+68]
	mov	eax, DWORD PTR [edx+edi*4]
	inc	eax
	push	eax
	push	OFFSET ??_C@_03IOBBOKCP@?6?$CFd?$AA@
	push	esi
	call	_fprintf
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR _S$[ebp+4]
	jl	SHORT $LL12@hessian_me
$LN10@hessian_me:

; 1563 :                    }
; 1564 :                    fprintf(fd,"};\n");

	push	OFFSET ??_C@_03JFDPLKFJ@?$HN?$DL?6?$AA@
	push	esi
	call	_fprintf
	add	esp, 8

; 1565 : 
; 1566 :                    if ( dir_flag )

	cmp	DWORD PTR _dir_flag$[ebp], 0
	je	$LN7@hessian_me

; 1567 :                    { 
; 1568 :                      sprintf(msg,"Dumping solution to vector %sS.\n",bname);

	mov	edx, DWORD PTR _msg
	lea	ecx, DWORD PTR _bname$89901[ebp]
	push	ecx
	push	OFFSET ??_C@_0CB@BKEBKIBO@Dumping?5solution?5to?5vector?5?$CFsS?4?6@
	push	edx
	call	_sprintf

; 1569 :                      outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring

; 1570 :                      fprintf(fd,"\n%sS = {",bname);

	lea	ecx, DWORD PTR _bname$89901[ebp]
	push	ecx
	push	OFFSET ??_C@_08FNNCFELH@?6?$CFsS?5?$DN?5?$HL?$AA@
	push	esi
	call	_fprintf

; 1571 :                      comma_flag = 0; 

	xor	ebx, ebx
	add	esp, 28					; 0000001cH

; 1572 :                      for ( i = 0 ; i < S.N ; i++ )

	xor	edi, edi
	cmp	DWORD PTR _S$[ebp+4], ebx
	jle	SHORT $LN4@hessian_me
$LL6@hessian_me:

; 1573 :                      { if ( comma_flag )

	test	ebx, ebx
	je	SHORT $LN3@hessian_me

; 1574 :                         fprintf(fd,",");

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	push	esi
	call	_fprintf
	add	esp, 8
	jmp	SHORT $LN2@hessian_me
$LN3@hessian_me:

; 1575 :                        else comma_flag = 1;                    

	mov	ebx, 1
$LN2@hessian_me:

; 1576 :                        fprintf(fd,"\n%17.15f",(DOUBLE)(X[i]));

	mov	edx, DWORD PTR _X$[ebp]
	fld	QWORD PTR [edx+edi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_08NEEHBPF@?6?$CF17?415f?$AA@
	push	esi
	call	_fprintf
	inc	edi
	add	esp, 16					; 00000010H
	cmp	edi, DWORD PTR _S$[ebp+4]
	jl	SHORT $LL6@hessian_me
$LN4@hessian_me:

; 1577 :                      }
; 1578 :                      fprintf(fd,"};\n");

	push	OFFSET ??_C@_03JFDPLKFJ@?$HN?$DL?6?$AA@
	push	esi
	call	_fprintf
	add	esp, 8
$LN7@hessian_me:

; 1579 :                    }
; 1580 : 
; 1581 :                    
; 1582 :                    fprintf(fd,"(* Solving constrained Hessian *)\n");

	push	OFFSET ??_C@_0CD@HBKDMHCF@?$CI?$CK?5Solving?5constrained?5Hessian?5?$CK@
	push	esi
	call	_fprintf

; 1583 :                    fprintf(fd,"\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	push	esi
	call	_fprintf

; 1584 :                    fprintf(fd,"(* get both halves of H *)\n");

	push	OFFSET ??_C@_0BM@GHCDBMBC@?$CI?$CK?5get?5both?5halves?5of?5H?5?$CK?$CJ?6?$AA@
	push	esi
	call	_fprintf

; 1585 :                    fprintf(fd,"h = %sH + Transpose[%sH];\n",bname,bname);

	lea	eax, DWORD PTR _bname$89901[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	push	OFFSET ??_C@_0BL@COMGBIHK@h?5?$DN?5?$CFsH?5?$CL?5Transpose?$FL?$CFsH?$FN?$DL?6?$AA@
	push	esi
	call	_fprintf

; 1586 :                    fprintf(fd,"For[n=1,n<=Length[%sH],n++,h[[n,n]] /= 2;];\n",bname);

	lea	edx, DWORD PTR _bname$89901[ebp]
	push	edx
	push	OFFSET ??_C@_0CN@IKLGBGDK@For?$FLn?$DN1?0n?$DM?$DNLength?$FL?$CFsH?$FN?0n?$CL?$CL?0h?$FL?$FLn?0@
	push	esi
	call	_fprintf

; 1587 :                    fprintf(fd,"\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	push	esi
	call	_fprintf

; 1588 :                    fprintf(fd,"invH = Inverse[h];\n");

	push	OFFSET ??_C@_0BE@JFEILLGB@invH?5?$DN?5Inverse?$FLh?$FN?$DL?6?$AA@
	push	esi
	call	_fprintf
	add	esp, 68					; 00000044H

; 1589 :                    fprintf(fd,"If[Length[%sC] > 0,\n",bname);

	lea	eax, DWORD PTR _bname$89901[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@GMKHIPMI@If?$FLLength?$FL?$CFsC?$FN?5?$DO?50?0?6?$AA@
	push	esi
	call	_fprintf

; 1590 :                    fprintf(fd,"   cthinv = %sC . invH;\n",bname);

	lea	ecx, DWORD PTR _bname$89901[ebp]
	push	ecx
	push	OFFSET ??_C@_0BJ@FDDAHBAB@?5?5?5cthinv?5?$DN?5?$CFsC?5?4?5invH?$DL?6?$AA@
	push	esi
	call	_fprintf

; 1591 :                    fprintf(fd,"   cthinvc = cthinv . Transpose[%sC];\n",bname);

	lea	edx, DWORD PTR _bname$89901[ebp]
	push	edx
	push	OFFSET ??_C@_0CH@HFGGDBDO@?5?5?5cthinvc?5?$DN?5cthinv?5?4?5Transpose?$FL@
	push	esi
	call	_fprintf

; 1592 :                    fprintf(fd,"   cthinvcinv = Inverse[cthinvc];\n");

	push	OFFSET ??_C@_0CD@DIPFIJHI@?5?5?5cthinvcinv?5?$DN?5Inverse?$FLcthinvc?$FN@
	push	esi
	call	_fprintf

; 1593 :                    fprintf(fd,"   gamma = cthinvcinv . cthinv . %sRHS;\n",bname);

	lea	eax, DWORD PTR _bname$89901[ebp]
	push	eax
	push	OFFSET ??_C@_0CJ@IHFCIBCD@?5?5?5gamma?5?$DN?5cthinvcinv?5?4?5cthinv?5?4@
	push	esi
	call	_fprintf

; 1594 :                    fprintf(fd,"   %sx = ( invH . %sRHS) - (Transpose[cthinv] . gamma);,\n",bname,bname);

	lea	ecx, DWORD PTR _bname$89901[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	push	OFFSET ??_C@_0DK@EAHBBGHF@?5?5?5?$CFsx?5?$DN?5?$CI?5invH?5?4?5?$CFsRHS?$CJ?5?9?5?$CITran@
	push	esi
	call	_fprintf
	add	esp, 72					; 00000048H

; 1595 :                    fprintf(fd,"   (* else *)\n");

	push	OFFSET ??_C@_0P@DMJEFINF@?5?5?5?$CI?$CK?5else?5?$CK?$CJ?6?$AA@
	push	esi
	call	_fprintf

; 1596 :                    fprintf(fd,"   %sx = invH . %sRHS;\n];\n",bname,bname);

	lea	eax, DWORD PTR _bname$89901[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	push	OFFSET ??_C@_0BL@GDGKLNK@?5?5?5?$CFsx?5?$DN?5invH?5?4?5?$CFsRHS?$DL?6?$FN?$DL?6?$AA@
	push	esi
	call	_fprintf

; 1597 :                    fclose(fd);

	push	esi
	call	_fclose
	add	esp, 28					; 0000001cH

; 1598 :                  }
; 1599 :                break;

	jmp	$LL271@hessian_me
$LN1@hessian_me:

; 1600 : 
; 1601 : #ifdef MPI_EVOLVER
; 1602 :              case 'A' : 
; 1603 :    				 mpi_hessian_fill_distrib(Mpi_RHS_MOVE); 
; 1604 :    		printf("Done fill.  Enter shift: ");
; 1605 :               scanf("%lf",&S.lambda);
; 1606 :    				 mpi_hessian_factor_distrib(&S);
; 1607 :    				 printf("Done factoring. Inertia: pos %d, neg %d, zero %d\n", 
; 1608 :                    S.pos,S.neg,S.zero); 
; 1609 : 
; 1610 :    				 mpi_solve_distrib(Mpi_LINSYS_HESSIAN, Mpi_RHS_MOVE, Mpi_SOLUTION_MOVE);
; 1611 :                  mpi_hessian_distrib_move(1.0,ACTUAL_MOVE);
; 1612 : #ifdef RANDOMRHS
; 1613 :    				 mpi_create_random_rhs();
; 1614 :    				 printf("Created random rhs\n");
; 1615 :    				 mpi_solve_distrib(Mpi_LINSYS_HESSIAN, Mpi_RHS_RANDOM, Mpi_SOLUTION_RANDOM);
; 1616 :                  printf("Solved random rhs\n");
; 1617 :                  if ( S.lambda == 0.0 )
; 1618 :                  { mpi_mult_hess_distrib(); /* check */
; 1619 :                    printf("Multiplied solution by original\n");
; 1620 :                  }
; 1621 : #endif
; 1622 :                  
; 1623 :    				 break;
; 1624 : #endif
; 1625 :              default : outstring("Illegal choice.\n");

	push	OFFSET ??_C@_0BB@GAGBKKBE@Illegal?5choice?4?6?$AA@
	call	_outstring
	add	esp, 4

; 1626 :           }
; 1627 :      }

	jmp	$LL271@hessian_me
$LN242@hessian_me:

; 887  : 
; 888  :              case 'Q': case '0': case 0: 
; 889  :                    hessian_exit(X); 

	mov	esi, DWORD PTR _X$[ebp]
	push	esi
	call	_hessian_exit

; 890  :                    free_system(&S);

	lea	edx, DWORD PTR _S$[ebp]
	push	edx
	call	_free_system
	add	esp, 8

; 891  :                    if ( hessian_linear_metric_flag || web.area_norm_flag )

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN240@hessian_me
	cmp	DWORD PTR _web+876, 0
	je	SHORT $LN241@hessian_me
$LN240@hessian_me:

; 892  :                        free_system(&Met);

	push	OFFSET _Met
	call	_free_system
	add	esp, 4
$LN241@hessian_me:

; 893  :                    if ( rhs ) temp_free((char*)rhs);

	mov	eax, DWORD PTR _rhs$[ebp]
	test	eax, eax
	je	SHORT $LN239@hessian_me
	push	eax
	call	_temp_free
	add	esp, 4
$LN239@hessian_me:

; 894  :                    if ( X ) temp_free((char*)X);

	test	esi, esi
	je	SHORT $LN238@hessian_me
	push	esi
	call	_temp_free
	add	esp, 4
$LN238@hessian_me:

; 1628 : } /* end hessian_menu() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN390@hessian_me:
	DD	$LN242@hessian_me
	DD	$LN266@hessian_me
	DD	$LN261@hessian_me
	DD	$LN255@hessian_me
	DD	$LN248@hessian_me
	DD	$LN246@hessian_me
	DD	$LN245@hessian_me
	DD	$LN237@hessian_me
	DD	$LN243@hessian_me
	DD	$LN267@hessian_me
	DD	$LN186@hessian_me
	DD	$LN188@hessian_me
	DD	$LN159@hessian_me
	DD	$LN180@hessian_me
	DD	$LN176@hessian_me
	DD	$LN162@hessian_me
	DD	$LN81@hessian_me
	DD	$LN202@hessian_me
	DD	$LN165@hessian_me
	DD	$LN184@hessian_me
	DD	$LN195@hessian_me
	DD	$LN174@hessian_me
	DD	$LN234@hessian_me
	DD	$LN168@hessian_me
	DD	$LN182@hessian_me
	DD	$LN227@hessian_me
	DD	$LN172@hessian_me
	DD	$LN231@hessian_me
	DD	$LN178@hessian_me
	DD	$LN1@hessian_me
$LN359@hessian_me:
	DB	0
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	5
	DB	6
	DB	7
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	8
	DB	29					; 0000001dH
	DB	9
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	19					; 00000013H
	DB	0
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	29					; 0000001dH
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	29					; 0000001dH
	DB	28					; 0000001cH
_hessian_menu ENDP
_TEXT	ENDS
END
