; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\WULFF.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	__real@c415af1d78b58c40
PUBLIC	_file_wulff
EXTRN	_dot:PROC
EXTRN	_wulff_vector:BYTE
EXTRN	_web:BYTE
EXTRN	__fltused:DWORD
EXTRN	_memcpy:PROC
;	COMDAT __real@c415af1d78b58c40
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\wulff.c
CONST	SEGMENT
__real@c415af1d78b58c40 DQ 0c415af1d78b58c40r	; -1e+020
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _file_wulff
_TEXT	SEGMENT
_maxw$ = -8						; size = 8
_norm$ = 8						; size = 4
_wulff$ = 12						; size = 4
_file_wulff PROC					; COMDAT

; 122  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 123  :   REAL maxw = -1e20;

	fld	QWORD PTR __real@c415af1d78b58c40
	push	ebx
	push	esi
	fstp	QWORD PTR _maxw$[ebp]

; 124  :   REAL *w; /* Wulff vector being tested */
; 125  :   int k;
; 126  :   int best = 0;

	xor	ebx, ebx

; 127  : 
; 128  :   for ( k = 0 ; k < web.wulff_count ; k++ )

	xor	esi, esi
	cmp	DWORD PTR _web+912, ebx
	jle	SHORT $LN2@file_wulff

; 123  :   REAL maxw = -1e20;

	push	edi
	mov	edi, OFFSET _wulff_vector
$LL4@file_wulff:

; 129  :      { w = wulff_vector[k];
; 130  :         if ( SDIM_dot(w,norm) > maxw )

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _norm$[ebp]
	push	eax
	push	ecx
	push	edi
	call	_dot
	fcomp	QWORD PTR _maxw$[ebp]
	add	esp, 12					; 0000000cH
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@file_wulff

; 131  :           { best = k;
; 132  :              maxw = SDIM_dot(w,norm);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _norm$[ebp]
	push	edx
	push	eax
	push	edi
	mov	ebx, esi
	call	_dot
	fstp	QWORD PTR _maxw$[ebp]
	add	esp, 12					; 0000000cH
$LN3@file_wulff:

; 127  : 
; 128  :   for ( k = 0 ; k < web.wulff_count ; k++ )

	inc	esi
	add	edi, 48					; 00000030H
	cmp	esi, DWORD PTR _web+912
	jl	SHORT $LL4@file_wulff
	pop	edi
$LN2@file_wulff:

; 133  :           }
; 134  :      }
; 135  :   memcpy((char *)wulff,(char *)wulff_vector[best],SDIM*sizeof(REAL));

	mov	ecx, DWORD PTR _web+616
	lea	edx, DWORD PTR [ecx*8]
	mov	ecx, DWORD PTR _wulff$[ebp]
	lea	eax, DWORD PTR [ebx+ebx*2]
	shl	eax, 4
	push	edx
	add	eax, OFFSET _wulff_vector
	push	eax
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebx

; 136  : } // end file_wulff()

	mov	esp, ebp
	pop	ebp
	ret	0
_file_wulff ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_hemi_wulff
EXTRN	__CIsqrt:PROC
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _hemi_wulff
_TEXT	SEGMENT
_normal$ = 8						; size = 4
_wulff$ = 12						; size = 4
_hemi_wulff PROC					; COMDAT

; 149  : {

	push	ebp
	mov	ebp, esp

; 150  :   int i;
; 151  :   REAL norm;
; 152  : 
; 153  :   wulff[0] = normal[0];

	mov	ecx, DWORD PTR _normal$[ebp]
	fld	QWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR _wulff$[ebp]
	fstp	QWORD PTR [esi]

; 154  :   wulff[1] = normal[1];

	fld	QWORD PTR [ecx+8]
	fstp	QWORD PTR [esi+8]

; 155  :   if ( normal[2] < 0.0 )

	fldz
	fcom	QWORD PTR [ecx+16]
	fnstsw	ax
	test	ah, 65					; 00000041H

; 156  :      wulff[2] = 0.0;

	je	SHORT $LN20@hemi_wulff

; 157  :   else wulff[2] = normal[2];

	fstp	ST(0)
	fld	QWORD PTR [ecx+16]
$LN20@hemi_wulff:
	fstp	QWORD PTR [esi+16]

; 158  :   norm = sqrt(SDIM_dot(wulff,wulff));

	mov	eax, DWORD PTR _web+616
	push	eax
	push	esi
	push	esi
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 159  :   if ( norm > 0.0 )

	fldz
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN19@hemi_wulff

; 160  :      for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN19@hemi_wulff
$LN3@hemi_wulff:

; 161  :         wulff[i] /= norm;

	fld	QWORD PTR [esi+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [esi+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@hemi_wulff
$LN19@hemi_wulff:

; 160  :      for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
	pop	esi

; 162  : } // end hemi_wulff()

	pop	ebp
	ret	0
_hemi_wulff ENDP
_TEXT	ENDS
PUBLIC	__real@3fe8000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@4008000000000000
PUBLIC	_lens_wulff
;	COMDAT __real@3fe8000000000000
CONST	SEGMENT
__real@3fe8000000000000 DQ 03fe8000000000000r	; 0.75
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _lens_wulff
_TEXT	SEGMENT
_normal$ = 8						; size = 4
_wulff$ = 12						; size = 4
_lens_wulff PROC					; COMDAT

; 175  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 176  :   REAL norm;
; 177  : 
; 178  :   /* test whether interior or edge Wulff vector */  
; 179  :   norm = dot(normal,normal,2);     /* x and y only */

	mov	esi, DWORD PTR _normal$[ebp]
	push	2
	push	esi
	push	esi
	call	_dot

; 180  :   if ( norm < 3*normal[2]*normal[2] )

	fld	QWORD PTR [esi+16]
	fmul	QWORD PTR __real@4008000000000000
	add	esp, 12					; 0000000cH
	fmul	QWORD PTR [esi+16]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@lens_wulff

; 181  :      { /* interior */
; 182  :         norm = sqrt(norm + normal[2]*normal[2]);

	fld	QWORD PTR [esi+16]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt

; 183  :         if ( norm > 0.0 )

	fldz
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN10@lens_wulff

; 184  :           { wulff[0] = normal[0]/norm;

	fld	QWORD PTR [esi]
	mov	eax, DWORD PTR _wulff$[ebp]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax]

; 185  :              wulff[1] = normal[1]/norm;

	fld	QWORD PTR [esi+8]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax+8]

; 186  :              wulff[2] = normal[2]/norm - 0.5;

	fdivr	QWORD PTR [esi+16]
	pop	esi
	fsub	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [eax+16]

; 195  :      }
; 196  : } // end lens_wulff()

	pop	ebp
	ret	0
$LN3@lens_wulff:

; 187  :           }
; 188  :      }
; 189  :   else
; 190  :      { /* edge */
; 191  :         norm = sqrt(norm/0.75);

	fdiv	QWORD PTR __real@3fe8000000000000
	call	__CIsqrt

; 192  :         wulff[0] = normal[0]/norm;

	fld	QWORD PTR [esi]
	fdiv	ST(0), ST(1)
	mov	eax, DWORD PTR _wulff$[ebp]
	fstp	QWORD PTR [eax]

; 193  :         wulff[1] = normal[1]/norm;

	fdivr	QWORD PTR [esi+8]
	pop	esi
	fstp	QWORD PTR [eax+8]

; 194  :         wulff[2] = 0.0;

	fldz
	fstp	QWORD PTR [eax+16]

; 195  :      }
; 196  : } // end lens_wulff()

	pop	ebp
	ret	0
$LN10@lens_wulff:

; 183  :         if ( norm > 0.0 )

	fstp	ST(0)
	pop	esi

; 195  :      }
; 196  : } // end lens_wulff()

	pop	ebp
	ret	0
_lens_wulff ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_facet_wulff_value
EXTRN	_get_wulff:DWORD
EXTRN	_cross_prod:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _facet_wulff_value
_TEXT	SEGMENT
_density$ = -416					; size = 8
_ii$89122 = -408					; size = 4
tv363 = -404						; size = 4
tv1258 = -400						; size = 4
tv1119 = -396						; size = 4
tv1278 = -392						; size = 4
_side$ = -388						; size = 288
_wulff$ = -100						; size = 48
_normal$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_f_info$ = 8						; size = 4
_facet_wulff_value PROC					; COMDAT

; 229  : { REAL normal[MAXCOORD];

	push	ebp
	mov	ebp, esp
	sub	esp, 416				; 000001a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 230  :   REAL wulff [MAXCOORD];
; 231  :   REAL density = get_facet_density(f_info->id);

	mov	ecx, DWORD PTR _web+236
	push	ebx
	mov	ebx, DWORD PTR _f_info$[ebp]
	mov	eax, DWORD PTR [ebx]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+32]
	push	esi

; 232  :   REAL energy;
; 233  :   REAL side  [MAXCOORD][MAXCOORD];
; 234  :   int i,j;
; 235  : 
; 236  :   for ( i = 0 ; i < FACET_EDGES ; i++ )

	xor	eax, eax
	fstp	QWORD PTR _density$[ebp]
	lea	ecx, DWORD PTR _side$[ebp+8]
	lea	edx, DWORD PTR [ebx+416]
	push	edi
	mov	DWORD PTR tv1119[ebp], eax
	mov	DWORD PTR tv1258[ebp], ecx
	mov	DWORD PTR tv1278[ebp], edx
	lea	esi, DWORD PTR [eax+4]
$LL16@facet_wulf:

; 237  :      { int ii = (i+1)%FACET_EDGES;

	inc	eax
	mov	DWORD PTR tv363[ebp], eax
	cdq
	mov	edi, 3
	idiv	edi
	mov	edi, edx

; 238  :         for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	mov	DWORD PTR _ii$89122[ebp], edi
	cmp	DWORD PTR _web+616, esi
	jl	SHORT $LC14@facet_wulf
	mov	edx, DWORD PTR [ebx+edi*4+416]
	mov	eax, DWORD PTR tv1278[ebp]
	mov	esi, DWORD PTR [eax]
	lea	eax, DWORD PTR [esi+8]

; 239  :             side[i][j] = f_info->x[ii][j] - f_info->x[i][j];

	mov	ebx, edx
	sub	ebx, esi
	mov	esi, DWORD PTR _web+616
	add	esi, -4					; fffffffcH
	shr	esi, 2
	inc	esi
	lea	edi, DWORD PTR [edx+24]
	lea	edx, DWORD PTR [esi*4]
$LL15@facet_wulf:
	fld	QWORD PTR [edi-24]
	add	eax, 32					; 00000020H
	fsub	QWORD PTR [eax-40]
	add	edi, 32					; 00000020H
	add	ecx, 32					; 00000020H
	dec	esi
	fstp	QWORD PTR [ecx-40]
	fld	QWORD PTR [eax+ebx-32]
	fsub	QWORD PTR [eax-32]
	fstp	QWORD PTR [ecx-32]
	fld	QWORD PTR [edi-40]
	fsub	QWORD PTR [eax-24]
	fstp	QWORD PTR [ecx-24]
	fld	QWORD PTR [edi-32]
	fsub	QWORD PTR [eax-16]
	fstp	QWORD PTR [ecx-16]
	jne	SHORT $LL15@facet_wulf

; 237  :      { int ii = (i+1)%FACET_EDGES;

	mov	ebx, DWORD PTR _f_info$[ebp]
	mov	edi, DWORD PTR _ii$89122[ebp]
$LC14@facet_wulf:

; 238  :         for ( j = 0 ; j < SDIM ; j++ )

	cmp	edx, DWORD PTR _web+616
	jge	SHORT $LN5@facet_wulf
	mov	ecx, DWORD PTR tv1278[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ebx+edi*4+416]
	mov	esi, DWORD PTR tv1119[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	sub	edi, ecx
	mov	ecx, DWORD PTR _web+616
	add	esi, edx
	lea	esi, DWORD PTR _side$[ebp+esi*8]
	sub	ecx, edx
$LC3@facet_wulf:

; 239  :             side[i][j] = f_info->x[ii][j] - f_info->x[i][j];

	fld	QWORD PTR [edi+eax]
	add	eax, 8
	fsub	QWORD PTR [eax-8]
	add	esi, 8
	dec	ecx
	fstp	QWORD PTR [esi-8]
	jne	SHORT $LC3@facet_wulf
$LN5@facet_wulf:

; 232  :   REAL energy;
; 233  :   REAL side  [MAXCOORD][MAXCOORD];
; 234  :   int i,j;
; 235  : 
; 236  :   for ( i = 0 ; i < FACET_EDGES ; i++ )

	mov	edx, DWORD PTR tv1119[ebp]
	mov	ecx, DWORD PTR tv1258[ebp]
	mov	eax, DWORD PTR tv363[ebp]
	mov	esi, 4
	add	DWORD PTR tv1278[ebp], esi
	add	edx, 6
	add	ecx, 48					; 00000030H
	mov	DWORD PTR tv1258[ebp], ecx
	mov	DWORD PTR tv1119[ebp], edx
	cmp	edx, 18					; 00000012H
	jl	$LL16@facet_wulf

; 240  :      }
; 241  :   /* calculate normal */ 
; 242  :   cross_prod(side[0],side[1],normal);

	lea	edx, DWORD PTR _normal$[ebp]
	push	edx
	lea	eax, DWORD PTR _side$[ebp+48]
	push	eax
	lea	ecx, DWORD PTR _side$[ebp]
	push	ecx
	call	_cross_prod

; 243  :   (*get_wulff)(normal,wulff);

	lea	edx, DWORD PTR _wulff$[ebp]
	push	edx
	lea	eax, DWORD PTR _normal$[ebp]
	push	eax
	call	DWORD PTR _get_wulff

; 244  :   energy = SDIM_dot(wulff,normal)/2;

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _normal$[ebp]
	push	edx
	lea	eax, DWORD PTR _wulff$[ebp]
	push	eax
	call	_dot
	fmul	QWORD PTR __real@3fe0000000000000

; 245  :   return density*energy;
; 246  : } // end  facet_wulff_value()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 32					; 00000020H
	fmul	QWORD PTR _density$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_facet_wulff_value ENDP
_TEXT	ENDS
PUBLIC	_f_info$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_facet_wulff_grad
; Function compile flags: /Ogtp
;	COMDAT _facet_wulff_grad
_TEXT	SEGMENT
_density$ = -468					; size = 8
_f_info$GSCopy$ = -460					; size = 4
_ii$89141 = -456					; size = 4
tv395 = -452						; size = 4
tv1287 = -448						; size = 4
tv1148 = -444						; size = 4
tv1307 = -440						; size = 4
_side$ = -436						; size = 288
_temp$ = -148						; size = 48
_wulff$ = -100						; size = 48
_normal$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_f_info$ = 8						; size = 4
_facet_wulff_grad PROC					; COMDAT

; 253  : { REAL normal[MAXCOORD];

	push	ebp
	mov	ebp, esp
	sub	esp, 468				; 000001d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 254  :   REAL wulff [MAXCOORD];
; 255  :   REAL temp  [MAXCOORD];
; 256  :   REAL side  [MAXCOORD][MAXCOORD];
; 257  :   REAL density = get_facet_density(f_info->id);

	mov	ecx, DWORD PTR _web+236
	push	ebx
	mov	ebx, DWORD PTR _f_info$[ebp]
	mov	eax, DWORD PTR [ebx]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+32]
	push	esi

; 258  :   REAL energy;
; 259  :   int i,j;
; 260  : 
; 261  :   for ( i = 0 ; i < FACET_EDGES ; i++ )

	xor	eax, eax
	fstp	QWORD PTR _density$[ebp]
	lea	ecx, DWORD PTR _side$[ebp+8]

; 269  :   /* force on each vertex */
; 270  :   for ( i = 0 ; i < FACET_VERTS ; i++ )  /* vertex loop */

	lea	edx, DWORD PTR [ebx+416]
	push	edi
	mov	DWORD PTR _f_info$GSCopy$[ebp], ebx
	mov	DWORD PTR tv1148[ebp], eax
	mov	DWORD PTR tv1287[ebp], ecx
	mov	DWORD PTR tv1307[ebp], edx
	lea	esi, DWORD PTR [eax+4]
	npad	5
$LL26@facet_wulf@2:

; 262  :      { int ii = (i+1)%FACET_EDGES;

	inc	eax
	mov	DWORD PTR tv395[ebp], eax
	cdq
	mov	edi, 3
	idiv	edi
	mov	edi, edx

; 263  :         for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	mov	DWORD PTR _ii$89141[ebp], edi
	cmp	DWORD PTR _web+616, esi
	jl	SHORT $LC24@facet_wulf@2
	mov	edx, DWORD PTR [ebx+edi*4+416]
	mov	eax, DWORD PTR tv1307[ebp]
	mov	esi, DWORD PTR [eax]
	lea	eax, DWORD PTR [esi+8]

; 264  :             side[i][j] = f_info->x[ii][j] - f_info->x[i][j];

	mov	ebx, edx
	sub	ebx, esi
	mov	esi, DWORD PTR _web+616
	add	esi, -4					; fffffffcH
	shr	esi, 2
	inc	esi
	lea	edi, DWORD PTR [edx+24]
	lea	edx, DWORD PTR [esi*4]
	npad	2
$LL25@facet_wulf@2:
	fld	QWORD PTR [edi-24]
	add	eax, 32					; 00000020H
	fsub	QWORD PTR [eax-40]
	add	edi, 32					; 00000020H
	add	ecx, 32					; 00000020H
	dec	esi
	fstp	QWORD PTR [ecx-40]
	fld	QWORD PTR [eax+ebx-32]
	fsub	QWORD PTR [eax-32]
	fstp	QWORD PTR [ecx-32]
	fld	QWORD PTR [edi-40]
	fsub	QWORD PTR [eax-24]
	fstp	QWORD PTR [ecx-24]
	fld	QWORD PTR [edi-32]
	fsub	QWORD PTR [eax-16]
	fstp	QWORD PTR [ecx-16]
	jne	SHORT $LL25@facet_wulf@2

; 262  :      { int ii = (i+1)%FACET_EDGES;

	mov	ebx, DWORD PTR _f_info$GSCopy$[ebp]
	mov	edi, DWORD PTR _ii$89141[ebp]
$LC24@facet_wulf@2:

; 263  :         for ( j = 0 ; j < SDIM ; j++ )

	cmp	edx, DWORD PTR _web+616
	jge	SHORT $LN11@facet_wulf@2
	mov	ecx, DWORD PTR tv1307[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ebx+edi*4+416]
	mov	esi, DWORD PTR tv1148[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	sub	edi, ecx
	mov	ecx, DWORD PTR _web+616
	add	esi, edx
	lea	esi, DWORD PTR _side$[ebp+esi*8]
	sub	ecx, edx
$LC9@facet_wulf@2:

; 264  :             side[i][j] = f_info->x[ii][j] - f_info->x[i][j];

	fld	QWORD PTR [edi+eax]
	add	eax, 8
	fsub	QWORD PTR [eax-8]
	add	esi, 8
	dec	ecx
	fstp	QWORD PTR [esi-8]
	jne	SHORT $LC9@facet_wulf@2
$LN11@facet_wulf@2:

; 258  :   REAL energy;
; 259  :   int i,j;
; 260  : 
; 261  :   for ( i = 0 ; i < FACET_EDGES ; i++ )

	mov	edx, DWORD PTR tv1148[ebp]
	mov	ecx, DWORD PTR tv1287[ebp]
	mov	eax, DWORD PTR tv395[ebp]
	mov	esi, 4
	add	DWORD PTR tv1307[ebp], esi
	add	edx, 6
	add	ecx, 48					; 00000030H
	mov	DWORD PTR tv1287[ebp], ecx
	mov	DWORD PTR tv1148[ebp], edx
	cmp	edx, 18					; 00000012H
	jl	$LL26@facet_wulf@2

; 265  :      }
; 266  :   /* calculate normal */ 
; 267  :   cross_prod(side[0],side[1],normal);

	lea	edx, DWORD PTR _normal$[ebp]
	push	edx
	lea	eax, DWORD PTR _side$[ebp+48]
	push	eax
	lea	ecx, DWORD PTR _side$[ebp]
	push	ecx
	call	_cross_prod

; 268  :   (*get_wulff)(normal,wulff);

	lea	edx, DWORD PTR _wulff$[ebp]
	push	edx
	lea	eax, DWORD PTR _normal$[ebp]
	push	eax
	call	DWORD PTR _get_wulff
	add	esp, 20					; 00000014H

; 269  :   /* force on each vertex */
; 270  :   for ( i = 0 ; i < FACET_VERTS ; i++ )  /* vertex loop */

	xor	esi, esi
$LL6@facet_wulf@2:

; 271  :       { int k;
; 272  :          j = (i+1)%FACET_EDGES;  /* opposite side */
; 273  :          cross_prod(side[j],wulff,temp);

	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _wulff$[ebp]
	push	edx
	lea	eax, DWORD PTR [esi+1]
	cdq
	mov	ecx, 3
	idiv	ecx
	lea	edx, DWORD PTR [edx+edx*2]
	add	edx, edx
	lea	eax, DWORD PTR _side$[ebp+edx*8]
	push	eax
	call	_cross_prod

; 274  :          for ( k = 0 ; k < SDIM ; k++ ) 

	mov	ecx, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN5@facet_wulf@2
	fld	QWORD PTR __real@3fe0000000000000
	fld	QWORD PTR _density$[ebp]
$LN3@facet_wulf@2:

; 275  :              f_info->grad[i][k] -= density*temp[k]/2;

	fld	QWORD PTR _temp$[ebp+eax*8]
	mov	ecx, DWORD PTR [ebx+1336]
	mov	edx, DWORD PTR [ecx+esi*4]
	fmul	ST(0), ST(1)
	lea	ecx, DWORD PTR [edx+eax*8]
	inc	eax
	fmul	ST(0), ST(2)
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN3@facet_wulf@2

; 274  :          for ( k = 0 ; k < SDIM ; k++ ) 

	fstp	ST(1)
	fstp	ST(0)
$LN5@facet_wulf@2:

; 269  :   /* force on each vertex */
; 270  :   for ( i = 0 ; i < FACET_VERTS ; i++ )  /* vertex loop */

	inc	esi
	cmp	esi, 3
	jl	SHORT $LL6@facet_wulf@2

; 276  :       }
; 277  :   energy = SDIM_dot(wulff,normal)/2;

	push	ecx
	lea	eax, DWORD PTR _normal$[ebp]
	push	eax
	lea	ecx, DWORD PTR _wulff$[ebp]
	push	ecx
	call	_dot
	fmul	QWORD PTR __real@3fe0000000000000

; 278  :   return density*energy;
; 279  : } // end facet_wulff_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	fmul	QWORD PTR _density$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_facet_wulff_grad ENDP
_TEXT	ENDS
PUBLIC	??_C@_03DLDNIBIK@?$CFlf?$AA@			; `string'
PUBLIC	??_C@_0CD@DFEHFDGO@Cannot?5open?5Wulff?5vector?5file?5?$CFs@ ; `string'
PUBLIC	??_C@_04CPLMFJIA@lens?$AA@			; `string'
PUBLIC	??_C@_04GIFHLLMC@hemi?$AA@			; `string'
PUBLIC	??_C@_0L@BHMOPECP@hemisphere?$AA@		; `string'
PUBLIC	??_C@_0BK@BMIBJJGI@Missing?5Wulff?5file?5name?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DA@BKAIHILB@Can?5only?5do?5Wulff?5energy?5for?52D?5@ ; `string'
PUBLIC	_wulff_initialize
EXTRN	_fclose:PROC
EXTRN	_fscanf:PROC
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
EXTRN	_path_open:PROC
EXTRN	_strncmp:PROC
EXTRN	_strncpy:PROC
EXTRN	_kb_error:PROC
;	COMDAT ??_C@_03DLDNIBIK@?$CFlf?$AA@
CONST	SEGMENT
??_C@_03DLDNIBIK@?$CFlf?$AA@ DB '%lf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DFEHFDGO@Cannot?5open?5Wulff?5vector?5file?5?$CFs@
CONST	SEGMENT
??_C@_0CD@DFEHFDGO@Cannot?5open?5Wulff?5vector?5file?5?$CFs@ DB 'Cannot o'
	DB	'pen Wulff vector file %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CPLMFJIA@lens?$AA@
CONST	SEGMENT
??_C@_04CPLMFJIA@lens?$AA@ DB 'lens', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GIFHLLMC@hemi?$AA@
CONST	SEGMENT
??_C@_04GIFHLLMC@hemi?$AA@ DB 'hemi', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BHMOPECP@hemisphere?$AA@
CONST	SEGMENT
??_C@_0L@BHMOPECP@hemisphere?$AA@ DB 'hemisphere', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMIBJJGI@Missing?5Wulff?5file?5name?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@BMIBJJGI@Missing?5Wulff?5file?5name?4?6?$AA@ DB 'Missing Wulff '
	DB	'file name.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BKAIHILB@Can?5only?5do?5Wulff?5energy?5for?52D?5@
CONST	SEGMENT
??_C@_0DA@BKAIHILB@Can?5only?5do?5Wulff?5energy?5for?52D?5@ DB 'Can only '
	DB	'do Wulff energy for 2D surface in 3D.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _wulff_initialize
_TEXT	SEGMENT
tv218 = 8						; size = 4
_wulffname$ = 8						; size = 4
_wulff_initialize PROC					; COMDAT

; 50   : {

	push	ebp
	mov	ebp, esp

; 51   :   FILE *wfd;
; 52   :   REAL *row; /* current Wulff vector */
; 53   :   int k;         /* vector number */
; 54   :   int j;         /* dimension number */
; 55   : 
; 56   :   if ( (web.representation != SOAPFILM ) || (SDIM != 3) )

	cmp	DWORD PTR _web+624, 2
	jne	SHORT $LN15@wulff_init
	cmp	DWORD PTR _web+616, 3
	je	SHORT $LN29@wulff_init
$LN15@wulff_init:

; 57   :      kb_error(1385,"Can only do Wulff energy for 2D surface in 3D.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DA@BKAIHILB@Can?5only?5do?5Wulff?5energy?5for?52D?5@
	push	1385					; 00000569H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN29@wulff_init:

; 58   : 
; 59   :   if ( !wulffname || (wulffname[0] == 0) )

	push	esi
	mov	esi, DWORD PTR _wulffname$[ebp]
	test	esi, esi
	je	SHORT $LN13@wulff_init
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN31@wulff_init
$LN13@wulff_init:

; 60   :      kb_error(2857,"Missing Wulff file name.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BK@BMIBJJGI@Missing?5Wulff?5file?5name?4?6?$AA@
	push	2857					; 00000b29H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN31@wulff_init:

; 61   :   web.wulff_flag = 1;
; 62   : 
; 63   :   /* save  name */
; 64   :   strncpy(web.wulff_name,wulffname,sizeof(web.wulff_name));

	push	60					; 0000003cH
	push	esi
	push	OFFSET _web+916
	mov	DWORD PTR _web+908, 1
	call	_strncpy

; 65   : 
; 66   :   /* test special names */
; 67   :   if ( (strncmp(wulffname,"hemisphere",10) == 0  )
; 68   :       || (strcmp(wulffname,"hemi") == 0)  )

	push	10					; 0000000aH
	push	OFFSET ??_C@_0L@BHMOPECP@hemisphere?$AA@
	push	esi
	call	_strncmp
	add	esp, 24					; 00000018H
	test	eax, eax
	je	$LN11@wulff_init
	mov	ecx, OFFSET ??_C@_04GIFHLLMC@hemi?$AA@
	mov	eax, esi
$LL24@wulff_init:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN25@wulff_init
	test	dl, dl
	je	SHORT $LN26@wulff_init
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN25@wulff_init
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL24@wulff_init
$LN26@wulff_init:
	xor	eax, eax
	jmp	SHORT $LN27@wulff_init
$LN25@wulff_init:
	sbb	eax, eax
	sbb	eax, -1
$LN27@wulff_init:
	test	eax, eax
	je	$LN11@wulff_init

; 70   :     return;
; 71   :   }
; 72   :   else if ( strncmp(wulffname,"lens",4) == 0 )

	push	4
	push	OFFSET ??_C@_04CPLMFJIA@lens?$AA@
	push	esi
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN9@wulff_init

; 73   :   { get_wulff = lens_wulff;

	mov	DWORD PTR _get_wulff, OFFSET _lens_wulff
	pop	esi

; 103  : } // end wulff_initialize()

	pop	ebp
	ret	0
$LN9@wulff_init:
	push	ebx

; 74   :     return;
; 75   :   }
; 76   : 
; 77   :   /* default is from file */
; 78   :   get_wulff = file_wulff;
; 79   : 
; 80   :   wfd = path_open(wulffname,NOTDATAFILENAME);

	push	0
	push	esi
	mov	DWORD PTR _get_wulff, OFFSET _file_wulff
	call	_path_open
	mov	ebx, eax
	add	esp, 8

; 81   :   if ( wfd == NULL )

	test	ebx, ebx
	jne	SHORT $LN8@wulff_init

; 82   :      { sprintf(errmsg,"Cannot open Wulff vector file %s.\n",wulffname);

	push	esi
	push	OFFSET ??_C@_0CD@DFEHFDGO@Cannot?5open?5Wulff?5vector?5file?5?$CFs@
	push	OFFSET _errmsg
	call	_sprintf

; 83   :        kb_error(1386,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1386					; 0000056aH
	call	_kb_error
	add	esp, 24					; 00000018H
	pop	ebx
	pop	esi

; 103  : } // end wulff_initialize()

	pop	ebp
	ret	0
$LN8@wulff_init:

; 84   :        return;
; 85   :      }
; 86   : 
; 87   :   for ( k = 0 ; k < MAXWULFF ; k++ )

	mov	esi, OFFSET _wulff_vector
	mov	DWORD PTR tv218[ebp], esi
	push	edi
	npad	5
$LL32@wulff_init:

; 88   :      { row = wulff_vector[k];
; 89   :        for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	cmp	DWORD PTR _web+616, edi
	jle	SHORT $LN6@wulff_init
	npad	6
$LL4@wulff_init:

; 90   : #ifdef FLOAT128
; 91   :        { DOUBLE x;
; 92   :          if ( fscanf(wfd,"%lf",&x) != 1 ) break;
; 93   :          row[j] = x;
; 94   :        }
; 95   : #elif defined(LONGDOUBLE)
; 96   :        if ( fscanf(wfd,"%Lf",row+j) != 1 ) break;
; 97   : #else
; 98   :        if ( fscanf(wfd,"%lf",row+j) != 1 ) break;

	push	esi
	push	OFFSET ??_C@_03DLDNIBIK@?$CFlf?$AA@
	push	ebx
	call	_fscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN6@wulff_init

; 88   :      { row = wulff_vector[k];
; 89   :        for ( j = 0 ; j < SDIM ; j++ )

	inc	edi
	add	esi, 8
	cmp	edi, DWORD PTR _web+616
	jl	SHORT $LL4@wulff_init
$LN6@wulff_init:

; 84   :        return;
; 85   :      }
; 86   : 
; 87   :   for ( k = 0 ; k < MAXWULFF ; k++ )

	mov	esi, DWORD PTR tv218[ebp]
	add	esi, 48					; 00000030H
	mov	DWORD PTR tv218[ebp], esi
	cmp	esi, OFFSET _wulff_vector+4800
	jl	SHORT $LL32@wulff_init

; 99   : #endif
; 100  :      }
; 101  :   fclose(wfd);

	push	ebx
	call	_fclose
	add	esp, 4
	pop	edi
	pop	ebx

; 102  :   web.wulff_count = k;

	mov	DWORD PTR _web+912, 100			; 00000064H
	pop	esi

; 103  : } // end wulff_initialize()

	pop	ebp
	ret	0
$LN11@wulff_init:

; 69   :   { get_wulff = hemi_wulff;

	mov	DWORD PTR _get_wulff, OFFSET _hemi_wulff
	pop	esi

; 103  : } // end wulff_initialize()

	pop	ebp
	ret	0
_wulff_initialize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@IHDLOMH@Enter?5Wulff?5name?5?$CIhemi?0lens?0?5or?5@ ; `string'
PUBLIC	??_C@_0DA@PLCDCIOA@Wulff?5energy?5can?5only?5be?5done?5in@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_wulff_method_init
EXTRN	_prompt:PROC
;	COMDAT ??_C@_0CM@IHDLOMH@Enter?5Wulff?5name?5?$CIhemi?0lens?0?5or?5@
CONST	SEGMENT
??_C@_0CM@IHDLOMH@Enter?5Wulff?5name?5?$CIhemi?0lens?0?5or?5@ DB 'Enter W'
	DB	'ulff name (hemi,lens, or filename): ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@PLCDCIOA@Wulff?5energy?5can?5only?5be?5done?5in@
CONST	SEGMENT
??_C@_0DA@PLCDCIOA@Wulff?5energy?5can?5only?5be?5done?5in@ DB 'Wulff ener'
	DB	'gy can only be done in LINEAR model.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _wulff_method_init
_TEXT	SEGMENT
_response$ = -204					; size = 200
__$ArrayPad$ = -4					; size = 4
_mode$ = 8						; size = 4
_mi$ = 12						; size = 4
_wulff_method_init PROC					; COMDAT

; 212  : { char response[200];

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 213  : 
; 214  :   if ( web.modeltype != LINEAR )

	cmp	DWORD PTR _web+628, 1
	je	SHORT $LN2@wulff_meth

; 215  :     kb_error(2859,"Wulff energy can only be done in LINEAR model.\n",
; 216  :      RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DA@PLCDCIOA@Wulff?5energy?5can?5only?5be?5done?5in@
	push	2859					; 00000b2bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN2@wulff_meth:

; 217  : 
; 218  :   if ( web.wulff_flag == 0 ) 

	cmp	DWORD PTR _web+908, 0
	jne	SHORT $LN1@wulff_meth

; 219  :   { prompt("Enter Wulff name (hemi,lens, or filename): ",response,sizeof(response));

	push	200					; 000000c8H
	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	push	OFFSET ??_C@_0CM@IHDLOMH@Enter?5Wulff?5name?5?$CIhemi?0lens?0?5or?5@
	call	_prompt

; 220  :      wulff_initialize(response);

	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	call	_wulff_initialize
	add	esp, 16					; 00000010H
$LN1@wulff_meth:

; 221  :   }
; 222  : } // end wulff_method_init()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_wulff_method_init ENDP
_TEXT	ENDS
END
