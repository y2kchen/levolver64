; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\LEXINIT2.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_get_fe_edge
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _get_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_facet PROC					; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp

; 84   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 85   :     return inverse_id(feptr(fe_id)->nextfacet[1]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]
	xor	eax, 134217728				; 08000000H

; 88   : }

	pop	ebp
	ret	0
$LN2@get_prev_f:

; 86   :   else 
; 87   :     return feptr(fe_id)->nextfacet[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]

; 88   : }

	pop	ebp
	ret	0
_get_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_prev_edge
EXTRN	_top_timestamp:DWORD
EXTRN	_global_timestamp:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_edge PROC					; COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp

; 103  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_e

; 104  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_e

; 105  :     { invert(fe);
; 106  :       feptr(fe_id)->nextedge[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+32], ecx

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 111  : }

	pop	ebp
	ret	0
$LN2@set_prev_e:

; 107  :     }
; 108  :   else
; 109  :       feptr(fe_id)->nextedge[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_e:

; 111  : }

	pop	ebp
	ret	0
_set_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_set_next_edge
; Function compile flags: /Ogtp
;	COMDAT _set_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_next_edge PROC					; COMDAT

; 116  : {

	push	ebp
	mov	ebp, esp

; 117  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_next_e

; 118  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_next_e

; 119  :     { invert(fe);

	mov	ecx, DWORD PTR _fe$[ebp]

; 120  :       feptr(fe_id)->nextedge[0] = fe;

	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+28], ecx

; 124  : }

	pop	ebp
	ret	0
$LN2@set_next_e:

; 121  :     }
; 122  :   else
; 123  :       feptr(fe_id)->nextedge[1] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN1@set_next_e:

; 124  : }

	pop	ebp
	ret	0
_set_next_edge ENDP
_TEXT	ENDS
PUBLIC	_set_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _set_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_facet PROC					; COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp

; 130  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_f

; 131  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_f

; 132  :   { invert(fe);
; 133  :     feptr(fe_id)->nextfacet[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+40], ecx

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 138  : }

	pop	ebp
	ret	0
$LN2@set_prev_f:

; 134  :   }
; 135  :   else
; 136  :     feptr(fe_id)->nextfacet[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+36], eax

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_f:

; 138  : }

	pop	ebp
	ret	0
_set_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_set_next_facet
; Function compile flags: /Ogtp
;	COMDAT _set_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_next_facet PROC					; COMDAT

; 143  : {

	push	ebp
	mov	ebp, esp

; 144  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_next_f

; 145  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_next_f

; 146  :   { invert(fe);

	mov	ecx, DWORD PTR _fe$[ebp]

; 147  :     feptr(fe_id)->nextfacet[0] = fe;

	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+36], ecx

; 151  : }

	pop	ebp
	ret	0
$LN2@set_next_f:

; 148  :   }
; 149  :   else
; 150  :     feptr(fe_id)->nextfacet[1] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+40], eax
$LN1@set_next_f:

; 151  : }

	pop	ebp
	ret	0
_set_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _set_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_edge_fe PROC					; COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp

; 172  :   if ( inverted(e_id) ) invert(fe);

	mov	eax, DWORD PTR _e_id$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN1@set_edge_f
	xor	DWORD PTR _fe$[ebp], 134217728		; 08000000H
$LN1@set_edge_f:

; 173  :   eptr(e_id)->fe_id = fe;

	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 174  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 175  : }

	pop	ebp
	ret	0
_set_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_tail_edge PROC				; COMDAT

; 270  : { return eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4+32]
	pop	ebp
	ret	0
_get_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_get_body_volume
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_body_volume
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_volume PROC					; COMDAT

; 308  :     { return    ( valid_id(b_id) ?  bptr(b_id)->volume : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_v
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+40]
	pop	ebp
	ret	0
$LN3@get_body_v:
	fldz
	pop	ebp
	ret	0
_get_body_volume ENDP
_TEXT	ENDS
PUBLIC	_get_body_fixvol
; Function compile flags: /Ogtp
;	COMDAT _get_body_fixvol
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_fixvol PROC					; COMDAT

; 311  :      { return ( valid_id(b_id) ?  bptr(b_id)->fixvol : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_f
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+32]
	pop	ebp
	ret	0
$LN3@get_body_f:
	fldz
	pop	ebp
	ret	0
_get_body_fixvol ENDP
_TEXT	ENDS
PUBLIC	_get_body_pressure
; Function compile flags: /Ogtp
;	COMDAT _get_body_pressure
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_pressure PROC					; COMDAT

; 317  :     { return  ( valid_id(b_id) ?    bptr(b_id)->pressure : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_p
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+312]
	pop	ebp
	ret	0
$LN3@get_body_p:
	fldz
	pop	ebp
	ret	0
_get_body_pressure ENDP
_TEXT	ENDS
PUBLIC	_get_body_volconst
; Function compile flags: /Ogtp
;	COMDAT _get_body_volconst
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_volconst PROC					; COMDAT

; 320  :   { return    ( valid_id(b_id) ?  bptr(b_id)->volconst : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_v@2
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+328]
	pop	ebp
	ret	0
$LN3@get_body_v@2:
	fldz
	pop	ebp
	ret	0
_get_body_volconst ENDP
_TEXT	ENDS
PUBLIC	_set_body_volconst
EXTRN	_gen_quant_list:DWORD
EXTRN	_everything_quantities_flag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_body_volconst
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_set_body_volconst PROC					; COMDAT

; 329  : { if ( !valid_id(b_id) ) return;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_body_v

; 330  :   bptr(b_id)->volconst = v;

	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	fst	QWORD PTR [edx+328]

; 331  :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN6@set_body_v

; 332  :   { struct gen_quant *q = GEN_QUANT(get_body_volquant(b_id));

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx+404]

; 333  :     q->volconst = v;

	mov	ecx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H
	fstp	QWORD PTR [eax+ecx+208]

; 334  :   }
; 335  : }

	pop	ebp
	ret	0
$LN6@set_body_v:

; 333  :     q->volconst = v;

	fstp	ST(0)
$LN1@set_body_v:

; 334  :   }
; 335  : }

	pop	ebp
	ret	0
_set_body_volconst ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@		; `string'
PUBLIC	_torus_period_init
EXTRN	_set_inverse_periods_global:PROC
EXTRN	_set_torus_periods_global:PROC
EXTRN	_kb_dmatrix:PROC
;	COMDAT __real@3ff0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\lexinit2.c
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
CONST	SEGMENT
??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@ DB 'LEXINIT2.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _torus_period_init
_TEXT	SEGMENT
_torus_period_init PROC					; COMDAT

; 29   : 
; 30   :   if ( web.torus_period ) return;

	cmp	DWORD PTR _web+1608, 0
	jne	$LN5@torus_peri

; 31   : 
; 32   :   web.torus_period = dmatrix(0,SDIM-1,0,SDIM-1);

	mov	eax, DWORD PTR _web+616
	push	32					; 00000020H
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 33   :   web.inverse_periods = dmatrix(0,SDIM-1,0,SDIM-1);

	push	33					; 00000021H
	mov	DWORD PTR _web+1608, eax
	mov	eax, DWORD PTR _web+616
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 34   :   web.inverse_periods_tr = dmatrix(0,SDIM-1,0,SDIM-1);

	push	34					; 00000022H
	mov	DWORD PTR _web+1612, eax
	mov	eax, DWORD PTR _web+616
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix
	add	esp, 72					; 00000048H
	mov	DWORD PTR _web+1616, eax

; 35   :   set_torus_periods_global();

	call	_set_torus_periods_global

; 36   :   set_inverse_periods_global();

	call	_set_inverse_periods_global

; 37   :   for ( i = 0 ; i < SDIM ; i++ )

	fld1
	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN1@torus_peri
$LN3@torus_peri:

; 38   :     web.torus_period[i][i] = web.inverse_periods[i][i] = 1.0;

	mov	ecx, DWORD PTR _web+1612
	mov	edx, DWORD PTR [ecx+eax*4]
	fst	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _web+1608
	mov	edx, DWORD PTR [ecx+eax*4]
	fst	QWORD PTR [edx+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@torus_peri
$LN1@torus_peri:

; 39   :   web.torusv = 1.0;

	fstp	QWORD PTR _web+1600
$LN5@torus_peri:

; 40   : } // end torus_period_init()

	ret	0
_torus_period_init ENDP
_TEXT	ENDS
PUBLIC	_torus_display_period_init
; Function compile flags: /Ogtp
;	COMDAT _torus_display_period_init
_TEXT	SEGMENT
_torus_display_period_init PROC				; COMDAT

; 51   : 
; 52   :   if ( web.torus_display_period ) return;

	cmp	DWORD PTR _web+1620, 0
	jne	SHORT $LN1@torus_disp

; 53   : 
; 54   :   web.torus_display_period = dmatrix(0,SDIM-1,0,SDIM-1);

	mov	eax, DWORD PTR _web+616
	push	54					; 00000036H
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 55   :   web.inverse_display_periods = dmatrix(0,SDIM-1,0,SDIM-1);

	push	55					; 00000037H
	mov	DWORD PTR _web+1620, eax
	mov	eax, DWORD PTR _web+616
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix
	mov	DWORD PTR _web+1672, eax

; 56   :   for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	add	esp, 48					; 00000030H
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN1@torus_disp
	fld1
$LN3@torus_disp:

; 57   :     web.torus_display_period[i][i] = web.inverse_display_periods[i][i] = 1.0;

	mov	ecx, DWORD PTR _web+1672
	mov	edx, DWORD PTR [ecx+eax*4]
	fst	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _web+1620
	mov	edx, DWORD PTR [ecx+eax*4]
	fst	QWORD PTR [edx+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@torus_disp

; 56   :   for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN1@torus_disp:

; 58   : } // end torus_display_period_init()

	ret	0
_torus_display_period_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@MOBBDHGA@Bad?5torus_period?$FL?$CFd?$FN?$FL?$CFd?$FN?5definit@ ; `string'
PUBLIC	??_C@_0BG@EONKGAPM@torus?5period?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	_read_periods
EXTRN	_kb_error:PROC
EXTRN	_errmsg:BYTE
EXTRN	_calc_periods:PROC
EXTRN	_sprintf:PROC
EXTRN	_exparse:PROC
EXTRN	_torus_period_expr:BYTE
;	COMDAT ??_C@_0DN@MOBBDHGA@Bad?5torus_period?$FL?$CFd?$FN?$FL?$CFd?$FN?5definit@
CONST	SEGMENT
??_C@_0DN@MOBBDHGA@Bad?5torus_period?$FL?$CFd?$FN?$FL?$CFd?$FN?5definit@ DB 'B'
	DB	'ad torus_period[%d][%d] definition.  Check space dimension', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EONKGAPM@torus?5period?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BG@EONKGAPM@torus?5period?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$AA@ DB 'tor'
	DB	'us period [%d][%d]', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _read_periods
_TEXT	SEGMENT
tv216 = -4						; size = 4
_read_periods PROC					; COMDAT

; 68   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi

; 69   :   int i,j;
; 70   : 
; 71   :   torus_period_init();

	call	_torus_period_init

; 72   : 
; 73   :   /* read in torus periods */
; 74   :   for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN5@read_perio

; 69   :   int i,j;
; 70   : 
; 71   :   torus_period_init();

	mov	edi, OFFSET _torus_period_expr+20
	mov	DWORD PTR tv216[ebp], edi
	npad	1
$LL16@read_perio:

; 75   :     for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN6@read_perio
$LL15@read_perio:

; 76   :     { int esize;
; 77   :       esize = exparse(0,&torus_period_expr[i][j],USERCOPY);

	push	1
	lea	eax, DWORD PTR [edi-20]
	push	eax
	push	0
	call	_exparse
	add	esp, 12					; 0000000cH

; 78   :       if ( esize <= 0 )

	test	eax, eax
	jle	SHORT $LN12@read_perio

; 83   :         return;
; 84   :       }
; 85   :       sprintf(torus_period_expr[i][j].name,"torus period [%d][%d]",i,j);

	push	esi
	push	ebx
	push	OFFSET ??_C@_0BG@EONKGAPM@torus?5period?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$AA@
	push	edi
	call	_sprintf
	mov	eax, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	add	edi, 104				; 00000068H
	cmp	esi, eax
	jl	SHORT $LL15@read_perio
$LN6@read_perio:

; 72   : 
; 73   :   /* read in torus periods */
; 74   :   for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR tv216[ebp]
	inc	ebx
	add	edi, 624				; 00000270H
	mov	DWORD PTR tv216[ebp], edi
	cmp	ebx, eax
	jl	SHORT $LL16@read_perio
$LN5@read_perio:

; 86   :     }
; 87   :   calc_periods(ADJUST_VOLUMES);

	push	1
	call	_calc_periods
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 88   : 
; 89   : } // end read_periods()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@read_perio:

; 79   :       { sprintf(errmsg,
; 80   :             "Bad torus_period[%d][%d] definition.  Check space dimension\n",
; 81   :                    i+1,j+1);

	inc	esi
	push	esi
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_0DN@MOBBDHGA@Bad?5torus_period?$FL?$CFd?$FN?$FL?$CFd?$FN?5definit@
	push	OFFSET _errmsg
	call	_sprintf

; 82   :         kb_error(3903,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	3903					; 00000f3fH
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 88   : 
; 89   : } // end read_periods()

	mov	esp, ebp
	pop	ebp
	ret	0
_read_periods ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DP@EKANIKFM@Bad?5display_period?$FL?$CFd?$FN?$FL?$CFd?$FN?5defin@ ; `string'
PUBLIC	??_C@_0BI@BLGCINFB@display?5period?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$AA@ ; `string'
PUBLIC	_read_display_periods
EXTRN	_torus_display_period_expr:BYTE
;	COMDAT ??_C@_0DP@EKANIKFM@Bad?5display_period?$FL?$CFd?$FN?$FL?$CFd?$FN?5defin@
CONST	SEGMENT
??_C@_0DP@EKANIKFM@Bad?5display_period?$FL?$CFd?$FN?$FL?$CFd?$FN?5defin@ DB 'B'
	DB	'ad display_period[%d][%d] definition.  Check space dimension', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BLGCINFB@display?5period?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$AA@
CONST	SEGMENT
??_C@_0BI@BLGCINFB@display?5period?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$AA@ DB 'd'
	DB	'isplay period [%d][%d]', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _read_display_periods
_TEXT	SEGMENT
tv216 = -4						; size = 4
_read_display_periods PROC				; COMDAT

; 99   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi

; 100  :   int i,j;
; 101  : 
; 102  :   torus_display_period_init();

	call	_torus_display_period_init

; 103  : 
; 104  :   /* read in display periods */
; 105  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	xor	ebx, ebx
	test	eax, eax
	jle	SHORT $LN5@read_displ

; 100  :   int i,j;
; 101  : 
; 102  :   torus_display_period_init();

	mov	edi, OFFSET _torus_display_period_expr+20
	mov	DWORD PTR tv216[ebp], edi
	npad	1
$LL16@read_displ:

; 106  :     for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN6@read_displ
$LL15@read_displ:

; 107  :     { int esize;
; 108  :       esize = exparse(0,&torus_display_period_expr[i][j],USERCOPY);

	push	1
	lea	eax, DWORD PTR [edi-20]
	push	eax
	push	0
	call	_exparse
	add	esp, 12					; 0000000cH

; 109  :       if ( esize <= 0 )

	test	eax, eax
	jle	SHORT $LN12@read_displ

; 114  :         return;
; 115  :       }
; 116  :       sprintf(torus_display_period_expr[i][j].name,"display period [%d][%d]",i,j);

	push	esi
	push	ebx
	push	OFFSET ??_C@_0BI@BLGCINFB@display?5period?5?$FL?$CFd?$FN?$FL?$CFd?$FN?$AA@
	push	edi
	call	_sprintf
	mov	eax, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	add	edi, 104				; 00000068H
	cmp	esi, eax
	jl	SHORT $LL15@read_displ
$LN6@read_displ:

; 103  : 
; 104  :   /* read in display periods */
; 105  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR tv216[ebp]
	inc	ebx
	add	edi, 624				; 00000270H
	mov	DWORD PTR tv216[ebp], edi
	cmp	ebx, eax
	jl	SHORT $LL16@read_displ
$LN5@read_displ:

; 117  :     }
; 118  :   calc_periods(ADJUST_VOLUMES);

	push	1
	call	_calc_periods
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 119  : } // end read_display_periods()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@read_displ:

; 110  :       { sprintf(errmsg,
; 111  :             "Bad display_period[%d][%d] definition.  Check space dimension\n",
; 112  :                    i+1,j+1);

	inc	esi
	push	esi
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_0DP@EKANIKFM@Bad?5display_period?$FL?$CFd?$FN?$FL?$CFd?$FN?5defin@
	push	OFFSET _errmsg
	call	_sprintf

; 113  :         kb_error(1670,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1670					; 00000686H
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 119  : } // end read_display_periods()

	mov	esp, ebp
	pop	ebp
	ret	0
_read_display_periods ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EE@JFBLPNJP@Numbered?5surface?5energies?5are?5ob@ ; `string'
PUBLIC	_read_surface_energy
EXTRN	_tok:DWORD
EXTRN	_kb_yylex:PROC
;	COMDAT ??_C@_0EE@JFBLPNJP@Numbered?5surface?5energies?5are?5ob@
CONST	SEGMENT
??_C@_0EE@JFBLPNJP@Numbered?5surface?5energies?5are?5ob@ DB 'Numbered sur'
	DB	'face energies are obsolete. Please use named quantity.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _read_surface_energy
_TEXT	SEGMENT
_read_surface_energy PROC				; COMDAT

; 889  :   kb_error(1702,
; 890  :    "Numbered surface energies are obsolete. Please use named quantity.\n",
; 891  :       DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0EE@JFBLPNJP@Numbered?5surface?5energies?5are?5ob@
	push	1702					; 000006a6H
	call	_kb_error

; 892  :   tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tok, eax

; 893  : } // end read_surface_energy()

	ret	0
_read_surface_energy ENDP
_TEXT	ENDS
PUBLIC	_add_outside
; Function compile flags: /Ogtp
;	COMDAT _add_outside
_TEXT	SEGMENT
_add_outside PROC					; COMDAT

; 1384 : 
; 1385 : return; /* temporary turn off */
; 1386 : #ifdef OUTSIDEBODY     
; 1387 :     body_id b_id;    /* both models */
; 1388 : 
; 1389 : 
; 1390 :         b_id = new_body();
; 1391 :         web.outside_body = b_id;
; 1392 :         set_attr(b_id,PRESSURE); /* since has ambient pressure */
; 1393 : 
; 1394 :         if ( web.representation == STRING )
; 1395 :          { edge_id e_id;
; 1396 :             facet_id f_id;
; 1397 : 
; 1398 :             f_id = new_facet();    /* outside facet */
; 1399 :             set_facet_body(f_id,b_id);
; 1400 : 
; 1401 :             /* add to outside of every edge bordering just ONE cell */
; 1402 :             FOR_ALL_EDGES(e_id)
; 1403 :               {
; 1404 :                  facetedge_id new_fe;
; 1405 :                  facetedge_id fe_id;
; 1406 :                  
; 1407 :                  fe_id = get_edge_fe(e_id);
; 1408 :                  if ( !valid_id(fe_id) ) continue;
; 1409 :                  if ( !equal_id(fe_id,get_next_facet(fe_id)) ) continue;
; 1410 :                  new_fe = new_facetedge(inverse_id(f_id),e_id);
; 1411 :                  set_next_facet(fe_id,new_fe);
; 1412 :                  set_prev_facet(fe_id,new_fe);
; 1413 :                  set_next_facet(new_fe,fe_id);
; 1414 :                  set_prev_facet(new_fe,fe_id);
; 1415 :                  set_facet_fe(f_id,new_fe);
; 1416 : 
; 1417 :               }
; 1418 :          }
; 1419 :       else /* SOAPFILM */
; 1420 :          {
; 1421 :             facet_id f_id;
; 1422 : 
; 1423 :             /* add to outside of every facet bordering just ONE cell */
; 1424 :             FOR_ALL_FACETS(f_id)
; 1425 :               {
; 1426 :                  body_id b1_id,b2_id;
; 1427 : 
; 1428 :                  b1_id = get_facet_body(f_id);
; 1429 :                  b2_id = get_facet_body(inverse_id(f_id));
; 1430 :                  if ( valid_id(b1_id) == valid_id(b2_id) ) continue;
; 1431 : 
; 1432 :                  if ( valid_id(b1_id) )
; 1433 :                     set_facet_body(inverse_id(f_id),b_id);
; 1434 :                  if ( valid_id(b2_id) )
; 1435 :                     set_facet_body(f_id,b_id);
; 1436 :               }
; 1437 :         }
; 1438 : #endif
; 1439 : } // end  add_outside()

	ret	0
_add_outside ENDP
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	_fix_volconst
EXTRN	_set_body_volume:PROC
EXTRN	_floor:PROC
;	COMDAT __real@3fe0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\lexinit2.c
CONST	ENDS
;	COMDAT _fix_volconst
_TEXT	SEGMENT
tv268 = -24						; size = 8
_calcvol$90117 = -24					; size = 8
_adjust$ = -16						; size = 8
_newvc$90118 = -8					; size = 8
tv259 = -4						; size = 4
_fix_volconst PROC					; COMDAT

; 1451 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1452 :   REAL adjust;
; 1453 :   body_id b_id;
; 1454 : 
; 1455 :   if ( web.pressure_flag ) return;

	cmp	DWORD PTR _web+868, 0
	jne	$LN4@fix_volcon

; 1456 : 
; 1457 :   /* get volume of piece of unit cell */
; 1458 :   if ( SDIM == 2 )

	fld	QWORD PTR _web+1600
	push	edi

; 1459 :   {
; 1460 :      adjust = web.torusv  /* /2 */;
; 1461 :   }
; 1462 :   else /* web.representation == SOAPFILM */
; 1463 :   {
; 1464 :      adjust = web.torusv  /* /6 */;
; 1465 :   }
; 1466 : 
; 1467 :   /* adjust volconsts */
; 1468 :   FOR_ALL_BODIES(b_id)

	mov	edi, DWORD PTR _web+384
	fstp	QWORD PTR _adjust$[ebp]
	mov	eax, edi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv259[ebp], eax
	je	$LN28@fix_volcon
	fldz
	push	ebx
	push	esi
$LN26@fix_volcon:
	mov	eax, DWORD PTR _web+348
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv268[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN5@fix_volcon

; 1469 :     if ( get_battr(b_id) & FIXEDVOL )

	and	ecx, 32					; 00000020H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN5@fix_volcon

; 1470 :     { REAL vol = get_body_volume(b_id);

	cmp	DWORD PTR tv259[ebp], eax
	je	$LN14@fix_volcon
	fstp	ST(0)
	fld	QWORD PTR [edx+40]

; 1471 :       REAL fix = get_body_fixvol(b_id);

	fld	QWORD PTR [edx+32]

; 1472 :       REAL vc = get_body_volconst(b_id);

	fld	QWORD PTR [edx+328]
	fxch	ST(2)
	fxch	ST(1)
$LN23@fix_volcon:

; 1473 :       REAL calcvol = vol-vc;

	fxch	ST(1)

; 1474 :       REAL newvc = fix - calcvol;
; 1475 :       newvc = adjust*floor(0.5+newvc/adjust);

	sub	esp, 8
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _calcvol$90117[ebp]
	fsubp	ST(1), ST(0)
	fdiv	QWORD PTR _adjust$[ebp]
	fadd	QWORD PTR __real@3fe0000000000000
	fstp	QWORD PTR [esp]
	call	_floor
	fmul	QWORD PTR _adjust$[ebp]
	fst	QWORD PTR _newvc$90118[ebp]

; 1476 :       set_body_volconst(b_id,newvc);

	fstp	QWORD PTR [esp]
	push	edi
	call	_set_body_volconst

; 1477 :       set_body_volume(b_id,calcvol+newvc,SETSTAMP);

	fld	QWORD PTR _newvc$90118[ebp]
	fadd	QWORD PTR _calcvol$90117[ebp]
	add	esp, 12					; 0000000cH
	push	1
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	call	_set_body_volume
	fldz
	add	esp, 16					; 00000010H
$LN5@fix_volcon:

; 1459 :   {
; 1460 :      adjust = web.torusv  /* /2 */;
; 1461 :   }
; 1462 :   else /* web.representation == SOAPFILM */
; 1463 :   {
; 1464 :      adjust = web.torusv  /* /6 */;
; 1465 :   }
; 1466 : 
; 1467 :   /* adjust volconsts */
; 1468 :   FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [esi+ecx]
	mov	edi, DWORD PTR [edx]
	mov	eax, edi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv259[ebp], eax
	jne	$LN26@fix_volcon
	pop	esi
	fstp	ST(0)
	pop	ebx
$LN28@fix_volcon:
	pop	edi
$LN4@fix_volcon:

; 1478 :    }
; 1479 : } // end fix_volconst()

	mov	esp, ebp
	pop	ebp
	ret	0

; 1470 :     { REAL vol = get_body_volume(b_id);

$LN14@fix_volcon:
	fld	ST(0)

; 1471 :       REAL fix = get_body_fixvol(b_id);

	fld	ST(1)

; 1472 :       REAL vc = get_body_volconst(b_id);

	jmp	SHORT $LN23@fix_volcon
_fix_volconst ENDP
_TEXT	ENDS
PUBLIC	__real@401921fb54442d18
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@46293e5939a08cea
PUBLIC	??_C@_0DL@PDBOKNGE@Edge?5?$CFs?5facets?5body?5order?5disagr@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_0CO@JCMFDCON@More?5than?5100?5facets?5on?5an?5edge?$DL@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_fe_reorder
EXTRN	_elnames:BYTE
EXTRN	_dot:PROC
EXTRN	_cross_prod:PROC
EXTRN	_get_edge_side:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIatan2:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@401921fb54442d18
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@401921fb54442d18 DQ 0401921fb54442d18r	; 6.28319
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@46293e5939a08cea
CONST	SEGMENT
__real@46293e5939a08cea DQ 046293e5939a08cear	; 1e+030
CONST	ENDS
;	COMDAT ??_C@_0DL@PDBOKNGE@Edge?5?$CFs?5facets?5body?5order?5disagr@
CONST	SEGMENT
??_C@_0DL@PDBOKNGE@Edge?5?$CFs?5facets?5body?5order?5disagr@ DB 'Edge %s '
	DB	'facets body order disagrees with geometric order.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JCMFDCON@More?5than?5100?5facets?5on?5an?5edge?$DL@
CONST	SEGMENT
??_C@_0CO@JCMFDCON@More?5than?5100?5facets?5on?5an?5edge?$DL@ DB 'More th'
	DB	'an 100 facets on an edge; not sorted.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\lexinit2.c
CONST	ENDS
;	COMDAT _fe_reorder
_TEXT	SEGMENT
_ftemp$90238 = -1936					; size = 16
_tempfe$90215 = -1936					; size = 16
_ftemp$90226 = -1920					; size = 16
_a_norm$ = -1912					; size = 8
tv1553 = -1908						; size = 4
_bestk$90222 = -1904					; size = 4
tv201 = -1904						; size = 4
_ftemp$90194 = -1900					; size = 16
_aa_norm$ = -1892					; size = 8
tv2632 = -1888						; size = 4
tv1639 = -1888						; size = 4
$T92129 = -1888						; size = 4
_s$ = -1884						; size = 8
tv655 = -1880						; size = 4
_bodies_ok$ = -1880					; size = 4
_k$ = -1880						; size = 4
_i$ = -1880						; size = 4
_kk$90206 = -1876					; size = 4
_eb$90165 = -1876					; size = 4
tv2432 = -1872						; size = 4
_ef$90164 = -1872					; size = 4
_kkk$90210 = -1868					; size = 4
_af$90166 = -1868					; size = 4
tv2480 = -1864						; size = 4
tv1312 = -1864						; size = 4
tv1002 = -1864						; size = 4
tv2469 = -1860						; size = 4
tv1201 = -1860						; size = 4
tv628 = -1860						; size = 4
$T92176 = -1860						; size = 4
_bf$90168 = -1860					; size = 4
tv2440 = -1856						; size = 4
tv2292 = -1856						; size = 4
_k$90220 = -1856					; size = 4
_ab$90167 = -1856					; size = 4
_fcount$ = -1852					; size = 4
tv2515 = -1848						; size = 4
tv2465 = -1848						; size = 4
tv2422 = -1848						; size = 4
tv2361 = -1848						; size = 4
_body_order$ = -1848					; size = 4
_fe_list$ = -1844					; size = 1600
_side_a$ = -244						; size = 48
_side$ = -196						; size = 48
_side_b$ = -148						; size = 48
_norm_aa$ = -100					; size = 48
_norm_a$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_fe_reorder PROC					; COMDAT

; 1503 : { int fcount = 0;

	push	ebp
	mov	ebp, esp
	sub	esp, 1936				; 00000790H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1504 :   facetedge_id fe;
; 1505 : #define FSORTMAX 100
; 1506 :   struct fsort fe_list[FSORTMAX];
; 1507 :   REAL side[MAXCOORD],norm_a[MAXCOORD],side_a[MAXCOORD];
; 1508 :   REAL side_b[MAXCOORD],norm_aa[MAXCOORD],a_norm,aa_norm;
; 1509 :   REAL c,s,angle;
; 1510 :   int i,j,k;
; 1511 :   facetedge_id first_fe;
; 1512 :   int bodies_ok;
; 1513 :   int body_order = 0; /* set if order triple line by bodies */
; 1514 : 
; 1515 :   /* see if we have 3 or more facets */
; 1516 :   fe = first_fe = get_edge_fe(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	push	esi
	mov	esi, DWORD PTR _web+124
	xor	edx, edx
	mov	DWORD PTR tv1312[ebp], eax
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR _body_order$[ebp], edx
	cmp	eax, edx
	jne	SHORT $LN75@fe_reorder
	xor	eax, eax
	jmp	SHORT $LN74@fe_reorder
$LN75@fe_reorder:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN74@fe_reorder
	xor	eax, 134217728				; 08000000H
$LN74@fe_reorder:
	mov	esi, eax

; 1517 :   if ( valid_id(fe) ) 

	test	eax, 268435456				; 10000000H
	je	$LN1@fe_reorder
	mov	ecx, DWORD PTR _web+460
$LL54@fe_reorder:

; 1518 :   do { fcount++; 

	inc	edx

; 1519 :        fe = get_next_facet(fe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN79@fe_reorder
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [esi+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN53@fe_reorder
$LN79@fe_reorder:
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [esi+40]
$LN53@fe_reorder:

; 1520 :      } while ( valid_id(fe) && !equal_id(fe,first_fe) );

	test	esi, 268435456				; 10000000H
	je	SHORT $LN217@fe_reorder
	cmp	esi, eax
	jne	SHORT $LL54@fe_reorder
$LN217@fe_reorder:

; 1518 :   do { fcount++; 

	mov	DWORD PTR _fcount$[ebp], edx

; 1521 :   if ( fcount <= 2 ) return;

	cmp	edx, 2
	jle	$LN1@fe_reorder

; 1522 : 
; 1523 :   if ( fcount > FSORTMAX )

	cmp	edx, 100				; 00000064H
	jle	SHORT $LN49@fe_reorder

; 1524 :   { kb_error(1742,"More than 100 facets on an edge; not sorted.\n",WARNING); 

	push	2
	push	OFFSET ??_C@_0CO@JCMFDCON@More?5than?5100?5facets?5on?5an?5edge?$DL@
	push	1742					; 000006ceH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	esi

; 1697 :   }
; 1698 : } // end fe_reorder()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@fe_reorder:
	push	ebx
	push	edi

; 1525 :     return;
; 1526 :   }
; 1527 : 
; 1528 :   /* common case of three facets, check for body determination */
; 1529 :   if ( fcount == 3 )

	cmp	edx, 3
	jne	$LN45@fe_reorder

; 1530 :   { /* see if there is a unique order of facets */
; 1531 :     facetedge_id fa = get_next_facet(fe);

	push	esi
	call	_get_next_facet

; 1532 :     facetedge_id fb = get_prev_facet(fe);

	push	esi
	mov	edi, eax
	call	_get_prev_facet

; 1533 :     body_id ef = get_facet_body(get_fe_facet(fe));

	push	esi
	mov	ebx, eax
	call	_get_fe_facet
	push	eax
	call	_get_facet_body

; 1534 :     body_id eb = get_facet_body(inverse_id(get_fe_facet(fe)));

	push	esi
	mov	DWORD PTR _ef$90164[ebp], eax
	call	_get_fe_facet
	xor	eax, 134217728				; 08000000H
	push	eax
	call	_get_facet_body

; 1535 :     body_id af = get_facet_body(get_fe_facet(fa));

	push	edi
	mov	DWORD PTR _eb$90165[ebp], eax
	call	_get_fe_facet
	push	eax
	call	_get_facet_body

; 1536 :     body_id ab = get_facet_body(inverse_id(get_fe_facet(fa)));

	push	edi
	mov	DWORD PTR _af$90166[ebp], eax
	call	_get_fe_facet
	xor	eax, 134217728				; 08000000H
	push	eax
	call	_get_facet_body

; 1537 :     body_id bf = get_facet_body(get_fe_facet(fb));

	push	ebx
	mov	DWORD PTR _ab$90167[ebp], eax
	call	_get_fe_facet
	push	eax
	call	_get_facet_body

; 1538 :     body_id bb = get_facet_body(inverse_id(get_fe_facet(fb)));

	push	ebx
	mov	DWORD PTR _bf$90168[ebp], eax
	call	_get_fe_facet
	xor	eax, 134217728				; 08000000H
	push	eax
	call	_get_facet_body

; 1539 :     int asis  = (eb==af) && (ab==bf) && (bb==ef);

	mov	ecx, DWORD PTR _af$90166[ebp]
	add	esp, 56					; 00000038H
	cmp	DWORD PTR _eb$90165[ebp], ecx
	jne	SHORT $LN210@fe_reorder
	mov	edx, DWORD PTR _ab$90167[ebp]
	cmp	edx, DWORD PTR _bf$90168[ebp]
	jne	SHORT $LN210@fe_reorder
	cmp	eax, DWORD PTR _ef$90164[ebp]
	jne	SHORT $LN210@fe_reorder
	mov	ecx, 1
	jmp	SHORT $LN59@fe_reorder
$LN210@fe_reorder:
	xor	ecx, ecx
$LN59@fe_reorder:

; 1540 :     int other = (eb==bf) && (bb==af) && (ab==ef);

	mov	edx, DWORD PTR _bf$90168[ebp]
	cmp	DWORD PTR _eb$90165[ebp], edx
	jne	SHORT $LN60@fe_reorder
	cmp	eax, DWORD PTR _af$90166[ebp]
	jne	SHORT $LN60@fe_reorder
	mov	eax, DWORD PTR _ef$90164[ebp]
	cmp	DWORD PTR _ab$90167[ebp], eax
	jne	SHORT $LN60@fe_reorder
	mov	eax, 1
	jmp	SHORT $LN61@fe_reorder
$LN60@fe_reorder:
	xor	eax, eax
$LN61@fe_reorder:

; 1541 :     if ( asis && !other ) body_order = 1;

	test	ecx, ecx
	je	SHORT $LN47@fe_reorder
	test	eax, eax
	jne	SHORT $LN45@fe_reorder
	jmp	SHORT $LN287@fe_reorder
$LN47@fe_reorder:

; 1542 :     else if ( other && !asis )

	test	eax, eax
	je	SHORT $LN45@fe_reorder

; 1543 :     { /* swap */
; 1544 :       set_next_facet(fe,fb);

	push	ebx
	push	esi
	call	_set_next_facet

; 1545 :       set_next_facet(fb,fa);

	push	edi
	push	ebx
	call	_set_next_facet

; 1546 :       set_next_facet(fa,fe);

	push	esi
	push	edi
	call	_set_next_facet

; 1547 :       set_prev_facet(fe,fa);

	push	edi
	push	esi
	call	_set_prev_facet

; 1548 :       set_prev_facet(fa,fb);

	push	ebx
	push	edi
	call	_set_prev_facet

; 1549 :       set_prev_facet(fb,fe);

	push	esi
	push	ebx
	call	_set_prev_facet
	add	esp, 48					; 00000030H
$LN287@fe_reorder:

; 1550 :       body_order = 1;

	mov	DWORD PTR _body_order$[ebp], 1
$LN45@fe_reorder:

; 1551 :     }
; 1552 :     /* else fall through to geometric test */
; 1553 :   }
; 1554 : 
; 1555 :   /* use first facet as reference facet */
; 1556 :   /* to get basis for calculating angles */
; 1557 :   get_edge_side(e_id,side);     

	mov	esi, DWORD PTR _e_id$[ebp]
	lea	ecx, DWORD PTR _side$[ebp]
	push	ecx
	push	esi
	call	_get_edge_side

; 1558 :   fe = get_edge_fe(e_id);

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR tv1312[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN83@fe_reorder
	xor	esi, esi
	jmp	SHORT $LN84@fe_reorder
$LN83@fe_reorder:
	mov	eax, DWORD PTR [eax+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN82@fe_reorder
	xor	eax, 134217728				; 08000000H
$LN82@fe_reorder:
	mov	esi, eax
$LN84@fe_reorder:

; 1559 :   fe_list[0].fe = fe;
; 1560 :   get_fe_side(get_next_edge(fe),side_a);

	mov	ecx, DWORD PTR _web+460
	mov	ebx, esi
	mov	DWORD PTR _fe_list$[ebp], esi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	shr	ebx, 27					; 0000001bH
	add	esi, esi
	and	ebx, 1
	je	SHORT $LN87@fe_reorder
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN86@fe_reorder
$LN87@fe_reorder:
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+32]
$LN86@fe_reorder:
	lea	edx, DWORD PTR _side_a$[ebp]
	push	edx
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	push	eax
	call	_get_edge_side

; 1561 :   cross_prod(side,side_a,norm_a);

	lea	edx, DWORD PTR _norm_a$[ebp]
	push	edx
	lea	eax, DWORD PTR _side_a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _side$[ebp]
	push	ecx
	call	_cross_prod

; 1562 :   cross_prod(norm_a,side,norm_aa);

	lea	edx, DWORD PTR _norm_aa$[ebp]
	push	edx
	lea	eax, DWORD PTR _side$[ebp]
	push	eax
	lea	ecx, DWORD PTR _norm_a$[ebp]
	push	ecx
	call	_cross_prod

; 1563 :   a_norm = sqrt(SDIM_dot(norm_a,norm_a));

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _norm_a$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	add	esp, 44					; 0000002cH
	call	__CIsqrt
	fstp	QWORD PTR _a_norm$[ebp]

; 1564 :   aa_norm = sqrt(SDIM_dot(norm_aa,norm_aa));

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _norm_aa$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fstp	QWORD PTR _aa_norm$[ebp]

; 1565 : 
; 1566 :   /* now get angles to rest of facets */
; 1567 :   fe_list[0].angle = 0.0;
; 1568 :   for ( i = 1 ; i < fcount ; i++ )

	cmp	DWORD PTR _fcount$[ebp], 1
	fldz
	fld	ST(0)
	fst	QWORD PTR _fe_list$[ebp+8]
	jle	$LN42@fe_reorder
	mov	edx, DWORD PTR _fcount$[ebp]
	fstp	ST(1)
	dec	edx
	fstp	ST(0)
	lea	edi, DWORD PTR _fe_list$[ebp+24]
	mov	DWORD PTR tv1201[ebp], edx
	npad	8
$LL44@fe_reorder:

; 1569 :   { fe = get_next_facet(fe);

	mov	ecx, DWORD PTR _web+460
	test	ebx, ebx
	je	SHORT $LN93@fe_reorder
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN92@fe_reorder
$LN93@fe_reorder:
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+40]
$LN92@fe_reorder:

; 1570 :     fe_list[i].fe = fe;
; 1571 :     get_fe_side(get_next_edge(fe),side_b);

	mov	ebx, eax
	mov	DWORD PTR [edi-8], eax
	and	eax, 134217727				; 07ffffffH
	shr	ebx, 27					; 0000001bH
	add	eax, eax
	and	ebx, 1
	lea	esi, DWORD PTR [eax+eax]
	je	SHORT $LN97@fe_reorder
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN96@fe_reorder
$LN97@fe_reorder:
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+32]
$LN96@fe_reorder:
	lea	edx, DWORD PTR _side_b$[ebp]
	push	edx
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	push	eax
	call	_get_edge_side

; 1572 :     s = SDIM_dot(side_b,norm_a)*aa_norm;

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _norm_a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _side_b$[ebp]
	push	ecx
	call	_dot
	fmul	QWORD PTR _aa_norm$[ebp]

; 1573 :     c = SDIM_dot(side_b,norm_aa)*a_norm;

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _norm_aa$[ebp]
	fstp	QWORD PTR _s$[ebp]
	push	eax
	lea	ecx, DWORD PTR _side_b$[ebp]
	push	ecx
	call	_dot
	fmul	QWORD PTR _a_norm$[ebp]

; 1574 :     angle = atan2(s,c);

	fld	QWORD PTR _s$[ebp]
	add	esp, 32					; 00000020H
	fxch	ST(1)
	call	__CIatan2

; 1575 :     fe_list[i].angle = angle;

	fstp	QWORD PTR [edi]
	add	edi, 16					; 00000010H
	dec	DWORD PTR tv1201[ebp]
	jne	$LL44@fe_reorder

; 1565 : 
; 1566 :   /* now get angles to rest of facets */
; 1567 :   fe_list[0].angle = 0.0;
; 1568 :   for ( i = 1 ; i < fcount ; i++ )

	fldz
	fld	QWORD PTR _fe_list$[ebp+8]
$LN42@fe_reorder:

; 1576 :   }
; 1577 :   if ( body_order )

	cmp	DWORD PTR _body_order$[ebp], 0
	je	$LN224@fe_reorder

; 1578 :   { /* warn if not agreeing with geometric order */
; 1579 :     if ( ((fe_list[1].angle > 0) && (fe_list[2].angle > fe_list[0].angle) && 
; 1580 :            (fe_list[2].angle < fe_list[1].angle))  ||
; 1581 :       (( (fe_list[1].angle < 0) && ((fe_list[2].angle > fe_list[0].angle) || 
; 1582 :            (fe_list[2].angle < fe_list[1].angle)))   )
; 1583 :       )

	fld	QWORD PTR _fe_list$[ebp+24]
	fcom	ST(2)
	fnstsw	ax
	fld	QWORD PTR _fe_list$[ebp+40]
	test	ah, 65					; 00000041H
	jne	SHORT $LN38@fe_reorder
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN38@fe_reorder
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN231@fe_reorder
$LN38@fe_reorder:
	fxch	ST(3)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN233@fe_reorder
	fxch	ST(1)
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN236@fe_reorder
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN218@fe_reorder
	jmp	SHORT $LN37@fe_reorder
$LN231@fe_reorder:
	fstp	ST(1)
	fstp	ST(0)
	fstp	ST(1)
	jmp	SHORT $LN288@fe_reorder
$LN236@fe_reorder:
	fstp	ST(0)
$LN288@fe_reorder:
	fstp	ST(0)
$LN37@fe_reorder:

; 1584 :     { sprintf(errmsg,
; 1585 :          "Edge %s facets body order disagrees with geometric order.\n",
; 1586 :             ELNAME(e_id));

	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN62@fe_reorder
	mov	edx, DWORD PTR tv1312[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN63@fe_reorder
$LN62@fe_reorder:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN63@fe_reorder:
	push	eax
	push	OFFSET ??_C@_0DL@PDBOKNGE@Edge?5?$CFs?5facets?5body?5order?5disagr@
	push	OFFSET _errmsg
	call	_sprintf

; 1587 :       kb_error(3857,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	3857					; 00000f11H
	call	_kb_error
	add	esp, 24					; 00000018H
	pop	edi
	pop	ebx
	pop	esi

; 1697 :   }
; 1698 : } // end fe_reorder()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN224@fe_reorder:

; 1588 :     } 
; 1589 :     return;
; 1590 :   }
; 1591 : 
; 1592 :   /* sort by angle */
; 1593 : /* Bombed in IRIX 6 long double mode
; 1594 :   qsort((char *)&fe_list[1],fcount-1,sizeof(struct fsort),FCAST fcompare);
; 1595 : */
; 1596 :   for ( j = 0 ; j < fcount-1 ; j++ )

	mov	ebx, DWORD PTR _fcount$[ebp]
	fstp	ST(1)
	lea	eax, DWORD PTR [ebx-1]
	fstp	ST(0)
	test	eax, eax
	jle	$LN34@fe_reorder
	mov	edi, 1
	mov	DWORD PTR tv2292[ebp], edi
	lea	ecx, DWORD PTR _fe_list$[ebp]
	mov	DWORD PTR tv2361[ebp], eax
	mov	DWORD PTR tv628[ebp], eax
	npad	1
$LL36@fe_reorder:

; 1597 :     for ( k = j+1 ; k < fcount ; k++ )

	mov	eax, edi
	cmp	edi, ebx
	jge	$LN35@fe_reorder
	cmp	DWORD PTR tv2361[ebp], 4
	jl	$LC195@fe_reorder

; 1598 :        if ( fe_list[k].angle < fe_list[j].angle )

	mov	esi, ebx
	sub	esi, edi
	sub	esi, 4
	shr	esi, 2
	inc	esi
	lea	eax, DWORD PTR [edi+esi*4]
	lea	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _k$[ebp], eax
	npad	2
$LL200@fe_reorder:
	fld	QWORD PTR [ecx+8]
	fcomp	QWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN196@fe_reorder

; 1599 :        { struct fsort ftemp;
; 1600 :          ftemp = fe_list[k];

	mov	ebx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx]
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR _ftemp$90194[ebp+8], ebx
	mov	ebx, DWORD PTR [edx+12]
	mov	DWORD PTR _ftemp$90194[ebp+12], ebx

; 1601 :          fe_list[k] = fe_list[j];

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ebx

; 1602 :          fe_list[j] = ftemp;

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _ftemp$90194[ebp+8]
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _ftemp$90194[ebp+12]
	mov	DWORD PTR [ecx+12], eax
$LN196@fe_reorder:

; 1598 :        if ( fe_list[k].angle < fe_list[j].angle )

	fld	QWORD PTR [ecx+8]
	fcomp	QWORD PTR [edx+24]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN197@fe_reorder

; 1599 :        { struct fsort ftemp;
; 1600 :          ftemp = fe_list[k];

	mov	ebx, DWORD PTR [edx+24]
	mov	eax, DWORD PTR [edx+16]
	mov	edi, DWORD PTR [edx+20]
	mov	DWORD PTR _ftemp$90194[ebp+8], ebx
	mov	ebx, DWORD PTR [edx+28]
	mov	DWORD PTR _ftemp$90194[ebp+12], ebx

; 1601 :          fe_list[k] = fe_list[j];

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+16], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+20], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+24], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+28], ebx

; 1602 :          fe_list[j] = ftemp;

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _ftemp$90194[ebp+8]
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _ftemp$90194[ebp+12]
	mov	DWORD PTR [ecx+12], eax
$LN197@fe_reorder:

; 1598 :        if ( fe_list[k].angle < fe_list[j].angle )

	fld	QWORD PTR [ecx+8]
	fcomp	QWORD PTR [edx+40]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN198@fe_reorder

; 1599 :        { struct fsort ftemp;
; 1600 :          ftemp = fe_list[k];

	mov	ebx, DWORD PTR [edx+40]
	mov	eax, DWORD PTR [edx+32]
	mov	edi, DWORD PTR [edx+36]
	mov	DWORD PTR _ftemp$90194[ebp+8], ebx
	mov	ebx, DWORD PTR [edx+44]
	mov	DWORD PTR _ftemp$90194[ebp+12], ebx

; 1601 :          fe_list[k] = fe_list[j];

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+32], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+36], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+40], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+44], ebx

; 1602 :          fe_list[j] = ftemp;

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _ftemp$90194[ebp+8]
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _ftemp$90194[ebp+12]
	mov	DWORD PTR [ecx+12], eax
$LN198@fe_reorder:

; 1598 :        if ( fe_list[k].angle < fe_list[j].angle )

	fld	QWORD PTR [ecx+8]
	fcomp	QWORD PTR [edx+56]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN199@fe_reorder

; 1599 :        { struct fsort ftemp;
; 1600 :          ftemp = fe_list[k];

	mov	ebx, DWORD PTR [edx+56]
	mov	eax, DWORD PTR [edx+48]
	mov	edi, DWORD PTR [edx+52]
	mov	DWORD PTR _ftemp$90194[ebp+8], ebx
	mov	ebx, DWORD PTR [edx+60]
	mov	DWORD PTR _ftemp$90194[ebp+12], ebx

; 1601 :          fe_list[k] = fe_list[j];

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+48], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+52], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+56], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+60], ebx

; 1602 :          fe_list[j] = ftemp;

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _ftemp$90194[ebp+8]
	mov	DWORD PTR [ecx+4], edi
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _ftemp$90194[ebp+12]
	mov	DWORD PTR [ecx+12], eax
$LN199@fe_reorder:

; 1598 :        if ( fe_list[k].angle < fe_list[j].angle )

	add	edx, 64					; 00000040H
	dec	esi
	jne	$LL200@fe_reorder
	mov	eax, DWORD PTR _k$[ebp]
	mov	edi, DWORD PTR tv2292[ebp]
	mov	ebx, DWORD PTR _fcount$[ebp]
$LC195@fe_reorder:

; 1597 :     for ( k = j+1 ; k < fcount ; k++ )

	cmp	eax, ebx
	jge	SHORT $LN35@fe_reorder
	mov	edx, eax
	add	edx, edx
	sub	ebx, eax
	lea	edx, DWORD PTR _fe_list$[ebp+edx*8]
	mov	DWORD PTR tv1002[ebp], ebx
	npad	3
$LC33@fe_reorder:

; 1598 :        if ( fe_list[k].angle < fe_list[j].angle )

	fld	QWORD PTR [ecx+8]
	fcomp	QWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN32@fe_reorder

; 1599 :        { struct fsort ftemp;
; 1600 :          ftemp = fe_list[k];

	mov	ebx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx+8]
	mov	DWORD PTR _ftemp$90194[ebp+12], ebx

; 1601 :          fe_list[k] = fe_list[j];

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ebx

; 1602 :          fe_list[j] = ftemp;

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _ftemp$90194[ebp+12]
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], eax
$LN32@fe_reorder:

; 1597 :     for ( k = j+1 ; k < fcount ; k++ )

	add	edx, 16					; 00000010H
	dec	DWORD PTR tv1002[ebp]
	jne	SHORT $LC33@fe_reorder
	mov	edi, DWORD PTR tv2292[ebp]
	mov	ebx, DWORD PTR _fcount$[ebp]
$LN35@fe_reorder:

; 1588 :     } 
; 1589 :     return;
; 1590 :   }
; 1591 : 
; 1592 :   /* sort by angle */
; 1593 : /* Bombed in IRIX 6 long double mode
; 1594 :   qsort((char *)&fe_list[1],fcount-1,sizeof(struct fsort),FCAST fcompare);
; 1595 : */
; 1596 :   for ( j = 0 ; j < fcount-1 ; j++ )

	mov	eax, 1
	sub	DWORD PTR tv2361[ebp], eax
	add	edi, eax
	add	ecx, 16					; 00000010H
	sub	DWORD PTR tv628[ebp], eax
	mov	DWORD PTR tv2292[ebp], edi
	jne	$LL36@fe_reorder
$LN34@fe_reorder:

; 1603 :        } 
; 1604 : 
; 1605 :   /* check consistency for facets on bodies */
; 1606 :   bodies_ok = 1;
; 1607 :   for ( i = 0 ; i < fcount ; i++ )

	xor	esi, esi
	test	ebx, ebx
	jle	$LN4@fe_reorder
	mov	edi, DWORD PTR _web+328
	mov	ebx, DWORD PTR _web+236
	lea	ecx, DWORD PTR _fe_list$[ebp]
	mov	DWORD PTR tv2422[ebp], ecx
$LL214@fe_reorder:

; 1608 :   { facet_id f1,f2;
; 1609 :     int ii = (i == fcount-1) ? 0 : i+1;

	mov	eax, DWORD PTR _fcount$[ebp]
	dec	eax
	cmp	esi, eax
	jne	SHORT $LN64@fe_reorder
	xor	edx, edx
	jmp	SHORT $LN65@fe_reorder
$LN64@fe_reorder:
	lea	edx, DWORD PTR [esi+1]
$LN65@fe_reorder:

; 1610 :     f1 = facet_inverse(get_fe_facet(fe_list[i].fe));

	mov	eax, DWORD PTR tv2422[ebp]
	mov	ecx, DWORD PTR [eax]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN103@fe_reorder
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN104@fe_reorder
$LN103@fe_reorder:
	mov	ebx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [eax+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN102@fe_reorder
	xor	eax, 134217728				; 08000000H
$LN102@fe_reorder:
	mov	ebx, DWORD PTR _web+236
$LN104@fe_reorder:

; 1611 :     f2 = get_fe_facet(fe_list[ii].fe);

	add	edx, edx
	mov	edx, DWORD PTR _fe_list$[ebp+edx*8]
	xor	eax, 134217728				; 08000000H
	test	edx, 268435456				; 10000000H
	jne	SHORT $LN107@fe_reorder
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN108@fe_reorder
$LN107@fe_reorder:
	mov	ebx, DWORD PTR _web+460
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN106@fe_reorder
	xor	ecx, 134217728				; 08000000H
$LN106@fe_reorder:
	mov	ebx, DWORD PTR _web+236
$LN108@fe_reorder:

; 1612 :     if ( !equal_id(get_facet_body(f1),get_facet_body(f2)) )

	cmp	DWORD PTR _web+400, 0
	je	$LN204@fe_reorder
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN112@fe_reorder
	xor	edx, edx
	jmp	SHORT $LN119@fe_reorder
$LN112@fe_reorder:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN111@fe_reorder
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edi+eax+784]
	mov	edx, DWORD PTR [edx+eax+4]
	jmp	SHORT $LN119@fe_reorder
$LN111@fe_reorder:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edi+eax+784]
	mov	edx, DWORD PTR [edx+eax]
$LN119@fe_reorder:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN118@fe_reorder
	xor	eax, eax
	jmp	SHORT $LN116@fe_reorder
$LN118@fe_reorder:
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edi+eax+784]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN117@fe_reorder
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	eax, DWORD PTR [ecx+eax+4]
	jmp	SHORT $LN116@fe_reorder
$LN117@fe_reorder:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN116@fe_reorder:
	cmp	edx, eax
	jne	SHORT $LN182@fe_reorder
$LN204@fe_reorder:

; 1603 :        } 
; 1604 : 
; 1605 :   /* check consistency for facets on bodies */
; 1606 :   bodies_ok = 1;
; 1607 :   for ( i = 0 ; i < fcount ; i++ )

	add	DWORD PTR tv2422[ebp], 16		; 00000010H
	inc	esi
	cmp	esi, DWORD PTR _fcount$[ebp]
	jl	$LL214@fe_reorder

; 1666 :         if ( !equal_id(get_facet_body(f1),get_facet_body(f2)) )

	jmp	$LN4@fe_reorder
$LN182@fe_reorder:

; 1613 :     { bodies_ok = 0;
; 1614 :       break;
; 1615 :     }
; 1616 :   }
; 1617 : 
; 1618 :   if ( !bodies_ok )
; 1619 :   { // see if body matching forces order
; 1620 :     bodies_ok = 1;

	mov	eax, DWORD PTR _fcount$[ebp]
	mov	edx, 1
	mov	ecx, edx
	sub	ecx, eax
	mov	DWORD PTR tv2465[ebp], ecx
	lea	ecx, DWORD PTR _fe_list$[ebp]
	mov	DWORD PTR _bodies_ok$[ebp], edx
	mov	DWORD PTR tv2440[ebp], edx
	mov	DWORD PTR tv2469[ebp], ecx
	mov	DWORD PTR tv201[ebp], eax
	mov	esi, edx
	jmp	SHORT $LN24@fe_reorder
$LL215@fe_reorder:
	mov	eax, DWORD PTR _fcount$[ebp]
$LN24@fe_reorder:

; 1622 :     { int kk;
; 1623 :       for ( kk = k+1 ; kk < fcount+k ; kk++ )

	dec	eax
	add	eax, esi
	mov	DWORD PTR _kk$90206[ebp], esi
	mov	DWORD PTR tv2480[ebp], eax
	cmp	esi, eax
	jge	$LN19@fe_reorder

; 1625 :         body_id kbod,kkbod;
; 1626 :         kbod = get_facet_body(inverse_id(get_fe_facet(fe_list[k].fe)));

	mov	eax, DWORD PTR tv2469[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv2465[ebp]
	mov	DWORD PTR $T92129[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, edx
	mov	DWORD PTR tv1553[ebp], eax
	mov	DWORD PTR tv2432[ebp], ecx
$LL21@fe_reorder:

; 1624 :       { int kkk = (kk >= fcount) ? kk-fcount : kk;

	cmp	esi, DWORD PTR _fcount$[ebp]
	jl	SHORT $LN66@fe_reorder
	mov	edx, DWORD PTR tv2432[ebp]
	mov	DWORD PTR _kkk$90210[ebp], edx
	jmp	SHORT $LN67@fe_reorder
$LN66@fe_reorder:
	mov	DWORD PTR _kkk$90210[ebp], esi
$LN67@fe_reorder:

; 1625 :         body_id kbod,kkbod;
; 1626 :         kbod = get_facet_body(inverse_id(get_fe_facet(fe_list[k].fe)));

	cmp	DWORD PTR tv1553[ebp], 0
	jne	SHORT $LN123@fe_reorder
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN122@fe_reorder
$LN123@fe_reorder:
	mov	ecx, DWORD PTR $T92129[ebp]
	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN122@fe_reorder
	xor	eax, 134217728				; 08000000H
$LN122@fe_reorder:
	xor	eax, 134217728				; 08000000H
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN128@fe_reorder
	xor	edx, edx
	jmp	SHORT $LN126@fe_reorder
$LN128@fe_reorder:
	mov	edx, DWORD PTR _dymem
	test	eax, 134217728				; 08000000H
	je	SHORT $LN127@fe_reorder
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [edi+edx+784]
	mov	edx, DWORD PTR [ecx+eax+4]
	jmp	SHORT $LN126@fe_reorder
$LN127@fe_reorder:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [edi+edx+784]
	mov	edx, DWORD PTR [ecx+eax]
$LN126@fe_reorder:

; 1627 :         kkbod = get_facet_body(get_fe_facet(fe_list[kkk].fe));

	mov	ecx, DWORD PTR _kkk$90210[ebp]
	add	ecx, ecx
	mov	ecx, DWORD PTR _fe_list$[ebp+ecx*8]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN133@fe_reorder
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN134@fe_reorder
$LN133@fe_reorder:
	mov	esi, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN132@fe_reorder
	xor	eax, 134217728				; 08000000H
$LN132@fe_reorder:
	mov	esi, DWORD PTR _kk$90206[ebp]
$LN134@fe_reorder:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN138@fe_reorder
	xor	eax, eax
	jmp	SHORT $LN136@fe_reorder
$LN138@fe_reorder:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN137@fe_reorder
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edi+eax+784]
	mov	eax, DWORD PTR [ecx+eax+4]
	jmp	SHORT $LN136@fe_reorder
$LN137@fe_reorder:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edi+eax+784]
	mov	eax, DWORD PTR [ecx+eax]
$LN136@fe_reorder:

; 1628 :         if ( kbod == kkbod )

	cmp	edx, eax
	je	SHORT $LN183@fe_reorder

; 1622 :     { int kk;
; 1623 :       for ( kk = k+1 ; kk < fcount+k ; kk++ )

	inc	DWORD PTR tv2432[ebp]
	inc	esi
	mov	DWORD PTR _kk$90206[ebp], esi
	cmp	esi, DWORD PTR tv2480[ebp]
	jl	$LL21@fe_reorder

; 1666 :         if ( !equal_id(get_facet_body(f1),get_facet_body(f2)) )

	jmp	$LN19@fe_reorder
$LN183@fe_reorder:

; 1629 :         { int kkkk;
; 1630 :           struct fsort tempfe;
; 1631 :           if ( kk == k+1 )

	cmp	esi, DWORD PTR tv2440[ebp]
	je	$LN19@fe_reorder

; 1632 :             break;
; 1633 :           // swap 
; 1634 :           kkkk = (k+1 >= fcount) ? k+1-fcount : k+1;

	mov	eax, DWORD PTR tv2440[ebp]
	cmp	eax, DWORD PTR _fcount$[ebp]
	jl	SHORT $LN68@fe_reorder
	mov	eax, DWORD PTR tv2465[ebp]
$LN68@fe_reorder:

; 1635 :           tempfe = fe_list[kkkk];

	add	eax, eax
	mov	ecx, DWORD PTR _fe_list$[ebp+eax*8+12]
	mov	edx, DWORD PTR _fe_list$[ebp+eax*8]
	mov	esi, DWORD PTR _fe_list$[ebp+eax*8+4]
	mov	edi, DWORD PTR _fe_list$[ebp+eax*8+8]
	lea	eax, DWORD PTR _fe_list$[ebp+eax*8]
	mov	DWORD PTR _tempfe$90215[ebp+12], ecx

; 1636 :           fe_list[kkkk] = fe_list[kkk];

	mov	ecx, DWORD PTR _kkk$90210[ebp]
	add	ecx, ecx
	mov	ebx, DWORD PTR _fe_list$[ebp+ecx*8]
	lea	ecx, DWORD PTR _fe_list$[ebp+ecx*8]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebx

; 1637 :           fe_list[kkk] = tempfe;

	mov	ebx, DWORD PTR _web+236
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR _tempfe$90215[ebp+12]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR _kk$90206[ebp]
	mov	DWORD PTR [ecx+8], edi
	mov	edi, DWORD PTR _web+328
	mov	DWORD PTR [ecx+12], edx
$LN19@fe_reorder:

; 1638 :           break;
; 1639 :         }
; 1640 :       }
; 1641 :       if ( kk == fcount+k )

	cmp	esi, DWORD PTR tv2480[ebp]
	jne	SHORT $LN23@fe_reorder

; 1642 :         bodies_ok = 0;

	mov	DWORD PTR _bodies_ok$[ebp], 0
$LN23@fe_reorder:

; 1621 :     for ( k = 0 ; k < fcount ; k++ )

	mov	esi, DWORD PTR tv2440[ebp]
	add	DWORD PTR tv2469[ebp], 16		; 00000010H
	mov	edx, 1
	add	DWORD PTR tv2465[ebp], edx
	add	esi, edx
	sub	DWORD PTR tv201[ebp], edx
	mov	DWORD PTR tv2440[ebp], esi
	jne	$LL215@fe_reorder

; 1643 :     }
; 1644 :   }
; 1645 : 
; 1646 :   if ( !bodies_ok )

	cmp	DWORD PTR _bodies_ok$[ebp], 0
	jne	$LN4@fe_reorder

; 1647 :   { REAL best_violation;
; 1648 :     int k,kk,bestk;
; 1649 :     /* try swaps of adjacent facets, and pick workable one with
; 1650 :        least violation of angle ordering */
; 1651 :     best_violation = 1e30;

	fld	QWORD PTR __real@46293e5939a08cea

; 1652 :     bestk = -1;

	mov	DWORD PTR _bestk$90222[ebp], -1
	fld	QWORD PTR __real@400921fb54442d18

; 1653 :     for ( k = 0 ; k < fcount ; k++ )

	mov	DWORD PTR _k$90220[ebp], 0
	fld	QWORD PTR __real@401921fb54442d18
	lea	ecx, DWORD PTR _fe_list$[ebp]
$LN14@fe_reorder:

; 1654 :     { struct fsort ftemp;
; 1655 :       kk = (k==fcount-1) ? 0 : k+1;

	mov	edx, DWORD PTR _fcount$[ebp]
	mov	eax, DWORD PTR _k$90220[ebp]
	dec	edx
	cmp	eax, edx
	jne	SHORT $LN70@fe_reorder
	xor	eax, eax
	jmp	SHORT $LN71@fe_reorder
$LN70@fe_reorder:
	inc	eax
$LN71@fe_reorder:

; 1656 :       ftemp = fe_list[k];

	mov	edx, DWORD PTR [ecx+12]
	mov	esi, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [ecx+8]

; 1657 :       fe_list[k] = fe_list[kk];

	shl	eax, 4
	mov	DWORD PTR tv1639[ebp], eax
	mov	DWORD PTR _ftemp$90226[ebp+12], edx
	lea	edx, DWORD PTR _fe_list$[ebp+eax]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax

; 1658 :       fe_list[kk] = ftemp;

	mov	eax, DWORD PTR _ftemp$90226[ebp+12]
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	mov	DWORD PTR [edx+8], ebx
	mov	DWORD PTR [edx+12], eax

; 1659 :  
; 1660 :       bodies_ok = 1;
; 1661 :       for ( i = 0 ; i < fcount-1 ; i++ )

	mov	eax, DWORD PTR _fcount$[ebp]
	dec	eax
	mov	DWORD PTR _i$[ebp], 0
	test	eax, eax
	jle	$LN207@fe_reorder

; 1656 :       ftemp = fe_list[k];

	mov	ebx, DWORD PTR _web+328
	lea	eax, DWORD PTR _fe_list$[ebp+16]
	mov	DWORD PTR tv2515[ebp], eax
$LN208@fe_reorder:

; 1662 :       { facet_id f1,f2;
; 1663 : 
; 1664 :         f1 = facet_inverse(get_fe_facet(fe_list[i].fe));

	mov	eax, DWORD PTR tv2515[ebp]
	mov	esi, DWORD PTR [eax-16]
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN143@fe_reorder
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN142@fe_reorder
$LN143@fe_reorder:
	mov	edi, DWORD PTR _web+460
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN142@fe_reorder
	xor	eax, 134217728				; 08000000H
$LN142@fe_reorder:

; 1665 :         f2 = get_fe_facet(fe_list[i+1].fe);

	mov	esi, DWORD PTR tv2515[ebp]
	mov	edi, DWORD PTR [esi]
	xor	eax, 134217728				; 08000000H
	test	edi, 268435456				; 10000000H
	jne	SHORT $LN147@fe_reorder
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN148@fe_reorder
$LN147@fe_reorder:
	mov	ebx, DWORD PTR _web+460
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	esi, DWORD PTR [esi+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN146@fe_reorder
	xor	esi, 134217728				; 08000000H
$LN146@fe_reorder:
	mov	ebx, DWORD PTR _web+328
$LN148@fe_reorder:

; 1666 :         if ( !equal_id(get_facet_body(f1),get_facet_body(f2)) )

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN152@fe_reorder
	mov	eax, DWORD PTR _dymem
	mov	DWORD PTR $T92176[ebp], 0
	jmp	SHORT $LN150@fe_reorder
$LN152@fe_reorder:
	mov	edi, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN151@fe_reorder
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ebx+eax+784]
	mov	edi, DWORD PTR [edi+ebx+4]
	jmp	SHORT $LN289@fe_reorder
$LN151@fe_reorder:
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ebx+eax+784]
	mov	edi, DWORD PTR [edi+ebx]
$LN289@fe_reorder:
	mov	ebx, DWORD PTR _web+328
	mov	DWORD PTR $T92176[ebp], edi
$LN150@fe_reorder:
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN158@fe_reorder
	xor	eax, eax
	jmp	SHORT $LN156@fe_reorder
$LN158@fe_reorder:
	mov	edi, DWORD PTR _web+236
	mov	eax, DWORD PTR [ebx+eax+784]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN157@fe_reorder
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [esi+eax+4]
	jmp	SHORT $LN156@fe_reorder
$LN157@fe_reorder:
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [esi+eax]
$LN156@fe_reorder:
	cmp	DWORD PTR $T92176[ebp], eax
	jne	SHORT $LN5@fe_reorder

; 1659 :  
; 1660 :       bodies_ok = 1;
; 1661 :       for ( i = 0 ; i < fcount-1 ; i++ )

	mov	esi, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _fcount$[ebp]
	add	DWORD PTR tv2515[ebp], 16		; 00000010H
	inc	esi
	dec	eax
	mov	DWORD PTR _i$[ebp], esi
	cmp	esi, eax
	jl	$LN208@fe_reorder
$LN207@fe_reorder:

; 1667 :         { bodies_ok = 0;
; 1668 :           break;
; 1669 :         }
; 1670 :       }
; 1671 :       if ( bodies_ok )
; 1672 :       { REAL violation = fabs(fe_list[k].angle-fe_list[kk].angle);

	mov	eax, DWORD PTR tv1639[ebp]
	fld	QWORD PTR [ecx+8]
	fsub	QWORD PTR _fe_list$[ebp+eax+8]
	fabs

; 1673 :         if ( violation > M_PI ) 

	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN6@fe_reorder

; 1674 :            violation = 2*M_PI - violation;  /* shortest way */

	fsubr	ST(0), ST(1)
$LN6@fe_reorder:

; 1675 :         if ( violation < best_violation )

	fcom	ST(3)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN285@fe_reorder

; 1676 :         { bestk = k;

	mov	eax, DWORD PTR _k$90220[ebp]
	fstp	ST(3)
	mov	DWORD PTR _bestk$90222[ebp], eax

; 1677 :           best_violation = violation;

	jmp	SHORT $LN5@fe_reorder
$LN285@fe_reorder:

; 1675 :         if ( violation < best_violation )

	fstp	ST(0)
$LN5@fe_reorder:

; 1678 :         }
; 1679 :       }
; 1680 :       ftemp = fe_list[kk];

	mov	ebx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx+8]
	mov	DWORD PTR _ftemp$90226[ebp+12], ebx

; 1681 :       fe_list[kk] = fe_list[k];

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ebx

; 1682 :       fe_list[k] = ftemp;

	mov	edx, DWORD PTR _ftemp$90226[ebp+12]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _k$90220[ebp]
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	inc	eax
	mov	DWORD PTR [ecx+12], edx
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _k$90220[ebp], eax
	cmp	eax, DWORD PTR _fcount$[ebp]
	jl	$LN14@fe_reorder

; 1683 :     }
; 1684 :     if ( bestk >= 0 )

	mov	eax, DWORD PTR _bestk$90222[ebp]
	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(0)
	test	eax, eax
	js	$LN4@fe_reorder

; 1685 :     { struct fsort ftemp;
; 1686 :       kk = (bestk==fcount-1) ? 0 : bestk+1;

	mov	ecx, DWORD PTR _fcount$[ebp]
	dec	ecx
	cmp	eax, ecx
	jne	SHORT $LN72@fe_reorder
	xor	ecx, ecx
	jmp	SHORT $LN73@fe_reorder
$LN72@fe_reorder:
	lea	ecx, DWORD PTR [eax+1]
$LN73@fe_reorder:

; 1687 :       ftemp = fe_list[bestk];

	add	eax, eax
	mov	ebx, DWORD PTR _fe_list$[ebp+eax*8+12]
	mov	edx, DWORD PTR _fe_list$[ebp+eax*8]
	mov	esi, DWORD PTR _fe_list$[ebp+eax*8+4]
	mov	edi, DWORD PTR _fe_list$[ebp+eax*8+8]
	lea	eax, DWORD PTR _fe_list$[ebp+eax*8]
	mov	DWORD PTR _ftemp$90238[ebp+12], ebx

; 1688 :       fe_list[bestk] = fe_list[kk];

	add	ecx, ecx
	mov	ebx, DWORD PTR _fe_list$[ebp+ecx*8]
	lea	ecx, DWORD PTR _fe_list$[ebp+ecx*8]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebx

; 1689 :       fe_list[kk] = ftemp;

	mov	eax, DWORD PTR _ftemp$90238[ebp+12]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], eax
$LN4@fe_reorder:

; 1690 :     }
; 1691 :   }
; 1692 : 
; 1693 :   /* relink in proper order */
; 1694 :   for ( i = 0 ; i < fcount ; i++ )

	mov	ecx, DWORD PTR _fcount$[ebp]
	test	ecx, ecx
	jle	$LN218@fe_reorder
	mov	edi, DWORD PTR _web+460
	mov	eax, 2
	sub	eax, ecx
	lea	esi, DWORD PTR [ecx-1]
	lea	ebx, DWORD PTR _fe_list$[ebp]
	mov	DWORD PTR tv2632[ebp], eax
	mov	DWORD PTR tv655[ebp], ecx
	jmp	SHORT $LN3@fe_reorder
	npad	9
$LL212@fe_reorder:
	mov	ecx, DWORD PTR _fcount$[ebp]
$LN3@fe_reorder:

; 1695 :   { set_next_facet(fe_list[i].fe,fe_list[(i+1)%fcount].fe);

	mov	eax, DWORD PTR tv2632[ebp]
	lea	eax, DWORD PTR [eax+esi]
	cdq
	idiv	ecx
	mov	ecx, DWORD PTR [ebx]
	add	edx, edx
	mov	eax, DWORD PTR _fe_list$[ebp+edx*8]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN162@fe_reorder
	mov	edx, ecx
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN163@fe_reorder
	xor	eax, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [edx+36], eax
	jmp	SHORT $LN290@fe_reorder
$LN163@fe_reorder:
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [edx+40], eax
$LN290@fe_reorder:
	mov	edi, DWORD PTR _web+460
$LN162@fe_reorder:

; 1696 :     set_prev_facet(fe_list[i].fe,fe_list[(i+fcount-1)%fcount].fe);

	mov	eax, esi
	cdq
	idiv	DWORD PTR _fcount$[ebp]
	add	edx, edx
	mov	eax, DWORD PTR _fe_list$[ebp+edx*8]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN2@fe_reorder
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN168@fe_reorder
	xor	eax, 134217728				; 08000000H
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR [ecx+40], eax
	jmp	SHORT $LN167@fe_reorder
$LN168@fe_reorder:
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR [edx+36], eax
$LN167@fe_reorder:
	mov	eax, DWORD PTR _global_timestamp
	mov	edi, DWORD PTR _web+460
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN2@fe_reorder:

; 1690 :     }
; 1691 :   }
; 1692 : 
; 1693 :   /* relink in proper order */
; 1694 :   for ( i = 0 ; i < fcount ; i++ )

	inc	esi
	add	ebx, 16					; 00000010H
	dec	DWORD PTR tv655[ebp]
	jne	$LL212@fe_reorder
	pop	edi
	pop	ebx
	pop	esi

; 1697 :   }
; 1698 : } // end fe_reorder()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN233@fe_reorder:

; 1578 :   { /* warn if not agreeing with geometric order */
; 1579 :     if ( ((fe_list[1].angle > 0) && (fe_list[2].angle > fe_list[0].angle) && 
; 1580 :            (fe_list[2].angle < fe_list[1].angle))  ||
; 1581 :       (( (fe_list[1].angle < 0) && ((fe_list[2].angle > fe_list[0].angle) || 
; 1582 :            (fe_list[2].angle < fe_list[1].angle)))   )
; 1583 :       )

	fstp	ST(0)
	fstp	ST(1)
	fstp	ST(0)
$LN218@fe_reorder:
	pop	edi
	pop	ebx
$LN1@fe_reorder:

; 1697 :   }
; 1698 : } // end fe_reorder()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fe_reorder ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_raw_fe_reorder
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT _raw_fe_reorder
_TEXT	SEGMENT
_s$ = -1892						; size = 8
tv1278 = -1888						; size = 4
_aa_norm$ = -1884					; size = 8
tv1425 = -1880						; size = 4
tv1186 = -1880						; size = 4
_a_norm$ = -1876					; size = 8
tv1402 = -1872						; size = 4
tv219 = -1872						; size = 4
_k$ = -1872						; size = 4
_ftemp$90281 = -1868					; size = 16
_fcount$ = -1852					; size = 4
tv1394 = -1848						; size = 4
tv1177 = -1848						; size = 4
tv212 = -1848						; size = 4
_fe_list$ = -1844					; size = 1600
_side_a$ = -244						; size = 48
_side_b$ = -196						; size = 48
_side$ = -148						; size = 48
_norm_aa$ = -100					; size = 48
_norm_a$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_raw_fe_reorder PROC					; COMDAT

; 1710 : { int fcount = 0;

	push	ebp
	mov	ebp, esp
	sub	esp, 1892				; 00000764H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1711 :   facetedge_id fe;
; 1712 :   struct fsort fe_list[FSORTMAX];
; 1713 :   REAL side[MAXCOORD],norm_a[MAXCOORD],side_a[MAXCOORD];
; 1714 :   REAL side_b[MAXCOORD],norm_aa[MAXCOORD],a_norm,aa_norm;
; 1715 :   REAL c,s,angle;
; 1716 :   int i,j,k;
; 1717 :   facetedge_id first_fe;
; 1718 : 
; 1719 :   memset(norm_a,0,sizeof(norm_a));

	push	48					; 00000030H
	xor	edi, edi
	lea	eax, DWORD PTR _norm_a$[ebp]
	push	edi
	push	eax
	call	_memset

; 1720 :   memset(norm_aa,0,sizeof(norm_aa));

	push	48					; 00000030H
	lea	ecx, DWORD PTR _norm_aa$[ebp]
	push	edi
	push	ecx
	call	_memset

; 1721 : 
; 1722 :   /* see if we have 3 or more facets */
; 1723 :   fe = first_fe = get_edge_fe(e_id);

	mov	ebx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN24@raw_fe_reo
	xor	edx, edx
	jmp	SHORT $LN25@raw_fe_reo
$LN24@raw_fe_reo:
	mov	eax, DWORD PTR [eax+28]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN23@raw_fe_reo
	xor	eax, 134217728				; 08000000H
$LN23@raw_fe_reo:
	mov	edx, eax
$LN25@raw_fe_reo:
	mov	eax, edx

; 1724 :   if ( valid_id(fe) ) 

	test	edx, 268435456				; 10000000H
	je	$LN1@raw_fe_reo
	mov	ecx, DWORD PTR _web+460
	npad	7
$LL19@raw_fe_reo:

; 1725 :   do { fcount++; 

	inc	edi

; 1726 :        fe = get_next_facet(fe);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN28@raw_fe_reo
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN18@raw_fe_reo
$LN28@raw_fe_reo:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+40]
$LN18@raw_fe_reo:

; 1727 :      } while ( valid_id(fe) && !equal_id(fe,first_fe) );

	test	eax, 268435456				; 10000000H
	je	SHORT $LN79@raw_fe_reo
	cmp	eax, edx
	jne	SHORT $LL19@raw_fe_reo
$LN79@raw_fe_reo:

; 1725 :   do { fcount++; 

	mov	DWORD PTR _fcount$[ebp], edi

; 1728 :   if ( fcount <= 2 ) return;

	cmp	edi, 2
	jle	$LN1@raw_fe_reo

; 1729 : 
; 1730 :   if ( fcount > FSORTMAX )

	cmp	edi, 100				; 00000064H
	jle	SHORT $LN14@raw_fe_reo

; 1731 :   { kb_error(5742,"More than 100 facets on an edge; not sorted.\n",WARNING); 

	push	2
	push	OFFSET ??_C@_0CO@JCMFDCON@More?5than?5100?5facets?5on?5an?5edge?$DL@
	push	5742					; 0000166eH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 1772 :   }
; 1773 : } // end raw_fe_reorder()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@raw_fe_reo:

; 1732 :     return;
; 1733 :   }
; 1734 : 
; 1735 :   /* use first facet as reference facet */
; 1736 :   /* to get basis for calculating angles */
; 1737 :   get_edge_side(e_id,side);     

	lea	ecx, DWORD PTR _side$[ebp]
	push	ecx
	push	ebx
	call	_get_edge_side

; 1738 :   fe = get_edge_fe(e_id);

	mov	edx, DWORD PTR _web+124
	mov	esi, DWORD PTR [esi+edx]
	add	esp, 8
	test	esi, esi
	je	SHORT $LN31@raw_fe_reo
$LN32@raw_fe_reo:
	mov	esi, DWORD PTR [esi+28]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN31@raw_fe_reo
	xor	esi, 134217728				; 08000000H
$LN31@raw_fe_reo:

; 1739 :   fe_list[0].fe = fe;
; 1740 :   get_fe_side(get_next_edge(fe),side_a);

	mov	ecx, DWORD PTR _web+460
	mov	ebx, esi
	mov	DWORD PTR _fe_list$[ebp], esi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	shr	ebx, 27					; 0000001bH
	add	esi, esi
	and	ebx, 1
	je	SHORT $LN36@raw_fe_reo
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN35@raw_fe_reo
$LN36@raw_fe_reo:
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+32]
$LN35@raw_fe_reo:
	lea	edx, DWORD PTR _side_a$[ebp]
	push	edx
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	push	eax
	call	_get_edge_side

; 1741 :   cross_prod(side,side_a,norm_a);

	lea	edx, DWORD PTR _norm_a$[ebp]
	push	edx
	lea	eax, DWORD PTR _side_a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _side$[ebp]
	push	ecx
	call	_cross_prod

; 1742 :   cross_prod(norm_a,side,norm_aa);

	lea	edx, DWORD PTR _norm_aa$[ebp]
	push	edx
	lea	eax, DWORD PTR _side$[ebp]
	push	eax
	lea	ecx, DWORD PTR _norm_a$[ebp]
	push	ecx
	call	_cross_prod

; 1743 :   a_norm = sqrt(SDIM_dot(norm_a,norm_a));

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _norm_a$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	add	esp, 44					; 0000002cH
	call	__CIsqrt
	fstp	QWORD PTR _a_norm$[ebp]

; 1744 :   aa_norm = sqrt(SDIM_dot(norm_aa,norm_aa));

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _norm_aa$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fstp	QWORD PTR _aa_norm$[ebp]

; 1745 : 
; 1746 :   /* now get angles to rest of facets */
; 1747 :   fe_list[0].angle = 0.0;

	fldz
	fstp	QWORD PTR _fe_list$[ebp+8]

; 1748 :   for ( i = 1 ; i < fcount ; i++ )

	cmp	edi, 1
	jle	$LN11@raw_fe_reo

; 1739 :   fe_list[0].fe = fe;
; 1740 :   get_fe_side(get_next_edge(fe),side_a);

	mov	edx, DWORD PTR _fcount$[ebp]
	dec	edx
	lea	edi, DWORD PTR _fe_list$[ebp+24]
	mov	DWORD PTR tv212[ebp], edx
	npad	5
$LL13@raw_fe_reo:

; 1749 :   { fe = get_next_facet(fe);

	mov	ecx, DWORD PTR _web+460
	test	ebx, ebx
	je	SHORT $LN42@raw_fe_reo
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN41@raw_fe_reo
$LN42@raw_fe_reo:
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+40]
$LN41@raw_fe_reo:

; 1750 :     fe_list[i].fe = fe;
; 1751 :     get_fe_side(get_next_edge(fe),side_b);

	mov	ebx, eax
	mov	DWORD PTR [edi-8], eax
	and	eax, 134217727				; 07ffffffH
	shr	ebx, 27					; 0000001bH
	add	eax, eax
	and	ebx, 1
	lea	esi, DWORD PTR [eax+eax]
	je	SHORT $LN46@raw_fe_reo
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN45@raw_fe_reo
$LN46@raw_fe_reo:
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+32]
$LN45@raw_fe_reo:
	lea	edx, DWORD PTR _side_b$[ebp]
	push	edx
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	push	eax
	call	_get_edge_side

; 1752 :     s = SDIM_dot(side_b,norm_a)*aa_norm;

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _norm_a$[ebp]
	push	eax
	lea	ecx, DWORD PTR _side_b$[ebp]
	push	ecx
	call	_dot
	fmul	QWORD PTR _aa_norm$[ebp]

; 1753 :     c = SDIM_dot(side_b,norm_aa)*a_norm;

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _norm_aa$[ebp]
	fstp	QWORD PTR _s$[ebp]
	push	eax
	lea	ecx, DWORD PTR _side_b$[ebp]
	push	ecx
	call	_dot
	fmul	QWORD PTR _a_norm$[ebp]

; 1754 :     angle = atan2(s,c);

	fld	QWORD PTR _s$[ebp]
	add	esp, 32					; 00000020H
	fxch	ST(1)
	call	__CIatan2

; 1755 :     fe_list[i].angle = angle;

	fstp	QWORD PTR [edi]
	add	edi, 16					; 00000010H
	dec	DWORD PTR tv212[ebp]
	jne	$LL13@raw_fe_reo

; 1748 :   for ( i = 1 ; i < fcount ; i++ )

	mov	edi, DWORD PTR _fcount$[ebp]
$LN11@raw_fe_reo:

; 1756 :   }
; 1757 : 
; 1758 :   /* sort by angle */
; 1759 :   for ( j = 0 ; j < fcount-1 ; j++ )

	lea	eax, DWORD PTR [edi-1]
	test	eax, eax
	jle	$LN8@raw_fe_reo
	mov	ebx, 1
	mov	DWORD PTR tv1177[ebp], ebx
	lea	ecx, DWORD PTR _fe_list$[ebp]
	mov	DWORD PTR tv1278[ebp], eax
	mov	DWORD PTR tv1186[ebp], eax
$LL10@raw_fe_reo:

; 1760 :     for ( k = j+1 ; k < fcount ; k++ )

	mov	esi, ebx
	cmp	ebx, edi
	jge	$LN9@raw_fe_reo
	cmp	DWORD PTR tv1278[ebp], 4
	jl	$LC71@raw_fe_reo

; 1761 :        if ( fe_list[k].angle < fe_list[j].angle )

	mov	esi, edi
	sub	esi, ebx
	sub	esi, 4
	shr	esi, 2
	inc	esi
	lea	eax, DWORD PTR [ebx+esi*4]
	lea	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _k$[ebp], eax
$LL76@raw_fe_reo:
	fld	QWORD PTR [ecx+8]
	fcomp	QWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN72@raw_fe_reo

; 1762 :        { struct fsort ftemp;
; 1763 :          ftemp = fe_list[k];

	mov	ebx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx]
	mov	edi, DWORD PTR [edx+4]
	mov	DWORD PTR _ftemp$90281[ebp+8], ebx
	mov	ebx, DWORD PTR [edx+12]
	mov	DWORD PTR _ftemp$90281[ebp+12], ebx

; 1764 :          fe_list[k] = fe_list[j];

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ebx

; 1765 :          fe_list[j] = ftemp;

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _ftemp$90281[ebp+8]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR _fcount$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _ftemp$90281[ebp+12]
	mov	DWORD PTR [ecx+12], eax
$LN72@raw_fe_reo:

; 1761 :        if ( fe_list[k].angle < fe_list[j].angle )

	fld	QWORD PTR [ecx+8]
	fcomp	QWORD PTR [edx+24]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN73@raw_fe_reo

; 1762 :        { struct fsort ftemp;
; 1763 :          ftemp = fe_list[k];

	mov	ebx, DWORD PTR [edx+24]
	mov	eax, DWORD PTR [edx+16]
	mov	edi, DWORD PTR [edx+20]
	mov	DWORD PTR _ftemp$90281[ebp+8], ebx
	mov	ebx, DWORD PTR [edx+28]
	mov	DWORD PTR _ftemp$90281[ebp+12], ebx

; 1764 :          fe_list[k] = fe_list[j];

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+16], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+20], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+24], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+28], ebx

; 1765 :          fe_list[j] = ftemp;

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _ftemp$90281[ebp+8]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR _fcount$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _ftemp$90281[ebp+12]
	mov	DWORD PTR [ecx+12], eax
$LN73@raw_fe_reo:

; 1761 :        if ( fe_list[k].angle < fe_list[j].angle )

	fld	QWORD PTR [ecx+8]
	fcomp	QWORD PTR [edx+40]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN74@raw_fe_reo

; 1762 :        { struct fsort ftemp;
; 1763 :          ftemp = fe_list[k];

	mov	ebx, DWORD PTR [edx+40]
	mov	eax, DWORD PTR [edx+32]
	mov	edi, DWORD PTR [edx+36]
	mov	DWORD PTR _ftemp$90281[ebp+8], ebx
	mov	ebx, DWORD PTR [edx+44]
	mov	DWORD PTR _ftemp$90281[ebp+12], ebx

; 1764 :          fe_list[k] = fe_list[j];

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+32], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+36], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+40], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+44], ebx

; 1765 :          fe_list[j] = ftemp;

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _ftemp$90281[ebp+8]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR _fcount$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _ftemp$90281[ebp+12]
	mov	DWORD PTR [ecx+12], eax
$LN74@raw_fe_reo:

; 1761 :        if ( fe_list[k].angle < fe_list[j].angle )

	fld	QWORD PTR [ecx+8]
	fcomp	QWORD PTR [edx+56]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN75@raw_fe_reo

; 1762 :        { struct fsort ftemp;
; 1763 :          ftemp = fe_list[k];

	mov	ebx, DWORD PTR [edx+56]
	mov	eax, DWORD PTR [edx+48]
	mov	edi, DWORD PTR [edx+52]
	mov	DWORD PTR _ftemp$90281[ebp+8], ebx
	mov	ebx, DWORD PTR [edx+60]
	mov	DWORD PTR _ftemp$90281[ebp+12], ebx

; 1764 :          fe_list[k] = fe_list[j];

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+48], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+52], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+56], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+60], ebx

; 1765 :          fe_list[j] = ftemp;

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _ftemp$90281[ebp+8]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR _fcount$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _ftemp$90281[ebp+12]
	mov	DWORD PTR [ecx+12], eax
$LN75@raw_fe_reo:

; 1761 :        if ( fe_list[k].angle < fe_list[j].angle )

	add	edx, 64					; 00000040H
	dec	esi
	jne	$LL76@raw_fe_reo
	mov	ebx, DWORD PTR tv1177[ebp]
	mov	esi, DWORD PTR _k$[ebp]
$LC71@raw_fe_reo:

; 1760 :     for ( k = j+1 ; k < fcount ; k++ )

	cmp	esi, edi
	jge	SHORT $LN9@raw_fe_reo
	mov	edx, esi
	add	edx, edx
	mov	eax, edi
	sub	eax, esi
	lea	edx, DWORD PTR _fe_list$[ebp+edx*8]
	mov	DWORD PTR tv219[ebp], eax
$LC7@raw_fe_reo:

; 1761 :        if ( fe_list[k].angle < fe_list[j].angle )

	fld	QWORD PTR [ecx+8]
	fcomp	QWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN6@raw_fe_reo

; 1762 :        { struct fsort ftemp;
; 1763 :          ftemp = fe_list[k];

	mov	ebx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR [edx]
	mov	edi, DWORD PTR [edx+8]
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR _ftemp$90281[ebp+12], ebx

; 1764 :          fe_list[k] = fe_list[j];

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ebx
	mov	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ebx

; 1765 :          fe_list[j] = ftemp;

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _ftemp$90281[ebp+12]
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	mov	edi, DWORD PTR _fcount$[ebp]
	mov	DWORD PTR [ecx+12], eax
$LN6@raw_fe_reo:

; 1760 :     for ( k = j+1 ; k < fcount ; k++ )

	add	edx, 16					; 00000010H
	dec	DWORD PTR tv219[ebp]
	jne	SHORT $LC7@raw_fe_reo
	mov	ebx, DWORD PTR tv1177[ebp]
$LN9@raw_fe_reo:

; 1756 :   }
; 1757 : 
; 1758 :   /* sort by angle */
; 1759 :   for ( j = 0 ; j < fcount-1 ; j++ )

	mov	eax, 1
	sub	DWORD PTR tv1278[ebp], eax
	add	ebx, eax
	add	ecx, 16					; 00000010H
	sub	DWORD PTR tv1186[ebp], eax
	mov	DWORD PTR tv1177[ebp], ebx
	jne	$LL10@raw_fe_reo
$LN8@raw_fe_reo:

; 1766 :        } 
; 1767 : 
; 1768 :   /* relink in proper order */
; 1769 :   for ( i = 0 ; i < fcount ; i++ )

	test	edi, edi
	jle	$LN1@raw_fe_reo
	mov	eax, 2
	lea	ecx, DWORD PTR _fe_list$[ebp]
	sub	eax, edi
	lea	esi, DWORD PTR [edi-1]
	mov	DWORD PTR tv1394[ebp], ecx
	mov	DWORD PTR tv1402[ebp], eax
	mov	DWORD PTR tv1425[ebp], edi
	jmp	SHORT $LN3@raw_fe_reo
	npad	1
$LL78@raw_fe_reo:
	mov	eax, DWORD PTR tv1402[ebp]
$LN3@raw_fe_reo:

; 1770 :   { set_next_facet(fe_list[i].fe,fe_list[(i+1)%fcount].fe);

	add	eax, esi
	cdq
	idiv	edi
	add	edx, edx
	mov	eax, DWORD PTR _fe_list$[ebp+edx*8]
	mov	edx, DWORD PTR tv1394[ebp]
	mov	ecx, DWORD PTR [edx]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN51@raw_fe_reo
	mov	ebx, DWORD PTR _web+460
	mov	edx, ecx
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN52@raw_fe_reo
	xor	eax, 134217728				; 08000000H
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [edx+36], eax
	jmp	SHORT $LN51@raw_fe_reo
$LN52@raw_fe_reo:
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [edx+40], eax
$LN51@raw_fe_reo:

; 1771 :     set_prev_facet(fe_list[i].fe,fe_list[(i+fcount-1)%fcount].fe);

	mov	eax, esi
	cdq
	idiv	edi
	add	edx, edx
	mov	eax, DWORD PTR _fe_list$[ebp+edx*8]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN2@raw_fe_reo
	mov	edx, DWORD PTR _web+460
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN57@raw_fe_reo
	xor	eax, 134217728				; 08000000H
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+40], eax
	jmp	SHORT $LN56@raw_fe_reo
$LN57@raw_fe_reo:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+36], eax
$LN56@raw_fe_reo:
	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN2@raw_fe_reo:

; 1766 :        } 
; 1767 : 
; 1768 :   /* relink in proper order */
; 1769 :   for ( i = 0 ; i < fcount ; i++ )

	add	DWORD PTR tv1394[ebp], 16		; 00000010H
	inc	esi
	dec	DWORD PTR tv1425[ebp]
	jne	$LL78@raw_fe_reo
$LN1@raw_fe_reo:

; 1772 :   }
; 1773 : } // end raw_fe_reorder()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_raw_fe_reorder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@NBIIFMGB@Unexpected?5minus?5sign?4?6?$AA@ ; `string'
PUBLIC	_gettok
EXTRN	_yylval:BYTE
;	COMDAT ??_C@_0BI@NBIIFMGB@Unexpected?5minus?5sign?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@NBIIFMGB@Unexpected?5minus?5sign?4?6?$AA@ DB 'Unexpected minus '
	DB	'sign.', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _gettok
_TEXT	SEGMENT
_sign$ = -4						; size = 4
_kind$ = 8						; size = 4
_gettok	PROC						; COMDAT

; 1785 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 1786 :   int sign = 1; 

	mov	esi, 1

; 1787 : 
; 1788 :   tok = yylex();

	push	0
	mov	DWORD PTR _sign$[ebp], esi
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1789 :   if ( tok == ',' ) tok = yylex(); /* skip separating comma */

	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN8@gettok
	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN8@gettok:

; 1790 :   if ( tok == '-' ) { sign = -1; tok = yylex(); }

	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN7@gettok
	or	esi, -1
	push	0
	mov	DWORD PTR _sign$[ebp], esi
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN7@gettok:

; 1791 :   if ( tok == UMINUS_TOK ) { sign = -1; tok = yylex(); }

	cmp	eax, 287				; 0000011fH
	jne	SHORT $LN6@gettok
	or	esi, -1
	push	0
	mov	DWORD PTR _sign$[ebp], esi
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN6@gettok:

; 1792 :   if ( tok != kind )

	mov	ecx, DWORD PTR _kind$[ebp]
	cmp	eax, ecx
	je	SHORT $LN4@gettok

; 1793 :   { if ( !((tok == INTEGER_TOK) && (kind == REAL_TOK) ) &&
; 1794 :          !((tok == INTEGER_AT_TOK) && (kind == INTEGER_TOK)) )

	cmp	eax, 265				; 00000109H
	jne	SHORT $LN3@gettok
	cmp	ecx, 266				; 0000010aH
	jmp	SHORT $LN11@gettok
$LN3@gettok:
	cmp	eax, 550				; 00000226H
	jne	SHORT $LN2@gettok
	cmp	ecx, 265				; 00000109H
$LN11@gettok:
	je	SHORT $LN4@gettok
$LN2@gettok:

; 1795 :     { if ( sign == -1 ) 

	cmp	esi, -1
	jne	SHORT $LN9@gettok

; 1796 :           kb_error(2129,"Unexpected minus sign.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BI@NBIIFMGB@Unexpected?5minus?5sign?4?6?$AA@
	push	2129					; 00000851H
	call	_kb_error
	mov	eax, DWORD PTR _tok
	add	esp, 12					; 0000000cH
	pop	esi

; 1806 : } // end gettok()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@gettok:

; 1797 :       return tok;
; 1798 :     }
; 1799 :     /* caller should check for error, and if error leave tok as lookahead */
; 1800 :   }
; 1801 : 
; 1802 :   yylval.i *= sign;

	mov	eax, DWORD PTR _yylval

; 1803 :   yylval.r *= sign;

	fild	DWORD PTR _sign$[ebp]
	imul	eax, esi
	fmul	QWORD PTR _yylval+16
	fstp	QWORD PTR _yylval+16
	mov	DWORD PTR _yylval, eax

; 1804 :   tok = kind;

	mov	DWORD PTR _tok, ecx

; 1805 :   return tok;

	mov	eax, ecx
$LN9@gettok:
	pop	esi

; 1806 : } // end gettok()

	mov	esp, ebp
	pop	ebp
	ret	0
_gettok	ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_read_const
EXTRN	_myfree:PROC
EXTRN	_eval:PROC
EXTRN	_const_expr_flag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _read_const
_TEXT	SEGMENT
_node$ = -108						; size = 104
__$ArrayPad$ = -4					; size = 4
_value$ = 8						; size = 4
_read_const PROC					; COMDAT

; 1824 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, DWORD PTR _value$[ebp]

; 1825 :   int retval;
; 1826 :   struct expnode node;  /* for getting constant expression */
; 1827 : 
; 1828 :   memset(&node,0,sizeof(struct expnode));

	push	104					; 00000068H
	lea	eax, DWORD PTR _node$[ebp]
	push	0
	push	eax
	call	_memset

; 1829 :   const_expr_flag = 1;
; 1830 :   if ( (retval = exparse(0,&node,NOUSERCOPY)) <= 0 )

	push	0
	lea	ecx, DWORD PTR _node$[ebp]
	push	ecx
	push	0
	mov	DWORD PTR _const_expr_flag, 1
	call	_exparse
	add	esp, 24					; 00000018H
	test	eax, eax

; 1831 :   { const_expr_flag = 0;
; 1832 :     return retval;

	jle	SHORT $LN6@read_const

; 1833 :   }
; 1834 :   /* sprintf(node.name,"constant expression at line %d",line_no); */
; 1835 :   *value = eval(&node,NULL,NULLID,NULL);

	push	0
	push	0
	lea	edx, DWORD PTR _node$[ebp]
	push	0
	push	edx
	call	_eval
	fstp	QWORD PTR [esi]

; 1836 :   if ( node.locals ) 

	mov	ecx, DWORD PTR _node$[ebp+8]
	add	esp, 16					; 00000010H
	test	ecx, ecx
	je	SHORT $LN2@read_const

; 1837 :   { if ( node.locals->list ) myfree((char*)node.locals->list );

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN1@read_const
	push	eax
	call	_myfree
	mov	ecx, DWORD PTR _node$[ebp+8]
	add	esp, 4
$LN1@read_const:

; 1838 :     myfree((char*)(node.locals));

	push	ecx
	call	_myfree
	add	esp, 4
$LN2@read_const:

; 1839 :   }
; 1840 :   const_expr_flag = 0;
; 1841 :   return 1;

	mov	eax, 1
$LN6@read_const:

; 1842 : } // end read_const()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	mov	DWORD PTR _const_expr_flag, 0
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_read_const ENDP
_TEXT	ENDS
PUBLIC	_const_expr
EXTRN	_yylex_init:PROC
EXTRN	_cmdptr:DWORD
; Function compile flags: /Ogtp
;	COMDAT _const_expr
_TEXT	SEGMENT
_str$ = 8						; size = 4
_value$ = 12						; size = 4
_const_expr PROC					; COMDAT

; 1862 : { char *old_cmdptr;  /* in case in middle of another parse */

	push	ebp
	mov	ebp, esp

; 1863 :   int ret;    /* return value */
; 1864 : 
; 1865 :   if ( str == NULL ) return 0;

	mov	eax, DWORD PTR _str$[ebp]
	test	eax, eax
	jne	SHORT $LN1@const_expr

; 1871 :   return ret;
; 1872 : } // end const_expr()

	pop	ebp
	ret	0
$LN1@const_expr:
	push	esi

; 1866 :   old_cmdptr = cmdptr;

	mov	esi, DWORD PTR _cmdptr

; 1867 :   cmdptr = str;

	mov	DWORD PTR _cmdptr, eax

; 1868 :   yylex_init();

	call	_yylex_init

; 1869 :   ret = read_const(value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	_read_const
	add	esp, 4

; 1870 :   cmdptr = old_cmdptr;

	mov	DWORD PTR _cmdptr, esi
	pop	esi

; 1871 :   return ret;
; 1872 : } // end const_expr()

	pop	ebp
	ret	0
_const_expr ENDP
_TEXT	ENDS
PUBLIC	_string_fixup
EXTRN	_new_facetedge:PROC
; Function compile flags: /Ogtp
;	COMDAT _string_fixup
_TEXT	SEGMENT
tv310 = -8						; size = 4
_e_id$ = -4						; size = 4
_string_fixup PROC					; COMDAT

; 1885 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 1886 :   edge_id e_id;
; 1887 :   facetedge_id fe;
; 1888 : 
; 1889 :   /* do all bare edges */
; 1890 :   FOR_ALL_EDGES(e_id)

	mov	esi, DWORD PTR _web+160
	mov	DWORD PTR _e_id$[ebp], esi
	test	esi, 268435456				; 10000000H
	je	$LN4@string_fix
	push	ebx
	mov	ebx, DWORD PTR _web+124
	push	edi
	jmp	SHORT $LN6@string_fix
	npad	10
$LL28@string_fix:
	mov	esi, DWORD PTR _e_id$[ebp]
$LN6@string_fix:
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+ebx]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN5@string_fix

; 1891 :     {
; 1892 :       fe = get_edge_fe(e_id);

	test	ecx, ecx
	je	SHORT $LN9@string_fix
$LN10@string_fix:
	mov	ecx, DWORD PTR [ecx+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN9@string_fix
	xor	ecx, 134217728				; 08000000H
$LN9@string_fix:

; 1893 :       if ( valid_id(fe) ) continue;

	test	ecx, 268435456				; 10000000H
	jne	$LN5@string_fix

; 1894 : 
; 1895 :       fe = new_facetedge(NULLFACET,e_id);

	mov	eax, DWORD PTR _NULLFACET
	push	esi
	push	eax
	call	_new_facetedge
	mov	esi, eax

; 1896 :       set_next_facet(fe,fe);

	shr	eax, 28					; 0000001cH
	add	esp, 8
	and	eax, 1
	mov	DWORD PTR tv310[ebp], eax
	je	SHORT $LN13@string_fix
	test	esi, 134217728				; 08000000H
	je	SHORT $LN14@string_fix
	mov	edx, DWORD PTR _web+460
	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+36], eax
	jmp	SHORT $LN13@string_fix
$LN14@string_fix:
	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+40], esi
$LN13@string_fix:

; 1897 :       set_prev_facet(fe,fe);

	push	esi
	push	esi
	call	_set_prev_facet

; 1898 :       set_next_edge(fe,inverse_id(fe));

	mov	ebx, esi
	add	esp, 8
	xor	ebx, 134217728				; 08000000H
	cmp	DWORD PTR tv310[ebp], 0
	je	SHORT $LN18@string_fix
	test	esi, 134217728				; 08000000H
	je	SHORT $LN19@string_fix
	mov	ecx, DWORD PTR _web+460
	mov	edx, ebx
	xor	edx, 134217728				; 08000000H
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [eax+28], edx
	jmp	SHORT $LN18@string_fix
$LN19@string_fix:
	mov	edx, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+32], ebx
$LN18@string_fix:

; 1899 :       set_prev_edge(fe,inverse_id(fe));

	push	ebx
	push	esi
	call	_set_prev_edge
	add	esp, 8

; 1900 :       set_edge_fe(e_id,fe);

	test	DWORD PTR _e_id$[ebp], 134217728	; 08000000H
	je	SHORT $LN23@string_fix
	mov	esi, ebx
$LN23@string_fix:
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [edi+ecx]
	mov	DWORD PTR [edx+28], esi
	mov	eax, DWORD PTR _global_timestamp
	mov	ebx, DWORD PTR _web+124
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN5@string_fix:

; 1886 :   edge_id e_id;
; 1887 :   facetedge_id fe;
; 1888 : 
; 1889 :   /* do all bare edges */
; 1890 :   FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR [edi+ebx]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _e_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL28@string_fix
	pop	edi
	pop	ebx
$LN4@string_fix:
	pop	esi

; 1901 : 
; 1902 :     }
; 1903 : } // end string_fixup()

	mov	esp, ebp
	pop	ebp
	ret	0
_string_fixup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@FALCJKPP@Bad?5phase?5numbers?3?5?$CFd?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_09GHFPDIPJ@?$CFd?5?$CFd?5?$CFlf?$AA@	; `string'
PUBLIC	??_C@_0CM@EGFEIDCM@Cannot?5open?5phase?5boundary?5energ@ ; `string'
PUBLIC	??_C@_05CBPKLGJM@phase?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_phase_initialize
EXTRN	_fclose:PROC
EXTRN	_sscanf:PROC
EXTRN	_fgets:PROC
EXTRN	_phase_data:DWORD
EXTRN	_fscanf:PROC
EXTRN	_phasemax:DWORD
EXTRN	_path_open:PROC
EXTRN	_strncpy:PROC
EXTRN	_phase_file_name:BYTE
EXTRN	_B_PHASE_ATTR:DWORD
EXTRN	_F_PHASE_ATTR:DWORD
EXTRN	_add_attribute:PROC
EXTRN	_phase_flag:DWORD
;	COMDAT ??_C@_0BK@FALCJKPP@Bad?5phase?5numbers?3?5?$CFd?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BK@FALCJKPP@Bad?5phase?5numbers?3?5?$CFd?5?$CFd?6?$AA@ DB 'Bad pha'
	DB	'se numbers: %d %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GHFPDIPJ@?$CFd?5?$CFd?5?$CFlf?$AA@
CONST	SEGMENT
??_C@_09GHFPDIPJ@?$CFd?5?$CFd?5?$CFlf?$AA@ DB '%d %d %lf', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@EGFEIDCM@Cannot?5open?5phase?5boundary?5energ@
CONST	SEGMENT
??_C@_0CM@EGFEIDCM@Cannot?5open?5phase?5boundary?5energ@ DB 'Cannot open '
	DB	'phase boundary energy file %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CBPKLGJM@phase?$AA@
CONST	SEGMENT
??_C@_05CBPKLGJM@phase?$AA@ DB 'phase', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _phase_initialize
_TEXT	SEGMENT
_value$ = -224						; size = 8
_one$ = -216						; size = 4
_j$ = -212						; size = 4
_i$ = -208						; size = 4
_line$ = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_phasename$ = 8						; size = 4
_phase_initialize PROC					; COMDAT

; 1920 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1921 :   FILE *pfd;
; 1922 :   int i,j;         /* which phases */
; 1923 :   REAL value;
; 1924 :   char line[200];
; 1925 :   int one = 1;
; 1926 : 
; 1927 :   phase_flag = 1;
; 1928 : 
; 1929 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	push	ebx
	push	esi
	mov	esi, DWORD PTR _phasename$[ebp]

; 1930 :     F_PHASE_ATTR = add_attribute(FACET,"phase",INTEGER_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	mov	DWORD PTR _one$[ebp], 1
	mov	DWORD PTR _phase_flag, 1
	push	0
	jne	SHORT $LN14@phase_init
	lea	eax, DWORD PTR _one$[ebp]
	push	eax
	push	0
	push	2
	push	OFFSET ??_C@_05CBPKLGJM@phase?$AA@
	push	2
	call	_add_attribute
	mov	DWORD PTR _F_PHASE_ATTR, eax

; 1931 :   else

	jmp	SHORT $LN27@phase_init
$LN14@phase_init:

; 1932 :     B_PHASE_ATTR = add_attribute(BODY,"phase",INTEGER_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	lea	ecx, DWORD PTR _one$[ebp]
	push	ecx
	push	0
	push	2
	push	OFFSET ??_C@_05CBPKLGJM@phase?$AA@
	push	3
	call	_add_attribute
	mov	DWORD PTR _B_PHASE_ATTR, eax
$LN27@phase_init:
	add	esp, 32					; 00000020H

; 1933 : 
; 1934 :   /* save  name */
; 1935 :   strncpy(phase_file_name,phasename,sizeof(phase_file_name));

	push	1000					; 000003e8H
	push	esi
	push	OFFSET _phase_file_name
	call	_strncpy

; 1936 : 
; 1937 :   pfd = path_open(phasename,NOTDATAFILENAME);

	push	0
	push	esi
	call	_path_open
	mov	ebx, eax
	add	esp, 20					; 00000014H

; 1938 :   if ( pfd == NULL )

	test	ebx, ebx
	jne	SHORT $LN12@phase_init

; 1939 :   { sprintf(errmsg, "Cannot open phase boundary energy file %s.\n",phasename);

	push	esi
	push	OFFSET ??_C@_0CM@EGFEIDCM@Cannot?5open?5phase?5boundary?5energ@
	push	OFFSET _errmsg
	call	_sprintf

; 1940 :     kb_error(1746,errmsg, DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1746					; 000006d2H
	call	_kb_error
	add	esp, 24					; 00000018H
	pop	esi
	pop	ebx

; 1975 : } // end phase_initialize()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@phase_init:

; 1941 :     return;
; 1942 :   }
; 1943 : 
; 1944 :   fscanf(pfd,"%d",&phasemax);

	push	OFFSET _phasemax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	ebx
	call	_fscanf

; 1945 :   phase_data = dmatrix(0,phasemax,0,phasemax);

	mov	eax, DWORD PTR _phasemax
	push	1945					; 00000799H
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 1946 :   for ( i = 0 ; i <= phasemax ; i++ )

	mov	ecx, DWORD PTR _phasemax
	add	esp, 36					; 00000024H
	mov	DWORD PTR _phase_data, eax
	mov	DWORD PTR _i$[ebp], 0
	test	ecx, ecx
	js	SHORT $LN19@phase_init
	fld1
$LN11@phase_init:

; 1947 :      for ( j = 0 ; j <= phasemax ; j++ ) 

	xor	eax, eax
	mov	DWORD PTR _j$[ebp], eax
	test	ecx, ecx
	js	SHORT $LN10@phase_init
$LN22@phase_init:

; 1948 :         phase_data[i][j] = 1.0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _phase_data
	mov	edx, DWORD PTR [edx+ecx*4]
	fst	QWORD PTR [edx+eax*8]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _phasemax
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, ecx
	jle	SHORT $LN22@phase_init
$LN10@phase_init:

; 1946 :   for ( i = 0 ; i <= phasemax ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, ecx
	jle	SHORT $LN11@phase_init
	fstp	ST(0)
$LN19@phase_init:

; 1949 :   while ( fgets(line,sizeof(line),pfd) )

	push	ebx
	lea	eax, DWORD PTR _line$[ebp]
	push	200					; 000000c8H
	push	eax
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN4@phase_init
	npad	6
$LL5@phase_init:

; 1950 :   { 
; 1951 : #ifdef FLOAT128
; 1952 :     char *c;
; 1953 :     c = strtok(line," \t");
; 1954 :     if ( !c ) continue;
; 1955 :     i = atoi(c);
; 1956 :     c = strtok(NULL," \t");
; 1957 :     if ( !c ) continue;
; 1958 :     j = atoi(c);
; 1959 :     c = strtok(NULL," \t");
; 1960 :     if ( !c ) continue;
; 1961 :     value = atof(c);
; 1962 : #elif defined(LONGDOUBLE)
; 1963 :     if ( sscanf(line,"%d %d %Lf",&i,&j,&value) == 3 ) 
; 1964 : #else
; 1965 :     if ( sscanf(line,"%d %d %lf",&i,&j,&value) == 3 ) 

	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	lea	edx, DWORD PTR _j$[ebp]
	push	edx
	lea	eax, DWORD PTR _i$[ebp]
	push	eax
	lea	ecx, DWORD PTR _line$[ebp]
	push	OFFSET ??_C@_09GHFPDIPJ@?$CFd?5?$CFd?5?$CFlf?$AA@
	push	ecx
	call	_sscanf
	add	esp, 20					; 00000014H
	cmp	eax, 3
	jne	$LN3@phase_init

; 1966 : #endif
; 1967 :     { if ( (i < 0) || (i > phasemax) || (j < 0) || (j > phasemax) )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	test	eax, eax
	js	SHORT $LN1@phase_init
	mov	edx, DWORD PTR _phasemax
	cmp	eax, edx
	jg	SHORT $LN1@phase_init
	test	ecx, ecx
	js	SHORT $LN1@phase_init
	cmp	ecx, edx
	jle	SHORT $LN2@phase_init
$LN1@phase_init:

; 1968 :       { sprintf(errmsg,"Bad phase numbers: %d %d\n",i,j);

	push	ecx
	push	eax
	push	OFFSET ??_C@_0BK@FALCJKPP@Bad?5phase?5numbers?3?5?$CFd?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1969 :         kb_error(1747,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1747					; 000006d3H
	call	_kb_error
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	add	esp, 28					; 0000001cH
$LN2@phase_init:

; 1970 :       }
; 1971 :       phase_data[i][j] = phase_data[j][i] = value;

	mov	edx, DWORD PTR _phase_data
	fld	QWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	fstp	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _phase_data
	fld	QWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _j$[ebp]
	fstp	QWORD PTR [ecx+edx*8]
$LN3@phase_init:

; 1949 :   while ( fgets(line,sizeof(line),pfd) )

	push	ebx
	lea	eax, DWORD PTR _line$[ebp]
	push	200					; 000000c8H
	push	eax
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LL5@phase_init
$LN4@phase_init:

; 1972 :     }
; 1973 :   }
; 1974 :   fclose(pfd);

	push	ebx
	call	_fclose

; 1975 : } // end phase_initialize()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 4
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_phase_initialize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@BCMJEMJG@Not?5enough?5values?5for?5transform?5@ ; `string'
PUBLIC	??_C@_0BK@NDCFKHJC@Missing?5transform?5color?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@FOHODPDF@Missing?5number?5of?5transforms?4?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_read_transforms
EXTRN	_transforms_flag:DWORD
EXTRN	_determinant:PROC
EXTRN	_unput_tok:PROC
EXTRN	_transform_colors_flag:DWORD
EXTRN	_transform_colors:DWORD
EXTRN	_matcopy:PROC
EXTRN	_view_transform_det:DWORD
EXTRN	_identmat:DWORD
EXTRN	_kb_calloc:PROC
EXTRN	_allocate_transform_colors:PROC
EXTRN	_set_view_transforms_global:PROC
EXTRN	_kb_dmatrix3:PROC
EXTRN	_free_matrix3:PROC
EXTRN	_transform_count:DWORD
EXTRN	_view_transforms:DWORD
EXTRN	_lists_flag:DWORD
EXTRN	_mat2d_setup:PROC
;	COMDAT ??_C@_0CJ@BCMJEMJG@Not?5enough?5values?5for?5transform?5@
CONST	SEGMENT
??_C@_0CJ@BCMJEMJG@Not?5enough?5values?5for?5transform?5@ DB 'Not enough '
	DB	'values for transform matrix.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NDCFKHJC@Missing?5transform?5color?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@NDCFKHJC@Missing?5transform?5color?4?6?$AA@ DB 'Missing transfo'
	DB	'rm color.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FOHODPDF@Missing?5number?5of?5transforms?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@FOHODPDF@Missing?5number?5of?5transforms?4?6?$AA@ DB 'Missing n'
	DB	'umber of transforms.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _read_transforms
_TEXT	SEGMENT
_temp_matqXvS$ = -436					; size = 28
_value$ = -408						; size = 8
_temp_mat$ = -400					; size = 4
_temp_matxJ$ = -396					; size = 392
__$ArrayPad$ = -4					; size = 4
_count$ = 8						; size = 4
_read_transforms PROC					; COMDAT

; 1986 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 436				; 000001b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1987 :   int i,j,n;
; 1988 :   REAL value;
; 1989 :   MAT2D(temp_mat,MAXCOORD+1,MAXCOORD+1);

	push	7
	push	7
	lea	eax, DWORD PTR _temp_matxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp_matqXvS$[ebp]
	push	ecx
	call	_mat2d_setup
	mov	DWORD PTR _temp_mat$[ebp], eax

; 1990 : 
; 1991 :   lists_flag = 1;
; 1992 :   if ( count > 0 ) transform_count = count+1;

	mov	eax, DWORD PTR _count$[ebp]
	add	esp, 16					; 00000010H
	mov	esi, 1
	mov	DWORD PTR _lists_flag, esi
	test	eax, eax
	jle	SHORT $LN24@read_trans
	lea	ecx, DWORD PTR [eax+1]

; 1993 :   else

	jmp	SHORT $LN38@read_trans
$LN24@read_trans:

; 1994 :   {
; 1995 :     /* find how many transforms */
; 1996 :     if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN22@read_trans

; 1997 :     { kb_error(1748,"Missing number of transforms.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BP@FOHODPDF@Missing?5number?5of?5transforms?4?6?$AA@
	push	1748					; 000006d4H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1998 :       transform_count = 1;

	mov	ecx, esi
	jmp	SHORT $LN38@read_trans
$LN22@read_trans:

; 1999 :     }
; 2000 :     else transform_count = yylval.i+1;     /* including identity */

	mov	ecx, DWORD PTR _yylval
	inc	ecx
$LN38@read_trans:

; 2001 :   }
; 2002 : 
; 2003 :   if ( view_transforms )   

	mov	eax, DWORD PTR _view_transforms
	mov	DWORD PTR _transform_count, ecx
	test	eax, eax
	je	SHORT $LN20@read_trans

; 2004 :   { free_matrix3(view_transforms); view_transforms = NULL;}

	push	eax
	call	_free_matrix3
	mov	ecx, DWORD PTR _transform_count
	add	esp, 4
	mov	DWORD PTR _view_transforms, 0
$LN20@read_trans:

; 2005 : 
; 2006 :   if ( transform_count <= 0 ) return;

	test	ecx, ecx
	jle	$LN1@read_trans

; 2007 :   view_transforms = dmatrix3(transform_count,SDIM+1,SDIM+1);

	mov	eax, DWORD PTR _web+616
	push	ebx
	push	edi
	push	2007					; 000007d7H
	inc	eax
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	eax
	push	eax
	push	ecx
	call	_kb_dmatrix3
	mov	DWORD PTR _view_transforms, eax

; 2008 :   set_view_transforms_global();

	call	_set_view_transforms_global

; 2009 :   allocate_transform_colors(transform_count);

	mov	edx, DWORD PTR _transform_count
	push	edx
	call	_allocate_transform_colors

; 2010 :   view_transform_det = (int*)mycalloc(transform_count,sizeof(int));

	mov	eax, DWORD PTR _transform_count
	push	2010					; 000007daH
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	4
	push	eax
	call	_kb_calloc

; 2011 :   matcopy(view_transforms[0],identmat,SDIM+1,SDIM+1);

	mov	ecx, DWORD PTR _identmat
	mov	edx, DWORD PTR _view_transforms
	mov	DWORD PTR _view_transform_det, eax
	mov	eax, DWORD PTR _web+616
	inc	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	push	eax
	call	_matcopy

; 2012 :   transform_colors[0] = SAME_COLOR;

	mov	ecx, DWORD PTR _transform_colors
	mov	DWORD PTR [ecx], 0

; 2013 :   view_transform_det[0] = 1;

	mov	edx, DWORD PTR _view_transform_det
	mov	DWORD PTR [edx], esi

; 2014 : 
; 2015 :   /* read in transform matrices, in homogeneous coords */
; 2016 :   for ( n = 1 ; n < transform_count ; n++ )

	mov	eax, DWORD PTR _transform_count
	add	esp, 56					; 00000038H
	mov	ebx, esi
	cmp	eax, esi
	jle	$LN16@read_trans
$LL35@read_trans:

; 2017 :   { tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 2018 :     if ( tok == COLOR_TOK )

	cmp	eax, 289				; 00000121H
	jne	SHORT $LN15@read_trans

; 2019 :     { if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN14@read_trans

; 2020 :          kb_error(1749,"Missing transform color.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BK@NDCFKHJC@Missing?5transform?5color?4?6?$AA@
	push	1749					; 000006d5H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN14@read_trans:

; 2021 :       transform_colors[n] = yylval.i;

	mov	eax, DWORD PTR _yylval
	mov	ecx, DWORD PTR _transform_colors
	mov	DWORD PTR [ecx+ebx*4], eax

; 2022 :       transform_colors_flag = 1;

	mov	DWORD PTR _transform_colors_flag, esi
	jmp	SHORT $LN11@read_trans
$LN15@read_trans:

; 2023 :     }
; 2024 :     else if ( tok == SWAP_COLORS_TOK )

	cmp	eax, 35010				; 000088c2H
	jne	SHORT $LN12@read_trans

; 2025 :     { transform_colors[n] = SWAP_COLORS;

	mov	edx, DWORD PTR _transform_colors
	mov	DWORD PTR [edx+ebx*4], esi

; 2026 :       transform_colors_flag = 1;

	mov	DWORD PTR _transform_colors_flag, esi

; 2027 :     }
; 2028 :     else

	jmp	SHORT $LN11@read_trans
$LN12@read_trans:

; 2029 :     { transform_colors[n] = SAME_COLOR;

	mov	eax, DWORD PTR _transform_colors
	mov	DWORD PTR [eax+ebx*4], 0

; 2030 :       unput_tok();

	call	_unput_tok
$LN11@read_trans:

; 2031 :     }
; 2032 :     for ( i = 0 ; i <= SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	xor	edi, edi
	test	eax, eax
	js	$LN17@read_trans
$LL34@read_trans:

; 2033 :     { for ( j = 0 ; j <= SDIM ; j++ ) 

	xor	esi, esi
	test	eax, eax
	js	SHORT $LN5@read_trans
	npad	7
$LL7@read_trans:

; 2034 :       { if ( read_const(&value) <= 0 )

	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jle	$LN30@read_trans

; 2037 :           return;
; 2038 :         }
; 2039 :         view_transforms[n][i][j] = value;

	mov	edx, DWORD PTR _view_transforms
	fld	QWORD PTR _value$[ebp]
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	ecx, DWORD PTR [eax+edi*4]
	fstp	QWORD PTR [ecx+esi*8]
	mov	eax, DWORD PTR _web+616
	inc	esi
	cmp	esi, eax
	jle	SHORT $LL7@read_trans
$LN5@read_trans:

; 2040 :       }     
; 2041 :       matcopy(temp_mat,view_transforms[n],SDIM+1,SDIM+1);

	mov	edx, DWORD PTR _view_transforms
	mov	esi, DWORD PTR _temp_mat$[ebp]
	inc	eax
	push	eax
	push	eax
	mov	eax, DWORD PTR [edx+ebx*4]
	push	eax
	push	esi
	call	_matcopy

; 2042 :       if ( determinant(temp_mat,SDIM+1) > 0.0 )

	mov	ecx, DWORD PTR _web+616
	inc	ecx
	push	ecx
	push	esi
	call	_determinant
	fcomp	QWORD PTR __real@0000000000000000
	add	esp, 24					; 00000018H
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@read_trans

; 2043 :          view_transform_det[n] = 1;

	mov	edx, DWORD PTR _view_transform_det
	mov	DWORD PTR [edx+ebx*4], 1
	jmp	SHORT $LN9@read_trans
$LN3@read_trans:

; 2044 :       else  view_transform_det[n] = -1;

	mov	eax, DWORD PTR _view_transform_det
	mov	DWORD PTR [eax+ebx*4], -1
$LN9@read_trans:

; 2031 :     }
; 2032 :     for ( i = 0 ; i <= SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	inc	edi
	cmp	edi, eax
	jle	$LL34@read_trans
	mov	esi, 1
$LN17@read_trans:

; 2014 : 
; 2015 :   /* read in transform matrices, in homogeneous coords */
; 2016 :   for ( n = 1 ; n < transform_count ; n++ )

	mov	eax, DWORD PTR _transform_count
	add	ebx, esi
	cmp	ebx, eax
	jl	$LL35@read_trans
$LN16@read_trans:

; 2045 :     }
; 2046 :   }
; 2047 :   transforms_flag = 1; /* default is to show */

	mov	DWORD PTR _transforms_flag, esi

; 2048 :   lists_flag = 0;

	mov	DWORD PTR _lists_flag, 0

; 2049 :   if ( n == transform_count ) tok = yylex(); /* lookahead */

	cmp	ebx, eax
	jne	SHORT $LN36@read_trans
	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN36@read_trans:
	pop	edi
	pop	ebx
$LN1@read_trans:
	pop	esi

; 2050 : } // end read_transforms()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@read_trans:

; 2035 :         { kb_error(1750,"Not enough values for transform matrix.\n",
; 2036 :              DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CJ@BCMJEMJG@Not?5enough?5values?5for?5transform?5@
	push	1750					; 000006d6H
	call	_kb_error

; 2050 : } // end read_transforms()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebx
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_read_transforms ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@EDOAEIAK@edge_vector_integral?$AA@	; `string'
PUBLIC	??_C@_0BH@EHAKMPOM@vertex_scalar_integral?$AA@	; `string'
PUBLIC	??_C@_0BK@LGGCNLLE@constraint_?$CFd_energy_inst?$AA@ ; `string'
PUBLIC	??_C@_0BF@GLGPDKCP@constraint_?$CFd_energy?$AA@	; `string'
PUBLIC	??_C@_0BK@LFBNENBI@constraint_?$CFs_energy_inst?$AA@ ; `string'
PUBLIC	??_C@_0BF@KDMOBFJH@constraint_?$CFs_energy?$AA@	; `string'
PUBLIC	_i$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_convert_constraint_to_quantities
EXTRN	_e_on_constraint:PROC
EXTRN	_apply_quantity:PROC
EXTRN	_v_on_constraint:PROC
EXTRN	_apply_method_num:PROC
EXTRN	_attach_method_num:PROC
EXTRN	_meth_inst_list:DWORD
EXTRN	_new_method_instance:PROC
EXTRN	_new_quantity:PROC
;	COMDAT ??_C@_0BF@EDOAEIAK@edge_vector_integral?$AA@
CONST	SEGMENT
??_C@_0BF@EDOAEIAK@edge_vector_integral?$AA@ DB 'edge_vector_integral', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EHAKMPOM@vertex_scalar_integral?$AA@
CONST	SEGMENT
??_C@_0BH@EHAKMPOM@vertex_scalar_integral?$AA@ DB 'vertex_scalar_integral'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LGGCNLLE@constraint_?$CFd_energy_inst?$AA@
CONST	SEGMENT
??_C@_0BK@LGGCNLLE@constraint_?$CFd_energy_inst?$AA@ DB 'constraint_%d_en'
	DB	'ergy_inst', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GLGPDKCP@constraint_?$CFd_energy?$AA@
CONST	SEGMENT
??_C@_0BF@GLGPDKCP@constraint_?$CFd_energy?$AA@ DB 'constraint_%d_energy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LFBNENBI@constraint_?$CFs_energy_inst?$AA@
CONST	SEGMENT
??_C@_0BK@LFBNENBI@constraint_?$CFs_energy_inst?$AA@ DB 'constraint_%s_en'
	DB	'ergy_inst', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KDMOBFJH@constraint_?$CFs_energy?$AA@
CONST	SEGMENT
??_C@_0BF@KDMOBFJH@constraint_?$CFs_energy?$AA@ DB 'constraint_%s_energy', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _convert_constraint_to_quantities
_TEXT	SEGMENT
tv293 = -224						; size = 8
_gq$ = -220						; size = 4
_con$ = -216						; size = 4
_i$GSCopy$ = -212					; size = 4
_meth$ = -208						; size = 4
_qname$ = -204						; size = 100
_inst_name$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_i$ = 8							; size = 4
_convert_constraint_to_quantities PROC			; COMDAT

; 2059 : {   int j;

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _i$[ebp]
	push	esi

; 2060 :     char qname[100];
; 2061 :     char inst_name[100];
; 2062 :     int gq;
; 2063 :     int meth;
; 2064 :     edge_id e_id;
; 2065 :     struct constraint *con = get_constraint(i);

	mov	esi, ebx
	and	esi, 1073741823				; 3fffffffH
	imul	esi, 176				; 000000b0H
	add	esi, DWORD PTR _web+652

; 2066 :     if ( !(con->attr & CON_ENERGY) ) return;

	xor	edx, edx
	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR tv293[ebp+4], eax
	mov	eax, ecx
	and	eax, 64					; 00000040H
	or	eax, edx
	mov	DWORD PTR _i$GSCopy$[ebp], ebx
	mov	DWORD PTR _con$[ebp], esi
	je	$LN25@convert_co

; 2067 :     if ( con->attr & NAMED_THING )

	and	ecx, 512				; 00000200H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN23@convert_co

; 2068 :     { sprintf(qname,"constraint_%s_energy",con->name);

	push	esi
	lea	ecx, DWORD PTR _qname$[ebp]
	push	OFFSET ??_C@_0BF@KDMOBFJH@constraint_?$CFs_energy?$AA@
	push	ecx
	call	_sprintf

; 2069 :       sprintf(inst_name,"constraint_%s_energy_inst",con->name);

	push	esi
	push	OFFSET ??_C@_0BK@LFBNENBI@constraint_?$CFs_energy_inst?$AA@
	lea	edx, DWORD PTR _inst_name$[ebp]
	push	edx

; 2070 :     }
; 2071 :     else

	jmp	SHORT $LN37@convert_co
$LN23@convert_co:

; 2072 :     { sprintf(qname,"constraint_%d_energy",i);

	push	ebx
	lea	eax, DWORD PTR _qname$[ebp]
	push	OFFSET ??_C@_0BF@GLGPDKCP@constraint_?$CFd_energy?$AA@
	push	eax
	call	_sprintf

; 2073 :       sprintf(inst_name,"constraint_%d_energy_inst",i);

	push	ebx
	push	OFFSET ??_C@_0BK@LGGCNLLE@constraint_?$CFd_energy_inst?$AA@
	lea	ecx, DWORD PTR _inst_name$[ebp]
	push	ecx
$LN37@convert_co:
	call	_sprintf
	add	esp, 24					; 00000018H

; 2074 :     }
; 2075 :     gq = new_quantity(qname,Q_ENERGY);

	lea	edx, DWORD PTR _qname$[ebp]
	push	1
	push	edx
	call	_new_quantity

; 2076 :     GEN_QUANT(gq)->flags |= DEFAULT_QUANTITY;

	mov	ecx, DWORD PTR _gen_quant_list
	mov	DWORD PTR _gq$[ebp], eax
	imul	eax, 368				; 00000170H
	or	DWORD PTR [eax+ecx+136], 8192		; 00002000H
	lea	eax, DWORD PTR [eax+ecx+136]
	add	esp, 8

; 2077 :     if ( web.representation ==  STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN21@convert_co

; 2078 :        meth = new_method_instance("vertex_scalar_integral",inst_name);

	lea	edx, DWORD PTR _inst_name$[ebp]
	push	edx
	push	OFFSET ??_C@_0BH@EHAKMPOM@vertex_scalar_integral?$AA@
	call	_new_method_instance
	mov	ecx, eax
	mov	DWORD PTR _meth$[ebp], ecx

; 2079 :     else

	jmp	SHORT $LN38@convert_co
$LN21@convert_co:

; 2080 :        meth = new_method_instance("edge_vector_integral",inst_name);

	lea	eax, DWORD PTR _inst_name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@EDOAEIAK@edge_vector_integral?$AA@
	call	_new_method_instance
	mov	DWORD PTR _meth$[ebp], eax
	mov	ecx, eax
$LN38@convert_co:

; 2081 :     METH_INSTANCE(meth)->connum = i;

	mov	eax, ecx
	cdq
	add	esp, 8
	push	edi
	mov	edi, eax
	xor	edi, edx
	sub	edi, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	edi, 2928				; 00000b70H
	mov	DWORD PTR [edi+edx+216], ebx

; 2082 :     METH_INSTANCE(meth)->flags |= IMPLICIT_INSTANCE|DEFAULT_INSTANCE;

	mov	eax, DWORD PTR _meth_inst_list
	or	DWORD PTR [edi+eax+140], 6291456	; 00600000H

; 2083 :     attach_method_num(gq,meth);

	mov	eax, DWORD PTR _gq$[ebp]
	push	ecx
	push	eax
	call	_attach_method_num

; 2084 :     if ( con->attr & GLOBAL ) 

	mov	eax, DWORD PTR [esi+32]
	and	eax, 4
	xor	ecx, ecx
	add	esp, 8
	or	eax, ecx
	je	SHORT $LN19@convert_co

; 2085 :        apply_method_num(NULLID,meth);

	mov	ecx, DWORD PTR _meth$[ebp]
	push	ecx
	push	0
	call	_apply_method_num
	add	esp, 8

; 2086 :     else

	jmp	$LN35@convert_co
$LN19@convert_co:

; 2087 :     { vertex_id v_id;
; 2088 :       if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN17@convert_co

; 2089 :       { FOR_ALL_VERTICES(v_id)

	mov	ebx, DWORD PTR _web+48
	test	ebx, 268435456				; 10000000H
	je	$LN35@convert_co
	npad	6
$LL16@convert_co:
	mov	edx, DWORD PTR _web+12
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN15@convert_co

; 2090 :           if ( v_on_constraint(v_id,i) ) 

	mov	eax, DWORD PTR _i$GSCopy$[ebp]
	push	eax
	push	ebx
	call	_v_on_constraint
	add	esp, 8
	test	eax, eax
	je	SHORT $LN15@convert_co

; 2091 :             apply_quantity(v_id,gq);

	mov	ecx, DWORD PTR _gq$[ebp]
	push	ecx
	push	ebx
	call	_apply_quantity
	add	esp, 8
$LN15@convert_co:

; 2089 :       { FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [esi+edx]
	mov	ebx, DWORD PTR [eax]
	test	ebx, 268435456				; 10000000H
	jne	SHORT $LL16@convert_co

; 2092 :       }
; 2093 :       else 

	jmp	SHORT $LN39@convert_co
$LN17@convert_co:

; 2094 :       { FOR_ALL_EDGES(e_id)

	mov	ebx, DWORD PTR _web+160
	test	ebx, 268435456				; 10000000H
	je	SHORT $LN35@convert_co
	npad	8
$LL9@convert_co:
	mov	ecx, DWORD PTR _web+124
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN8@convert_co

; 2095 :           if ( e_on_constraint(e_id,i) ) 

	mov	edx, DWORD PTR _i$GSCopy$[ebp]
	push	edx
	push	ebx
	call	_e_on_constraint
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@convert_co

; 2096 :              apply_quantity(e_id,gq);

	mov	eax, DWORD PTR _gq$[ebp]
	push	eax
	push	ebx
	call	_apply_quantity
	add	esp, 8
$LN8@convert_co:

; 2094 :       { FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [esi+ecx]
	mov	ebx, DWORD PTR [edx]
	test	ebx, 268435456				; 10000000H
	jne	SHORT $LL9@convert_co
$LN39@convert_co:
	mov	esi, DWORD PTR _con$[ebp]
$LN35@convert_co:

; 2097 :       }
; 2098 :     }
; 2099 :     for ( j = 0 ; j < SDIM ; j++ ) 

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN1@convert_co
	add	edi, 232				; 000000e8H
	lea	eax, DWORD PTR [esi+48]
$LL3@convert_co:

; 2100 :        METH_INSTANCE(meth)->expr[j] = con->envect[j];

	mov	edx, DWORD PTR [eax]
	mov	ebx, DWORD PTR _meth_inst_list
	mov	DWORD PTR [edi+ebx], edx
	inc	ecx
	add	eax, 4
	add	edi, 4
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL3@convert_co
$LN1@convert_co:

; 2101 :     con->attr |= USURPED_BY_QUANTITY;  /* prevent dual expr deallocation */

	mov	eax, DWORD PTR [esi+36]

; 2102 :     con->energy_method = meth;

	mov	ecx, DWORD PTR _meth$[ebp]
	or	DWORD PTR [esi+32], 256			; 00000100H
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+168], ecx
	pop	edi
$LN25@convert_co:

; 2103 : 
; 2104 : } // end convert_constraint_to_quantities()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_convert_constraint_to_quantities ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@EMKIJNG@Not?5enough?5entries?5for?5transform@ ; `string'
PUBLIC	??_C@_0CO@HHLBHCBD@Missing?5number?5of?5view_transform@ ; `string'
PUBLIC	_read_transform_generators
EXTRN	_calc_view_transform_gens:PROC
EXTRN	_transform_gen_swap:DWORD
EXTRN	_view_transform_gens:DWORD
EXTRN	_free_expr:PROC
EXTRN	_transform_gen_count:DWORD
EXTRN	_view_transform_gens_expr:DWORD
;	COMDAT ??_C@_0DE@EMKIJNG@Not?5enough?5entries?5for?5transform@
CONST	SEGMENT
??_C@_0DE@EMKIJNG@Not?5enough?5entries?5for?5transform@ DB 'Not enough en'
	DB	'tries for transform generator matrix.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HHLBHCBD@Missing?5number?5of?5view_transform@
CONST	SEGMENT
??_C@_0CO@HHLBHCBD@Missing?5number?5of?5view_transform@ DB 'Missing numbe'
	DB	'r of view_transform_generators.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _read_transform_generators
_TEXT	SEGMENT
_n$ = -8						; size = 4
_i$ = -8						; size = 4
tv329 = -4						; size = 4
tv392 = 8						; size = 4
_count$ = 8						; size = 4
_read_transform_generators PROC				; COMDAT

; 2115 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi

; 2116 :   int i,j,n;
; 2117 : 
; 2118 :   // take care of addload memory leak
; 2119 :   if (  view_transform_gens_expr )

	xor	esi, esi
	push	edi
	cmp	DWORD PTR _view_transform_gens_expr, esi
	je	$LN50@read_trans@2

; 2120 :   { for ( i = 0; i < transform_gen_count ; i++ )

	mov	DWORD PTR _i$[ebp], esi
	cmp	DWORD PTR _transform_gen_count, esi
	jle	SHORT $LN28@read_trans@2
	mov	eax, DWORD PTR _web+616
	mov	DWORD PTR tv329[ebp], esi
	npad	6
$LL55@read_trans@2:

; 2121 :       for ( j = 0 ; j <= SDIM ; j++ )

	xor	ebx, ebx
	test	eax, eax
	js	SHORT $LN29@read_trans@2
$LL53@read_trans@2:

; 2122 :         for ( n = 0 ; n <= SDIM ; n++ )

	xor	edi, edi
	test	eax, eax
	js	SHORT $LN26@read_trans@2
	mov	esi, DWORD PTR tv329[ebp]
	add	esi, ebx
	imul	esi, 624				; 00000270H
	npad	9
$LL49@read_trans@2:

; 2123 :           free_expr(&view_transform_gens_expr[i][j][n]);

	mov	ecx, DWORD PTR _view_transform_gens_expr
	lea	edx, DWORD PTR [esi+ecx]
	push	edx
	call	_free_expr
	mov	eax, DWORD PTR _web+616
	inc	edi
	add	esp, 4
	add	esi, 104				; 00000068H
	cmp	edi, eax
	jle	SHORT $LL49@read_trans@2
$LN26@read_trans@2:

; 2121 :       for ( j = 0 ; j <= SDIM ; j++ )

	inc	ebx
	cmp	ebx, eax
	jle	SHORT $LL53@read_trans@2
$LN29@read_trans@2:

; 2120 :   { for ( i = 0; i < transform_gen_count ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	add	DWORD PTR tv329[ebp], 6
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, DWORD PTR _transform_gen_count
	jl	SHORT $LL55@read_trans@2
$LN28@read_trans@2:

; 2124 :     myfree((char*)view_transform_gens_expr);

	mov	eax, DWORD PTR _view_transform_gens_expr
	push	eax
	call	_myfree
	add	esp, 4

; 2125 :     view_transform_gens_expr = NULL;

	xor	esi, esi
	mov	DWORD PTR _view_transform_gens_expr, esi

; 2126 :     transform_gen_count = 0;

	mov	DWORD PTR _transform_gen_count, esi
$LN50@read_trans@2:

; 2127 :   }
; 2128 :   if ( view_transform_gens )

	mov	eax, DWORD PTR _view_transform_gens
	cmp	eax, esi
	je	SHORT $LN21@read_trans@2

; 2129 :     free_matrix3(view_transform_gens);

	push	eax
	call	_free_matrix3
	add	esp, 4
$LN21@read_trans@2:

; 2130 : 
; 2131 :   lists_flag = 1;
; 2132 :   if ( count > 0 ) transform_count = count;

	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR _lists_flag, 1
	cmp	eax, esi
	jle	SHORT $LN20@read_trans@2
	mov	DWORD PTR _transform_count, eax

; 2133 :   else

	jmp	SHORT $LN17@read_trans@2
$LN20@read_trans@2:

; 2134 :   { /* find how many transforms */
; 2135 :     if ( (tok = gettok(INTEGER_TOK)) != INTEGER_TOK )

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax
	cmp	eax, 265				; 00000109H
	je	SHORT $LN18@read_trans@2

; 2136 :     { kb_error(1751,"Missing number of view_transform_generators.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CO@HHLBHCBD@Missing?5number?5of?5view_transform@
	push	1751					; 000006d7H
	call	_kb_error

; 2137 :       transform_gen_count = 1;

	mov	DWORD PTR _transform_gen_count, 1
	jmp	SHORT $LN58@read_trans@2
$LN18@read_trans@2:

; 2138 :     }
; 2139 :     else transform_gen_count = yylval.i;

	mov	ecx, DWORD PTR _yylval
	mov	DWORD PTR _transform_gen_count, ecx
$LN17@read_trans@2:

; 2140 :   }
; 2141 :   if ( transform_gen_count < 0 )

	cmp	DWORD PTR _transform_gen_count, esi
	jge	SHORT $LN52@read_trans@2

; 2142 :   { kb_error(3900,"Missing number of view_transform_generators.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CO@HHLBHCBD@Missing?5number?5of?5view_transform@
	push	3900					; 00000f3cH
	call	_kb_error

; 2143 :     transform_gen_count = 0;

	mov	DWORD PTR _transform_gen_count, esi
$LN58@read_trans@2:

; 2142 :   { kb_error(3900,"Missing number of view_transform_generators.\n",DATAFILE_ERROR);

	add	esp, 12					; 0000000cH
$LN52@read_trans@2:

; 2144 :   }
; 2145 :  
; 2146 : 
; 2147 :   if ( transform_gen_swap ) myfree((char*)transform_gen_swap);

	mov	eax, DWORD PTR _transform_gen_swap
	cmp	eax, esi
	je	SHORT $LN15@read_trans@2
	push	eax
	call	_myfree
	add	esp, 4
$LN15@read_trans@2:

; 2148 :   transform_gen_swap = (int*)mycalloc(transform_gen_count+SDIM,sizeof(int));

	mov	edx, DWORD PTR _web+616
	add	edx, DWORD PTR _transform_gen_count
	push	2148					; 00000864H
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	4
	push	edx
	call	_kb_calloc

; 2149 :   view_transform_gens = dmatrix3(web.torus_flag?(transform_gen_count+SDIM):
; 2150 :             transform_gen_count,SDIM+1,SDIM+1);

	mov	ecx, DWORD PTR _transform_gen_count
	add	esp, 16					; 00000010H
	mov	DWORD PTR _transform_gen_swap, eax
	mov	eax, DWORD PTR _web+616
	cmp	DWORD PTR _web+860, esi
	je	SHORT $LN35@read_trans@2
	add	ecx, eax
$LN35@read_trans@2:
	push	2150					; 00000866H
	inc	eax
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	eax
	push	eax
	push	ecx
	call	_kb_dmatrix3
	mov	DWORD PTR _view_transform_gens, eax

; 2151 :   view_transform_gens_expr = 
; 2152 :         (expnodearray *)mycalloc((MAXCOORD+1)*(MAXCOORD+1)*(transform_gen_count+SDIM),
; 2153 :                                     sizeof(struct expnode));

	mov	eax, DWORD PTR _web+616
	add	eax, DWORD PTR _transform_gen_count
	push	2153					; 00000869H
	imul	eax, 49					; 00000031H
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	104					; 00000068H
	push	eax
	call	_kb_calloc

; 2154 : 
; 2155 :   /* read in transform matrices, in homogeneous coords */
; 2156 :   for ( n = 0 ; n < transform_gen_count ; n++ )

	mov	ecx, DWORD PTR _transform_gen_count
	add	esp, 36					; 00000024H
	mov	DWORD PTR _view_transform_gens_expr, eax
	mov	DWORD PTR _n$[ebp], esi
	cmp	ecx, esi
	jle	$LN51@read_trans@2

; 2149 :   view_transform_gens = dmatrix3(web.torus_flag?(transform_gen_count+SDIM):
; 2150 :             transform_gen_count,SDIM+1,SDIM+1);

	mov	DWORD PTR tv392[ebp], esi
$LL56@read_trans@2:

; 2157 :   { tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 2158 :     if ( tok == SWAP_COLORS_TOK )

	cmp	eax, 35010				; 000088c2H
	jne	SHORT $LN11@read_trans@2

; 2159 :     { transform_gen_swap[n] = 1;

	mov	ecx, DWORD PTR _transform_gen_swap
	mov	DWORD PTR [ecx+esi*4], 1
	jmp	SHORT $LN10@read_trans@2
$LN11@read_trans@2:

; 2160 :     }
; 2161 :     else unput_tok();

	call	_unput_tok
$LN10@read_trans@2:

; 2162 :     for ( i = 0 ; i <= SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	xor	ebx, ebx
	test	eax, eax
	js	SHORT $LN13@read_trans@2
$LL54@read_trans@2:

; 2163 :     { for ( j = 0 ; j <= SDIM ; j++ ) 

	xor	edi, edi
	test	eax, eax
	js	SHORT $LN8@read_trans@2
	mov	esi, DWORD PTR tv392[ebp]
	add	esi, ebx
	imul	esi, 624				; 00000270H
	npad	8
$LL6@read_trans@2:

; 2164 :       { int esize = exparse(0,&view_transform_gens_expr[n][i][j],USERCOPY);

	mov	eax, DWORD PTR _view_transform_gens_expr
	push	1
	lea	ecx, DWORD PTR [esi+eax]
	push	ecx
	push	0
	call	_exparse
	add	esp, 12					; 0000000cH

; 2165 :         if ( esize < 0 )

	test	eax, eax
	js	SHORT $LN42@read_trans@2

; 2163 :     { for ( j = 0 ; j <= SDIM ; j++ ) 

	mov	eax, DWORD PTR _web+616
	inc	edi
	add	esi, 104				; 00000068H
	cmp	edi, eax
	jle	SHORT $LL6@read_trans@2
	mov	esi, DWORD PTR _n$[ebp]
$LN8@read_trans@2:

; 2162 :     for ( i = 0 ; i <= SDIM ; i++ )

	inc	ebx
	cmp	ebx, eax
	jle	SHORT $LL54@read_trans@2
$LN13@read_trans@2:

; 2154 : 
; 2155 :   /* read in transform matrices, in homogeneous coords */
; 2156 :   for ( n = 0 ; n < transform_gen_count ; n++ )

	mov	ecx, DWORD PTR _transform_gen_count
	add	DWORD PTR tv392[ebp], 6
	inc	esi
	mov	DWORD PTR _n$[ebp], esi
	cmp	esi, ecx
	jl	$LL56@read_trans@2

; 2165 :         if ( esize < 0 )

	jmp	SHORT $LN12@read_trans@2
$LN42@read_trans@2:

; 2166 :         { kb_error(1752,"Not enough entries for transform generator matrix.\n",
; 2167 :               DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DE@EMKIJNG@Not?5enough?5entries?5for?5transform@
	push	1752					; 000006d8H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2179 : } // end read_transform_generators()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@read_trans@2:

; 2168 :           return;

	mov	eax, DWORD PTR _web+616
$LN12@read_trans@2:

; 2169 :         }
; 2170 :       }     
; 2171 :     }
; 2172 :   }
; 2173 :   if ( n == transform_gen_count ) tok = yylex(); /* lookahead */

	cmp	esi, ecx
	jne	SHORT $LN57@read_trans@2
	push	0
	call	_kb_yylex
	mov	DWORD PTR _tok, eax
	mov	eax, DWORD PTR _web+616
	add	esp, 4
$LN57@read_trans@2:

; 2174 :   if ( web.torus_flag ) transform_gen_count += SDIM;

	cmp	DWORD PTR _web+860, 0
	je	SHORT $LN1@read_trans@2
	add	DWORD PTR _transform_gen_count, eax
$LN1@read_trans@2:

; 2175 : 
; 2176 :   transforms_flag = 1; /* default is to show */

	mov	DWORD PTR _transforms_flag, 1

; 2177 :   lists_flag = 0;

	mov	DWORD PTR _lists_flag, 0

; 2178 :   calc_view_transform_gens();

	call	_calc_view_transform_gens
	pop	edi
	pop	esi
	pop	ebx

; 2179 : } // end read_transform_generators()

	mov	esp, ebp
	pop	ebp
	ret	0
_read_transform_generators ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@ ; `string'
PUBLIC	??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_create_body_constraint_content_method
EXTRN	_find_method_instance:PROC
;	COMDAT ??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@
CONST	SEGMENT
??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@ DB 'body_%d_con_%d_meth'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@
CONST	SEGMENT
??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@ DB 'body_%d_%s_meth', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _create_body_constraint_content_method
_TEXT	SEGMENT
_meth1$ = -108						; size = 4
_inst_name1$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_b_id$ = 8						; size = 4
_connum$ = 12						; size = 4
_create_body_constraint_content_method PROC		; COMDAT

; 2974 : { struct constraint *con = get_constraint(connum);

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _web+652
	push	ebx
	mov	ebx, DWORD PTR _b_id$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _connum$[ebp]
	mov	esi, edi
	and	esi, 1073741823				; 3fffffffH
	imul	esi, 176				; 000000b0H
	lea	edx, DWORD PTR [esi+eax]

; 2975 :   int k;
; 2976 :   int meth1;
; 2977 :   char inst_name1[100];
; 2978 :     
; 2979 :   if ( con->attr & NAMED_THING )

	mov	eax, DWORD PTR [edx+32]
	and	eax, 512				; 00000200H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN10@create_bod

; 2980 :     sprintf(inst_name1,"body_%d_%s_meth",ordinal(b_id)+1,con->name);

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN13@create_bod
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	push	edx
	inc	eax
	push	eax
	push	OFFSET ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@
	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	ecx

; 2981 :   else

	jmp	SHORT $LN20@create_bod
$LN13@create_bod:

; 2980 :     sprintf(inst_name1,"body_%d_%s_meth",ordinal(b_id)+1,con->name);

	or	eax, -1
	push	edx
	inc	eax
	push	eax
	push	OFFSET ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@
	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	ecx

; 2981 :   else

	jmp	SHORT $LN20@create_bod
$LN10@create_bod:

; 2982 :     sprintf(inst_name1,"body_%d_con_%d_meth",ordinal(b_id)+1,connum);

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN15@create_bod
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN16@create_bod
$LN15@create_bod:
	or	eax, -1
$LN16@create_bod:
	push	edi
	inc	eax
	push	eax
	push	OFFSET ??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@
	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
$LN20@create_bod:
	call	_sprintf

; 2983 :   meth1 = find_method_instance(inst_name1);

	lea	eax, DWORD PTR _inst_name1$[ebp]
	add	esp, 16					; 00000010H
	push	eax
	call	_find_method_instance
	add	esp, 4

; 2984 :   if ( meth1 < 0 )

	test	eax, eax
	jns	$LN8@create_bod

; 2985 :   { /* have to create */
; 2986 :     if ( web.representation ==  STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN7@create_bod

; 2987 :     { meth1 = new_method_instance("vertex_scalar_integral",inst_name1);

	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BH@EHAKMPOM@vertex_scalar_integral?$AA@

; 2988 :     }
; 2989 :     else

	jmp	SHORT $LN21@create_bod
$LN7@create_bod:

; 2990 :     { meth1 = new_method_instance("edge_vector_integral",inst_name1);

	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
	push	OFFSET ??_C@_0BF@EDOAEIAK@edge_vector_integral?$AA@
$LN21@create_bod:
	call	_new_method_instance

; 2991 :     }
; 2992 :     METH_INSTANCE(meth1)->flags |= DEFAULT_INSTANCE | BODY_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	DWORD PTR _meth1$[ebp], eax
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	or	DWORD PTR [eax+ecx+140], 20971520	; 01400000H

; 2993 :     METH_INSTANCE(meth1)->connum = connum;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	DWORD PTR [eax+ecx+216], edi

; 2994 :     con = get_constraint(connum); /* may have moved */

	mov	edi, DWORD PTR _web+652
	add	esp, 8

; 2995 :     if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN5@create_bod

; 2996 :        METH_INSTANCE(meth1)->expr[0]  = con->convect[0];

	mov	edx, DWORD PTR [esi+edi+108]
	mov	ecx, DWORD PTR _meth_inst_list
	mov	DWORD PTR [eax+ecx+232], edx

; 2997 :     else

	jmp	SHORT $LN1@create_bod
$LN5@create_bod:

; 2998 :        for ( k = 0 ; k < SDIM ; k++ ) 

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN1@create_bod
	lea	ecx, DWORD PTR [eax+232]
	lea	eax, DWORD PTR [esi+edi+108]
	npad	2
$LL3@create_bod:

; 2999 :            METH_INSTANCE(meth1)->expr[k] = con->convect[k];

	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR _meth_inst_list
	mov	DWORD PTR [ecx+edi], esi
	inc	edx
	add	eax, 4
	add	ecx, 4
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL3@create_bod
$LN1@create_bod:

; 3000 :     attach_method_num(get_body_volquant(b_id),meth1);

	mov	edx, DWORD PTR _web+348
	mov	esi, DWORD PTR _meth1$[ebp]
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	ecx, DWORD PTR [eax+404]
	push	esi
	push	ecx
	call	_attach_method_num
	add	esp, 8

; 3001 :   }
; 3002 :   return meth1;

	mov	eax, esi
$LN8@create_bod:

; 3003 : } // end create_body_constraint_content_method()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_create_body_constraint_content_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@MHGGIEFG@body_?$CFd_bdry_?$CFs_meth?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_create_body_boundary_content_method
;	COMDAT ??_C@_0BF@MHGGIEFG@body_?$CFd_bdry_?$CFs_meth?$AA@
CONST	SEGMENT
??_C@_0BF@MHGGIEFG@body_?$CFd_bdry_?$CFs_meth?$AA@ DB 'body_%d_bdry_%s_me'
	DB	'th', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _create_body_boundary_content_method
_TEXT	SEGMENT
_meth1$ = -108						; size = 4
_inst_name1$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_b_id$ = 8						; size = 4
_bdrynum$ = 12						; size = 4
_create_body_boundary_content_method PROC		; COMDAT

; 3016 : { struct boundary *bdry = web.boundaries + bdrynum;

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, DWORD PTR _bdrynum$[ebp]
	imul	esi, 136				; 00000088H
	add	esi, DWORD PTR _web+776
	push	edi
	mov	edi, DWORD PTR _b_id$[ebp]

; 3017 :   int k;
; 3018 :   int meth1;
; 3019 :   char inst_name1[100];
; 3020 :  
; 3021 :       sprintf(inst_name1,"body_%d_bdry_%s_meth",ordinal(b_id)+1,bdry->name);

	test	edi, 268435456				; 10000000H
	je	SHORT $LN11@create_bod@2
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN12@create_bod@2
$LN11@create_bod@2:
	or	eax, -1
$LN12@create_bod@2:
	push	esi
	inc	eax
	push	eax
	lea	eax, DWORD PTR _inst_name1$[ebp]
	push	OFFSET ??_C@_0BF@MHGGIEFG@body_?$CFd_bdry_?$CFs_meth?$AA@
	push	eax
	call	_sprintf

; 3022 :       meth1 = find_method_instance(inst_name1);

	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	ecx
	call	_find_method_instance
	add	esp, 20					; 00000014H

; 3023 :       if ( meth1 < 0 )

	test	eax, eax
	jns	$LN8@create_bod@2

; 3024 :       { /* have to create */
; 3025 :         if ( web.representation ==  STRING )

	cmp	DWORD PTR _web+624, 1
	push	ebx
	jne	SHORT $LN7@create_bod@2

; 3026 :         { meth1 = new_method_instance("vertex_scalar_integral",inst_name1);

	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
	push	OFFSET ??_C@_0BH@EHAKMPOM@vertex_scalar_integral?$AA@
	call	_new_method_instance
	mov	ebx, eax
	mov	DWORD PTR _meth1$[ebp], ebx

; 3027 :         }
; 3028 :         else

	jmp	SHORT $LN16@create_bod@2
$LN7@create_bod@2:

; 3029 :         { meth1 = new_method_instance("edge_vector_integral",inst_name1);

	lea	eax, DWORD PTR _inst_name1$[ebp]
	push	eax
	push	OFFSET ??_C@_0BF@EDOAEIAK@edge_vector_integral?$AA@
	call	_new_method_instance
	mov	ebx, eax
	mov	DWORD PTR _meth1$[ebp], eax
$LN16@create_bod@2:

; 3030 :         }
; 3031 :         METH_INSTANCE(meth1)->flags |= DEFAULT_INSTANCE | BODY_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	eax, ebx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	or	DWORD PTR [eax+ecx+140], 20971520	; 01400000H
	add	esp, 8

; 3032 :         if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN5@create_bod@2

; 3033 :            METH_INSTANCE(meth1)->expr[0] = bdry->convect[0];

	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR _meth_inst_list
	mov	DWORD PTR [eax+edx+232], ecx

; 3034 :         else

	jmp	SHORT $LN1@create_bod@2
$LN5@create_bod@2:

; 3035 :           for ( k = 0 ; k < SDIM ; k++ ) 

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN1@create_bod@2
	lea	ecx, DWORD PTR [eax+232]
	lea	eax, DWORD PTR [esi+96]
	npad	2
$LL3@create_bod@2:

; 3036 :            METH_INSTANCE(meth1)->expr[k] = bdry->convect[k];

	mov	esi, DWORD PTR [eax]
	mov	ebx, DWORD PTR _meth_inst_list
	mov	DWORD PTR [ecx+ebx], esi
	inc	edx
	add	eax, 4
	add	ecx, 4
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL3@create_bod@2

; 3035 :           for ( k = 0 ; k < SDIM ; k++ ) 

	mov	ebx, DWORD PTR _meth1$[ebp]
$LN1@create_bod@2:

; 3037 :         attach_method_num(get_body_volquant(b_id),meth1);

	mov	eax, DWORD PTR _web+348
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	edx, DWORD PTR [ecx+404]
	push	ebx
	push	edx
	call	_attach_method_num
	add	esp, 8

; 3038 :       }
; 3039 :     return meth1;

	mov	eax, ebx
	pop	ebx
$LN8@create_bod@2:

; 3040 : } // end create_body_boundary_content_method()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_create_body_boundary_content_method ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_convert_bodies_to_quantities
EXTRN	_E_BOUNDARY_ATTR:DWORD
EXTRN	_V_BOUNDARY_ATTR:DWORD
EXTRN	_apply_method:PROC
EXTRN	_attach_method:PROC
EXTRN	_nullcon:QWORD
EXTRN	_check_edge_vol_methods:PROC
; Function compile flags: /Ogtp
;	COMDAT _convert_bodies_to_quantities
_TEXT	SEGMENT
_max_rank$91206 = -256					; size = 4
_min_rank$91207 = -252					; size = 4
_min_rank$91303 = -248					; size = 4
_connum$91232 = -248					; size = 4
tv2397 = -244						; size = 8
tv2379 = -244						; size = 8
_first_fe$91445 = -240					; size = 4
_first_fe$91413 = -240					; size = 4
_bdry$91364 = -240					; size = 4
_connum$91325 = -240					; size = 4
_first_e$91205 = -240					; size = 4
tv2659 = -236						; size = 4
_first_e$91404 = -236					; size = 4
_first_fe$91246 = -236					; size = 4
_i$ = -232						; size = 4
_concount$91298 = -228					; size = 4
_v_id$91187 = -228					; size = 4
tv2764 = -224						; size = 4
tv2490 = -224						; size = 4
tv2419 = -224						; size = 4
_max_rank$91304 = -224					; size = 4
_e_id$ = -220						; size = 4
tv3483 = -216						; size = 4
tv2471 = -216						; size = 4
_v_id$91388 = -216					; size = 4
_first_fe$91300 = -216					; size = 4
tv2373 = -212						; size = 4
_j$ = -212						; size = 4
_fe$ = -208						; size = 4
_name$91335 = -204					; size = 100
_name$91245 = -204					; size = 100
_inst_name1$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_convert_bodies_to_quantities PROC			; COMDAT

; 3050 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3051 :   body_id b_id;
; 3052 :   int meth1;
; 3053 :   char inst_name1[100];
; 3054 :   int i,j,k;
; 3055 :   edge_id e_id;
; 3056 :   facet_id f_id;
; 3057 :   facetedge_id fe;
; 3058 : 
; 3059 :   /* The main surface integral */
; 3060 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	push	ebx
	push	esi
	push	edi
	jne	SHORT $LN148@convert_bo

; 3061 :   {
; 3062 :     FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	test	edx, 268435456				; 10000000H
	je	$LN331@convert_bo
	mov	ebx, DWORD PTR _web+124
	npad	9
$LL147@convert_bo:
	mov	esi, edx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ebx]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv2379[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN146@convert_bo

; 3063 :     { if ( get_eattr(e_id) & NONCONTENT ) 

	and	ecx, 536870912				; 20000000H
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN146@convert_bo

; 3064 :         continue;
; 3065 :       check_edge_vol_methods(e_id);

	push	edx
	call	_check_edge_vol_methods
	mov	ebx, DWORD PTR _web+124
	add	esp, 4
$LN146@convert_bo:

; 3061 :   {
; 3062 :     FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR [esi+ebx]
	mov	edx, DWORD PTR [ecx]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL147@convert_bo

; 3066 : #ifdef ZZZZ
; 3067 :       fe = get_edge_fe(e_id); 
; 3068 :       if ( !valid_id(fe)  ) continue;
; 3069 :       f_id = get_fe_facet(fe);
; 3070 :       for ( i = 0 ; i < 2 ; i++ ) /* at most two facets per edge */
; 3071 :       { if ( valid_id(f_id)) 
; 3072 :         { b_id = get_facet_body(f_id);
; 3073 :           if ( valid_id(b_id) )
; 3074 :              apply_method_num(e_id,get_body_volmeth(b_id));
; 3075 :           b_id = get_facet_body(inverse_id(f_id));
; 3076 :           if ( valid_id(b_id) )
; 3077 :              apply_method_num(inverse_id(e_id),get_body_volmeth(b_id));
; 3078 :         }
; 3079 :         fe = get_next_facet(fe);
; 3080 :         f_id = get_fe_facet(fe);
; 3081 :       }
; 3082 : #endif
; 3083 :     }
; 3084 :   }
; 3085 :   else  /* SOAPFILM */

	jmp	$LN331@convert_bo
$LN148@convert_bo:

; 3086 :   {
; 3087 :      FOR_ALL_FACETS(f_id)

	mov	edi, DWORD PTR _web+272
	test	edi, 268435456				; 10000000H
	je	$LN331@convert_bo
	npad	11
$LL140@convert_bo:
	mov	edx, DWORD PTR _web+236
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv2397[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN139@convert_bo

; 3088 :      { /* check both in case of torus wrapping */
; 3089 :        if ( get_fattr(f_id) & NONCONTENT ) continue;

	and	ecx, 536870912				; 20000000H
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN139@convert_bo

; 3090 :        b_id = get_facet_body(f_id);

	push	edi
	call	_get_facet_body
	add	esp, 4

; 3091 :        if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN134@convert_bo

; 3092 :             apply_method_num(f_id,get_body_volmeth(b_id));

	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+412]
	push	eax
	push	edi
	call	_apply_method_num
	add	esp, 8
$LN134@convert_bo:

; 3093 :        b_id = get_facet_body(inverse_id(f_id));

	xor	edi, 134217728				; 08000000H
	push	edi
	call	_get_facet_body
	add	esp, 4

; 3094 :        if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN139@convert_bo

; 3095 :             apply_method_num(inverse_id(f_id),get_body_volmeth(b_id));

	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+412]
	push	eax
	push	edi
	call	_apply_method_num
	add	esp, 8
$LN139@convert_bo:

; 3086 :   {
; 3087 :      FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR [esi+ecx]
	mov	edi, DWORD PTR [edx]
	test	edi, 268435456				; 10000000H
	jne	$LL140@convert_bo
$LN331@convert_bo:

; 3096 :      }
; 3097 :   }
; 3098 : 
; 3099 :   /* constraint content integrals */
; 3100 : 
; 3101 :   /* create instance for each possible body/constraint content pair */
; 3102 :   for ( j = 0 ; j < web.maxcon ; j++ )

	cmp	DWORD PTR _web+644, 0
	mov	DWORD PTR _j$[ebp], 0
	jle	$LN334@convert_bo
	npad	8
$LL132@convert_bo:

; 3103 :   { struct constraint *con = get_constraint(j);

	mov	ebx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _web+652
	and	ebx, 1073741823				; 3fffffffH
	imul	ebx, 176				; 000000b0H
	lea	esi, DWORD PTR [ebx+eax]

; 3104 : 
; 3105 :     if ( !(con->attr & CON_CONTENT) ) continue;

	mov	eax, DWORD PTR [esi+32]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	mov	DWORD PTR tv2419[ebp], ebx
	je	$LN131@convert_bo

; 3106 :     FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+384
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	je	$LN131@convert_bo
	npad	11
$LL128@convert_bo:
	mov	edx, DWORD PTR _web+348
	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+edi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN127@convert_bo

; 3107 :     { struct method_instance *mi;
; 3108 :       if ( con->attr & NAMED_THING )

	mov	eax, DWORD PTR [esi+32]
	and	eax, 512				; 00000200H
	or	eax, edx
	je	SHORT $LN123@convert_bo

; 3109 :         sprintf(inst_name1,"body_%d_%s_meth",ordinal(b_id)+1,con->name);

	test	ecx, ecx
	je	SHORT $LN151@convert_bo
	mov	eax, edi
	push	esi
	inc	eax
	push	eax
	push	OFFSET ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@
	lea	eax, DWORD PTR _inst_name1$[ebp]
	push	eax

; 3110 :       else

	jmp	SHORT $LN352@convert_bo
$LN151@convert_bo:

; 3109 :         sprintf(inst_name1,"body_%d_%s_meth",ordinal(b_id)+1,con->name);

	or	eax, -1
	push	esi
	inc	eax
	push	eax
	push	OFFSET ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@
	lea	eax, DWORD PTR _inst_name1$[ebp]
	push	eax

; 3110 :       else

	jmp	SHORT $LN352@convert_bo
$LN123@convert_bo:

; 3111 :         sprintf(inst_name1,"body_%d_con_%d_meth",ordinal(b_id)+1,j);

	test	ecx, ecx
	je	SHORT $LN153@convert_bo
	mov	eax, edi
	jmp	SHORT $LN154@convert_bo
$LN153@convert_bo:
	or	eax, -1
$LN154@convert_bo:
	mov	ecx, DWORD PTR _j$[ebp]
	push	ecx
	inc	eax
	push	eax
	push	OFFSET ??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@
	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
$LN352@convert_bo:
	call	_sprintf

; 3112 :       meth1 = find_method_instance(inst_name1);

	lea	eax, DWORD PTR _inst_name1$[ebp]
	add	esp, 16					; 00000010H
	push	eax
	call	_find_method_instance
	add	esp, 4

; 3113 :       if ( meth1 < 0 )

	test	eax, eax
	jns	SHORT $LN119@convert_bo

; 3114 :       { /* have to create */     
; 3115 :         if ( web.representation ==  STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN120@convert_bo

; 3116 :         { meth1 = new_method_instance("vertex_scalar_integral",inst_name1);

	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BH@EHAKMPOM@vertex_scalar_integral?$AA@

; 3117 :         }
; 3118 :         else

	jmp	SHORT $LN353@convert_bo
$LN120@convert_bo:

; 3119 :         { meth1 = new_method_instance("edge_vector_integral",inst_name1);

	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
	push	OFFSET ??_C@_0BF@EDOAEIAK@edge_vector_integral?$AA@
$LN353@convert_bo:
	call	_new_method_instance
	add	esp, 8
$LN119@convert_bo:

; 3120 :         }
; 3121 :       }
; 3122 :       mi = METH_INSTANCE(meth1);

	mov	ecx, DWORD PTR _meth_inst_list

; 3123 :       mi->flags |= DEFAULT_INSTANCE | BODY_INSTANCE;
; 3124 :       METH_INSTANCE(meth1)->connum = j;

	mov	esi, DWORD PTR _j$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	or	DWORD PTR [ecx+eax+140], 20971520	; 01400000H
	mov	edx, DWORD PTR _meth_inst_list
	add	ecx, eax
	mov	DWORD PTR [eax+edx+216], esi

; 3125 :       con = get_constraint(j); /* may have moved */
; 3126 :       if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	mov	eax, DWORD PTR _web+652
	lea	esi, DWORD PTR [ebx+eax]
	jne	SHORT $LN118@convert_bo

; 3127 :          mi->expr[0]  = con->convect[0];

	mov	edx, DWORD PTR [esi+108]
	mov	DWORD PTR [ecx+232], edx

; 3128 :       else

	jmp	SHORT $LN127@convert_bo
$LN118@convert_bo:

; 3129 :          for ( k = 0 ; k < SDIM ; k++ ) 

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN127@convert_bo
	add	ecx, 232				; 000000e8H
	lea	eax, DWORD PTR [esi+108]
	npad	4
$LL116@convert_bo:

; 3130 :             mi->expr[k] = con->convect[k];

	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebx
	inc	edx
	add	eax, 4
	add	ecx, 4
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL116@convert_bo

; 3129 :          for ( k = 0 ; k < SDIM ; k++ ) 

	mov	ebx, DWORD PTR tv2419[ebp]
$LN127@convert_bo:

; 3106 :     FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LL128@convert_bo
$LN131@convert_bo:

; 3096 :      }
; 3097 :   }
; 3098 : 
; 3099 :   /* constraint content integrals */
; 3100 : 
; 3101 :   /* create instance for each possible body/constraint content pair */
; 3102 :   for ( j = 0 ; j < web.maxcon ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _web+644
	jl	$LL132@convert_bo
$LN334@convert_bo:

; 3131 :       
; 3132 :     }
; 3133 :   }
; 3134 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	mov	esi, DWORD PTR _web+652
	jne	$LN113@convert_bo

; 3135 :   { vertex_id v_id;
; 3136 :     FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	edi, DWORD PTR _web+12
	mov	DWORD PTR _v_id$91187[ebp], eax
	test	eax, 268435456				; 10000000H
	je	$LN75@convert_bo
	npad	7
$LL112@convert_bo:
	mov	eax, DWORD PTR _v_id$91187[ebp]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edi]
	mov	DWORD PTR tv2471[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN111@convert_bo

; 3137 :     { conmap_t *con = get_v_constraint_map(v_id);

	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	cmp	DWORD PTR [edx+eax+1288], 0
	je	SHORT $LN155@convert_bo
	mov	edx, DWORD PTR [edx+eax+1264]
	add	edx, ecx
	jmp	SHORT $LN156@convert_bo
$LN155@convert_bo:
	mov	edx, OFFSET _nullcon
$LN156@convert_bo:

; 3138 :       int concount = (int)con[0];

	mov	eax, DWORD PTR [edx]

; 3139 :       edge_id first_e;
; 3140 :       int max_rank,min_rank;
; 3141 :         
; 3142 :       min_rank = MAXINT; max_rank = 0;
; 3143 :       for ( j = 1 ; j <= (int)con[0] ; j++ )

	mov	ecx, 1
	mov	DWORD PTR tv2490[ebp], eax
	mov	DWORD PTR _min_rank$91207[ebp], 2147483647 ; 7fffffffH
	mov	DWORD PTR _max_rank$91206[ebp], 0
	cmp	eax, ecx
	jl	SHORT $LN105@convert_bo
$LL349@convert_bo:

; 3144 :       { struct constraint *c;
; 3145 :         if ( !(con[j] & CON_HIT_BIT) ) continue;

	mov	eax, DWORD PTR [edx+ecx*4]
	test	eax, eax
	jns	SHORT $LN106@convert_bo

; 3146 :         c = get_constraint(con[j]);

	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H

; 3147 :         if ( c->content_rank < min_rank ) min_rank = c->content_rank;

	mov	eax, DWORD PTR [eax+esi+172]
	cmp	eax, DWORD PTR _min_rank$91207[ebp]
	jge	SHORT $LN103@convert_bo
	mov	DWORD PTR _min_rank$91207[ebp], eax
$LN103@convert_bo:

; 3148 :         if ( c->content_rank > max_rank ) max_rank = c->content_rank;

	cmp	eax, DWORD PTR _max_rank$91206[ebp]
	jle	SHORT $LN106@convert_bo
	mov	DWORD PTR _max_rank$91206[ebp], eax
$LN106@convert_bo:

; 3139 :       edge_id first_e;
; 3140 :       int max_rank,min_rank;
; 3141 :         
; 3142 :       min_rank = MAXINT; max_rank = 0;
; 3143 :       for ( j = 1 ; j <= (int)con[0] ; j++ )

	mov	eax, DWORD PTR tv2490[ebp]
	inc	ecx
	cmp	ecx, eax
	jle	SHORT $LL349@convert_bo
$LN105@convert_bo:

; 3149 :       }
; 3150 : 
; 3151 :       for ( i = 1 ; i <= concount ; i++ )

	mov	DWORD PTR _i$[ebp], 1
	cmp	eax, 1
	jl	$LN111@convert_bo
	mov	edx, DWORD PTR _web+104
	npad	5
$LL101@convert_bo:

; 3152 :       { conmap_t *con = get_v_constraint_map(v_id); /* might have moved */

	mov	ecx, DWORD PTR _dymem
	cmp	DWORD PTR [edx+ecx+1288], 0
	je	SHORT $LN157@convert_bo
	mov	eax, DWORD PTR tv2471[ebp]
	mov	eax, DWORD PTR [eax+edi]
	add	eax, DWORD PTR [edx+ecx+1264]
	jmp	SHORT $LN158@convert_bo
$LN157@convert_bo:
	mov	eax, OFFSET _nullcon
$LN158@convert_bo:

; 3153 :         int connum = con[i] & CONMASK;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	and	eax, 1073741823				; 3fffffffH

; 3154 :         struct constraint *c = get_constraint(connum);

	mov	ebx, eax
	and	ebx, 1073741823				; 3fffffffH
	imul	ebx, 176				; 000000b0H
	mov	DWORD PTR _connum$91232[ebp], eax

; 3155 :         if ( !(c->attr & CON_CONTENT)) continue;

	mov	eax, DWORD PTR [ebx+esi+32]
	add	ebx, esi
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN100@convert_bo

; 3156 :         first_e = e_id = get_vertex_edge(v_id);

	mov	eax, DWORD PTR tv2471[ebp]
	mov	ecx, DWORD PTR [eax+edi]
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR _e_id$[ebp], eax
	mov	DWORD PTR _first_e$91205[ebp], eax

; 3157 :         if ( valid_id(e_id) )

	test	eax, 268435456				; 10000000H
	je	$LN94@convert_bo
$LL96@convert_bo:

; 3158 :         do
; 3159 :         { char name[100];
; 3160 :           facetedge_id first_fe = fe = get_edge_fe(e_id);

	mov	edx, DWORD PTR _e_id$[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2373[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	test	eax, eax
	jne	SHORT $LN194@convert_bo
	xor	ecx, ecx
	jmp	SHORT $LN193@convert_bo
$LN194@convert_bo:
	mov	ecx, DWORD PTR [eax+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN193@convert_bo
	xor	ecx, 134217728				; 08000000H
$LN193@convert_bo:
	mov	DWORD PTR _fe$[ebp], ecx
	mov	DWORD PTR _first_fe$91246[ebp], ecx

; 3161 :           if ( valid_id(fe) && !(get_eattr(e_id) & NONCONTENT) )  

	test	ecx, 268435456				; 10000000H
	je	$LN90@convert_bo
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN90@convert_bo
$LL92@convert_bo:

; 3162 :           do
; 3163 :           { f_id = get_fe_facet(fe);

	mov	ecx, DWORD PTR _fe$[ebp]
	mov	edx, DWORD PTR _web+460
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN198@convert_bo
	mov	edi, DWORD PTR _NULLFACET
	jmp	SHORT $LN199@convert_bo
$LN198@convert_bo:
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN197@convert_bo
	xor	eax, 134217728				; 08000000H
$LN197@convert_bo:
	mov	edi, eax
$LN199@convert_bo:

; 3164 :             fe = get_next_facet(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN202@convert_bo
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+36]
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR _fe$[ebp], edx
	jmp	SHORT $LN201@convert_bo
$LN202@convert_bo:
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _fe$[ebp], ecx
$LN201@convert_bo:

; 3165 :             if ( !valid_id(f_id) ) continue;

	test	edi, 268435456				; 10000000H
	je	$LN91@convert_bo

; 3166 :             b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN208@convert_bo
	xor	esi, esi
	jmp	SHORT $LN205@convert_bo
$LN208@convert_bo:
	test	edi, 134217728				; 08000000H
	je	SHORT $LN206@convert_bo
	mov	eax, DWORD PTR _web+236
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+784]
	mov	esi, DWORD PTR [ecx+edx+4]
	jmp	SHORT $LN205@convert_bo
$LN206@convert_bo:
	mov	ecx, DWORD PTR _web+236
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	esi, DWORD PTR [edx+eax]
$LN205@convert_bo:

; 3167 :             if ( valid_id(b_id)   && 
; 3168 :            ( (!inverted(f_id) && c->content_rank >= max_rank) 
; 3169 :                || (inverted(f_id) && c->content_rank <= min_rank)))

	test	esi, 268435456				; 10000000H
	je	$LN341@convert_bo
	mov	eax, edi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	jne	SHORT $LN346@convert_bo
	mov	ecx, DWORD PTR [ebx+172]
	cmp	ecx, DWORD PTR _max_rank$91206[ebp]
	jge	SHORT $LN351@convert_bo
$LN346@convert_bo:
	test	eax, eax
	je	$LN341@convert_bo
	mov	edx, DWORD PTR [ebx+172]
	cmp	edx, DWORD PTR _min_rank$91207[ebp]
	jg	SHORT $LN341@convert_bo
$LN351@convert_bo:

; 3170 :             { if ( c->attr & NAMED_THING )

	mov	eax, DWORD PTR [ebx+32]
	and	eax, 512				; 00000200H
	xor	ecx, ecx

; 3171 :                 sprintf(name,"body_%d_%s_meth",ordinal(b_id)+1,c->name);

	and	esi, 134217727				; 07ffffffH
	or	eax, ecx
	lea	ecx, DWORD PTR _name$91245[ebp]
	lea	eax, DWORD PTR [esi+1]
	je	SHORT $LN85@convert_bo
	push	ebx
	push	eax
	push	OFFSET ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@

; 3172 :               else

	jmp	SHORT $LN354@convert_bo
$LN85@convert_bo:

; 3173 :                 sprintf(name,"body_%d_con_%d_meth",ordinal(b_id)+1,connum);

	mov	edx, DWORD PTR _connum$91232[ebp]
	push	edx
	push	eax
	push	OFFSET ??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@
$LN354@convert_bo:
	push	ecx
	call	_sprintf

; 3174 :               attach_method(get_body_volquant(b_id),name);

	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [eax+esi*4]
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR _name$91245[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx+404]
	push	edx
	call	_attach_method

; 3175 :               apply_method(inverse_id(v_id),name);

	mov	ecx, DWORD PTR _v_id$91187[ebp]
	lea	eax, DWORD PTR _name$91245[ebp]
	push	eax
	xor	ecx, 134217728				; 08000000H
	push	ecx
	call	_apply_method
	add	esp, 16					; 00000010H
$LN341@convert_bo:

; 3176 :             }
; 3177 :             b_id = get_facet_body(inverse_id(f_id));

	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN214@convert_bo
	xor	esi, esi
	jmp	SHORT $LN211@convert_bo
$LN214@convert_bo:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN213@convert_bo
	xor	esi, esi
	jmp	SHORT $LN211@convert_bo
$LN213@convert_bo:
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR _web+328
	test	eax, 134217728				; 08000000H
	je	SHORT $LN212@convert_bo
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	esi, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN211@convert_bo
$LN212@convert_bo:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	esi, DWORD PTR [eax+ecx]
$LN211@convert_bo:

; 3178 :             if ( valid_id(b_id) && 
; 3179 :               ( (!inverted(f_id) && c->content_rank >= max_rank) 
; 3180 :                || (inverted(f_id) && c->content_rank <= min_rank)))

	test	esi, 268435456				; 10000000H
	je	$LN91@convert_bo
	shr	edi, 27					; 0000001bH
	mov	eax, edi
	and	eax, 1
	jne	SHORT $LN81@convert_bo
	mov	edx, DWORD PTR _max_rank$91206[ebp]
	cmp	DWORD PTR [ebx+172], edx
	jge	SHORT $LN82@convert_bo
$LN81@convert_bo:
	test	eax, eax
	je	SHORT $LN91@convert_bo
	mov	eax, DWORD PTR _min_rank$91207[ebp]
	cmp	DWORD PTR [ebx+172], eax
	jg	SHORT $LN91@convert_bo
$LN82@convert_bo:

; 3181 :             { if ( c->attr & NAMED_THING )

	mov	eax, DWORD PTR [ebx+32]
	xor	ecx, ecx
	and	eax, 512				; 00000200H

; 3182 :                 sprintf(name,"body_%d_%s_meth",ordinal(b_id)+1,c->name);

	and	esi, 134217727				; 07ffffffH
	or	eax, ecx
	lea	edx, DWORD PTR _name$91245[ebp]
	lea	ecx, DWORD PTR [esi+1]
	je	SHORT $LN80@convert_bo
	push	ebx
	push	ecx
	push	OFFSET ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@

; 3183 :               else

	jmp	SHORT $LN355@convert_bo
$LN80@convert_bo:

; 3184 :                 sprintf(name,"body_%d_con_%d_meth",ordinal(b_id)+1,connum);

	mov	eax, DWORD PTR _connum$91232[ebp]
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@
$LN355@convert_bo:
	push	edx
	call	_sprintf

; 3185 :               attach_method(get_body_volquant(b_id),name);

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ecx+esi*4]
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR _name$91245[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+404]
	push	eax
	call	_attach_method

; 3186 :               apply_method(v_id,name);

	mov	edx, DWORD PTR _v_id$91187[ebp]
	lea	ecx, DWORD PTR _name$91245[ebp]
	push	ecx
	push	edx
	call	_apply_method
	add	esp, 16					; 00000010H
$LN91@convert_bo:

; 3187 :             }
; 3188 :           } while ( !equal_id(fe,first_fe) );

	mov	eax, DWORD PTR _first_fe$91246[ebp]
	cmp	DWORD PTR _fe$[ebp], eax
	jne	$LL92@convert_bo
$LN90@convert_bo:

; 3189 :           e_id = get_next_tail_edge(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	eax, DWORD PTR tv2373[ebp]
	mov	edx, DWORD PTR _web+124
	mov	edx, DWORD PTR [eax+edx]
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	eax, DWORD PTR [edx+ecx*4+32]
	mov	DWORD PTR _e_id$[ebp], eax

; 3190 :         } while ( !equal_id(first_e,e_id));

	cmp	DWORD PTR _first_e$91205[ebp], eax
	jne	$LL96@convert_bo
	mov	edx, DWORD PTR _web+104
	mov	edi, DWORD PTR _web+12
$LN94@convert_bo:
	mov	esi, DWORD PTR _web+652
$LN100@convert_bo:

; 3149 :       }
; 3150 : 
; 3151 :       for ( i = 1 ; i <= concount ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR tv2490[ebp]
	jle	$LL101@convert_bo
$LN111@convert_bo:

; 3135 :   { vertex_id v_id;
; 3136 :     FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR tv2471[ebp]
	mov	ecx, DWORD PTR [eax+edi]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _v_id$91187[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL112@convert_bo

; 3191 :       }
; 3192 :     }
; 3193 :   }
; 3194 :   else  /* SOAPFILM */

	jmp	$LN75@convert_bo
$LN113@convert_bo:

; 3195 :   { FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+160
	mov	DWORD PTR _e_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	je	$LN335@convert_bo
	npad	7
$LL77@convert_bo:
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR tv2373[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN76@convert_bo

; 3196 :     { conmap_t *con = get_e_constraint_map(e_id);

	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	cmp	DWORD PTR [edx+eax+1048], 0
	je	SHORT $LN167@convert_bo
	mov	edx, DWORD PTR [edx+eax+1024]
	add	edx, ecx
	jmp	SHORT $LN168@convert_bo
$LN167@convert_bo:
	mov	edx, OFFSET _nullcon
$LN168@convert_bo:

; 3197 :       int concount = (int)con[0];

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _concount$91298[ebp], eax

; 3198 :       facetedge_id first_fe = fe = get_edge_fe(e_id);

	test	ecx, ecx
	jne	SHORT $LN220@convert_bo
	xor	eax, eax
	jmp	SHORT $LN221@convert_bo
$LN220@convert_bo:
	test	DWORD PTR _e_id$[ebp], 134217728	; 08000000H
	mov	ecx, DWORD PTR [ecx+28]
	je	SHORT $LN219@convert_bo
	xor	ecx, 134217728				; 08000000H
$LN219@convert_bo:
	mov	eax, ecx
$LN221@convert_bo:
	mov	DWORD PTR _first_fe$91300[ebp], eax

; 3199 :       if ( valid_id ( fe ) )

	test	eax, 268435456				; 10000000H
	je	$LN76@convert_bo

; 3200 :       { int min_rank, max_rank;
; 3201 : 
; 3202 :          min_rank = MAXINT; max_rank = 0;
; 3203 :          for ( j = 1 ; j <= concount ; j++ )

	mov	ebx, DWORD PTR _concount$91298[ebp]
	xor	edi, edi
	lea	ecx, DWORD PTR [edi+1]
	mov	esi, 2147483647				; 7fffffffH
	mov	DWORD PTR _min_rank$91303[ebp], esi
	mov	DWORD PTR _max_rank$91304[ebp], edi
	cmp	ebx, ecx
	jl	SHORT $LN69@convert_bo
	npad	5
$LL71@convert_bo:

; 3204 :          { 
; 3205 :            struct constraint *c = get_constraint(con[j]);

	mov	eax, DWORD PTR [edx+ecx*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 3206 :            if ( c->content_rank < min_rank ) min_rank = c->content_rank;

	mov	eax, DWORD PTR [eax+172]
	cmp	eax, esi
	jge	SHORT $LN68@convert_bo
	mov	esi, eax
$LN68@convert_bo:

; 3207 :            if ( c->content_rank > max_rank ) max_rank = c->content_rank;

	cmp	eax, edi
	jle	SHORT $LN70@convert_bo
	mov	edi, eax
$LN70@convert_bo:

; 3200 :       { int min_rank, max_rank;
; 3201 : 
; 3202 :          min_rank = MAXINT; max_rank = 0;
; 3203 :          for ( j = 1 ; j <= concount ; j++ )

	inc	ecx
	cmp	ecx, ebx
	jle	SHORT $LL71@convert_bo

; 3207 :            if ( c->content_rank > max_rank ) max_rank = c->content_rank;

	mov	DWORD PTR _max_rank$91304[ebp], edi
	mov	DWORD PTR _min_rank$91303[ebp], esi
$LN69@convert_bo:

; 3208 :          }
; 3209 :       for ( i = 1 ; i <= concount ; i++ )

	mov	DWORD PTR _i$[ebp], 1
	cmp	ebx, 1
	jl	$LN76@convert_bo
	npad	6
$LL66@convert_bo:

; 3210 :       { conmap_t *con = get_e_constraint_map(e_id);  /* might have moved */

	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	cmp	DWORD PTR [edx+ecx+1048], 0
	je	SHORT $LN169@convert_bo
	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR tv2373[ebp]
	mov	eax, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR _web+216
	add	eax, DWORD PTR [edx+ecx+1024]
	jmp	SHORT $LN170@convert_bo
$LN169@convert_bo:
	mov	eax, OFFSET _nullcon
$LN170@convert_bo:

; 3211 :         int connum = con[i]&CONMASK;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	and	eax, 1073741823				; 3fffffffH
	mov	DWORD PTR _connum$91325[ebp], eax

; 3212 :         struct constraint *c = get_constraint(connum);

	and	eax, 1073741823				; 3fffffffH
	mov	edi, eax
	imul	edi, 176				; 000000b0H
	add	edi, DWORD PTR _web+652
	mov	DWORD PTR tv2659[ebp], eax

; 3213 :         if ( !(c->attr & CON_CONTENT) ) continue;

	mov	eax, DWORD PTR [edi+32]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN65@convert_bo

; 3214 :         fe = first_fe;

	mov	edx, DWORD PTR _first_fe$91300[ebp]
	mov	DWORD PTR _fe$[ebp], edx
	npad	12
$LL62@convert_bo:

; 3215 :         do
; 3216 :         { char name[100];
; 3217 :           f_id = get_fe_facet(fe);

	mov	ecx, DWORD PTR _fe$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN224@convert_bo
	mov	ebx, DWORD PTR _NULLFACET
	jmp	SHORT $LN225@convert_bo
$LN224@convert_bo:
	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN223@convert_bo
	xor	eax, 134217728				; 08000000H
$LN223@convert_bo:
	mov	ebx, eax
$LN225@convert_bo:

; 3218 :           fe = get_next_facet(fe);

	mov	eax, DWORD PTR _fe$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN228@convert_bo
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN356@convert_bo
$LN228@convert_bo:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]
$LN356@convert_bo:
	mov	DWORD PTR _fe$[ebp], eax

; 3219 :           if ( !valid_id(f_id) ) continue;

	test	ebx, 268435456				; 10000000H
	je	$LN61@convert_bo

; 3220 :           if ( get_fattr(f_id) & NONCONTENT ) continue;

	mov	edx, DWORD PTR _web+236
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 536870912				; 20000000H
	xor	edx, edx
	or	eax, edx
	jne	$LN61@convert_bo

; 3221 :           b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, edx
	jne	SHORT $LN234@convert_bo
	xor	ecx, ecx
	jmp	SHORT $LN231@convert_bo
$LN234@convert_bo:
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN232@convert_bo
	mov	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+784]
	mov	ecx, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN231@convert_bo
$LN232@convert_bo:
	mov	edx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+784]
	mov	ecx, DWORD PTR [ecx+edx]
$LN231@convert_bo:

; 3222 :           if ( valid_id(b_id) && (c->content_rank >= max_rank))

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN57@convert_bo
	mov	eax, DWORD PTR _max_rank$91304[ebp]
	cmp	DWORD PTR [edi+172], eax
	jl	SHORT $LN57@convert_bo

; 3223 :           { if ( c->attr & NAMED_THING )

	mov	eax, DWORD PTR [edi+32]

; 3224 :               sprintf(name,"body_%d_%s_meth",ordinal(b_id)+1,c->name);

	mov	esi, ecx
	xor	edx, edx
	and	eax, 512				; 00000200H
	and	esi, 134217727				; 07ffffffH
	or	eax, edx
	lea	ecx, DWORD PTR [esi+1]
	lea	edx, DWORD PTR _name$91335[ebp]
	je	SHORT $LN56@convert_bo
	push	edi
	push	ecx
	push	OFFSET ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@

; 3225 :             else

	jmp	SHORT $LN357@convert_bo
$LN56@convert_bo:

; 3226 :               sprintf(name,"body_%d_con_%d_meth",ordinal(b_id)+1,connum);

	mov	eax, DWORD PTR _connum$91325[ebp]
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@
$LN357@convert_bo:
	push	edx
	call	_sprintf

; 3227 :             attach_method(get_body_volquant(b_id),name);

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ecx+esi*4]
	add	esp, 16					; 00000010H
	lea	eax, DWORD PTR _name$91335[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+404]
	push	eax
	call	_attach_method

; 3228 :             apply_method(e_id,name);

	mov	edx, DWORD PTR _e_id$[ebp]
	lea	ecx, DWORD PTR _name$91335[ebp]
	push	ecx
	push	edx
	call	_apply_method
	add	esp, 16					; 00000010H
$LN57@convert_bo:

; 3229 :           }
; 3230 :           b_id = get_facet_body(inverse_id(f_id));

	mov	eax, ebx
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN240@convert_bo
	xor	esi, esi
	jmp	SHORT $LN237@convert_bo
$LN240@convert_bo:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN239@convert_bo
	xor	esi, esi
	jmp	SHORT $LN237@convert_bo
$LN239@convert_bo:
	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN238@convert_bo
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	esi, DWORD PTR [edx+eax+4]
	jmp	SHORT $LN237@convert_bo
$LN238@convert_bo:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	esi, DWORD PTR [edx+eax]
$LN237@convert_bo:

; 3231 :           if ( valid_id(b_id) && (c->content_rank <= min_rank) )

	test	esi, 268435456				; 10000000H
	je	$LN61@convert_bo
	mov	ecx, DWORD PTR _min_rank$91303[ebp]
	cmp	DWORD PTR [edi+172], ecx
	jg	SHORT $LN61@convert_bo

; 3232 :           { if ( c->attr & NAMED_THING )

	mov	eax, DWORD PTR [edi+32]
	and	eax, 512				; 00000200H
	xor	ecx, ecx

; 3233 :               sprintf(name,"body_%d_%s_meth",ordinal(b_id)+1,c->name);

	and	esi, 134217727				; 07ffffffH
	or	eax, ecx
	lea	edx, DWORD PTR [esi+1]
	lea	eax, DWORD PTR _name$91335[ebp]
	je	SHORT $LN53@convert_bo
	push	edi
	push	edx
	push	OFFSET ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@

; 3234 :             else

	jmp	SHORT $LN358@convert_bo
$LN53@convert_bo:

; 3235 :               sprintf(name,"body_%d_con_%d_meth",ordinal(b_id)+1,connum&CONMASK);

	mov	ecx, DWORD PTR tv2659[ebp]
	push	ecx
	push	edx
	push	OFFSET ??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@
$LN358@convert_bo:
	push	eax
	call	_sprintf

; 3236 :             attach_method(get_body_volquant(b_id),name);

	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [edx+esi*4]
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR _name$91335[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+404]
	push	ecx
	call	_attach_method

; 3237 :             apply_method(inverse_id(e_id),name);

	mov	eax, DWORD PTR _e_id$[ebp]
	lea	edx, DWORD PTR _name$91335[ebp]
	push	edx
	xor	eax, 134217728				; 08000000H
	push	eax
	call	_apply_method
	add	esp, 16					; 00000010H
$LN61@convert_bo:

; 3238 :           }
; 3239 :         } while ( !equal_id(fe,first_fe) );

	mov	ecx, DWORD PTR _first_fe$91300[ebp]
	cmp	DWORD PTR _fe$[ebp], ecx
	jne	$LL62@convert_bo
$LN65@convert_bo:

; 3208 :          }
; 3209 :       for ( i = 1 ; i <= concount ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _concount$91298[ebp]
	jle	$LL66@convert_bo
$LN76@convert_bo:

; 3195 :   { FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+124
	mov	edx, DWORD PTR tv2373[ebp]
	mov	ecx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _e_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL77@convert_bo
$LN335@convert_bo:
	mov	edi, DWORD PTR _web+12
$LN75@convert_bo:

; 3240 :       }
; 3241 :       }
; 3242 :     }
; 3243 :   }
; 3244 : 
; 3245 :   /* boundary content integrals */
; 3246 :   for ( j = 0 ; j < web.bdrymax ; j++ )

	xor	eax, eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	DWORD PTR _web+768, eax
	jle	$LN337@convert_bo
	mov	edi, DWORD PTR _web+348
	mov	DWORD PTR tv3483[ebp], eax
	npad	4
$LL51@convert_bo:

; 3247 :   { struct boundary *bdry = web.boundaries + j;

	mov	ebx, DWORD PTR tv3483[ebp]
	add	ebx, DWORD PTR _web+776

; 3248 : 
; 3249 :     if ( !(bdry->attr & CON_CONTENT) ) continue;

	xor	ecx, ecx
	mov	eax, DWORD PTR [ebx+32]
	and	eax, 128				; 00000080H
	or	eax, ecx
	mov	DWORD PTR _bdry$91364[ebp], ebx
	je	$LN50@convert_bo

; 3250 :     FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+384
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	je	$LN50@convert_bo
	npad	9
$LL47@convert_bo:
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN46@convert_bo

; 3251 :     { struct method_instance *mi;
; 3252 :       sprintf(inst_name1,"body_%d_bdry_%s_meth",ordinal(b_id)+1,bdry->name);

	test	ecx, ecx
	je	SHORT $LN179@convert_bo
	mov	eax, esi
	jmp	SHORT $LN180@convert_bo
$LN179@convert_bo:
	or	eax, -1
$LN180@convert_bo:
	push	ebx
	inc	eax
	push	eax
	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	OFFSET ??_C@_0BF@MHGGIEFG@body_?$CFd_bdry_?$CFs_meth?$AA@
	push	ecx
	call	_sprintf

; 3253 :       meth1 = find_method_instance(inst_name1);

	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
	call	_find_method_instance
	mov	edi, eax
	add	esp, 20					; 00000014H

; 3254 :       if ( meth1 < 0 )

	test	edi, edi
	jns	SHORT $LN40@convert_bo

; 3255 :       { /* have to create */
; 3256 :         if ( web.representation ==  STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN41@convert_bo

; 3257 :         { meth1 = new_method_instance("vertex_scalar_integral",inst_name1);

	lea	eax, DWORD PTR _inst_name1$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@EHAKMPOM@vertex_scalar_integral?$AA@

; 3258 :         }
; 3259 :         else

	jmp	SHORT $LN359@convert_bo
$LN41@convert_bo:

; 3260 :         { meth1 = new_method_instance("edge_vector_integral",inst_name1);

	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BF@EDOAEIAK@edge_vector_integral?$AA@
$LN359@convert_bo:
	call	_new_method_instance
	mov	edi, eax
	add	esp, 8
$LN40@convert_bo:

; 3261 :         }
; 3262 :       }
; 3263 :       mi = METH_INSTANCE(meth1);

	mov	eax, edi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 3264 :       mi->flags |= DEFAULT_INSTANCE | BODY_INSTANCE;

	or	DWORD PTR [eax+140], 20971520		; 01400000H

; 3265 :       if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN39@convert_bo

; 3266 :          mi->expr[0] = bdry->convect[0];

	mov	edx, DWORD PTR [ebx+96]
	mov	DWORD PTR [eax+232], edx

; 3267 :       else

	jmp	SHORT $LN35@convert_bo
$LN39@convert_bo:

; 3268 :         for ( k = 0 ; k < SDIM ; k++ ) 

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN35@convert_bo
	lea	ecx, DWORD PTR [eax+232]
	lea	eax, DWORD PTR [ebx+96]
$LL37@convert_bo:

; 3269 :            mi->expr[k] = bdry->convect[k];

	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebx
	inc	edx
	add	eax, 4
	add	ecx, 4
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL37@convert_bo

; 3268 :         for ( k = 0 ; k < SDIM ; k++ ) 

	mov	ebx, DWORD PTR _bdry$91364[ebp]
$LN35@convert_bo:

; 3270 :       attach_method_num(get_body_volquant(b_id),meth1);

	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	edx, DWORD PTR [ecx+404]
	push	edi
	push	edx
	call	_attach_method_num
	mov	edi, DWORD PTR _web+348
	add	esp, 8
$LN46@convert_bo:

; 3250 :     FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LL47@convert_bo
$LN50@convert_bo:

; 3240 :       }
; 3241 :       }
; 3242 :     }
; 3243 :   }
; 3244 : 
; 3245 :   /* boundary content integrals */
; 3246 :   for ( j = 0 ; j < web.bdrymax ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	add	DWORD PTR tv3483[ebp], 136		; 00000088H
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _web+768
	jl	$LL51@convert_bo
	mov	edi, DWORD PTR _web+12
$LN337@convert_bo:

; 3271 :     }
; 3272 :   }
; 3273 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	$LN34@convert_bo

; 3274 :   { vertex_id v_id;
; 3275 :     FOR_ALL_VERTICES(v_id)

	mov	ebx, DWORD PTR _web+48
	mov	DWORD PTR _v_id$91388[ebp], ebx
	test	ebx, 268435456				; 10000000H
	je	$LN13@convert_bo
	mov	esi, DWORD PTR _V_BOUNDARY_ATTR
$LL33@convert_bo:
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+edi]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv2764[ebp], ebx
	je	$LN32@convert_bo

; 3276 :     { struct boundary *bdry = get_boundary(v_id);  

	test	esi, esi
	je	$LN32@convert_bo
	mov	eax, DWORD PTR _dymem
	mov	edx, esi
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+eax+64]
	mov	ebx, DWORD PTR [edx+ecx]
	imul	ebx, 136				; 00000088H
	add	ebx, DWORD PTR _web+776

; 3277 :       edge_id first_e;
; 3278 :       if ( !bdry || !(bdry->attr & CON_CONTENT) ) continue;

	je	$LN344@convert_bo
	mov	eax, DWORD PTR [ebx+32]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	$LN344@convert_bo

; 3279 :       first_e = e_id = get_vertex_edge(v_id);

	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR _e_id$[ebp], ecx
	mov	DWORD PTR _first_e$91404[ebp], ecx

; 3280 :       if ( valid_id(e_id) )

	test	ecx, 268435456				; 10000000H
	je	$LN344@convert_bo
	mov	edx, DWORD PTR _web+328
	mov	edi, DWORD PTR _web+236
$LL25@convert_bo:

; 3281 :       do
; 3282 :       { facetedge_id first_fe = fe = get_edge_fe(e_id);

	mov	eax, DWORD PTR _e_id$[ebp]
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2373[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	test	eax, eax
	jne	SHORT $LN244@convert_bo
	xor	ecx, ecx
	jmp	SHORT $LN243@convert_bo
$LN244@convert_bo:
	test	DWORD PTR _e_id$[ebp], 134217728	; 08000000H
	mov	ecx, DWORD PTR [eax+28]
	je	SHORT $LN243@convert_bo
	xor	ecx, 134217728				; 08000000H
$LN243@convert_bo:
	mov	DWORD PTR _fe$[ebp], ecx
	mov	DWORD PTR _first_fe$91413[ebp], ecx

; 3283 :         if ( valid_id(fe) && !(get_eattr(e_id) & NONCONTENT) ) 

	test	ecx, 268435456				; 10000000H
	je	$LN19@convert_bo
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN19@convert_bo
	npad	9
$LL21@convert_bo:

; 3284 :         do
; 3285 :         { f_id = get_fe_facet(fe);

	test	DWORD PTR _fe$[ebp], 268435456		; 10000000H
	jne	SHORT $LN248@convert_bo
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN247@convert_bo
$LN248@convert_bo:
	mov	eax, DWORD PTR _fe$[ebp]
	mov	esi, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN247@convert_bo
	xor	esi, 134217728				; 08000000H
$LN247@convert_bo:

; 3286 :           b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN254@convert_bo
	xor	eax, eax
	jmp	SHORT $LN251@convert_bo
$LN254@convert_bo:
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN253@convert_bo
	xor	eax, eax
	jmp	SHORT $LN251@convert_bo
$LN253@convert_bo:
	test	esi, 134217728				; 08000000H
	je	SHORT $LN252@convert_bo
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax+784]
	mov	eax, DWORD PTR [ecx+eax+4]
	jmp	SHORT $LN251@convert_bo
$LN252@convert_bo:
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx+784]
	mov	eax, DWORD PTR [eax+ecx]
$LN251@convert_bo:

; 3287 :           if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN18@convert_bo

; 3288 :           {
; 3289 :             sprintf(inst_name1,"body_%d_bdry_%s_meth",ordinal(b_id)+1,bdry->name);

	and	eax, 134217727				; 07ffffffH
	push	ebx
	inc	eax
	push	eax
	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	OFFSET ??_C@_0BF@MHGGIEFG@body_?$CFd_bdry_?$CFs_meth?$AA@
	push	edx
	call	_sprintf

; 3290 :             meth1 = find_method_instance(inst_name1);

	lea	eax, DWORD PTR _inst_name1$[ebp]
	push	eax
	call	_find_method_instance

; 3291 :             apply_method_num(v_id,meth1);

	mov	ecx, DWORD PTR _v_id$91388[ebp]
	push	eax
	push	ecx
	call	_apply_method_num
	mov	edx, DWORD PTR _web+328
	mov	edi, DWORD PTR _web+236
	add	esp, 28					; 0000001cH
$LN18@convert_bo:

; 3292 :           }
; 3293 :           b_id = get_facet_body(inverse_id(f_id));

	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN260@convert_bo
	xor	eax, eax
	jmp	SHORT $LN257@convert_bo
$LN260@convert_bo:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN259@convert_bo
	xor	eax, eax
	jmp	SHORT $LN257@convert_bo
$LN259@convert_bo:
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx+784]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN258@convert_bo
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN257@convert_bo
$LN258@convert_bo:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN257@convert_bo:

; 3294 :           if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN17@convert_bo

; 3295 :           {
; 3296 :             sprintf(inst_name1,"body_%d_bdry_%s_meth",ordinal(b_id)+1,bdry->name);

	and	eax, 134217727				; 07ffffffH
	push	ebx
	inc	eax
	push	eax
	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	OFFSET ??_C@_0BF@MHGGIEFG@body_?$CFd_bdry_?$CFs_meth?$AA@
	push	edx
	call	_sprintf

; 3297 :             meth1 = find_method_instance(inst_name1);

	lea	eax, DWORD PTR _inst_name1$[ebp]
	push	eax
	call	_find_method_instance

; 3298 :             apply_method_num(inverse_id(v_id),meth1);

	mov	ecx, DWORD PTR _v_id$91388[ebp]
	push	eax
	xor	ecx, 134217728				; 08000000H
	push	ecx
	call	_apply_method_num
	mov	edx, DWORD PTR _web+328
	mov	edi, DWORD PTR _web+236
	add	esp, 28					; 0000001cH
$LN17@convert_bo:

; 3299 :           }
; 3300 :           fe = get_next_facet(fe);

	mov	eax, DWORD PTR _fe$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN264@convert_bo
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN360@convert_bo
$LN264@convert_bo:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+40]
$LN360@convert_bo:
	mov	DWORD PTR _fe$[ebp], eax

; 3301 :         } while ( !equal_id(fe,first_fe) );

	cmp	eax, DWORD PTR _first_fe$91413[ebp]
	jne	$LL21@convert_bo
$LN19@convert_bo:

; 3302 :         e_id = get_next_tail_edge(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	eax, DWORD PTR _web+124
	mov	esi, DWORD PTR tv2373[ebp]
	mov	eax, DWORD PTR [esi+eax]
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4+32]
	mov	DWORD PTR _e_id$[ebp], eax

; 3303 :       } while ( !equal_id(first_e,e_id));

	cmp	DWORD PTR _first_e$91404[ebp], eax
	jne	$LL25@convert_bo
	mov	edi, DWORD PTR _web+12
	mov	esi, DWORD PTR _V_BOUNDARY_ATTR
$LN344@convert_bo:
	mov	ebx, DWORD PTR tv2764[ebp]
$LN32@convert_bo:

; 3274 :   { vertex_id v_id;
; 3275 :     FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR _v_id$91388[ebp], ebx
	test	ebx, 268435456				; 10000000H
	jne	$LL33@convert_bo
	pop	edi
	pop	esi
	pop	ebx

; 3332 :     }
; 3333 :   }
; 3334 : 
; 3335 :   /* done in convert_new_body...
; 3336 :   if ( web.pressure_flag )
; 3337 :     FOR_ALL_BODIES(b_id)
; 3338 :       create_pressure_quant(b_id);
; 3339 :    */
; 3340 : } // end convert_bodies_to_quantities()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@convert_bo:

; 3304 :     }
; 3305 :   }
; 3306 :   else  /* SOAPFILM */
; 3307 :   { FOR_ALL_EDGES(e_id)

	mov	ebx, DWORD PTR _web+160
	test	ebx, 268435456				; 10000000H
	je	$LN13@convert_bo
	mov	edi, DWORD PTR _E_BOUNDARY_ATTR
	npad	3
$LL15@convert_bo:
	mov	edx, DWORD PTR _web+124
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv2373[ebp], esi
	je	$LN14@convert_bo

; 3308 :     { struct boundary *bdry = get_edge_boundary(e_id);  

	test	edi, edi
	je	$LN14@convert_bo
	mov	edx, DWORD PTR _dymem
	mov	eax, edi
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edx+64]
	mov	esi, DWORD PTR [eax+ecx]
	imul	esi, 136				; 00000088H
	add	esi, DWORD PTR _web+776

; 3309 :       facetedge_id first_fe;
; 3310 :       if ( !bdry || !(bdry->attr & CON_CONTENT) ) continue;

	je	$LN340@convert_bo
	mov	eax, DWORD PTR [esi+32]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	$LN340@convert_bo

; 3311 :       first_fe = fe = get_edge_fe(e_id);

	test	ecx, ecx
	je	SHORT $LN269@convert_bo
$LN270@convert_bo:
	mov	ecx, DWORD PTR [ecx+28]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN269@convert_bo
	xor	ecx, 134217728				; 08000000H
$LN269@convert_bo:
	mov	DWORD PTR _fe$[ebp], ecx
	mov	DWORD PTR _first_fe$91445[ebp], ecx

; 3312 :       if ( valid_id(fe) )

	test	ecx, 268435456				; 10000000H
	je	$LN340@convert_bo
	npad	1
$LL7@convert_bo:

; 3313 :       do
; 3314 :       { f_id = get_fe_facet(fe);

	mov	ecx, DWORD PTR _fe$[ebp]
	mov	edx, DWORD PTR _web+460
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN274@convert_bo
	mov	edi, DWORD PTR _NULLFACET
	jmp	SHORT $LN275@convert_bo
$LN274@convert_bo:
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN273@convert_bo
	xor	eax, 134217728				; 08000000H
$LN273@convert_bo:
	mov	edi, eax
$LN275@convert_bo:

; 3315 :         fe = get_next_facet(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN278@convert_bo
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx+36]
	xor	edx, 134217728				; 08000000H
	mov	DWORD PTR _fe$[ebp], edx
	jmp	SHORT $LN277@convert_bo
$LN278@convert_bo:
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _fe$[ebp], ecx
$LN277@convert_bo:

; 3316 :         if ( !valid_id(f_id) ) continue;

	test	edi, 268435456				; 10000000H
	je	$LN6@convert_bo

; 3317 :         if ( get_fattr(f_id) & NONCONTENT ) continue;

	mov	eax, DWORD PTR _web+236
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 536870912				; 20000000H
	xor	edx, edx
	or	eax, edx
	jne	$LN6@convert_bo

; 3318 :         b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, edx
	je	SHORT $LN281@convert_bo
$LN284@convert_bo:
	test	edi, 134217728				; 08000000H
	je	SHORT $LN282@convert_bo
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+328
	mov	edx, DWORD PTR [edx+eax+784]
	mov	eax, DWORD PTR [edx+ecx+4]
	jmp	SHORT $LN281@convert_bo
$LN282@convert_bo:
	mov	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+784]
	mov	eax, DWORD PTR [ecx+eax]
$LN281@convert_bo:

; 3319 :         
; 3320 :         if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN2@convert_bo

; 3321 :         { sprintf(inst_name1,"body_%d_bdry_%s_meth",ordinal(b_id)+1,bdry->name);

	and	eax, 134217727				; 07ffffffH
	push	esi
	inc	eax
	push	eax
	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	OFFSET ??_C@_0BF@MHGGIEFG@body_?$CFd_bdry_?$CFs_meth?$AA@
	push	ecx
	call	_sprintf

; 3322 :           meth1 = find_method_instance(inst_name1);

	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
	call	_find_method_instance

; 3323 :           apply_method_num(inverse_id(e_id),meth1);

	push	eax
	mov	eax, ebx
	xor	eax, 134217728				; 08000000H
	push	eax
	call	_apply_method_num
	add	esp, 28					; 0000001cH
$LN2@convert_bo:

; 3324 :         }
; 3325 :         b_id = get_facet_body(inverse_id(f_id));

	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN290@convert_bo
	xor	eax, eax
	jmp	SHORT $LN287@convert_bo
$LN290@convert_bo:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN289@convert_bo
	xor	eax, eax
	jmp	SHORT $LN287@convert_bo
$LN289@convert_bo:
	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN288@convert_bo
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]
	jmp	SHORT $LN287@convert_bo
$LN288@convert_bo:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]
$LN287@convert_bo:

; 3326 :         if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN6@convert_bo

; 3327 :         { sprintf(inst_name1,"body_%d_bdry_%s_meth",ordinal(b_id)+1,bdry->name);

	and	eax, 134217727				; 07ffffffH
	push	esi
	inc	eax
	push	eax
	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	OFFSET ??_C@_0BF@MHGGIEFG@body_?$CFd_bdry_?$CFs_meth?$AA@
	push	ecx
	call	_sprintf

; 3328 :           meth1 = find_method_instance(inst_name1);

	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
	call	_find_method_instance

; 3329 :           apply_method_num(e_id,meth1);

	push	eax
	push	ebx
	call	_apply_method_num
	add	esp, 28					; 0000001cH
$LN6@convert_bo:

; 3330 :         }
; 3331 :       } while ( !equal_id(fe,first_fe) );

	mov	eax, DWORD PTR _first_fe$91445[ebp]
	cmp	DWORD PTR _fe$[ebp], eax
	jne	$LL7@convert_bo
	mov	edi, DWORD PTR _E_BOUNDARY_ATTR
$LN340@convert_bo:
	mov	esi, DWORD PTR tv2373[ebp]
$LN14@convert_bo:

; 3304 :     }
; 3305 :   }
; 3306 :   else  /* SOAPFILM */
; 3307 :   { FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [esi+ecx]
	mov	ebx, DWORD PTR [edx]
	test	ebx, 268435456				; 10000000H
	jne	$LL15@convert_bo
$LN13@convert_bo:

; 3332 :     }
; 3333 :   }
; 3334 : 
; 3335 :   /* done in convert_new_body...
; 3336 :   if ( web.pressure_flag )
; 3337 :     FOR_ALL_BODIES(b_id)
; 3338 :       create_pressure_quant(b_id);
; 3339 :    */
; 3340 : } // end convert_bodies_to_quantities()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_convert_bodies_to_quantities ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@NBMEGDLE@?$CFs?5formula?$AA@		; `string'
PUBLIC	??_C@_0FO@OHFMEMCN@?9ambient_pressure_value?$CK?$CIbody?$FL?$CFd@ ; `string'
PUBLIC	??_C@_06LPHIKPID@?4value?$AA@			; `string'
PUBLIC	??_C@_01MIFGBAGJ@?$CL?$AA@			; `string'
PUBLIC	??_C@_0BC@MIDBFOKC@body?$FL?$CFd?$FN?4volconst?$AA@ ; `string'
PUBLIC	??_C@_0BH@EBJHIOOD@body_?$CFd_ambient_energy?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_create_pressure_quant
EXTRN	_temp_free:PROC
EXTRN	_compound_quant_list_head:DWORD
EXTRN	_line_no:DWORD
EXTRN	_msg:DWORD
EXTRN	_find_quantity:PROC
EXTRN	_kb_temp_calloc:PROC
;	COMDAT ??_C@_0L@NBMEGDLE@?$CFs?5formula?$AA@
CONST	SEGMENT
??_C@_0L@NBMEGDLE@?$CFs?5formula?$AA@ DB '%s formula', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@OHFMEMCN@?9ambient_pressure_value?$CK?$CIbody?$FL?$CFd@
CONST	SEGMENT
??_C@_0FO@OHFMEMCN@?9ambient_pressure_value?$CK?$CIbody?$FL?$CFd@ DB '-am'
	DB	'bient_pressure_value*(body[%d].target*(log(%s)-log(body[%d].t'
	DB	'arget))-(%s-body[%d].target))', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LPHIKPID@?4value?$AA@
CONST	SEGMENT
??_C@_06LPHIKPID@?4value?$AA@ DB '.value', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01MIFGBAGJ@?$CL?$AA@
CONST	SEGMENT
??_C@_01MIFGBAGJ@?$CL?$AA@ DB '+', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MIDBFOKC@body?$FL?$CFd?$FN?4volconst?$AA@
CONST	SEGMENT
??_C@_0BC@MIDBFOKC@body?$FL?$CFd?$FN?4volconst?$AA@ DB 'body[%d].volconst'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@EBJHIOOD@body_?$CFd_ambient_energy?$AA@
CONST	SEGMENT
??_C@_0BH@EBJHIOOD@body_?$CFd_ambient_energy?$AA@ DB 'body_%d_ambient_ene'
	DB	'rgy', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _create_pressure_quant
_TEXT	SEGMENT
tv353 = -1036						; size = 4
tv369 = -1032						; size = 4
tv361 = -1028						; size = 4
_q$91476 = -1024					; size = 4
_mc$91472 = -1020					; size = 4
_j$91478 = -1016					; size = 4
_formula$91474 = -1012					; size = 4
_volsum$91473 = -1008					; size = 4
_qname$91475 = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_b_id$ = 8						; size = 4
_create_pressure_quant PROC				; COMDAT

; 3349 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1036				; 0000040cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3350 :   if ( web.pressure_flag )

	cmp	DWORD PTR _web+868, 0
	push	ebx
	mov	ebx, DWORD PTR _b_id$[ebp]
	je	$LN7@create_pre

; 3351 :   { /* create formula and do compound quantity */
; 3352 :     int gq = get_body_volquant(b_id);

	mov	eax, DWORD PTR _web+348

; 3353 :     int mc = GEN_QUANT(gq)->method_count;

	mov	edx, DWORD PTR _gen_quant_list
	push	esi
	push	edi
	mov	edi, ebx
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	esi, DWORD PTR [ecx+404]
	imul	esi, 368				; 00000170H
	mov	eax, DWORD PTR [esi+edx+240]

; 3354 :     char *volsum = temp_calloc(40,mc);

	push	3354					; 00000d1aH
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	eax
	push	40					; 00000028H
	mov	DWORD PTR tv353[ebp], edi
	mov	DWORD PTR tv361[ebp], esi
	mov	DWORD PTR _mc$91472[ebp], eax
	call	_kb_temp_calloc
	mov	DWORD PTR _volsum$91473[ebp], eax

; 3355 :     char *formula = temp_calloc(2,40*mc + 100);

	mov	eax, DWORD PTR _mc$91472[ebp]
	push	3355					; 00000d1bH
	lea	eax, DWORD PTR [eax+eax*4]
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	lea	ecx, DWORD PTR [eax*8+100]
	push	ecx
	push	2
	call	_kb_temp_calloc

; 3356 :     char qname[1000];
; 3357 :     int q,i,j;
; 3358 : 
; 3359 :     sprintf(qname,"body_%d_ambient_energy",ordinal(b_id)+1);

	shr	ebx, 28					; 0000001cH
	add	esp, 32					; 00000020H
	and	ebx, 1
	mov	DWORD PTR _formula$91474[ebp], eax
	mov	DWORD PTR tv369[ebp], ebx
	je	SHORT $LN10@create_pre
	mov	eax, edi
	jmp	SHORT $LN11@create_pre
$LN10@create_pre:
	or	eax, -1
$LN11@create_pre:
	inc	eax
	push	eax
	lea	edx, DWORD PTR _qname$91475[ebp]
	push	OFFSET ??_C@_0BH@EBJHIOOD@body_?$CFd_ambient_energy?$AA@
	push	edx
	call	_sprintf

; 3360 :     q = find_quantity(qname);

	lea	eax, DWORD PTR _qname$91475[ebp]
	push	eax
	call	_find_quantity
	add	esp, 16					; 00000010H
	mov	DWORD PTR _q$91476[ebp], eax

; 3361 :     if ( q < 0 ) q = new_quantity(qname,Q_INFO);

	test	eax, eax
	jns	SHORT $LN24@create_pre
	lea	ecx, DWORD PTR _qname$91475[ebp]
	push	4
	push	ecx
	call	_new_quantity
	add	esp, 8
	mov	DWORD PTR _q$91476[ebp], eax
$LN24@create_pre:

; 3362 :     set_body_ambquant(b_id,q);

	mov	edx, DWORD PTR _web+348
	mov	ecx, DWORD PTR [edx+edi*4]

; 3363 :     GEN_QUANT(q)->flags |= DEFAULT_QUANTITY;

	mov	ebx, eax
	imul	ebx, 368				; 00000170H
	mov	DWORD PTR [ecx+408], eax
	mov	eax, DWORD PTR _gen_quant_list
	or	DWORD PTR [ebx+eax+136], 8192		; 00002000H

; 3364 :     sprintf(volsum,"body[%d].volconst",ordinal(b_id)+1);

	cmp	DWORD PTR tv369[ebp], 0
	je	SHORT $LN12@create_pre
	mov	eax, edi
	jmp	SHORT $LN13@create_pre
$LN12@create_pre:
	or	eax, -1
$LN13@create_pre:
	mov	edx, DWORD PTR _volsum$91473[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_0BC@MIDBFOKC@body?$FL?$CFd?$FN?4volconst?$AA@
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 3365 :     for ( j = 0 ; j < mc ; j++ )

	cmp	DWORD PTR _mc$91472[ebp], 0
	mov	DWORD PTR _j$91478[ebp], 0
	jle	$LN3@create_pre
$LL5@create_pre:

; 3366 :     { int m = GEN_QUANT(gq)->meth_inst[j];
; 3367 :       struct method_instance *mi = METH_INSTANCE(m);

	mov	eax, DWORD PTR _gen_quant_list
	mov	ecx, DWORD PTR [esi+eax+244]
	mov	edx, DWORD PTR _j$91478[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]

; 3368 :       strcat(volsum,((mi->modulus > 0.0) ? "+" : "+"));

	mov	edi, DWORD PTR _volsum$91473[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list
	dec	edi
	npad	3
$LL20@create_pre:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL20@create_pre
	mov	cx, WORD PTR ??_C@_01MIFGBAGJ@?$CL?$AA@
	mov	WORD PTR [edi], cx

; 3369 :       strcat(volsum,mi->name);

	mov	ecx, eax
	mov	esi, eax
$LL21@create_pre:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL21@create_pre
	mov	edi, DWORD PTR _volsum$91473[ebp]
	sub	ecx, esi
	mov	edx, ecx
	dec	edi
$LL22@create_pre:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL22@create_pre
	mov	ecx, edx
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb

; 3370 :       strcat(volsum,".value");

	mov	ecx, DWORD PTR _volsum$91473[ebp]
	dec	ecx
$LL23@create_pre:
	mov	dl, BYTE PTR [ecx+1]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL23@create_pre
	mov	edx, DWORD PTR ??_C@_06LPHIKPID@?4value?$AA@
	mov	esi, DWORD PTR tv361[ebp]
	mov	DWORD PTR [ecx], edx
	mov	dx, WORD PTR ??_C@_06LPHIKPID@?4value?$AA@+4
	mov	WORD PTR [ecx+4], dx
	mov	dl, BYTE PTR ??_C@_06LPHIKPID@?4value?$AA@+6
	mov	BYTE PTR [ecx+6], dl

; 3371 :       mi->flags |= Q_COMPOUND;

	or	DWORD PTR [eax+140], 256		; 00000100H
	mov	eax, DWORD PTR _j$91478[ebp]
	inc	eax
	mov	DWORD PTR _j$91478[ebp], eax
	cmp	eax, DWORD PTR _mc$91472[ebp]
	jl	$LL5@create_pre

; 3365 :     for ( j = 0 ; j < mc ; j++ )

	mov	edi, DWORD PTR tv353[ebp]
$LN3@create_pre:

; 3372 :     }
; 3373 :     GEN_QUANT(q)->method_count = 0;
; 3374 :     i = ordinal(b_id)+1;

	cmp	DWORD PTR tv369[ebp], 0
	mov	eax, DWORD PTR _gen_quant_list
	mov	DWORD PTR [ebx+eax+240], 0
	je	SHORT $LN16@create_pre
	mov	eax, edi
	jmp	SHORT $LN17@create_pre
$LN16@create_pre:
	or	eax, -1
$LN17@create_pre:

; 3375 :     sprintf(formula,"-ambient_pressure_value*(body[%d].target*(log(%s)-log(body[%d].target))-(%s-body[%d].target))",
; 3376 :        i,volsum,i,volsum,i);

	mov	ecx, DWORD PTR _volsum$91473[ebp]
	inc	eax
	push	eax
	push	ecx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _formula$91474[ebp]
	push	eax
	push	OFFSET ??_C@_0FO@OHFMEMCN@?9ambient_pressure_value?$CK?$CIbody?$FL?$CFd@
	push	ecx
	call	_sprintf

; 3377 :     cmdptr = formula;
; 3378 :     exparse(0,&(GEN_QUANT(q)->expr),USERCOPY); line_no--;

	mov	eax, DWORD PTR _gen_quant_list
	mov	edx, DWORD PTR _formula$91474[ebp]
	push	1
	lea	ecx, DWORD PTR [ebx+eax+256]
	push	ecx
	push	0
	mov	DWORD PTR _cmdptr, edx
	call	_exparse

; 3379 :     sprintf(msg,"%s formula",qname);

	mov	eax, DWORD PTR _msg
	dec	DWORD PTR _line_no
	lea	edx, DWORD PTR _qname$91475[ebp]
	push	edx
	push	OFFSET ??_C@_0L@NBMEGDLE@?$CFs?5formula?$AA@
	push	eax
	call	_sprintf

; 3380 :     strncpy(GEN_QUANT(q)->expr.name,msg,EXPNAMESIZE-1);

	mov	ecx, DWORD PTR _msg
	mov	edx, DWORD PTR _gen_quant_list
	push	63					; 0000003fH
	push	ecx
	lea	eax, DWORD PTR [ebx+edx+276]
	push	eax
	call	_strncpy

; 3381 :     cmdptr = NULL;
; 3382 :     GEN_QUANT(q)->flags |= Q_COMPOUND;

	mov	eax, DWORD PTR _gen_quant_list
	xor	ecx, ecx
	mov	DWORD PTR _cmdptr, ecx
	or	DWORD PTR [ebx+eax+136], 256		; 00000100H

; 3383 :     GEN_QUANT(q)->next_compound = compound_quant_list_head;

	mov	edx, DWORD PTR _compound_quant_list_head
	mov	eax, DWORD PTR _gen_quant_list
	mov	DWORD PTR [ebx+eax+360], edx

; 3384 :     compound_quant_list_head = q;

	mov	edx, DWORD PTR _q$91476[ebp]

; 3385 :     if ( get_battr(b_id) & FIXEDVOL ) 

	mov	eax, DWORD PTR _web+348
	mov	DWORD PTR _compound_quant_list_head, edx
	mov	edi, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 32					; 00000020H
	add	esp, 64					; 00000040H
	or	eax, ecx

; 3386 :        GEN_QUANT(q)->flags |= Q_ENERGY;

	mov	eax, DWORD PTR _gen_quant_list
	je	SHORT $LN2@create_pre
	or	DWORD PTR [ebx+eax+136], 1
	jmp	SHORT $LN1@create_pre
$LN2@create_pre:

; 3387 :     else   GEN_QUANT(q)->flags |= Q_INFO;

	or	DWORD PTR [ebx+eax+136], 4
$LN1@create_pre:

; 3388 :     GEN_QUANT(gq)->flags &= ~Q_FIXED;

	mov	eax, DWORD PTR _gen_quant_list
	and	DWORD PTR [esi+eax+136], -3		; fffffffdH

; 3389 :     GEN_QUANT(gq)->flags |= Q_INFO;
; 3390 :     temp_free(volsum);

	mov	ecx, DWORD PTR _volsum$91473[ebp]
	mov	eax, DWORD PTR _gen_quant_list
	or	DWORD PTR [esi+eax+136], 4
	push	ecx
	call	_temp_free

; 3391 :     temp_free(formula);

	mov	edx, DWORD PTR _formula$91474[ebp]
	push	edx
	call	_temp_free
	add	esp, 8
	pop	edi
	pop	esi
$LN7@create_pre:

; 3392 :   }  
; 3393 : } // end create_pressure_quant()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_create_pressure_quant ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@GBDLOEDI@Array?5initializer?5has?5too?5many?5d@ ; `string'
PUBLIC	??_C@_0CN@JOEKDCPM@Illegal?5token?5?$CC?$CFs?$CC?5in?5array?5init@ ; `string'
PUBLIC	??_C@_0BI@ECCJKJJA@Too?5many?5initializers?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CK@BCOGNCDN@Missing?5?8?$HL?8?$DL?5expected?5array?5init@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_read_array_initializer
EXTRN	_yytext:DWORD
EXTRN	_read_single_value:PROC
;	COMDAT ??_C@_0CM@GBDLOEDI@Array?5initializer?5has?5too?5many?5d@
CONST	SEGMENT
??_C@_0CM@GBDLOEDI@Array?5initializer?5has?5too?5many?5d@ DB 'Array initi'
	DB	'alizer has too many dimensions.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JOEKDCPM@Illegal?5token?5?$CC?$CFs?$CC?5in?5array?5init@
CONST	SEGMENT
??_C@_0CN@JOEKDCPM@Illegal?5token?5?$CC?$CFs?$CC?5in?5array?5init@ DB 'Il'
	DB	'legal token "%s" in array initialization.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ECCJKJJA@Too?5many?5initializers?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@ECCJKJJA@Too?5many?5initializers?4?6?$AA@ DB 'Too many initiali'
	DB	'zers.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BCOGNCDN@Missing?5?8?$HL?8?$DL?5expected?5array?5init@
CONST	SEGMENT
??_C@_0CK@BCOGNCDN@Missing?5?8?$HL?8?$DL?5expected?5array?5init@ DB 'Miss'
	DB	'ing ''{''; expected array initializer.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _read_array_initializer
_TEXT	SEGMENT
_spots$ = -84						; size = 32
_blocksize$ = -52					; size = 4
tv439 = -48						; size = 4
tv437 = -44						; size = 4
_k$91517 = -40						; size = 4
_spot$ = -40						; size = 4
_items$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_read_array_initializer PROC				; COMDAT

; 3403 : { char *spot;

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _a$[ebp]

; 3404 :     char *spots[MAXARRAYDIMS];
; 3405 :     int depth;
; 3406 :     int blocksize;
; 3407 :     int items[MAXARRAYDIMS];
; 3408 : 
; 3409 :     tok = yylex(); /* should be '{' */

	push	0
	call	_kb_yylex
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _tok, ecx

; 3410 :     if ( tok != '{' )

	cmp	ecx, 123				; 0000007bH
	je	SHORT $LN22@read_array

; 3411 :       kb_error(3041,"Missing '{'; expected array initializer.\n",RECOVERABLE);       

	push	1
	push	OFFSET ??_C@_0CK@BCOGNCDN@Missing?5?8?$HL?8?$DL?5expected?5array?5init@
	push	3041					; 00000be1H
	call	_kb_error
	mov	ecx, DWORD PTR _tok
	add	esp, 12					; 0000000cH
$LN22@read_array:

; 3415 :     spots[depth] = spot;
; 3416 :     blocksize = a->datacount; 

	mov	edx, DWORD PTR [edi+16]
	mov	ebx, DWORD PTR [edi+20]
	lea	eax, DWORD PTR [edi+20]
	xor	esi, esi
	mov	DWORD PTR _blocksize$[ebp], edx
	add	ebx, edi
	lea	edx, DWORD PTR [edi+24]
	mov	DWORD PTR _spots$[ebp], ebx
	mov	DWORD PTR tv437[ebp], edx
	mov	DWORD PTR tv439[ebp], eax
$LN33@read_array:

; 3412 :  
; 3413 :     depth = 0;
; 3414 :     spot = (char *)a + a->datastart;

	mov	DWORD PTR _spot$[ebp], ebx
$LL21@read_array:

; 3417 :     for (;;)
; 3418 :     { 
; 3419 :       if ( depth == a->dim )

	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LN28@read_array

; 3420 :       { int k;
; 3421 :         for ( k = 0 ; ;  )

	mov	DWORD PTR _k$91517[ebp], 0
$LL18@read_array:

; 3422 :         { if ( read_single_value(a->datatype,spot) )

	mov	eax, DWORD PTR [edi+8]
	push	ebx
	push	eax
	call	_read_single_value
	add	esp, 8
	test	eax, eax
	je	SHORT $LN16@read_array

; 3423 :           { if ( k < a->sizes[depth-1] )

	mov	ecx, DWORD PTR tv439[ebp]
	mov	edx, DWORD PTR _k$91517[ebp]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN15@read_array

; 3424 :             { spot += a->itemsize;

	add	ebx, DWORD PTR [edi+12]

; 3425 :               k++;

	inc	DWORD PTR _k$91517[ebp]
	jmp	SHORT $LL18@read_array
$LN15@read_array:

; 3426 :             }
; 3427 :             else kb_error(2132,"Too many initializers.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BI@ECCJKJJA@Too?5many?5initializers?4?6?$AA@
	push	2132					; 00000854H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3428 :           }          
; 3429 :           else

	jmp	SHORT $LL18@read_array
$LN16@read_array:

; 3430 :           { tok = yylex();  /* get back token exparse pushed back */

	push	0
	call	_kb_yylex
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _tok, ecx

; 3431 :             if ( tok != ',' ) 

	cmp	ecx, 44					; 0000002cH

; 3432 :               break;
; 3433 :           }
; 3434 :         }

	je	SHORT $LL18@read_array

; 3424 :             { spot += a->itemsize;

	mov	DWORD PTR _spot$[ebp], ebx
$LN28@read_array:

; 3435 :       }
; 3436 :       if ( tok == '{' )  

	cmp	ecx, 123				; 0000007bH
	jne	SHORT $LN11@read_array

; 3437 :       { 
; 3438 :         if ( blocksize ) blocksize /= a->sizes[depth]; 

	mov	eax, DWORD PTR _blocksize$[ebp]
	test	eax, eax
	je	SHORT $LN10@read_array
	mov	ebx, DWORD PTR tv437[ebp]
	cdq
	idiv	DWORD PTR [ebx]
	mov	ebx, DWORD PTR _spot$[ebp]
	mov	DWORD PTR _blocksize$[ebp], eax
$LN10@read_array:

; 3439 :         spots[depth] = spot;
; 3440 :         items[depth]++;

	inc	DWORD PTR _items$[ebp+esi*4]
	mov	eax, DWORD PTR _items$[ebp+esi*4]
	mov	DWORD PTR _spots$[ebp+esi*4], ebx

; 3441 :         if ( depth > 0 && items[depth] > a->sizes[depth-1] )

	test	esi, esi
	jle	SHORT $LN32@read_array
	mov	edx, DWORD PTR tv439[ebp]
	cmp	eax, DWORD PTR [edx]
	jg	$LN29@read_array
$LN32@read_array:

; 3444 :         }
; 3445 :         depth++; 

	mov	eax, 4
	add	DWORD PTR tv439[ebp], eax
	add	DWORD PTR tv437[ebp], eax

; 3446 :         if ( depth > a->dim )

	mov	eax, DWORD PTR [edi+4]
	inc	esi
	cmp	esi, eax
	jg	$LN30@read_array

; 3448 :           return;
; 3449 :         }
; 3450 :         items[depth] = 0;

	mov	DWORD PTR _items$[ebp+esi*4], 0

; 3451 :         if ( depth != a->dim ) tok = yylex();

	je	$LL21@read_array
	push	0
	call	_kb_yylex
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _tok, ecx

; 3452 :       }
; 3453 :       else if ( tok == '}' )

	jmp	$LL21@read_array
$LN11@read_array:
	cmp	ecx, 125				; 0000007dH
	jne	SHORT $LN5@read_array

; 3454 :       { tok = yylex();

	push	0
	call	_kb_yylex
	mov	ecx, eax

; 3455 :         depth--;

	mov	eax, 4
	sub	DWORD PTR tv439[ebp], eax
	sub	DWORD PTR tv437[ebp], eax
	add	esp, 4
	dec	esi
	mov	DWORD PTR _tok, ecx

; 3456 :         if ( depth == 0 ) return;

	je	$LN31@read_array

; 3457 : 
; 3458 :         blocksize *= a->sizes[depth];

	mov	eax, DWORD PTR tv437[ebp]
	mov	eax, DWORD PTR [eax]
	imul	eax, DWORD PTR _blocksize$[ebp]

; 3459 :         spots[depth] += blocksize*a->itemsize;

	mov	edx, DWORD PTR [edi+12]
	imul	edx, eax
	add	DWORD PTR _spots$[ebp+esi*4], edx
	mov	ebx, DWORD PTR _spots$[ebp+esi*4]
	mov	DWORD PTR _blocksize$[ebp], eax

; 3460 :         spot = spots[depth];

	jmp	$LN33@read_array
$LN5@read_array:

; 3461 :       }
; 3462 :       else if ( tok == ',' )

	cmp	ecx, 44					; 0000002cH
	jne	SHORT $LN2@read_array

; 3463 :       { tok = yylex();

	push	0
	call	_kb_yylex
	mov	ecx, eax
	mov	DWORD PTR _tok, ecx

; 3464 :         spots[depth] += blocksize*a->itemsize;

	mov	eax, DWORD PTR [edi+12]
	imul	eax, DWORD PTR _blocksize$[ebp]
	add	esp, 4
	add	DWORD PTR _spots$[ebp+esi*4], eax

; 3465 :       }
; 3466 :       else 

	jmp	$LL21@read_array
$LN2@read_array:

; 3467 :       { sprintf(errmsg,"Illegal token \"%s\" in array initialization.\n",yytext);

	mov	ecx, DWORD PTR _yytext
	push	ecx
	push	OFFSET ??_C@_0CN@JOEKDCPM@Illegal?5token?5?$CC?$CFs?$CC?5in?5array?5init@
	push	OFFSET _errmsg
	call	_sprintf

; 3468 :         kb_error(2540,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	2540					; 000009ecH
	call	_kb_error

; 3469 :       }
; 3470 :     }

	mov	ecx, DWORD PTR _tok
	add	esp, 24					; 00000018H
	jmp	$LL21@read_array
$LN29@read_array:

; 3442 :         { kb_error(2539,"Too many initializers.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BI@ECCJKJJA@Too?5many?5initializers?4?6?$AA@
	push	2539					; 000009ebH

; 3443 :           return;

	jmp	SHORT $LN34@read_array
$LN30@read_array:

; 3447 :         { kb_error(7398,"Array initializer has too many dimensions.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CM@GBDLOEDI@Array?5initializer?5has?5too?5many?5d@
	push	7398					; 00001ce6H
$LN34@read_array:
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN31@read_array:

; 3471 : } /* end read_array_initializer() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_read_array_initializer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@KILJOOLI@Expecting?5?$FN?4?6?$AA@	; `string'
PUBLIC	??_C@_0CF@CMPKEAMH@Array?5dimension?5cannot?5be?5negati@ ; `string'
PUBLIC	??_C@_0BI@HJEBGFAN@Need?5dimension?5number?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CK@GHBCOGJI@Need?5an?5array?5data?5type?4?5?5Assumi@ ; `string'
PUBLIC	??_C@_0BL@POJMBMDB@Duplicate?5parameter?5name?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CP@GENOAPJF@Array?5name?5already?5in?5use?5for?5so@ ; `string'
PUBLIC	??_C@_0DD@EFGMNCGE@Identifiers?5must?5be?5at?5least?5two@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_define_array
EXTRN	_KB_realloc:PROC
EXTRN	_datatype_size:BYTE
EXTRN	_add_global:PROC
EXTRN	_localbase:DWORD
EXTRN	_lookup_global:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0O@KILJOOLI@Expecting?5?$FN?4?6?$AA@
CONST	SEGMENT
??_C@_0O@KILJOOLI@Expecting?5?$FN?4?6?$AA@ DB 'Expecting ].', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CMPKEAMH@Array?5dimension?5cannot?5be?5negati@
CONST	SEGMENT
??_C@_0CF@CMPKEAMH@Array?5dimension?5cannot?5be?5negati@ DB 'Array dimens'
	DB	'ion cannot be negative.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HJEBGFAN@Need?5dimension?5number?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@HJEBGFAN@Need?5dimension?5number?4?6?$AA@ DB 'Need dimension nu'
	DB	'mber.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@GHBCOGJI@Need?5an?5array?5data?5type?4?5?5Assumi@
CONST	SEGMENT
??_C@_0CK@GHBCOGJI@Need?5an?5array?5data?5type?4?5?5Assumi@ DB 'Need an a'
	DB	'rray data type.  Assuming REAL.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@POJMBMDB@Duplicate?5parameter?5name?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@POJMBMDB@Duplicate?5parameter?5name?4?6?$AA@ DB 'Duplicate para'
	DB	'meter name.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GENOAPJF@Array?5name?5already?5in?5use?5for?5so@
CONST	SEGMENT
??_C@_0CP@GENOAPJF@Array?5name?5already?5in?5use?5for?5so@ DB 'Array name'
	DB	' already in use for something else.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EFGMNCGE@Identifiers?5must?5be?5at?5least?5two@
CONST	SEGMENT
??_C@_0DD@EFGMNCGE@Identifiers?5must?5be?5at?5least?5two@ DB 'Identifiers'
	DB	' must be at least two characters long.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _define_array
_TEXT	SEGMENT
_val$91577 = -52					; size = 8
_datatype$ = -44					; size = 4
_itemsize$ = -40					; size = 4
_sizes$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_define_array PROC					; COMDAT

; 3484 : { int n;

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3485 :   struct global *g;
; 3486 :   struct array *a;
; 3487 :   int dim;
; 3488 :   int size;
; 3489 :   int sizes[MAXARRAYDIMS];
; 3490 :   int itemsize=0;
; 3491 :   int datatype=0;
; 3492 :   size_t rem;
; 3493 : 
; 3494 :   if ( strlen(yytext) < 2 )

	mov	eax, DWORD PTR _yytext
	lea	edx, DWORD PTR [eax+1]
$LL45@define_arr:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL45@define_arr
	sub	eax, edx
	cmp	eax, 2
	jae	SHORT $LN46@define_arr

; 3495 :     kb_error(1867,"Identifiers must be at least two characters long.\n",
; 3496 :             DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DD@EFGMNCGE@Identifiers?5must?5be?5at?5least?5two@
	push	1867					; 0000074bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN46@define_arr:

; 3497 :   n = lookup_global(yytext);

	mov	eax, DWORD PTR _yytext
	push	esi
	push	edi
	push	eax
	call	_lookup_global
	add	esp, 4

; 3498 :   if ( n >= 0 )

	test	eax, eax
	js	$LN23@define_arr

; 3499 :   { 
; 3500 :     g = globals(n);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN27@define_arr
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN29@define_arr
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	mov	esi, eax
	jmp	SHORT $LN28@define_arr
$LN29@define_arr:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN27@define_arr
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN28@define_arr
$LN27@define_arr:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax]
$LN28@define_arr:

; 3501 :     if ( !(g->flags & ARRAY_PARAM) )

	test	DWORD PTR [esi+192], 2048		; 00000800H
	jne	$LN21@define_arr

; 3502 :       kb_error(3213,"Array name already in use for something else.\n",
; 3503 :         DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CP@GENOAPJF@Array?5name?5already?5in?5use?5for?5so@
	push	3213					; 00000c8dH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3504 :   }
; 3505 :   else

	jmp	$LN21@define_arr
$LN23@define_arr:

; 3506 :   { n = add_global(yytext);

	mov	ecx, DWORD PTR _yytext
	push	ecx
	call	_add_global
	mov	esi, eax
	add	esp, 4

; 3507 :     if ( n < 0 )

	test	esi, esi
	jns	SHORT $LN20@define_arr

; 3508 :       kb_error(1673,"Duplicate parameter name.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BL@POJMBMDB@Duplicate?5parameter?5name?4?6?$AA@
	push	1673					; 00000689H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN20@define_arr:

; 3509 :     g = globals(n);

	mov	eax, esi
	and	eax, -16777216				; ff000000H
	and	esi, 16777215				; 00ffffffH
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN37@define_arr
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR [eax+ecx]
	jmp	SHORT $LN34@define_arr
$LN37@define_arr:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN35@define_arr
	mov	edx, DWORD PTR _localbase
	imul	esi, 224				; 000000e0H
	add	esi, DWORD PTR [edx]
	jmp	SHORT $LN34@define_arr
$LN35@define_arr:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN33@define_arr
	mov	eax, DWORD PTR _web+5656
	mov	esi, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN34@define_arr
$LN33@define_arr:
	mov	ecx, DWORD PTR _web+5652
	mov	eax, DWORD PTR _dymem
	lea	edx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [edx+eax]
$LN34@define_arr:

; 3510 :     g->flags |= ARRAY_PARAM;

	or	DWORD PTR [esi+192], 2048		; 00000800H
$LN21@define_arr:
	push	ebx

; 3511 :   }
; 3512 : 
; 3513 :   tok = yylex(); /* dispose of IDENT_ */

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3514 :   if ( tok == DATATYPE_TOK )

	mov	edi, 1
	cmp	eax, 358				; 00000166H
	jne	SHORT $LN19@define_arr

; 3515 :   { datatype = yylval.datatype;

	mov	ebx, DWORD PTR _yylval+28

; 3516 :     itemsize = datatype_size[datatype];

	mov	ecx, DWORD PTR _datatype_size[ebx*4]
	mov	DWORD PTR _datatype$[ebp], ebx
	mov	DWORD PTR _itemsize$[ebp], ecx
	jmp	SHORT $LN16@define_arr
$LN19@define_arr:

; 3517 :   }
; 3518 :   else if ( tok == STRING_TOK ) // since "string" also used for model type

	cmp	eax, 457				; 000001c9H
	jne	SHORT $LN17@define_arr

; 3519 :   { datatype = STRING_TYPE;
; 3520 :     itemsize = datatype_size[datatype];

	mov	edx, DWORD PTR _datatype_size+44
	mov	ebx, 11					; 0000000bH
	mov	DWORD PTR _datatype$[ebp], ebx
	mov	DWORD PTR _itemsize$[ebp], edx

; 3521 :   }
; 3522 :   else

	jmp	SHORT $LN16@define_arr
$LN17@define_arr:

; 3523 :   { kb_error(2130,"Need an array data type.  Assuming REAL.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CK@GHBCOGJI@Need?5an?5array?5data?5type?4?5?5Assumi@
	push	2130					; 00000852H
	call	_kb_error

; 3524 :     datatype = REAL_TYPE;
; 3525 :     itemsize = datatype_size[datatype];

	mov	eax, DWORD PTR _datatype_size+4
	add	esp, 12					; 0000000cH
	mov	ebx, edi
	mov	DWORD PTR _datatype$[ebp], edi
	mov	DWORD PTR _itemsize$[ebp], eax
$LN16@define_arr:

; 3526 :   }
; 3527 :   g->type = datatype;
; 3528 : 
; 3529 :   tok = yylex(); /* dispose of type */

	push	0
	mov	DWORD PTR [esi+200], ebx
	call	_kb_yylex

; 3530 : 
; 3531 :   g->attr.arrayptr = (struct array*)mycalloc(1,sizeof(struct array));

	push	3531					; 00000dcbH
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	56					; 00000038H
	push	edi
	mov	DWORD PTR _tok, eax
	call	_kb_calloc
	mov	DWORD PTR [esi+168], eax
	add	esp, 20					; 00000014H

; 3532 :   g->attr.arrayptr->dim = 0;

	mov	DWORD PTR [eax+4], 0

; 3533 :   while ( tok == '[' )

	cmp	DWORD PTR _tok, 91			; 0000005bH
	jne	$LN14@define_arr
	npad	7
$LL15@define_arr:

; 3534 :   {  REAL val;
; 3535 :      if ( read_const(&val) < 0 )

	lea	ecx, DWORD PTR _val$91577[ebp]
	push	ecx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jns	SHORT $LN13@define_arr

; 3536 :        kb_error(1057,"Need dimension number.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BI@HJEBGFAN@Need?5dimension?5number?4?6?$AA@
	push	1057					; 00000421H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN13@define_arr:

; 3537 :      sizes[g->attr.arrayptr->dim] = (int)val;

	fld	QWORD PTR _val$91577[ebp]
	call	__ftol2_sse
	mov	edx, DWORD PTR [esi+168]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR _sizes$[ebp+ecx*4], eax

; 3538 :      if ( sizes[g->attr.arrayptr->dim] < 0 )

	test	eax, eax
	jns	SHORT $LN12@define_arr

; 3539 :        kb_error(1059,"Array dimension cannot be negative.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CF@CMPKEAMH@Array?5dimension?5cannot?5be?5negati@
	push	1059					; 00000423H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN12@define_arr:

; 3540 :      tok = yylex(); /* get ] */

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 3541 :      if ( tok != ']' ) 

	cmp	eax, 93					; 0000005dH
	je	SHORT $LN11@define_arr

; 3542 :         kb_error(2131,"Expecting ].\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0O@KILJOOLI@Expecting?5?$FN?4?6?$AA@
	push	2131					; 00000853H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN11@define_arr:

; 3543 :      tok = yylex(); /* eat ] */

	push	0
	call	_kb_yylex
	mov	DWORD PTR _tok, eax

; 3544 :      g->attr.arrayptr->dim++;

	mov	eax, DWORD PTR [esi+168]
	add	DWORD PTR [eax+4], edi
	add	esp, 4
	cmp	DWORD PTR _tok, 91			; 0000005bH
	je	$LL15@define_arr
$LN14@define_arr:

; 3545 :   }
; 3546 :   if ( g->attr.arrayptr->dim == 0 ) sizes[g->attr.arrayptr->dim++] = 1;

	mov	eax, DWORD PTR [esi+168]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN10@define_arr
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _sizes$[ebp+ecx*4], edi
	inc	ecx
	mov	DWORD PTR [eax+4], ecx
$LN10@define_arr:

; 3547 : 
; 3548 :   for ( size = 1, dim=0 ; dim < g->attr.arrayptr->dim ; dim++ )

	mov	ecx, DWORD PTR [esi+168]
	xor	eax, eax
	cmp	DWORD PTR [ecx+4], eax
	jle	SHORT $LN7@define_arr
	mov	edx, DWORD PTR [ecx+4]
$LL9@define_arr:

; 3549 :   { size *= sizes[dim];  }

	imul	edi, DWORD PTR _sizes$[ebp+eax*4]
	inc	eax
	cmp	eax, edx
	jl	SHORT $LL9@define_arr

; 3547 : 
; 3548 :   for ( size = 1, dim=0 ; dim < g->attr.arrayptr->dim ; dim++ )

	mov	ebx, DWORD PTR _datatype$[ebp]
$LN7@define_arr:

; 3550 :   a = g->attr.arrayptr = (struct array*)kb_realloc((char*)(g->attr.arrayptr),
; 3551 :        sizeof(struct array)+dim*sizeof(int)
; 3552 :                   + (size+1)*itemsize);  /* extra for alignment */

	lea	edx, DWORD PTR [edi+1]
	imul	edx, DWORD PTR _itemsize$[ebp]
	push	3552					; 00000de0H
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	lea	eax, DWORD PTR [edx+eax*4+56]
	push	eax
	push	ecx
	call	_KB_realloc
	mov	ecx, eax

; 3553 :   a->dim = g->attr.arrayptr->dim;
; 3554 :   a->itemsize = itemsize;

	mov	eax, DWORD PTR _itemsize$[ebp]
	mov	DWORD PTR [esi+168], ecx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+12], eax

; 3555 :   a->datatype = datatype;

	mov	DWORD PTR [ecx+8], ebx
	mov	DWORD PTR [ecx+4], edx

; 3556 :   a->datacount = size;

	mov	DWORD PTR [ecx+16], edi

; 3557 :   for ( dim=0 ; dim < g->attr.arrayptr->dim ; dim++ )

	mov	edx, DWORD PTR [esi+168]
	add	esp, 16					; 00000010H
	xor	eax, eax
	pop	ebx
	cmp	DWORD PTR [edx+4], eax
	jle	SHORT $LN4@define_arr

; 3550 :   a = g->attr.arrayptr = (struct array*)kb_realloc((char*)(g->attr.arrayptr),
; 3551 :        sizeof(struct array)+dim*sizeof(int)
; 3552 :                   + (size+1)*itemsize);  /* extra for alignment */

	lea	edx, DWORD PTR [ecx+24]
	npad	4
$LL6@define_arr:

; 3558 :      a->sizes[dim] = sizes[dim];

	mov	edi, DWORD PTR _sizes$[ebp+eax*4]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [esi+168]
	inc	eax
	add	edx, 4
	cmp	eax, DWORD PTR [edi+4]
	jl	SHORT $LL6@define_arr
$LN4@define_arr:

; 3559 :   a->datastart = sizeof(struct array) + a->dim*sizeof(int);

	mov	edi, DWORD PTR [ecx+4]

; 3560 : 
; 3561 :   /* align datastart to size of item */
; 3562 :   rem = a->datastart % a->itemsize;

	mov	esi, DWORD PTR [ecx+12]
	lea	edi, DWORD PTR [edi*4+56]
	xor	edx, edx
	mov	eax, edi
	div	esi
	mov	DWORD PTR [ecx+20], edi

; 3563 :   if ( rem )

	test	edx, edx
	je	SHORT $LN3@define_arr

; 3564 :      a->datastart += a->itemsize - rem;

	sub	esi, edx
	add	esi, edi
	mov	DWORD PTR [ecx+20], esi
$LN3@define_arr:

; 3565 : 
; 3566 :   /* Initialization */
; 3567 :   if ( (tok == '=') || (tok == ASSIGN_TOK) ) /* have initial values */

	mov	eax, DWORD PTR _tok
	pop	edi
	pop	esi
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN1@define_arr
	cmp	eax, 441				; 000001b9H
	jne	SHORT $LN2@define_arr
$LN1@define_arr:

; 3568 :     read_array_initializer(a);

	push	ecx
	call	_read_array_initializer
	add	esp, 4
$LN2@define_arr:

; 3569 : 
; 3570 : } // end define_array()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_define_array ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@OEOOCKHD@Forward?5declared?5method_instance@ ; `string'
PUBLIC	??_C@_0DA@FOADLABG@Forward?5declared?5quantity?5?$CFs?5not@ ; `string'
PUBLIC	??_C@_0DA@CCCOOFPN@Forward?5declared?5boundary?5?$CFs?5not@ ; `string'
PUBLIC	??_C@_0DC@FMEDFLBG@Forward?5declared?5constraint?5?$CFs?5n@ ; `string'
PUBLIC	_check_forwards
;	COMDAT ??_C@_0DH@OEOOCKHD@Forward?5declared?5method_instance@
CONST	SEGMENT
??_C@_0DH@OEOOCKHD@Forward?5declared?5method_instance@ DB 'Forward declar'
	DB	'ed method_instance %s not instantiated.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FOADLABG@Forward?5declared?5quantity?5?$CFs?5not@
CONST	SEGMENT
??_C@_0DA@FOADLABG@Forward?5declared?5quantity?5?$CFs?5not@ DB 'Forward d'
	DB	'eclared quantity %s not instantiated.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@CCCOOFPN@Forward?5declared?5boundary?5?$CFs?5not@
CONST	SEGMENT
??_C@_0DA@CCCOOFPN@Forward?5declared?5boundary?5?$CFs?5not@ DB 'Forward d'
	DB	'eclared boundary %s not instantiated.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@FMEDFLBG@Forward?5declared?5constraint?5?$CFs?5n@
CONST	SEGMENT
??_C@_0DC@FMEDFLBG@Forward?5declared?5constraint?5?$CFs?5n@ DB 'Forward d'
	DB	'eclared constraint %s not instantiated.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _check_forwards
_TEXT	SEGMENT
_check_forwards PROC					; COMDAT

; 3581 : { int i;

	push	ebx
	push	esi

; 3582 : 
; 3583 :   /* constraints */
; 3584 :   for ( i = 0 ; i < web.maxcon ; i++ )

	xor	esi, esi
	push	edi
	cmp	DWORD PTR _web+644, esi
	jle	SHORT $LN14@check_forw
	npad	3
$LL16@check_forw:

; 3585 :   { struct constraint *con = get_constraint(i);

	mov	eax, esi
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 3586 :     if ( con->attr & CON_FORWARD_DEF )

	xor	edx, edx
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 4096				; 00001000H
	or	ecx, edx
	je	SHORT $LN15@check_forw

; 3587 :     { sprintf(errmsg,"Forward declared constraint %s not instantiated.\n",
; 3588 :              con->name);

	push	eax
	push	OFFSET ??_C@_0DC@FMEDFLBG@Forward?5declared?5constraint?5?$CFs?5n@
	push	OFFSET _errmsg
	call	_sprintf

; 3589 :       kb_error(5911,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5911					; 00001717H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN15@check_forw:

; 3582 : 
; 3583 :   /* constraints */
; 3584 :   for ( i = 0 ; i < web.maxcon ; i++ )

	inc	esi
	cmp	esi, DWORD PTR _web+644
	jl	SHORT $LL16@check_forw
$LN14@check_forw:

; 3590 :     }
; 3591 :   }
; 3592 : 
; 3593 :   /* boundaries */
; 3594 :   for ( i = 0 ; i < web.bdrymax ; i++ )

	xor	edi, edi
	cmp	DWORD PTR _web+768, edi
	jle	SHORT $LN10@check_forw
	xor	esi, esi
	npad	5
$LL12@check_forw:

; 3595 :   { struct boundary *bdry = web.boundaries + i;

	mov	eax, DWORD PTR _web+776
	lea	ecx, DWORD PTR [esi+eax]

; 3596 :     if ( bdry->attr & BDRY_FORWARD_DEF )

	mov	eax, DWORD PTR [ecx+32]
	and	eax, 4096				; 00001000H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN11@check_forw

; 3597 :     { sprintf(errmsg,"Forward declared boundary %s not instantiated.\n",
; 3598 :              bdry->name);

	push	ecx
	push	OFFSET ??_C@_0DA@CCCOOFPN@Forward?5declared?5boundary?5?$CFs?5not@
	push	OFFSET _errmsg
	call	_sprintf

; 3599 :       kb_error(3227,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3227					; 00000c9bH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN11@check_forw:

; 3590 :     }
; 3591 :   }
; 3592 : 
; 3593 :   /* boundaries */
; 3594 :   for ( i = 0 ; i < web.bdrymax ; i++ )

	inc	edi
	add	esi, 136				; 00000088H
	cmp	edi, DWORD PTR _web+768
	jl	SHORT $LL12@check_forw
$LN10@check_forw:

; 3600 :     }
; 3601 :   }
; 3602 : 
; 3603 :   /* quantities */
; 3604 :   for ( i = 0 ; i < gen_quant_count ; i++ )

	xor	edi, edi
	mov	ebx, 1048576				; 00100000H
	cmp	DWORD PTR _web+5528, edi
	jle	SHORT $LN6@check_forw
	xor	esi, esi
	npad	6
$LL8@check_forw:

; 3605 :   { if ( GEN_QUANT(i)->flags & Q_FORWARD_DEF )

	mov	ecx, DWORD PTR _gen_quant_list
	test	DWORD PTR [esi+ecx+136], ebx
	lea	eax, DWORD PTR [esi+ecx]
	je	SHORT $LN7@check_forw

; 3606 :     { sprintf(errmsg,"Forward declared quantity %s not instantiated.\n",
; 3607 :              GEN_QUANT(i)->name);

	push	eax
	push	OFFSET ??_C@_0DA@FOADLABG@Forward?5declared?5quantity?5?$CFs?5not@
	push	OFFSET _errmsg
	call	_sprintf

; 3608 :       kb_error(3225,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3225					; 00000c99H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN7@check_forw:

; 3600 :     }
; 3601 :   }
; 3602 : 
; 3603 :   /* quantities */
; 3604 :   for ( i = 0 ; i < gen_quant_count ; i++ )

	inc	edi
	add	esi, 368				; 00000170H
	cmp	edi, DWORD PTR _web+5528
	jl	SHORT $LL8@check_forw
$LN6@check_forw:

; 3609 :     }
; 3610 :   }
; 3611 : 
; 3612 :   /* method instances */
; 3613 :   for ( i = 1 ; i < meth_inst_count ; i++ )

	mov	esi, 1
	cmp	DWORD PTR _web+5560, esi
	jle	SHORT $LN2@check_forw
$LL4@check_forw:

; 3614 :   { if ( METH_INSTANCE(i)->flags & Q_FORWARD_DEF )

	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list
	test	DWORD PTR [eax+140], ebx
	je	SHORT $LN3@check_forw

; 3615 :     { sprintf(errmsg,"Forward declared method_instance %s not instantiated.\n",
; 3616 :              METH_INSTANCE(i)->name);

	push	eax
	push	OFFSET ??_C@_0DH@OEOOCKHD@Forward?5declared?5method_instance@
	push	OFFSET _errmsg
	call	_sprintf

; 3617 :       kb_error(3226,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3226					; 00000c9aH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN3@check_forw:

; 3609 :     }
; 3610 :   }
; 3611 : 
; 3612 :   /* method instances */
; 3613 :   for ( i = 1 ; i < meth_inst_count ; i++ )

	inc	esi
	cmp	esi, DWORD PTR _web+5560
	jl	SHORT $LL4@check_forw
$LN2@check_forw:
	pop	edi
	pop	esi
	pop	ebx

; 3618 :     }
; 3619 :   }
; 3620 : 
; 3621 : } // end check_forwards()

	ret	0
_check_forwards ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@JGGPBFBL@Need?5constant?5expression?5for?5pde@ ; `string'
PUBLIC	??_C@_0CF@DEFKBMIO@Need?5constant?5expression?5for?5sca@ ; `string'
PUBLIC	??_C@_0DC@KABODIMK@on_assign_call?5must?5be?5followed?5@ ; `string'
PUBLIC	??_C@_0DB@LABGMEKM@on_assign_call?5procedure?5cannot?5@ ; `string'
PUBLIC	??_C@_0CN@PPDAGEAP@Need?5constant?5expression?5for?5ini@ ; `string'
PUBLIC	??_C@_05NCGEDJPM@delta?$AA@			; `string'
PUBLIC	??_C@_0CO@HCJKBOJB@Missing?5?8?$DN?8?5after?5parameter?5name@ ; `string'
PUBLIC	??_C@_0BO@BJMAIJJB@Parameter?5file?5name?5missing?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CM@OGGEJBHM@Too?5high?5element?5number?5in?5param@ ; `string'
PUBLIC	??_C@_06EIDEPFJL@?$CFd?5?$CFlf?$AA@		; `string'
PUBLIC	??_C@_0CA@NCLIFCDD@Cannot?5open?5parameter?5file?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0FJ@OPIDFOC@Too?5many?5optimizing?5parameters?4?5@ ; `string'
PUBLIC	__real@3f1a36e2eb1c432d
PUBLIC	??_C@_0BM@ECCMBLAI@Need?5PARAMETER?5identifier?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@DOBFLHCD@Redefinition?5of?5identifier?5?8?$CFs?8?4@ ; `string'
PUBLIC	_read_parameter
EXTRN	_recovery_flag:DWORD
EXTRN	_kb_stricmp:PROC
EXTRN	_verb_flag:DWORD
EXTRN	_msgmax:DWORD
EXTRN	_optparam:BYTE
EXTRN	_optparamcount:DWORD
EXTRN	_addload_flag:DWORD
;	COMDAT ??_C@_0CG@JGGPBFBL@Need?5constant?5expression?5for?5pde@
CONST	SEGMENT
??_C@_0CG@JGGPBFBL@Need?5constant?5expression?5for?5pde@ DB 'Need constan'
	DB	't expression for pdelta.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DEFKBMIO@Need?5constant?5expression?5for?5sca@
CONST	SEGMENT
??_C@_0CF@DEFKBMIO@Need?5constant?5expression?5for?5sca@ DB 'Need constan'
	DB	't expression for scale.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@KABODIMK@on_assign_call?5must?5be?5followed?5@
CONST	SEGMENT
??_C@_0DC@KABODIMK@on_assign_call?5must?5be?5followed?5@ DB 'on_assign_ca'
	DB	'll must be followed by command name.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LABGMEKM@on_assign_call?5procedure?5cannot?5@
CONST	SEGMENT
??_C@_0DB@LABGMEKM@on_assign_call?5procedure?5cannot?5@ DB 'on_assign_cal'
	DB	'l procedure cannot have arguments.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@PPDAGEAP@Need?5constant?5expression?5for?5ini@
CONST	SEGMENT
??_C@_0CN@PPDAGEAP@Need?5constant?5expression?5for?5ini@ DB 'Need constan'
	DB	't expression for initial value.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NCGEDJPM@delta?$AA@
CONST	SEGMENT
??_C@_05NCGEDJPM@delta?$AA@ DB 'delta', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HCJKBOJB@Missing?5?8?$DN?8?5after?5parameter?5name@
CONST	SEGMENT
??_C@_0CO@HCJKBOJB@Missing?5?8?$DN?8?5after?5parameter?5name@ DB 'Missing'
	DB	' ''='' after parameter name on line %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BJMAIJJB@Parameter?5file?5name?5missing?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@BJMAIJJB@Parameter?5file?5name?5missing?4?6?$AA@ DB 'Parameter '
	DB	'file name missing.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OGGEJBHM@Too?5high?5element?5number?5in?5param@
CONST	SEGMENT
??_C@_0CM@OGGEJBHM@Too?5high?5element?5number?5in?5param@ DB 'Too high el'
	DB	'ement number in parameter file.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EIDEPFJL@?$CFd?5?$CFlf?$AA@
CONST	SEGMENT
??_C@_06EIDEPFJL@?$CFd?5?$CFlf?$AA@ DB '%d %lf', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NCLIFCDD@Cannot?5open?5parameter?5file?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@NCLIFCDD@Cannot?5open?5parameter?5file?5?$CFs?4?6?$AA@ DB 'Cann'
	DB	'ot open parameter file %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@OPIDFOC@Too?5many?5optimizing?5parameters?4?5@
CONST	SEGMENT
??_C@_0FJ@OPIDFOC@Too?5many?5optimizing?5parameters?4?5@ DB 'Too many opt'
	DB	'imizing parameters. Change MAXOPTPARAM in extern.h if you rea'
	DB	'lly need more.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT __real@3f1a36e2eb1c432d
CONST	SEGMENT
__real@3f1a36e2eb1c432d DQ 03f1a36e2eb1c432dr	; 0.0001
CONST	ENDS
;	COMDAT ??_C@_0BM@ECCMBLAI@Need?5PARAMETER?5identifier?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@ECCMBLAI@Need?5PARAMETER?5identifier?4?6?$AA@ DB 'Need PARAMETE'
	DB	'R identifier.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DOBFLHCD@Redefinition?5of?5identifier?5?8?$CFs?8?4@
CONST	SEGMENT
??_C@_0CC@DOBFLHCD@Redefinition?5of?5identifier?5?8?$CFs?8?4@ DB 'Redefin'
	DB	'ition of identifier ''%s''.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _read_parameter
_TEXT	SEGMENT
_val$89446 = -12					; size = 8
_k$89445 = -4						; size = 4
_oldtok$ = -4						; size = 4
_read_parameter PROC					; COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 130  :   int n=0;
; 131  :   struct global *p;
; 132  :   int oldtok = tok; /* whether optimizing */

	mov	eax, DWORD PTR _tok
	push	esi
	push	edi
	xor	esi, esi

; 133  : 
; 134  :   tok = yylex(); /* dispose of PARAMETER */

	push	esi
	mov	DWORD PTR _oldtok$[ebp], eax
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 135  :   if ( tok == IDENT_TOK )

	cmp	eax, 286				; 0000011eH
	jne	$LN48@read_param

; 136  :   { p = globals(yylval.i);

	mov	eax, DWORD PTR _yylval
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN51@read_param
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN53@read_param
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	mov	edi, eax
	jmp	SHORT $LN52@read_param
$LN53@read_param:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN51@read_param
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	edi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN52@read_param
$LN51@read_param:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	edi, DWORD PTR [edx+eax]
$LN52@read_param:

; 137  :     if ( !(p->flags & LEFTOVER) && !addload_flag ) 

	test	DWORD PTR [edi+192], 16384		; 00004000H
	jne	SHORT $LN47@read_param
	cmp	DWORD PTR _addload_flag, esi
	jne	SHORT $LN47@read_param

; 138  :     { sprintf(errmsg,"Redefinition of identifier '%s'.\n",yytext);

	mov	ecx, DWORD PTR _yytext
	push	ecx
	push	OFFSET ??_C@_0CC@DOBFLHCD@Redefinition?5of?5identifier?5?8?$CFs?8?4@
	push	OFFSET _errmsg
	call	_sprintf

; 139  :       kb_error(1671,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1671					; 00000687H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN47@read_param:

; 140  :     }
; 141  :     p->flags &= ~LEFTOVER;

	and	DWORD PTR [edi+192], -16385		; ffffbfffH

; 142  :   }
; 143  :   else 

	jmp	$LN58@read_param
$LN48@read_param:

; 144  :   { if ( tok != NEWIDENT_TOK )

	cmp	eax, 268				; 0000010cH
	je	SHORT $LN45@read_param

; 145  :      { kb_error(1672,"Need PARAMETER identifier.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BM@ECCMBLAI@Need?5PARAMETER?5identifier?4?6?$AA@
	push	1672					; 00000688H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 276  : } // end read_parameter()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@read_param:

; 146  :         return;
; 147  :      }
; 148  :      if ( strlen(yytext) < 2 )

	mov	eax, DWORD PTR _yytext
	lea	edx, DWORD PTR [eax+1]
$LL79@read_param:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL79@read_param
	sub	eax, edx
	cmp	eax, 2
	jae	SHORT $LN44@read_param

; 149  :         kb_error(1480,"Identifiers must be at least two characters long.\n",
; 150  :             DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DD@EFGMNCGE@Identifiers?5must?5be?5at?5least?5two@
	push	1480					; 000005c8H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN44@read_param:

; 151  :      n = add_global(yytext);

	mov	edx, DWORD PTR _yytext
	push	edx
	call	_add_global
	mov	esi, eax
	add	esp, 4

; 152  :      if ( n < 0 )

	test	esi, esi
	jns	SHORT $LN43@read_param

; 153  :          kb_error(1350,"Duplicate parameter name.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BL@POJMBMDB@Duplicate?5parameter?5name?4?6?$AA@
	push	1350					; 00000546H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN43@read_param:

; 154  :      p = globals(n);

	mov	eax, esi
	and	eax, -16777216				; ff000000H
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN61@read_param
	mov	ecx, DWORD PTR _web+5652
	mov	eax, esi
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	edi, DWORD PTR [edx+eax]
	jmp	SHORT $LN58@read_param
$LN61@read_param:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN59@read_param
	mov	ecx, DWORD PTR _localbase
	mov	edi, esi
	and	edi, 16777215				; 00ffffffH
	imul	edi, 224				; 000000e0H
	add	edi, DWORD PTR [ecx]
	jmp	SHORT $LN58@read_param
$LN59@read_param:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN57@read_param
	mov	eax, DWORD PTR _web+5656
	mov	edx, esi
	and	edx, 16777215				; 00ffffffH
	mov	edi, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN58@read_param
$LN57@read_param:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, esi
	and	ecx, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	edi, DWORD PTR [eax+ecx]
$LN58@read_param:

; 155  :   }
; 156  :   p->value.real = 0.0;  /* default */

	fldz
	push	ebx
	fstp	QWORD PTR [edi+64]
	lea	ebx, DWORD PTR [edi+64]

; 157  :   p->type = REAL_TYPE;
; 158  :   p->flags |= ORDINARY_PARAM;
; 159  :   p->attr.varstuff.delta = OPTPARAM_DELTA;

	fld	QWORD PTR __real@3f1a36e2eb1c432d
	mov	eax, 1
	or	DWORD PTR [edi+192], eax
	fstp	QWORD PTR [edi+168]

; 160  :   p->attr.varstuff.pscale = 1.0;
; 161  :   if ( (oldtok == OPTIMIZING_PARAMETER_TOK) && !(p->flags & OPTIMIZING_PARAMETER) )

	cmp	DWORD PTR _oldtok$[ebp], 35021		; 000088cdH
	fld1
	mov	DWORD PTR [edi+200], eax
	fstp	QWORD PTR [edi+176]
	mov	eax, DWORD PTR [edi+192]
	jne	SHORT $LN40@read_param
	test	eax, 32768				; 00008000H
	jne	SHORT $LN40@read_param

; 162  :   { p->flags |= OPTIMIZING_PARAMETER;

	or	eax, 32768				; 00008000H
	mov	DWORD PTR [edi+192], eax

; 163  :      if ( optparamcount >= MAXOPTPARAM-1 )

	mov	eax, DWORD PTR _optparamcount
	cmp	eax, 99					; 00000063H
	jl	SHORT $LN41@read_param

; 164  :         kb_error(1674,"Too many optimizing parameters. Change MAXOPTPARAM in extern.h if you really need more.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0FJ@OPIDFOC@Too?5many?5optimizing?5parameters?4?5@
	push	1674					; 0000068aH
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN40@read_param
$LN41@read_param:

; 165  :      else optparam[optparamcount++].pnum = n;

	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	inc	eax
	mov	DWORD PTR _optparam[edx*8], esi
	mov	DWORD PTR _optparamcount, eax
$LN40@read_param:

; 166  :   }
; 167  : 
; 168  :   tok = yylex(); /* dispose of IDENT_ */

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 169  :   if ( (tok == '=') || (tok == ASSIGN_TOK ) )/* have initial value */

	cmp	eax, 61					; 0000003dH
	je	$LN38@read_param
	cmp	eax, 441				; 000001b9H
	je	$LN38@read_param

; 185  :   }
; 186  :   else if ( tok == PARAMETER_FILE_TOK )

	cmp	eax, 35089				; 00008911H
	jne	$LN31@read_param

; 187  :   {
; 188  :     tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 189  :     if ( tok == QUOTATION_TOK )

	cmp	eax, 309				; 00000135H
	jne	$LN30@read_param

; 190  :     { FILE *pfd = path_open(yytext,NOTDATAFILENAME);

	mov	eax, DWORD PTR _yytext
	push	0
	push	eax
	call	_path_open
	mov	esi, eax
	add	esp, 8

; 191  :       int k;
; 192  :       REAL val; 
; 193  : 
; 194  :       if ( pfd == NULL )

	test	esi, esi
	jne	SHORT $LN29@read_param

; 195  :       { 
; 196  :         sprintf(errmsg, "Cannot open parameter file %s.\n",yytext);

	mov	ecx, DWORD PTR _yytext
	push	ecx
	push	OFFSET ??_C@_0CA@NCLIFCDD@Cannot?5open?5parameter?5file?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 197  :         kb_error(1356,errmsg, DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1356					; 0000054cH
	call	_kb_error
	add	esp, 24					; 00000018H
	pop	ebx
	pop	edi
	pop	esi

; 276  : } // end read_parameter()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@read_param:

; 198  :         return;
; 199  :       }
; 200  :       p->value.file.value_file = mycalloc(strlen(yytext)+1,1);

	mov	eax, DWORD PTR _yytext
	lea	edx, DWORD PTR [eax+1]
$LL80@read_param:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL80@read_param
	push	200					; 000000c8H
	sub	eax, edx
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	inc	eax
	push	1
	push	eax
	call	_kb_calloc
	mov	DWORD PTR [edi+68], eax

; 201  :       strcpy(p->value.file.value_file,yytext);

	mov	ecx, DWORD PTR _yytext
	add	esp, 16					; 00000010H
	mov	edx, eax
	npad	2
$LL64@read_param:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL64@read_param

; 202  :       p->value.file.values = (REAL *)mycalloc(1000,sizeof(REAL));

	push	202					; 000000caH
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	8
	push	1000					; 000003e8H
	call	_kb_calloc
	mov	DWORD PTR [ebx], eax

; 203  :       while ( fgets(msg,msgmax,pfd) )

	mov	edx, DWORD PTR _msgmax
	mov	eax, DWORD PTR _msg
	push	esi
	push	edx
	push	eax
	call	_fgets
	add	esp, 28					; 0000001cH
	test	eax, eax
	je	SHORT $LN83@read_param
	npad	4
$LL28@read_param:

; 204  :       {
; 205  : #ifdef FLOAT128
; 206  :         k = atoi(msg);
; 207  :         strtok(msg," \t");
; 208  :         val = atof(strtok(NULL," \t"));
; 209  : #elif defined(LONGDOUBLE)
; 210  :         sscanf(msg,"%d %Lf",&k,&val);
; 211  : #else
; 212  :         sscanf(msg,"%d %lf",&k,&val);

	mov	eax, DWORD PTR _msg
	lea	ecx, DWORD PTR _val$89446[ebp]
	push	ecx
	lea	edx, DWORD PTR _k$89445[ebp]
	push	edx
	push	OFFSET ??_C@_06EIDEPFJL@?$CFd?5?$CFlf?$AA@
	push	eax
	call	_sscanf

; 213  : #endif
; 214  :         if ( k >= 1000 )

	mov	eax, DWORD PTR _k$89445[ebp]
	add	esp, 16					; 00000010H
	cmp	eax, 1000				; 000003e8H
	jge	SHORT $LN76@read_param

; 216  :           break;
; 217  :         }
; 218  :         p->value.file.values[k] = val;

	mov	ecx, DWORD PTR [ebx]
	fld	QWORD PTR _val$89446[ebp]
	fstp	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR _msgmax
	mov	eax, DWORD PTR _msg
	push	esi
	push	edx
	push	eax
	call	_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LL28@read_param

; 213  : #endif
; 214  :         if ( k >= 1000 )

	jmp	SHORT $LN83@read_param
$LN76@read_param:

; 215  :         { kb_error(1677,"Too high element number in parameter file.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CM@OGGEJBHM@Too?5high?5element?5number?5in?5param@
	push	1677					; 0000068dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN83@read_param:

; 219  :       }
; 220  :       fclose(pfd);

	push	esi
	call	_fclose

; 221  :       p->flags |= FILE_VALUES;

	or	DWORD PTR [edi+192], 2

; 222  :       tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 8

; 223  :     }
; 224  :     else

	jmp	$LN85@read_param
$LN30@read_param:

; 225  :       kb_error(1678,"Parameter file name missing.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BO@BJMAIJJB@Parameter?5file?5name?5missing?4?6?$AA@
	push	1678					; 0000068eH
	call	_kb_error

; 226  : 
; 227  :   }
; 228  :   else

	mov	eax, DWORD PTR _tok
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN82@read_param
$LN31@read_param:

; 229  :   { int errline = line_no;

	mov	esi, DWORD PTR _line_no

; 230  :     unput_tok();

	call	_unput_tok

; 231  :     if ( read_const(&p->value.real) >= 0 )      

	push	ebx
	call	_read_const
	add	esp, 4
	test	eax, eax
	js	SHORT $LN37@read_param

; 232  :     { sprintf(errmsg,"Missing '=' after parameter name on line %d.\n",errline);

	push	esi
	push	OFFSET ??_C@_0CO@HCJKBOJB@Missing?5?8?$DN?8?5after?5parameter?5name@
	push	OFFSET _errmsg
	call	_sprintf

; 233  :       kb_error(2672,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2672					; 00000a70H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN37@read_param:

; 182  :     }
; 183  :     else tok = yylex();  /* get back token exparse pushed back */

	push	0
	call	_kb_yylex
	add	esp, 4
$LN87@read_param:
	mov	DWORD PTR _tok, eax
$LN34@read_param:

; 184  :     if ( tok == ';' ){ verb_flag = 0; tok = yylex();  /* permit ; */ }

	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN82@read_param
	push	0
	mov	DWORD PTR _verb_flag, 0
	call	_kb_yylex
	add	esp, 4
$LN85@read_param:
	mov	DWORD PTR _tok, eax
$LN82@read_param:
	mov	ebx, -2147483648			; 80000000H
$LL21@read_param:

; 234  :     }
; 235  :     tok = yylex();  /* get back token exparse pushed back */
; 236  :     if ( tok == ';' ){ verb_flag = 0; tok = yylex();  /* permit ; */ }
; 237  :   
; 238  :   }
; 239  : 
; 240  :   for (;;)
; 241  :   {
; 242  :     if ( (tok == PDELTA_TOK) || ( stricmp(yytext,"delta") == 0) )

	cmp	eax, 478				; 000001deH
	je	$LN18@read_param
	mov	edx, DWORD PTR _yytext
	push	OFFSET ??_C@_05NCGEDJPM@delta?$AA@
	push	edx
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	$LN18@read_param

; 247  :           else tok = yylex();  /* get back token exparse pushed back */
; 248  :        }
; 249  :     }
; 250  :     else if ( tok == PSCALE_TOK || tok == SCALE_TOK)

	mov	eax, DWORD PTR _tok
	cmp	eax, 405				; 00000195H
	je	$LN11@read_param
	cmp	eax, 404				; 00000194H
	je	$LN11@read_param

; 255  :         else tok = yylex();  /* get back token exparse pushed back */
; 256  :       }
; 257  :     }
; 258  :     else if ( tok == ON_ASSIGN_CALL_TOK )

	cmp	eax, 263				; 00000107H
	jne	$LN5@read_param

; 259  :     { tok = yylex(); /* dispose of ON_ASSIGN_CALL_TOK */

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 260  :       if ( tok == PROCEDURE_IDENT_TOK )

	cmp	eax, 521				; 00000209H
	jne	$LN4@read_param

; 261  :       { struct global *gg = globals(yylval.i);

	mov	eax, DWORD PTR _yylval
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	jne	$LN69@read_param
	mov	edx, DWORD PTR _web+5652
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR [ecx+edx]
	jmp	$LN66@read_param
$LN38@read_param:

; 170  :   { if ( read_const(&p->value.real) < 0 )

	push	ebx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jns	$LN37@read_param

; 171  :     { if ( tok == QUOTATION_TOK )

	cmp	DWORD PTR _tok, 309			; 00000135H
	jne	$LN36@read_param

; 172  :       { p->value.string = mycalloc(strlen(yytext)+2,sizeof(char));

	mov	eax, DWORD PTR _yytext
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL81@read_param:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL81@read_param
	push	172					; 000000acH
	sub	eax, edx
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	add	eax, 2
	push	1
	push	eax
	call	_kb_calloc
	mov	DWORD PTR [ebx], eax

; 173  :         strcpy(p->value.string,yytext);

	mov	ecx, DWORD PTR _yytext
	add	esp, 16					; 00000010H
	mov	edx, eax
	npad	5
$LL63@read_param:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL63@read_param

; 174  :         p->type = STRING_TYPE;
; 175  :         p->flags |= STRINGVAL;
; 176  :         p->flags &= ~ORDINARY_PARAM;

	mov	ecx, DWORD PTR [edi+192]
	and	ecx, -2					; fffffffeH
	or	ecx, 8192				; 00002000H

; 177  :         tok = yylex();  // eat string token

	push	0
	mov	DWORD PTR [edi+200], 11			; 0000000bH
	mov	DWORD PTR [edi+192], ecx
	call	_kb_yylex

; 178  :         tok = yylex();

	push	0
	mov	DWORD PTR _tok, eax
	call	_kb_yylex
	add	esp, 8

; 179  :       } 
; 180  :       else

	jmp	$LN87@read_param
$LN36@read_param:

; 181  :         kb_error(1351,"Need constant expression for initial value.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CN@PPDAGEAP@Need?5constant?5expression?5for?5ini@
	push	1351					; 00000547H
	call	_kb_error

; 182  :     }
; 183  :     else tok = yylex();  /* get back token exparse pushed back */

	mov	eax, DWORD PTR _tok
	add	esp, 12					; 0000000cH
	jmp	$LN34@read_param
$LN69@read_param:

; 261  :       { struct global *gg = globals(yylval.i);

	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN67@read_param
	mov	ecx, eax
	and	ecx, 16777215				; 00ffffffH
	lea	esi, DWORD PTR [ecx*8]
	sub	esi, ecx
	mov	ecx, DWORD PTR _localbase
	shl	esi, 5
	add	esi, DWORD PTR [ecx]
	jmp	SHORT $LN66@read_param
$LN67@read_param:
	mov	edx, eax
	and	edx, 16777215				; 00ffffffH
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN65@read_param
	mov	ecx, DWORD PTR _web+5656
	mov	esi, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN66@read_param
$LN65@read_param:
	mov	ecx, DWORD PTR _web+5652
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+ecx]
$LN66@read_param:

; 262  :         if ( gg->attr.procstuff.argcount != 0 )

	cmp	DWORD PTR [esi+168], 0
	je	SHORT $LN3@read_param

; 263  :           kb_error(4765,"on_assign_call procedure cannot have arguments.\n",
; 264  :            DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DB@LABGMEKM@on_assign_call?5procedure?5cannot?5@
	push	4765					; 0000129dH
	call	_kb_error
	mov	eax, DWORD PTR _yylval
	add	esp, 12					; 0000000cH
$LN3@read_param:

; 265  :         p->attr.varstuff.on_assign_call = yylval.i;

	mov	DWORD PTR [edi+188], eax

; 266  :         gg->flags |= USED_ON_ASSIGN_CALL;

	or	DWORD PTR [esi+192], ebx
$LN15@read_param:

; 267  :         tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 268  :       }
; 269  :       else 

	jmp	$LL21@read_param
$LN4@read_param:

; 270  :         kb_error(5629,"on_assign_call must be followed by command name.\n",
; 271  :           DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DC@KABODIMK@on_assign_call?5must?5be?5followed?5@
	push	5629					; 000015fdH
	call	_kb_error

; 272  :     }
; 273  :     else break;

	mov	eax, DWORD PTR _tok
	add	esp, 12					; 0000000cH
	jmp	$LL21@read_param
$LN11@read_param:

; 251  :     { tok = yylex(); /* dispose of SCALE_TOK */

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 252  :       if ( (tok == '=') || (tok == ASSIGN_TOK) ) /* have initial value */

	cmp	eax, 61					; 0000003dH
	je	SHORT $LN9@read_param
	cmp	eax, 441				; 000001b9H
	jne	$LL21@read_param
$LN9@read_param:

; 253  :       { if ( read_const(&p->attr.varstuff.pscale) < 0 )

	lea	eax, DWORD PTR [edi+176]
	push	eax
	call	_read_const
	add	esp, 4
	test	eax, eax
	jns	SHORT $LN15@read_param

; 254  :            kb_error(1676,"Need constant expression for scale.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CF@DEFKBMIO@Need?5constant?5expression?5for?5sca@
	push	1676					; 0000068cH
	call	_kb_error
	mov	eax, DWORD PTR _tok
	add	esp, 12					; 0000000cH
	jmp	$LL21@read_param
$LN18@read_param:

; 243  :     { tok = yylex(); /* dispose of DELTA_TOK */

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 244  :        if ( (tok == '=') || (tok == ASSIGN_TOK) ) /* have initial value */

	cmp	eax, 61					; 0000003dH
	je	SHORT $LN16@read_param
	cmp	eax, 441				; 000001b9H
	jne	$LL21@read_param
$LN16@read_param:

; 245  :        { if ( read_const(&p->attr.varstuff.delta) < 0 )

	lea	eax, DWORD PTR [edi+168]
	push	eax
	call	_read_const
	add	esp, 4
	test	eax, eax
	jns	$LN15@read_param

; 246  :             kb_error(1675,"Need constant expression for pdelta.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CG@JGGPBFBL@Need?5constant?5expression?5for?5pde@
	push	1675					; 0000068bH
	call	_kb_error
	mov	eax, DWORD PTR _tok
	add	esp, 12					; 0000000cH
	jmp	$LL21@read_param
$LN5@read_param:
	pop	ebx
	pop	edi

; 274  :   } 
; 275  :   recovery_flag = 0;

	mov	DWORD PTR _recovery_flag, 0
	pop	esi

; 276  : } // end read_parameter()

	mov	esp, ebp
	pop	ebp
	ret	0
_read_parameter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@MPKJBKDJ@Bad?5energy?5component?5?$CFd?5definiti@ ; `string'
PUBLIC	??_C@_0DG@EMDHGOCF@Bad?5content?5component?5?$CFd?5definit@ ; `string'
PUBLIC	??_C@_0CL@HPAJOJJN@Missing?5energy?5components?5for?5bo@ ; `string'
PUBLIC	??_C@_0CA@LHKHGLIJ@boundary?5?$CFs?5energy?5component?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0DE@PDLGGICP@Illegal?5number?5of?5components?5in?5@ ; `string'
PUBLIC	??_C@_0CP@NLJCDGEM@Bad?5coordinate?5?$CFd?5definition?5for@ ; `string'
PUBLIC	??_C@_0DJ@BCGNCPOM@Inconsistent?5number?5of?5component@ ; `string'
PUBLIC	??_C@_0CB@PAEEFJCD@boundary?5?$CFs?5content?5component?5?$CFd@ ; `string'
PUBLIC	??_C@_0BJ@IHDDOBFN@boundary?5?$CFs?5component?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CG@BIJAAKHM@Need?5integer?5value?5for?5content_r@ ; `string'
PUBLIC	??_C@_0DK@BCOLCBIL@Parameter?5count?5for?5boundary?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0DF@JEBBABII@Bad?5parameter?5count?5?$CFd?5for?5bound@ ; `string'
PUBLIC	??_C@_0CP@JKHABEPK@Expecting?5PARAMETERS?5keyword?5for@ ; `string'
PUBLIC	??_C@_0CA@NABFHFEB@Boundary?5name?5?$CFs?5already?5used?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@GFACOFJ@Boundary?5number?5?$CFd?5already?5defin@ ; `string'
PUBLIC	??_C@_0BK@LJIDEHMC@Bad?5boundary?5number?3?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@CEDOMNKL@Need?5boundary?5number?5or?5name?4?6?$AA@ ; `string'
PUBLIC	??_C@_0L@NFFGHKFE@f_boundary?$AA@		; `string'
PUBLIC	??_C@_0L@EMLEBMFF@e_boundary?$AA@		; `string'
PUBLIC	??_C@_0L@HLKALOJP@v_boundary?$AA@		; `string'
PUBLIC	_read_boundary
EXTRN	_kb_lower_array:BYTE
EXTRN	_boundary_expr_flag:DWORD
EXTRN	_expand_attribute:PROC
EXTRN	_datafile_flag:DWORD
EXTRN	_F_BOUNDARY_ATTR:DWORD
;	COMDAT ??_C@_0DF@MPKJBKDJ@Bad?5energy?5component?5?$CFd?5definiti@
CONST	SEGMENT
??_C@_0DF@MPKJBKDJ@Bad?5energy?5component?5?$CFd?5definiti@ DB 'Bad energ'
	DB	'y component %d definition for boundary %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@EMDHGOCF@Bad?5content?5component?5?$CFd?5definit@
CONST	SEGMENT
??_C@_0DG@EMDHGOCF@Bad?5content?5component?5?$CFd?5definit@ DB 'Bad conte'
	DB	'nt component %d definition for boundary %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HPAJOJJN@Missing?5energy?5components?5for?5bo@
CONST	SEGMENT
??_C@_0CL@HPAJOJJN@Missing?5energy?5components?5for?5bo@ DB 'Missing ener'
	DB	'gy components for boundary %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LHKHGLIJ@boundary?5?$CFs?5energy?5component?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0CA@LHKHGLIJ@boundary?5?$CFs?5energy?5component?5?$CFd?$AA@ DB 'bou'
	DB	'ndary %s energy component %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PDLGGICP@Illegal?5number?5of?5components?5in?5@
CONST	SEGMENT
??_C@_0DE@PDLGGICP@Illegal?5number?5of?5components?5in?5@ DB 'Illegal num'
	DB	'ber of components in content integrand.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@NLJCDGEM@Bad?5coordinate?5?$CFd?5definition?5for@
CONST	SEGMENT
??_C@_0CP@NLJCDGEM@Bad?5coordinate?5?$CFd?5definition?5for@ DB 'Bad coord'
	DB	'inate %d definition for boundary %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@BCGNCPOM@Inconsistent?5number?5of?5component@
CONST	SEGMENT
??_C@_0DJ@BCGNCPOM@Inconsistent?5number?5of?5component@ DB 'Inconsistent '
	DB	'number of components in content integrand.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PAEEFJCD@boundary?5?$CFs?5content?5component?5?$CFd@
CONST	SEGMENT
??_C@_0CB@PAEEFJCD@boundary?5?$CFs?5content?5component?5?$CFd@ DB 'bounda'
	DB	'ry %s content component %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IHDDOBFN@boundary?5?$CFs?5component?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BJ@IHDDOBFN@boundary?5?$CFs?5component?5?$CFd?$AA@ DB 'boundary %s'
	DB	' component %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BIJAAKHM@Need?5integer?5value?5for?5content_r@
CONST	SEGMENT
??_C@_0CG@BIJAAKHM@Need?5integer?5value?5for?5content_r@ DB 'Need integer'
	DB	' value for content_rank.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@BCOLCBIL@Parameter?5count?5for?5boundary?5?$CFs?5@
CONST	SEGMENT
??_C@_0DK@BCOLCBIL@Parameter?5count?5for?5boundary?5?$CFs?5@ DB 'Paramete'
	DB	'r count for boundary %s exceeds %d. Assuming %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@JEBBABII@Bad?5parameter?5count?5?$CFd?5for?5bound@
CONST	SEGMENT
??_C@_0DF@JEBBABII@Bad?5parameter?5count?5?$CFd?5for?5bound@ DB 'Bad para'
	DB	'meter count %d for boundary %s. Assuming 1.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JKHABEPK@Expecting?5PARAMETERS?5keyword?5for@
CONST	SEGMENT
??_C@_0CP@JKHABEPK@Expecting?5PARAMETERS?5keyword?5for@ DB 'Expecting PAR'
	DB	'AMETERS keyword for boundary %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NABFHFEB@Boundary?5name?5?$CFs?5already?5used?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@NABFHFEB@Boundary?5name?5?$CFs?5already?5used?4?6?$AA@ DB 'Boun'
	DB	'dary name %s already used.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GFACOFJ@Boundary?5number?5?$CFd?5already?5defin@
CONST	SEGMENT
??_C@_0CF@GFACOFJ@Boundary?5number?5?$CFd?5already?5defin@ DB 'Boundary n'
	DB	'umber %d already defined.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LJIDEHMC@Bad?5boundary?5number?3?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@LJIDEHMC@Bad?5boundary?5number?3?5?$CFd?4?6?$AA@ DB 'Bad bounda'
	DB	'ry number: %d.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CEDOMNKL@Need?5boundary?5number?5or?5name?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@CEDOMNKL@Need?5boundary?5number?5or?5name?4?6?$AA@ DB 'Need bou'
	DB	'ndary number or name.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NFFGHKFE@f_boundary?$AA@
CONST	SEGMENT
??_C@_0L@NFFGHKFE@f_boundary?$AA@ DB 'f_boundary', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EMLEBMFF@e_boundary?$AA@
CONST	SEGMENT
??_C@_0L@EMLEBMFF@e_boundary?$AA@ DB 'e_boundary', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HLKALOJP@v_boundary?$AA@
CONST	SEGMENT
??_C@_0L@HLKALOJP@v_boundary?$AA@ DB 'v_boundary', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _read_boundary
_TEXT	SEGMENT
_rank$89610 = -28					; size = 8
tv1939 = -24						; size = 4
tv1247 = -24						; size = 4
_one$89512 = -24					; size = 4
tv1251 = -20						; size = 8
tv636 = -16						; size = 4
_pcount$ = -16						; size = 4
_moved_flag$89535 = -16					; size = 4
_esize$ = -12						; size = 4
_i$ = -8						; size = 4
_bnum$ = -4						; size = 4
_read_boundary PROC					; COMDAT

; 287  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 288  :   int bnum=0;  /* boundary number */
; 289  :   int pcount; /* number of parameters */
; 290  :   int i,k;
; 291  :   int esize;
; 292  :   struct boundary *bdry;
; 293  : 
; 294  :   if ( V_BOUNDARY_ATTR == 0 )

	cmp	DWORD PTR _V_BOUNDARY_ATTR, 0
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _bnum$[ebp], 0
	mov	esi, 1
	jne	$LN89@read_bound

; 295  :   { int one = 1;
; 296  :     V_BOUNDARY_ATTR = 
; 297  : 	  add_attribute(VERTEX,"v_boundary",INTEGER_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _one$89512[ebp]
	push	eax
	push	0
	push	2
	push	OFFSET ??_C@_0L@HLKALOJP@v_boundary?$AA@
	push	0
	mov	DWORD PTR _one$89512[ebp], esi
	call	_add_attribute

; 298  :     E_BOUNDARY_ATTR = 
; 299  : 	  add_attribute(EDGE,"e_boundary",INTEGER_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _one$89512[ebp]
	push	ecx
	push	0
	push	2
	push	OFFSET ??_C@_0L@EMLEBMFF@e_boundary?$AA@
	push	esi
	mov	DWORD PTR _V_BOUNDARY_ATTR, eax
	call	_add_attribute
	add	esp, 64					; 00000040H

; 300  :     F_BOUNDARY_ATTR = 
; 301  : 	  add_attribute(FACET,"f_boundary",INTEGER_TYPE,0,&one,0,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _one$89512[ebp]
	push	edx
	push	0
	push	2
	push	OFFSET ??_C@_0L@NFFGHKFE@f_boundary?$AA@
	push	2
	mov	DWORD PTR _E_BOUNDARY_ATTR, eax
	call	_add_attribute

; 302  :     EXTRAS(VERTEX)[V_BOUNDARY_ATTR].flags |= READ_ONLY_ATTR;

	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR _F_BOUNDARY_ATTR, eax
	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	or	DWORD PTR [eax+ecx+232], 16		; 00000010H

; 303  :     EXTRAS(EDGE)[E_BOUNDARY_ATTR].flags |= READ_ONLY_ATTR;

	mov	edx, DWORD PTR _E_BOUNDARY_ATTR
	lea	eax, DWORD PTR [eax+ecx+232]
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+216
	mov	eax, DWORD PTR _dymem
	or	DWORD PTR [edx+eax+232], 16		; 00000010H

; 304  :     EXTRAS(FACET)[F_BOUNDARY_ATTR].flags |= READ_ONLY_ATTR;

	mov	ecx, DWORD PTR _F_BOUNDARY_ATTR
	lea	eax, DWORD PTR [edx+eax+232]
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	lea	eax, DWORD PTR [ecx+edx+232]
	add	esp, 32					; 00000020H
	or	DWORD PTR [eax], 16			; 00000010H
$LN89@read_bound:

; 305  :   }
; 306  : 
; 307  :   tok = yylex();  /* eat BOUNDARY token */

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 308  :   if ( (tok != INTEGER_TOK) && (tok != NEWIDENT_TOK) && (tok != BOUNDARY_NAME_TOK) ) 

	cmp	eax, 265				; 00000109H
	je	SHORT $LN151@read_bound
	cmp	eax, 268				; 0000010cH
	je	$LN87@read_bound
	cmp	eax, 520				; 00000208H
	je	$LN87@read_bound

; 309  :   { kb_error(1679,"Need boundary number or name.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BP@CEDOMNKL@Need?5boundary?5number?5or?5name?4?6?$AA@
	push	1679					; 0000068fH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 310  :     return -1;

	or	eax, -1
	pop	ebx

; 585  :   return bnum;
; 586  : 
; 587  : } /* end read_boundary() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN151@read_bound:

; 311  :   }
; 312  :   if ( tok == INTEGER_TOK )
; 313  :   { bnum = yylval.i;     /* boundary number */

	mov	esi, DWORD PTR _yylval
	mov	DWORD PTR _bnum$[ebp], esi

; 314  :     if ( bnum < 0 ) 

	test	esi, esi
	jns	SHORT $LN86@read_bound

; 315  :     { sprintf(errmsg,"Bad boundary number: %d.\n",bnum);

	push	esi
	push	OFFSET ??_C@_0BK@LJIDEHMC@Bad?5boundary?5number?3?5?$CFd?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 316  :       kb_error(1680,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1680					; 00000690H
	call	_kb_error

; 317  :       tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	mov	DWORD PTR _tok, eax

; 318  :       return -1;

	or	eax, -1
	pop	ebx

; 585  :   return bnum;
; 586  : 
; 587  : } /* end read_boundary() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN86@read_bound:

; 319  :     }
; 320  :     if ( bnum >= web.bdrymax )

	mov	edx, DWORD PTR _web+768
	cmp	esi, edx
	jl	SHORT $LN157@read_bound

; 321  :     { web.boundaries = (struct boundary *)kb_realloc((char*)web.boundaries,
; 322  :          (bnum+10)*sizeof(struct boundary));

	mov	ecx, DWORD PTR _web+776
	lea	eax, DWORD PTR [esi+10]
	imul	eax, 136				; 00000088H
	push	322					; 00000142H
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	eax
	push	ecx
	call	_KB_realloc

; 323  :       web.bdrymax = bnum+10;

	lea	edx, DWORD PTR [esi+10]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _web+776, eax
	mov	DWORD PTR _web+768, edx
	jmp	SHORT $LN85@read_bound
$LN157@read_bound:
	mov	eax, DWORD PTR _web+776
$LN85@read_bound:

; 324  :     }
; 325  :     if ( bnum > web.highbdry )

	cmp	esi, DWORD PTR _web+772
	jle	SHORT $LN84@read_bound

; 326  :       web.highbdry = bnum;

	mov	DWORD PTR _web+772, esi
$LN84@read_bound:

; 327  :     if ( web.boundaries[bnum].attr & IN_USE )

	mov	ecx, esi
	imul	ecx, 136				; 00000088H
	mov	esi, DWORD PTR [ecx+eax+32]
	mov	DWORD PTR tv1247[ebp], ecx
	mov	ecx, DWORD PTR [ecx+eax+36]
	mov	DWORD PTR tv1251[ebp+4], ecx
	mov	ecx, esi
	and	ecx, 32					; 00000020H
	xor	edi, edi
	or	ecx, edi
	je	$LN60@read_bound

; 328  :     { int moved_flag = 0;
; 329  :       if ( web.boundaries[bnum].attr & NAMED_THING )

	mov	ecx, esi
	and	ecx, 512				; 00000200H
	or	ecx, edi
	mov	DWORD PTR _moved_flag$89535[ebp], edi
	je	$LN82@read_bound
	npad	2
$LL81@read_bound:

; 330  :       /* move named boundary */
; 331  :       do
; 332  :       { for ( i = 1 ; i < web.bdrymax ; i++ )

	mov	DWORD PTR _i$[ebp], 1
	cmp	edx, 1
	jle	$LN150@read_bound
	mov	ebx, DWORD PTR _i$[ebp]
	lea	esi, DWORD PTR [eax+168]
	npad	7
$LL78@read_bound:

; 333  :           if ( !(web.boundaries[i].attr & IN_USE) )

	mov	ecx, DWORD PTR [esi]
	and	ecx, 32					; 00000020H
	xor	edi, edi
	or	ecx, edi
	je	SHORT $LN122@read_bound

; 330  :       /* move named boundary */
; 331  :       do
; 332  :       { for ( i = 1 ; i < web.bdrymax ; i++ )

	inc	ebx
	add	esi, 136				; 00000088H
	cmp	ebx, edx
	jl	SHORT $LL78@read_bound

; 511  :      }
; 512  :   for (;;)
; 513  :     switch ( tok )

	jmp	$LN150@read_bound
$LN122@read_bound:

; 334  :           { web.boundaries[i] = web.boundaries[bnum];

	mov	edx, DWORD PTR tv1247[ebp]
	mov	DWORD PTR _i$[ebp], ebx
	imul	ebx, 136				; 00000088H
	lea	esi, DWORD PTR [edx+eax]
	lea	edi, DWORD PTR [ebx+eax]
	mov	ecx, 34					; 00000022H
	rep movsd

; 335  :             memset((char*)(&web.boundaries[bnum]),0,sizeof(struct boundary));

	add	edx, DWORD PTR _web+776
	push	136					; 00000088H
	push	0
	push	edx
	call	_memset

; 336  :             web.boundaries[i].num = i;

	mov	ecx, DWORD PTR _web+776
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ebx+ecx+44], edx

; 337  :             k = lookup_global(web.boundaries[i].name);

	add	ebx, DWORD PTR _web+776
	push	ebx
	call	_lookup_global

; 338  :             globals(k)->value.bnum = i;

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 16					; 00000010H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN92@read_bound
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN94@read_bound
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN93@read_bound
$LN94@read_bound:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN92@read_bound
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN93@read_bound
$LN92@read_bound:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN93@read_bound:
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+64], ecx

; 339  :             if ( i > web.highbdry )

	cmp	ecx, DWORD PTR _web+772
	jle	SHORT $LN74@read_bound

; 340  :               web.highbdry = i;

	mov	DWORD PTR _web+772, ecx
$LN74@read_bound:

; 341  :             moved_flag = 1;
; 342  :             break;
; 343  :           }
; 344  :         if ( i >= web.bdrymax )   

	mov	edx, DWORD PTR _web+768
	mov	eax, DWORD PTR _web+776
	mov	DWORD PTR _moved_flag$89535[ebp], 1
	cmp	ecx, edx
	jl	$LN60@read_bound
$LN150@read_bound:

; 345  :         { web.boundaries = (struct boundary *)kb_realloc((char*)web.boundaries,
; 346  :            (web.bdrymax+10)*sizeof(struct boundary));

	add	edx, 10					; 0000000aH
	imul	edx, 136				; 00000088H
	push	346					; 0000015aH
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	edx
	push	eax
	call	_KB_realloc

; 347  :           web.bdrymax = web.bdrymax+10;

	mov	edx, DWORD PTR _web+768
	add	edx, 10					; 0000000aH
	add	esp, 16					; 00000010H

; 348  :         }
; 349  :       } while ( !moved_flag );

	cmp	DWORD PTR _moved_flag$89535[ebp], 0
	mov	DWORD PTR _web+776, eax
	mov	DWORD PTR _web+768, edx
	je	$LL81@read_bound

; 350  :       else if ( !(web.boundaries[bnum].attr & BDRY_FORWARD_DEF)  && !addload_flag)

	jmp	$LN60@read_bound
$LN82@read_bound:
	and	esi, 4096				; 00001000H
	xor	ecx, ecx
	or	esi, ecx
	jne	$LN60@read_bound
	cmp	DWORD PTR _addload_flag, ecx
	jne	$LN60@read_bound

; 351  :       { sprintf(errmsg,"Boundary number %d already defined.\n",bnum);

	mov	ecx, DWORD PTR _bnum$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CF@GFACOFJ@Boundary?5number?5?$CFd?5already?5defin@
	push	OFFSET _errmsg
	call	_sprintf

; 352  :         kb_error(2120,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	2120					; 00000848H
	call	_kb_error

; 353  :         tok = yylex();

	push	esi
	call	_kb_yylex
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	mov	DWORD PTR _tok, eax

; 354  :         return -1; 

	or	eax, -1
	pop	ebx

; 585  :   return bnum;
; 586  : 
; 587  : } /* end read_boundary() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN87@read_bound:

; 355  :       }
; 356  :     }
; 357  :   } 
; 358  :   else /* name */
; 359  :   {
; 360  :     for ( i = 1 ; i < web.bdrymax ; i++ )

	cmp	DWORD PTR _web+768, esi
	jle	SHORT $LN158@read_bound
	mov	ebx, 136				; 00000088H
$LL69@read_bound:

; 361  :     {
; 362  :       if ( !(web.boundaries[i].attr & IN_USE) )

	mov	eax, DWORD PTR _web+776
	mov	ecx, DWORD PTR [ebx+eax+32]
	lea	edx, DWORD PTR [ebx+eax]
	and	ecx, 32					; 00000020H
	xor	edi, edi
	or	ecx, edi
	je	$LN123@read_bound

; 364  :       if ( stricmp(yytext,web.boundaries[i].name) == 0 )

	push	edx
	mov	edx, DWORD PTR _yytext
	push	edx
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	$LN124@read_bound

; 355  :       }
; 356  :     }
; 357  :   } 
; 358  :   else /* name */
; 359  :   {
; 360  :     for ( i = 1 ; i < web.bdrymax ; i++ )

	inc	esi
	add	ebx, 136				; 00000088H
	cmp	esi, DWORD PTR _web+768
	jl	SHORT $LL69@read_bound
$LN158@read_bound:

; 371  :         }
; 372  :         else
; 373  :         { bnum = i;

	mov	eax, DWORD PTR _web+776
$LN67@read_bound:

; 374  :           break;
; 375  :         }
; 376  :       }
; 377  :     }
; 378  :     if ( i > web.highbdry )

	cmp	esi, DWORD PTR _web+772
	jle	SHORT $LN62@read_bound

; 379  :       web.highbdry = i;

	mov	DWORD PTR _web+772, esi
$LN62@read_bound:

; 380  :     if ( i >= web.bdrymax )

	mov	ecx, DWORD PTR _web+768
	cmp	esi, ecx
	jl	SHORT $LN61@read_bound

; 381  :     { web.boundaries = (struct boundary *)kb_realloc((char*)web.boundaries,
; 382  :            (web.bdrymax+10)*sizeof(struct boundary));

	add	ecx, 10					; 0000000aH
	imul	ecx, 136				; 00000088H
	push	382					; 0000017eH
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	ecx
	push	eax
	call	_KB_realloc
	add	esp, 16					; 00000010H

; 383  :       web.bdrymax = web.bdrymax+10;

	add	DWORD PTR _web+768, 10			; 0000000aH
	mov	DWORD PTR _web+776, eax

; 384  :       bnum = i;

	mov	DWORD PTR _bnum$[ebp], esi
$LN61@read_bound:

; 385  :     }
; 386  : 
; 387  :     if ( tok == NEWIDENT_TOK )

	cmp	DWORD PTR _tok, 268			; 0000010cH
	jne	$LN60@read_bound

; 388  :     { k = add_global(yytext);

	mov	ecx, DWORD PTR _yytext
	push	ecx
	call	_add_global

; 389  :       globals(k)->flags |= BOUNDARY_NAME;

	mov	edx, eax
	and	edx, -16777216				; ff000000H
	add	esp, 4
	cmp	edx, 268435456				; 10000000H
	je	$LN98@read_bound
	cmp	edx, 805306368				; 30000000H
	jne	$LN100@read_bound
	mov	esi, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [esi]
	jmp	$LN99@read_bound
$LN123@read_bound:

; 363  :       { bnum = i; break; } 

	mov	DWORD PTR _bnum$[ebp], esi
	jmp	$LN67@read_bound
$LN124@read_bound:

; 365  :       { if ( (datafile_flag == IN_DATAFILE) && !addload_flag 
; 366  :                   && !(web.boundaries[i].attr & BDRY_FORWARD_DEF))

	cmp	DWORD PTR _datafile_flag, 1
	mov	eax, DWORD PTR _web+776
	jne	SHORT $LN123@read_bound
	cmp	DWORD PTR _addload_flag, edi
	jne	SHORT $LN123@read_bound
	mov	ecx, esi
	imul	ecx, 136				; 00000088H
	mov	ecx, DWORD PTR [ecx+eax+32]
	and	ecx, 4096				; 00001000H
	xor	edx, edx
	or	ecx, edx
	jne	SHORT $LN123@read_bound

; 367  :         { sprintf(errmsg,"Boundary name %s already used.\n",yytext);

	mov	eax, DWORD PTR _yytext
	push	eax
	push	OFFSET ??_C@_0CA@NABFHFEB@Boundary?5name?5?$CFs?5already?5used?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 368  :           kb_error(2121,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	2121					; 00000849H
	call	_kb_error

; 369  :           tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	mov	DWORD PTR _tok, eax

; 370  :           return -1;

	or	eax, -1
	pop	ebx

; 585  :   return bnum;
; 586  : 
; 587  : } /* end read_boundary() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN100@read_bound:

; 389  :       globals(k)->flags |= BOUNDARY_NAME;

	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN98@read_bound
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN99@read_bound
$LN98@read_bound:
	mov	ecx, DWORD PTR _web+5652
	mov	esi, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [ecx+esi]
$LN99@read_bound:
	or	DWORD PTR [ecx+192], 262144		; 00040000H

; 390  :       globals(k)->value.bnum = bnum;

	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN104@read_bound
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN106@read_bound
	mov	edx, DWORD PTR _localbase
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN105@read_bound
$LN106@read_bound:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN104@read_bound
	mov	ecx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN105@read_bound
$LN104@read_bound:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN105@read_bound:
	mov	edx, DWORD PTR _bnum$[ebp]
	mov	DWORD PTR [eax+64], edx
	mov	eax, DWORD PTR _web+776
$LN60@read_bound:

; 391  :     }
; 392  :   }
; 393  :   bdry = web.boundaries + bnum;

	mov	esi, DWORD PTR _bnum$[ebp]
	imul	esi, 136				; 00000088H
	mov	DWORD PTR tv1247[ebp], esi
	add	esi, eax

; 394  :   
; 395  :   // fix memory lead for addload
; 396  :   if ( bdry->coordf[0] )

	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN160@read_bound

; 397  :   { 
; 398  :     for ( i = 0 ; i < MAXCOORD ; i++ )

	lea	ebx, DWORD PTR [esi+96]
	mov	DWORD PTR tv636[ebp], 6
	npad	1
$LL58@read_bound:

; 399  :     { free_expr(bdry->coordf[i]);

	mov	eax, DWORD PTR [ebx-48]
	push	eax
	call	_free_expr

; 400  :       free_expr(bdry->convect[i]);

	mov	ecx, DWORD PTR [ebx]
	push	ecx
	call	_free_expr

; 401  :       free_expr(bdry->envect[i]);

	mov	edx, DWORD PTR [ebx-24]
	push	edx
	call	_free_expr
	add	esp, 12					; 0000000cH
	add	ebx, 4
	dec	DWORD PTR tv636[ebp]
	jne	SHORT $LL58@read_bound

; 402  :     }
; 403  :     myfree((char*)bdry->coordf[0]);

	mov	eax, DWORD PTR [esi+48]
	push	eax
	call	_myfree
	add	esp, 4
$LN160@read_bound:

; 404  :   }
; 405  : 
; 406  :   memset((char*)bdry,0,sizeof(struct boundary));

	push	136					; 00000088H
	push	0
	push	esi
	call	_memset

; 407  :   bdry->num = bnum;

	mov	ebx, DWORD PTR _bnum$[ebp]

; 408  :   bdry->attr |= IN_USE;

	mov	ecx, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], 32			; 00000020H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+44], ebx
	mov	DWORD PTR [esi+36], ecx

; 409  :   if ( tok == INTEGER_TOK ) 

	cmp	DWORD PTR _tok, 265			; 00000109H
	jne	SHORT $LN55@read_bound

; 410  :     sprintf(web.boundaries[bnum].name,"%d",bnum);

	mov	eax, DWORD PTR tv1247[ebp]
	add	eax, DWORD PTR _web+776
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 411  :   else

	jmp	SHORT $LN54@read_bound
$LN55@read_bound:

; 412  :   { strncpy(bdry->name,yytext,BDRYNAMESIZE-1);

	mov	ecx, DWORD PTR _yytext
	push	31					; 0000001fH
	push	ecx
	push	esi
	call	_strncpy

; 413  :     bdry->attr |= NAMED_THING;

	mov	edx, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
	or	DWORD PTR [esi+32], 512			; 00000200H
	mov	DWORD PTR [esi+36], edx
$LN54@read_bound:

; 414  :   }
; 415  :   
; 416  :   tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 417  :   if ( tok == ';' )

	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN53@read_bound

; 418  :   { bdry->attr |= BDRY_FORWARD_DEF;

	mov	eax, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], 4096		; 00001000H
	mov	DWORD PTR [esi+36], eax

; 419  :     verb_flag = 0;  /* set by ';' */
; 420  :     tok = yylex();

	push	0
	mov	DWORD PTR _verb_flag, 0
	call	_kb_yylex
	add	esp, 4
	pop	edi
	mov	DWORD PTR _tok, eax
	pop	esi

; 421  :     return bnum;

	mov	eax, ebx
	pop	ebx

; 585  :   return bnum;
; 586  : 
; 587  : } /* end read_boundary() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@read_bound:

; 422  :   }
; 423  :   if ( tok != PARAMETERS_TOK )

	cmp	eax, 35071				; 000088ffH
	je	SHORT $LN52@read_bound

; 424  :      { sprintf(errmsg,"Expecting PARAMETERS keyword for boundary %s.\n",bdry->name);

	push	esi
	push	OFFSET ??_C@_0CP@JKHABEPK@Expecting?5PARAMETERS?5keyword?5for@
	push	OFFSET _errmsg
	call	_sprintf

; 425  :        kb_error(1683,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1683					; 00000693H
	call	_kb_error
	add	esp, 24					; 00000018H

; 426  :        pcount = bdry->pcount = 1; 

	mov	ebx, 1

; 427  :        /* try to continue */
; 428  :      }
; 429  :   else

	jmp	SHORT $LN166@read_bound
$LN52@read_bound:

; 430  :   { tok = gettok(INTEGER_TOK);

	push	265					; 00000109H
	call	_gettok

; 431  :     bdry->pcount = pcount = yylval.i;

	mov	ebx, DWORD PTR _yylval
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN166@read_bound:
	mov	DWORD PTR [esi+40], ebx
	mov	DWORD PTR _pcount$[ebp], ebx

; 432  :   }
; 433  :   if ( pcount > web.maxparam )

	cmp	ebx, DWORD PTR _web+640
	jle	SHORT $LN161@read_bound

; 434  :   { web.maxparam = pcount;
; 435  :     expand_attribute(VERTEX,V_PARAM_ATTR,&web.maxparam);

	push	OFFSET _web+640
	push	2
	push	0
	mov	DWORD PTR _web+640, ebx
	call	_expand_attribute
	add	esp, 12					; 0000000cH
$LN161@read_bound:

; 436  :   }
; 437  :   if ( (pcount < 0) || (tok != INTEGER_TOK) ) 

	test	ebx, ebx
	js	SHORT $LN48@read_bound
	cmp	DWORD PTR _tok, 265			; 00000109H
	je	SHORT $LN49@read_bound
$LN48@read_bound:

; 438  :      { sprintf(errmsg,"Bad parameter count %d for boundary %s. Assuming 1.\n",
; 439  :           pcount,bdry->name);

	push	esi
	push	ebx
	push	OFFSET ??_C@_0DF@JEBBABII@Bad?5parameter?5count?5?$CFd?5for?5bound@
	push	OFFSET _errmsg
	call	_sprintf

; 440  :        kb_error(1684,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1684					; 00000694H
	call	_kb_error

; 441  :        pcount = bdry->pcount = 1;  /* try to continue */

	mov	eax, 1
	add	esp, 28					; 0000001cH
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR _pcount$[ebp], eax

; 442  :      }
; 443  :   if ( pcount > MAXPARAM )

	jmp	SHORT $LN164@read_bound
$LN49@read_bound:
	cmp	ebx, 6
	jle	SHORT $LN164@read_bound

; 444  :      { sprintf(errmsg,
; 445  :             "Parameter count for boundary %s exceeds %d. Assuming %d.\n",
; 446  :                                           bdry->name,MAXPARAM,MAXPARAM);

	mov	ebx, 6
	push	ebx
	push	ebx
	push	esi
	push	OFFSET ??_C@_0DK@BCOLCBIL@Parameter?5count?5for?5boundary?5?$CFs?5@
	push	OFFSET _errmsg
	call	_sprintf

; 447  :        kb_error(1685,errmsg,DATAFILE_ERROR);

	push	ebx
	push	OFFSET _errmsg
	push	1685					; 00000695H
	call	_kb_error
	add	esp, 32					; 00000020H

; 448  :        bdry->pcount = pcount = MAXPARAM; /* try to continue */

	mov	DWORD PTR _pcount$[ebp], ebx
	mov	DWORD PTR [esi+40], ebx
$LN164@read_bound:

; 449  :      }
; 450  : 
; 451  :   tok = yylex();

	push	0
	call	_kb_yylex
	mov	DWORD PTR _tok, eax

; 452  :   for (;;)
; 453  :     switch (tok )

	sub	eax, 35001				; 000088b9H
	add	esp, 4
	cmp	eax, 90					; 0000005aH
	ja	$read_coord_funcs$89620
	mov	ebx, 8
$LL46@read_bound:
	movzx	ecx, BYTE PTR $LN156@read_bound[eax]
	jmp	DWORD PTR $LN172@read_bound[ecx*4]
$LN42@read_bound:

; 454  :     { case CONVEX_TOK:
; 455  :        web.convex_flag = 1;

	mov	DWORD PTR _web+840, 1

; 456  :        bdry->attr |= B_CONVEX;

	or	DWORD PTR [esi+32], ebx

; 457  :        tok = yylex();
; 458  :        break;

	jmp	SHORT $LN167@read_bound
$LN41@read_bound:

; 459  :       case CONTENT_RANK_TOK:
; 460  :         { REAL rank;
; 461  :           if ( read_const(&rank) < 0 )

	lea	eax, DWORD PTR _rank$89610[ebp]
	push	eax
	call	_read_const
	add	esp, 4
	test	eax, eax
	jns	SHORT $LN40@read_bound

; 462  :             kb_error(3467,"Need integer value for content_rank.\n",
; 463  :               DATAFILE_ERROR); 

	push	6
	push	OFFSET ??_C@_0CG@BIJAAKHM@Need?5integer?5value?5for?5content_r@
	push	3467					; 00000d8bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN40@read_bound:

; 464  :           bdry->content_rank = (int)rank;

	fld	QWORD PTR _rank$89610[ebp]
	call	__ftol2_sse
	mov	DWORD PTR [esi+128], eax

; 465  :           tok = yylex();  /* lookahead */
; 466  :           break;

	jmp	SHORT $LN168@read_bound
$LN39@read_bound:

; 467  :         }
; 468  :       case NONWALL_TOK:
; 469  :        bdry->attr |= NONWALL;

	mov	ecx, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], 1024		; 00000400H
	mov	DWORD PTR [esi+36], ecx

; 470  :        tok = yylex();
; 471  :        break;

	jmp	SHORT $LN168@read_bound
$LN38@read_bound:

; 472  :       case PARTNER_HITTING_TOK:
; 473  :        bdry->attr |= PARTNER_HITTING;

	or	DWORD PTR [esi+32], 2048		; 00000800H
$LN167@read_bound:
	mov	edx, DWORD PTR [esi+36]
	mov	DWORD PTR [esi+36], edx
$LN168@read_bound:

; 474  :        tok = yylex();

	push	0
	call	_kb_yylex
	mov	DWORD PTR _tok, eax
	sub	eax, 35001				; 000088b9H
	add	esp, 4
	cmp	eax, 90					; 0000005aH
	jbe	$LL46@read_bound
$read_coord_funcs$89620:

; 475  :        break;
; 476  :       default: goto read_coord_funcs;
; 477  :      }
; 478  : 
; 479  : 
; 480  : read_coord_funcs:
; 481  :   /* read and parse coordinate functions */
; 482  :   bdry->coordf[0] = (struct expnode *)mycalloc(SDIM+2*MAXCOORD,
; 483  :                             sizeof(struct expnode));

	mov	eax, DWORD PTR _web+616
	push	483					; 000001e3H
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	add	eax, 12					; 0000000cH
	push	104					; 00000068H
	push	eax
	call	_kb_calloc
	mov	DWORD PTR [esi+48], eax

; 484  :   for ( i = 1 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	mov	ecx, 1
	add	esp, 16					; 00000010H
	cmp	eax, ecx
	jle	SHORT $LN163@read_bound

; 475  :        break;
; 476  :       default: goto read_coord_funcs;
; 477  :      }
; 478  : 
; 479  : 
; 480  : read_coord_funcs:
; 481  :   /* read and parse coordinate functions */
; 482  :   bdry->coordf[0] = (struct expnode *)mycalloc(SDIM+2*MAXCOORD,
; 483  :                             sizeof(struct expnode));

	mov	ebx, 104				; 00000068H
	lea	edx, DWORD PTR [esi+52]
$LL36@read_bound:

; 485  :     bdry->coordf[i] = bdry->coordf[0] + i;

	mov	eax, DWORD PTR [esi+48]
	add	eax, ebx
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _web+616
	inc	ecx
	add	edx, 4
	add	ebx, 104				; 00000068H
	cmp	ecx, eax
	jl	SHORT $LL36@read_bound
$LN163@read_bound:

; 486  : 
; 487  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	eax, eax
	jle	$LN31@read_bound
	mov	DWORD PTR tv1939[ebp], 1
	lea	ebx, DWORD PTR [esi+48]
	npad	15
$LL162@read_bound:

; 488  :   {
; 489  :     if ( (tok != COORD_TOK ) || ( yylval.i != 1 + i ))

	cmp	DWORD PTR _tok, 321			; 00000141H
	jne	$LN29@read_bound
	mov	ecx, DWORD PTR tv1939[ebp]
	cmp	DWORD PTR _yylval, ecx
	jne	$LN29@read_bound

; 492  :       goto berr;
; 493  :     }
; 494  :     boundary_expr_flag = 1;
; 495  :     esize = exparse(pcount,bdry->coordf[i],USERCOPY);

	mov	eax, DWORD PTR _pcount$[ebp]
	mov	DWORD PTR _boundary_expr_flag, 1
	mov	edx, DWORD PTR [ebx]
	push	1
	push	edx
	push	eax
	call	_exparse

; 496  :     boundary_expr_flag = 0;
; 497  :     tok = yylex();

	push	0
	mov	DWORD PTR _esize$[ebp], eax
	mov	DWORD PTR _boundary_expr_flag, 0
	call	_kb_yylex
	add	esp, 16					; 00000010H

; 498  :     if ( esize <= 0 )

	cmp	DWORD PTR _esize$[ebp], 0
	mov	DWORD PTR _tok, eax
	jle	$LN126@read_bound

; 502  :     }
; 503  :     sprintf(msg,"boundary %s component %d",bdry->name,i+1);

	mov	ecx, DWORD PTR tv1939[ebp]
	mov	edx, DWORD PTR _msg
	push	ecx
	push	esi
	push	OFFSET ??_C@_0BJ@IHDDOBFN@boundary?5?$CFs?5component?5?$CFd?$AA@
	push	edx
	call	_sprintf

; 504  :     strncpy(bdry->coordf[i]->name,msg,EXPNAMESIZE-1);

	mov	eax, DWORD PTR _msg
	mov	ecx, DWORD PTR [ebx]
	push	63					; 0000003fH
	push	eax
	add	ecx, 20					; 00000014H
	push	ecx
	call	_strncpy
	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _web+616
	inc	DWORD PTR tv1939[ebp]
	inc	ecx
	add	esp, 28					; 0000001cH
	add	ebx, 4
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, eax
	jl	$LL162@read_bound
$LN31@read_bound:

; 505  :   }
; 506  : 
; 507  :   /* various integrands */
; 508  :   for ( i = 0 ; i < MAXCOORD ; i++ )
; 509  :      { bdry->envect[i] = bdry->coordf[0] + SDIM + i;

	imul	eax, 104				; 00000068H
	add	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+72], eax

; 510  :         bdry->convect[i] = bdry->coordf[0] + SDIM + MAXCOORD + i;

	mov	ecx, DWORD PTR _web+616
	add	ecx, 6
	imul	ecx, 104				; 00000068H
	add	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+96], ecx
	mov	edx, DWORD PTR _web+616
	inc	edx
	imul	edx, 104				; 00000068H
	add	edx, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+76], edx
	mov	eax, DWORD PTR _web+616
	add	eax, 7
	imul	eax, 104				; 00000068H
	add	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+100], eax
	mov	ecx, DWORD PTR _web+616
	add	ecx, 2
	imul	ecx, 104				; 00000068H
	add	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+80], ecx
	mov	edx, DWORD PTR _web+616
	add	edx, 8
	imul	edx, 104				; 00000068H
	add	edx, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+104], edx
	mov	eax, DWORD PTR _web+616
	add	eax, 3
	imul	eax, 104				; 00000068H
	add	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+84], eax
	mov	ecx, DWORD PTR _web+616
	add	ecx, 9
	imul	ecx, 104				; 00000068H
	add	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+108], ecx
	mov	edx, DWORD PTR _web+616
	add	edx, 4
	imul	edx, 104				; 00000068H
	add	edx, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+88], edx
	mov	eax, DWORD PTR _web+616
	add	eax, 10					; 0000000aH
	imul	eax, 104				; 00000068H
	add	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+112], eax
	mov	ecx, DWORD PTR _web+616
	add	ecx, 5
	imul	ecx, 104				; 00000068H
	add	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+92], ecx
	mov	edx, DWORD PTR _web+616
	add	edx, 11					; 0000000bH
	imul	edx, 104				; 00000068H
	add	edx, DWORD PTR [esi+48]
	mov	DWORD PTR [esi+116], edx
	npad	3
$LL24@read_bound:

; 511  :      }
; 512  :   for (;;)
; 513  :     switch ( tok )

	mov	eax, DWORD PTR _tok
	cmp	eax, 438				; 000001b6H
	je	$LN20@read_bound
	cmp	eax, 35094				; 00008916H
	jne	$LN170@read_bound

; 542  :       break;
; 543  : 
; 544  :      case CONTENT_TOK:
; 545  :       /* read and parse content vector potential */
; 546  :       tok = yylex();

	push	0
	call	_kb_yylex
	mov	DWORD PTR _tok, eax

; 547  :       bdry->attr |= CON_CONTENT;

	mov	eax, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], 128			; 00000080H
	mov	DWORD PTR [esi+36], eax

; 548  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 4
	xor	edi, edi
	test	eax, eax
	jle	$LN127@read_bound

; 542  :       break;
; 543  : 
; 544  :      case CONTENT_TOK:
; 545  :       /* read and parse content vector potential */
; 546  :       tok = yylex();

	lea	ebx, DWORD PTR [esi+96]
	npad	7
$LL11@read_bound:

; 549  :       {
; 550  :         if ( (tolower(yytext[0]) != 'c') || (yytext[1] != '1' + i) )

	mov	ecx, DWORD PTR _yytext
	movsx	edx, BYTE PTR [ecx]
	cmp	BYTE PTR _kb_lower_array[edx], 99	; 00000063H
	jne	SHORT $LN127@read_bound
	movsx	ecx, BYTE PTR [ecx+1]
	lea	edx, DWORD PTR [edi+49]
	cmp	ecx, edx
	jne	SHORT $LN127@read_bound

; 551  :             break;
; 552  :         esize = exparse(SDIM,bdry->convect[i],USERCOPY);

	mov	ecx, DWORD PTR [ebx]
	push	1
	push	ecx
	push	eax
	call	_exparse

; 553  :         tok = yylex();

	push	0
	mov	DWORD PTR _esize$[ebp], eax
	call	_kb_yylex
	add	esp, 16					; 00000010H
	inc	edi

; 554  :         if ( esize <= 0 )

	cmp	DWORD PTR _esize$[ebp], 0
	mov	DWORD PTR _tok, eax
	jle	$LN128@read_bound

; 559  :           return bnum;
; 560  :         }
; 561  :         sprintf(msg, "boundary %s content component %d", bdry->name,i+1);

	mov	edx, DWORD PTR _msg
	push	edi
	push	esi
	push	OFFSET ??_C@_0CB@PAEEFJCD@boundary?5?$CFs?5content?5component?5?$CFd@
	push	edx
	call	_sprintf

; 562  :         strncpy(bdry->convect[i]->name,msg,EXPNAMESIZE-1);

	mov	eax, DWORD PTR _msg
	mov	ecx, DWORD PTR [ebx]
	push	63					; 0000003fH
	push	eax
	add	ecx, 20					; 00000014H
	push	ecx
	call	_strncpy
	mov	eax, DWORD PTR _web+616
	add	esp, 28					; 0000001cH
	add	ebx, 4
	cmp	edi, eax
	jl	SHORT $LL11@read_bound
$LN127@read_bound:

; 563  :       } 
; 564  :       /* check consistency of number of components */
; 565  :       if ( bdry->compcount )

	mov	ecx, DWORD PTR [esi+120]
	test	ecx, ecx
	je	SHORT $LN5@read_bound

; 566  :       { if ( bdry->compcount != i )

	cmp	ecx, edi
	je	$LN3@read_bound

; 567  :           kb_error(1381,
; 568  :              "Inconsistent number of components in content integrand.\n",
; 569  :                    WARNING);

	push	2
	push	OFFSET ??_C@_0DJ@BCGNCPOM@Inconsistent?5number?5of?5component@
	push	1381					; 00000565H
	call	_kb_error

; 576  :       }
; 577  :       bdry->attr |= CON_CONTENT;

	mov	edx, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
	or	DWORD PTR [esi+32], 128			; 00000080H
	mov	DWORD PTR [esi+36], edx

; 578  :       break;

	jmp	$LL24@read_bound
$LN126@read_bound:

; 499  :     { sprintf(errmsg,
; 500  :        "Bad coordinate %d definition for boundary %s.\n",i+1,bdry->name);

	mov	edx, DWORD PTR _i$[ebp]
	push	esi
	inc	edx
	push	edx

; 501  :       goto berr;

	jmp	SHORT $LN169@read_bound
$LN29@read_bound:

; 490  :     { sprintf(errmsg,
; 491  :           "Bad coordinate %d definition for boundary %s.\n",i+1,bdry->name);

	mov	eax, DWORD PTR _i$[ebp]
	push	esi
	inc	eax
	push	eax
$LN169@read_bound:
	push	OFFSET ??_C@_0CP@NLJCDGEM@Bad?5coordinate?5?$CFd?5definition?5for@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 16					; 00000010H

; 582  : 
; 583  : berr:
; 584  :   kb_error(1686,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1686					; 00000696H
$berr$89632:
	call	_kb_error
	mov	eax, DWORD PTR _bnum$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 585  :   return bnum;
; 586  : 
; 587  : } /* end read_boundary() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@read_bound:

; 570  :       }
; 571  :       else
; 572  :       { if ( (i != 1) && (i != SDIM) )

	cmp	edi, 1
	je	SHORT $LN2@read_bound
	cmp	edi, eax
	je	SHORT $LN2@read_bound

; 573  :          kb_error(1449,"Illegal number of components in content integrand.\n",
; 574  :                    DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DE@PDLGGICP@Illegal?5number?5of?5components?5in?5@
	push	1449					; 000005a9H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN2@read_bound:

; 575  :          bdry->compcount = i;

	mov	DWORD PTR [esi+120], edi
$LN3@read_bound:

; 576  :       }
; 577  :       bdry->attr |= CON_CONTENT;

	mov	edx, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], 128			; 00000080H
	mov	DWORD PTR [esi+36], edx

; 578  :       break;

	jmp	$LL24@read_bound
$LN20@read_bound:

; 514  :     { 
; 515  :       case ENERGY_TOK:
; 516  :       /* read and parse energy function */
; 517  :       tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 518  :       for ( i = 0 ; i < MAXCOORD ; i++ )

	xor	edi, edi
	lea	ebx, DWORD PTR [esi+72]
	npad	13
$LL19@read_bound:

; 519  :       {
; 520  :         if ( (tolower(yytext[0]) != 'e') || (yytext[1] != '1' + i) )

	mov	eax, DWORD PTR _yytext
	movsx	ecx, BYTE PTR [eax]
	cmp	BYTE PTR _kb_lower_array[ecx], 101	; 00000065H
	jne	SHORT $LN129@read_bound
	movsx	edx, BYTE PTR [eax+1]
	lea	eax, DWORD PTR [edi+49]
	cmp	edx, eax
	jne	SHORT $LN129@read_bound

; 521  :             break;
; 522  :         esize = exparse(SDIM,bdry->envect[i],USERCOPY);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR _web+616
	push	1
	push	ecx
	push	edx
	call	_exparse

; 523  :         tok = yylex();  

	push	0
	mov	DWORD PTR _esize$[ebp], eax
	call	_kb_yylex
	add	esp, 16					; 00000010H
	inc	edi

; 524  :         if ( esize <= 0 )

	cmp	DWORD PTR _esize$[ebp], 0
	mov	DWORD PTR _tok, eax
	jle	$LN130@read_bound

; 530  :         }
; 531  :         sprintf(msg,"boundary %s energy component %d",bdry->name,i+1);

	mov	eax, DWORD PTR _msg
	push	edi
	push	esi
	push	OFFSET ??_C@_0CA@LHKHGLIJ@boundary?5?$CFs?5energy?5component?5?$CFd?$AA@
	push	eax
	call	_sprintf

; 532  :         strncpy(bdry->envect[i]->name,msg,EXPNAMESIZE-1);

	mov	ecx, DWORD PTR _msg
	mov	edx, DWORD PTR [ebx]
	push	63					; 0000003fH
	push	ecx
	add	edx, 20					; 00000014H
	push	edx
	call	_strncpy
	add	esp, 28					; 0000001cH
	add	ebx, 4
	cmp	edi, 6
	jl	SHORT $LL19@read_bound
$LN129@read_bound:

; 533  :       }
; 534  :       if ( i == 0 )

	test	edi, edi
	jne	SHORT $LN13@read_bound

; 535  :       { sprintf(errmsg,"Missing energy components for boundary %s\n",
; 536  :              bdry->name);

	push	esi
	push	OFFSET ??_C@_0CL@HPAJOJJN@Missing?5energy?5components?5for?5bo@
	push	OFFSET _errmsg
	call	_sprintf

; 537  :         kb_error(5932,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	5932					; 0000172cH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN13@read_bound:

; 538  :       }
; 539  : 
; 540  :       bdry->compcount = i;
; 541  :       bdry->attr |= CON_ENERGY;

	mov	eax, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], 64			; 00000040H
	mov	DWORD PTR [esi+120], edi
	mov	DWORD PTR [esi+36], eax

; 579  :     
; 580  :      default: return bnum; 
; 581  :     } /* end switch for integrands */

	jmp	$LL24@read_bound
$LN128@read_bound:

; 555  :         { sprintf(errmsg,
; 556  :               "Bad content component %d definition for boundary %s.\n",
; 557  :                  i+1,bdry->name);

	push	esi
	push	edi
	push	OFFSET ??_C@_0DG@EMDHGOCF@Bad?5content?5component?5?$CFd?5definit@
	push	OFFSET _errmsg
	call	_sprintf

; 558  :           kb_error(1378,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1378					; 00000562H
	call	_kb_error
	mov	eax, DWORD PTR _bnum$[ebp]
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 585  :   return bnum;
; 586  : 
; 587  : } /* end read_boundary() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN130@read_bound:

; 525  :         { sprintf(errmsg,
; 526  :            "Bad energy component %d definition for boundary %s.\n",
; 527  :             i+1,bdry->name);

	push	esi
	push	edi
	push	OFFSET ??_C@_0DF@MPKJBKDJ@Bad?5energy?5component?5?$CFd?5definiti@
	push	OFFSET _errmsg
	call	_sprintf

; 528  :           kb_error(1367,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1367					; 00000557H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN170@read_bound:

; 529  :           return bnum;

	mov	eax, DWORD PTR _bnum$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 585  :   return bnum;
; 586  : 
; 587  : } /* end read_boundary() */

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN172@read_bound:
	DD	$LN41@read_bound
	DD	$LN38@read_bound
	DD	$LN42@read_bound
	DD	$LN39@read_bound
	DD	$read_coord_funcs$89620
$LN156@read_bound:
	DB	0
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	3
_read_boundary ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@EGAOMJJD@Bad?5energy?5component?5?$CFd?5definiti@ ; `string'
PUBLIC	??_C@_0DI@PHBBKCHF@Bad?5content?5component?5?$CFd?5definit@ ; `string'
PUBLIC	??_C@_0CN@BGHOKPDI@Missing?5energy?5components?5for?5co@ ; `string'
PUBLIC	??_C@_0CC@BLJHHNJG@constraint?5?$CFs?5energy?5component?5?$CF@ ; `string'
PUBLIC	??_C@_0CD@HNOAGEMA@constraint?5?$CFs?5content?5component?5@ ; `string'
PUBLIC	??_C@_0BG@FPIMEADN@constraint?5?$CFs?5formula?$AA@ ; `string'
PUBLIC	??_C@_0CM@PDFNDLGB@Bad?5function?5definition?5for?5cons@ ; `string'
PUBLIC	??_C@_0DB@GJPFJFHG@Expected?5function?5definition?5for@ ; `string'
PUBLIC	??_C@_0N@JNGNPCNJ@raw_velocity?$AA@		; `string'
PUBLIC	??_C@_0CC@NPLINMK@Constraint?5name?5?$CFs?5already?5used?4@ ; `string'
PUBLIC	??_C@_0CH@BEFONHGK@Constraint?5number?5?$CFd?5already?5def@ ; `string'
PUBLIC	??_C@_0CF@HGBAPLDG@Constraint?5number?5must?5be?5positi@ ; `string'
PUBLIC	??_C@_0CB@ECBILCPK@Need?5constraint?5number?5or?5name?4?6@ ; `string'
PUBLIC	_read_constraint
EXTRN	_constraint_init:PROC
EXTRN	_raw_velocity_attr:DWORD
EXTRN	_one_sided_present:DWORD
;	COMDAT ??_C@_0DH@EGAOMJJD@Bad?5energy?5component?5?$CFd?5definiti@
CONST	SEGMENT
??_C@_0DH@EGAOMJJD@Bad?5energy?5component?5?$CFd?5definiti@ DB 'Bad energ'
	DB	'y component %d definition for constraint %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@PHBBKCHF@Bad?5content?5component?5?$CFd?5definit@
CONST	SEGMENT
??_C@_0DI@PHBBKCHF@Bad?5content?5component?5?$CFd?5definit@ DB 'Bad conte'
	DB	'nt component %d definition for constraint %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BGHOKPDI@Missing?5energy?5components?5for?5co@
CONST	SEGMENT
??_C@_0CN@BGHOKPDI@Missing?5energy?5components?5for?5co@ DB 'Missing ener'
	DB	'gy components for constraint %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BLJHHNJG@constraint?5?$CFs?5energy?5component?5?$CF@
CONST	SEGMENT
??_C@_0CC@BLJHHNJG@constraint?5?$CFs?5energy?5component?5?$CF@ DB 'constr'
	DB	'aint %s energy component %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HNOAGEMA@constraint?5?$CFs?5content?5component?5@
CONST	SEGMENT
??_C@_0CD@HNOAGEMA@constraint?5?$CFs?5content?5component?5@ DB 'constrain'
	DB	't %s content component %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FPIMEADN@constraint?5?$CFs?5formula?$AA@
CONST	SEGMENT
??_C@_0BG@FPIMEADN@constraint?5?$CFs?5formula?$AA@ DB 'constraint %s form'
	DB	'ula', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PDFNDLGB@Bad?5function?5definition?5for?5cons@
CONST	SEGMENT
??_C@_0CM@PDFNDLGB@Bad?5function?5definition?5for?5cons@ DB 'Bad function'
	DB	' definition for constraint %s.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GJPFJFHG@Expected?5function?5definition?5for@
CONST	SEGMENT
??_C@_0DB@GJPFJFHG@Expected?5function?5definition?5for@ DB 'Expected func'
	DB	'tion definition for constraint %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JNGNPCNJ@raw_velocity?$AA@
CONST	SEGMENT
??_C@_0N@JNGNPCNJ@raw_velocity?$AA@ DB 'raw_velocity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NPLINMK@Constraint?5name?5?$CFs?5already?5used?4@
CONST	SEGMENT
??_C@_0CC@NPLINMK@Constraint?5name?5?$CFs?5already?5used?4@ DB 'Constrain'
	DB	't name %s already used.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@BEFONHGK@Constraint?5number?5?$CFd?5already?5def@
CONST	SEGMENT
??_C@_0CH@BEFONHGK@Constraint?5number?5?$CFd?5already?5def@ DB 'Constrain'
	DB	't number %d already defined.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HGBAPLDG@Constraint?5number?5must?5be?5positi@
CONST	SEGMENT
??_C@_0CF@HGBAPLDG@Constraint?5number?5must?5be?5positi@ DB 'Constraint n'
	DB	'umber must be positive.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@ECBILCPK@Need?5constraint?5number?5or?5name?4?6@
CONST	SEGMENT
??_C@_0CB@ECBILCPK@Need?5constraint?5number?5or?5name?4?6@ DB 'Need const'
	DB	'raint number or name.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _read_constraint
_TEXT	SEGMENT
_rank$89775 = -12					; size = 8
_esize$ = -8						; size = 4
_dim$89792 = -8						; size = 4
_i$ = -8						; size = 4
_cnum$ = -4						; size = 4
_read_constraint PROC					; COMDAT

; 597  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi

; 598  :   int cnum=0;  /* constraint number */
; 599  :   int i,k;
; 600  :   int esize;
; 601  :   int more_attr;
; 602  :   struct constraint *con;
; 603  :   int done_flag;
; 604  : 
; 605  :   tok = yylex();  /* eat CONSTRAINT */

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 606  :   if ( (tok != INTEGER_TOK)  && (tok != NEWIDENT_TOK) && ( tok != CONSTRAINT_NAME_TOK) ) 

	cmp	eax, 265				; 00000109H
	je	SHORT $LN125@read_const@2
	cmp	eax, 268				; 0000010cH
	je	$LN75@read_const@2
	cmp	eax, 519				; 00000207H
	je	$LN75@read_const@2

; 607  :   { kb_error(1687,"Need constraint number or name.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CB@ECBILCPK@Need?5constraint?5number?5or?5name?4?6@
	push	1687					; 00000697H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 608  :     return -1;

	or	eax, -1
	pop	ebx

; 877  : } // end read_constraint()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN125@read_const@2:

; 609  :   }
; 610  :   if ( tok == INTEGER_TOK )
; 611  :   { cnum = yylval.i;     /* constraint number */

	mov	esi, DWORD PTR _yylval
	mov	DWORD PTR _cnum$[ebp], esi

; 612  :     if ( cnum < 0 ) 

	test	esi, esi
	jns	SHORT $LN104@read_const@2

; 613  :      { kb_error(1688,"Constraint number must be positive.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CF@HGBAPLDG@Constraint?5number?5must?5be?5positi@
	push	1688					; 00000698H
	call	_kb_error

; 614  :        tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	mov	DWORD PTR _tok, eax

; 615  :        return -1;

	or	eax, -1
	pop	ebx

; 877  : } // end read_constraint()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN104@read_const@2:

; 616  :      }
; 617  :     while ( cnum >= web.maxcon )

	mov	ecx, DWORD PTR _web+644
	mov	eax, DWORD PTR _web+652
	cmp	esi, ecx
	jl	SHORT $LN72@read_const@2
	npad	7
$LL73@read_const@2:

; 618  :     { int newcons = web.maxcon ? 2*web.maxcon : 16;

	lea	edi, DWORD PTR [ecx+ecx]
	test	ecx, ecx
	jne	SHORT $LN80@read_const@2
	mov	edi, 16					; 00000010H
$LN80@read_const@2:

; 619  :       web.constraints = (struct constraint *) kb_realloc((char*)web.constraints,
; 620  :           newcons*sizeof(struct constraint));

	mov	ecx, edi
	imul	ecx, 176				; 000000b0H
	push	620					; 0000026cH
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	ecx
	push	eax
	call	_KB_realloc
	add	esp, 16					; 00000010H

; 621  :       web.maxcon = newcons;

	mov	ecx, edi
	mov	DWORD PTR _web+652, eax
	mov	DWORD PTR _web+644, ecx
	cmp	esi, edi
	jge	SHORT $LL73@read_const@2
$LN72@read_const@2:

; 622  :     }
; 623  :     if ( cnum > web.highcon )

	cmp	esi, DWORD PTR _web+648
	jle	SHORT $LN71@read_const@2

; 624  :       web.highcon = cnum;

	mov	DWORD PTR _web+648, esi
$LN71@read_const@2:

; 625  :     con = get_constraint(cnum);

	and	esi, 1073741823				; 3fffffffH
	imul	esi, 176				; 000000b0H

; 626  :     if ( con->attr & IN_USE )

	mov	edi, DWORD PTR [esi+eax+32]
	lea	edx, DWORD PTR [esi+eax]
	mov	ecx, edi
	and	ecx, 32					; 00000020H
	xor	ebx, ebx
	or	ecx, ebx
	je	$LN48@read_const@2

; 627  :     { 
; 628  :       if ( con->attr & NAMED_THING )

	mov	ecx, edi
	and	ecx, 512				; 00000200H
	or	ecx, ebx
	je	$LN69@read_const@2

; 629  :       { /* Oops. Move the named constraint */
; 630  :         for ( i = 1 ;  ; i++ )

	mov	ebx, 1
$LN147@read_const@2:
	mov	ecx, DWORD PTR _web+644
	mov	DWORD PTR _i$[ebp], ebx

; 631  :         { struct constraint *c;
; 632  : 
; 633  :           if ( i >= web.maxcon ) // need more constraint structures

	cmp	ebx, ecx
	jl	SHORT $LN65@read_const@2

; 634  :           { int newcons = 2*web.maxcon;

	lea	edi, DWORD PTR [ecx+ecx]

; 635  :             web.constraints = 
; 636  :               (struct constraint *) kb_realloc((char*)web.constraints,
; 637  :               newcons*sizeof(struct constraint));

	mov	edx, edi
	imul	edx, 176				; 000000b0H
	push	637					; 0000027dH
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	edx
	push	eax
	call	_KB_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _web+652, eax

; 638  :             web.maxcon = newcons;

	mov	DWORD PTR _web+644, edi

; 639  :             con = get_constraint(cnum);  // might hvae move during re-allocation

	lea	edx, DWORD PTR [esi+eax]
$LN65@read_const@2:

; 640  :           }
; 641  :           c = get_constraint(i);

	and	ebx, 1073741823				; 3fffffffH
	imul	ebx, 176				; 000000b0H

; 642  :           if ( !(c->attr & IN_USE) )

	mov	ecx, DWORD PTR [ebx+eax+32]
	add	ebx, eax
	and	ecx, 32					; 00000020H
	xor	edi, edi
	or	ecx, edi
	je	SHORT $LN112@read_const@2

; 629  :       { /* Oops. Move the named constraint */
; 630  :         for ( i = 1 ;  ; i++ )

	mov	ebx, DWORD PTR _i$[ebp]
	inc	ebx
	jmp	SHORT $LN147@read_const@2
$LN112@read_const@2:

; 643  :           { struct global *g;
; 644  :             *c = *con;
; 645  :             memset((char*)con,0,sizeof(struct constraint));

	push	176					; 000000b0H
	mov	esi, edx
	push	0
	mov	ecx, 44					; 0000002cH
	mov	edi, ebx
	push	edx
	rep movsd
	call	_memset

; 646  :             k = lookup_global(c->name);

	push	ebx
	call	_lookup_global

; 647  :             g = globals(k);  

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 16					; 00000010H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN81@read_const@2
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN83@read_const@2
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN82@read_const@2
$LN83@read_const@2:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN81@read_const@2
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN82@read_const@2
$LN81@read_const@2:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN82@read_const@2:

; 648  :             g->value.cnum = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+64], ecx

; 651  :             break;
; 652  :           }   
; 653  :         }
; 654  :        }           
; 655  :        else if ( datafile_flag & !(con->attr & CON_FORWARD_DEF)

	mov	eax, DWORD PTR _web+652
	cmp	ecx, DWORD PTR _web+648
	jle	$LN48@read_const@2

; 649  :             if ( i > web.highcon )
; 650  :               web.highcon = i;

	mov	DWORD PTR _web+648, ecx

; 651  :             break;
; 652  :           }   
; 653  :         }
; 654  :        }           
; 655  :        else if ( datafile_flag & !(con->attr & CON_FORWARD_DEF)

	jmp	$LN48@read_const@2
$LN69@read_const@2:

; 656  :                          & !addload_flag )

	mov	eax, edi
	and	eax, 4096				; 00001000H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN87@read_const@2
	lea	eax, DWORD PTR [ecx+1]
	jmp	SHORT $LN88@read_const@2
$LN87@read_const@2:
	xor	eax, eax
$LN88@read_const@2:
	xor	ecx, ecx
	cmp	DWORD PTR _addload_flag, ecx
	sete	cl
	and	ecx, eax
	test	DWORD PTR _datafile_flag, ecx
	je	SHORT $LN61@read_const@2

; 657  :        { sprintf(errmsg,"Constraint number %d already defined.\n",cnum);

	mov	edx, DWORD PTR _cnum$[ebp]
	push	edx
	push	OFFSET ??_C@_0CH@BEFONHGK@Constraint?5number?5?$CFd?5already?5def@
	push	OFFSET _errmsg
	call	_sprintf

; 658  :          kb_error(1690,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1690					; 0000069aH
	call	_kb_error

; 659  :          tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	mov	DWORD PTR _tok, eax

; 660  :          return -1;

	or	eax, -1
	pop	ebx

; 877  : } // end read_constraint()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@read_const@2:

; 661  :        }
; 662  :        else
; 663  :          con->attr &= ~CON_FORWARD_DEF;

	mov	eax, DWORD PTR [edx+36]
	and	edi, -4097				; ffffefffH
	mov	DWORD PTR [edx+32], edi
	mov	DWORD PTR [edx+36], eax

; 664  :     }
; 665  :   }
; 666  :   else /* named constraint */

	jmp	$LN152@read_const@2
$LN75@read_const@2:

; 667  :   { 
; 668  :     for ( i = 1 ; i < web.maxcon ; i++ )

	mov	ebx, DWORD PTR _web+644
	mov	edi, 1
	cmp	ebx, edi
	jle	SHORT $LN140@read_const@2
$LL58@read_const@2:

; 669  :     { con = get_constraint(i);

	mov	eax, DWORD PTR _web+652
	mov	esi, edi
	and	esi, 1073741823				; 3fffffffH
	imul	esi, 176				; 000000b0H

; 670  :       if ( !(con->attr & IN_USE) )

	mov	ecx, DWORD PTR [esi+eax+32]
	add	esi, eax
	and	ecx, 32					; 00000020H
	xor	edx, edx
	or	ecx, edx
	je	$LN113@read_const@2

; 671  :       { cnum = i; break; }   
; 672  :       if ( stricmp(yytext,get_constraint(i)->name) == 0 ) 

	mov	edx, DWORD PTR _yytext
	push	esi
	push	edx
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	$LN114@read_const@2

; 667  :   { 
; 668  :     for ( i = 1 ; i < web.maxcon ; i++ )

	mov	ebx, DWORD PTR _web+644
	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL58@read_const@2
$LN140@read_const@2:

; 816  :        if ( esize <= 0 )

	mov	eax, DWORD PTR _web+652
$LN124@read_const@2:

; 688  :     { int newcons = web.maxcon ? 2*web.maxcon : 16;

	lea	esi, DWORD PTR [ebx+ebx]
	test	ebx, ebx
	jne	SHORT $LN90@read_const@2
	mov	esi, 16					; 00000010H
$LN90@read_const@2:

; 689  :       web.constraints = (struct constraint *) kb_realloc((char*)web.constraints,
; 690  :               newcons*sizeof(struct constraint));

	mov	edx, esi
	imul	edx, 176				; 000000b0H
	push	690					; 000002b2H
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	edx
	push	eax
	call	_KB_realloc

; 691  :       cnum = web.maxcon;

	mov	ecx, DWORD PTR _web+644
	add	esp, 16					; 00000010H
	mov	DWORD PTR _web+652, eax
	mov	DWORD PTR _cnum$[ebp], ecx

; 692  :       if ( cnum == 0 )

	test	ecx, ecx
	jne	SHORT $LN50@read_const@2

; 693  :          cnum = 1;  // not using constraint number 0

	mov	DWORD PTR _cnum$[ebp], 1
$LN50@read_const@2:

; 694  :       web.maxcon = newcons;

	mov	DWORD PTR _web+644, esi
$LN51@read_const@2:

; 695  :     }
; 696  :     if ( i > web.highcon )

	cmp	edi, DWORD PTR _web+648
	jle	SHORT $LN49@read_const@2

; 697  :       web.highcon = i;

	mov	DWORD PTR _web+648, edi
$LN49@read_const@2:

; 698  :     if ( tok == NEWIDENT_TOK )

	cmp	DWORD PTR _tok, 268			; 0000010cH
	jne	$LN48@read_const@2

; 699  :     { k = add_global(yytext);

	mov	eax, DWORD PTR _yytext
	push	eax
	call	_add_global

; 700  :       globals(k)->flags |= CONSTRAINT_NAME;

	mov	edx, eax
	and	edx, -16777216				; ff000000H
	add	esp, 4
	cmp	edx, 268435456				; 10000000H
	je	$LN91@read_const@2
	cmp	edx, 805306368				; 30000000H
	jne	$LN93@read_const@2
	mov	esi, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	mov	ecx, eax
	imul	ecx, 224				; 000000e0H
	add	ecx, DWORD PTR [esi]
	jmp	$LN92@read_const@2
$LN114@read_const@2:

; 673  :       { if ( datafile_flag == IN_DATAFILE && !(con->attr & CON_FORWARD_DEF)
; 674  :             && !addload_flag )

	cmp	DWORD PTR _datafile_flag, 1
	jne	SHORT $LN53@read_const@2
	mov	eax, DWORD PTR [esi+32]
	and	eax, 4096				; 00001000H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN53@read_const@2
	cmp	DWORD PTR _addload_flag, ecx
	jne	SHORT $LN53@read_const@2

; 675  :         { sprintf(errmsg,"Constraint name %s already used.\n",yytext);

	mov	eax, DWORD PTR _yytext
	push	eax
	push	OFFSET ??_C@_0CC@NPLINMK@Constraint?5name?5?$CFs?5already?5used?4@
	push	OFFSET _errmsg
	call	_sprintf

; 676  :           kb_error(2122,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	2122					; 0000084aH
	call	_kb_error

; 677  :           tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	mov	DWORD PTR _tok, eax

; 678  :           return -1;

	or	eax, -1
	pop	ebx

; 877  : } // end read_constraint()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@read_const@2:

; 679  :         }
; 680  :         else 
; 681  :         { cnum = i;
; 682  :           con->attr &= ~CON_FORWARD_DEF;

	mov	ecx, DWORD PTR [esi+36]
	and	DWORD PTR [esi+32], -4097		; ffffefffH
	mov	DWORD PTR [esi+36], ecx
	mov	eax, DWORD PTR _web+652
	mov	ebx, DWORD PTR _web+644
$LN113@read_const@2:

; 683  :           break;
; 684  :         }
; 685  :       }
; 686  :     }
; 687  :     if ( i >= web.maxcon )

	mov	DWORD PTR _cnum$[ebp], edi
	cmp	edi, ebx
	jl	$LN51@read_const@2
	jmp	$LN124@read_const@2
$LN93@read_const@2:

; 700  :       globals(k)->flags |= CONSTRAINT_NAME;

	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN91@read_const@2
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN92@read_const@2
$LN91@read_const@2:
	mov	ecx, DWORD PTR _web+5652
	mov	esi, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [ecx+esi]
$LN92@read_const@2:
	or	DWORD PTR [ecx+192], 131072		; 00020000H

; 701  :       globals(k)->value.cnum = cnum;

	cmp	edx, 268435456				; 10000000H
	je	SHORT $LN97@read_const@2
	cmp	edx, 805306368				; 30000000H
	jne	SHORT $LN99@read_const@2
	mov	edx, DWORD PTR _localbase
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN98@read_const@2
$LN99@read_const@2:
	cmp	edx, 536870912				; 20000000H
	jne	SHORT $LN97@read_const@2
	mov	ecx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN98@read_const@2
$LN97@read_const@2:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN98@read_const@2:
	mov	edx, DWORD PTR _cnum$[ebp]
	mov	DWORD PTR [eax+64], edx
$LN152@read_const@2:
	mov	eax, DWORD PTR _web+652
$LN48@read_const@2:

; 702  :     }
; 703  :   } // end else named constraint
; 704  : 
; 705  :   con = GETCONSTR(cnum);

	mov	ebx, DWORD PTR _cnum$[ebp]
	mov	esi, ebx
	imul	esi, 176				; 000000b0H
	add	esi, eax

; 706  :   // fix memory leak for addload
; 707  :   if ( con->formula )

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN142@read_const@2

; 708  :   { free_expr(con->formula);

	push	eax
	call	_free_expr
	add	esp, 4
	lea	edi, DWORD PTR [esi+48]
	mov	ebx, 15					; 0000000fH
	npad	1
$LL46@read_const@2:

; 709  :     for ( i = 0 ; i < MAXCONCOMP ; i++ )
; 710  :     { free_expr(con->convect[i]);

	mov	eax, DWORD PTR [edi+60]
	push	eax
	call	_free_expr

; 711  :       free_expr(con->envect[i]);

	mov	ecx, DWORD PTR [edi]
	push	ecx
	call	_free_expr
	add	esp, 8
	add	edi, 4
	dec	ebx
	jne	SHORT $LL46@read_const@2

; 712  :     }
; 713  :     myfree((char*)con->formula);

	mov	edx, DWORD PTR [esi+40]
	push	edx
	call	_myfree
	mov	ebx, DWORD PTR _cnum$[ebp]
	add	esp, 4
$LN142@read_const@2:

; 714  :   }
; 715  : 
; 716  :   memset((char*)con,0,sizeof(struct constraint));

	push	176					; 000000b0H
	push	0
	push	esi
	mov	edi, 1
	call	_memset
	add	esp, 12					; 0000000cH

; 717  :   if ( tok == INTEGER_TOK )

	cmp	DWORD PTR _tok, 265			; 00000109H
	jne	SHORT $LN43@read_const@2

; 718  :     sprintf(con->name,"%d",cnum);

	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	esi
	call	_sprintf
	add	esp, 12					; 0000000cH

; 719  :   else

	jmp	SHORT $LN42@read_const@2
$LN43@read_const@2:

; 720  :   { strncpy(con->name,yytext,CONNAMESIZE-1);

	mov	eax, DWORD PTR _yytext
	push	31					; 0000001fH
	push	eax
	push	esi
	call	_strncpy

; 721  :     con->attr |= NAMED_THING;

	mov	ecx, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
	or	DWORD PTR [esi+32], 512			; 00000200H
	mov	DWORD PTR [esi+36], ecx
$LN42@read_const@2:

; 722  :   }
; 723  :   con->attr |= IN_USE;

	mov	edx, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], 32			; 00000020H

; 724  :   tok = yylex();

	push	0
	mov	DWORD PTR [esi+36], edx
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 725  :   if ( tok == ';' )

	cmp	eax, 59					; 0000003bH
	jne	SHORT $LL40@read_const@2

; 726  :   { con->attr |= CON_FORWARD_DEF;

	mov	eax, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], 4096		; 00001000H
	mov	DWORD PTR [esi+36], eax

; 727  :     verb_flag = 0; /* ';' sets verb_flag */
; 728  :     tok = yylex();

	push	0
	mov	DWORD PTR _verb_flag, 0
	call	_kb_yylex

; 875  :     convert_constraint_to_quantities(cnum);

	add	esp, 4
	pop	edi
	mov	DWORD PTR _tok, eax
	pop	esi

; 876  :   return cnum;

	mov	eax, ebx
	pop	ebx

; 877  : } // end read_constraint()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN151@read_const@2:

; 740  :           tok = yylex();  /* lookahead */

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LL40@read_const@2:

; 729  :     return cnum;
; 730  :   } 
; 731  :   for ( more_attr = 1 ; more_attr ; )
; 732  :     switch ( tok )

	cmp	eax, 35001				; 000088b9H
	jg	$LN103@read_const@2
	je	SHORT $LN36@read_const@2
	sub	eax, 387				; 00000183H
	je	SHORT $LN31@read_const@2
	sub	eax, edi
	je	SHORT $LN32@read_const@2
	sub	eax, 160				; 000000a0H
	jne	$LN137@read_const@2

; 764  :           one_sided_present = 1;
; 765  :           tok = yylex();
; 766  :           break;
; 767  : 
; 768  :       case GLOBAL_TOK:
; 769  :           web.constr_flag = 1;

	mov	DWORD PTR _web+848, edi

; 770  :           con->attr |= GLOBAL;

	mov	ecx, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], 4
	mov	DWORD PTR [esi+36], ecx

; 771  :           web.con_global_map[web.con_global_count++] = (conmap_t)cnum;

	mov	edx, DWORD PTR _web+748
	mov	DWORD PTR _web[edx*4+656], ebx
	add	DWORD PTR _web+748, edi

; 772  :           tok = yylex();
; 773  :           break;

	jmp	SHORT $LN151@read_const@2
$LN32@read_const@2:

; 753  : 
; 754  :       case NONNEGATIVE_TOK:
; 755  :           web.constr_flag = 1;

	mov	DWORD PTR _web+848, edi

; 756  :           con->attr |= NONNEGATIVE;

	mov	eax, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], 2
	mov	DWORD PTR [esi+36], eax

; 757  :           one_sided_present = 1;

	mov	DWORD PTR _one_sided_present, edi

; 758  :           tok = yylex();
; 759  :           break;

	jmp	SHORT $LN151@read_const@2
$LN31@read_const@2:

; 760  : 
; 761  :       case NONPOSITIVE_TOK:
; 762  :           web.constr_flag = 1;

	mov	DWORD PTR _web+848, edi

; 763  :           con->attr |= NONPOSITIVE;

	mov	ecx, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+36], ecx
	mov	DWORD PTR _one_sided_present, edi
	jmp	$LN151@read_const@2
$LN36@read_const@2:

; 733  :     {
; 734  :       case CONTENT_RANK_TOK:
; 735  :         { REAL rank;
; 736  :           if ( read_const(&rank) < 0 )

	lea	edx, DWORD PTR _rank$89775[ebp]
	push	edx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jns	SHORT $LN35@read_const@2

; 737  :             kb_error(1911,"Need integer value for content_rank.\n",
; 738  :               DATAFILE_ERROR); 

	push	6
	push	OFFSET ??_C@_0CG@BIJAAKHM@Need?5integer?5value?5for?5content_r@
	push	1911					; 00000777H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN35@read_const@2:

; 739  :           con->content_rank = (int)rank;

	fld	QWORD PTR _rank$89775[ebp]
	call	__ftol2_sse
	mov	DWORD PTR [esi+172], eax

; 741  :           break;

	jmp	$LN151@read_const@2
$LN103@read_const@2:

; 729  :     return cnum;
; 730  :   } 
; 731  :   for ( more_attr = 1 ; more_attr ; )
; 732  :     switch ( tok )

	sub	eax, 35090				; 00008912H
	je	SHORT $LN34@read_const@2
	sub	eax, edi
	jne	SHORT $LN137@read_const@2

; 746  :           tok = yylex();
; 747  :           break;
; 748  : 
; 749  :       case NONWALL_TOK:
; 750  :           con->attr |= NONWALL;

	mov	eax, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], 1024		; 00000400H
	mov	DWORD PTR [esi+36], eax

; 751  :           tok = yylex();
; 752  :           break;

	jmp	$LN151@read_const@2
$LN34@read_const@2:

; 742  :         }
; 743  :       case CONVEX_TOK:
; 744  :           web.convex_flag = 1;

	mov	DWORD PTR _web+840, edi

; 745  :           con->attr |= B_CONVEX;

	mov	ecx, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], 8
	mov	DWORD PTR [esi+36], ecx
	jmp	$LN151@read_const@2
$LN137@read_const@2:

; 774  : 
; 775  :       default: more_attr = 0;
; 776  :     }
; 777  :      
; 778  :   if ( one_sided_present && (raw_velocity_attr < 0) )

	cmp	DWORD PTR _one_sided_present, 0
	je	SHORT $LN28@read_const@2
	cmp	DWORD PTR _raw_velocity_attr, 0
	jge	SHORT $LN28@read_const@2

; 779  :   { int dim = SDIM;

	mov	edx, DWORD PTR _web+616

; 780  :     raw_velocity_attr = add_attribute(VERTEX,RAW_VELOCITY_ATTR_NAME,
; 781  :         REAL_TYPE,1,&dim,0,NULL,MPI_PROPAGATE);

	push	edi
	push	0
	push	0
	lea	eax, DWORD PTR _dim$89792[ebp]
	push	eax
	push	edi
	push	edi
	push	OFFSET ??_C@_0N@JNGNPCNJ@raw_velocity?$AA@
	push	0
	mov	DWORD PTR _dim$89792[ebp], edx
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _raw_velocity_attr, eax
$LN28@read_const@2:

; 782  :   }
; 783  : 
; 784  :   /* read and parse defining function */
; 785  :   constraint_init(con);

	push	esi
	call	_constraint_init
	add	esp, 4

; 786  :   if ( tok != FUNCTION_TOK )

	cmp	DWORD PTR _tok, 428			; 000001acH
	je	SHORT $LN27@read_const@2

; 787  :   { sprintf(errmsg,
; 788  :        "Expected function definition for constraint %s.\n",con->name);

	push	esi
	push	OFFSET ??_C@_0DB@GJPFJFHG@Expected?5function?5definition?5for@
	push	OFFSET _errmsg
	call	_sprintf

; 789  :     kb_error(1691,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1691					; 0000069bH
	call	_kb_error
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 876  :   return cnum;

	mov	eax, ebx
	pop	ebx

; 877  : } // end read_constraint()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@read_const@2:

; 790  :     return cnum;
; 791  :   }
; 792  :   esize = exparse(SDIM,con->formula,USERCOPY);

	mov	ecx, DWORD PTR [esi+40]
	mov	edx, DWORD PTR _web+616
	push	edi
	push	ecx
	push	edx
	call	_exparse

; 793  :   tok = yylex();

	push	0
	mov	edi, eax
	call	_kb_yylex
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tok, eax

; 794  :   if ( esize <= 0 )
; 795  :   { sprintf(errmsg,"Bad function definition for constraint %s.\n",con->name);

	push	esi
	test	edi, edi
	jg	SHORT $LN26@read_const@2
	push	OFFSET ??_C@_0CM@PDFNDLGB@Bad?5function?5definition?5for?5cons@
	push	OFFSET _errmsg
	call	_sprintf

; 796  :     kb_error(1692,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1692					; 0000069cH
	call	_kb_error
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 876  :   return cnum;

	mov	eax, ebx
	pop	ebx

; 877  : } // end read_constraint()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@read_const@2:

; 797  :     return cnum;
; 798  :   }
; 799  :   sprintf(msg,"constraint %s formula",con->name);

	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0BG@FPIMEADN@constraint?5?$CFs?5formula?$AA@
	push	eax
	call	_sprintf

; 800  :   strncpy(con->formula->name,msg,EXPNAMESIZE-1);

	mov	ecx, DWORD PTR _msg
	mov	edx, DWORD PTR [esi+40]
	push	63					; 0000003fH
	push	ecx
	add	edx, 20					; 00000014H
	push	edx
	call	_strncpy
	add	esp, 24					; 00000018H
	npad	1
$LL25@read_const@2:

; 801  : 
; 802  :   /* various integrands */
; 803  :   done_flag = 0;
; 804  :   while ( !done_flag )
; 805  :     switch ( tok )

	mov	eax, DWORD PTR _tok
	cmp	eax, 438				; 000001b6H
	je	$LN21@read_const@2
	cmp	eax, 35094				; 00008916H
	jne	$LN24@read_const@2

; 833  :       break;
; 834  : 
; 835  :      case CONTENT_TOK:
; 836  :       /* read and parse content vector potential */
; 837  :       tok = yylex();

	push	0
	call	_kb_yylex
	mov	DWORD PTR _tok, eax

; 838  :       con->attr |= CON_CONTENT;

	mov	eax, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], 128			; 00000080H
	mov	DWORD PTR [esi+36], eax

; 839  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 4
	xor	edi, edi
	test	eax, eax
	jle	$LN115@read_const@2

; 833  :       break;
; 834  : 
; 835  :      case CONTENT_TOK:
; 836  :       /* read and parse content vector potential */
; 837  :       tok = yylex();

	lea	ebx, DWORD PTR [esi+108]
	npad	7
$LL145@read_const@2:

; 840  :       {
; 841  :         if ( (tolower(yytext[0]) != 'c') || (yytext[1] != '1' + i) )

	mov	ecx, DWORD PTR _yytext
	movsx	edx, BYTE PTR [ecx]
	cmp	BYTE PTR _kb_lower_array[edx], 99	; 00000063H
	jne	SHORT $LN115@read_const@2
	movsx	ecx, BYTE PTR [ecx+1]
	lea	edx, DWORD PTR [edi+49]
	cmp	ecx, edx
	jne	SHORT $LN115@read_const@2

; 842  :           break;
; 843  :        esize = exparse(SDIM,con->convect[i],USERCOPY);

	mov	ecx, DWORD PTR [ebx]
	push	1
	push	ecx
	push	eax
	call	_exparse

; 844  :        tok = yylex();

	push	0
	mov	DWORD PTR _esize$[ebp], eax
	call	_kb_yylex
	add	esp, 16					; 00000010H
	inc	edi

; 845  :        if ( esize <= 0 )

	cmp	DWORD PTR _esize$[ebp], 0
	mov	DWORD PTR _tok, eax
	jle	$LN116@read_const@2

; 851  :        }
; 852  :        sprintf(msg,"constraint %s content component %d",con->name,i+1);

	mov	edx, DWORD PTR _msg
	push	edi
	push	esi
	push	OFFSET ??_C@_0CD@HNOAGEMA@constraint?5?$CFs?5content?5component?5@
	push	edx
	call	_sprintf

; 853  :        strncpy(con->convect[i]->name,msg,EXPNAMESIZE-1);

	mov	eax, DWORD PTR _msg
	mov	ecx, DWORD PTR [ebx]
	push	63					; 0000003fH
	push	eax
	add	ecx, 20					; 00000014H
	push	ecx
	call	_strncpy
	mov	eax, DWORD PTR _web+616
	add	esp, 28					; 0000001cH
	add	ebx, 4
	cmp	edi, eax
	jl	SHORT $LL145@read_const@2
$LN115@read_const@2:

; 854  :       }
; 855  :       /* check consistency of number of components */
; 856  :       if ( con->compcount )

	mov	ecx, DWORD PTR [esi+44]
	test	ecx, ecx
	je	SHORT $LN6@read_const@2

; 857  :       { if ( con->compcount != i )

	cmp	ecx, edi
	je	SHORT $LN4@read_const@2

; 858  :           kb_error(1695,
; 859  :             "Inconsistent number of components in content integrand.\n",
; 860  :                WARNING);

	push	2
	push	OFFSET ??_C@_0DJ@BCGNCPOM@Inconsistent?5number?5of?5component@
	push	1695					; 0000069fH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 861  :       }
; 862  :       else

	jmp	SHORT $LN4@read_const@2
$LN6@read_const@2:

; 863  :       { if ( (i != 1) && (i != SDIM) )

	cmp	edi, 1
	je	SHORT $LN3@read_const@2
	cmp	edi, eax
	je	SHORT $LN3@read_const@2

; 864  :           kb_error(1696,"Illegal number of components in content integrand.\n",
; 865  :                   DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DE@PDLGGICP@Illegal?5number?5of?5components?5in?5@
	push	1696					; 000006a0H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN3@read_const@2:

; 866  :         con->compcount = i;

	mov	DWORD PTR [esi+44], edi
$LN4@read_const@2:

; 867  :       }
; 868  :       con->attr |= CON_CONTENT;

	mov	edx, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], 128			; 00000080H

; 869  :       break;

	mov	ebx, DWORD PTR _cnum$[ebp]
	mov	DWORD PTR [esi+36], edx
	jmp	$LL25@read_const@2
$LN21@read_const@2:

; 806  :     { 
; 807  :      case ENERGY_TOK:
; 808  :       /* read and parse energy function */
; 809  :       tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 810  :       for ( i = 0 ; i < MAXCONCOMP ; i++ )

	xor	edi, edi
	lea	ebx, DWORD PTR [esi+48]
	npad	12
$LL146@read_const@2:

; 811  :       {
; 812  :        if ( (tolower(yytext[0]) != 'e') || (yytext[1] != '1' + i) )

	mov	eax, DWORD PTR _yytext
	movsx	ecx, BYTE PTR [eax]
	cmp	BYTE PTR _kb_lower_array[ecx], 101	; 00000065H
	jne	SHORT $LN117@read_const@2
	movsx	edx, BYTE PTR [eax+1]
	lea	eax, DWORD PTR [edi+49]
	cmp	edx, eax
	jne	SHORT $LN117@read_const@2

; 813  :             break;
; 814  :        esize = exparse(SDIM,con->envect[i],USERCOPY);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR _web+616
	push	1
	push	ecx
	push	edx
	call	_exparse

; 815  :        tok = yylex();  

	push	0
	mov	DWORD PTR _esize$[ebp], eax
	call	_kb_yylex
	add	esp, 16					; 00000010H
	inc	edi

; 816  :        if ( esize <= 0 )

	cmp	DWORD PTR _esize$[ebp], 0
	mov	DWORD PTR _tok, eax
	jle	$LN118@read_const@2

; 822  :        }
; 823  :        sprintf(msg,"constraint %s energy component %d",con->name,i+1);

	mov	eax, DWORD PTR _msg
	push	edi
	push	esi
	push	OFFSET ??_C@_0CC@BLJHHNJG@constraint?5?$CFs?5energy?5component?5?$CF@
	push	eax
	call	_sprintf

; 824  :        strncpy(con->envect[i]->name,msg,EXPNAMESIZE-1);

	mov	ecx, DWORD PTR _msg
	mov	edx, DWORD PTR [ebx]
	push	63					; 0000003fH
	push	ecx
	add	edx, 20					; 00000014H
	push	edx
	call	_strncpy
	add	esp, 28					; 0000001cH
	add	ebx, 4
	cmp	edi, 15					; 0000000fH
	jl	SHORT $LL146@read_const@2
$LN117@read_const@2:

; 825  :       }
; 826  :       if ( i == 0 )

	test	edi, edi
	jne	SHORT $LN14@read_const@2

; 827  :       { sprintf(errmsg,"Missing energy components for constraint %s\n",
; 828  :              con->name);

	push	esi
	push	OFFSET ??_C@_0CN@BGHOKPDI@Missing?5energy?5components?5for?5co@
	push	OFFSET _errmsg
	call	_sprintf

; 829  :         kb_error(3228,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	3228					; 00000c9cH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN14@read_const@2:

; 830  :       }
; 831  :       con->compcount = i;
; 832  :       con->attr |= CON_ENERGY;

	mov	eax, DWORD PTR [esi+36]
	or	DWORD PTR [esi+32], 64			; 00000040H
	mov	ebx, DWORD PTR _cnum$[ebp]
	mov	DWORD PTR [esi+44], edi
	mov	DWORD PTR [esi+36], eax
	jmp	$LL25@read_const@2
$LN116@read_const@2:

; 846  :        { sprintf(errmsg,
; 847  :               "Bad content component %d definition for constraint %s.\n",
; 848  :                   i+1,con->name);

	push	esi
	push	edi
	push	OFFSET ??_C@_0DI@PHBBKCHF@Bad?5content?5component?5?$CFd?5definit@
	push	OFFSET _errmsg
	call	_sprintf

; 849  :          kb_error(1694,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1694					; 0000069eH
	call	_kb_error

; 850  :          return cnum;

	mov	eax, DWORD PTR _cnum$[ebp]
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 877  : } // end read_constraint()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN118@read_const@2:

; 817  :        { sprintf(errmsg,
; 818  :             "Bad energy component %d definition for constraint %s.\n",
; 819  :                i+1,con->name);

	push	esi
	push	edi
	push	OFFSET ??_C@_0DH@EGAOMJJD@Bad?5energy?5component?5?$CFd?5definiti@
	push	OFFSET _errmsg
	call	_sprintf

; 820  :          kb_error(1693,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1693					; 0000069dH
	call	_kb_error

; 821  :          return cnum;

	mov	eax, DWORD PTR _cnum$[ebp]
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 877  : } // end read_constraint()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@read_const@2:

; 870  : 
; 871  :      default: done_flag = 1; break; 
; 872  :     } /* end switch for integrands */
; 873  : 
; 874  :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN1@read_const@2

; 875  :     convert_constraint_to_quantities(cnum);

	push	ebx
	call	_convert_constraint_to_quantities
	add	esp, 4
$LN1@read_const@2:

; 876  :   return cnum;

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 877  : } // end read_constraint()

	mov	esp, ebp
	pop	ebp
	ret	0
_read_constraint ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DM@OLABLKBN@?$CFs?3?5Cannot?5use?5boundary?5paramete@ ; `string'
PUBLIC	??_C@_0DL@HEFJICEC@Need?5k_vector_order?5and?5vector_i@ ; `string'
PUBLIC	??_C@_0CI@FEILCMAD@Need?5vector?5integrand?5for?5this?5m@ ; `string'
PUBLIC	??_C@_0CI@KEFMBOI@Need?5scalar?5integrand?5for?5this?5m@ ; `string'
PUBLIC	??_C@_0BP@IPGPKEG@?$CFs?5form?5integrand?5component?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0CG@CLIJAHGB@No?52?9form?5integrand?5for?5this?5met@ ; `string'
PUBLIC	??_C@_0DO@OGCLCHKJ@k_vector?5method?5needs?5only?5?$CFd?5?$CIc@ ; `string'
PUBLIC	??_C@_0CD@IBENPDAK@Expected?5component?5?$CFd?5definition@ ; `string'
PUBLIC	??_C@_0CB@BPDAEIFH@?$CFs?5vector?5integrand?5component?5?$CFd@ ; `string'
PUBLIC	??_C@_0BO@NHINACAL@Bad?5component?5?$CFd?5definition?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CE@GPKNNOIL@Total?5components?5exceeds?5MAXMEXP@ ; `string'
PUBLIC	??_C@_0BG@HOIHGKBM@Need?5k_vector_order?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CG@KFNLCANI@No?5vector?5integrand?5for?5this?5met@ ; `string'
PUBLIC	??_C@_0BE@LOCGBJCF@?$CFs?5scalar?5integrand?$AA@ ; `string'
PUBLIC	??_C@_0BL@JJIGCOIM@Bad?5integrand?5definition?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CG@PLBFMNDD@No?5scalar?5integrand?5for?5this?5met@ ; `string'
PUBLIC	??_C@_0BM@OEDELGEO@Missing?5parameter_2?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@PADANEN@Missing?5parameter_1?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@NBIOFLBJ@Missing?5k_vector_order?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CO@JPDKDMKJ@Element?5modulus?5attribute?5type?5m@ ; `string'
PUBLIC	??_C@_0CP@OILAAJEO@Extra?5attribute?5is?5for?5wrong?5typ@ ; `string'
PUBLIC	??_C@_0DC@BCJBEDJP@Need?5extra?5attribute?5name?5after?5@ ; `string'
PUBLIC	??_C@_0BC@JMFGPLPH@Missing?5modulus?4?6?$AA@	; `string'
PUBLIC	_read_instance_attr
EXTRN	_isdigit:PROC
EXTRN	_atoi:PROC
EXTRN	_sqcurve_ignore_constr:DWORD
EXTRN	_find_extra:PROC
EXTRN	_idname:BYTE
EXTRN	_basic_gen_methods:BYTE
;	COMDAT ??_C@_0DM@OLABLKBN@?$CFs?3?5Cannot?5use?5boundary?5paramete@
CONST	SEGMENT
??_C@_0DM@OLABLKBN@?$CFs?3?5Cannot?5use?5boundary?5paramete@ DB '%s: Cann'
	DB	'ot use boundary parameters in gradient or hessian.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HEFJICEC@Need?5k_vector_order?5and?5vector_i@
CONST	SEGMENT
??_C@_0DL@HEFJICEC@Need?5k_vector_order?5and?5vector_i@ DB 'Need k_vector'
	DB	'_order and vector_integrand for this method.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FEILCMAD@Need?5vector?5integrand?5for?5this?5m@
CONST	SEGMENT
??_C@_0CI@FEILCMAD@Need?5vector?5integrand?5for?5this?5m@ DB 'Need vector'
	DB	' integrand for this method.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KEFMBOI@Need?5scalar?5integrand?5for?5this?5m@
CONST	SEGMENT
??_C@_0CI@KEFMBOI@Need?5scalar?5integrand?5for?5this?5m@ DB 'Need scalar '
	DB	'integrand for this method.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IPGPKEG@?$CFs?5form?5integrand?5component?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BP@IPGPKEG@?$CFs?5form?5integrand?5component?5?$CFd?$AA@ DB '%s fo'
	DB	'rm integrand component %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CLIJAHGB@No?52?9form?5integrand?5for?5this?5met@
CONST	SEGMENT
??_C@_0CG@CLIJAHGB@No?52?9form?5integrand?5for?5this?5met@ DB 'No 2-form '
	DB	'integrand for this method.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@OGCLCHKJ@k_vector?5method?5needs?5only?5?$CFd?5?$CIc@
CONST	SEGMENT
??_C@_0DO@OGCLCHKJ@k_vector?5method?5needs?5only?5?$CFd?5?$CIc@ DB 'k_vec'
	DB	'tor method needs only %d (complement of order) vectors.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IBENPDAK@Expected?5component?5?$CFd?5definition@
CONST	SEGMENT
??_C@_0CD@IBENPDAK@Expected?5component?5?$CFd?5definition@ DB 'Expected c'
	DB	'omponent %d definition.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BPDAEIFH@?$CFs?5vector?5integrand?5component?5?$CFd@
CONST	SEGMENT
??_C@_0CB@BPDAEIFH@?$CFs?5vector?5integrand?5component?5?$CFd@ DB '%s vec'
	DB	'tor integrand component %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NHINACAL@Bad?5component?5?$CFd?5definition?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@NHINACAL@Bad?5component?5?$CFd?5definition?4?6?$AA@ DB 'Bad com'
	DB	'ponent %d definition.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GPKNNOIL@Total?5components?5exceeds?5MAXMEXP@
CONST	SEGMENT
??_C@_0CE@GPKNNOIL@Total?5components?5exceeds?5MAXMEXP@ DB 'Total compone'
	DB	'nts exceeds MAXMEXPR.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HOIHGKBM@Need?5k_vector_order?4?6?$AA@
CONST	SEGMENT
??_C@_0BG@HOIHGKBM@Need?5k_vector_order?4?6?$AA@ DB 'Need k_vector_order.'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KFNLCANI@No?5vector?5integrand?5for?5this?5met@
CONST	SEGMENT
??_C@_0CG@KFNLCANI@No?5vector?5integrand?5for?5this?5met@ DB 'No vector i'
	DB	'ntegrand for this method.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LOCGBJCF@?$CFs?5scalar?5integrand?$AA@
CONST	SEGMENT
??_C@_0BE@LOCGBJCF@?$CFs?5scalar?5integrand?$AA@ DB '%s scalar integrand', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JJIGCOIM@Bad?5integrand?5definition?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@JJIGCOIM@Bad?5integrand?5definition?4?6?$AA@ DB 'Bad integrand '
	DB	'definition.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PLBFMNDD@No?5scalar?5integrand?5for?5this?5met@
CONST	SEGMENT
??_C@_0CG@PLBFMNDD@No?5scalar?5integrand?5for?5this?5met@ DB 'No scalar i'
	DB	'ntegrand for this method.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OEDELGEO@Missing?5parameter_2?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@OEDELGEO@Missing?5parameter_2?5value?4?6?$AA@ DB 'Missing param'
	DB	'eter_2 value.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PADANEN@Missing?5parameter_1?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@PADANEN@Missing?5parameter_1?5value?4?6?$AA@ DB 'Missing parame'
	DB	'ter_1 value.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NBIOFLBJ@Missing?5k_vector_order?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@NBIOFLBJ@Missing?5k_vector_order?5value?4?6?$AA@ DB 'Missing k_'
	DB	'vector_order value.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JPDKDMKJ@Element?5modulus?5attribute?5type?5m@
CONST	SEGMENT
??_C@_0CO@JPDKDMKJ@Element?5modulus?5attribute?5type?5m@ DB 'Element modu'
	DB	'lus attribute type must be REAL.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OILAAJEO@Extra?5attribute?5is?5for?5wrong?5typ@
CONST	SEGMENT
??_C@_0CP@OILAAJEO@Extra?5attribute?5is?5for?5wrong?5typ@ DB 'Extra attri'
	DB	'bute is for wrong type of element.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BCJBEDJP@Need?5extra?5attribute?5name?5after?5@
CONST	SEGMENT
??_C@_0DC@BCJBEDJP@Need?5extra?5attribute?5name?5after?5@ DB 'Need extra '
	DB	'attribute name after ELEMENT_MODULUS.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JMFGPLPH@Missing?5modulus?4?6?$AA@
CONST	SEGMENT
??_C@_0BC@JMFGPLPH@Missing?5modulus?4?6?$AA@ DB 'Missing modulus.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _read_instance_attr
_TEXT	SEGMENT
_val$ = -44						; size = 8
tv641 = -36						; size = 4
_etype$ = -32						; size = 4
tv388 = -28						; size = 4
tv327 = -28						; size = 4
_esize$ = -28						; size = 4
tv1041 = -24						; size = 4
_i$ = -24						; size = 4
tv953 = -20						; size = 4
tv283 = -20						; size = 4
_comps$ = -20						; size = 4
_expr_count$ = -16					; size = 4
_gm$ = -12						; size = 4
_mi$ = -8						; size = 4
_spec_flag$ = -4					; size = 4
_mnum$ = 8						; size = 4
_read_instance_attr PROC				; COMDAT

; 952  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 953  :   int bflag;
; 954  :   int spec_flag = 0;
; 955  :   int esize,i;
; 956  :   struct gen_quant_method *gm;
; 957  :   struct method_instance *mi = METH_INSTANCE(mnum);

	mov	eax, DWORD PTR _mnum$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	mov	DWORD PTR tv641[ebp], eax
	add	eax, DWORD PTR _meth_inst_list
	push	ebx
	mov	DWORD PTR _mi$[ebp], eax

; 958  :   int comps,etype;
; 959  :   REAL val;
; 960  :   int expr_count = 0;
; 961  : 
; 962  :   gm = basic_gen_methods + mi->gen_method;

	mov	eax, DWORD PTR [eax+148]
	mov	ebx, DWORD PTR _mi$[ebp]
	lea	eax, DWORD PTR [eax+eax*4]
	xor	ecx, ecx
	shl	eax, 5
	push	esi
	add	eax, OFFSET _basic_gen_methods
	push	edi
	mov	DWORD PTR _spec_flag$[ebp], ecx
	mov	DWORD PTR _expr_count$[ebp], ecx
	mov	DWORD PTR _gm$[ebp], eax
	mov	edi, eax
	jmp	SHORT $LL74@read_insta
	npad	10
$LL96@read_insta:

; 963  :   /* read further attributes of instance */
; 964  :   for (bflag=0;bflag==0;)

	mov	ebx, DWORD PTR _mi$[ebp]
$LN97@read_insta:

; 973  :              kb_error(1711,"Missing modulus.\n",WARNING);

	mov	edi, DWORD PTR _gm$[ebp]
	npad	10
$LL74@read_insta:

; 965  :      switch ( tok )

	mov	eax, DWORD PTR _tok
	cmp	eax, 35009				; 000088c1H
	jg	$LN77@read_insta
	je	SHORT $LN65@read_insta
	sub	eax, 473				; 000001d9H
	je	SHORT $LN68@read_insta
	sub	eax, 75					; 0000004bH
	jne	$LN94@read_insta

; 966  :      { case GLOBAL_TOK:
; 967  :           if ( !(mi->flags & GLOBAL_INST) )

	test	DWORD PTR [ebx+140], 1073741824		; 40000000H
	jne	SHORT $LN101@read_insta

; 968  :              apply_method_num(NULLID,mnum); 

	mov	eax, DWORD PTR _mnum$[ebp]
	push	eax
	push	0
	call	_apply_method_num
	add	esp, 8
$LN101@read_insta:

; 969  :           tok = yylex(); 

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 970  :           break;

	jmp	SHORT $LL74@read_insta
$LN68@read_insta:

; 971  :        case MODULUS_TOK:
; 972  :           if ( read_const(&(mi->modulus))  <= 0 )

	lea	ecx, DWORD PTR [ebx+304]
	push	ecx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN101@read_insta

; 973  :              kb_error(1711,"Missing modulus.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BC@JMFGPLPH@Missing?5modulus?4?6?$AA@
	push	1711					; 000006afH
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LL74@read_insta
$LN65@read_insta:

; 974  :           else tok = yylex();
; 975  :           break;
; 976  :        case ELEMENT_MODULUS_TOK:
; 977  :           tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 978  :           if ( tok != EXTRA_ATTRIBUTE_TOK )

	cmp	eax, 284				; 0000011cH
	je	SHORT $LN102@read_insta

; 979  :              kb_error(2123,"Need extra attribute name after ELEMENT_MODULUS.\n",
; 980  :                 DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DC@BCJBEDJP@Need?5extra?5attribute?5name?5after?5@
	push	2123					; 0000084bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN102@read_insta:

; 981  :           mi->elmodulus = find_extra(idname,&etype);

	lea	edx, DWORD PTR _etype$[ebp]
	push	edx
	push	OFFSET _idname
	call	_find_extra
	mov	DWORD PTR [ebx+228], eax

; 982  :           if ( etype != mi->type )

	mov	eax, DWORD PTR _etype$[ebp]
	add	esp, 8
	cmp	eax, DWORD PTR [ebx+136]
	je	SHORT $LN106@read_insta

; 983  :              kb_error(2124,"Extra attribute is for wrong type of element.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CP@OILAAJEO@Extra?5attribute?5is?5for?5wrong?5typ@
	push	2124					; 0000084cH
	call	_kb_error
	mov	eax, DWORD PTR _etype$[ebp]
	add	esp, 12					; 0000000cH
$LN106@read_insta:

; 984  :           if ( EXTRAS(etype)[mi->elmodulus].type != REAL_TYPE )

	mov	ecx, DWORD PTR [ebx+228]
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web[eax+104]
	cmp	DWORD PTR [ecx+edx+68], 1
	je	SHORT $LN62@read_insta

; 985  :              kb_error(2125,"Element modulus attribute type must be REAL.\n",
; 986  :               DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CO@JPDKDMKJ@Element?5modulus?5attribute?5type?5m@
	push	2125					; 0000084dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN62@read_insta:

; 987  :           mi->flags |= ELEMENT_MODULUS_FLAG;

	or	DWORD PTR [ebx+140], 268435456		; 10000000H

; 988  :           tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 989  :           break;

	jmp	$LL74@read_insta
$LN77@read_insta:

; 965  :      switch ( tok )

	sub	eax, 35015				; 000088c7H
	cmp	eax, 89					; 00000059H
	ja	$LN94@read_insta
	movzx	eax, BYTE PTR $LN93@read_insta[eax]
	jmp	DWORD PTR $LN116@read_insta[eax*4]
$LN61@read_insta:

; 990  :        case IGNORE_FIXED_TOK:
; 991  :           mi->flags |= IGNORE_FIXED;

	or	DWORD PTR [ebx+140], 134217728		; 08000000H

; 992  :           tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 993  :           break;

	jmp	$LL74@read_insta
$LN60@read_insta:

; 994  :        case IGNORE_CONSTRAINTS_TOK:
; 995  :           mi->flags |= IGNORE_CONSTR;

	or	DWORD PTR [ebx+140], 33554432		; 02000000H

; 996  :           sqcurve_ignore_constr = 1; /* kludge */
; 997  :           tok = yylex();

	push	0
	mov	DWORD PTR _sqcurve_ignore_constr, 1
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 998  :           break;

	jmp	$LL74@read_insta
$LN59@read_insta:

; 999  :        case K_VEC_ORDER_TOK:
; 1000 :           if ( read_const(&val)  <= 0 )

	lea	ecx, DWORD PTR _val$[ebp]
	push	ecx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN58@read_insta

; 1001 :           { kb_error(1712,"Missing k_vector_order value.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BP@NBIOFLBJ@Missing?5k_vector_order?5value?4?6?$AA@
	push	1712					; 000006b0H
	call	_kb_error

; 1002 :              val = 1.;

	fld1
	fstp	QWORD PTR _val$[ebp]
	add	esp, 12					; 0000000cH

; 1005 :           mi->vec_order = (int)val;

	fld	QWORD PTR _val$[ebp]
	call	__ftol2_sse
	mov	DWORD PTR [ebx+224], eax

; 1006 :           break;

	jmp	$LL74@read_insta
$LN58@read_insta:

; 1003 :           }
; 1004 :           else tok = yylex();

	push	0
	call	_kb_yylex

; 1005 :           mi->vec_order = (int)val;

	fld	QWORD PTR _val$[ebp]
	add	esp, 4
	mov	DWORD PTR _tok, eax
	call	__ftol2_sse
	mov	DWORD PTR [ebx+224], eax

; 1006 :           break;

	jmp	$LL74@read_insta
$LN56@read_insta:

; 1007 :        case PARAMETER_1_TOK:
; 1008 :           if ( read_const(&(mi->parameter_1))  <= 0 )

	lea	edx, DWORD PTR [ebx+2904]
	push	edx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN55@read_insta

; 1009 :              kb_error(1713,"Missing parameter_1 value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BM@PADANEN@Missing?5parameter_1?5value?4?6?$AA@
	push	1713					; 000006b1H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1011 :           mi->flags |= METH_PARAMETER_1;

	or	DWORD PTR [ebx+140], 8388608		; 00800000H

; 1012 :           break;

	jmp	$LL74@read_insta
$LN55@read_insta:

; 1010 :           else tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1011 :           mi->flags |= METH_PARAMETER_1;

	or	DWORD PTR [ebx+140], 8388608		; 00800000H

; 1012 :           break;

	jmp	$LL74@read_insta
$LN53@read_insta:

; 1013 :        case PARAMETER_2_TOK:
; 1014 :           if ( read_const(&(mi->parameter_2))  <= 0 )

	lea	eax, DWORD PTR [ebx+2912]
	push	eax
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN52@read_insta

; 1015 :              kb_error(2660,"Missing parameter_2 value.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BM@OEDELGEO@Missing?5parameter_2?5value?4?6?$AA@
	push	2660					; 00000a64H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1017 :           mi->flags2 |= METH_PARAMETER_2;

	or	DWORD PTR [ebx+144], 2

; 1018 :           break;

	jmp	$LL74@read_insta
$LN52@read_insta:

; 1016 :           else tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1017 :           mi->flags2 |= METH_PARAMETER_2;

	or	DWORD PTR [ebx+144], 2

; 1018 :           break;

	jmp	$LL74@read_insta
$LN50@read_insta:

; 1019 :        case CALC_IN_3D_TOK:
; 1020 :            mi->flags2 |= CALC_IN_3D;

	or	DWORD PTR [ebx+144], 1

; 1021 :            tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1022 :            break;

	jmp	$LL74@read_insta
$LN49@read_insta:

; 1023 :        case SCALAR_INTEGRAND_TOK: 
; 1024 :            /* read and parse integrand function */
; 1025 :            if ( !(gm->spec_flags & SPEC_SCALAR) )

	test	BYTE PTR [edi+136], 1
	jne	SHORT $LN103@read_insta

; 1026 :            { kb_error(1714,"No scalar integrand for this method.\n",
; 1027 :                DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CG@PLBFMNDD@No?5scalar?5integrand?5for?5this?5met@
	push	1714					; 000006b2H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN103@read_insta:

; 1028 :              /* read in anyway */
; 1029 :            }
; 1030 :            spec_flag |= SPEC_SCALAR;

	mov	eax, 1
	or	DWORD PTR _spec_flag$[ebp], eax

; 1031 :            expr_count = 1;
; 1032 :            if ( mi->expr[0] )

	cmp	DWORD PTR [ebx+232], 0
	mov	DWORD PTR _expr_count$[ebp], eax
	je	SHORT $LN44@read_insta

; 1033 :            { // in case of replace_load or something
; 1034 :              for ( i = 0 ; i < expr_count ; i++ )
; 1035 :                free_expr(mi->expr[i]);

	mov	ecx, DWORD PTR [ebx+232]
	push	ecx
	call	_free_expr
	add	esp, 4
$LN44@read_insta:

; 1036 :            }
; 1037 :            mi->expr[0] =
; 1038 :                (struct expnode *)kb_realloc((char*)mi->expr[0],expr_count*sizeof(struct expnode));

	mov	edx, DWORD PTR [ebx+232]
	push	1038					; 0000040eH
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	104					; 00000068H
	push	edx
	call	_KB_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ebx+232], eax

; 1039 :            if ( gm->spec_flags & SPEC_EXTRADIM )

	mov	ecx, DWORD PTR [edi+136]

; 1040 :            { esize = exparse(2*SDIM,mi->expr[0],USERCOPY);

	push	1
	push	eax
	test	cl, 8
	je	SHORT $LN43@read_insta
	mov	eax, DWORD PTR _web+616
	lea	ecx, DWORD PTR [eax+eax]
	push	ecx
	call	_exparse
	add	esp, 12					; 0000000cH

; 1041 :              spec_flag |= SPEC_EXTRADIM;

	or	DWORD PTR _spec_flag$[ebp], 8
	jmp	SHORT $LN114@read_insta
$LN43@read_insta:

; 1042 :            }
; 1043 :            else if ( gm->spec_flags & SPEC_EXTRADIM2 )

	test	cl, 16					; 00000010H
	je	SHORT $LN41@read_insta

; 1044 :            { esize = exparse(SDIM+(SDIM*(SDIM-1))/2,mi->expr[0],USERCOPY);

	mov	ecx, DWORD PTR _web+616
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	push	eax
	call	_exparse
	add	esp, 12					; 0000000cH

; 1045 :              spec_flag |= SPEC_EXTRADIM2;

	or	DWORD PTR _spec_flag$[ebp], 16		; 00000010H
	jmp	SHORT $LN114@read_insta
$LN41@read_insta:

; 1046 :            }
; 1047 :            else esize = exparse(SDIM,mi->expr[0],USERCOPY);

	mov	edx, DWORD PTR _web+616
	push	edx
	call	_exparse
	add	esp, 12					; 0000000cH
$LN114@read_insta:

; 1048 :            tok = yylex();

	push	0
	mov	esi, eax
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1049 :            if ( esize <= 0 )

	test	esi, esi
	jg	SHORT $LN39@read_insta

; 1050 :            { sprintf(errmsg, "Bad integrand definition.\n");

	push	OFFSET ??_C@_0BL@JJIGCOIM@Bad?5integrand?5definition?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1051 :              kb_error(1715,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1715					; 000006b3H
	call	_kb_error
	add	esp, 20					; 00000014H
$LN39@read_insta:

; 1052 :            }
; 1053 :            sprintf(msg, "%s scalar integrand", mi->name);

	mov	eax, DWORD PTR _msg
	push	ebx
	push	OFFSET ??_C@_0BE@LOCGBJCF@?$CFs?5scalar?5integrand?$AA@
	push	eax
	call	_sprintf

; 1054 :            strncpy(mi->expr[0]->name,msg,EXPNAMESIZE-1);

	mov	ecx, DWORD PTR _msg
	mov	edx, DWORD PTR [ebx+232]
	push	63					; 0000003fH
	push	ecx
	add	edx, 20					; 00000014H
	push	edx
	call	_strncpy
	add	esp, 24					; 00000018H

; 1055 :            break;

	jmp	$LL74@read_insta
$LN38@read_insta:

; 1056 : 
; 1057 :        case VECTOR_INTEGRAND_TOK:
; 1058 :            /* read and parse integrand vector */
; 1059 :            if ( !(gm->spec_flags & (SPEC_VECTOR|SPEC_KVECTOR)) )

	test	BYTE PTR [edi+136], 66			; 00000042H
	jne	SHORT $LN104@read_insta

; 1060 :            { kb_error(1716,"No vector integrand for this method.\n",
; 1061 :                 DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CG@KFNLCANI@No?5vector?5integrand?5for?5this?5met@
	push	1716					; 000006b4H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN104@read_insta:

; 1062 :              comps = SDIM;
; 1063 :              /* read vector integrand anyway to get past it */
; 1064 :            }
; 1065 :            if ( gm->spec_flags & SPEC_VECTOR )

	test	BYTE PTR [edi+136], 2
	je	SHORT $LN36@read_insta

; 1066 :            { spec_flag |= SPEC_VECTOR;

	or	DWORD PTR _spec_flag$[ebp], 2

; 1067 :              comps = SDIM;

	mov	edi, DWORD PTR _web+616

; 1068 :            }
; 1069 :            else /* SPEC_KVECTOR  */

	jmp	SHORT $LN107@read_insta
$LN36@read_insta:

; 1070 :            { spec_flag |= SPEC_KVECTOR;
; 1071 :              comps = (SDIM-mi->vec_order)*SDIM;

	mov	eax, DWORD PTR _web+616
	or	DWORD PTR _spec_flag$[ebp], 64		; 00000040H
	mov	edi, eax
	sub	edi, DWORD PTR [ebx+224]
	imul	edi, eax

; 1072 :              if ( comps <= 0 ) 

	test	edi, edi
	jg	SHORT $LN107@read_insta

; 1073 :                  kb_error(1717,"Need k_vector_order.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BG@HOIHGKBM@Need?5k_vector_order?4?6?$AA@
	push	1717					; 000006b5H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN107@read_insta:

; 1074 :            }
; 1075 :            if ( comps > MAXMEXPR )

	cmp	edi, 18					; 00000012H
	jle	SHORT $LN33@read_insta

; 1076 :               kb_error(1718,"Total components exceeds MAXMEXPR.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CE@GPKNNOIL@Total?5components?5exceeds?5MAXMEXP@
	push	1718					; 000006b6H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN33@read_insta:

; 1077 :            expr_count = comps;
; 1078 :            if ( mi->expr[0] )

	cmp	DWORD PTR [ebx+232], 0
	lea	esi, DWORD PTR [ebx+232]
	mov	DWORD PTR _expr_count$[ebp], edi
	je	SHORT $LN29@read_insta

; 1079 :            { // in case of replace_load or something
; 1080 :              for ( i = 0 ; i < expr_count ; i++ )

	test	edi, edi
	jle	SHORT $LN29@read_insta
	mov	DWORD PTR tv388[ebp], edi
	npad	1
$LL109@read_insta:

; 1081 :                free_expr(mi->expr[i]);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	_free_expr
	add	esp, 4
	add	esi, 4
	dec	DWORD PTR tv388[ebp]
	jne	SHORT $LL109@read_insta
$LN29@read_insta:

; 1082 :            }
; 1083 :            mi->expr[0]=(struct expnode *)kb_realloc((char*)mi->expr[0],
; 1084 :              comps*sizeof(struct expnode));

	mov	edx, DWORD PTR [ebx+232]
	mov	ecx, edi
	imul	ecx, 104				; 00000068H
	push	1084					; 0000043cH
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	ecx
	push	edx
	call	_KB_realloc

; 1085 :            tok = yylex();

	push	0
	mov	DWORD PTR [ebx+232], eax
	call	_kb_yylex
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tok, eax

; 1086 :            for ( i = 0 ; i < comps ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	edi, edi
	jle	$LN26@read_insta

; 1082 :            }
; 1083 :            mi->expr[0]=(struct expnode *)kb_realloc((char*)mi->expr[0],
; 1084 :              comps*sizeof(struct expnode));

	mov	esi, DWORD PTR _mi$[ebp]
	mov	ebx, 1
	mov	DWORD PTR tv953[ebp], 0
	add	esi, 232				; 000000e8H
	npad	8
$LL110@read_insta:

; 1087 :            { mi->expr[i] = mi->expr[0] + i;

	mov	eax, DWORD PTR _mi$[ebp]
	mov	eax, DWORD PTR [eax+232]
	add	eax, DWORD PTR tv953[ebp]
	mov	DWORD PTR [esi], eax

; 1088 :              if ( (tolower(yytext[0]) != 'q') || (atoi(yytext+1) != 1 + i ))

	mov	eax, DWORD PTR _yytext
	movsx	ecx, BYTE PTR [eax]
	cmp	BYTE PTR _kb_lower_array[ecx], 113	; 00000071H
	jne	$LN99@read_insta
	inc	eax
	push	eax
	call	_atoi
	add	esp, 4
	cmp	eax, ebx
	jne	$LN99@read_insta

; 1091 :                break;                  
; 1092 :              }
; 1093 :              esize = exparse(SDIM,mi->expr[i],USERCOPY);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _web+616
	push	1
	push	edx
	push	eax
	call	_exparse

; 1094 :              tok = yylex();

	push	0
	mov	DWORD PTR _esize$[ebp], eax
	call	_kb_yylex
	add	esp, 16					; 00000010H

; 1095 :              if ( esize <= 0 )

	cmp	DWORD PTR _esize$[ebp], 0
	mov	DWORD PTR _tok, eax
	jg	SHORT $LN23@read_insta

; 1096 :              { sprintf(errmsg, "Bad component %d definition.\n",i+1);

	push	ebx
	push	OFFSET ??_C@_0BO@NHINACAL@Bad?5component?5?$CFd?5definition?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1097 :                kb_error(1720,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1720					; 000006b8H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN23@read_insta:

; 1098 :              }
; 1099 :              sprintf(msg,"%s vector integrand component %d",
; 1100 :                 mi->name,i+1);

	mov	ecx, DWORD PTR _mi$[ebp]
	mov	edx, DWORD PTR _msg
	push	ebx
	push	ecx
	push	OFFSET ??_C@_0CB@BPDAEIFH@?$CFs?5vector?5integrand?5component?5?$CFd@
	push	edx
	call	_sprintf

; 1101 :              strncpy(mi->expr[i]->name,msg,EXPNAMESIZE-1);

	mov	eax, DWORD PTR _msg
	mov	ecx, DWORD PTR [esi]
	push	63					; 0000003fH
	push	eax
	add	ecx, 20					; 00000014H
	push	ecx
	call	_strncpy
	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv953[ebp], 104		; 00000068H
	inc	eax
	add	esp, 28					; 0000001cH
	add	esi, 4
	inc	ebx
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, edi
	jl	$LL110@read_insta

; 1088 :              if ( (tolower(yytext[0]) != 'q') || (atoi(yytext+1) != 1 + i ))

	jmp	SHORT $LN115@read_insta
$LN99@read_insta:

; 1089 :              { sprintf(errmsg,"Expected component %d definition.\n",i+1);

	mov	edx, DWORD PTR _i$[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_0CD@IBENPDAK@Expected?5component?5?$CFd?5definition@
	push	OFFSET _errmsg
	call	_sprintf

; 1090 :                kb_error(1719,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1719					; 000006b7H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN115@read_insta:
	mov	ebx, DWORD PTR _mi$[ebp]
$LN26@read_insta:

; 1102 :            }
; 1103 :            if ( (tolower(yytext[0]) == 'q') && isdigit(yytext[1]) ) 

	mov	eax, DWORD PTR _yytext
	movsx	ecx, BYTE PTR [eax]
	cmp	BYTE PTR _kb_lower_array[ecx], 113	; 00000071H
	jne	$LL96@read_insta
	movsx	edx, BYTE PTR [eax+1]
	push	edx
	call	_isdigit
	add	esp, 4
	test	eax, eax
	je	$LN97@read_insta

; 1104 :            { sprintf(errmsg,"k_vector method needs only %d (complement of order) vectors.\n",(SDIM-METH_INSTANCE(mnum)->vec_order));

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _meth_inst_list
	mov	edx, DWORD PTR tv641[ebp]
	sub	eax, DWORD PTR [edx+ecx+224]
	push	eax
	push	OFFSET ??_C@_0DO@OGCLCHKJ@k_vector?5method?5needs?5only?5?$CFd?5?$CIc@
	push	OFFSET _errmsg
	call	_sprintf

; 1105 :              kb_error(2863,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2863					; 00000b2fH
	call	_kb_error
	add	esp, 24					; 00000018H

; 1106 :            }
; 1107 :            break;

	jmp	$LN97@read_insta
$LN21@read_insta:

; 1108 : 
; 1109 :        case FORM_INTEGRAND_TOK:  /* 2-form */
; 1110 :            /* read and parse integrand 2-form */
; 1111 :            if ( !(gm->spec_flags & SPEC_2FORM) )

	test	BYTE PTR [edi+136], 4
	jne	SHORT $LN20@read_insta

; 1112 :            { kb_error(1721,"No 2-form integrand for this method.\n",
; 1113 :                    DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CG@CLIJAHGB@No?52?9form?5integrand?5for?5this?5met@
	push	1721					; 000006b9H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN20@read_insta:

; 1114 :              /* read in anyway to get past it */
; 1115 :            }
; 1116 :            spec_flag |= SPEC_2FORM;
; 1117 :            comps = (SDIM*(SDIM-1))/2;

	mov	ecx, DWORD PTR _web+616
	or	DWORD PTR _spec_flag$[ebp], 4
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	mov	DWORD PTR _comps$[ebp], esi

; 1118 :            if ( comps > MAXMEXPR )

	cmp	esi, 18					; 00000012H
	jle	SHORT $LN19@read_insta

; 1119 :               kb_error(1722,"Total components exceeds MAXMEXPR.\n",
; 1120 :                  DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CE@GPKNNOIL@Total?5components?5exceeds?5MAXMEXP@
	push	1722					; 000006baH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN19@read_insta:

; 1121 : 
; 1122 :            expr_count = comps;
; 1123 :            if ( mi->expr[0] )

	cmp	DWORD PTR [ebx+232], 0
	lea	edi, DWORD PTR [ebx+232]
	mov	DWORD PTR _expr_count$[ebp], esi
	je	SHORT $LN15@read_insta

; 1124 :            { // in case of replace_load or something
; 1125 :              for ( i = 0 ; i < expr_count ; i++ )

	test	esi, esi
	jle	SHORT $LN15@read_insta
	mov	DWORD PTR tv327[ebp], esi
$LL111@read_insta:

; 1126 :                free_expr(mi->expr[i]);

	mov	eax, DWORD PTR [edi]
	push	eax
	call	_free_expr
	add	esp, 4
	add	edi, 4
	dec	DWORD PTR tv327[ebp]
	jne	SHORT $LL111@read_insta
$LN15@read_insta:

; 1127 :            }
; 1128 : 
; 1129 :            mi->expr[0]=(struct expnode *)kb_realloc((char*)mi->expr[0],
; 1130 :              comps*sizeof(struct expnode));

	mov	edx, DWORD PTR [ebx+232]
	mov	ecx, esi
	imul	ecx, 104				; 00000068H
	push	1130					; 0000046aH
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	ecx
	push	edx
	call	_KB_realloc

; 1131 :            tok = yylex();

	push	0
	mov	DWORD PTR [ebx+232], eax
	call	_kb_yylex
	add	esp, 20					; 00000014H
	mov	DWORD PTR _tok, eax

; 1132 :            for ( i = 0 ; i < comps ; i++ )

	test	esi, esi
	jle	$LL96@read_insta

; 1127 :            }
; 1128 : 
; 1129 :            mi->expr[0]=(struct expnode *)kb_realloc((char*)mi->expr[0],
; 1130 :              comps*sizeof(struct expnode));

	mov	eax, DWORD PTR _comps$[ebp]
	mov	esi, 1
	mov	DWORD PTR tv1041[ebp], 0
	lea	edi, DWORD PTR [ebx+232]
	mov	DWORD PTR tv283[ebp], eax
	npad	10
$LL112@read_insta:

; 1133 :            {
; 1134 :              mi->expr[i] = mi->expr[0] + i;

	mov	ecx, DWORD PTR [ebx+232]
	add	ecx, DWORD PTR tv1041[ebp]
	mov	DWORD PTR [edi], ecx

; 1135 :              if ( (tolower(yytext[0]) != 'q') || (atoi(yytext+1) != 1 + i ) )

	mov	eax, DWORD PTR _yytext
	movsx	edx, BYTE PTR [eax]
	cmp	BYTE PTR _kb_lower_array[edx], 113	; 00000071H
	jne	SHORT $LN10@read_insta
	inc	eax
	push	eax
	call	_atoi
	add	esp, 4
	cmp	eax, esi
	je	SHORT $LN11@read_insta
$LN10@read_insta:

; 1136 :              { sprintf(errmsg,"Expected component %d definition.\n",i+1);

	push	esi
	push	OFFSET ??_C@_0CD@IBENPDAK@Expected?5component?5?$CFd?5definition@
	push	OFFSET _errmsg
	call	_sprintf

; 1137 :                kb_error(1723,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1723					; 000006bbH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN11@read_insta:

; 1138 :              }
; 1139 :              esize = exparse(SDIM,mi->expr[i],USERCOPY);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _web+616
	push	1
	push	eax
	push	ecx
	call	_exparse

; 1140 :              tok = yylex();

	push	0
	mov	DWORD PTR _esize$[ebp], eax
	call	_kb_yylex
	add	esp, 16					; 00000010H

; 1141 :              if ( esize <= 0 )

	cmp	DWORD PTR _esize$[ebp], 0
	mov	DWORD PTR _tok, eax
	jg	SHORT $LN9@read_insta

; 1142 :              { sprintf(errmsg, "Bad component %d definition.\n",i+1);

	push	esi
	push	OFFSET ??_C@_0BO@NHINACAL@Bad?5component?5?$CFd?5definition?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1143 :                kb_error(1724,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1724					; 000006bcH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN9@read_insta:

; 1144 :              }
; 1145 :              sprintf(msg,"%s form integrand component %d", mi->name,i+1);

	mov	edx, DWORD PTR _msg
	push	esi
	push	ebx
	push	OFFSET ??_C@_0BP@IPGPKEG@?$CFs?5form?5integrand?5component?5?$CFd?$AA@
	push	edx
	call	_sprintf

; 1146 :              strncpy(mi->expr[i]->name,msg,EXPNAMESIZE-1);

	mov	eax, DWORD PTR _msg
	mov	ecx, DWORD PTR [edi]
	push	63					; 0000003fH
	push	eax
	add	ecx, 20					; 00000014H
	push	ecx
	call	_strncpy
	add	DWORD PTR tv1041[ebp], 104		; 00000068H
	add	esp, 28					; 0000001cH
	add	edi, 4
	inc	esi
	dec	DWORD PTR tv283[ebp]
	jne	$LL112@read_insta

; 963  :   /* read further attributes of instance */
; 964  :   for (bflag=0;bflag==0;)

	jmp	$LN97@read_insta
$LN94@read_insta:

; 1147 :            }
; 1148 :            break;
; 1149 : 
; 1150 :        default: bflag = 1; break;
; 1151 :      }
; 1152 :     if ( (gm->spec_flags & SPEC_SCALAR) & ~spec_flag )

	mov	esi, DWORD PTR _spec_flag$[ebp]
	not	esi
	mov	edx, esi
	and	edx, DWORD PTR [edi+136]
	test	dl, 1
	je	SHORT $LN105@read_insta

; 1153 :       kb_error(1725,"Need scalar integrand for this method.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CI@KEFMBOI@Need?5scalar?5integrand?5for?5this?5m@
	push	1725					; 000006bdH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN105@read_insta:

; 1154 : 
; 1155 :     if ( (gm->spec_flags & SPEC_VECTOR) & ~spec_flag )

	mov	eax, esi
	and	eax, DWORD PTR [edi+136]
	test	al, 2
	je	SHORT $LN6@read_insta

; 1156 :       kb_error(1726,"Need vector integrand for this method.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CI@FEILCMAD@Need?5vector?5integrand?5for?5this?5m@
	push	1726					; 000006beH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN6@read_insta:

; 1157 : 
; 1158 :     if ( (gm->spec_flags & SPEC_KVECTOR) & ~spec_flag )

	mov	ecx, esi
	and	ecx, DWORD PTR [edi+136]
	test	cl, 64					; 00000040H
	je	SHORT $LN5@read_insta

; 1159 :       kb_error(2862,
; 1160 :         "Need k_vector_order and vector_integrand for this method.\n",
; 1161 :            DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DL@HEFJICEC@Need?5k_vector_order?5and?5vector_i@
	push	2862					; 00000b2eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN5@read_insta:

; 1162 : 
; 1163 :     /* Check use of boundary parameters */
; 1164 :     for ( i = 0 ; i < expr_count ; i++ )

	mov	edi, DWORD PTR _expr_count$[ebp]
	test	edi, edi
	jle	SHORT $LN95@read_insta
	lea	esi, DWORD PTR [ebx+232]
	npad	2
$LL113@read_insta:

; 1165 : 	{ 
; 1166 : 	  if ( mi->expr[i] && (mi->expr[i]->flag & USING_PARAM_FLAG) )

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@read_insta
	test	DWORD PTR [eax+12], 512			; 00000200H
	je	SHORT $LN3@read_insta

; 1167 :       { sprintf(errmsg,
; 1168 :          "%s: Cannot use boundary parameters in gradient or hessian.\n",
; 1169 :            METH_INSTANCE(mnum)->name);

	mov	edx, DWORD PTR tv641[ebp]
	add	edx, DWORD PTR _meth_inst_list
	push	edx
	push	OFFSET ??_C@_0DM@OLABLKBN@?$CFs?3?5Cannot?5use?5boundary?5paramete@
	push	OFFSET _errmsg
	call	_sprintf

; 1170 : 	    kb_error(3895,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	3895					; 00000f37H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN3@read_insta:

; 1162 : 
; 1163 :     /* Check use of boundary parameters */
; 1164 :     for ( i = 0 ; i < expr_count ; i++ )

	add	esi, 4
	dec	edi
	jne	SHORT $LL113@read_insta
$LN95@read_insta:

; 1171 : 	  }
; 1172 :     }
; 1173 :     
; 1174 :     mi->flags &= ~Q_FORWARD_DEF;

	and	DWORD PTR [ebx+140], -1048577		; ffefffffH
	pop	edi
	pop	esi
	pop	ebx

; 1175 :  } // end read_instance_attr()

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN116@read_insta:
	DD	$LN60@read_insta
	DD	$LN61@read_insta
	DD	$LN56@read_insta
	DD	$LN49@read_insta
	DD	$LN38@read_insta
	DD	$LN59@read_insta
	DD	$LN21@read_insta
	DD	$LN50@read_insta
	DD	$LN53@read_insta
	DD	$LN94@read_insta
$LN93@read_insta:
	DB	0
	DB	1
	DB	9
	DB	9
	DB	9
	DB	2
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	4
	DB	5
	DB	6
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	7
	DB	8
_read_instance_attr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@GJDPGLEJ@Missing?5lagrange_multiplier?5valu@ ; `string'
PUBLIC	??_C@_03DLKKFNII@?$CFd_?$AA@			; `string'
PUBLIC	??_C@_0BN@DLJCKBBD@Tolerance?5must?5be?5positive?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@IFPICNPD@Missing?5tolerance?5value?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@CLEGJGKL@Missing?5quantity?5volconst?5value?4@ ; `string'
PUBLIC	??_C@_0BK@HNENCAJG@Bad?5function?5definition?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DH@IGMDOIIB@Can?8t?5list?5separate?5methods?5with@ ; `string'
PUBLIC	??_C@_0CC@OKLMHOFB@Missing?5quantity?5modulus?5value?4?5@ ; `string'
PUBLIC	??_C@_0EA@CHHIDGDJ@Need?5type?5of?5quantity?3?5energy?0?5f@ ; `string'
PUBLIC	??_C@_0CB@GANEIODP@Missing?5quantity?5target?5value?4?5?6@ ; `string'
PUBLIC	??_C@_0N@PDOINPE@Missing?5?8?$DN?8?6?$AA@	; `string'
PUBLIC	??_C@_0BF@EAMJGDOF@Need?5quantity?5name?4?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_read_named_quantity
EXTRN	_pressure_set_flag:DWORD
EXTRN	_strncat:PROC
EXTRN	_reading_comp_quant_flag:DWORD
EXTRN	_cur_quant:DWORD
;	COMDAT ??_C@_0CE@GJDPGLEJ@Missing?5lagrange_multiplier?5valu@
CONST	SEGMENT
??_C@_0CE@GJDPGLEJ@Missing?5lagrange_multiplier?5valu@ DB 'Missing lagran'
	DB	'ge_multiplier value.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLKKFNII@?$CFd_?$AA@
CONST	SEGMENT
??_C@_03DLKKFNII@?$CFd_?$AA@ DB '%d_', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DLJCKBBD@Tolerance?5must?5be?5positive?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@DLJCKBBD@Tolerance?5must?5be?5positive?4?6?$AA@ DB 'Tolerance m'
	DB	'ust be positive.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IFPICNPD@Missing?5tolerance?5value?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@IFPICNPD@Missing?5tolerance?5value?4?6?$AA@ DB 'Missing toleran'
	DB	'ce value.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CLEGJGKL@Missing?5quantity?5volconst?5value?4@
CONST	SEGMENT
??_C@_0CD@CLEGJGKL@Missing?5quantity?5volconst?5value?4@ DB 'Missing quan'
	DB	'tity volconst value. ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HNENCAJG@Bad?5function?5definition?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@HNENCAJG@Bad?5function?5definition?4?6?$AA@ DB 'Bad function de'
	DB	'finition.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@IGMDOIIB@Can?8t?5list?5separate?5methods?5with@
CONST	SEGMENT
??_C@_0DH@IGMDOIIB@Can?8t?5list?5separate?5methods?5with@ DB 'Can''t list'
	DB	' separate methods with function of methods.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@OKLMHOFB@Missing?5quantity?5modulus?5value?4?5@
CONST	SEGMENT
??_C@_0CC@OKLMHOFB@Missing?5quantity?5modulus?5value?4?5@ DB 'Missing qua'
	DB	'ntity modulus value. ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@CHHIDGDJ@Need?5type?5of?5quantity?3?5energy?0?5f@
CONST	SEGMENT
??_C@_0EA@CHHIDGDJ@Need?5type?5of?5quantity?3?5energy?0?5f@ DB 'Need type'
	DB	' of quantity: energy, fixed, conserved, or info_only.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GANEIODP@Missing?5quantity?5target?5value?4?5?6@
CONST	SEGMENT
??_C@_0CB@GANEIODP@Missing?5quantity?5target?5value?4?5?6@ DB 'Missing qu'
	DB	'antity target value. ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PDOINPE@Missing?5?8?$DN?8?6?$AA@
CONST	SEGMENT
??_C@_0N@PDOINPE@Missing?5?8?$DN?8?6?$AA@ DB 'Missing ''=''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EAMJGDOF@Need?5quantity?5name?4?6?$AA@
CONST	SEGMENT
??_C@_0BF@EAMJGDOF@Need?5quantity?5name?4?6?$AA@ DB 'Need quantity name.', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _read_named_quantity
_TEXT	SEGMENT
_namecount$ = -816					; size = 4
_lagmulflag$ = -812					; size = 4
_gnum$ = -808						; size = 4
_qname$ = -804						; size = 400
_inst_name$ = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
_read_named_quantity PROC				; COMDAT

; 1207 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 816				; 00000330H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1208 :   int n;
; 1209 :   int gnum; /* quantity number */
; 1210 :   char qname[400];
; 1211 :   int meth;
; 1212 :   struct method_instance *mi;
; 1213 :   char inst_name[400];
; 1214 :   int namecount; /* number of uninstantiated methods */
; 1215 :   int globality;
; 1216 :   int esize;
; 1217 :   int lagmulflag = 0;
; 1218 : 
; 1219 :   if ( (tok != NEWIDENT_TOK) && (tok != IDENT_TOK) && (tok != QUANTITY_NAME_TOK) )

	mov	eax, DWORD PTR _tok
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR _lagmulflag$[ebp], ebx
	cmp	eax, 268				; 0000010cH
	je	SHORT $LN48@read_named
	cmp	eax, 286				; 0000011eH
	je	SHORT $LN48@read_named
	cmp	eax, 336				; 00000150H
	je	SHORT $LN48@read_named

; 1220 :   { kb_error(1733,"Need quantity name.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BF@EAMJGDOF@Need?5quantity?5name?4?6?$AA@
	push	1733					; 000006c5H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1221 :     return -1;

	or	eax, -1
	pop	ebx

; 1371 :   return gnum;
; 1372 : } // end read_named_quantity()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@read_named:

; 1222 :   }
; 1223 :   strncpy(qname,yytext,sizeof(qname));

	mov	eax, DWORD PTR _yytext
	push	esi
	push	400					; 00000190H
	push	eax
	lea	ecx, DWORD PTR _qname$[ebp]
	push	ecx
	call	_strncpy

; 1224 :   /* check not already defined and add to list */
; 1225 :   tok = yylex();

	push	ebx
	call	_kb_yylex
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tok, eax

; 1226 :   if ( tok == ';' ) 

	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN47@read_named

; 1227 :   { gnum = new_quantity(qname,Q_INFO);

	lea	edx, DWORD PTR _qname$[ebp]
	push	4
	push	edx
	call	_new_quantity

; 1228 :     GEN_QUANT(gnum)->flags |= Q_FORWARD_DEF;

	mov	ecx, DWORD PTR _gen_quant_list
	mov	esi, eax
	imul	eax, 368				; 00000170H
	or	DWORD PTR [eax+ecx+136], 1048576	; 00100000H
	lea	eax, DWORD PTR [eax+ecx+136]

; 1229 :     verb_flag = 0; /* set by ';' */
; 1230 :     tok = yylex();

	push	ebx
	mov	DWORD PTR _verb_flag, ebx
	call	_kb_yylex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax

; 1231 :     return gnum;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1371 :   return gnum;
; 1372 : } // end read_named_quantity()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@read_named:
	push	edi

; 1232 :   }
; 1233 :   if ( tok == FIXED_TOK )

	cmp	eax, 317				; 0000013dH
	jne	$LN46@read_named

; 1234 :   { gnum = new_quantity(qname,Q_FIXED);

	lea	edx, DWORD PTR _qname$[ebp]
	push	2
	push	edx
	call	_new_quantity
	mov	edi, eax

; 1235 :     tok = yylex(); /* eat '=' */

	push	ebx
	mov	DWORD PTR _gnum$[ebp], edi
	call	_kb_yylex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax

; 1236 :     if ( tok != '=' )

	cmp	eax, 61					; 0000003dH
	je	SHORT $LN65@read_named

; 1237 :       kb_error(1734,"Missing '='\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0N@PDOINPE@Missing?5?8?$DN?8?6?$AA@
	push	1734					; 000006c6H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN65@read_named:

; 1238 :     if (read_const(&(GEN_QUANT(gnum)->target)) <= 0)

	mov	ecx, DWORD PTR _gen_quant_list
	mov	eax, edi
	imul	eax, 368				; 00000170H
	lea	edx, DWORD PTR [eax+ecx+144]
	push	edx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN44@read_named

; 1239 :       kb_error(1735,"Missing quantity target value. \n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CB@GANEIODP@Missing?5quantity?5target?5value?4?5?6@
	push	1735					; 000006c7H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN44@read_named:

; 1240 :     tok = yylex();

	push	ebx
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1259 :   }
; 1260 :   namecount = 0;

	mov	DWORD PTR _namecount$[ebp], ebx
	jmp	$LL36@read_named
$LN46@read_named:

; 1241 :   }
; 1242 :   else if ( tok == ENERGY_TOK )

	cmp	eax, 438				; 000001b6H
	jne	SHORT $LN42@read_named

; 1243 :   { gnum = new_quantity(qname,Q_ENERGY);

	push	1
	lea	eax, DWORD PTR _qname$[ebp]
	push	eax

; 1244 :     tok = yylex();

	jmp	SHORT $LN74@read_named
$LN42@read_named:

; 1245 :   }
; 1246 :   else if ( tok == INFO_ONLY_TOK )

	cmp	eax, 440				; 000001b8H
	jne	SHORT $LN40@read_named

; 1247 :   { gnum = new_quantity(qname,Q_INFO);

	push	4
	lea	ecx, DWORD PTR _qname$[ebp]
	push	ecx

; 1248 :     tok = yylex();

	jmp	SHORT $LN74@read_named
$LN40@read_named:

; 1249 :   }
; 1250 :   else if ( tok == CONSERVED_TOK )

	cmp	eax, 439				; 000001b7H
	jne	SHORT $LN38@read_named

; 1251 :   { gnum = new_quantity(qname,Q_CONSERVED);

	push	8
	lea	edx, DWORD PTR _qname$[ebp]
	push	edx
$LN74@read_named:
	call	_new_quantity

; 1252 :     tok = yylex();

	push	ebx
	mov	DWORD PTR _gnum$[ebp], eax
	call	_kb_yylex

; 1253 :   }
; 1254 :   else 

	mov	edi, DWORD PTR _gnum$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax

; 1259 :   }
; 1260 :   namecount = 0;

	mov	DWORD PTR _namecount$[ebp], ebx
	jmp	SHORT $LL36@read_named
$LN38@read_named:

; 1255 :   { kb_error(1736,
; 1256 :       "Need type of quantity: energy, fixed, conserved, or info_only.\n",
; 1257 :            DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0EA@CHHIDGDJ@Need?5type?5of?5quantity?3?5energy?0?5f@
	push	1736					; 000006c8H
	call	_kb_error

; 1258 :     gnum = new_quantity(qname,Q_INFO);

	lea	eax, DWORD PTR _qname$[ebp]
	push	4
	push	eax
	call	_new_quantity
	add	esp, 20					; 00000014H
	mov	DWORD PTR _gnum$[ebp], eax
	mov	edi, eax

; 1259 :   }
; 1260 :   namecount = 0;

	mov	DWORD PTR _namecount$[ebp], ebx
	jmp	SHORT $LL36@read_named
$LN64@read_named:

; 1324 :              kb_error(1738,"Missing quantity volconst value. \n",DATAFILE_ERROR);

	mov	edi, DWORD PTR _gnum$[ebp]
	npad	10
$LL36@read_named:

; 1261 :   for (;;) /* further attributes */
; 1262 :     switch ( tok )

	mov	eax, DWORD PTR _tok
	cmp	eax, 496				; 000001f0H
	jg	$LN51@read_named
	je	$LN13@read_named
	sub	eax, 291				; 00000123H
	je	$LN16@read_named
	sub	eax, 137				; 00000089H
	je	SHORT $LN6@read_named
	sub	eax, 45					; 0000002dH
	jne	$named_exit$90093

; 1334 : 
; 1335 :       case MODULUS_TOK:
; 1336 :           if (read_const(&(GEN_QUANT(gnum)->modulus)) <= 0)

	mov	edx, DWORD PTR _gen_quant_list
	mov	ecx, edi
	imul	ecx, 368				; 00000170H
	lea	eax, DWORD PTR [ecx+edx+176]
	push	eax
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	$LN15@read_named

; 1337 :              kb_error(1739,"Missing quantity modulus value. \n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CC@OKLMHOFB@Missing?5quantity?5modulus?5value?4?5@
	push	1739					; 000006cbH
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LL36@read_named
$LN6@read_named:

; 1338 :           else tok = yylex();
; 1339 :           break;
; 1340 :       case FUNCTION_TOK:  /* compound function of instances */
; 1341 :           cur_quant = gnum;
; 1342 :           if ( GEN_QUANT(cur_quant)->method_count > 0 && !addload_flag)

	mov	ecx, DWORD PTR _gen_quant_list
	mov	esi, edi
	imul	esi, 368				; 00000170H
	mov	DWORD PTR _cur_quant, edi
	cmp	DWORD PTR [esi+ecx+240], 0
	jle	SHORT $LN5@read_named
	cmp	DWORD PTR _addload_flag, 0
	jne	SHORT $LN5@read_named

; 1343 :             kb_error(1740,
; 1344 :               "Can't list separate methods with function of methods.\n",
; 1345 :                          DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DH@IGMDOIIB@Can?8t?5list?5separate?5methods?5with@
	push	1740					; 000006ccH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN5@read_named:

; 1346 :           reading_comp_quant_flag = 1;
; 1347 :           esize = exparse(0,&(GEN_QUANT(gnum)->expr),USERCOPY);

	mov	edx, DWORD PTR _gen_quant_list
	push	1
	lea	eax, DWORD PTR [esi+edx+256]
	push	eax
	push	0
	mov	DWORD PTR _reading_comp_quant_flag, 1
	call	_exparse

; 1348 :           reading_comp_quant_flag = 0;
; 1349 :           cur_quant = -1 ;
; 1350 :           tok = yylex();

	push	0
	mov	edi, eax
	mov	DWORD PTR _reading_comp_quant_flag, 0
	mov	DWORD PTR _cur_quant, -1
	call	_kb_yylex
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tok, eax

; 1351 :           if ( esize <= 0 )

	test	edi, edi
	jg	SHORT $LN4@read_named

; 1352 :           { sprintf(errmsg, "Bad function definition.\n");

	push	OFFSET ??_C@_0BK@HNENCAJG@Bad?5function?5definition?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1353 :             kb_error(1741,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1741					; 000006cdH
	call	_kb_error
	add	esp, 20					; 00000014H
$LN4@read_named:

; 1354 :           }
; 1355 :           sprintf(msg,"%s formula",GEN_QUANT(gnum)->name);

	mov	ecx, DWORD PTR _gen_quant_list
	mov	eax, DWORD PTR _msg
	lea	edx, DWORD PTR [esi+ecx]
	push	edx
	push	OFFSET ??_C@_0L@NBMEGDLE@?$CFs?5formula?$AA@
	push	eax
	call	_sprintf

; 1356 :           strncpy(GEN_QUANT(gnum)->expr.name,msg,EXPNAMESIZE-1);

	mov	ecx, DWORD PTR _msg
	mov	edx, DWORD PTR _gen_quant_list
	push	63					; 0000003fH
	push	ecx
	lea	eax, DWORD PTR [esi+edx+276]
	push	eax
	call	_strncpy

; 1357 :           GEN_QUANT(gnum)->flags |= Q_COMPOUND;

	mov	eax, DWORD PTR _gen_quant_list
	or	DWORD PTR [esi+eax+136], 256		; 00000100H

; 1358 :           if ( gnum > compound_quant_list_head ) // avoid loop with addload

	mov	eax, DWORD PTR _compound_quant_list_head
	add	esp, 24					; 00000018H
	cmp	DWORD PTR _gnum$[ebp], eax
	jle	$LN64@read_named

; 1359 :           { GEN_QUANT(gnum)->next_compound = compound_quant_list_head;

	mov	ecx, DWORD PTR _gen_quant_list

; 1360 :             compound_quant_list_head = gnum;

	mov	edx, DWORD PTR _gnum$[ebp]
	mov	DWORD PTR [esi+ecx+360], eax
	mov	DWORD PTR _compound_quant_list_head, edx

; 1361 :           }
; 1362 :           break;

	jmp	$LN64@read_named
$LN16@read_named:

; 1319 :          }
; 1320 :          break;
; 1321 : 
; 1322 :       case VOLCONST_TOK:
; 1323 :           if (read_const(&(GEN_QUANT(gnum)->volconst)) <= 0)

	mov	ecx, DWORD PTR _gen_quant_list
	mov	eax, edi
	imul	eax, 368				; 00000170H
	lea	edx, DWORD PTR [eax+ecx+208]
	push	edx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	$LN15@read_named

; 1324 :              kb_error(1738,"Missing quantity volconst value. \n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0CD@CLEGJGKL@Missing?5quantity?5volconst?5value?4@
	push	1738					; 000006caH
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	$LL36@read_named
$LN13@read_named:

; 1325 :           else tok = yylex();
; 1326 :           break;
; 1327 :       case TOLERANCE_TOK:
; 1328 :          if ( read_const(&GEN_QUANT(gnum)->tolerance) <= 0 )

	mov	ecx, DWORD PTR _gen_quant_list
	mov	esi, edi
	imul	esi, 368				; 00000170H
	lea	edx, DWORD PTR [esi+ecx+184]
	push	edx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN12@read_named

; 1329 :             kb_error(2127,"Missing tolerance value.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BK@IFPICNPD@Missing?5tolerance?5value?4?6?$AA@
	push	2127					; 0000084fH
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN11@read_named
$LN12@read_named:

; 1330 :          else tok=yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN11@read_named:

; 1331 :          if ( GEN_QUANT(gnum)->tolerance <= 0.0 ) 

	fldz
	mov	eax, DWORD PTR _gen_quant_list
	fcomp	QWORD PTR [esi+eax+184]
	fnstsw	ax
	test	ah, 1
	jne	$LL36@read_named

; 1332 :           kb_error(2128,"Tolerance must be positive.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BN@DLJCKBBD@Tolerance?5must?5be?5positive?4?6?$AA@
	push	2128					; 00000850H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1333 :          break;

	jmp	$LL36@read_named
$LN51@read_named:

; 1261 :   for (;;) /* further attributes */
; 1262 :     switch ( tok )

	sub	eax, 35013				; 000088c5H
	je	$LN19@read_named
	sub	eax, 11					; 0000000bH
	je	SHORT $LN32@read_named
	sub	eax, 8
	jne	$named_exit$90093
$LN32@read_named:

; 1263 :     { case GLOBAL_METHOD_TOK :
; 1264 :       case METHOD_TOK :
; 1265 :           if ( GEN_QUANT(gnum)->flags & Q_COMPOUND )

	mov	ecx, DWORD PTR _gen_quant_list
	imul	edi, 368				; 00000170H
	test	DWORD PTR [edi+ecx+136], 256		; 00000100H
	je	SHORT $LN31@read_named

; 1266 :             kb_error(1737,
; 1267 :               "Can't list separate methods with function of methods.\n",
; 1268 :                          DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DH@IGMDOIIB@Can?8t?5list?5separate?5methods?5with@
	push	1737					; 000006c9H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN31@read_named:

; 1269 :           globality = tok;

	mov	ebx, DWORD PTR _tok

; 1270 :           tok = yylex();

	push	0
	call	_kb_yylex

; 1271 : 
; 1272 :           strncpy(inst_name,qname,sizeof(qname));

	push	400					; 00000190H
	lea	edx, DWORD PTR _qname$[ebp]
	mov	DWORD PTR _tok, eax
	push	edx
	lea	eax, DWORD PTR _inst_name$[ebp]
	push	eax
	call	_strncpy

; 1273 :           sprintf(inst_name+strlen(inst_name),"%d_",++namecount);

	lea	eax, DWORD PTR _inst_name$[ebp]
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL70@read_named:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL70@read_named
	mov	ecx, DWORD PTR _namecount$[ebp]
	inc	ecx
	push	ecx
	sub	eax, edx
	mov	DWORD PTR _namecount$[ebp], ecx
	lea	ecx, DWORD PTR _inst_name$[ebp+eax]
	push	OFFSET ??_C@_03DLKKFNII@?$CFd_?$AA@
	push	ecx
	call	_sprintf

; 1274 :           strncat(inst_name,yytext,sizeof(qname)-strlen(inst_name));

	lea	eax, DWORD PTR _inst_name$[ebp]
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL71@read_named:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL71@read_named
	sub	eax, edx
	mov	edx, 400				; 00000190H
	sub	edx, eax
	mov	eax, DWORD PTR _yytext
	push	edx
	push	eax
	lea	ecx, DWORD PTR _inst_name$[ebp]
	push	ecx
	call	_strncat

; 1275 : 
; 1276 :           /* see if existing instance */
; 1277 :           for ( n=LOW_INST ; n < meth_inst_count ; n++ )

	mov	edi, 1
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+5560, edi
	jle	$LN58@read_named
	npad	3
$LL72@read_named:

; 1278 :           { mi = METH_INSTANCE(n);

	mov	eax, edi
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list

; 1279 :             if ( mi->flags & Q_DELETED ) continue;

	test	DWORD PTR [esi+140], 524288		; 00080000H
	jne	SHORT $LN29@read_named

; 1280 :             if ( stricmp(mi->name,inst_name) == 0 ) 

	lea	edx, DWORD PTR _inst_name$[ebp]
	push	edx
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN55@read_named

; 1288 :             }
; 1289 :             if ( stricmp(mi->name,yytext) == 0 )

	mov	eax, DWORD PTR _yytext
	push	eax
	push	esi
	call	_kb_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN56@read_named
$LN29@read_named:

; 1275 : 
; 1276 :           /* see if existing instance */
; 1277 :           for ( n=LOW_INST ; n < meth_inst_count ; n++ )

	inc	edi
	cmp	edi, DWORD PTR _web+5560
	jl	SHORT $LL72@read_named

; 1288 :             }
; 1289 :             if ( stricmp(mi->name,yytext) == 0 )

	jmp	$LN58@read_named
$LN55@read_named:

; 1281 :             { // existing implicit method, say in replace_load
; 1282 :               attach_method_num(gnum,n);

	mov	ecx, DWORD PTR _gnum$[ebp]
	push	edi
	push	ecx
	call	_attach_method_num
	add	esp, 8

; 1283 :               if ( globality == GLOBAL_METHOD_TOK) 

	cmp	ebx, 35032				; 000088d8H
	jne	SHORT $LN66@read_named

; 1284 :                 apply_method(NULLID,inst_name);

	lea	edx, DWORD PTR _inst_name$[ebp]
	push	edx
	push	0
	call	_apply_method
	add	esp, 8
$LN66@read_named:

; 1285 :               tok = yylex();

	push	0
	call	_kb_yylex

; 1286 :               read_instance_attr(n);

	push	edi
	mov	DWORD PTR _tok, eax
	call	_read_instance_attr
	add	esp, 8

; 1287 :               break;

	jmp	SHORT $LN28@read_named
$LN56@read_named:

; 1290 :             { /* predefined instance */
; 1291 :               int mnum = attach_method(gnum,yytext);

	mov	eax, DWORD PTR _yytext
	mov	ecx, DWORD PTR _gnum$[ebp]
	push	eax
	push	ecx
	call	_attach_method
	add	esp, 8

; 1292 :               if ( (globality  == GLOBAL_METHOD_TOK) && (mnum>=0) &&
; 1293 :                 !(METH_INSTANCE(mnum)->flags & GLOBAL_INST) )

	cmp	ebx, 35032				; 000088d8H
	jne	SHORT $LN67@read_named
	test	eax, eax
	js	SHORT $LN67@read_named
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	test	DWORD PTR [eax+edx+140], 1073741824	; 40000000H
	jne	SHORT $LN67@read_named

; 1294 :                  apply_method(NULLID,yytext);

	mov	eax, DWORD PTR _yytext
	push	eax
	push	0
	call	_apply_method
	add	esp, 8
$LN67@read_named:

; 1295 :               tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax
$LN28@read_named:

; 1296 :               break;
; 1297 :             }
; 1298 :           }
; 1299 :           if ( n >= meth_inst_count )

	cmp	edi, DWORD PTR _web+5560
	jl	$LN64@read_named
$LN58@read_named:

; 1300 :           { /* need to instantiate method */
; 1301 :             meth = new_method_instance(yytext,inst_name);

	mov	edx, DWORD PTR _yytext
	lea	ecx, DWORD PTR _inst_name$[ebp]
	push	ecx
	push	edx
	call	_new_method_instance
	mov	esi, eax
	add	esp, 8

; 1302 :             if ( meth >= 0 )

	test	esi, esi
	js	$LN64@read_named

; 1303 :             { METH_INSTANCE(meth)->flags |= IMPLICIT_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	cdq
	xor	eax, edx
	sub	eax, edx

; 1304 :               attach_method_num(gnum,meth);

	mov	edx, DWORD PTR _gnum$[ebp]
	imul	eax, 2928				; 00000b70H
	or	DWORD PTR [eax+ecx+140], 2097152	; 00200000H
	lea	eax, DWORD PTR [eax+ecx+140]
	push	esi
	push	edx
	call	_attach_method_num
	add	esp, 8

; 1305 :               if ( globality == GLOBAL_METHOD_TOK) 

	cmp	ebx, 35032				; 000088d8H
	jne	SHORT $LN68@read_named

; 1306 :                 apply_method(NULLID,inst_name);

	lea	eax, DWORD PTR _inst_name$[ebp]
	push	eax
	push	0
	call	_apply_method
	add	esp, 8
$LN68@read_named:

; 1307 :               tok = yylex();

	push	0
	call	_kb_yylex

; 1308 :               read_instance_attr(meth);

	push	esi
	mov	DWORD PTR _tok, eax
	call	_read_instance_attr
	add	esp, 8

; 1309 :             }
; 1310 :           }
; 1311 :           break;

	jmp	$LN64@read_named
$LN19@read_named:

; 1312 : 
; 1313 :       case LAGRANGE_MULTIPLIER_TOK: 
; 1314 :          if ( read_const(&(GEN_QUANT(gnum)->pressure)) <= 0 ) 

	mov	ecx, DWORD PTR _gen_quant_list
	mov	esi, edi
	imul	esi, 368				; 00000170H
	lea	edx, DWORD PTR [esi+ecx+192]
	push	edx
	call	_read_const
	add	esp, 4
	test	eax, eax
	jg	SHORT $LN18@read_named

; 1315 :            kb_error(2126,"Missing lagrange_multiplier value.\n",DATAFILE_ERROR);  

	push	6
	push	OFFSET ??_C@_0CE@GJDPGLEJ@Missing?5lagrange_multiplier?5valu@
	push	2126					; 0000084eH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 1316 :          else 

	jmp	$LL36@read_named
$LN18@read_named:

; 1317 :          { GEN_QUANT(gnum)->flags |= Q_PRESSURE_SET; 

	mov	eax, DWORD PTR _gen_quant_list
	or	DWORD PTR [esi+eax+136], 32768		; 00008000H

; 1318 :            lagmulflag = 1; tok = yylex(); 

	mov	DWORD PTR _lagmulflag$[ebp], 1
$LN15@read_named:
	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1363 :       default:
; 1364 :           goto named_exit; /* done with quantity */
; 1365 :           
; 1366 :   }

	jmp	$LL36@read_named
$named_exit$90093:

; 1367 : 
; 1368 : named_exit:
; 1369 :   if ( !lagmulflag ) pressure_set_flag = 0;

	cmp	DWORD PTR _lagmulflag$[ebp], 0
	jne	SHORT $LN1@read_named
	mov	DWORD PTR _pressure_set_flag, 0
$LN1@read_named:

; 1370 :   GEN_QUANT(gnum)->flags &= ~Q_FORWARD_DEF;

	mov	ecx, DWORD PTR _gen_quant_list
	mov	eax, edi
	imul	eax, 368				; 00000170H
	and	DWORD PTR [eax+ecx+136], -1048577	; ffefffffH
	lea	eax, DWORD PTR [eax+ecx+136]

; 1371 :   return gnum;
; 1372 : } // end read_named_quantity()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_read_named_quantity ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@BMGHIFMK@facet_volume?$AA@		; `string'
PUBLIC	??_C@_06EBIBGOAF@x?$CFd?1?$CFd?$AA@		; `string'
PUBLIC	??_C@_0BG@NMBFJJMF@facet_vector_integral?$AA@	; `string'
PUBLIC	??_C@_09IDNCJNBA@edge_area?$AA@			; `string'
PUBLIC	??_C@_0BP@PNGOPOBC@symmetric?5content?5component?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_03KOFBPNDM@x?12?$AA@			; `string'
PUBLIC	??_C@_04MINKFJON@?9y?12?$AA@			; `string'
PUBLIC	??_C@_0BB@EFJDIHF@body_?$CFd_vol_meth?$AA@	; `string'
PUBLIC	??_C@_0M@PLFBMNIM@body_?$CFd_vol?$AA@		; `string'
PUBLIC	_b_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_convert_body_to_quantity
EXTRN	_volume_method_name:BYTE
EXTRN	_area_method_name:BYTE
;	COMDAT ??_C@_0N@BMGHIFMK@facet_volume?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0N@BMGHIFMK@facet_volume?$AA@ DB 'facet_volume', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBIBGOAF@x?$CFd?1?$CFd?$AA@
CONST	SEGMENT
??_C@_06EBIBGOAF@x?$CFd?1?$CFd?$AA@ DB 'x%d/%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NMBFJJMF@facet_vector_integral?$AA@
CONST	SEGMENT
??_C@_0BG@NMBFJJMF@facet_vector_integral?$AA@ DB 'facet_vector_integral', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IDNCJNBA@edge_area?$AA@
CONST	SEGMENT
??_C@_09IDNCJNBA@edge_area?$AA@ DB 'edge_area', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PNGOPOBC@symmetric?5content?5component?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BP@PNGOPOBC@symmetric?5content?5component?5?$CFd?$AA@ DB 'symmetri'
	DB	'c content component %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KOFBPNDM@x?12?$AA@
CONST	SEGMENT
??_C@_03KOFBPNDM@x?12?$AA@ DB 'x/2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MINKFJON@?9y?12?$AA@
CONST	SEGMENT
??_C@_04MINKFJON@?9y?12?$AA@ DB '-y/2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EFJDIHF@body_?$CFd_vol_meth?$AA@
CONST	SEGMENT
??_C@_0BB@EFJDIHF@body_?$CFd_vol_meth?$AA@ DB 'body_%d_vol_meth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PLFBMNIM@body_?$CFd_vol?$AA@
CONST	SEGMENT
??_C@_0M@PLFBMNIM@body_?$CFd_vol?$AA@ DB 'body_%d_vol', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\lexinit2.c
CONST	ENDS
;	COMDAT _convert_body_to_quantity
_TEXT	SEGMENT
_first_e$90953 = -244					; size = 4
_first_e$90830 = -244					; size = 4
tv2925 = -240						; size = 4
_first_fe$90861 = -240					; size = 4
_i$ = -236						; size = 4
tv2708 = -232						; size = 8
tv2692 = -232						; size = 8
tv2633 = -232						; size = 8
tv2539 = -232						; size = 8
tv2740 = -228						; size = 4
_first_fe$90986 = -228					; size = 4
_first_fe$90960 = -228					; size = 4
_first_fe$90890 = -228					; size = 4
_con$90799 = -224					; size = 4
_max_rank$90832 = -220					; size = 4
_fe$ = -220						; size = 4
_j$ = -216						; size = 4
_gq$ = -212						; size = 4
tv2627 = -208						; size = 4
_b_id$GSCopy$ = -204					; size = 4
tv2659 = -200						; size = 4
tv2533 = -200						; size = 4
_bdry$90925 = -200					; size = 4
_max_rank$90903 = -200					; size = 4
_v_id$90802 = -200					; size = 4
_e_id$ = -196						; size = 4
tv2608 = -192						; size = 4
tv2601 = -192						; size = 4
_v_id$90926 = -192					; size = 4
_min_rank$90899 = -192					; size = 4
_min_rank$90833 = -192					; size = 4
_meth1$ = -188						; size = 4
_formula$ = -184					; size = 100
_qname$ = -84						; size = 40
_inst_name1$ = -44					; size = 40
__$ArrayPad$ = -4					; size = 4
_b_id$ = 8						; size = 4
_convert_body_to_quantity PROC				; COMDAT

; 2476 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _b_id$[ebp]
	push	esi
	push	edi

; 2477 :   int gq;
; 2478 :   int meth1;
; 2479 :   char inst_name1[40];
; 2480 :   char qname[40];
; 2481 :   int i,j,k;
; 2482 :   edge_id e_id;
; 2483 :   facet_id f_id;
; 2484 :   facetedge_id fe;
; 2485 :   char formula[100];
; 2486 :   struct gen_quant *g = NULL;
; 2487 : 
; 2488 :   i = ordinal(b_id) + 1;

	mov	edi, ebx
	shr	edi, 28					; 0000001cH
	and	edi, 1

; 2544 :             cmdptr = formula;

	mov	DWORD PTR _b_id$GSCopy$[ebp], ebx
	je	SHORT $LN158@convert_bo@2

; 2477 :   int gq;
; 2478 :   int meth1;
; 2479 :   char inst_name1[40];
; 2480 :   char qname[40];
; 2481 :   int i,j,k;
; 2482 :   edge_id e_id;
; 2483 :   facet_id f_id;
; 2484 :   facetedge_id fe;
; 2485 :   char formula[100];
; 2486 :   struct gen_quant *g = NULL;
; 2487 : 
; 2488 :   i = ordinal(b_id) + 1;

	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN159@convert_bo@2
$LN158@convert_bo@2:
	or	eax, -1
$LN159@convert_bo@2:
	lea	esi, DWORD PTR [eax+1]

; 2489 :   sprintf(qname,"body_%d_vol",i);

	push	esi
	lea	eax, DWORD PTR _qname$[ebp]
	push	OFFSET ??_C@_0M@PLFBMNIM@body_?$CFd_vol?$AA@
	push	eax
	mov	DWORD PTR _i$[ebp], esi
	call	_sprintf

; 2490 :   sprintf(inst_name1,"body_%d_vol_meth",i);

	push	esi
	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	OFFSET ??_C@_0BB@EFJDIHF@body_?$CFd_vol_meth?$AA@
	push	ecx
	call	_sprintf

; 2491 :   if ( get_battr(b_id) & FIXEDVOL )

	mov	edx, DWORD PTR _web+348
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv2539[ebp+4], eax
	mov	eax, ecx
	and	eax, 32					; 00000020H
	xor	edx, edx
	add	esp, 24					; 00000018H
	or	eax, edx
	mov	DWORD PTR tv2533[ebp], esi
	je	SHORT $LN155@convert_bo@2

; 2492 :   { 
; 2493 :     gq = find_quantity(qname);

	lea	ecx, DWORD PTR _qname$[ebp]
	push	ecx
	call	_find_quantity
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR _gq$[ebp], edx

; 2494 :     if ( gq < 0 ) gq = new_quantity(qname,Q_FIXED);

	test	edx, edx
	jns	SHORT $LN154@convert_bo@2
	lea	edx, DWORD PTR _qname$[ebp]
	push	2
	push	edx
	call	_new_quantity
	add	esp, 8
	mov	edx, eax
	mov	DWORD PTR _gq$[ebp], eax
$LN154@convert_bo@2:

; 2495 :     g = GEN_QUANT(gq);

	mov	ecx, edx
	imul	ecx, 368				; 00000170H
	add	ecx, DWORD PTR _gen_quant_list

; 2496 :     g->target = get_body_fixvol(b_id);

	test	edi, edi
	je	SHORT $LN170@convert_bo@2
	mov	eax, DWORD PTR _web+348
	mov	eax, DWORD PTR [esi+eax]
	fld	QWORD PTR [eax+32]
	fldz
	fxch	ST(1)
	fstp	QWORD PTR [ecx+144]
	jmp	$LN149@convert_bo@2
$LN170@convert_bo@2:
	fldz
	fld	ST(0)
	fxch	ST(1)
	fxch	ST(1)
	fstp	QWORD PTR [ecx+144]
	jmp	$LN149@convert_bo@2
$LN155@convert_bo@2:

; 2497 :   }
; 2498 :   else if ( get_battr(b_id) & PRESSURE )

	and	ecx, 2048				; 00000800H
	xor	eax, eax
	or	ecx, eax

; 2499 :   { REAL p;
; 2500 :     gq = find_quantity(qname);

	lea	ecx, DWORD PTR _qname$[ebp]
	push	ecx
	je	$LN152@convert_bo@2
	call	_find_quantity
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR _gq$[ebp], edx

; 2501 :     if ( gq < 0 ) gq = new_quantity(qname,Q_ENERGY);

	test	edx, edx
	jns	SHORT $LN151@convert_bo@2
	lea	edx, DWORD PTR _qname$[ebp]
	push	1
	push	edx
	call	_new_quantity
	add	esp, 8
	mov	edx, eax
	mov	DWORD PTR _gq$[ebp], eax
$LN151@convert_bo@2:

; 2502 :     g = GEN_QUANT(gq);

	mov	ecx, edx
	imul	ecx, 368				; 00000170H
	add	ecx, DWORD PTR _gen_quant_list

; 2503 :     p = get_body_pressure(b_id);

	test	edi, edi
	je	SHORT $LN174@convert_bo@2
	mov	eax, DWORD PTR _web+348
	mov	eax, DWORD PTR [esi+eax]
	fld	QWORD PTR [eax+312]
	fldz
	jmp	SHORT $LN175@convert_bo@2
$LN174@convert_bo@2:
	fldz
	fld	ST(0)
	fxch	ST(1)
$LN175@convert_bo@2:

; 2504 :     g->modulus = -p;

	fld	ST(1)
	fchs
	fstp	QWORD PTR [ecx+176]

; 2505 :     if ( p == 0.0 )

	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN149@convert_bo@2

; 2506 :     { g->flags &= ~Q_ENERGY;

	mov	eax, DWORD PTR [ecx+136]

; 2507 :       g->flags |= Q_INFO; /* to force volume calc even for zero pressure */
; 2508 :       g->modulus = 1.0;

	fld1
	and	eax, -2					; fffffffeH
	fstp	QWORD PTR [ecx+176]
	or	eax, 4
	mov	DWORD PTR [ecx+136], eax

; 2509 :     }

	jmp	SHORT $LN149@convert_bo@2
$LN152@convert_bo@2:

; 2510 :   }
; 2511 :   else { gq = find_quantity(qname);

	call	_find_quantity
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR _gq$[ebp], edx

; 2512 :          if ( gq < 0 ) gq = new_quantity(qname,Q_INFO);

	test	edx, edx
	jns	SHORT $LN148@convert_bo@2
	lea	edx, DWORD PTR _qname$[ebp]
	push	4
	push	edx
	call	_new_quantity
	add	esp, 8
	mov	edx, eax
	mov	DWORD PTR _gq$[ebp], eax
$LN148@convert_bo@2:

; 2513 :          g = GEN_QUANT(gq);

	fldz
	mov	ecx, edx
	imul	ecx, 368				; 00000170H
	add	ecx, DWORD PTR _gen_quant_list
$LN149@convert_bo@2:

; 2514 :        }
; 2515 :   g->flags |= DEFAULT_QUANTITY;

	or	DWORD PTR [ecx+136], 8192		; 00002000H

; 2516 :   g->b_id = b_id;

	mov	DWORD PTR [ecx+216], ebx

; 2517 :   set_body_volquant(b_id,gq);

	mov	eax, DWORD PTR _web+348
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [eax+404], edx

; 2518 :   g->volconst = get_body_volconst(b_id);

	test	edi, edi
	je	SHORT $LN178@convert_bo@2
	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [esi+edx]
	fld	QWORD PTR [eax+328]
	jmp	SHORT $LN179@convert_bo@2
$LN178@convert_bo@2:
	fld	ST(0)
$LN179@convert_bo@2:
	fstp	QWORD PTR [ecx+208]

; 2519 :   g->pressure = get_body_pressure(b_id);

	test	edi, edi
	je	SHORT $LN182@convert_bo@2
	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [esi+edx]
	fld	QWORD PTR [eax+312]
	jmp	SHORT $LN183@convert_bo@2
$LN182@convert_bo@2:
	fld	ST(0)
$LN183@convert_bo@2:
	fstp	QWORD PTR [ecx+192]

; 2520 :   g->value = get_body_volume(b_id);

	test	edi, edi
	je	SHORT $LN186@convert_bo@2
	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [esi+edx]
	fld	QWORD PTR [eax+40]
	jmp	SHORT $LN187@convert_bo@2
$LN186@convert_bo@2:
	fld	ST(0)
$LN187@convert_bo@2:
	fstp	QWORD PTR [ecx+152]

; 2521 :   g->oldvalue = get_body_volume(b_id);

	test	edi, edi
	je	SHORT $LN191@convert_bo@2
	mov	edx, DWORD PTR _web+348
	fstp	ST(0)
	mov	eax, DWORD PTR [esi+edx]
	fld	QWORD PTR [eax+40]
$LN191@convert_bo@2:
	fstp	QWORD PTR [ecx+160]

; 2522 : 
; 2523 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1

; 2524 :   {
; 2525 :      meth1 = find_method_instance(inst_name1);

	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	ecx
	jne	$LN147@convert_bo@2
	call	_find_method_instance
	add	esp, 4
	mov	DWORD PTR _meth1$[ebp], eax

; 2526 :      if ( meth1 < 0 )

	test	eax, eax
	jns	$LN146@convert_bo@2

; 2527 :      { /* have to create */
; 2528 :         if ( area_method_name[0] )

	cmp	BYTE PTR _area_method_name, 0
	je	SHORT $LN145@convert_bo@2

; 2529 :         { meth1 = find_method_instance(area_method_name);  /* user instance? */

	push	OFFSET _area_method_name
	call	_find_method_instance
	add	esp, 4
	mov	DWORD PTR _meth1$[ebp], eax

; 2530 :           if ( meth1 < 0 )  /* try pre-defined method */

	test	eax, eax
	jns	$LN136@convert_bo@2

; 2531 :           { meth1 = new_method_instance(area_method_name,inst_name1);

	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
	push	OFFSET _area_method_name
	call	_new_method_instance

; 2532 :             METH_INSTANCE(meth1)->flags |= DEFAULT_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	DWORD PTR _meth1$[ebp], eax
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	lea	eax, DWORD PTR [eax+ecx+140]

; 2533 :           }

	jmp	$LN436@convert_bo@2
$LN145@convert_bo@2:

; 2534 :         }
; 2535 :         else if ( web.symmetric_content )

	cmp	DWORD PTR _web+808, 0
	je	$LN142@convert_bo@2

; 2536 :         { 
; 2537 :           meth1 = new_method_instance("edge_vector_integral",inst_name1);

	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
	push	OFFSET ??_C@_0BF@EDOAEIAK@edge_vector_integral?$AA@
	call	_new_method_instance
	mov	DWORD PTR _meth1$[ebp], eax

; 2538 :           METH_INSTANCE(meth1)->flags |= DEFAULT_INSTANCE;

	cdq
	mov	esi, eax
	mov	eax, DWORD PTR _meth_inst_list
	xor	esi, edx
	sub	esi, edx
	mov	ebx, esi
	imul	ebx, 2928				; 00000b70H
	or	DWORD PTR [ebx+eax+140], 4194304	; 00400000H

; 2539 :           METH_INSTANCE(meth1)->expr[0] = 
; 2540 :               (struct expnode *)mycalloc(SDIM,sizeof(struct expnode));

	mov	eax, DWORD PTR _web+616
	push	2540					; 000009ecH
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	104					; 00000068H
	push	eax
	call	_kb_calloc
	imul	esi, 732				; 000002dcH
	mov	ecx, DWORD PTR _meth_inst_list
	add	esp, 24					; 00000018H

; 2541 :           for ( j = 0 ; j < 2 ; j++ )

	xor	edi, edi
	add	esi, 58					; 0000003aH
	mov	DWORD PTR [ebx+ecx+232], eax
	mov	DWORD PTR tv2608[ebp], esi
$LL141@convert_bo@2:

; 2542 :           { if ( j==0 )sprintf(formula,"-y/2");

	test	edi, edi
	jne	SHORT $LN138@convert_bo@2
	push	OFFSET ??_C@_04MINKFJON@?9y?12?$AA@
	lea	edx, DWORD PTR _formula$[ebp]
	push	edx

; 2543 :             if ( j==1 )sprintf(formula,"x/2");

	jmp	SHORT $LN437@convert_bo@2
$LN138@convert_bo@2:
	cmp	edi, 1
	jne	SHORT $LN137@convert_bo@2
	push	OFFSET ??_C@_03KOFBPNDM@x?12?$AA@
	lea	eax, DWORD PTR _formula$[ebp]
	push	eax
$LN437@convert_bo@2:
	call	_sprintf
	add	esp, 8
$LN137@convert_bo@2:

; 2545 :             METH_INSTANCE(meth1)->expr[j] = METH_INSTANCE(meth1)->expr[0] + j;

	mov	esi, DWORD PTR tv2608[ebp]
	mov	eax, DWORD PTR _meth_inst_list
	lea	ecx, DWORD PTR _formula$[ebp]
	mov	DWORD PTR _cmdptr, ecx
	mov	ecx, edi
	imul	ecx, 104				; 00000068H
	add	ecx, DWORD PTR [ebx+eax+232]
	add	esi, edi
	add	esi, esi
	add	esi, esi
	mov	DWORD PTR [esi+eax], ecx

; 2546 :             datafile_flag = 1;
; 2547 :             exparse(SDIM,METH_INSTANCE(meth1)->expr[j],USERCOPY); line_no--;

	mov	edx, DWORD PTR _meth_inst_list
	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR _datafile_flag, 1
	mov	eax, DWORD PTR [esi+edx]
	push	1
	push	eax
	push	ecx
	call	_exparse

; 2548 :             sprintf(METH_INSTANCE(meth1)->expr[j]->name,
; 2549 :                 "symmetric content component %d",j+1);

	mov	edx, DWORD PTR _meth_inst_list
	dec	DWORD PTR _line_no
	mov	eax, DWORD PTR [esi+edx]
	inc	edi
	push	edi
	add	eax, 20					; 00000014H
	push	OFFSET ??_C@_0BP@PNGOPOBC@symmetric?5content?5component?5?$CFd?$AA@
	push	eax
	call	_sprintf

; 2550 :             datafile_flag = 0;

	xor	eax, eax
	add	esp, 24					; 00000018H
	mov	DWORD PTR _datafile_flag, eax

; 2551 :             cmdptr = NULL;

	mov	DWORD PTR _cmdptr, eax
	cmp	edi, 2
	jl	$LL141@convert_bo@2

; 2552 :           }
; 2553 :         }
; 2554 :         else

	jmp	SHORT $LN136@convert_bo@2
$LN142@convert_bo@2:

; 2555 :         {
; 2556 :           meth1 = new_method_instance("edge_area",inst_name1);

	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	ecx
	push	OFFSET ??_C@_09IDNCJNBA@edge_area?$AA@
	call	_new_method_instance
	mov	DWORD PTR _meth1$[ebp], eax

; 2557 :           METH_INSTANCE(meth1)->flags |= DEFAULT_INSTANCE;

	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	lea	eax, DWORD PTR [eax+edx+140]
$LN436@convert_bo@2:
	add	esp, 8
	or	DWORD PTR [eax], 4194304		; 00400000H
$LN136@convert_bo@2:

; 2558 :         }
; 2559 :         METH_INSTANCE(meth1)->flags |= BODY_INSTANCE;

	mov	esi, DWORD PTR _meth1$[ebp]

; 2560 :         METH_INSTANCE(meth1)->modulus = 1.0;

	fld1
	mov	ecx, DWORD PTR _meth_inst_list
	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx

; 2561 :         attach_method_num(gq,meth1);

	mov	edx, DWORD PTR _gq$[ebp]
	imul	eax, 2928				; 00000b70H
	or	DWORD PTR [eax+ecx+140], 16777216	; 01000000H
	mov	ecx, DWORD PTR _meth_inst_list
	push	esi
	push	edx
	fstp	QWORD PTR [eax+ecx+304]
	call	_attach_method_num

; 2562 :         set_body_volmeth(b_id,meth1);

	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR tv2533[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	add	esp, 8
	mov	DWORD PTR [edx+412], esi
$LN146@convert_bo@2:

; 2563 :      }
; 2564 :      FOR_ALL_EDGES(e_id)

	mov	edi, DWORD PTR _web+160
	test	edi, 268435456				; 10000000H
	je	$LN109@convert_bo@2
	mov	ecx, DWORD PTR _web+124
$LL378@convert_bo@2:
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv2627[ebp], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR tv2633[ebp+4], eax
	mov	eax, edx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN134@convert_bo@2

; 2565 :      { fe = get_edge_fe(e_id); 

	test	ecx, ecx
	jne	SHORT $LN193@convert_bo@2
	xor	eax, eax
	jmp	SHORT $LN194@convert_bo@2
$LN193@convert_bo@2:
	mov	ecx, DWORD PTR [ecx+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN192@convert_bo@2
	xor	ecx, 134217728				; 08000000H
$LN192@convert_bo@2:
	mov	eax, ecx
$LN194@convert_bo@2:

; 2566 :         if ( !valid_id(fe)  ) continue;

	test	eax, 268435456				; 10000000H
	je	$LN134@convert_bo@2

; 2567 :         if ( get_eattr(e_id) & NONCONTENT ) continue;

	and	edx, 536870912				; 20000000H
	xor	ecx, ecx
	or	edx, ecx
	jne	$LN134@convert_bo@2

; 2568 :         f_id = get_fe_facet(fe);

	mov	ecx, DWORD PTR _web+460
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+ecx]
	mov	ebx, DWORD PTR [edx+24]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv2659[ebp], eax
	je	SHORT $LN196@convert_bo@2
	xor	ebx, 134217728				; 08000000H
$LN196@convert_bo@2:

; 2569 :         if ( valid_id(f_id)) 

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN379@convert_bo@2

; 2570 :         { if ( equal_id(b_id,get_facet_body(f_id)) )

	push	ebx
	call	_get_facet_body
	add	esp, 4
	cmp	DWORD PTR _b_id$GSCopy$[ebp], eax
	jne	SHORT $LN127@convert_bo@2

; 2571 :              apply_method_num(e_id,meth1);

	mov	eax, DWORD PTR _meth1$[ebp]
	push	eax
	push	edi
	jmp	SHORT $LN438@convert_bo@2
$LN127@convert_bo@2:

; 2572 :           else if ( equal_id(b_id,get_facet_body(inverse_id(f_id))) )

	xor	ebx, 134217728				; 08000000H
	push	ebx
	call	_get_facet_body
	add	esp, 4
	cmp	DWORD PTR _b_id$GSCopy$[ebp], eax
	jne	SHORT $LN379@convert_bo@2

; 2573 :              apply_method_num(inverse_id(e_id),meth1);

	mov	ecx, DWORD PTR _meth1$[ebp]
	mov	edx, edi
	push	ecx
	xor	edx, 134217728				; 08000000H
	push	edx
$LN438@convert_bo@2:
	call	_apply_method_num
	add	esp, 8
$LN379@convert_bo@2:

; 2574 :         }
; 2575 :         fe = get_next_facet(fe);

	cmp	DWORD PTR tv2659[ebp], 0
	mov	ecx, DWORD PTR _web+460
	je	SHORT $LN201@convert_bo@2
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN200@convert_bo@2
$LN201@convert_bo@2:
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+40]
$LN200@convert_bo@2:

; 2576 :         f_id = get_fe_facet(fe);

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN205@convert_bo@2
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN204@convert_bo@2
$LN205@convert_bo@2:
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	esi, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN204@convert_bo@2
	xor	esi, 134217728				; 08000000H
$LN204@convert_bo@2:

; 2577 :         if ( valid_id(f_id)) 

	test	esi, 268435456				; 10000000H
	je	SHORT $LN134@convert_bo@2

; 2578 :         { /* check both in case of torus wrapping */
; 2579 :           if ( equal_id(b_id,get_facet_body(f_id)) )

	push	esi
	call	_get_facet_body
	mov	ebx, DWORD PTR _b_id$GSCopy$[ebp]
	add	esp, 4
	cmp	ebx, eax
	jne	SHORT $LN123@convert_bo@2

; 2580 :              apply_method_num(e_id,meth1);

	mov	edx, DWORD PTR _meth1$[ebp]
	push	edx
	push	edi
	call	_apply_method_num
	add	esp, 8
$LN123@convert_bo@2:

; 2581 :           if ( equal_id(b_id,get_facet_body(inverse_id(f_id))) )

	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	push	eax
	call	_get_facet_body
	add	esp, 4
	cmp	ebx, eax
	jne	SHORT $LN134@convert_bo@2

; 2582 :              apply_method_num(inverse_id(e_id),meth1);

	mov	eax, DWORD PTR _meth1$[ebp]
	push	eax
	xor	edi, 134217728				; 08000000H
	push	edi
	call	_apply_method_num
	add	esp, 8
$LN134@convert_bo@2:

; 2563 :      }
; 2564 :      FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR tv2627[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [edx+ecx]
	mov	edi, DWORD PTR [eax]
	test	edi, 268435456				; 10000000H
	jne	$LL378@convert_bo@2

; 2583 :         }
; 2584 :      }
; 2585 :   }
; 2586 :   else  /* SOAPFILM */

	jmp	$LN109@convert_bo@2
$LN147@convert_bo@2:

; 2587 :   {
; 2588 :      meth1 = find_method_instance(inst_name1);

	call	_find_method_instance
	mov	ebx, eax
	add	esp, 4

; 2589 :      if ( meth1 < 0 )

	test	ebx, ebx
	jns	$LN120@convert_bo@2

; 2590 :      { /* have to create */
; 2591 :         if ( volume_method_name[0] )

	cmp	BYTE PTR _volume_method_name, 0
	je	SHORT $LN119@convert_bo@2

; 2592 :         { meth1 = find_method_instance(volume_method_name); /* user instance? */

	push	OFFSET _volume_method_name
	call	_find_method_instance
	add	esp, 4
	mov	DWORD PTR _meth1$[ebp], eax

; 2593 :           if ( meth1 < 0 )  /* try pre-defined method */

	test	eax, eax
	jns	$LN112@convert_bo@2

; 2594 :           { meth1 = new_method_instance(volume_method_name,inst_name1);

	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
	push	OFFSET _volume_method_name

; 2595 :             METH_INSTANCE(meth1)->flags |= DEFAULT_INSTANCE;
; 2596 :           }

	jmp	$LN439@convert_bo@2
$LN119@convert_bo@2:

; 2597 :         }
; 2598 :         else if ( web.symmetric_content )

	cmp	DWORD PTR _web+808, 0
	je	$LN116@convert_bo@2

; 2599 :         {
; 2600 :           meth1 = new_method_instance("facet_vector_integral",inst_name1);

	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
	push	OFFSET ??_C@_0BG@NMBFJJMF@facet_vector_integral?$AA@
	call	_new_method_instance
	mov	DWORD PTR _meth1$[ebp], eax

; 2601 :           METH_INSTANCE(meth1)->flags |= DEFAULT_INSTANCE;

	cdq
	mov	esi, eax
	mov	eax, DWORD PTR _meth_inst_list
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	or	DWORD PTR [esi+eax+140], 4194304	; 00400000H

; 2602 :           METH_INSTANCE(meth1)->expr[0] = 
; 2603 :             (struct expnode *)mycalloc(SDIM,sizeof(struct expnode));

	mov	eax, DWORD PTR _web+616
	push	2603					; 00000a2bH
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	104					; 00000068H
	push	eax
	call	_kb_calloc
	mov	ecx, DWORD PTR _meth_inst_list
	mov	DWORD PTR [esi+ecx+232], eax

; 2604 :           for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 24					; 00000018H
	test	eax, eax
	jle	$LN112@convert_bo@2

; 2599 :         {
; 2600 :           meth1 = new_method_instance("facet_vector_integral",inst_name1);

	add	esi, 232				; 000000e8H
	mov	DWORD PTR tv2601[ebp], esi
	mov	edi, 1
	xor	ebx, ebx
$LL115@convert_bo@2:

; 2605 :           { sprintf(formula,"x%d/%d",j+1,SDIM);

	push	eax
	push	edi
	lea	edx, DWORD PTR _formula$[ebp]
	push	OFFSET ??_C@_06EBIBGOAF@x?$CFd?1?$CFd?$AA@
	push	edx
	call	_sprintf

; 2606 :             cmdptr = formula;
; 2607 :             METH_INSTANCE(meth1)->expr[j] = METH_INSTANCE(meth1)->expr[0] + j;

	mov	ecx, DWORD PTR tv2601[ebp]
	lea	eax, DWORD PTR _formula$[ebp]
	mov	DWORD PTR _cmdptr, eax
	mov	eax, DWORD PTR _meth_inst_list
	mov	edx, DWORD PTR [ecx+eax]
	add	edx, ebx
	mov	DWORD PTR [esi+eax], edx

; 2608 :             datafile_flag = 1;
; 2609 :             exparse(SDIM,METH_INSTANCE(meth1)->expr[j],USERCOPY); line_no--;

	mov	eax, DWORD PTR _meth_inst_list
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR _datafile_flag, 1
	mov	ecx, DWORD PTR [esi+eax]
	push	1
	push	ecx
	push	edx
	call	_exparse

; 2610 :             sprintf(METH_INSTANCE(meth1)->expr[j]->name,
; 2611 :                "symmetric content component %d",j+1);

	mov	eax, DWORD PTR _meth_inst_list
	dec	DWORD PTR _line_no
	mov	ecx, DWORD PTR [esi+eax]
	push	edi
	add	ecx, 20					; 00000014H
	push	OFFSET ??_C@_0BP@PNGOPOBC@symmetric?5content?5component?5?$CFd?$AA@
	push	ecx
	call	_sprintf

; 2612 :             datafile_flag = 0;

	xor	eax, eax
	inc	edi
	mov	DWORD PTR _datafile_flag, eax

; 2613 :             cmdptr = NULL;

	mov	DWORD PTR _cmdptr, eax
	mov	eax, DWORD PTR _web+616
	lea	edx, DWORD PTR [edi-1]
	add	esp, 40					; 00000028H
	add	esi, 4
	add	ebx, 104				; 00000068H
	cmp	edx, eax
	jl	$LL115@convert_bo@2

; 2614 :           }
; 2615 :         }
; 2616 :         else

	jmp	SHORT $LN112@convert_bo@2
$LN116@convert_bo@2:

; 2617 :         {
; 2618 :           meth1 = new_method_instance("facet_volume",inst_name1);

	lea	eax, DWORD PTR _inst_name1$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@BMGHIFMK@facet_volume?$AA@
$LN439@convert_bo@2:
	call	_new_method_instance

; 2619 :           METH_INSTANCE(meth1)->flags |= DEFAULT_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	DWORD PTR _meth1$[ebp], eax
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	lea	eax, DWORD PTR [eax+ecx+140]
	add	esp, 8
	or	DWORD PTR [eax], 4194304		; 00400000H
$LN112@convert_bo@2:

; 2620 :         }
; 2621 :         METH_INSTANCE(meth1)->flags |= BODY_INSTANCE;

	mov	esi, DWORD PTR _meth1$[ebp]

; 2622 :         METH_INSTANCE(meth1)->modulus = 1.0;

	fld1
	mov	ecx, DWORD PTR _meth_inst_list
	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	or	DWORD PTR [eax+ecx+140], 16777216	; 01000000H
	mov	edx, DWORD PTR _meth_inst_list

; 2623 :         attach_method_num(gq,meth1);

	push	esi
	fstp	QWORD PTR [eax+edx+304]
	mov	eax, DWORD PTR _gq$[ebp]
	push	eax
	call	_attach_method_num

; 2624 :         set_body_volmeth(b_id,meth1);

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR tv2533[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	add	esp, 8
	mov	DWORD PTR [eax+412], esi
	mov	ebx, esi
$LN120@convert_bo@2:

; 2625 :      }
; 2626 :      FOR_ALL_FACETS(f_id)

	mov	edi, DWORD PTR _web+272
	test	edi, 268435456				; 10000000H
	je	$LN109@convert_bo@2
	npad	2
$LL111@convert_bo@2:
	mov	ecx, DWORD PTR _web+236
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, ecx
	mov	DWORD PTR tv2692[ebp+4], edx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN110@convert_bo@2

; 2627 :      { /* check both in case of torus wrapping */
; 2628 :         if ( get_fattr(f_id) & NONCONTENT ) continue;

	and	ecx, 536870912				; 20000000H
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN110@convert_bo@2

; 2629 :         if ( equal_id(b_id,get_facet_body(f_id)) )

	push	edi
	call	_get_facet_body
	add	esp, 4
	cmp	DWORD PTR _b_id$GSCopy$[ebp], eax
	jne	SHORT $LN105@convert_bo@2

; 2630 :             apply_method_num(f_id,meth1);

	push	ebx
	push	edi
	call	_apply_method_num
	add	esp, 8
$LN105@convert_bo@2:

; 2631 :         if ( equal_id(b_id,get_facet_body(inverse_id(f_id))) )

	xor	edi, 134217728				; 08000000H
	push	edi
	call	_get_facet_body
	add	esp, 4
	cmp	DWORD PTR _b_id$GSCopy$[ebp], eax
	jne	SHORT $LN110@convert_bo@2

; 2632 :             apply_method_num(inverse_id(f_id),meth1);

	push	ebx
	push	edi
	call	_apply_method_num
	add	esp, 8
$LN110@convert_bo@2:

; 2625 :      }
; 2626 :      FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [ecx]
	test	edi, 268435456				; 10000000H
	jne	$LL111@convert_bo@2
$LN109@convert_bo@2:

; 2633 :      }
; 2634 :   }
; 2635 : 
; 2636 :   /* constraint content integrals */
; 2637 :   for ( j = 0 ; j < web.maxcon ; j++ )

	xor	ebx, ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	DWORD PTR _web+644, ebx
	jle	$LN101@convert_bo@2
	npad	2
$LL103@convert_bo@2:

; 2638 :   { struct constraint *con = get_constraint(j);

	mov	edx, DWORD PTR _web+652
	mov	edi, ebx
	and	edi, 1073741823				; 3fffffffH
	imul	edi, 176				; 000000b0H

; 2639 :     vertex_id v_id;
; 2640 :     struct method_instance *mi;
; 2641 : 
; 2642 :     if ( !(con->attr & CON_CONTENT) ) continue;

	mov	eax, DWORD PTR [edx+edi+36]
	mov	ecx, DWORD PTR [edx+edi+32]
	add	edx, edi
	mov	DWORD PTR tv2708[ebp+4], eax
	mov	eax, ecx
	and	eax, 128				; 00000080H
	xor	esi, esi
	or	eax, esi
	je	$LN102@convert_bo@2

; 2643 :     if ( con->attr & NAMED_THING )

	and	ecx, 512				; 00000200H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN99@convert_bo@2

; 2644 :       sprintf(inst_name1,"body_%d_%s_meth",i,con->name);

	mov	ecx, DWORD PTR _i$[ebp]
	push	edx
	push	ecx
	push	OFFSET ??_C@_0BA@NNIIKJGD@body_?$CFd_?$CFs_meth?$AA@
	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx

; 2645 :     else

	jmp	SHORT $LN440@convert_bo@2
$LN99@convert_bo@2:

; 2646 :       sprintf(inst_name1,"body_%d_con_%d_meth",i,j);

	mov	eax, DWORD PTR _i$[ebp]
	push	ebx
	push	eax
	push	OFFSET ??_C@_0BE@MMPMDLLO@body_?$CFd_con_?$CFd_meth?$AA@
	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	ecx
$LN440@convert_bo@2:
	call	_sprintf

; 2647 :     meth1 = find_method_instance(inst_name1);

	lea	edx, DWORD PTR _inst_name1$[ebp]
	add	esp, 16					; 00000010H
	push	edx
	call	_find_method_instance
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _meth1$[ebp], ecx

; 2648 :     if ( meth1 < 0 )

	test	ecx, ecx
	jns	SHORT $LN95@convert_bo@2

; 2649 :     { /* have to create */
; 2650 :       if ( web.representation ==  STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN96@convert_bo@2

; 2651 :       { meth1 = new_method_instance("vertex_scalar_integral",inst_name1);

	lea	eax, DWORD PTR _inst_name1$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@EHAKMPOM@vertex_scalar_integral?$AA@
	call	_new_method_instance
	mov	ecx, eax
	mov	DWORD PTR _meth1$[ebp], ecx

; 2652 :       }
; 2653 :       else

	jmp	SHORT $LN441@convert_bo@2
$LN96@convert_bo@2:

; 2654 :       { meth1 = new_method_instance("edge_vector_integral",inst_name1);

	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BF@EDOAEIAK@edge_vector_integral?$AA@
	call	_new_method_instance
	mov	ecx, eax
	mov	DWORD PTR _meth1$[ebp], eax
$LN441@convert_bo@2:
	add	esp, 8
$LN95@convert_bo@2:

; 2655 :       }
; 2656 :     }
; 2657 :     mi = METH_INSTANCE(meth1);

	mov	eax, ecx
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx

; 2658 :     mi->flags |= DEFAULT_INSTANCE | BODY_INSTANCE;
; 2659 :     mi->connum = j; 
; 2660 :     attach_method_num(gq,meth1);

	mov	edx, DWORD PTR _gq$[ebp]
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list
	push	ecx
	or	DWORD PTR [esi+140], 20971520		; 01400000H
	push	edx
	mov	DWORD PTR [esi+216], ebx
	call	_attach_method_num

; 2661 :     con = get_constraint(j); /* may have moved */

	mov	eax, DWORD PTR _web+652
	add	eax, edi
	add	esp, 8

; 2662 :     if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	mov	DWORD PTR _con$90799[ebp], eax
	jne	SHORT $LN94@convert_bo@2

; 2663 :       mi->expr[0]  = con->convect[0];

	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR [esi+232], ecx

; 2664 :     else

	jmp	SHORT $LN394@convert_bo@2
$LN94@convert_bo@2:

; 2665 :       for ( k = 0 ; k < SDIM ; k++ ) 

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN394@convert_bo@2
	add	esi, 232				; 000000e8H
	add	eax, 108				; 0000006cH
$LL92@convert_bo@2:

; 2666 :         mi->expr[k] = con->convect[k];

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [esi], edx
	inc	ecx
	add	eax, 4
	add	esi, 4
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL92@convert_bo@2
$LN394@convert_bo@2:

; 2667 :     
; 2668 :     if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	$LN89@convert_bo@2

; 2669 :     { FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+48
	mov	DWORD PTR _v_id$90802[ebp], edx
	test	edx, 268435456				; 10000000H
	je	$LN102@convert_bo@2
	mov	edi, DWORD PTR _web+12
$LL88@convert_bo@2:
	mov	esi, edx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	mov	DWORD PTR tv2740[ebp], esi
	je	$LN87@convert_bo@2

; 2670 :       if ( v_on_constraint(v_id,j) ) 

	push	ebx
	push	edx
	call	_v_on_constraint
	add	esp, 8
	test	eax, eax
	je	$LN73@convert_bo@2

; 2671 :       { edge_id first_e = e_id = get_vertex_edge(v_id);

	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [eax+28]

; 2672 :         int max_rank,min_rank,jj;
; 2673 :         conmap_t *map = get_v_constraint_map(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	cmp	DWORD PTR [ecx+edx+1288], 0
	mov	DWORD PTR _e_id$[ebp], edi
	mov	DWORD PTR _first_e$90830[ebp], edi
	je	SHORT $LN160@convert_bo@2
	mov	ecx, DWORD PTR [ecx+edx+1264]
	add	ecx, eax
	jmp	SHORT $LN161@convert_bo@2
$LN160@convert_bo@2:
	mov	ecx, OFFSET _nullcon
$LN161@convert_bo@2:
	mov	esi, DWORD PTR [ecx]

; 2674 : 
; 2675 :         min_rank = MAXINT; max_rank = 0;
; 2676 :         for ( jj = 1 ; jj <= (int)map[0] ; jj++ )

	mov	edx, 1
	mov	DWORD PTR _min_rank$90833[ebp], 2147483647 ; 7fffffffH
	mov	DWORD PTR _max_rank$90832[ebp], 0
	cmp	esi, edx
	jl	SHORT $LN80@convert_bo@2
	mov	eax, DWORD PTR _j$[ebp]
	mov	edi, DWORD PTR [ecx+eax*4]
	and	edi, -2147483648			; 80000000H
$LL403@convert_bo@2:

; 2677 :         { struct constraint *c;
; 2678 :           if ( !(map[j] & CON_HIT_BIT) ) continue;

	test	edi, edi
	je	SHORT $LN81@convert_bo@2

; 2679 :           c = get_constraint(map[jj]);

	mov	eax, DWORD PTR [ecx+edx*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 2680 :           if ( c->content_rank < min_rank ) min_rank = c->content_rank;

	mov	eax, DWORD PTR [eax+172]
	cmp	eax, DWORD PTR _min_rank$90833[ebp]
	jge	SHORT $LN78@convert_bo@2
	mov	DWORD PTR _min_rank$90833[ebp], eax
$LN78@convert_bo@2:

; 2681 :           if ( c->content_rank > max_rank ) max_rank = c->content_rank;

	cmp	eax, DWORD PTR _max_rank$90832[ebp]
	jle	SHORT $LN81@convert_bo@2
	mov	DWORD PTR _max_rank$90832[ebp], eax
$LN81@convert_bo@2:

; 2674 : 
; 2675 :         min_rank = MAXINT; max_rank = 0;
; 2676 :         for ( jj = 1 ; jj <= (int)map[0] ; jj++ )

	inc	edx
	cmp	edx, esi
	jle	SHORT $LL403@convert_bo@2
	mov	edi, DWORD PTR _e_id$[ebp]
$LN80@convert_bo@2:

; 2682 :         }
; 2683 : 
; 2684 :         if ( valid_id(e_id) )

	test	edi, 268435456				; 10000000H
	je	$LN73@convert_bo@2
	mov	ebx, DWORD PTR _web+328
	mov	edx, DWORD PTR _web+124
	npad	11
$LL75@convert_bo@2:

; 2685 :         do
; 2686 :         { 
; 2687 :           facetedge_id first_fe = fe = get_edge_fe(e_id);

	mov	esi, DWORD PTR _e_id$[ebp]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2627[ebp], eax
	mov	eax, DWORD PTR [eax+edx]
	test	eax, eax
	jne	SHORT $LN209@convert_bo@2
	xor	edi, edi
	jmp	SHORT $LN210@convert_bo@2
$LN209@convert_bo@2:
	mov	ecx, DWORD PTR [eax+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN208@convert_bo@2
	xor	ecx, 134217728				; 08000000H
$LN208@convert_bo@2:
	mov	edi, ecx
$LN210@convert_bo@2:
	mov	DWORD PTR _first_fe$90861[ebp], edi

; 2688 :           if ( valid_id(fe) && !(get_eattr(e_id) & NONCONTENT) )  

	test	edi, 268435456				; 10000000H
	je	$LN69@convert_bo@2
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN69@convert_bo@2
	npad	7
$LL71@convert_bo@2:

; 2689 :           do
; 2690 :           { f_id = get_fe_facet(fe);

	test	edi, 268435456				; 10000000H
	jne	SHORT $LN213@convert_bo@2
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN212@convert_bo@2
$LN213@convert_bo@2:
	mov	edx, DWORD PTR _web+460
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	esi, DWORD PTR [eax+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN212@convert_bo@2
	xor	esi, 134217728				; 08000000H
$LN212@convert_bo@2:

; 2691 :             if ( equal_id(b_id,get_facet_body(f_id)) && 
; 2692 :               ( (!inverted(f_id) && con->content_rank >= max_rank) 
; 2693 :                || (inverted(f_id) && con->content_rank <= min_rank)) )

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN219@convert_bo@2
	xor	eax, eax
	jmp	SHORT $LN216@convert_bo@2
$LN219@convert_bo@2:
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN218@convert_bo@2
	xor	eax, eax
	jmp	SHORT $LN216@convert_bo@2
$LN218@convert_bo@2:
	test	esi, 134217728				; 08000000H
	je	SHORT $LN217@convert_bo@2
	mov	edx, DWORD PTR _web+236
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [ebx+ecx+784]
	mov	eax, DWORD PTR [eax+edx+4]
	jmp	SHORT $LN216@convert_bo@2
$LN217@convert_bo@2:
	mov	ecx, DWORD PTR _web+236
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ebx+eax+784]
	mov	eax, DWORD PTR [edx+ecx]
$LN216@convert_bo@2:
	cmp	DWORD PTR _b_id$GSCopy$[ebp], eax
	jne	SHORT $LN401@convert_bo@2
	mov	eax, esi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	jne	SHORT $LN399@convert_bo@2
	mov	edx, DWORD PTR _con$90799[ebp]
	mov	ecx, DWORD PTR [edx+172]
	cmp	ecx, DWORD PTR _max_rank$90832[ebp]
	jge	SHORT $LN67@convert_bo@2
$LN399@convert_bo@2:
	test	eax, eax
	je	SHORT $LN401@convert_bo@2
	mov	edx, DWORD PTR _con$90799[ebp]
	mov	eax, DWORD PTR [edx+172]
	cmp	eax, DWORD PTR _min_rank$90833[ebp]
	jg	SHORT $LN401@convert_bo@2
$LN67@convert_bo@2:

; 2694 :               apply_method_num(inverse_id(v_id),meth1);

	mov	ecx, DWORD PTR _meth1$[ebp]
	mov	edx, DWORD PTR _v_id$90802[ebp]
	push	ecx
	xor	edx, 134217728				; 08000000H
	push	edx
	call	_apply_method_num
	mov	ebx, DWORD PTR _web+328
	add	esp, 8
$LN401@convert_bo@2:

; 2695 :             if ( equal_id(b_id,get_facet_body(inverse_id(f_id))) && 
; 2696 :               ( (!inverted(f_id) && con->content_rank >= max_rank) 
; 2697 :                || (inverted(f_id) && con->content_rank <= min_rank)) )

	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN225@convert_bo@2
	xor	eax, eax
	jmp	SHORT $LN222@convert_bo@2
$LN225@convert_bo@2:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN224@convert_bo@2
	xor	eax, eax
	jmp	SHORT $LN222@convert_bo@2
$LN224@convert_bo@2:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN223@convert_bo@2
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ebx+eax+784]
	mov	eax, DWORD PTR [edx+ecx+4]
	jmp	SHORT $LN222@convert_bo@2
$LN223@convert_bo@2:
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ebx+ecx+784]
	mov	eax, DWORD PTR [eax+edx]
$LN222@convert_bo@2:
	cmp	DWORD PTR _b_id$GSCopy$[ebp], eax
	jne	SHORT $LN65@convert_bo@2
	shr	esi, 27					; 0000001bH
	and	esi, 1
	jne	SHORT $LN404@convert_bo@2
	mov	eax, DWORD PTR _max_rank$90832[ebp]
	mov	ecx, DWORD PTR _con$90799[ebp]
	cmp	DWORD PTR [ecx+172], eax
	jge	SHORT $LN64@convert_bo@2
$LN404@convert_bo@2:
	test	esi, esi
	je	SHORT $LN65@convert_bo@2
	mov	edx, DWORD PTR _min_rank$90833[ebp]
	mov	eax, DWORD PTR _con$90799[ebp]
	cmp	DWORD PTR [eax+172], edx
	jg	SHORT $LN65@convert_bo@2
$LN64@convert_bo@2:

; 2698 :               apply_method(v_id,inst_name1);

	mov	edx, DWORD PTR _v_id$90802[ebp]
	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	ecx
	push	edx
	call	_apply_method
	mov	ebx, DWORD PTR _web+328
	add	esp, 8
$LN65@convert_bo@2:

; 2699 :             fe = get_next_facet(fe);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN229@convert_bo@2
	mov	eax, DWORD PTR _web+460
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR [ecx+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN70@convert_bo@2
$LN229@convert_bo@2:
	mov	edx, DWORD PTR _web+460
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+edi*4]
	mov	edi, DWORD PTR [eax+40]
$LN70@convert_bo@2:

; 2700 :           } while ( !equal_id(fe,first_fe) );

	cmp	edi, DWORD PTR _first_fe$90861[ebp]
	jne	$LL71@convert_bo@2
	mov	edx, DWORD PTR _web+124
$LN69@convert_bo@2:

; 2701 :           e_id = get_next_tail_edge(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	eax, DWORD PTR tv2627[ebp]
	mov	eax, DWORD PTR [eax+edx]
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4+32]
	mov	DWORD PTR _e_id$[ebp], eax

; 2702 :         } while ( !equal_id(first_e,e_id));

	cmp	DWORD PTR _first_e$90830[ebp], eax
	jne	$LL75@convert_bo@2
$LN73@convert_bo@2:
	mov	ebx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR tv2740[ebp]
	mov	edi, DWORD PTR _web+12
$LN87@convert_bo@2:

; 2669 :     { FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR [esi+edi]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _v_id$90802[ebp], edx
	test	edx, 268435456				; 10000000H
	jne	$LL88@convert_bo@2

; 2703 :       }
; 2704 :     }
; 2705 :     else  /* SOAPFILM */

	jmp	$LN102@convert_bo@2
$LN89@convert_bo@2:

; 2706 :     { FOR_ALL_EDGES(e_id)

	mov	edi, DWORD PTR _web+160
	mov	DWORD PTR _e_id$[ebp], edi
	test	edi, 268435456				; 10000000H
	je	$LN102@convert_bo@2
	npad	11
$LL61@convert_bo@2:
	mov	edx, DWORD PTR _web+124
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	mov	DWORD PTR tv2627[ebp], esi
	je	$LN60@convert_bo@2

; 2707 :       if ( e_on_constraint(e_id,j) ) 

	push	ebx
	push	edi
	call	_e_on_constraint
	add	esp, 8
	test	eax, eax
	je	$LN60@convert_bo@2

; 2708 :       { facetedge_id first_fe = fe = get_edge_fe(e_id);

	mov	eax, DWORD PTR _web+124
	mov	eax, DWORD PTR [esi+eax]
	test	eax, eax
	jne	SHORT $LN235@convert_bo@2
	xor	edi, edi
	mov	DWORD PTR _fe$[ebp], edi
	jmp	SHORT $LN236@convert_bo@2
$LN235@convert_bo@2:
	mov	ecx, DWORD PTR [eax+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN234@convert_bo@2
	xor	ecx, 134217728				; 08000000H
$LN234@convert_bo@2:
	mov	edi, ecx
	mov	DWORD PTR _fe$[ebp], ecx
$LN236@convert_bo@2:
	mov	DWORD PTR _first_fe$90890[ebp], edi

; 2709 :         
; 2710 :         if ( valid_id ( fe ) )

	test	edi, 268435456				; 10000000H
	je	$LN60@convert_bo@2

; 2711 :         { conmap_t *conmap = get_e_constraint_map(e_id);

	mov	ecx, DWORD PTR _web+216
	mov	ebx, DWORD PTR _dymem
	cmp	DWORD PTR [ecx+ebx+1048], 0
	je	SHORT $LN162@convert_bo@2
	mov	edx, DWORD PTR [ecx+ebx+1024]
	add	edx, eax
	jmp	SHORT $LN163@convert_bo@2
$LN162@convert_bo@2:
	mov	edx, OFFSET _nullcon
$LN163@convert_bo@2:
	mov	esi, DWORD PTR [edx]

; 2712 :           int min_rank = MAXINT; 
; 2713 :           int max_rank = 0;
; 2714 :           int jj;
; 2715 : 
; 2716 :           for ( jj = 1 ; jj <= (int)conmap[0] ; jj++ )

	mov	ecx, 1
	mov	DWORD PTR _min_rank$90899[ebp], 2147483647 ; 7fffffffH
	mov	DWORD PTR _max_rank$90903[ebp], 0
	cmp	esi, ecx
	jl	SHORT $LL49@convert_bo@2
	mov	edi, DWORD PTR _web+652
	npad	7
$LL380@convert_bo@2:

; 2717 :           { 
; 2718 :             struct constraint *c = get_constraint(conmap[jj]);

	mov	eax, DWORD PTR [edx+ecx*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H

; 2719 :             if ( c->content_rank < min_rank ) min_rank = c->content_rank;

	mov	eax, DWORD PTR [eax+edi+172]
	cmp	eax, DWORD PTR _min_rank$90899[ebp]
	jge	SHORT $LN51@convert_bo@2
	mov	DWORD PTR _min_rank$90899[ebp], eax
$LN51@convert_bo@2:

; 2720 :             if ( c->content_rank > max_rank ) max_rank = c->content_rank;

	cmp	eax, DWORD PTR _max_rank$90903[ebp]
	jle	SHORT $LN53@convert_bo@2
	mov	DWORD PTR _max_rank$90903[ebp], eax
$LN53@convert_bo@2:

; 2712 :           int min_rank = MAXINT; 
; 2713 :           int max_rank = 0;
; 2714 :           int jj;
; 2715 : 
; 2716 :           for ( jj = 1 ; jj <= (int)conmap[0] ; jj++ )

	inc	ecx
	cmp	ecx, esi
	jle	SHORT $LL380@convert_bo@2
	mov	edi, DWORD PTR _fe$[ebp]
	mov	ebx, DWORD PTR _dymem
$LL49@convert_bo@2:

; 2721 :           }
; 2722 :           do
; 2723 :           { f_id = get_fe_facet(fe);

	test	edi, 268435456				; 10000000H
	jne	SHORT $LN239@convert_bo@2
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN240@convert_bo@2
$LN239@convert_bo@2:
	mov	edx, DWORD PTR _web+460
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN238@convert_bo@2
	xor	eax, 134217728				; 08000000H
$LN238@convert_bo@2:
	mov	esi, eax
$LN240@convert_bo@2:

; 2724 :             if ( !(get_fattr(f_id) & NONCONTENT) )

	mov	edx, DWORD PTR _web+236
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 536870912				; 20000000H
	xor	edx, edx
	or	eax, edx
	jne	$LN393@convert_bo@2

; 2725 :             { if ( equal_id(b_id,get_facet_body(f_id)) 
; 2726 :                        && (con->content_rank >= max_rank) )

	cmp	DWORD PTR _web+400, edx
	jne	SHORT $LN245@convert_bo@2
	xor	ecx, ecx
	jmp	SHORT $LN242@convert_bo@2
$LN245@convert_bo@2:
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN244@convert_bo@2
	xor	ecx, ecx
	jmp	SHORT $LN242@convert_bo@2
$LN244@convert_bo@2:
	mov	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR [eax+ebx+784]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN243@convert_bo@2
	mov	ecx, DWORD PTR [edx+ecx+4]
	jmp	SHORT $LN242@convert_bo@2
$LN243@convert_bo@2:
	mov	ecx, DWORD PTR [ecx+edx]
$LN242@convert_bo@2:
	cmp	DWORD PTR _b_id$GSCopy$[ebp], ecx
	jne	SHORT $LN392@convert_bo@2
	mov	eax, DWORD PTR _max_rank$90903[ebp]
	mov	ecx, DWORD PTR _con$90799[ebp]
	cmp	DWORD PTR [ecx+172], eax
	jl	SHORT $LN392@convert_bo@2

; 2727 :                 apply_method_num(e_id,meth1);

	mov	edx, DWORD PTR _meth1$[ebp]
	mov	eax, DWORD PTR _e_id$[ebp]
	push	edx
	push	eax
	call	_apply_method_num
	mov	ebx, DWORD PTR _dymem
	add	esp, 8
$LN392@convert_bo@2:

; 2728 :               if ( equal_id(b_id,get_facet_body(inverse_id(f_id))) 
; 2729 :                        && (con->content_rank <= min_rank) )

	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN251@convert_bo@2
	xor	eax, eax
	jmp	SHORT $LN248@convert_bo@2
$LN251@convert_bo@2:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN250@convert_bo@2
	xor	eax, eax
	jmp	SHORT $LN248@convert_bo@2
$LN250@convert_bo@2:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN249@convert_bo@2
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR [eax+ebx+784]
	mov	eax, DWORD PTR [edx+ecx+4]
	jmp	SHORT $LN248@convert_bo@2
$LN249@convert_bo@2:
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+ebx+784]
	mov	eax, DWORD PTR [eax+edx]
$LN248@convert_bo@2:
	cmp	DWORD PTR _b_id$GSCopy$[ebp], eax
	jne	SHORT $LN393@convert_bo@2
	mov	eax, DWORD PTR _min_rank$90899[ebp]
	mov	ecx, DWORD PTR _con$90799[ebp]
	cmp	DWORD PTR [ecx+172], eax
	jg	SHORT $LN393@convert_bo@2

; 2730 :                 apply_method_num(inverse_id(e_id),meth1);

	mov	edx, DWORD PTR _meth1$[ebp]
	mov	eax, DWORD PTR _e_id$[ebp]
	push	edx
	xor	eax, 134217728				; 08000000H
	push	eax
	call	_apply_method_num
	mov	ebx, DWORD PTR _dymem
	add	esp, 8
$LN393@convert_bo@2:

; 2731 :             }
; 2732 :             fe = get_next_facet(fe);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN255@convert_bo@2
	mov	ecx, DWORD PTR _web+460
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR [edx+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN48@convert_bo@2
$LN255@convert_bo@2:
	mov	eax, DWORD PTR _web+460
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR [ecx+40]
$LN48@convert_bo@2:

; 2733 :           } while ( !equal_id(fe,first_fe) );

	cmp	edi, DWORD PTR _first_fe$90890[ebp]
	jne	$LL49@convert_bo@2
	mov	ebx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR tv2627[ebp]
$LN60@convert_bo@2:

; 2706 :     { FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [esi+edx]
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR _e_id$[ebp], edi
	test	edi, 268435456				; 10000000H
	jne	$LL61@convert_bo@2
$LN102@convert_bo@2:

; 2633 :      }
; 2634 :   }
; 2635 : 
; 2636 :   /* constraint content integrals */
; 2637 :   for ( j = 0 ; j < web.maxcon ; j++ )

	inc	ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, DWORD PTR _web+644
	jl	$LL103@convert_bo@2
$LN101@convert_bo@2:

; 2734 :         }
; 2735 :       }
; 2736 :     }
; 2737 :   }
; 2738 : 
; 2739 :   /* boundary content integrals */
; 2740 :   for ( j = 0 ; j < web.bdrymax ; j++ )

	xor	ebx, ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	DWORD PTR _web+768, ebx
	jle	$LN382@convert_bo@2
	npad	11
$LL406@convert_bo@2:

; 2741 :   { struct boundary *bdry = web.boundaries + j;

	mov	edi, ebx
	imul	edi, 136				; 00000088H
	add	edi, DWORD PTR _web+776

; 2742 :     vertex_id v_id;
; 2743 : 
; 2744 :     if ( !(bdry->attr & CON_CONTENT) ) continue;

	xor	ecx, ecx
	mov	eax, DWORD PTR [edi+32]
	and	eax, 128				; 00000080H
	or	eax, ecx
	mov	DWORD PTR _bdry$90925[ebp], edi
	je	$LN42@convert_bo@2

; 2745 :     sprintf(inst_name1,"body_%d_bdry_%s_meth",i+1,bdry->name);

	mov	ecx, DWORD PTR _i$[ebp]
	push	edi
	inc	ecx
	push	ecx
	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	OFFSET ??_C@_0BF@MHGGIEFG@body_?$CFd_bdry_?$CFs_meth?$AA@
	push	edx
	call	_sprintf

; 2746 :     meth1 = find_method_instance(inst_name1);

	lea	eax, DWORD PTR _inst_name1$[ebp]
	push	eax
	call	_find_method_instance
	mov	ecx, eax
	add	esp, 20					; 00000014H
	mov	DWORD PTR _meth1$[ebp], ecx

; 2747 :     if ( meth1 < 0 )

	test	ecx, ecx
	jns	SHORT $LN37@convert_bo@2

; 2748 :     { /* have to create */
; 2749 :       if ( web.representation ==  STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN38@convert_bo@2

; 2750 :       { meth1 = new_method_instance("vertex_scalar_integral",inst_name1);

	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BH@EHAKMPOM@vertex_scalar_integral?$AA@
	call	_new_method_instance
	mov	ecx, eax
	mov	DWORD PTR _meth1$[ebp], ecx

; 2751 :       }
; 2752 :       else

	jmp	SHORT $LN442@convert_bo@2
$LN38@convert_bo@2:

; 2753 :       { meth1 = new_method_instance("edge_vector_integral",inst_name1);

	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
	push	OFFSET ??_C@_0BF@EDOAEIAK@edge_vector_integral?$AA@
	call	_new_method_instance
	mov	ecx, eax
	mov	DWORD PTR _meth1$[ebp], eax
$LN442@convert_bo@2:
	add	esp, 8
$LN37@convert_bo@2:

; 2754 :       }
; 2755 :     }
; 2756 :     METH_INSTANCE(meth1)->flags |= DEFAULT_INSTANCE | BODY_INSTANCE;

	mov	eax, ecx
	cdq
	mov	esi, eax
	mov	eax, DWORD PTR _meth_inst_list
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	or	DWORD PTR [esi+eax+140], 20971520	; 01400000H

; 2757 :     METH_INSTANCE(meth1)->connum = j;

	mov	eax, DWORD PTR _meth_inst_list

; 2758 :     attach_method_num(gq,meth1);

	push	ecx
	mov	ecx, DWORD PTR _gq$[ebp]
	push	ecx
	mov	DWORD PTR [esi+eax+216], ebx
	call	_attach_method_num
	add	esp, 8

; 2759 :     if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN36@convert_bo@2

; 2760 :        METH_INSTANCE(meth1)->expr[0] = bdry->convect[0];

	mov	edx, DWORD PTR [edi+96]
	mov	eax, DWORD PTR _meth_inst_list
	mov	DWORD PTR [esi+eax+232], edx

; 2761 :     else

	jmp	SHORT $LN391@convert_bo@2
$LN36@convert_bo@2:

; 2762 :        for ( k = 0 ; k < SDIM ; k++ ) 

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN391@convert_bo@2
	add	esi, 232				; 000000e8H
	lea	eax, DWORD PTR [edi+96]
	npad	9
$LL407@convert_bo@2:

; 2763 :            METH_INSTANCE(meth1)->expr[k] = bdry->convect[k];

	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR _meth_inst_list
	mov	DWORD PTR [esi+edi], edx
	inc	ecx
	add	eax, 4
	add	esi, 4
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL407@convert_bo@2
$LN391@convert_bo@2:

; 2764 :      
; 2765 :      if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	$LN31@convert_bo@2

; 2766 :      { FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	DWORD PTR _v_id$90926[ebp], eax
	test	eax, 268435456				; 10000000H
	je	$LN42@convert_bo@2
	mov	ebx, DWORD PTR _web+124
	mov	esi, DWORD PTR _web+12
	mov	edi, DWORD PTR _V_BOUNDARY_ATTR
	npad	1
$LL408@convert_bo@2:
	mov	eax, DWORD PTR _v_id$90926[ebp]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+esi]
	mov	DWORD PTR tv2925[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN29@convert_bo@2

; 2767 :        if ( bdry == get_boundary(v_id) ) 

	test	edi, edi
	je	SHORT $LN164@convert_bo@2
	mov	edx, DWORD PTR _dymem
	mov	eax, edi
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN165@convert_bo@2
$LN164@convert_bo@2:
	xor	eax, eax
$LN165@convert_bo@2:
	cmp	DWORD PTR _bdry$90925[ebp], eax
	jne	$LN29@convert_bo@2

; 2768 :        { edge_id first_e = e_id = get_vertex_edge(v_id);

	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR _e_id$[ebp], ecx
	mov	DWORD PTR _first_e$90953[ebp], ecx

; 2769 :          if ( valid_id(e_id) )

	test	ecx, 268435456				; 10000000H
	je	$LN29@convert_bo@2
	mov	edx, DWORD PTR _web+328
	npad	12
$LL23@convert_bo@2:

; 2770 :          do
; 2771 :          { facetedge_id first_fe = fe = get_edge_fe(e_id);

	mov	esi, DWORD PTR _e_id$[ebp]
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv2627[ebp], eax
	mov	eax, DWORD PTR [eax+ebx]
	test	eax, eax
	jne	SHORT $LN259@convert_bo@2
	xor	edi, edi
	jmp	SHORT $LN260@convert_bo@2
$LN259@convert_bo@2:
	mov	ecx, DWORD PTR [eax+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN258@convert_bo@2
	xor	ecx, 134217728				; 08000000H
$LN258@convert_bo@2:
	mov	edi, ecx
$LN260@convert_bo@2:
	mov	DWORD PTR _first_fe$90960[ebp], edi

; 2772 :            if ( valid_id(fe) && !(get_eattr(e_id) & NONCONTENT) ) 

	test	edi, 268435456				; 10000000H
	je	$LN17@convert_bo@2
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN17@convert_bo@2
	npad	7
$LL19@convert_bo@2:

; 2773 :            do
; 2774 :            { f_id = get_fe_facet(fe);

	test	edi, 268435456				; 10000000H
	jne	SHORT $LN263@convert_bo@2
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN262@convert_bo@2
$LN263@convert_bo@2:
	mov	eax, DWORD PTR _web+460
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	esi, DWORD PTR [ecx+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN262@convert_bo@2
	xor	esi, 134217728				; 08000000H
$LN262@convert_bo@2:

; 2775 :              if ( equal_id(b_id,get_facet_body(f_id)) )

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN269@convert_bo@2
	xor	eax, eax
	jmp	SHORT $LN266@convert_bo@2
$LN269@convert_bo@2:
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN268@convert_bo@2
	xor	eax, eax
	jmp	SHORT $LN266@convert_bo@2
$LN268@convert_bo@2:
	mov	ecx, DWORD PTR _web+236
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx+784]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN267@convert_bo@2
	mov	eax, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN266@convert_bo@2
$LN267@convert_bo@2:
	mov	eax, DWORD PTR [eax+ecx]
$LN266@convert_bo@2:
	cmp	DWORD PTR _b_id$GSCopy$[ebp], eax
	jne	SHORT $LN397@convert_bo@2

; 2776 :                apply_method_num(v_id,meth1);

	mov	edx, DWORD PTR _meth1$[ebp]
	mov	eax, DWORD PTR _v_id$90926[ebp]
	push	edx
	push	eax
	call	_apply_method_num
	mov	edx, DWORD PTR _web+328
	add	esp, 8
$LN397@convert_bo@2:

; 2777 :              if ( equal_id(b_id,get_facet_body(inverse_id(f_id))) )

	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN275@convert_bo@2
	xor	eax, eax
	jmp	SHORT $LN272@convert_bo@2
$LN275@convert_bo@2:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN274@convert_bo@2
	xor	eax, eax
	jmp	SHORT $LN272@convert_bo@2
$LN274@convert_bo@2:
	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN273@convert_bo@2
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx+784]
	mov	eax, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN272@convert_bo@2
$LN273@convert_bo@2:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx+784]
	mov	eax, DWORD PTR [eax+ecx]
$LN272@convert_bo@2:
	cmp	DWORD PTR _b_id$GSCopy$[ebp], eax
	jne	SHORT $LN15@convert_bo@2

; 2778 :                apply_method_num(inverse_id(v_id),meth1);

	mov	edx, DWORD PTR _meth1$[ebp]
	mov	eax, DWORD PTR _v_id$90926[ebp]
	push	edx
	xor	eax, 134217728				; 08000000H
	push	eax
	call	_apply_method_num
	mov	edx, DWORD PTR _web+328
	add	esp, 8
$LN15@convert_bo@2:

; 2779 :              fe = get_next_facet(fe);

	mov	ecx, DWORD PTR _web+460
	test	edi, 134217728				; 08000000H
	je	SHORT $LN279@convert_bo@2
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR [eax+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN18@convert_bo@2
$LN279@convert_bo@2:
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR [eax+40]
$LN18@convert_bo@2:

; 2780 :            } while ( !equal_id(fe,first_fe) );

	cmp	edi, DWORD PTR _first_fe$90960[ebp]
	jne	$LL19@convert_bo@2
	mov	ebx, DWORD PTR _web+124
$LN17@convert_bo@2:

; 2781 :            e_id = get_next_tail_edge(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	eax, DWORD PTR tv2627[ebp]
	mov	eax, DWORD PTR [eax+ebx]
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4+32]
	mov	DWORD PTR _e_id$[ebp], eax

; 2782 :          } while ( !equal_id(first_e,e_id));

	cmp	DWORD PTR _first_e$90953[ebp], eax
	jne	$LL23@convert_bo@2
	mov	esi, DWORD PTR _web+12
	mov	edi, DWORD PTR _V_BOUNDARY_ATTR
$LN29@convert_bo@2:

; 2766 :      { FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR tv2925[ebp]
	mov	edx, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _v_id$90926[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL408@convert_bo@2

; 2783 :        }
; 2784 :      }
; 2785 :      else  /* SOAPFILM */

	jmp	$LN443@convert_bo@2
$LN31@convert_bo@2:

; 2786 :      { FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+160
	mov	DWORD PTR _e_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	je	$LN42@convert_bo@2
	mov	esi, DWORD PTR _web+124
	mov	edi, DWORD PTR _E_BOUNDARY_ATTR
	npad	2
$LL411@convert_bo@2:
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	ecx, DWORD PTR [ebx+esi]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv2627[ebp], ebx
	je	$LN12@convert_bo@2

; 2787 :        if ( bdry == get_edge_boundary(e_id)  ) 

	test	edi, edi
	je	SHORT $LN166@convert_bo@2
	mov	edx, DWORD PTR _dymem
	mov	eax, edi
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN167@convert_bo@2
$LN166@convert_bo@2:
	xor	eax, eax
$LN167@convert_bo@2:
	cmp	DWORD PTR _bdry$90925[ebp], eax
	jne	$LN4@convert_bo@2

; 2788 :        { facetedge_id first_fe = fe = get_edge_fe(e_id);

	test	ecx, ecx
	jne	SHORT $LN285@convert_bo@2
	xor	ebx, ebx
	jmp	SHORT $LN286@convert_bo@2
$LN285@convert_bo@2:
	test	DWORD PTR _e_id$[ebp], 134217728	; 08000000H
	mov	ecx, DWORD PTR [ecx+28]
	je	SHORT $LN284@convert_bo@2
	xor	ecx, 134217728				; 08000000H
$LN284@convert_bo@2:
	mov	ebx, ecx
$LN286@convert_bo@2:
	mov	DWORD PTR _first_fe$90986[ebp], ebx

; 2789 :          if ( valid_id(fe) )

	test	ebx, 268435456				; 10000000H
	je	$LN4@convert_bo@2
$LL6@convert_bo@2:

; 2790 :            do
; 2791 :            { f_id = get_fe_facet(fe);

	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN289@convert_bo@2
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN288@convert_bo@2
$LN289@convert_bo@2:
	mov	edx, DWORD PTR _web+460
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	esi, DWORD PTR [eax+24]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN288@convert_bo@2
	xor	esi, 134217728				; 08000000H
$LN288@convert_bo@2:

; 2792 :              if ( !(get_fattr(f_id) & NONCONTENT) )

	mov	edi, DWORD PTR _web+236
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 536870912				; 20000000H
	xor	edx, edx
	or	eax, edx
	jne	$LN385@convert_bo@2

; 2793 :              { if ( equal_id(b_id,get_facet_body(f_id)) )

	cmp	DWORD PTR _web+400, edx
	jne	SHORT $LN295@convert_bo@2
	xor	ecx, ecx
	jmp	SHORT $LN292@convert_bo@2
$LN295@convert_bo@2:
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN294@convert_bo@2
	xor	ecx, ecx
	jmp	SHORT $LN292@convert_bo@2
$LN294@convert_bo@2:
	test	esi, 134217728				; 08000000H
	je	SHORT $LN293@convert_bo@2
	mov	edx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+784]
	mov	ecx, DWORD PTR [edx+ecx+4]
	jmp	SHORT $LN292@convert_bo@2
$LN293@convert_bo@2:
	mov	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+784]
	mov	ecx, DWORD PTR [ecx+eax]
$LN292@convert_bo@2:
	cmp	DWORD PTR _b_id$GSCopy$[ebp], ecx
	jne	SHORT $LN384@convert_bo@2

; 2794 :                  apply_method_num(e_id,meth1);

	mov	ecx, DWORD PTR _meth1$[ebp]
	mov	edx, DWORD PTR _e_id$[ebp]
	push	ecx
	push	edx
	call	_apply_method_num
	mov	edi, DWORD PTR _web+236
	add	esp, 8
$LN384@convert_bo@2:

; 2795 :                if ( equal_id(b_id,get_facet_body(inverse_id(f_id))) )

	mov	eax, esi
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN301@convert_bo@2
	xor	eax, eax
	jmp	SHORT $LN298@convert_bo@2
$LN301@convert_bo@2:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN300@convert_bo@2
	xor	eax, eax
	jmp	SHORT $LN298@convert_bo@2
$LN300@convert_bo@2:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN299@convert_bo@2
	mov	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+784]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN298@convert_bo@2
$LN299@convert_bo@2:
	mov	ecx, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]
$LN298@convert_bo@2:
	cmp	DWORD PTR _b_id$GSCopy$[ebp], eax
	jne	SHORT $LN385@convert_bo@2

; 2796 :                  apply_method_num(inverse_id(e_id),meth1);

	mov	ecx, DWORD PTR _meth1$[ebp]
	mov	edx, DWORD PTR _e_id$[ebp]
	push	ecx
	xor	edx, 134217728				; 08000000H
	push	edx
	call	_apply_method_num
	add	esp, 8
$LN385@convert_bo@2:

; 2797 :              }
; 2798 :              fe = get_next_facet(fe);

	test	ebx, 134217728				; 08000000H
	je	SHORT $LN305@convert_bo@2
	mov	eax, DWORD PTR _web+460
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	ebx, DWORD PTR [ecx+36]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN5@convert_bo@2
$LN305@convert_bo@2:
	mov	edx, DWORD PTR _web+460
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	ebx, DWORD PTR [eax+40]
$LN5@convert_bo@2:

; 2799 :            } while ( !equal_id(fe,first_fe) );

	cmp	ebx, DWORD PTR _first_fe$90986[ebp]
	jne	$LL6@convert_bo@2
	mov	esi, DWORD PTR _web+124
	mov	edi, DWORD PTR _E_BOUNDARY_ATTR
$LN4@convert_bo@2:
	mov	ebx, DWORD PTR tv2627[ebp]
$LN12@convert_bo@2:

; 2786 :      { FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR [ebx+esi]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _e_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	$LL411@convert_bo@2
$LN443@convert_bo@2:
	mov	ebx, DWORD PTR _j$[ebp]
$LN42@convert_bo@2:

; 2734 :         }
; 2735 :       }
; 2736 :     }
; 2737 :   }
; 2738 : 
; 2739 :   /* boundary content integrals */
; 2740 :   for ( j = 0 ; j < web.bdrymax ; j++ )

	inc	ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, DWORD PTR _web+768
	jl	$LL406@convert_bo@2
$LN382@convert_bo@2:

; 2800 :        }
; 2801 :      }
; 2802 :   }
; 2803 :   create_pressure_quant(b_id);

	mov	edx, DWORD PTR _b_id$GSCopy$[ebp]
	push	edx
	call	_create_pressure_quant

; 2804 : } /* end convert_body_to_quantity() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 4
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_convert_body_to_quantity ENDP
_TEXT	ENDS
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	_b_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_convert_new_body_to_quantity
EXTRN	_dup_method_instance:PROC
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\lexinit2.c
CONST	ENDS
;	COMDAT _convert_new_body_to_quantity
_TEXT	SEGMENT
tv651 = -220						; size = 8
tv740 = -216						; size = 4
_old_tok$91038 = -216					; size = 4
_b_id$GSCopy$ = -212					; size = 4
tv701 = -208						; size = 4
_old_tok$91060 = -208					; size = 4
tv645 = -204						; size = 4
_old_datafile_flag$91058 = -200				; size = 4
_old_cmdptr$91037 = -200				; size = 4
tv720 = -196						; size = 4
_old_cmdptr$91059 = -196				; size = 4
_gq$ = -192						; size = 4
_meth1$ = -188						; size = 4
_formula$ = -184					; size = 100
_qname$ = -84						; size = 40
_inst_name1$ = -44					; size = 40
__$ArrayPad$ = -4					; size = 4
_b_id$ = 8						; size = 4
_convert_new_body_to_quantity PROC			; COMDAT

; 2817 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _b_id$[ebp]

; 2818 :   int gq;
; 2819 :   int meth1;
; 2820 :   char inst_name1[40];
; 2821 :   char qname[40];
; 2822 :   int i,j;
; 2823 :   char formula[100];
; 2824 :   struct gen_quant *g=NULL; 
; 2825 : 
; 2826 :   i = ordinal(b_id) + 1;

	mov	ebx, edi
	shr	ebx, 28					; 0000001cH
	and	ebx, 1

; 2934 :           { int old_datafile_flag;
; 2935 :             char *old_cmdptr = cmdptr;

	mov	DWORD PTR _b_id$GSCopy$[ebp], edi
	je	SHORT $LN35@convert_ne

; 2818 :   int gq;
; 2819 :   int meth1;
; 2820 :   char inst_name1[40];
; 2821 :   char qname[40];
; 2822 :   int i,j;
; 2823 :   char formula[100];
; 2824 :   struct gen_quant *g=NULL; 
; 2825 : 
; 2826 :   i = ordinal(b_id) + 1;

	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	jmp	SHORT $LN36@convert_ne
$LN35@convert_ne:
	or	esi, -1
$LN36@convert_ne:
	inc	esi

; 2827 :   sprintf(qname,"body_%d_vol",i);

	push	esi
	lea	eax, DWORD PTR _qname$[ebp]
	push	OFFSET ??_C@_0M@PLFBMNIM@body_?$CFd_vol?$AA@
	push	eax
	call	_sprintf

; 2828 :   sprintf(inst_name1,"body_%d_vol_meth",i);

	push	esi
	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	OFFSET ??_C@_0BB@EFJDIHF@body_?$CFd_vol_meth?$AA@
	push	ecx
	call	_sprintf

; 2829 :   if ( get_battr(b_id) & FIXEDVOL )

	mov	edx, DWORD PTR _web+348
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+edx]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv651[ebp+4], eax
	mov	eax, ecx
	and	eax, 32					; 00000020H
	xor	edx, edx
	add	esp, 24					; 00000018H
	or	eax, edx
	mov	DWORD PTR tv645[ebp], edi
	je	SHORT $LN32@convert_ne

; 2830 :   { 
; 2831 :     gq = find_quantity(qname);

	lea	ecx, DWORD PTR _qname$[ebp]
	push	ecx
	call	_find_quantity
	add	esp, 4
	mov	DWORD PTR _gq$[ebp], eax

; 2832 :     if ( gq < 0 ) gq = new_quantity(qname,Q_FIXED);

	test	eax, eax
	jns	SHORT $LN31@convert_ne
	lea	edx, DWORD PTR _qname$[ebp]
	push	2
	push	edx
	call	_new_quantity
	add	esp, 8
	mov	DWORD PTR _gq$[ebp], eax
$LN31@convert_ne:

; 2833 :     g = GEN_QUANT(gq);

	mov	ecx, DWORD PTR _gq$[ebp]
	imul	ecx, 368				; 00000170H
	add	ecx, DWORD PTR _gen_quant_list

; 2834 :     g->target = get_body_fixvol(b_id);

	test	ebx, ebx
	je	SHORT $LN39@convert_ne
	mov	eax, DWORD PTR _web+348
	mov	edx, DWORD PTR [edi+eax]
	fld	QWORD PTR [edx+32]
	fldz
	fxch	ST(1)
	fstp	QWORD PTR [ecx+144]
	jmp	$LN65@convert_ne
$LN39@convert_ne:
	fldz
	fld	ST(0)
	fxch	ST(1)
	fxch	ST(1)
	fstp	QWORD PTR [ecx+144]
	jmp	$LN65@convert_ne
$LN32@convert_ne:

; 2835 :   }
; 2836 :   else if ( get_battr(b_id) & PRESSURE )

	xor	eax, eax
	and	ecx, 2048				; 00000800H
	or	ecx, eax

; 2837 :   { REAL p;
; 2838 :     gq = find_quantity(qname);

	lea	eax, DWORD PTR _qname$[ebp]
	push	eax
	je	$LN29@convert_ne
	call	_find_quantity
	add	esp, 4
	mov	DWORD PTR _gq$[ebp], eax

; 2839 :     if ( gq < 0 ) gq = new_quantity(qname,Q_ENERGY);

	test	eax, eax
	jns	SHORT $LN71@convert_ne
	lea	ecx, DWORD PTR _qname$[ebp]
	push	1
	push	ecx
	call	_new_quantity
	add	esp, 8
	mov	DWORD PTR _gq$[ebp], eax
$LN71@convert_ne:

; 2840 :     g = GEN_QUANT(gq);

	mov	ecx, eax
	imul	ecx, 368				; 00000170H
	add	ecx, DWORD PTR _gen_quant_list

; 2841 :     p = get_body_pressure(b_id);

	test	ebx, ebx
	je	SHORT $LN43@convert_ne
	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [edi+edx]
	fld	QWORD PTR [eax+312]
	fldz
	jmp	SHORT $LN44@convert_ne
$LN43@convert_ne:
	fldz
	fld	ST(0)
	fxch	ST(1)
$LN44@convert_ne:

; 2842 :     g->modulus = -p;

	fld	ST(1)
	fchs
	fstp	QWORD PTR [ecx+176]

; 2843 :     if ( p == 0.0 )

	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN65@convert_ne

; 2844 :     { g->flags &= ~Q_ENERGY;

	mov	edx, DWORD PTR [ecx+136]

; 2845 :       g->flags |= Q_INFO; 
; 2846 :         /* to force volume calc even for zero pressure */
; 2847 :       g->modulus = 1.0;

	fld1
	and	edx, -2					; fffffffeH
	fstp	QWORD PTR [ecx+176]
	or	edx, 4
	mov	DWORD PTR [ecx+136], edx

; 2848 :     }

	jmp	SHORT $LN65@convert_ne
$LN29@convert_ne:

; 2849 :   }
; 2850 :   else { gq = find_quantity(qname);

	call	_find_quantity
	add	esp, 4
	mov	DWORD PTR _gq$[ebp], eax

; 2851 :          if ( gq < 0 ) 

	test	eax, eax
	jns	SHORT $LN25@convert_ne

; 2852 :             gq = new_quantity(qname,Q_INFO);

	lea	ecx, DWORD PTR _qname$[ebp]
	push	4
	push	ecx
	call	_new_quantity
	add	esp, 8
	mov	DWORD PTR _gq$[ebp], eax
$LN25@convert_ne:

; 2853 :          g = GEN_QUANT(gq);

	fldz
	mov	ecx, eax
	imul	ecx, 368				; 00000170H
	add	ecx, DWORD PTR _gen_quant_list
$LN65@convert_ne:

; 2854 :        }
; 2855 :   g->flags |= DEFAULT_QUANTITY;

	or	DWORD PTR [ecx+136], 8192		; 00002000H

; 2856 :   g->b_id = b_id;

	mov	edx, DWORD PTR _b_id$GSCopy$[ebp]
	mov	DWORD PTR [ecx+216], edx

; 2857 :   set_body_volquant(b_id,gq);

	mov	eax, DWORD PTR _web+348
	mov	edx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR _gq$[ebp]
	mov	DWORD PTR [edx+404], eax

; 2858 :   g->volconst = get_body_volconst(b_id);

	test	ebx, ebx
	je	SHORT $LN47@convert_ne
	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [edi+edx]
	fld	QWORD PTR [eax+328]
	jmp	SHORT $LN48@convert_ne
$LN47@convert_ne:
	fld	ST(0)
$LN48@convert_ne:
	fstp	QWORD PTR [ecx+208]

; 2859 :   g->pressure = get_body_pressure(b_id);

	test	ebx, ebx
	je	SHORT $LN51@convert_ne
	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [edi+edx]
	fld	QWORD PTR [eax+312]
	jmp	SHORT $LN52@convert_ne
$LN51@convert_ne:
	fld	ST(0)
$LN52@convert_ne:
	fstp	QWORD PTR [ecx+192]

; 2860 :   g->value = get_body_volume(b_id);

	test	ebx, ebx
	je	SHORT $LN55@convert_ne
	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [edi+edx]
	fld	QWORD PTR [eax+40]
	jmp	SHORT $LN56@convert_ne
$LN55@convert_ne:
	fld	ST(0)
$LN56@convert_ne:
	fstp	QWORD PTR [ecx+152]

; 2861 :   g->oldvalue = get_body_volume(b_id);

	test	ebx, ebx
	je	SHORT $LN60@convert_ne
	mov	edx, DWORD PTR _web+348
	fstp	ST(0)
	mov	eax, DWORD PTR [edi+edx]
	fld	QWORD PTR [eax+40]
$LN60@convert_ne:
	fstp	QWORD PTR [ecx+160]

; 2862 : 
; 2863 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	$LN24@convert_ne

; 2864 :   {
; 2865 :      meth1 = find_method_instance(inst_name1);

	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	ecx
	call	_find_method_instance
	mov	esi, eax
	add	esp, 4

; 2866 :      if ( meth1 < 0 )

	test	esi, esi
	jns	$LN11@convert_ne

; 2867 :      { /* have to create */
; 2868 :         if ( area_method_name[0] )

	cmp	BYTE PTR _area_method_name, 0
	je	SHORT $LN22@convert_ne

; 2869 :         { meth1 = dup_method_instance(area_method_name,inst_name1);  /* user instance? */

	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
	push	OFFSET _area_method_name
	call	_dup_method_instance
	add	esp, 8
	mov	DWORD PTR _meth1$[ebp], eax

; 2870 :           if ( meth1 < 0 )  /* try pre-defined method */

	test	eax, eax
	jns	$LN69@convert_ne

; 2871 :           { meth1 = new_method_instance(area_method_name,inst_name1);

	lea	eax, DWORD PTR _inst_name1$[ebp]
	push	eax
	push	OFFSET _area_method_name
	call	_new_method_instance

; 2872 :             METH_INSTANCE(meth1)->flags |= DEFAULT_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	DWORD PTR _meth1$[ebp], eax
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	lea	eax, DWORD PTR [eax+ecx+140]
	add	esp, 8
	or	DWORD PTR [eax], 4194304		; 00400000H

; 2873 :           }

	jmp	$LN69@convert_ne
$LN22@convert_ne:

; 2874 :         }
; 2875 :         else if ( web.symmetric_content )

	cmp	DWORD PTR _web+808, 0
	je	$LN19@convert_ne

; 2876 :         { 
; 2877 :           meth1 = new_method_instance("edge_vector_integral",inst_name1);

	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
	push	OFFSET ??_C@_0BF@EDOAEIAK@edge_vector_integral?$AA@
	call	_new_method_instance
	mov	DWORD PTR _meth1$[ebp], eax

; 2878 :           METH_INSTANCE(meth1)->flags |= DEFAULT_INSTANCE;

	cdq
	mov	esi, eax
	mov	eax, DWORD PTR _meth_inst_list
	xor	esi, edx
	sub	esi, edx
	mov	ebx, esi
	imul	ebx, 2928				; 00000b70H
	or	DWORD PTR [ebx+eax+140], 4194304	; 00400000H

; 2879 :           METH_INSTANCE(meth1)->expr[0] = 
; 2880 :               (struct expnode *)mycalloc(SDIM,sizeof(struct expnode));

	mov	eax, DWORD PTR _web+616
	push	2880					; 00000b40H
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	104					; 00000068H
	push	eax
	mov	DWORD PTR tv701[ebp], ebx
	call	_kb_calloc
	mov	ecx, DWORD PTR _meth_inst_list

; 2881 :           for ( j = 0 ; j < SDIM ; j++ )

	xor	edi, edi
	add	esp, 24					; 00000018H
	mov	DWORD PTR [ebx+ecx+232], eax
	cmp	DWORD PTR _web+616, edi
	jle	$LN70@convert_ne
	mov	eax, DWORD PTR _cmdptr
	imul	esi, 732				; 000002dcH
	mov	ecx, DWORD PTR _tok

; 2959 :   }
; 2960 :   create_pressure_quant(b_id);

	add	esi, 58					; 0000003aH
	mov	DWORD PTR tv720[ebp], esi
	jmp	SHORT $LN18@convert_ne
	npad	11
$LL68@convert_ne:

; 2881 :           for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR tv701[ebp]
$LN18@convert_ne:

; 2882 :           { int old_datafile_flag;
; 2883 :             char *old_cmdptr = cmdptr;

	mov	DWORD PTR _old_cmdptr$91037[ebp], eax

; 2884 :             int old_tok = tok;

	mov	DWORD PTR _old_tok$91038[ebp], ecx

; 2885 :             if ( j==0 )sprintf(formula,"-y/2");

	test	edi, edi
	jne	SHORT $LN15@convert_ne
	push	OFFSET ??_C@_04MINKFJON@?9y?12?$AA@
	lea	edx, DWORD PTR _formula$[ebp]
	push	edx
	jmp	SHORT $LN95@convert_ne
$LN15@convert_ne:

; 2886 :             else if ( j==1 )sprintf(formula,"x/2");

	cmp	edi, 1
	jne	SHORT $LN13@convert_ne
	push	OFFSET ??_C@_03KOFBPNDM@x?12?$AA@
	lea	eax, DWORD PTR _formula$[ebp]
	push	eax
	jmp	SHORT $LN95@convert_ne
$LN13@convert_ne:

; 2887 :             else sprintf(formula,"0");

	push	OFFSET ??_C@_01GBGANLPD@0?$AA@
	lea	ecx, DWORD PTR _formula$[ebp]
	push	ecx
$LN95@convert_ne:
	call	_sprintf

; 2888 :             cmdptr = formula;
; 2889 :             METH_INSTANCE(meth1)->expr[j] = METH_INSTANCE(meth1)->expr[0] + j;

	mov	esi, DWORD PTR tv720[ebp]
	mov	eax, DWORD PTR _meth_inst_list
	mov	ecx, edi
	imul	ecx, 104				; 00000068H
	lea	edx, DWORD PTR _formula$[ebp]
	mov	DWORD PTR _cmdptr, edx
	add	ecx, DWORD PTR [ebx+eax+232]
	add	esi, edi
	add	esi, esi
	add	esi, esi
	mov	DWORD PTR [esi+eax], ecx

; 2890 :             old_datafile_flag = datafile_flag;

	mov	ebx, DWORD PTR _datafile_flag

; 2891 :             datafile_flag = 1;
; 2892 :             exparse(SDIM,METH_INSTANCE(meth1)->expr[j],USERCOPY); line_no--;

	mov	edx, DWORD PTR _meth_inst_list
	mov	ecx, DWORD PTR _web+616
	add	esp, 8
	mov	DWORD PTR _datafile_flag, 1
	mov	eax, DWORD PTR [esi+edx]
	push	1
	push	eax
	push	ecx
	call	_exparse

; 2893 :             sprintf(METH_INSTANCE(meth1)->expr[j]->name,
; 2894 :                 "symmetric content component %d",j+1);

	mov	edx, DWORD PTR _meth_inst_list
	dec	DWORD PTR _line_no
	mov	eax, DWORD PTR [esi+edx]
	inc	edi
	push	edi
	add	eax, 20					; 00000014H
	push	OFFSET ??_C@_0BP@PNGOPOBC@symmetric?5content?5component?5?$CFd?$AA@
	push	eax
	call	_sprintf

; 2895 :             datafile_flag = old_datafile_flag;
; 2896 :             cmdptr = old_cmdptr;

	mov	eax, DWORD PTR _old_cmdptr$91037[ebp]

; 2897 :             tok = old_tok;

	mov	ecx, DWORD PTR _old_tok$91038[ebp]
	add	esp, 24					; 00000018H
	mov	DWORD PTR _datafile_flag, ebx
	mov	DWORD PTR _cmdptr, eax
	mov	DWORD PTR _tok, ecx
	cmp	edi, DWORD PTR _web+616
	jl	$LL68@convert_ne
$LN70@convert_ne:

; 2904 :           METH_INSTANCE(meth1)->flags |= DEFAULT_INSTANCE;

	mov	edi, DWORD PTR tv645[ebp]
$LN69@convert_ne:

; 2873 :           }

	mov	esi, DWORD PTR _meth1$[ebp]
$LN11@convert_ne:

; 2905 :         }
; 2906 : 
; 2907 :      }
; 2908 :              
; 2909 :      METH_INSTANCE(meth1)->flags |= BODY_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list

; 2910 :      METH_INSTANCE(meth1)->modulus = 1.0;

	fld1
	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx

; 2911 :      attach_method_num(gq,meth1);

	mov	edx, DWORD PTR _gq$[ebp]
	imul	eax, 2928				; 00000b70H
	or	DWORD PTR [eax+ecx+140], 16777216	; 01000000H
	mov	ecx, DWORD PTR _meth_inst_list
	push	esi
	push	edx
	fstp	QWORD PTR [eax+ecx+304]
	call	_attach_method_num

; 2912 :      set_body_volmeth(b_id,meth1);

	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [edi+eax]
	add	esp, 8
	mov	DWORD PTR [ecx+412], esi

; 2913 :   }
; 2914 :   else  /* SOAPFILM */

	jmp	$LN10@convert_ne
$LN19@convert_ne:

; 2898 :   
; 2899 :           }
; 2900 :         }
; 2901 :         else
; 2902 :         {
; 2903 :           meth1 = new_method_instance("edge_area",inst_name1);

	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	ecx
	push	OFFSET ??_C@_09IDNCJNBA@edge_area?$AA@
	call	_new_method_instance
	mov	DWORD PTR _meth1$[ebp], eax

; 2904 :           METH_INSTANCE(meth1)->flags |= DEFAULT_INSTANCE;

	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	lea	eax, DWORD PTR [eax+edx+140]
	add	esp, 8
	or	DWORD PTR [eax], 4194304		; 00400000H
	jmp	$LN69@convert_ne
$LN24@convert_ne:

; 2915 :   {
; 2916 :      meth1 = find_method_instance(inst_name1);

	lea	edx, DWORD PTR _inst_name1$[ebp]
	push	edx
	call	_find_method_instance
	add	esp, 4

; 2917 :      if ( meth1 < 0 )

	test	eax, eax
	jns	$LN9@convert_ne

; 2918 :      { /* have to create */
; 2919 :         if ( volume_method_name[0] )

	cmp	BYTE PTR _volume_method_name, 0

; 2920 :         { meth1 = dup_method_instance(volume_method_name,inst_name1); /* user instance? */

	lea	eax, DWORD PTR _inst_name1$[ebp]
	push	eax
	je	SHORT $LN8@convert_ne
	push	OFFSET _volume_method_name
	call	_dup_method_instance
	add	esp, 8
	mov	DWORD PTR _meth1$[ebp], eax

; 2921 :           if ( meth1 < 0 )  /* try pre-defined method */

	test	eax, eax
	jns	$LN66@convert_ne

; 2922 :           { meth1 = new_method_instance(volume_method_name,inst_name1);

	lea	ecx, DWORD PTR _inst_name1$[ebp]
	push	ecx
	push	OFFSET _volume_method_name
	call	_new_method_instance
	mov	DWORD PTR _meth1$[ebp], eax

; 2923 :             METH_INSTANCE(meth1)->flags |= DEFAULT_INSTANCE;

	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	lea	eax, DWORD PTR [eax+edx+140]

; 2924 :           }

	jmp	$LN96@convert_ne
$LN8@convert_ne:

; 2925 :         }
; 2926 :         else if ( web.symmetric_content )

	cmp	DWORD PTR _web+808, 0
	je	$LN5@convert_ne

; 2927 :         { struct method_instance *mi;
; 2928 :           meth1 = new_method_instance("facet_vector_integral",inst_name1);

	push	OFFSET ??_C@_0BG@NMBFJJMF@facet_vector_integral?$AA@
	call	_new_method_instance
	mov	DWORD PTR _meth1$[ebp], eax

; 2929 :           mi = METH_INSTANCE(meth1);

	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	add	eax, DWORD PTR _meth_inst_list

; 2930 :           mi->flags |= DEFAULT_INSTANCE;
; 2931 :           mi->expr[0] = 
; 2932 :             (struct expnode *)mycalloc(SDIM,sizeof(struct expnode));

	push	2932					; 00000b74H
	or	DWORD PTR [eax+140], 4194304		; 00400000H
	mov	ecx, DWORD PTR _web+616
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	lea	esi, DWORD PTR [eax+232]
	push	104					; 00000068H
	push	ecx
	mov	DWORD PTR tv740[ebp], esi
	call	_kb_calloc
	mov	DWORD PTR [esi], eax

; 2933 :           for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 24					; 00000018H
	test	eax, eax
	jle	$LN66@convert_ne

; 2927 :         { struct method_instance *mi;
; 2928 :           meth1 = new_method_instance("facet_vector_integral",inst_name1);

	mov	ecx, DWORD PTR _cmdptr
	mov	edi, 1
	xor	ebx, ebx
$LL67@convert_ne:

; 2936 :             int old_tok = tok;

	mov	edx, DWORD PTR _tok

; 2937 :             sprintf(formula,"x%d/%d",j+1,SDIM);

	push	eax
	push	edi
	lea	eax, DWORD PTR _formula$[ebp]
	push	OFFSET ??_C@_06EBIBGOAF@x?$CFd?1?$CFd?$AA@
	push	eax
	mov	DWORD PTR _old_cmdptr$91059[ebp], ecx
	mov	DWORD PTR _old_tok$91060[ebp], edx
	call	_sprintf

; 2938 :             cmdptr = formula;
; 2939 :             mi->expr[j] = mi->expr[0] + j;

	mov	edx, DWORD PTR tv740[ebp]
	lea	ecx, DWORD PTR _formula$[ebp]
	mov	DWORD PTR _cmdptr, ecx
	mov	eax, DWORD PTR [edx]
	add	eax, ebx
	mov	DWORD PTR [esi], eax

; 2940 :             old_datafile_flag = datafile_flag;

	mov	ecx, DWORD PTR _datafile_flag

; 2941 :             datafile_flag = 1;
; 2942 :             exparse(SDIM,mi->expr[j],USERCOPY); line_no--;

	mov	eax, DWORD PTR _web+616
	mov	DWORD PTR _datafile_flag, 1
	mov	edx, DWORD PTR [esi]
	push	1
	push	edx
	push	eax
	mov	DWORD PTR _old_datafile_flag$91058[ebp], ecx
	call	_exparse
	dec	DWORD PTR _line_no

; 2943 :             sprintf(mi->expr[j]->name,"symmetric content component %d",j+1);

	mov	ecx, DWORD PTR [esi]
	push	edi
	add	ecx, 20					; 00000014H
	push	OFFSET ??_C@_0BP@PNGOPOBC@symmetric?5content?5component?5?$CFd?$AA@
	push	ecx
	call	_sprintf

; 2944 :             datafile_flag = old_datafile_flag;

	mov	edx, DWORD PTR _old_datafile_flag$91058[ebp]

; 2945 :             cmdptr = old_cmdptr;
; 2946 :             tok = old_tok;

	mov	eax, DWORD PTR _old_tok$91060[ebp]
	mov	ecx, DWORD PTR _old_cmdptr$91059[ebp]
	inc	edi
	mov	DWORD PTR _datafile_flag, edx
	mov	DWORD PTR _tok, eax
	mov	eax, DWORD PTR _web+616
	lea	edx, DWORD PTR [edi-1]
	add	esp, 40					; 00000028H
	add	esi, 4
	add	ebx, 104				; 00000068H
	mov	DWORD PTR _cmdptr, ecx
	cmp	edx, eax
	jl	$LL67@convert_ne

; 2947 :           }
; 2948 :         }
; 2949 :         else

	mov	edi, DWORD PTR tv645[ebp]
	jmp	SHORT $LN66@convert_ne
$LN5@convert_ne:

; 2950 :         {
; 2951 :           meth1 = new_method_instance("facet_volume",inst_name1);

	push	OFFSET ??_C@_0N@BMGHIFMK@facet_volume?$AA@
	call	_new_method_instance

; 2952 :           METH_INSTANCE(meth1)->flags |= DEFAULT_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	DWORD PTR _meth1$[ebp], eax
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	lea	eax, DWORD PTR [eax+ecx+140]
$LN96@convert_ne:
	add	esp, 8
	or	DWORD PTR [eax], 4194304		; 00400000H
$LN66@convert_ne:

; 2953 :         }
; 2954 :         METH_INSTANCE(meth1)->flags |= BODY_INSTANCE;

	mov	esi, DWORD PTR _meth1$[ebp]

; 2955 :         METH_INSTANCE(meth1)->modulus = 1.0;

	fld1
	mov	ecx, DWORD PTR _meth_inst_list
	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	or	DWORD PTR [eax+ecx+140], 16777216	; 01000000H
	mov	edx, DWORD PTR _meth_inst_list

; 2956 :         attach_method_num(gq,meth1);    

	push	esi
	fstp	QWORD PTR [eax+edx+304]
	mov	eax, DWORD PTR _gq$[ebp]
	push	eax
	call	_attach_method_num
	add	esp, 8
	mov	eax, esi
$LN9@convert_ne:

; 2957 :      }
; 2958 :      set_body_volmeth(b_id,meth1);

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [edi+ecx]
	mov	DWORD PTR [edx+412], eax
$LN10@convert_ne:

; 2959 :   }
; 2960 :   create_pressure_quant(b_id);

	mov	eax, DWORD PTR _b_id$GSCopy$[ebp]
	push	eax
	call	_create_pressure_quant

; 2961 : } /* end convert_new_body_to_quantity() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 4
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_convert_new_body_to_quantity ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@JNLPELKF@Need?5method?5name?4?6?$AA@	; `string'
PUBLIC	??_C@_0BJ@IENIACIB@Missing?5METHOD?5keyword?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@HEOJGHCD@Need?5instance?5name?4?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_read_method_instance
;	COMDAT ??_C@_0BD@JNLPELKF@Need?5method?5name?4?6?$AA@
CONST	SEGMENT
??_C@_0BD@JNLPELKF@Need?5method?5name?4?6?$AA@ DB 'Need method name.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IENIACIB@Missing?5METHOD?5keyword?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@IENIACIB@Missing?5METHOD?5keyword?4?6?$AA@ DB 'Missing METHOD k'
	DB	'eyword.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HEOJGHCD@Need?5instance?5name?4?6?$AA@
CONST	SEGMENT
??_C@_0BF@HEOJGHCD@Need?5instance?5name?4?6?$AA@ DB 'Need instance name.', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _read_method_instance
_TEXT	SEGMENT
_mname$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_read_method_instance PROC				; COMDAT

; 904  : { char mname[40];

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 905  :   int mi = -1;
; 906  : 
; 907  :   tok = yylex(); /* name */

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 908  :   if ( tok != NEWIDENT_TOK && tok != METHOD_NAME_TOK )

	cmp	eax, 268				; 0000010cH
	je	SHORT $LN6@read_metho
	cmp	eax, 414				; 0000019eH
	je	SHORT $LN6@read_metho

; 909  :   { kb_error(1708,"Need instance name.\n",DATAFILE_ERROR); return -1; }

	push	6
	push	OFFSET ??_C@_0BF@HEOJGHCD@Need?5instance?5name?4?6?$AA@
	push	1708					; 000006acH
	call	_kb_error
	add	esp, 12					; 0000000cH
	or	eax, -1

; 938  :   METH_INSTANCE(mi)->flags &= ~Q_FORWARD_DEF;
; 939  :   
; 940  :   return mi;
; 941  : } // end read_method_instance()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@read_metho:

; 910  : 
; 911  :   if ( tok == METHOD_NAME_TOK )
; 912  :   { mi = yylval.i;  /* redefinition or was forward */
; 913  :   }
; 914  :  
; 915  :   strncpy(mname,yytext,sizeof(mname));

	mov	eax, DWORD PTR _yytext
	push	40					; 00000028H
	push	eax
	lea	ecx, DWORD PTR _mname$[ebp]
	push	ecx
	call	_strncpy

; 916  :   tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tok, eax

; 917  :   if ( tok == ';' ) /* forward definition */

	cmp	eax, 59					; 0000003bH
	jne	SHORT $LN4@read_metho

; 918  :   { verb_flag = 0;
; 919  :     tok = yylex();

	push	0
	mov	DWORD PTR _verb_flag, 0
	call	_kb_yylex

; 920  :     mi = new_method_instance(NULL,mname);

	lea	edx, DWORD PTR _mname$[ebp]
	push	edx
	push	0
	mov	DWORD PTR _tok, eax
	call	_new_method_instance
	mov	ecx, eax

; 921  :     METH_INSTANCE(mi)->flags |= Q_FORWARD_DEF;

	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	lea	eax, DWORD PTR [eax+edx+140]
	add	esp, 12					; 0000000cH
	or	DWORD PTR [eax], 1048576		; 00100000H

; 922  :     return mi;

	mov	eax, ecx

; 938  :   METH_INSTANCE(mi)->flags &= ~Q_FORWARD_DEF;
; 939  :   
; 940  :   return mi;
; 941  : } // end read_method_instance()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@read_metho:

; 923  :   }
; 924  :   
; 925  :   if ( tok != METHOD_TOK )

	cmp	eax, 35024				; 000088d0H
	je	SHORT $LN3@read_metho

; 926  :   { kb_error(1709,"Missing METHOD keyword.\n",DATAFILE_ERROR); return -1; }

	push	6
	push	OFFSET ??_C@_0BJ@IENIACIB@Missing?5METHOD?5keyword?4?6?$AA@
	push	1709					; 000006adH
	call	_kb_error
	add	esp, 12					; 0000000cH
	or	eax, -1

; 938  :   METH_INSTANCE(mi)->flags &= ~Q_FORWARD_DEF;
; 939  :   
; 940  :   return mi;
; 941  : } // end read_method_instance()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@read_metho:

; 927  : 
; 928  :   tok = yylex();

	push	0
	call	_kb_yylex
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 929  :   
; 930  :   if ( tok != NEWIDENT_TOK  && tok != MEAN_CURV_INT_TOK /* kludge */)

	cmp	eax, 268				; 0000010cH
	je	SHORT $LN2@read_metho
	cmp	eax, 35043				; 000088e3H
	je	SHORT $LN2@read_metho

; 931  :   { kb_error(1710,"Need method name.\n",DATAFILE_ERROR); return -1; }

	push	6
	push	OFFSET ??_C@_0BD@JNLPELKF@Need?5method?5name?4?6?$AA@
	push	1710					; 000006aeH
	call	_kb_error
	add	esp, 12					; 0000000cH
	or	eax, -1

; 938  :   METH_INSTANCE(mi)->flags &= ~Q_FORWARD_DEF;
; 939  :   
; 940  :   return mi;
; 941  : } // end read_method_instance()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@read_metho:

; 932  :   mi = new_method_instance(yytext,mname);

	mov	ecx, DWORD PTR _yytext
	push	esi
	lea	eax, DWORD PTR _mname$[ebp]
	push	eax
	push	ecx
	call	_new_method_instance

; 933  :   
; 934  :   tok = yylex();

	push	0
	mov	esi, eax
	call	_kb_yylex
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tok, eax

; 935  :   
; 936  :   if ( mi >= 0 ) 

	test	esi, esi
	js	SHORT $LN1@read_metho

; 937  :      read_instance_attr(mi);

	push	esi
	call	_read_instance_attr
	add	esp, 4
$LN1@read_metho:

; 938  :   METH_INSTANCE(mi)->flags &= ~Q_FORWARD_DEF;
; 939  :   
; 940  :   return mi;
; 941  : } // end read_method_instance()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	and	DWORD PTR [eax+edx+140], -1048577	; ffefffffH
	lea	eax, DWORD PTR [eax+edx+140]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_read_method_instance ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DO@CCAAMEBL@Numbered?5quantities?5are?5obsolete@ ; `string'
PUBLIC	_read_quantity
;	COMDAT ??_C@_0DO@CCAAMEBL@Numbered?5quantities?5are?5obsolete@
CONST	SEGMENT
??_C@_0DO@CCAAMEBL@Numbered?5quantities?5are?5obsolete@ DB 'Numbered quan'
	DB	'tities are obsolete. Please use named quantity.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _read_quantity
_TEXT	SEGMENT
_read_quantity PROC					; COMDAT

; 1187 :   tok = gettok(INTEGER_TOK);

	push	265					; 00000109H
	call	_gettok
	add	esp, 4
	mov	DWORD PTR _tok, eax

; 1188 :   if ( tok != INTEGER_TOK ) 

	cmp	eax, 265				; 00000109H
	je	SHORT $LN1@read_quant

; 1189 :   { return read_named_quantity();

	jmp	_read_named_quantity
$LN1@read_quant:

; 1190 :   }
; 1191 :   kb_error(1727,
; 1192 :    "Numbered quantities are obsolete. Please use named quantity.\n",
; 1193 :       DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0DO@CCAAMEBL@Numbered?5quantities?5are?5obsolete@
	push	1727					; 000006bfH
	call	_kb_error

; 1194 :   tok = yylex();

	push	0
	call	_kb_yylex
	mov	DWORD PTR _tok, eax
	add	esp, 16					; 00000010H

; 1195 :   return 0;

	xor	eax, eax

; 1196 : } // end read_quantity()

	ret	0
_read_quantity ENDP
_TEXT	ENDS
PUBLIC	??_C@_06MJLDIBBJ@Done?4?6?$AA@			; `string'
PUBLIC	??_C@_0L@GHOGACAB@gap_energy?$AA@		; `string'
PUBLIC	??_C@_09GGFHGOMM@gap_quant?$AA@			; `string'
PUBLIC	??_C@_0BC@GMGIDDOF@sq_mean_curvature?$AA@	; `string'
PUBLIC	??_C@_0P@GAKMPAOL@sqcurve_string?$AA@		; `string'
PUBLIC	??_C@_0BH@CCMBOEAG@sq_mean_curvature_inst?$AA@	; `string'
PUBLIC	??_C@_0BI@LBAGEHPE@sq_mean_curvature_quant?$AA@	; `string'
PUBLIC	??_C@_0BD@IHBAADBA@sq_gauss_curvature?$AA@	; `string'
PUBLIC	??_C@_0BI@KGGFDDEC@mean_curvature_integral?$AA@	; `string'
PUBLIC	??_C@_0P@OELPPHOM@gravity_method?$AA@		; `string'
PUBLIC	??_C@_0P@MACHNINP@string_gravity?$AA@		; `string'
PUBLIC	??_C@_0N@CPLKLOIP@gravity_inst?$AA@		; `string'
PUBLIC	??_C@_0O@CFGPAHCK@gravity_quant?$AA@		; `string'
PUBLIC	??_C@_0BI@DJNLNJJF@boundary_?$CFd_energy_inst?$AA@ ; `string'
PUBLIC	??_C@_0BD@BPDDPBCP@boundary_?$CFd_energy?$AA@	; `string'
PUBLIC	??_C@_0BI@DKKEEPDJ@boundary_?$CFs_energy_inst?$AA@ ; `string'
PUBLIC	??_C@_0BD@NHJCNOJH@boundary_?$CFs_energy?$AA@	; `string'
PUBLIC	??_C@_0BD@BNIMHGBP@density_facet_area?$AA@	; `string'
PUBLIC	??_C@_0BC@LINPBAPK@metric_facet_area?$AA@	; `string'
PUBLIC	??_C@_09JHHFBFEA@density?$CK?$CI?$AA@		; `string'
PUBLIC	??_C@_0BG@GCONPCCF@facet_scalar_integral?$AA@	; `string'
PUBLIC	??_C@_0L@IEMJCMLH@klein_area?$AA@		; `string'
PUBLIC	??_C@_0N@GGFMNOJB@wulff_energy?$AA@		; `string'
PUBLIC	??_C@_0BC@KOALOLKM@default_area_inst?$AA@	; `string'
PUBLIC	??_C@_0N@IHGFDJCL@default_area?$AA@		; `string'
PUBLIC	??_C@_0M@BHBPGCHH@edge_length?$AA@		; `string'
PUBLIC	??_C@_0BE@JMOBOOKO@density_edge_length?$AA@	; `string'
PUBLIC	??_C@_0BK@EEIBFKFE@Metric?5formula?5too?5long?4?6?$AA@ ; `string'
PUBLIC	??_C@_0M@HAPNKILN@2?$CKX?$CFd?$CKX?$CFd?$CK?$CI?$AA@ ; `string'
PUBLIC	??_C@_07KHHILPIO@X?$CFd?$FO2?$CK?$CI?$AA@	; `string'
PUBLIC	??_C@_0BG@FFNPDJE@edge_general_integral?$AA@	; `string'
PUBLIC	??_C@_0BB@LMKJAPE@conformal?5metric?$AA@	; `string'
PUBLIC	??_C@_01PKGAHCOL@?$CJ?$AA@			; `string'
PUBLIC	??_C@_0CE@NBENIECN@Conformal?5metric?5formula?5too?5lon@ ; `string'
PUBLIC	??_C@_0O@NALCIFII@density?$CKsqrt?$CI?$AA@	; `string'
PUBLIC	??_C@_0BF@PNBICDOK@edge_scalar_integral?$AA@	; `string'
PUBLIC	??_C@_0N@EKDPMMFI@klein_length?$AA@		; `string'
PUBLIC	??_C@_0BE@GCKPMHFK@default_length_inst?$AA@	; `string'
PUBLIC	??_C@_0P@PKBGOOAJ@default_length?$AA@		; `string'
PUBLIC	??_C@_0CG@BPFGDMOP@Converting?5to?5all?5named?5quantiti@ ; `string'
PUBLIC	??_C@_0CP@CPPIPFFF@Can?8t?5do?5wulff?5energy?5method?5for@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_convert_to_quantities
EXTRN	_quantities_only_flag:DWORD
EXTRN	_gap_quantity_num:DWORD
EXTRN	_square_curvature_param:DWORD
EXTRN	_sq_mean_curv_quantity_num:DWORD
EXTRN	_square_curvature_flag:DWORD
EXTRN	_sqgauss_flag:DWORD
EXTRN	_mean_curv_int_quantity_num:DWORD
EXTRN	_add_standard_quantity:PROC
EXTRN	_mean_curv_int_flag:DWORD
EXTRN	_gravity_quantity_num:DWORD
EXTRN	_length_method_number:DWORD
EXTRN	_print_express:PROC
EXTRN	_klein_metric_flag:DWORD
EXTRN	_length_method_name:BYTE
EXTRN	_default_area_quant_num:DWORD
EXTRN	_outstring:PROC
;	COMDAT ??_C@_06MJLDIBBJ@Done?4?6?$AA@
CONST	SEGMENT
??_C@_06MJLDIBBJ@Done?4?6?$AA@ DB 'Done.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GHOGACAB@gap_energy?$AA@
CONST	SEGMENT
??_C@_0L@GHOGACAB@gap_energy?$AA@ DB 'gap_energy', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GGFHGOMM@gap_quant?$AA@
CONST	SEGMENT
??_C@_09GGFHGOMM@gap_quant?$AA@ DB 'gap_quant', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GMGIDDOF@sq_mean_curvature?$AA@
CONST	SEGMENT
??_C@_0BC@GMGIDDOF@sq_mean_curvature?$AA@ DB 'sq_mean_curvature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GAKMPAOL@sqcurve_string?$AA@
CONST	SEGMENT
??_C@_0P@GAKMPAOL@sqcurve_string?$AA@ DB 'sqcurve_string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CCMBOEAG@sq_mean_curvature_inst?$AA@
CONST	SEGMENT
??_C@_0BH@CCMBOEAG@sq_mean_curvature_inst?$AA@ DB 'sq_mean_curvature_inst'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LBAGEHPE@sq_mean_curvature_quant?$AA@
CONST	SEGMENT
??_C@_0BI@LBAGEHPE@sq_mean_curvature_quant?$AA@ DB 'sq_mean_curvature_qua'
	DB	'nt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IHBAADBA@sq_gauss_curvature?$AA@
CONST	SEGMENT
??_C@_0BD@IHBAADBA@sq_gauss_curvature?$AA@ DB 'sq_gauss_curvature', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KGGFDDEC@mean_curvature_integral?$AA@
CONST	SEGMENT
??_C@_0BI@KGGFDDEC@mean_curvature_integral?$AA@ DB 'mean_curvature_integr'
	DB	'al', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OELPPHOM@gravity_method?$AA@
CONST	SEGMENT
??_C@_0P@OELPPHOM@gravity_method?$AA@ DB 'gravity_method', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MACHNINP@string_gravity?$AA@
CONST	SEGMENT
??_C@_0P@MACHNINP@string_gravity?$AA@ DB 'string_gravity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CPLKLOIP@gravity_inst?$AA@
CONST	SEGMENT
??_C@_0N@CPLKLOIP@gravity_inst?$AA@ DB 'gravity_inst', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CFGPAHCK@gravity_quant?$AA@
CONST	SEGMENT
??_C@_0O@CFGPAHCK@gravity_quant?$AA@ DB 'gravity_quant', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DJNLNJJF@boundary_?$CFd_energy_inst?$AA@
CONST	SEGMENT
??_C@_0BI@DJNLNJJF@boundary_?$CFd_energy_inst?$AA@ DB 'boundary_%d_energy'
	DB	'_inst', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BPDDPBCP@boundary_?$CFd_energy?$AA@
CONST	SEGMENT
??_C@_0BD@BPDDPBCP@boundary_?$CFd_energy?$AA@ DB 'boundary_%d_energy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DKKEEPDJ@boundary_?$CFs_energy_inst?$AA@
CONST	SEGMENT
??_C@_0BI@DKKEEPDJ@boundary_?$CFs_energy_inst?$AA@ DB 'boundary_%s_energy'
	DB	'_inst', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NHJCNOJH@boundary_?$CFs_energy?$AA@
CONST	SEGMENT
??_C@_0BD@NHJCNOJH@boundary_?$CFs_energy?$AA@ DB 'boundary_%s_energy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BNIMHGBP@density_facet_area?$AA@
CONST	SEGMENT
??_C@_0BD@BNIMHGBP@density_facet_area?$AA@ DB 'density_facet_area', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LINPBAPK@metric_facet_area?$AA@
CONST	SEGMENT
??_C@_0BC@LINPBAPK@metric_facet_area?$AA@ DB 'metric_facet_area', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JHHFBFEA@density?$CK?$CI?$AA@
CONST	SEGMENT
??_C@_09JHHFBFEA@density?$CK?$CI?$AA@ DB 'density*(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GCONPCCF@facet_scalar_integral?$AA@
CONST	SEGMENT
??_C@_0BG@GCONPCCF@facet_scalar_integral?$AA@ DB 'facet_scalar_integral', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IEMJCMLH@klein_area?$AA@
CONST	SEGMENT
??_C@_0L@IEMJCMLH@klein_area?$AA@ DB 'klein_area', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GGFMNOJB@wulff_energy?$AA@
CONST	SEGMENT
??_C@_0N@GGFMNOJB@wulff_energy?$AA@ DB 'wulff_energy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KOALOLKM@default_area_inst?$AA@
CONST	SEGMENT
??_C@_0BC@KOALOLKM@default_area_inst?$AA@ DB 'default_area_inst', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IHGFDJCL@default_area?$AA@
CONST	SEGMENT
??_C@_0N@IHGFDJCL@default_area?$AA@ DB 'default_area', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BHBPGCHH@edge_length?$AA@
CONST	SEGMENT
??_C@_0M@BHBPGCHH@edge_length?$AA@ DB 'edge_length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JMOBOOKO@density_edge_length?$AA@
CONST	SEGMENT
??_C@_0BE@JMOBOOKO@density_edge_length?$AA@ DB 'density_edge_length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EEIBFKFE@Metric?5formula?5too?5long?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@EEIBFKFE@Metric?5formula?5too?5long?4?6?$AA@ DB 'Metric formula'
	DB	' too long.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HAPNKILN@2?$CKX?$CFd?$CKX?$CFd?$CK?$CI?$AA@
CONST	SEGMENT
??_C@_0M@HAPNKILN@2?$CKX?$CFd?$CKX?$CFd?$CK?$CI?$AA@ DB '2*X%d*X%d*(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KHHILPIO@X?$CFd?$FO2?$CK?$CI?$AA@
CONST	SEGMENT
??_C@_07KHHILPIO@X?$CFd?$FO2?$CK?$CI?$AA@ DB 'X%d^2*(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FFNPDJE@edge_general_integral?$AA@
CONST	SEGMENT
??_C@_0BG@FFNPDJE@edge_general_integral?$AA@ DB 'edge_general_integral', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LMKJAPE@conformal?5metric?$AA@
CONST	SEGMENT
??_C@_0BB@LMKJAPE@conformal?5metric?$AA@ DB 'conformal metric', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ?$AA@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ?$AA@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NBENIECN@Conformal?5metric?5formula?5too?5lon@
CONST	SEGMENT
??_C@_0CE@NBENIECN@Conformal?5metric?5formula?5too?5lon@ DB 'Conformal me'
	DB	'tric formula too long.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NALCIFII@density?$CKsqrt?$CI?$AA@
CONST	SEGMENT
??_C@_0O@NALCIFII@density?$CKsqrt?$CI?$AA@ DB 'density*sqrt(', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PNBICDOK@edge_scalar_integral?$AA@
CONST	SEGMENT
??_C@_0BF@PNBICDOK@edge_scalar_integral?$AA@ DB 'edge_scalar_integral', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EKDPMMFI@klein_length?$AA@
CONST	SEGMENT
??_C@_0N@EKDPMMFI@klein_length?$AA@ DB 'klein_length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GCKPMHFK@default_length_inst?$AA@
CONST	SEGMENT
??_C@_0BE@GCKPMHFK@default_length_inst?$AA@ DB 'default_length_inst', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PKBGOOAJ@default_length?$AA@
CONST	SEGMENT
??_C@_0P@PKBGOOAJ@default_length?$AA@ DB 'default_length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BPFGDMOP@Converting?5to?5all?5named?5quantiti@
CONST	SEGMENT
??_C@_0CG@BPFGDMOP@Converting?5to?5all?5named?5quantiti@ DB 'Converting t'
	DB	'o all named quantities...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@CPPIPFFF@Can?8t?5do?5wulff?5energy?5method?5for@
CONST	SEGMENT
??_C@_0CP@CPPIPFFF@Can?8t?5do?5wulff?5energy?5method?5for@ DB 'Can''t do '
	DB	'wulff energy method for strings yet.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _convert_to_quantities
_TEXT	SEGMENT
tv1216 = -1180						; size = 8
_oldflag$90592 = -1176					; size = 4
_oldflag$90553 = -1176					; size = 4
_q$ = -1172						; size = 4
tv1165 = -1168						; size = 4
_oldflag$90541 = -1168					; size = 4
tv1532 = -1164						; size = 4
_gq$ = -1164						; size = 4
_i$ = -1160						; size = 4
tv1604 = -1156						; size = 4
tv1546 = -1156						; size = 4
_meth$ = -1152						; size = 4
_bdry$90610 = -1148					; size = 4
_j$ = -1148						; size = 4
_formula$ = -1144					; size = 1000
_qname$ = -144						; size = 100
_inst_name$ = -44					; size = 40
__$ArrayPad$ = -4					; size = 4
_convert_to_quantities PROC				; COMDAT

; 2191 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1180				; 0000049cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2192 :   int gq;
; 2193 :   int meth;
; 2194 :   char inst_name[40];
; 2195 :   char qname[100];
; 2196 :   int i,j;
; 2197 :   body_id b_id;
; 2198 :   edge_id e_id; 
; 2199 :   int q;
; 2200 :   char formula[1000];
; 2201 :   char *gformula;
; 2202 : 
; 2203 :   if ( everything_quantities_flag ) return;

	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	$LN85@convert_to

; 2204 : 
; 2205 :   if ( web.wulff_flag && (web.dimension != 2) ) 

	cmp	DWORD PTR _web+908, 0
	push	ebx
	push	esi
	push	edi
	je	SHORT $LN131@convert_to
	cmp	DWORD PTR _web+620, 2
	je	SHORT $LN131@convert_to

; 2206 :      kb_error(1754,"Can't do wulff energy method for strings yet.\n",RECOVERABLE);

	mov	edi, 1
	push	edi
	push	OFFSET ??_C@_0CP@CPPIPFFF@Can?8t?5do?5wulff?5energy?5method?5for@
	push	1754					; 000006daH
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN83@convert_to
$LN131@convert_to:
	mov	edi, 1
$LN83@convert_to:

; 2207 : 
; 2208 : #ifdef MPI_EVOLVER
; 2209 :   if ( this_task == MASTER_TASK )
; 2210 :   { mpi_convert_to_quantities();
; 2211 :     outstring("Converting to all named quantities...");
; 2212 :   }
; 2213 : #else
; 2214 :   outstring("Converting to all named quantities...");

	push	OFFSET ??_C@_0CG@BPFGDMOP@Converting?5to?5all?5named?5quantiti@
	call	_outstring
	add	esp, 4

; 2215 : #endif
; 2216 : 
; 2217 :   /* set up default length or area quantities */
; 2218 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, edi
	jne	SHORT $LN82@convert_to

; 2219 :   {  q = new_quantity("default_length",Q_ENERGY);

	push	edi
	push	OFFSET ??_C@_0P@PKBGOOAJ@default_length?$AA@
	call	_new_quantity
	mov	ebx, eax
	mov	DWORD PTR _q$[ebp], ebx

; 2220 :      default_area_quant_num = q;

	mov	DWORD PTR _default_area_quant_num, ebx
	jmp	SHORT $LN136@convert_to
$LN82@convert_to:

; 2221 :   }
; 2222 :   else q = new_quantity("default_length",Q_INFO);

	push	4
	push	OFFSET ??_C@_0P@PKBGOOAJ@default_length?$AA@
	call	_new_quantity
	mov	ebx, eax
	mov	DWORD PTR _q$[ebp], eax
$LN136@convert_to:

; 2223 :   GEN_QUANT(q)->flags |= DEFAULT_QUANTITY; 

	mov	ecx, DWORD PTR _gen_quant_list
	mov	eax, ebx
	imul	eax, 368				; 00000170H
	or	DWORD PTR [eax+ecx+136], 8192		; 00002000H
	lea	eax, DWORD PTR [eax+ecx+136]
	add	esp, 8

; 2224 :   
; 2225 :   if ( length_method_name[0] )

	cmp	BYTE PTR _length_method_name, 0
	je	SHORT $LN80@convert_to

; 2226 :   { meth = find_method_instance(length_method_name);  /* user instance? */

	push	OFFSET _length_method_name
	call	_find_method_instance
	mov	esi, eax
	add	esp, 4

; 2227 :     if ( meth < 0 )  /* try pre-defined method */

	test	esi, esi
	jns	$LN132@convert_to

; 2228 :     { meth = new_method_instance(length_method_name,"default_length_inst");

	push	OFFSET ??_C@_0BE@GCKPMHFK@default_length_inst?$AA@
	push	OFFSET _length_method_name

; 2229 :       METH_INSTANCE(meth)->flags |= DEFAULT_INSTANCE;
; 2230 :     }

	jmp	$LN137@convert_to
$LN80@convert_to:

; 2231 :   }
; 2232 :   else if ( web.dimension >= 3 )

	cmp	DWORD PTR _web+620, 3
	jl	SHORT $LN77@convert_to

; 2233 :   { /* can't do edges in simplex model */
; 2234 :     meth = -1;

	or	esi, -1
	jmp	$LN132@convert_to
$LN77@convert_to:

; 2235 :   }
; 2236 :   else if ( klein_metric_flag )

	cmp	DWORD PTR _klein_metric_flag, 0

; 2237 :   { meth = new_method_instance("klein_length","default_length_inst");

	push	OFFSET ??_C@_0BE@GCKPMHFK@default_length_inst?$AA@
	je	SHORT $LN75@convert_to
	push	OFFSET ??_C@_0N@EKDPMMFI@klein_length?$AA@
	call	_new_method_instance

; 2238 :     METH_INSTANCE(meth)->flags |= DEFAULT_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	esi, eax
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	lea	eax, DWORD PTR [eax+ecx+140]
	jmp	$LN138@convert_to
$LN75@convert_to:

; 2239 :   }
; 2240 :   else if ( web.conformal_flag )

	cmp	DWORD PTR _web+1680, 0
	je	$LN73@convert_to

; 2241 :   {  int oldflag = datafile_flag;

	mov	edx, DWORD PTR _datafile_flag

; 2242 :      meth = new_method_instance("edge_scalar_integral","default_length_inst");

	push	OFFSET ??_C@_0BF@PNBICDOK@edge_scalar_integral?$AA@
	mov	DWORD PTR _oldflag$90541[ebp], edx
	call	_new_method_instance
	mov	DWORD PTR _meth$[ebp], eax

; 2243 :      METH_INSTANCE(meth)->flags |= DEFAULT_INSTANCE;

	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR _meth_inst_list
	xor	ebx, edx
	sub	ebx, edx
	imul	ebx, 2928				; 00000b70H
	or	DWORD PTR [ebx+eax+140], 4194304	; 00400000H

; 2244 :      strcpy(formula,"density*sqrt(");

	mov	eax, DWORD PTR ??_C@_0O@NALCIFII@density?$CKsqrt?$CI?$AA@
	mov	ecx, DWORD PTR ??_C@_0O@NALCIFII@density?$CKsqrt?$CI?$AA@+4
	mov	edx, DWORD PTR ??_C@_0O@NALCIFII@density?$CKsqrt?$CI?$AA@+8
	mov	DWORD PTR _formula$[ebp], eax
	mov	ax, WORD PTR ??_C@_0O@NALCIFII@density?$CKsqrt?$CI?$AA@+12

; 2245 :      gformula = print_express(&web.metric[0][0],'X');

	push	88					; 00000058H
	push	OFFSET _web+1688
	mov	DWORD PTR _formula$[ebp+4], ecx
	mov	DWORD PTR _formula$[ebp+8], edx
	mov	WORD PTR _formula$[ebp+12], ax
	call	_print_express
	add	esp, 16					; 00000010H
	mov	esi, eax

; 2246 :      if ( strlen(gformula) > sizeof(formula)-20 )

	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL113@convert_to:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL113@convert_to
	sub	eax, edx
	cmp	eax, 980				; 000003d4H
	jbe	SHORT $LN72@convert_to

; 2247 :        kb_error(1755,"Conformal metric formula too long.\n",RECOVERABLE);

	push	edi
	push	OFFSET ??_C@_0CE@NBENIECN@Conformal?5metric?5formula?5too?5lon@
	push	1755					; 000006dbH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN72@convert_to:

; 2248 : 
; 2249 :      strcat(formula,gformula);

	mov	eax, esi
	mov	edx, esi
$LL114@convert_to:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL114@convert_to
	lea	edi, DWORD PTR _formula$[ebp]
	sub	eax, edx
	dec	edi
$LL115@convert_to:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL115@convert_to
	mov	ecx, eax
	shr	ecx, 2
	mov	esi, edx
	rep movsd
	mov	ecx, eax
	and	ecx, 3
	rep movsb

; 2250 :      strcat(formula,")");

	lea	edi, DWORD PTR _formula$[ebp]
	dec	edi
$LL116@convert_to:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL116@convert_to
	mov	cx, WORD PTR ??_C@_01PKGAHCOL@?$CJ?$AA@

; 2251 :      METH_INSTANCE(meth)->expr[0] = 
; 2252 :           (struct expnode *)mycalloc(1,sizeof(struct expnode));

	push	2252					; 000008ccH
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	104					; 00000068H
	mov	esi, 1
	push	esi
	mov	WORD PTR [edi], cx
	call	_kb_calloc
	mov	edx, DWORD PTR _meth_inst_list
	mov	DWORD PTR [ebx+edx+232], eax

; 2253 :      cmdptr = formula;
; 2254 :      datafile_flag = 1; 
; 2255 :      exparse(SDIM,METH_INSTANCE(meth)->expr[0],USERCOPY); line_no--;

	mov	ecx, DWORD PTR _meth_inst_list
	lea	eax, DWORD PTR _formula$[ebp]
	mov	DWORD PTR _cmdptr, eax
	mov	eax, DWORD PTR _web+616
	mov	DWORD PTR _datafile_flag, esi
	mov	edx, DWORD PTR [ebx+ecx+232]
	push	esi
	push	edx
	push	eax
	call	_exparse

; 2256 :      sprintf(METH_INSTANCE(meth)->expr[0]->name,"conformal metric");

	mov	ecx, DWORD PTR _meth_inst_list
	sub	DWORD PTR _line_no, esi
	mov	edx, DWORD PTR [ebx+ecx+232]
	add	edx, 20					; 00000014H
	push	OFFSET ??_C@_0BB@LMKJAPE@conformal?5metric?$AA@
	push	edx
	call	_sprintf

; 2257 :      cmdptr = NULL; datafile_flag = oldflag;

	mov	eax, DWORD PTR _oldflag$90541[ebp]
	mov	ebx, DWORD PTR _q$[ebp]
	mov	esi, DWORD PTR _meth$[ebp]
	add	esp, 36					; 00000024H
	mov	DWORD PTR _cmdptr, 0
	mov	DWORD PTR _datafile_flag, eax
	mov	edi, 1
	jmp	$LN132@convert_to
$LN73@convert_to:

; 2258 :   }
; 2259 :   else if ( web.metric_flag )

	cmp	DWORD PTR _web+1676, 0
	je	$LN70@convert_to

; 2260 :   {  int oldflag = datafile_flag;

	mov	ecx, DWORD PTR _datafile_flag

; 2261 :      meth = new_method_instance("edge_general_integral","default_length_inst");

	push	OFFSET ??_C@_0BG@FFNPDJE@edge_general_integral?$AA@
	mov	DWORD PTR _oldflag$90553[ebp], ecx
	call	_new_method_instance
	mov	esi, eax

; 2262 :      METH_INSTANCE(meth)->flags |= DEFAULT_INSTANCE;

	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR _meth_inst_list
	xor	ecx, edx
	sub	ecx, edx
	imul	ecx, 2928				; 00000b70H
	or	DWORD PTR [ecx+eax+140], 4194304	; 00400000H

; 2263 :      strcpy(formula,"density*sqrt(");

	mov	edx, DWORD PTR ??_C@_0O@NALCIFII@density?$CKsqrt?$CI?$AA@
	mov	eax, DWORD PTR ??_C@_0O@NALCIFII@density?$CKsqrt?$CI?$AA@+4
	mov	DWORD PTR _formula$[ebp], edx
	mov	dx, WORD PTR ??_C@_0O@NALCIFII@density?$CKsqrt?$CI?$AA@+12
	mov	WORD PTR _formula$[ebp+12], dx

; 2264 :      for ( i = 1 ; i <= SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR tv1165[ebp], ecx
	mov	ecx, DWORD PTR ??_C@_0O@NALCIFII@density?$CKsqrt?$CI?$AA@+8
	add	esp, 8
	mov	DWORD PTR _meth$[ebp], esi
	mov	DWORD PTR _formula$[ebp+4], eax
	mov	DWORD PTR _formula$[ebp+8], ecx
	mov	DWORD PTR _i$[ebp], edi
	cmp	edx, edi
	jl	$LN130@convert_to

; 2260 :   {  int oldflag = datafile_flag;

	mov	DWORD PTR tv1546[ebp], OFFSET _web+1688
	npad	10
$LL134@convert_to:

; 2265 :        for ( j = 1 ; j <= i  ; j++ )

	mov	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	cmp	DWORD PTR _i$[ebp], eax
	jl	$LN68@convert_to
	mov	eax, DWORD PTR tv1546[ebp]
	mov	ebx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv1532[ebp], eax
	npad	7
$LL66@convert_to:

; 2266 :        { if ( i > 1 ) strcat(formula,"+");

	cmp	ebx, 1
	jle	SHORT $LN63@convert_to
	lea	edi, DWORD PTR _formula$[ebp]
	dec	edi
	npad	4
$LL117@convert_to:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL117@convert_to
	mov	cx, WORD PTR ??_C@_01MIFGBAGJ@?$CL?$AA@
	mov	WORD PTR [edi], cx
$LN63@convert_to:

; 2267 :           if ( i==j ) sprintf(formula+strlen(formula),"X%d^2*(",i+SDIM);

	lea	eax, DWORD PTR _formula$[ebp]
	lea	esi, DWORD PTR [eax+1]
	cmp	ebx, DWORD PTR _j$[ebp]
	jne	SHORT $LL119@convert_to
$LL118@convert_to:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL118@convert_to
	add	edx, ebx
	push	edx
	sub	eax, esi
	lea	edx, DWORD PTR _formula$[ebp+eax]
	push	OFFSET ??_C@_07KHHILPIO@X?$CFd?$FO2?$CK?$CI?$AA@
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN61@convert_to
$LL119@convert_to:

; 2268 :           else sprintf(formula+strlen(formula),"2*X%d*X%d*(",i+SDIM,j+SDIM);

	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL119@convert_to
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, edx
	push	ecx
	add	edx, ebx
	push	edx
	sub	eax, esi
	lea	edx, DWORD PTR _formula$[ebp+eax]
	push	OFFSET ??_C@_0M@HAPNKILN@2?$CKX?$CFd?$CKX?$CFd?$CK?$CI?$AA@
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN61@convert_to:

; 2269 :           gformula = print_express(&web.metric[i-1][j-1],'X');

	mov	eax, DWORD PTR tv1532[ebp]
	push	88					; 00000058H
	push	eax
	call	_print_express
	add	esp, 8
	mov	esi, eax

; 2270 :           if ( strlen(gformula) > sizeof(formula)-20 )

	lea	edx, DWORD PTR [eax+1]
$LL120@convert_to:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL120@convert_to
	sub	eax, edx
	cmp	eax, 980				; 000003d4H
	jbe	SHORT $LN60@convert_to

; 2271 :             kb_error(1756,"Metric formula too long.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BK@EEIBFKFE@Metric?5formula?5too?5long?4?6?$AA@
	push	1756					; 000006dcH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN60@convert_to:

; 2272 :           strcat(formula,gformula);

	mov	eax, esi
	mov	edx, esi
	npad	2
$LL121@convert_to:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL121@convert_to
	lea	edi, DWORD PTR _formula$[ebp]
	sub	eax, edx
	dec	edi
$LL122@convert_to:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL122@convert_to
	mov	ecx, eax
	shr	ecx, 2
	mov	esi, edx
	rep movsd
	mov	ecx, eax
	and	ecx, 3
	rep movsb

; 2273 :           strcat(formula,")");

	lea	edi, DWORD PTR _formula$[ebp]
	dec	edi
	npad	1
$LL123@convert_to:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL123@convert_to
	mov	eax, DWORD PTR _j$[ebp]
	mov	cx, WORD PTR ??_C@_01PKGAHCOL@?$CJ?$AA@
	add	DWORD PTR tv1532[ebp], 104		; 00000068H
	mov	edx, DWORD PTR _web+616
	inc	eax
	mov	WORD PTR [edi], cx
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, ebx
	jle	$LL66@convert_to
$LN68@convert_to:

; 2264 :      for ( i = 1 ; i <= SDIM ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv1546[ebp], 624		; 00000270H
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, edx
	jle	$LL134@convert_to
	mov	ebx, DWORD PTR _q$[ebp]
	mov	esi, DWORD PTR _meth$[ebp]
$LN130@convert_to:

; 2274 :        }
; 2275 :      strcat(formula,")");

	lea	edi, DWORD PTR _formula$[ebp]
	dec	edi
$LL124@convert_to:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL124@convert_to
	mov	dx, WORD PTR ??_C@_01PKGAHCOL@?$CJ?$AA@

; 2276 :      METH_INSTANCE(meth)->expr[0] = 
; 2277 :          (struct expnode *)mycalloc(1,sizeof(struct expnode));

	push	2277					; 000008e5H
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	104					; 00000068H
	push	1
	mov	WORD PTR [edi], dx
	call	_kb_calloc
	mov	ecx, DWORD PTR _meth_inst_list
	mov	edi, DWORD PTR tv1165[ebp]
	mov	DWORD PTR [edi+ecx+232], eax

; 2278 :      cmdptr = formula;
; 2279 :      datafile_flag = 1;
; 2280 :      exparse(2*SDIM,METH_INSTANCE(meth)->expr[0],USERCOPY); line_no--;

	mov	eax, DWORD PTR _meth_inst_list
	lea	edx, DWORD PTR _formula$[ebp]
	mov	DWORD PTR _cmdptr, edx
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR _datafile_flag, 1
	mov	ecx, DWORD PTR [edi+eax+232]
	push	1
	push	ecx
	lea	eax, DWORD PTR [edx+edx]
	push	eax
	call	_exparse

; 2281 :      sprintf(METH_INSTANCE(meth)->expr[0]->name,"conformal metric");

	mov	ecx, DWORD PTR _meth_inst_list
	dec	DWORD PTR _line_no
	mov	edx, DWORD PTR [edi+ecx+232]
	add	edx, 20					; 00000014H
	push	OFFSET ??_C@_0BB@LMKJAPE@conformal?5metric?$AA@
	push	edx
	call	_sprintf

; 2282 :      cmdptr = NULL; datafile_flag = oldflag;

	mov	eax, DWORD PTR _oldflag$90553[ebp]
	add	esp, 36					; 00000024H
	mov	DWORD PTR _cmdptr, 0
	mov	DWORD PTR _datafile_flag, eax
	mov	edi, 1
	jmp	SHORT $LN132@convert_to
$LN70@convert_to:

; 2283 :   }
; 2284 :   else if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, edi
	jne	SHORT $LN58@convert_to

; 2285 :   { meth = new_method_instance("density_edge_length","default_length_inst");

	push	OFFSET ??_C@_0BE@JMOBOOKO@density_edge_length?$AA@
	call	_new_method_instance

; 2286 :     METH_INSTANCE(meth)->flags |= DEFAULT_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	esi, eax
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	lea	eax, DWORD PTR [eax+ecx+140]

; 2287 :   }
; 2288 :   else

	jmp	SHORT $LN138@convert_to
$LN58@convert_to:

; 2289 :   { meth = new_method_instance("edge_length","default_length_inst");

	push	OFFSET ??_C@_0M@BHBPGCHH@edge_length?$AA@
$LN137@convert_to:
	call	_new_method_instance
	mov	esi, eax

; 2290 :     METH_INSTANCE(meth)->flags |= DEFAULT_INSTANCE;

	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	lea	eax, DWORD PTR [eax+edx+140]
$LN138@convert_to:
	add	esp, 8
	or	DWORD PTR [eax], 4194304		; 00400000H
$LN132@convert_to:

; 2291 :   }
; 2292 :   length_method_number = meth;

	mov	DWORD PTR _length_method_number, esi

; 2293 :   if ( meth >= 0 )

	test	esi, esi
	js	SHORT $LN56@convert_to

; 2294 :   {
; 2295 :     METH_INSTANCE(meth)->flags |= IMPLICIT_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	or	DWORD PTR [eax+ecx+140], 2097152	; 00200000H

; 2296 :     if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, edi
	jne	SHORT $LN55@convert_to

; 2297 :       METH_INSTANCE(meth)->flags |= USE_DENSITY;

	mov	ecx, DWORD PTR _meth_inst_list
	or	DWORD PTR [eax+ecx+140], 536870912	; 20000000H
$LN55@convert_to:

; 2298 :     attach_method_num(q,meth);

	push	esi
	push	ebx
	call	_attach_method_num

; 2299 :     apply_method_num(NULLID,meth);  /* global method */

	push	esi
	push	0
	call	_apply_method_num
	add	esp, 16					; 00000010H
$LN56@convert_to:

; 2300 :   }
; 2301 :   
; 2302 :   if ( web.representation != STRING )

	cmp	DWORD PTR _web+624, edi
	je	$LN54@convert_to

; 2303 :   /* soapfilm or simplex */
; 2304 :   {  q = new_quantity("default_area",Q_ENERGY);

	push	edi
	push	OFFSET ??_C@_0N@IHGFDJCL@default_area?$AA@
	call	_new_quantity

; 2305 :      default_area_quant_num = q;
; 2306 :      GEN_QUANT(q)->flags |= DEFAULT_QUANTITY;

	mov	ecx, DWORD PTR _gen_quant_list
	mov	esi, eax
	imul	eax, 368				; 00000170H
	lea	eax, DWORD PTR [eax+ecx+136]
	mov	DWORD PTR _default_area_quant_num, esi
	or	DWORD PTR [eax], 8192			; 00002000H
	add	esp, 8

; 2307 :      if ( area_method_name[0] )

	cmp	BYTE PTR _area_method_name, 0
	mov	DWORD PTR _q$[ebp], esi
	je	SHORT $LN53@convert_to

; 2308 :      { meth = find_method_instance(area_method_name);  /* user instance? */

	push	OFFSET _area_method_name
	call	_find_method_instance
	mov	edi, eax
	add	esp, 4

; 2309 :        if ( meth < 0 )  /* try pre-defined method */

	test	edi, edi
	jns	$LN42@convert_to

; 2310 :        { meth = new_method_instance(area_method_name,"default_area_inst");

	push	OFFSET ??_C@_0BC@KOALOLKM@default_area_inst?$AA@
	push	OFFSET _area_method_name

; 2311 :          METH_INSTANCE(meth)->flags |= DEFAULT_INSTANCE;
; 2312 :        }

	jmp	$LN139@convert_to
$LN53@convert_to:

; 2313 :      }
; 2314 :      else if ( web.wulff_flag )

	cmp	DWORD PTR _web+908, 0

; 2315 :      { meth = new_method_instance("wulff_energy","default_area_inst");

	push	OFFSET ??_C@_0BC@KOALOLKM@default_area_inst?$AA@
	je	SHORT $LN50@convert_to
	push	OFFSET ??_C@_0N@GGFMNOJB@wulff_energy?$AA@
	call	_new_method_instance

; 2316 :        METH_INSTANCE(meth)->flags |= DEFAULT_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	edi, eax
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	lea	eax, DWORD PTR [eax+ecx+140]
	jmp	$LN140@convert_to
$LN50@convert_to:

; 2317 :      }
; 2318 :      else if ( klein_metric_flag )

	cmp	DWORD PTR _klein_metric_flag, 0
	je	SHORT $LN48@convert_to

; 2319 :      { meth = new_method_instance("klein_area","default_area_inst");

	push	OFFSET ??_C@_0L@IEMJCMLH@klein_area?$AA@

; 2320 :        METH_INSTANCE(meth)->flags |= DEFAULT_INSTANCE;

	jmp	$LN139@convert_to
$LN48@convert_to:

; 2321 :      }
; 2322 :      else if ( web.conformal_flag )

	cmp	DWORD PTR _web+1680, 0
	je	$LN46@convert_to

; 2323 :      {  int oldflag = datafile_flag;

	mov	eax, DWORD PTR _datafile_flag

; 2324 :         meth = new_method_instance("facet_scalar_integral","default_area_inst");

	push	OFFSET ??_C@_0BG@GCONPCCF@facet_scalar_integral?$AA@
	mov	DWORD PTR _oldflag$90592[ebp], eax
	call	_new_method_instance
	mov	DWORD PTR _meth$[ebp], eax

; 2325 :         METH_INSTANCE(meth)->flags |= DEFAULT_INSTANCE;

	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR _meth_inst_list
	xor	ebx, edx
	sub	ebx, edx
	imul	ebx, 2928				; 00000b70H
	or	DWORD PTR [ebx+eax+140], 4194304	; 00400000H

; 2326 :         strcpy(formula,"density*(");

	mov	ecx, DWORD PTR ??_C@_09JHHFBFEA@density?$CK?$CI?$AA@
	mov	edx, DWORD PTR ??_C@_09JHHFBFEA@density?$CK?$CI?$AA@+4
	mov	ax, WORD PTR ??_C@_09JHHFBFEA@density?$CK?$CI?$AA@+8

; 2327 :         gformula = print_express(&web.metric[0][0],'X');

	push	88					; 00000058H
	push	OFFSET _web+1688
	mov	DWORD PTR _formula$[ebp], ecx
	mov	DWORD PTR _formula$[ebp+4], edx
	mov	WORD PTR _formula$[ebp+8], ax
	call	_print_express
	add	esp, 16					; 00000010H
	mov	esi, eax

; 2328 :         if ( strlen(gformula) > sizeof(formula)-20 )

	lea	edx, DWORD PTR [eax+1]
$LL125@convert_to:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL125@convert_to
	sub	eax, edx
	cmp	eax, 980				; 000003d4H
	jbe	SHORT $LN45@convert_to

; 2329 :           kb_error(1757,"Conformal metric formula too long.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CE@NBENIECN@Conformal?5metric?5formula?5too?5lon@
	push	1757					; 000006ddH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN45@convert_to:

; 2330 : 
; 2331 :         strcat(formula,gformula);

	mov	eax, esi
	mov	edx, esi
$LL126@convert_to:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL126@convert_to
	lea	edi, DWORD PTR _formula$[ebp]
	sub	eax, edx
	dec	edi
$LL127@convert_to:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL127@convert_to
	mov	ecx, eax
	shr	ecx, 2
	mov	esi, edx
	rep movsd
	mov	ecx, eax
	and	ecx, 3
	rep movsb

; 2332 :         strcat(formula,")");

	lea	edi, DWORD PTR _formula$[ebp]
	dec	edi
	npad	1
$LL128@convert_to:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL128@convert_to
	mov	cx, WORD PTR ??_C@_01PKGAHCOL@?$CJ?$AA@

; 2333 :         METH_INSTANCE(meth)->expr[0] = 
; 2334 :             (struct expnode *)mycalloc(1,sizeof(struct expnode));

	push	2334					; 0000091eH
	push	OFFSET ??_C@_0L@INLEEIPK@LEXINIT2?4C?$AA@
	push	104					; 00000068H
	mov	esi, 1
	push	esi
	mov	WORD PTR [edi], cx
	call	_kb_calloc
	mov	edx, DWORD PTR _meth_inst_list
	mov	DWORD PTR [ebx+edx+232], eax

; 2335 :         cmdptr = formula;
; 2336 :         datafile_flag = 1;
; 2337 :         exparse(SDIM,METH_INSTANCE(meth)->expr[0],USERCOPY); line_no--;

	mov	ecx, DWORD PTR _meth_inst_list
	lea	eax, DWORD PTR _formula$[ebp]
	mov	DWORD PTR _cmdptr, eax
	mov	eax, DWORD PTR _web+616
	mov	DWORD PTR _datafile_flag, esi
	mov	edx, DWORD PTR [ebx+ecx+232]
	push	esi
	push	edx
	push	eax
	call	_exparse

; 2338 :         sprintf(METH_INSTANCE(meth)->expr[0]->name,"conformal metric");

	mov	ecx, DWORD PTR _meth_inst_list
	sub	DWORD PTR _line_no, esi
	mov	edx, DWORD PTR [ebx+ecx+232]
	add	edx, 20					; 00000014H
	push	OFFSET ??_C@_0BB@LMKJAPE@conformal?5metric?$AA@
	push	edx
	call	_sprintf

; 2339 :         cmdptr = NULL; datafile_flag = oldflag;

	mov	eax, DWORD PTR _oldflag$90592[ebp]
	mov	edi, DWORD PTR _meth$[ebp]
	mov	esi, DWORD PTR _q$[ebp]
	add	esp, 36					; 00000024H
	mov	DWORD PTR _cmdptr, 0
	mov	DWORD PTR _datafile_flag, eax
	jmp	SHORT $LN42@convert_to
$LN46@convert_to:

; 2340 :      }
; 2341 :      else if ( web.metric_flag )

	cmp	DWORD PTR _web+1676, 0
	je	SHORT $LN43@convert_to

; 2342 :      {
; 2343 :        meth = new_method_instance("metric_facet_area","default_area_inst");

	push	OFFSET ??_C@_0BC@LINPBAPK@metric_facet_area?$AA@
	call	_new_method_instance

; 2344 :        METH_INSTANCE(meth)->flags |= DEFAULT_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	edi, eax
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	lea	eax, DWORD PTR [eax+ecx+140]

; 2345 :      }
; 2346 :      else

	jmp	SHORT $LN140@convert_to
$LN43@convert_to:

; 2347 :      { meth = new_method_instance("density_facet_area","default_area_inst");

	push	OFFSET ??_C@_0BD@BNIMHGBP@density_facet_area?$AA@
$LN139@convert_to:
	call	_new_method_instance
	mov	edi, eax

; 2348 :        METH_INSTANCE(meth)->flags |= DEFAULT_INSTANCE;

	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	lea	eax, DWORD PTR [eax+edx+140]
$LN140@convert_to:
	add	esp, 8
	or	DWORD PTR [eax], 4194304		; 00400000H
$LN42@convert_to:

; 2349 :      }
; 2350 :      METH_INSTANCE(meth)->flags |= IMPLICIT_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	eax, edi
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	or	DWORD PTR [eax+ecx+140], 2097152	; 00200000H

; 2351 :      METH_INSTANCE(meth)->flags |= USE_DENSITY;

	mov	ecx, DWORD PTR _meth_inst_list
	or	DWORD PTR [eax+ecx+140], 536870912	; 20000000H

; 2352 :      attach_method_num(q,meth);

	push	edi
	push	esi
	call	_attach_method_num

; 2353 :      apply_method_num(NULLID,meth);  /* global method */

	push	edi
	push	0
	call	_apply_method_num
	add	esp, 16					; 00000010H
	mov	edi, 1
$LN54@convert_to:

; 2354 :   }
; 2355 : 
; 2356 :   /* constraint energy integrals */
; 2357 :   for ( i = 0 ; i < web.maxcon ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _web+644, esi
	jle	SHORT $LN39@convert_to
$LL41@convert_to:

; 2358 :     convert_constraint_to_quantities(i);

	push	esi
	call	_convert_constraint_to_quantities
	add	esi, edi
	add	esp, 4
	cmp	esi, DWORD PTR _web+644
	jl	SHORT $LL41@convert_to
$LN39@convert_to:

; 2359 : 
; 2360 : 
; 2361 : 
; 2362 :   /* boundary energy integrals */
; 2363 :   for ( i = 0 ; i < web.bdrymax ; i++ )

	xor	ebx, ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	DWORD PTR _web+768, ebx
	jle	$LN36@convert_to
	mov	DWORD PTR tv1604[ebp], ebx
$LL38@convert_to:

; 2364 :   { struct boundary *bdry = web.boundaries + i;

	mov	esi, DWORD PTR tv1604[ebp]
	add	esi, DWORD PTR _web+776

; 2365 :     if ( !(bdry->attr & CON_ENERGY) ) continue;

	mov	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [esi+36]
	mov	eax, ecx
	mov	DWORD PTR tv1216[ebp+4], edx
	and	eax, 64					; 00000040H
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR _bdry$90610[ebp], esi
	je	$LN37@convert_to

; 2366 :     if ( bdry->attr & NAMED_THING )

	and	ecx, 512				; 00000200H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN34@convert_to

; 2367 :     { sprintf(qname,"boundary_%s_energy",bdry->name);

	push	esi
	lea	eax, DWORD PTR _qname$[ebp]
	push	OFFSET ??_C@_0BD@NHJCNOJH@boundary_?$CFs_energy?$AA@
	push	eax
	call	_sprintf

; 2368 :       sprintf(inst_name,"boundary_%s_energy_inst",bdry->name);

	push	esi
	push	OFFSET ??_C@_0BI@DKKEEPDJ@boundary_?$CFs_energy_inst?$AA@
	lea	ecx, DWORD PTR _inst_name$[ebp]
	push	ecx

; 2369 :     } else

	jmp	SHORT $LN141@convert_to
$LN34@convert_to:

; 2370 :     { sprintf(qname,"boundary_%d_energy",i);

	push	ebx
	lea	edx, DWORD PTR _qname$[ebp]
	push	OFFSET ??_C@_0BD@BPDDPBCP@boundary_?$CFd_energy?$AA@
	push	edx
	call	_sprintf

; 2371 :       sprintf(inst_name,"boundary_%d_energy_inst",i);

	push	ebx
	push	OFFSET ??_C@_0BI@DJNLNJJF@boundary_?$CFd_energy_inst?$AA@
	lea	eax, DWORD PTR _inst_name$[ebp]
	push	eax
$LN141@convert_to:
	call	_sprintf
	add	esp, 24					; 00000018H

; 2372 :     }
; 2373 :     gq = new_quantity(qname,Q_ENERGY);

	lea	ecx, DWORD PTR _qname$[ebp]
	push	edi
	push	ecx
	call	_new_quantity
	mov	esi, eax

; 2374 :     GEN_QUANT(gq)->flags |= DEFAULT_QUANTITY;

	mov	eax, DWORD PTR _gen_quant_list
	mov	edx, esi
	imul	edx, 368				; 00000170H
	or	DWORD PTR [edx+eax+136], 8192		; 00002000H
	lea	eax, DWORD PTR [edx+eax+136]
	add	esp, 8
	mov	DWORD PTR _gq$[ebp], esi

; 2375 :     if ( web.representation ==  STRING )

	cmp	DWORD PTR _web+624, edi
	jne	SHORT $LN32@convert_to

; 2376 :         meth = new_method_instance("vertex_scalar_integral",inst_name);

	lea	ecx, DWORD PTR _inst_name$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BH@EHAKMPOM@vertex_scalar_integral?$AA@
	call	_new_method_instance
	mov	ecx, eax
	mov	DWORD PTR _meth$[ebp], ecx

; 2377 :     else

	jmp	SHORT $LN142@convert_to
$LN32@convert_to:

; 2378 :         meth = new_method_instance("edge_vector_integral",inst_name);

	lea	edx, DWORD PTR _inst_name$[ebp]
	push	edx
	push	OFFSET ??_C@_0BF@EDOAEIAK@edge_vector_integral?$AA@
	call	_new_method_instance
	mov	ecx, eax
	mov	DWORD PTR _meth$[ebp], eax
$LN142@convert_to:

; 2379 :     METH_INSTANCE(meth)->flags |= IMPLICIT_INSTANCE|DEFAULT_INSTANCE;

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	edx, DWORD PTR _meth_inst_list
	imul	eax, 2928				; 00000b70H
	or	DWORD PTR [eax+edx+140], 6291456	; 00600000H
	add	esp, 8

; 2380 :     attach_method_num(gq,meth);

	push	ecx
	push	esi
	mov	DWORD PTR tv1165[ebp], eax
	call	_attach_method_num
	add	esp, 8

; 2381 :     { vertex_id v_id;
; 2382 :       if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, edi
	jne	$LN30@convert_to

; 2383 :       { FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+48
	test	edx, 268435456				; 10000000H
	je	$LN20@convert_to
	mov	ebx, DWORD PTR _web+12
	npad	2
$LL29@convert_to:
	mov	esi, edx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [ebx+esi]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN28@convert_to

; 2384 :           if ( bdry == get_boundary(v_id) ) 

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN87@convert_to
	mov	edi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edi+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN88@convert_to
$LN87@convert_to:
	xor	eax, eax
$LN88@convert_to:
	cmp	DWORD PTR _bdry$90610[ebp], eax
	jne	SHORT $LN28@convert_to

; 2385 :              apply_quantity(v_id,gq);

	mov	ecx, DWORD PTR _gq$[ebp]
	push	ecx
	push	edx
	call	_apply_quantity
	mov	ebx, DWORD PTR _web+12
	add	esp, 8
$LN28@convert_to:

; 2383 :       { FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR [ebx+esi]
	mov	edx, DWORD PTR [edx]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL29@convert_to

; 2386 :       }
; 2387 :       else 

	jmp	$LN20@convert_to
$LN30@convert_to:

; 2388 :       { FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	test	edx, 268435456				; 10000000H
	je	$LN20@convert_to
	mov	ebx, DWORD PTR _web+124
$LL22@convert_to:
	mov	esi, edx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [ebx+esi]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN21@convert_to

; 2389 :            if ( bdry == get_edge_boundary(e_id) ) 

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN89@convert_to
	mov	edi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edi+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN90@convert_to
$LN89@convert_to:
	xor	eax, eax
$LN90@convert_to:
	cmp	DWORD PTR _bdry$90610[ebp], eax
	jne	SHORT $LN21@convert_to

; 2390 :               apply_quantity(e_id,gq);

	mov	ecx, DWORD PTR _gq$[ebp]
	push	ecx
	push	edx
	call	_apply_quantity
	mov	ebx, DWORD PTR _web+124
	add	esp, 8
$LN21@convert_to:

; 2388 :       { FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR [ebx+esi]
	mov	edx, DWORD PTR [edx]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL22@convert_to
$LN20@convert_to:

; 2391 :       }
; 2392 :     }
; 2393 :     for ( j = 0 ; j < SDIM ; j++ ) 

	mov	esi, DWORD PTR _bdry$90610[ebp]
	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN14@convert_to
	mov	ecx, DWORD PTR tv1165[ebp]
	add	ecx, 232				; 000000e8H
	lea	eax, DWORD PTR [esi+72]
	npad	4
$LL16@convert_to:

; 2394 :        METH_INSTANCE(meth)->expr[j] = bdry->envect[j];

	mov	edi, DWORD PTR [eax]
	mov	ebx, DWORD PTR _meth_inst_list
	mov	DWORD PTR [ecx+ebx], edi
	inc	edx
	add	eax, 4
	add	ecx, 4
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL16@convert_to
$LN14@convert_to:

; 2395 :     bdry->attr |= USURPED_BY_QUANTITY;  /* prevent dual expr deallocation */

	mov	eax, DWORD PTR [esi+36]

; 2396 :     bdry->energy_method = meth;

	mov	ecx, DWORD PTR _meth$[ebp]
	or	DWORD PTR [esi+32], 256			; 00000100H
	mov	ebx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+124], ecx
	mov	edi, 1
$LN37@convert_to:

; 2359 : 
; 2360 : 
; 2361 : 
; 2362 :   /* boundary energy integrals */
; 2363 :   for ( i = 0 ; i < web.bdrymax ; i++ )

	add	DWORD PTR tv1604[ebp], 136		; 00000088H
	add	ebx, edi
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ebx, DWORD PTR _web+768
	jl	$LL38@convert_to
$LN36@convert_to:

; 2397 :   }
; 2398 : 
; 2399 :   /* bodies */
; 2400 :   FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR _web+384
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN11@convert_to
	mov	edi, DWORD PTR _web+348
	npad	3
$LL13@convert_to:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [edi+esi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN12@convert_to

; 2401 :     convert_new_body_to_quantity(b_id);  /* set up individual stuff */

	push	ecx
	call	_convert_new_body_to_quantity
	mov	edi, DWORD PTR _web+348
	add	esp, 4
$LN12@convert_to:

; 2397 :   }
; 2398 : 
; 2399 :   /* bodies */
; 2400 :   FOR_ALL_BODIES(b_id)

	mov	edx, DWORD PTR [edi+esi]
	mov	ecx, DWORD PTR [edx]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL13@convert_to
$LN11@convert_to:

; 2402 :   convert_bodies_to_quantities();  /* add quantities to edges and facets */

	call	_convert_bodies_to_quantities

; 2403 : 
; 2404 :   /* gravity */
; 2405 :   /* if ( web.gravflag ) do it always anyway! */
; 2406 :   {
; 2407 :      sprintf(qname,"gravity_quant");

	lea	eax, DWORD PTR _qname$[ebp]
	push	OFFSET ??_C@_0O@CFGPAHCK@gravity_quant?$AA@
	push	eax
	call	_sprintf

; 2408 :      sprintf(inst_name,"gravity_inst");

	lea	ecx, DWORD PTR _inst_name$[ebp]
	push	OFFSET ??_C@_0N@CPLKLOIP@gravity_inst?$AA@
	push	ecx
	call	_sprintf

; 2409 :      gq = new_quantity(qname,Q_ENERGY);

	mov	ebx, 1
	lea	edx, DWORD PTR _qname$[ebp]
	push	ebx
	push	edx
	call	_new_quantity

; 2410 :      GEN_QUANT(gq)->flags |= DEFAULT_QUANTITY;

	mov	ecx, DWORD PTR _gen_quant_list
	mov	edi, eax
	imul	eax, 368				; 00000170H
	or	DWORD PTR [eax+ecx+136], 8192		; 00002000H

; 2411 :      GEN_QUANT(gq)->modulus = web.grav_const;

	mov	ecx, DWORD PTR _gen_quant_list
	fld	QWORD PTR _web+832
	add	esp, 24					; 00000018H
	fstp	QWORD PTR [eax+ecx+176]

; 2412 :      gravity_quantity_num = gq;

	mov	DWORD PTR _gravity_quantity_num, edi

; 2413 :      if ( web.representation ==  STRING )

	cmp	DWORD PTR _web+624, ebx
	jne	SHORT $LN8@convert_to

; 2414 :         meth = new_method_instance("string_gravity",inst_name);

	lea	edx, DWORD PTR _inst_name$[ebp]
	push	edx
	push	OFFSET ??_C@_0P@MACHNINP@string_gravity?$AA@

; 2415 :      else

	jmp	SHORT $LN143@convert_to
$LN8@convert_to:

; 2416 :         meth = new_method_instance("gravity_method",inst_name);

	lea	eax, DWORD PTR _inst_name$[ebp]
	push	eax
	push	OFFSET ??_C@_0P@OELPPHOM@gravity_method?$AA@
$LN143@convert_to:
	call	_new_method_instance

; 2417 :      METH_INSTANCE(meth)->flags |= IMPLICIT_INSTANCE|DEFAULT_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	esi, eax
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	or	DWORD PTR [eax+ecx+140], 6291456	; 00600000H
	add	esp, 8
	lea	eax, DWORD PTR [eax+ecx+140]

; 2418 :      attach_method_num(gq,meth);

	push	esi
	push	edi
	call	_attach_method_num

; 2419 :      apply_method_num(NULLID,meth);

	push	esi
	push	0
	call	_apply_method_num
	add	esp, 16					; 00000010H

; 2420 :   }
; 2421 : 
; 2422 :   if ( mean_curv_int_flag )

	cmp	DWORD PTR _mean_curv_int_flag, 0
	je	SHORT $LN6@convert_to

; 2423 :      mean_curv_int_quantity_num = 
; 2424 :          add_standard_quantity("mean_curvature_integral",1.0);

	fld1
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BI@KGGFDDEC@mean_curvature_integral?$AA@
	call	_add_standard_quantity
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _mean_curv_int_quantity_num, eax
$LN6@convert_to:

; 2425 : 
; 2426 :   if ( sqgauss_flag )

	cmp	DWORD PTR _sqgauss_flag, 0
	je	SHORT $LN5@convert_to

; 2427 :      add_standard_quantity("sq_gauss_curvature",1.0);

	fld1
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BD@IHBAADBA@sq_gauss_curvature?$AA@
	call	_add_standard_quantity
	add	esp, 12					; 0000000cH
$LN5@convert_to:

; 2428 : 
; 2429 :   /* square mean curvature */
; 2430 :   if ( square_curvature_flag )

	cmp	DWORD PTR _square_curvature_flag, 0
	je	$LN4@convert_to

; 2431 :   {
; 2432 :      sprintf(qname,"sq_mean_curvature_quant");

	lea	edx, DWORD PTR _qname$[ebp]
	push	OFFSET ??_C@_0BI@LBAGEHPE@sq_mean_curvature_quant?$AA@
	push	edx
	call	_sprintf

; 2433 :      sprintf(inst_name,"sq_mean_curvature_inst");

	lea	eax, DWORD PTR _inst_name$[ebp]
	push	OFFSET ??_C@_0BH@CCMBOEAG@sq_mean_curvature_inst?$AA@
	push	eax
	call	_sprintf

; 2434 :      gq = new_quantity(qname,Q_ENERGY);

	lea	ecx, DWORD PTR _qname$[ebp]
	push	1
	push	ecx
	call	_new_quantity
	mov	edi, eax

; 2435 :      GEN_QUANT(gq)->flags |= DEFAULT_QUANTITY;

	mov	eax, DWORD PTR _gen_quant_list
	mov	ebx, edi
	imul	ebx, 368				; 00000170H
	or	DWORD PTR [ebx+eax+136], 8192		; 00002000H
	add	esp, 24					; 00000018H

; 2436 :      sq_mean_curv_quantity_num = gq;
; 2437 :      if ( web.representation ==  STRING )

	cmp	DWORD PTR _web+624, 1
	mov	DWORD PTR _sq_mean_curv_quantity_num, edi
	jne	SHORT $LN3@convert_to

; 2438 :         meth = new_method_instance("sqcurve_string",inst_name);

	lea	edx, DWORD PTR _inst_name$[ebp]
	push	edx
	push	OFFSET ??_C@_0P@GAKMPAOL@sqcurve_string?$AA@

; 2439 :      else

	jmp	SHORT $LN144@convert_to
$LN3@convert_to:

; 2440 :         meth = new_method_instance("sq_mean_curvature",inst_name);

	lea	eax, DWORD PTR _inst_name$[ebp]
	push	eax
	push	OFFSET ??_C@_0BC@GMGIDDOF@sq_mean_curvature?$AA@
$LN144@convert_to:
	call	_new_method_instance

; 2441 :      METH_INSTANCE(meth)->flags |= IMPLICIT_INSTANCE|DEFAULT_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	esi, eax
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	or	DWORD PTR [eax+ecx+140], 6291456	; 00600000H
	add	esp, 8
	lea	eax, DWORD PTR [eax+ecx+140]

; 2442 :      attach_method_num(gq,meth);

	push	esi
	push	edi
	call	_attach_method_num

; 2443 :      apply_method_num(NULLID,meth);

	push	esi
	push	0
	call	_apply_method_num

; 2444 :      GEN_QUANT(gq)->modulus = globals(square_curvature_param)->value.real;

	mov	eax, DWORD PTR _square_curvature_param
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	add	esp, 16					; 00000010H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN91@convert_to
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN93@convert_to
	mov	edx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edx]
	jmp	SHORT $LN92@convert_to
$LN93@convert_to:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN91@convert_to
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN92@convert_to
$LN91@convert_to:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN92@convert_to:
	fld	QWORD PTR [eax+64]
	mov	edx, DWORD PTR _gen_quant_list
	fstp	QWORD PTR [ebx+edx+176]
	mov	ebx, 1
$LN4@convert_to:

; 2445 :   }
; 2446 : 
; 2447 :   if ( web.convex_flag )

	cmp	DWORD PTR _web+840, 0
	je	$LN1@convert_to

; 2448 :   {
; 2449 :      sprintf(qname,"gap_quant");

	lea	eax, DWORD PTR _qname$[ebp]
	push	OFFSET ??_C@_09GGFHGOMM@gap_quant?$AA@
	push	eax
	call	_sprintf

; 2450 :      sprintf(inst_name,"gap_energy");

	lea	ecx, DWORD PTR _inst_name$[ebp]
	push	OFFSET ??_C@_0L@GHOGACAB@gap_energy?$AA@
	push	ecx
	call	_sprintf

; 2451 :      gq = new_quantity(qname,Q_ENERGY);

	lea	edx, DWORD PTR _qname$[ebp]
	push	ebx
	push	edx
	call	_new_quantity

; 2452 :      GEN_QUANT(gq)->flags |= DEFAULT_QUANTITY;

	mov	ecx, DWORD PTR _gen_quant_list
	mov	esi, eax
	imul	eax, 368				; 00000170H
	or	DWORD PTR [eax+ecx+136], 8192		; 00002000H

; 2453 :      gap_quantity_num = gq;
; 2454 :      meth = new_method_instance("gap_energy",inst_name);

	lea	edx, DWORD PTR _inst_name$[ebp]
	lea	eax, DWORD PTR [eax+ecx+136]
	push	edx
	push	OFFSET ??_C@_0L@GHOGACAB@gap_energy?$AA@
	mov	DWORD PTR _gap_quantity_num, esi
	call	_new_method_instance

; 2455 :      METH_INSTANCE(meth)->flags |= IMPLICIT_INSTANCE|DEFAULT_INSTANCE;

	mov	ecx, DWORD PTR _meth_inst_list
	mov	edi, eax
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	or	DWORD PTR [eax+ecx+140], 6291456	; 00600000H
	lea	eax, DWORD PTR [eax+ecx+140]

; 2456 :      attach_method_num(gq,meth);

	push	edi
	push	esi
	call	_attach_method_num

; 2457 :      apply_method_num(NULLID,meth);

	push	edi
	push	0
	call	_apply_method_num
	add	esp, 48					; 00000030H
$LN1@convert_to:

; 2458 :   }
; 2459 : 
; 2460 :   quantities_only_flag = everything_quantities_flag = 1;
; 2461 : 
; 2462 :   outstring("Done.\n");

	push	OFFSET ??_C@_06MJLDIBBJ@Done?4?6?$AA@
	mov	DWORD PTR _everything_quantities_flag, ebx
	mov	DWORD PTR _quantities_only_flag, ebx
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
$LN85@convert_to:

; 2463 : } // end convert_to_quantities()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_convert_to_quantities ENDP
_TEXT	ENDS
END
