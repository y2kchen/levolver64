; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\glutgraph.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@GDACEMPM@Unknown?5error?4?$AA@		; `string'
PUBLIC	??_C@_0KF@KCJBDMIA@GL_INVALID_FRAMEBUFFER_OPERATION@ ; `string'
PUBLIC	??_C@_0OM@CFGFOMAN@GL_OUT_OF_MEMORY?3?5Given?5when?5per@ ; `string'
PUBLIC	??_C@_0NN@LEBFGIGN@GL_INVALID_OPERATION?3?5Given?5when@ ; `string'
PUBLIC	??_C@_0BCD@PMMJKDNI@GL_INVALID_VALUE1?3?5Given?5when?5a?5@ ; `string'
PUBLIC	??_C@_0BDD@KNMHAODA@GL_INVALID_ENUM?3?5Given?5when?5an?5e@ ; `string'
PUBLIC	_gl_errors
PUBLIC	_close_flag
PUBLIC	_no_graphthread_flag
PUBLIC	_vt3
PUBLIC	_vt3p
PUBLIC	_vt2
PUBLIC	_flip
PUBLIC	_flip2D
_BSS	SEGMENT
_mopt	DQ	01cH DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_pickbuf:DWORD:01f4H
COMM	_my_own_pick_flag:DWORD
COMM	_hashsize:DWORD
COMM	_pick_flag:DWORD
COMM	_dup_window:DWORD
COMM	_gthread_data:BYTE:018290H
COMM	_depth_sort:DWORD
COMM	_graph_thread_running:DWORD
COMM	_main_pid:DWORD
COMM	_draw_pid:DWORD
_DATA	ENDS
_BSS	SEGMENT
_close_flag DD	01H DUP (?)
_initz_flag DD	01H DUP (?)
_no_graphthread_flag DD 01H DUP (?)
_l_OpenGL_key DD 01H DUP (?)
_take_snapshot DD 01H DUP (?)
_gl_evolver_mode DD 01H DUP (?)
?FileCounter@?1??TakeScreenshot@@9@9 DD 01H DUP (?)	; `TakeScreenshot'::`2'::FileCounter
_nvidia_gpu_flag DD 01H DUP (?)
_ati_gpu_flag DD 01H DUP (?)
_light_none DD	04H DUP (?)
?FileCounter@?1??draw_screen@@9@9 DD 01H DUP (?)	; `draw_screen'::`2'::FileCounter
_BSS	ENDS
_DATA	SEGMENT
_gl_errors DD	FLAT:??_C@_0BDD@KNMHAODA@GL_INVALID_ENUM?3?5Given?5when?5an?5e@
	DD	FLAT:??_C@_0BCD@PMMJKDNI@GL_INVALID_VALUE1?3?5Given?5when?5a?5@
	DD	FLAT:??_C@_0NN@LEBFGIGN@GL_INVALID_OPERATION?3?5Given?5when@
	DD	FLAT:??_C@_0OM@CFGFOMAN@GL_OUT_OF_MEMORY?3?5Given?5when?5per@
	DD	FLAT:??_C@_0KF@KCJBDMIA@GL_INVALID_FRAMEBUFFER_OPERATION@
	DD	FLAT:??_C@_0P@GDACEMPM@Unknown?5error?4?$AA@
_gleps	DQ	03ee4f8b588e368f1r		; 1e-005
_imagescale DQ	03ff0000000000000r		; 1
_png_path_filename DB '.', 00H
	ORG $+1022
_vt3	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	0bff0000000000000r		; -1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
_vt3p	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
_vt2	DQ	04000000000000000r		; 2
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	0c000000000000000r		; -2
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	04000000000000000r		; 2
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
_flip	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	0bff0000000000000r		; -1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
_flip2D	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	0bff0000000000000r		; -1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	03ff0000000000000r		; 1
_dindex	DD	01H
_my_own_pick_transmat DD FLAT:_mopt
	DD	FLAT:_mopt+56
	DD	FLAT:_mopt+112
	DD	FLAT:_mopt+168
_mat_white DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
	DD	03f800000r			; 1
_light0_position DD 03f800000r			; 1
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
_light0_diffuse DD 03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f800000r			; 1
_light0_ambient DD 03e99999ar			; 0.3
	DD	03e99999ar			; 0.3
	DD	03e99999ar			; 0.3
	DD	03f800000r			; 1
_light1_position DD 000000000r			; 0
	DD	000000000r			; 0
	DD	03f800000r			; 1
	DD	000000000r			; 0
_light1_diffuse DD 03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f000000r			; 0.5
	DD	03f800000r			; 1
_DATA	ENDS
;	COMDAT ??_C@_0P@GDACEMPM@Unknown?5error?4?$AA@
CONST	SEGMENT
??_C@_0P@GDACEMPM@Unknown?5error?4?$AA@ DB 'Unknown error.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0KF@KCJBDMIA@GL_INVALID_FRAMEBUFFER_OPERATION@
CONST	SEGMENT
??_C@_0KF@KCJBDMIA@GL_INVALID_FRAMEBUFFER_OPERATION@ DB 'GL_INVALID_FRAME'
	DB	'BUFFER_OPERATION: Given when doing anything that would attemp'
	DB	't to read from or write/render to a framebuffer that is not c'
	DB	'omplete, as defined here. ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0OM@CFGFOMAN@GL_OUT_OF_MEMORY?3?5Given?5when?5per@
CONST	SEGMENT
??_C@_0OM@CFGFOMAN@GL_OUT_OF_MEMORY?3?5Given?5when?5per@ DB 'GL_OUT_OF_ME'
	DB	'MORY: Given when performing an operation that can allocate me'
	DB	'mory, but the memory cannot be allocated. The results of Open'
	DB	'GL functions that return this error are undefined; it is allo'
	DB	'wable for partial operations to happen. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0NN@LEBFGIGN@GL_INVALID_OPERATION?3?5Given?5when@
CONST	SEGMENT
??_C@_0NN@LEBFGIGN@GL_INVALID_OPERATION?3?5Given?5when@ DB 'GL_INVALID_OP'
	DB	'ERATION: Given when the set of state for a command is not leg'
	DB	'al for the parameters given to that command. It is also given'
	DB	' for commands where combinations of parameters define what th'
	DB	'e legal parameters are. ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BCD@PMMJKDNI@GL_INVALID_VALUE1?3?5Given?5when?5a?5@
CONST	SEGMENT
??_C@_0BCD@PMMJKDNI@GL_INVALID_VALUE1?3?5Given?5when?5a?5@ DB 'GL_INVALID'
	DB	'_VALUE1: Given when a value parameter is not a legal value fo'
	DB	'r that function. This is only given for local problems; if th'
	DB	'e spec allows the value in certain circumstances, and other p'
	DB	'arameters or state dictate those circumstances, then GL_INVAL'
	DB	'ID_OPERATION is the result instead. ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BDD@KNMHAODA@GL_INVALID_ENUM?3?5Given?5when?5an?5e@
CONST	SEGMENT
??_C@_0BDD@KNMHAODA@GL_INVALID_ENUM?3?5Given?5when?5an?5e@ DB 'GL_INVALID'
	DB	'_ENUM: Given when an enumeration parameter is not a legal enu'
	DB	'meration for that function. This is given only for local prob'
	DB	'lems; if the spec allows the enumeration in certain circumsta'
	DB	'nces, and other parameters or state dictate those circumstanc'
	DB	'es, then GL_INVALID_OPERATION is the result instead.', 00H ; `string'
CONST	ENDS
EXTRN	___glutInitWithExit@12:PROC
EXTRN	_exit:PROC
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\glut\glut.h
;	COMDAT _glutInit_ATEXIT_HACK@8
_TEXT	SEGMENT
_glutInit_ATEXIT_HACK@8 PROC				; COMDAT
; _argcp$ = ecx
; _argv$ = eax

; 486  : static void APIENTRY glutInit_ATEXIT_HACK(int *argcp, char **argv) { __glutInitWithExit(argcp, argv, exit); }

	push	OFFSET _exit
	push	eax
	push	ecx
	call	___glutInitWithExit@12
	ret	0
_glutInit_ATEXIT_HACK@8 ENDP
_TEXT	ENDS
EXTRN	___glutCreateWindowWithExit@8:PROC
; Function compile flags: /Ogtp
;	COMDAT _glutCreateWindow_ATEXIT_HACK@4
_TEXT	SEGMENT
_glutCreateWindow_ATEXIT_HACK@4 PROC			; COMDAT
; _title$ = eax

; 503  : static int APIENTRY glutCreateWindow_ATEXIT_HACK(const char *title) { return __glutCreateWindowWithExit(title, exit); }

	push	OFFSET _exit
	push	eax
	call	___glutCreateWindowWithExit@8
	ret	0
_glutCreateWindow_ATEXIT_HACK@4 ENDP
_TEXT	ENDS
EXTRN	___glutCreateMenuWithExit@8:PROC
; Function compile flags: /Ogtp
;	COMDAT _glutCreateMenu_ATEXIT_HACK@4
_TEXT	SEGMENT
_glutCreateMenu_ATEXIT_HACK@4 PROC			; COMDAT
; _func$ = eax

; 549  : static int APIENTRY glutCreateMenu_ATEXIT_HACK(void (GLUTCALLBACK *func)(int)) { return __glutCreateMenuWithExit(func, exit); }

	push	OFFSET _exit
	push	eax
	call	___glutCreateMenuWithExit@8
	ret	0
_glutCreateMenu_ATEXIT_HACK@4 ENDP
_TEXT	ENDS
EXTRN	__localtime64:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _localtime
_TEXT	SEGMENT
_localtime PROC						; COMDAT
; __Time$ = eax

; 114  : #pragma warning( push )
; 115  : #pragma warning( disable : 4996 )
; 116  :     return _localtime64(_Time);

	push	eax
	call	__localtime64
	add	esp, 4

; 117  : #pragma warning( pop )
; 118  : }

	ret	0
_localtime ENDP
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

	push	eax
	call	__time64
	add	esp, 4

; 134  : }

	ret	0
_time	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@COIOJKIC@Can?8t?5allocate?5memory?5for?5PNG?5fi@ ; `string'
PUBLIC	??_C@_06PIBLOKJG@1?42?418?$AA@			; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	_read_png
EXTRN	_free:PROC
EXTRN	_png_read_image:PROC
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
EXTRN	_malloc:PROC
EXTRN	_png_set_packing:PROC
EXTRN	_png_set_strip_16:PROC
EXTRN	_png_set_strip_alpha:PROC
EXTRN	_png_set_gray_to_rgb:PROC
EXTRN	_png_set_expand:PROC
EXTRN	_png_get_IHDR:PROC
EXTRN	_png_read_info:PROC
EXTRN	_png_init_io:PROC
EXTRN	_png_destroy_read_struct:PROC
EXTRN	_png_create_info_struct:PROC
EXTRN	_fclose:PROC
EXTRN	_png_create_read_struct:PROC
EXTRN	_fopen:PROC
EXTRN	_memcpy:PROC
EXTRN	__setjmp3:PROC
;	COMDAT ??_C@_0CF@COIOJKIC@Can?8t?5allocate?5memory?5for?5PNG?5fi@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\lpng1218\xplanet_png.c
CONST	SEGMENT
??_C@_0CF@COIOJKIC@Can?8t?5allocate?5memory?5for?5PNG?5fi@ DB 'Can''t all'
	DB	'ocate memory for PNG file.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PIBLOKJG@1?42?418?$AA@
CONST	SEGMENT
??_C@_06PIBLOKJG@1?42?418?$AA@ DB '1.2.18', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _read_png
_TEXT	SEGMENT
_interlace_type$ = -36					; size = 4
_h$ = -32						; size = 4
_w$ = -28						; size = 4
_bit_depth$ = -24					; size = 4
_infile$ = -20						; size = 4
_ptr$ = -16						; size = 4
_color_type$ = -12					; size = 4
_info_ptr$ = -8						; size = 4
_png_ptr$ = -4						; size = 4
_filename$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_rgb$ = 20						; size = 4
_read_png PROC						; COMDAT

; 30   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 31   :     FILE *infile = fopen(filename, "rb");

	mov	eax, DWORD PTR _filename$[ebp]
	push	ebx
	push	esi
	push	edi
	push	OFFSET ??_C@_02JDPG@rb?$AA@
	push	eax
	call	_fopen

; 32   : 
; 33   :     png_structp png_ptr;
; 34   :     png_infop info_ptr;
; 35   :     png_bytepp row_pointers;
; 36   :     unsigned char *ptr = NULL;
; 37   :     png_uint_32 w, h;
; 38   :     int bit_depth, color_type, interlace_type;
; 39   :     int i;
; 40   : 
; 41   :     png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, 
; 42   :                                      (png_voidp) NULL, 
; 43   :                                      (png_error_ptr) NULL, 
; 44   :                                      (png_error_ptr) NULL);

	push	0
	push	0
	mov	esi, eax
	push	0
	push	OFFSET ??_C@_06PIBLOKJG@1?42?418?$AA@
	mov	DWORD PTR _infile$[ebp], esi
	call	_png_create_read_struct
	add	esp, 24					; 00000018H
	mov	DWORD PTR _png_ptr$[ebp], eax

; 45   :     if (!png_ptr) 

	test	eax, eax
	jne	SHORT $LN19@read_png

; 46   :     {
; 47   :         fclose(infile);

	push	esi
	call	_fclose
	add	esp, 4

; 48   :         return(0);

	xor	eax, eax

; 127  :     return(1);
; 128  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@read_png:

; 49   :     }
; 50   :   
; 51   :     info_ptr = png_create_info_struct(png_ptr);

	push	eax
	call	_png_create_info_struct
	add	esp, 4
	mov	DWORD PTR _info_ptr$[ebp], eax

; 52   :     if (!info_ptr)
; 53   :     {
; 54   :         png_destroy_read_struct(&png_ptr, (png_infopp) NULL, 
; 55   :                                 (png_infopp) NULL);

	push	0
	test	eax, eax
	jne	SHORT $LN18@read_png
	push	eax
	lea	ecx, DWORD PTR _png_ptr$[ebp]
	push	ecx
	call	_png_destroy_read_struct

; 56   :         fclose(infile);

	push	esi
	call	_fclose
	add	esp, 16					; 00000010H

; 57   :         return(0);

	xor	eax, eax

; 127  :     return(1);
; 128  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@read_png:

; 58   :     }
; 59   :   
; 60   :     if (setjmp(png_ptr->jmpbuf))

	mov	edx, DWORD PTR _png_ptr$[ebp]
	push	edx
	call	__setjmp3
	add	esp, 8
	test	eax, eax
	je	SHORT $LN17@read_png

; 61   :     {
; 62   :         png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp) NULL);

	push	0
	lea	eax, DWORD PTR _info_ptr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _png_ptr$[ebp]
	push	ecx
	call	_png_destroy_read_struct

; 63   :         fclose(infile);

	mov	edx, DWORD PTR _infile$[ebp]
	push	edx
	call	_fclose
	add	esp, 16					; 00000010H

; 64   :         return(0);

	xor	eax, eax

; 127  :     return(1);
; 128  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@read_png:

; 65   :     }
; 66   :   
; 67   :     png_init_io(png_ptr, infile);

	mov	eax, DWORD PTR _infile$[ebp]
	mov	ecx, DWORD PTR _png_ptr$[ebp]
	push	eax
	push	ecx
	call	_png_init_io

; 68   :     png_read_info(png_ptr, info_ptr);

	mov	edx, DWORD PTR _info_ptr$[ebp]
	mov	eax, DWORD PTR _png_ptr$[ebp]
	push	edx
	push	eax
	call	_png_read_info

; 69   : 
; 70   :     png_get_IHDR(png_ptr, info_ptr, &w, &h, &bit_depth, &color_type,
; 71   :                  &interlace_type, (int *) NULL, (int *) NULL);

	push	0
	push	0
	lea	ecx, DWORD PTR _interlace_type$[ebp]
	push	ecx
	lea	edx, DWORD PTR _color_type$[ebp]
	push	edx
	lea	eax, DWORD PTR _bit_depth$[ebp]
	push	eax
	mov	eax, DWORD PTR _info_ptr$[ebp]
	lea	ecx, DWORD PTR _h$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _png_ptr$[ebp]
	lea	edx, DWORD PTR _w$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_png_get_IHDR

; 72   : 
; 73   :     *width = (int) w;

	mov	eax, DWORD PTR _width$[ebp]
	mov	edx, DWORD PTR _w$[ebp]

; 74   :     *height = (int) h;

	mov	ebx, DWORD PTR _height$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [eax], edx

; 75   : 
; 76   :     /* Change a paletted/grayscale image to RGB */
; 77   :     if (color_type == PNG_COLOR_TYPE_PALETTE && bit_depth <= 8) 

	mov	eax, DWORD PTR _color_type$[ebp]
	add	esp, 52					; 00000034H
	mov	DWORD PTR [ebx], ecx
	cmp	eax, 3
	jne	SHORT $LN16@read_png
	cmp	DWORD PTR _bit_depth$[ebp], 8
	jg	SHORT $LN16@read_png

; 78   :         png_set_expand(png_ptr);

	mov	edx, DWORD PTR _png_ptr$[ebp]
	push	edx
	call	_png_set_expand
	mov	eax, DWORD PTR _color_type$[ebp]
	add	esp, 4
$LN16@read_png:

; 79   : 
; 80   :     /* Change a grayscale image to RGB */
; 81   :     if (color_type == PNG_COLOR_TYPE_GRAY 
; 82   :         || color_type == PNG_COLOR_TYPE_GRAY_ALPHA)

	test	eax, eax
	je	SHORT $LN14@read_png
	cmp	eax, 4
	jne	SHORT $LN15@read_png
$LN14@read_png:

; 83   :         png_set_gray_to_rgb(png_ptr);

	mov	eax, DWORD PTR _png_ptr$[ebp]
	push	eax
	call	_png_set_gray_to_rgb
	mov	eax, DWORD PTR _color_type$[ebp]
	add	esp, 4
$LN15@read_png:

; 84   : 
; 85   :     /* Don't need the alpha channel */
; 86   :     if (color_type & PNG_COLOR_MASK_ALPHA) png_set_strip_alpha(png_ptr);

	test	al, 4
	je	SHORT $LN13@read_png
	mov	ecx, DWORD PTR _png_ptr$[ebp]
	push	ecx
	call	_png_set_strip_alpha
	add	esp, 4
$LN13@read_png:

; 87   :  
; 88   :     /* If the PNG file has 16 bits per channel, strip them down to 8 */
; 89   :     if (bit_depth == 16) png_set_strip_16(png_ptr);

	cmp	DWORD PTR _bit_depth$[ebp], 16		; 00000010H
	jne	SHORT $LN12@read_png
	mov	edx, DWORD PTR _png_ptr$[ebp]
	push	edx
	call	_png_set_strip_16
	add	esp, 4
$LN12@read_png:

; 90   : 
; 91   :     /* use 1 byte per pixel */
; 92   :     png_set_packing(png_ptr);

	mov	eax, DWORD PTR _png_ptr$[ebp]
	push	eax
	call	_png_set_packing

; 93   : 
; 94   :     row_pointers = malloc(*height * sizeof(png_bytep));

	mov	eax, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	call	_malloc
	mov	edi, eax
	add	esp, 8

; 95   :     if (row_pointers == NULL)

	test	edi, edi
	jne	SHORT $LN11@read_png

; 96   :     {
; 97   :         fprintf(stderr, "Can't allocate memory for PNG file.\n");

	push	OFFSET ??_C@_0CF@COIOJKIC@Can?8t?5allocate?5memory?5for?5PNG?5fi@
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 8

; 98   :         return(0);

	xor	eax, eax

; 127  :     return(1);
; 128  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@read_png:

; 99   :     }
; 100  : 
; 101  :     for (i = 0; i < *height; i++)

	xor	esi, esi
	cmp	DWORD PTR [ebx], esi
	jle	SHORT $LN8@read_png
	npad	7
$LL10@read_png:

; 102  :     {
; 103  :         row_pointers[i] = malloc(3 * *width * sizeof(png_byte));

	mov	edx, DWORD PTR _width$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	eax, DWORD PTR [eax+eax*2]
	push	eax
	call	_malloc
	mov	DWORD PTR [edi+esi*4], eax
	inc	esi
	add	esp, 4
	cmp	esi, DWORD PTR [ebx]
	jl	SHORT $LL10@read_png
$LN8@read_png:

; 104  :         if (row_pointers == NULL)
; 105  :         {
; 106  :             fprintf(stderr, "Can't allocate memory for PNG line.\n");
; 107  :             return(0);
; 108  :         }
; 109  :     }
; 110  : 
; 111  :     png_read_image(png_ptr, row_pointers);

	mov	ecx, DWORD PTR _png_ptr$[ebp]
	push	edi
	push	ecx
	call	_png_read_image

; 112  :   
; 113  :     ptr = rgb;

	mov	edx, DWORD PTR _rgb$[ebp]

; 114  : 
; 115  :     for (i = 0; i < *height; i++)

	xor	esi, esi
	add	esp, 8
	mov	DWORD PTR _ptr$[ebp], edx
	cmp	DWORD PTR [ebx], esi
	jle	SHORT $LN4@read_png
	mov	eax, DWORD PTR _width$[ebp]
	mov	eax, DWORD PTR [eax]
	lea	eax, DWORD PTR [eax+eax*2]
$LN6@read_png:

; 116  :     {
; 117  :         memcpy(ptr, row_pointers[i], 3 * *width);

	mov	ecx, DWORD PTR [edi+esi*4]
	mov	edx, DWORD PTR _ptr$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_memcpy

; 118  :         ptr += 3 * *width;

	mov	eax, DWORD PTR _width$[ebp]
	mov	eax, DWORD PTR [eax]
	lea	eax, DWORD PTR [eax+eax*2]
	add	DWORD PTR _ptr$[ebp], eax
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, DWORD PTR [ebx]
	jl	SHORT $LN6@read_png
$LN4@read_png:

; 119  :     }
; 120  : 
; 121  :     png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp) NULL);

	push	0
	lea	ecx, DWORD PTR _info_ptr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _png_ptr$[ebp]
	push	edx
	call	_png_destroy_read_struct

; 122  : 
; 123  :     for (i = 0; i < *height; i++) free(row_pointers[i]);

	xor	esi, esi
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [ebx], esi
	jle	SHORT $LN1@read_png
$LL3@read_png:
	mov	eax, DWORD PTR [edi+esi*4]
	push	eax
	call	_free
	inc	esi
	add	esp, 4
	cmp	esi, DWORD PTR [ebx]
	jl	SHORT $LL3@read_png
$LN1@read_png:

; 124  :     free(row_pointers);

	push	edi
	call	_free

; 125  : 
; 126  :     fclose(infile);

	mov	ecx, DWORD PTR _infile$[ebp]
	push	ecx
	call	_fclose
	add	esp, 8

; 127  :     return(1);
; 128  : }

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_read_png ENDP
_TEXT	ENDS
PUBLIC	_write_png
EXTRN	_png_write_end:PROC
EXTRN	_png_write_rows:PROC
EXTRN	_png_write_info:PROC
EXTRN	_png_set_IHDR:PROC
EXTRN	_png_destroy_write_struct:PROC
EXTRN	_png_create_write_struct:PROC
; Function compile flags: /Ogtp
;	COMDAT _write_png
_TEXT	SEGMENT
_rgba$10817 = -16					; size = 4
_row_ptr$ = -12						; size = 4
_info_ptr$ = -8						; size = 4
_png_ptr$ = -4						; size = 4
_outfile$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_rgb$ = 20						; size = 4
_alpha$ = 24						; size = 4
_write_png PROC						; COMDAT

; 133  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 134  :     png_structp png_ptr;
; 135  :     png_infop info_ptr;
; 136  :     png_bytep row_ptr;
; 137  : 
; 138  :     int i;
; 139  : 
; 140  :     png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, 
; 141  :                                       (png_voidp) NULL, 
; 142  :                                       (png_error_ptr) NULL, 
; 143  :                                       (png_error_ptr) NULL);

	push	0
	push	0
	push	0
	push	OFFSET ??_C@_06PIBLOKJG@1?42?418?$AA@
	call	_png_create_write_struct
	add	esp, 16					; 00000010H
	mov	DWORD PTR _png_ptr$[ebp], eax

; 144  : 
; 145  :     if (!png_ptr) return(0);

	test	eax, eax
	je	SHORT $LN22@write_png

; 146  :   
; 147  :     info_ptr = png_create_info_struct(png_ptr);

	push	eax
	call	_png_create_info_struct
	add	esp, 4
	mov	DWORD PTR _info_ptr$[ebp], eax

; 148  :     if (!info_ptr)

	test	eax, eax
	jne	SHORT $LN12@write_png

; 149  :     {
; 150  :         png_destroy_write_struct(&png_ptr, (png_infopp) NULL);

	push	eax
	lea	eax, DWORD PTR _png_ptr$[ebp]
	push	eax
	call	_png_destroy_write_struct
	add	esp, 8
$LN22@write_png:

; 151  :         return(0);

	xor	eax, eax

; 206  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@write_png:

; 152  :     }
; 153  :   
; 154  :     png_init_io(png_ptr, outfile);

	mov	ecx, DWORD PTR _outfile$[ebp]
	mov	edx, DWORD PTR _png_ptr$[ebp]
	push	ebx
	push	esi
	push	edi
	push	ecx
	push	edx
	call	_png_init_io

; 155  : 
; 156  :     if (alpha == NULL)

	mov	ebx, DWORD PTR _alpha$[ebp]

; 157  :     {
; 158  : 	png_set_IHDR(png_ptr, info_ptr, width, height, 8, PNG_COLOR_TYPE_RGB,
; 159  : 		     PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT,
; 160  : 		     PNG_FILTER_TYPE_DEFAULT);

	mov	esi, DWORD PTR _width$[ebp]
	add	esp, 8
	test	ebx, ebx
	jne	SHORT $LN11@write_png
	mov	edi, DWORD PTR _height$[ebp]
	mov	eax, DWORD PTR _info_ptr$[ebp]
	mov	ecx, DWORD PTR _png_ptr$[ebp]
	push	ebx
	push	ebx
	push	ebx
	push	2
	push	8
	push	edi
	push	esi
	push	eax
	push	ecx
	call	_png_set_IHDR

; 161  : 	
; 162  : 	png_write_info(png_ptr, info_ptr);

	mov	edx, DWORD PTR _info_ptr$[ebp]
	mov	eax, DWORD PTR _png_ptr$[ebp]
	push	edx
	push	eax
	call	_png_write_info
	add	esp, 44					; 0000002cH

; 163  : 	
; 164  : 	for (i = 0; i < height; i++) 

	test	edi, edi
	jle	$LN7@write_png

; 157  :     {
; 158  : 	png_set_IHDR(png_ptr, info_ptr, width, height, 8, PNG_COLOR_TYPE_RGB,
; 159  : 		     PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT,
; 160  : 		     PNG_FILTER_TYPE_DEFAULT);

	lea	ebx, DWORD PTR [esi+esi*2]
	mov	esi, DWORD PTR _rgb$[ebp]
$LL10@write_png:

; 165  : 	{
; 166  : 	    row_ptr = rgb + 3 * i * width;
; 167  : 	    png_write_rows(png_ptr, &row_ptr, 1);

	mov	edx, DWORD PTR _png_ptr$[ebp]
	push	1
	lea	ecx, DWORD PTR _row_ptr$[ebp]
	push	ecx
	push	edx
	mov	DWORD PTR _row_ptr$[ebp], esi
	call	_png_write_rows
	add	esp, 12					; 0000000cH
	add	esi, ebx
	dec	edi
	jne	SHORT $LL10@write_png

; 168  : 	}
; 169  :     }
; 170  :     else

	jmp	$LN7@write_png
$LN11@write_png:

; 173  : 	int irgba = 0;
; 174  : 
; 175  : 	int area = width * height;

	mov	edi, esi
	imul	edi, DWORD PTR _height$[ebp]

; 176  : 	unsigned char *rgba = malloc(4 * area);

	lea	eax, DWORD PTR [edi*4]
	push	eax
	call	_malloc

; 177  : 
; 178  : 	png_set_IHDR(png_ptr, info_ptr, width, height, 8, 
; 179  : 		     PNG_COLOR_TYPE_RGB_ALPHA,
; 180  : 		     PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT,
; 181  : 		     PNG_FILTER_TYPE_DEFAULT);

	mov	ecx, DWORD PTR _height$[ebp]
	mov	edx, DWORD PTR _info_ptr$[ebp]
	push	0
	push	0
	push	0
	push	6
	push	8
	push	ecx
	push	esi
	mov	DWORD PTR _rgba$10817[ebp], eax
	mov	eax, DWORD PTR _png_ptr$[ebp]
	push	edx
	push	eax
	call	_png_set_IHDR

; 182  : 	
; 183  : 	png_write_info(png_ptr, info_ptr);

	mov	ecx, DWORD PTR _info_ptr$[ebp]
	mov	edx, DWORD PTR _png_ptr$[ebp]
	push	ecx
	push	edx
	call	_png_write_info
	add	esp, 48					; 00000030H

; 184  : 	
; 185  : 	for (i = 0; i < area; i++)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN4@write_png

; 171  :     {
; 172  : 	int irgb = 0;

	mov	eax, DWORD PTR _rgba$10817[ebp]
	mov	ecx, DWORD PTR _rgb$[ebp]
$LL6@write_png:

; 186  : 	{
; 187  : 	    rgba[irgba++] = rgb[irgb++];

	movzx	edx, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 188  : 	    rgba[irgba++] = rgb[irgb++];

	movzx	edx, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 189  : 	    rgba[irgba++] = rgb[irgb++];

	movzx	edx, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 190  : 	    rgba[irgba++] = alpha[i];

	movzx	edx, BYTE PTR [esi+ebx]
	mov	BYTE PTR [eax+3], dl
	inc	esi
	add	ecx, 3
	add	eax, 4
	cmp	esi, edi
	jl	SHORT $LL6@write_png
$LN4@write_png:

; 191  : 	}
; 192  : 	
; 193  : 	for (i = 0; i < height; i++) 

	cmp	DWORD PTR _height$[ebp], 0
	jle	SHORT $LN1@write_png
	mov	ebx, DWORD PTR _width$[ebp]
	mov	esi, DWORD PTR _rgba$10817[ebp]
	mov	edi, DWORD PTR _height$[ebp]
	add	ebx, ebx
	add	ebx, ebx
	npad	4
$LL3@write_png:

; 194  : 	{
; 195  : 	    row_ptr = rgba + 4 * i * width;
; 196  : 	    png_write_rows(png_ptr, &row_ptr, 1);

	mov	ecx, DWORD PTR _png_ptr$[ebp]
	push	1
	lea	eax, DWORD PTR _row_ptr$[ebp]
	push	eax
	push	ecx
	mov	DWORD PTR _row_ptr$[ebp], esi
	call	_png_write_rows
	add	esp, 12					; 0000000cH
	add	esi, ebx
	dec	edi
	jne	SHORT $LL3@write_png
$LN1@write_png:

; 197  : 	}
; 198  : 
; 199  : 	free(rgba);

	mov	edx, DWORD PTR _rgba$10817[ebp]
	push	edx
	call	_free
	add	esp, 4
$LN7@write_png:

; 200  :     }
; 201  : 
; 202  :     png_write_end(png_ptr, info_ptr);

	mov	eax, DWORD PTR _info_ptr$[ebp]
	mov	ecx, DWORD PTR _png_ptr$[ebp]
	push	eax
	push	ecx
	call	_png_write_end

; 203  :     png_destroy_write_struct(&png_ptr, &info_ptr);

	lea	edx, DWORD PTR _info_ptr$[ebp]
	push	edx
	lea	eax, DWORD PTR _png_ptr$[ebp]
	push	eax
	call	_png_destroy_write_struct
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 204  : 
; 205  :     return(1);

	mov	eax, 1
	pop	ebx

; 206  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_write_png ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_set_graphics_title
EXTRN	_update_display:PROC
EXTRN	_strncpy:PROC
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\glutgraph.c
;	COMDAT _set_graphics_title
_TEXT	SEGMENT
_which$ = 8						; size = 4
_title$ = 12						; size = 4
_set_graphics_title PROC				; COMDAT

; 251  : { if ( which < 0 || which >= MAXGRAPHWINDOWS ) return;

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _which$[ebp]
	cmp	esi, 9
	ja	SHORT $LN1@set_graphi

; 252  :   strncpy(gthread_data[which].wintitle,title,WINTITLESIZE);

	mov	eax, DWORD PTR _title$[ebp]
	imul	esi, 9896				; 000026a8H
	push	120					; 00000078H
	push	eax
	lea	ecx, DWORD PTR _gthread_data[esi+8]
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 253  :   gthread_data[which].new_title_flag = 1;

	mov	DWORD PTR _gthread_data[esi+4], 1
	pop	esi

; 255  : }

	pop	ebp

; 254  :   update_display();

	jmp	_update_display
$LN1@set_graphi:
	pop	esi

; 255  : }

	pop	ebp
	ret	0
_set_graphics_title ENDP
_TEXT	ENDS
PUBLIC	_setOpenGL_key
; Function compile flags: /Ogtp
;	COMDAT _setOpenGL_key
_TEXT	SEGMENT
_setOpenGL_key PROC					; COMDAT

; 308  : void setOpenGL_key(){l_OpenGL_key = LEVOLVER_WAITING_FOR_OPENGL_KEYPRESS;}

	mov	DWORD PTR _l_OpenGL_key, 0
	ret	0
_setOpenGL_key ENDP
_TEXT	ENDS
PUBLIC	_getOpenGL_key
; Function compile flags: /Ogtp
;	COMDAT _getOpenGL_key
_TEXT	SEGMENT
_getOpenGL_key PROC					; COMDAT

; 309  : unsigned getOpenGL_key(){return l_OpenGL_key ;}

	mov	eax, DWORD PTR _l_OpenGL_key
	ret	0
_getOpenGL_key ENDP
_TEXT	ENDS
PUBLIC	_ActivatePngPathLogic
; Function compile flags: /Ogtp
;	COMDAT _ActivatePngPathLogic
_TEXT	SEGMENT
_lfname$ = 8						; size = 4
_ActivatePngPathLogic PROC				; COMDAT

; 317  : {

	push	ebp
	mov	ebp, esp

; 318  : 	strcpy(png_path_filename, lfname);

	mov	eax, DWORD PTR _lfname$[ebp]
	mov	edx, OFFSET _png_path_filename
	sub	edx, eax
	npad	3
$LL3@ActivatePn:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@ActivatePn

; 319  : 	gl_evolver_mode = TRUE;

	mov	DWORD PTR _gl_evolver_mode, 1

; 320  : }

	pop	ebp
	ret	0
_ActivatePngPathLogic ENDP
_TEXT	ENDS
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_04EEOGCCFB@?4png?$AA@			; `string'
PUBLIC	??_C@_0BJ@CJNCHCIE@?$CF4u?$CF02u?$CF02u_?$CF02u?$CF02u?$CF02u?$AA@ ; `string'
PUBLIC	??_C@_03NNHBJLDF@png?$AA@			; `string'
PUBLIC	??_C@_0BA@KIFGKKAI@Save?5screenshot?$AA@	; `string'
PUBLIC	??_C@_0BP@FLKALCJG@PNG?5Image?$AA?$CK?4png?$AAAny?5file?$AA?$CK?4?$CK?$AA?$AA?$AA@ ; `string'
PUBLIC	??_C@_0M@IIFJGMNN@Screenshot_?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_TakeScreenshot
EXTRN	__imp__Sleep@4:PROC
EXTRN	_remove:PROC
EXTRN	__imp__glReadPixels@28:PROC
EXTRN	__imp__glPixelStorei@8:PROC
EXTRN	__imp__glFinish@0:PROC
EXTRN	__imp__glFlush@0:PROC
EXTRN	_fputs:PROC
EXTRN	_strrchr:PROC
EXTRN	__imp__GetSaveFileNameA@4:PROC
EXTRN	_fgets:PROC
EXTRN	_sprintf:PROC
EXTRN	__imp__GetActiveWindow@0:PROC
EXTRN	_calloc:PROC
EXTRN	_glutGetWindow@0:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EEOGCCFB@?4png?$AA@
CONST	SEGMENT
??_C@_04EEOGCCFB@?4png?$AA@ DB '.png', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CJNCHCIE@?$CF4u?$CF02u?$CF02u_?$CF02u?$CF02u?$CF02u?$AA@
CONST	SEGMENT
??_C@_0BJ@CJNCHCIE@?$CF4u?$CF02u?$CF02u_?$CF02u?$CF02u?$CF02u?$AA@ DB '%4'
	DB	'u%02u%02u_%02u%02u%02u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NNHBJLDF@png?$AA@
CONST	SEGMENT
??_C@_03NNHBJLDF@png?$AA@ DB 'png', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KIFGKKAI@Save?5screenshot?$AA@
CONST	SEGMENT
??_C@_0BA@KIFGKKAI@Save?5screenshot?$AA@ DB 'Save screenshot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FLKALCJG@PNG?5Image?$AA?$CK?4png?$AAAny?5file?$AA?$CK?4?$CK?$AA?$AA?$AA@
CONST	SEGMENT
??_C@_0BP@FLKALCJG@PNG?5Image?$AA?$CK?4png?$AAAny?5file?$AA?$CK?4?$CK?$AA?$AA?$AA@ DB 'P'
	DB	'NG Image', 00H, '*.png', 00H, 'Any file', 00H, '*.*', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IIFJGMNN@Screenshot_?$AA@
CONST	SEGMENT
??_C@_0M@IIFJGMNN@Screenshot_?$AA@ DB 'Screenshot_', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\glutgraph.c
CONST	ENDS
;	COMDAT _TakeScreenshot
_TEXT	SEGMENT
_ofn$94529 = -2160					; size = 88
_tim$ = -2072						; size = 8
_swapY$94554 = -2064					; size = 4
_td$ = -2060						; size = 4
_y$ = -2056						; size = 4
_fname$ = -2052						; size = 1024
_stemp$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_AskFileName$ = 8					; size = 4
_TakeScreenshot PROC					; COMDAT

; 325  : void TakeScreenshot(BOOL AskFileName){

	push	ebp
	mov	ebp, esp
	sub	esp, 2160				; 00000870H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi

; 326  : 	//xsize, ysize contain the window size. So create a 24 bit bitmap.
; 327  : 	struct graph_thread_data *td = GET_DATA;

	call	_glutGetWindow@0
	imul	eax, 9896				; 000026a8H
	add	eax, OFFSET _gthread_data

; 328  : 	int bmp_size = 3*td->xsize*td->ysize, x, y;

	mov	ecx, DWORD PTR [eax+252]
	imul	ecx, DWORD PTR [eax+248]
	mov	DWORD PTR _td$[ebp], eax
	lea	eax, DWORD PTR [ecx+ecx*2]

; 329  : 	unsigned char t, *bmp = calloc(bmp_size, 1);

	push	1
	push	eax
	call	_calloc

; 330  : 	char fname[1024] = "Screenshot_";

	mov	ecx, DWORD PTR ??_C@_0M@IIFJGMNN@Screenshot_?$AA@
	mov	edx, DWORD PTR ??_C@_0M@IIFJGMNN@Screenshot_?$AA@+4
	push	1012					; 000003f4H
	mov	DWORD PTR _fname$[ebp], ecx
	xor	esi, esi
	mov	ebx, eax
	mov	eax, DWORD PTR ??_C@_0M@IIFJGMNN@Screenshot_?$AA@+8
	lea	ecx, DWORD PTR _fname$[ebp+12]
	push	esi
	push	ecx
	mov	DWORD PTR _fname$[ebp+4], edx
	mov	DWORD PTR _fname$[ebp+8], eax
	call	_memset

; 331  : 	char stemp[1024] = ".";

	push	1022					; 000003feH
	lea	eax, DWORD PTR _stemp$[ebp+2]
	mov	edx, 46					; 0000002eH
	push	esi
	push	eax
	mov	WORD PTR _stemp$[ebp], dx
	call	_memset
	add	esp, 32					; 00000020H

; 332  : 	char *last_backslash = NULL;
; 333  : 	FILE *out_file;
; 334  : 	FILE *png_dir_file;
; 335  : 	static char TimeString[64];				//Prefix on filenames.
; 336  : 	static unsigned int FileCounter = 0;		//Counter after the prefix above.
; 337  : 	time_t tim;
; 338  : 	struct tm *date;
; 339  : 
; 340  : 	if(AskFileName){	

	cmp	DWORD PTR _AskFileName$[ebp], esi
	je	$LN15@TakeScreen

; 341  : 
; 342  : //Use a Windows save dialog.
; 343  : 		OPENFILENAME ofn;
; 344  : 		memset(&ofn, 0, sizeof(OPENFILENAME));

	push	88					; 00000058H
	lea	ecx, DWORD PTR _ofn$94529[ebp]
	push	esi
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 345  : 		ofn.lStructSize = sizeof(OPENFILENAME);

	mov	DWORD PTR _ofn$94529[ebp], 88		; 00000058H

; 346  : 		ofn.hwndOwner = GetActiveWindow();

	call	DWORD PTR __imp__GetActiveWindow@0
	mov	DWORD PTR _ofn$94529[ebp+4], eax

; 347  : 		ofn.lpstrCustomFilter = NULL;
; 348  : 		ofn.nFilterIndex = 0;
; 349  : 		ofn.lpstrFile = fname;
; 350  : 		ofn.nMaxFile = sizeof(fname);
; 351  : 		
; 352  : 		//ofn.lpstrInitialDir = "c:\\Evolver230";
; 353  : 		ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_NOCHANGEDIR;
; 354  : 		ofn.lpstrFilter = "PNG Image\0*.png\0Any file\0*.*\0\0";
; 355  : 		ofn.lpstrTitle = "Save screenshot";
; 356  : 		ofn.lpstrDefExt = "png";
; 357  : 
; 358  : 		time(&tim);

	lea	eax, DWORD PTR _tim$[ebp]
	lea	edx, DWORD PTR _fname$[ebp]
	push	eax
	mov	DWORD PTR _ofn$94529[ebp+16], esi
	mov	DWORD PTR _ofn$94529[ebp+24], esi
	mov	DWORD PTR _ofn$94529[ebp+28], edx
	mov	DWORD PTR _ofn$94529[ebp+32], 1024	; 00000400H
	mov	DWORD PTR _ofn$94529[ebp+52], 526344	; 00080808H
	mov	DWORD PTR _ofn$94529[ebp+12], OFFSET ??_C@_0BP@FLKALCJG@PNG?5Image?$AA?$CK?4png?$AAAny?5file?$AA?$CK?4?$CK?$AA?$AA?$AA@
	mov	DWORD PTR _ofn$94529[ebp+48], OFFSET ??_C@_0BA@KIFGKKAI@Save?5screenshot?$AA@
	mov	DWORD PTR _ofn$94529[ebp+60], OFFSET ??_C@_03NNHBJLDF@png?$AA@
	call	__time64

; 359  : 		date = localtime(&tim);

	lea	ecx, DWORD PTR _tim$[ebp]
	push	ecx
	call	__localtime64

; 360  : 		sprintf(stemp, "%4u%02u%02u_%02u%02u%02u", date->tm_year + 1900, date->tm_mon + 1, date->tm_mday
; 361  : 					, date->tm_hour, date->tm_min, date->tm_sec);

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	push	edx
	mov	edx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR [eax+12]
	push	edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	push	ecx
	inc	edx
	push	edx
	add	eax, 1900				; 0000076cH
	push	eax
	lea	ecx, DWORD PTR _stemp$[ebp]
	push	OFFSET ??_C@_0BJ@CJNCHCIE@?$CF4u?$CF02u?$CF02u_?$CF02u?$CF02u?$CF02u?$AA@
	push	ecx
	call	_sprintf

; 362  : 		strcat(fname, stemp);

	lea	eax, DWORD PTR _stemp$[ebp]
	add	esp, 40					; 00000028H
	mov	esi, eax
	npad	7
$LL28@TakeScreen:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL28@TakeScreen
	push	edi
	lea	edi, DWORD PTR _fname$[ebp]
	sub	eax, esi
	dec	edi
$LL29@TakeScreen:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL29@TakeScreen
	mov	ecx, eax
	shr	ecx, 2
	rep movsd
	mov	ecx, eax
	and	ecx, 3

; 363  : 		strcat(fname, ".png");		

	lea	eax, DWORD PTR _fname$[ebp]
	rep movsb
	dec	eax
	npad	2
$LL30@TakeScreen:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL30@TakeScreen

; 364  : 
; 365  : 		//Set initial directory for file dialog
; 366  : 		//Check if there was a prior png save and go back to that directory
; 367  : 		/* primitive but working:
; 368  : 		png_dir_file = fopen("C:\\Evolver\\src\\temp\\ev_ogl\\z.txt", "r");
; 369  : 		if (png_dir_file!=NULL)
; 370  : 		{
; 371  : 			fgets(stemp, 1024, png_dir_file);
; 372  : 			fclose(png_dir_file);
; 373  : 		}
; 374  : 		else
; 375  : 			strcpy(stemp, ".");
; 376  : 		*/
; 377  : 		if  (gl_evolver_mode)

	cmp	DWORD PTR _gl_evolver_mode, 0
	mov	edx, DWORD PTR ??_C@_04EEOGCCFB@?4png?$AA@
	mov	cl, BYTE PTR ??_C@_04EEOGCCFB@?4png?$AA@+4
	mov	DWORD PTR [eax], edx
	mov	BYTE PTR [eax+4], cl
	je	SHORT $LN14@TakeScreen

; 378  : 			{
; 379  : 			png_dir_file = fopen(png_path_filename, "r");

	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	push	OFFSET _png_path_filename
	call	_fopen
	mov	esi, eax
	add	esp, 8

; 380  : 			if (png_dir_file!=NULL)

	test	esi, esi
	je	SHORT $LN13@TakeScreen

; 381  : 				{
; 382  : 				fgets(stemp, 1024, png_dir_file);

	push	esi
	lea	edx, DWORD PTR _stemp$[ebp]
	push	1024					; 00000400H
	push	edx
	call	_fgets

; 383  : 				fclose(png_dir_file);

	push	esi
	call	_fclose
	add	esp, 16					; 00000010H

; 384  : 				}		
; 385  : 			else

	jmp	SHORT $LN11@TakeScreen
$LN13@TakeScreen:

; 386  : 				strcpy(stemp, ".");

	mov	eax, 46					; 0000002eH
	mov	WORD PTR _stemp$[ebp], ax

; 387  : 			}
; 388  : 		else

	jmp	SHORT $LN11@TakeScreen
$LN14@TakeScreen:

; 389  : 			strcpy(stemp, ".");

	mov	ecx, 46					; 0000002eH
	mov	WORD PTR _stemp$[ebp], cx
$LN11@TakeScreen:

; 390  : 		ofn.lpstrInitialDir = stemp; //From my tests it seems that Windows casts the pointer correctly
; 391  : 
; 392  : 		if(!GetSaveFileName(&ofn)){

	lea	eax, DWORD PTR _ofn$94529[ebp]
	lea	edx, DWORD PTR _stemp$[ebp]
	push	eax
	mov	DWORD PTR _ofn$94529[ebp+44], edx
	call	DWORD PTR __imp__GetSaveFileNameA@4
	test	eax, eax
	jne	SHORT $LN10@TakeScreen

; 393  : 			free(bmp);

	push	ebx
	call	_free
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 451  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@TakeScreen:

; 394  : 			return;
; 395  : 		}
; 396  : 
; 397  : 		if  (gl_evolver_mode)

	cmp	DWORD PTR _gl_evolver_mode, 0
	je	SHORT $LN31@TakeScreen

; 398  : 			{
; 399  : 			png_dir_file = fopen(png_path_filename, "wb");

	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	push	OFFSET _png_path_filename
	call	_fopen
	mov	esi, eax
	add	esp, 8

; 400  : 			if (png_dir_file!=NULL)

	test	esi, esi
	je	SHORT $LN31@TakeScreen

; 401  : 				{
; 402  : 				strcpy(stemp, fname);

	xor	eax, eax
	npad	5
$LL18@TakeScreen:
	mov	cl, BYTE PTR _fname$[ebp+eax]
	mov	BYTE PTR _stemp$[ebp+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL18@TakeScreen

; 403  : 				last_backslash = strrchr(stemp, '\\');

	lea	ecx, DWORD PTR _stemp$[ebp]
	push	92					; 0000005cH
	push	ecx
	call	_strrchr

; 404  : 				last_backslash[0] = NULL; //Relies on Windows always using at least one '\' character like "C:\"
; 405  : 
; 406  : 				fputs(stemp, png_dir_file);

	lea	edx, DWORD PTR _stemp$[ebp]
	push	esi
	push	edx
	mov	BYTE PTR [eax], 0
	call	_fputs

; 407  : 				fclose(png_dir_file);

	push	esi
	call	_fclose
	add	esp, 20					; 00000014H
$LN31@TakeScreen:

; 415  : 		return;
; 416  : 	}
; 417  : 
; 418  : 	//Grab them pixels.
; 419  : 	glFlush(); //Added by Ben Schaeffer 

	call	DWORD PTR __imp__glFlush@0

; 420  : 	glFinish();  

	call	DWORD PTR __imp__glFinish@0

; 421  : 	glPixelStorei(GL_PACK_ALIGNMENT, 1);

	mov	edi, DWORD PTR __imp__glPixelStorei@8
	push	1
	push	3333					; 00000d05H
	call	edi

; 422  : 	glReadPixels(0, 0, td->xsize, td->ysize, GL_RGB, GL_UNSIGNED_BYTE, bmp);

	mov	esi, DWORD PTR _td$[ebp]
	mov	eax, DWORD PTR [esi+252]
	mov	ecx, DWORD PTR [esi+248]
	push	ebx
	push	5121					; 00001401H
	push	6407					; 00001907H
	push	eax
	push	ecx
	push	0
	push	0
	call	DWORD PTR __imp__glReadPixels@28

; 423  : 	glPixelStorei(GL_PACK_ALIGNMENT, 4);

	push	4
	push	3333					; 00000d05H
	call	edi

; 424  : 
; 425  : 	//Flip the image so that the origin is at top left. Blatanly copied from some forum, changed to C and some other minor adjustments.
; 426  : 	for(y = 0; y < (td->ysize >> 1); y++){

	mov	eax, DWORD PTR [esi+252]
	xor	edx, edx
	mov	DWORD PTR _y$[ebp], edx
	test	eax, -2					; fffffffeH
	jle	$LN4@TakeScreen
	mov	ecx, DWORD PTR [esi+248]
$LL33@TakeScreen:

; 427  : 		const int swapY = td->ysize - y - 1;

	sub	eax, edx
	dec	eax

; 428  : 		for(x = 0; x < td->xsize; x++){

	xor	edi, edi
	mov	DWORD PTR _swapY$94554[ebp], eax
	test	ecx, ecx
	jle	SHORT $LN5@TakeScreen
	npad	11
$LL3@TakeScreen:

; 429  : 			const int offset = 3*(x + y*td->xsize);

	mov	eax, ecx

; 430  : 			const int swapOffset = 3*(x + swapY*td->xsize);

	imul	ecx, DWORD PTR _swapY$94554[ebp]
	imul	eax, edx
	add	ecx, edi
	lea	esi, DWORD PTR [ecx+ecx*2]

; 431  : 
; 432  : 			t = bmp[offset];
; 433  : 			bmp[offset] = bmp[swapOffset];

	movzx	edx, BYTE PTR [esi+ebx]
	add	eax, edi
	lea	eax, DWORD PTR [eax+eax*2]
	mov	cl, BYTE PTR [eax+ebx]
	mov	BYTE PTR [eax+ebx], dl

; 434  : 			bmp[swapOffset] = t;
; 435  : 
; 436  : 			t = bmp[offset + 1];
; 437  : 			bmp[offset + 1] = bmp[swapOffset + 1];

	movzx	edx, BYTE PTR [ebx+esi+1]
	mov	BYTE PTR [esi+ebx], cl
	mov	cl, BYTE PTR [ebx+eax+1]
	mov	BYTE PTR [ebx+eax+1], dl

; 438  : 			bmp[swapOffset + 1] = t;
; 439  : 
; 440  : 			t = bmp[offset + 2];
; 441  : 			bmp[offset + 2] = bmp[swapOffset + 2];

	movzx	edx, BYTE PTR [ebx+esi+2]
	mov	BYTE PTR [ebx+esi+1], cl
	mov	cl, BYTE PTR [ebx+eax+2]
	mov	BYTE PTR [ebx+eax+2], dl
	mov	eax, DWORD PTR _td$[ebp]
	mov	edx, DWORD PTR _y$[ebp]

; 442  : 			bmp[swapOffset + 2] = t;

	mov	BYTE PTR [ebx+esi+2], cl
	mov	ecx, DWORD PTR [eax+248]
	inc	edi
	cmp	edi, ecx
	jl	SHORT $LL3@TakeScreen

; 428  : 		for(x = 0; x < td->xsize; x++){

	mov	esi, eax
$LN5@TakeScreen:

; 424  : 
; 425  : 	//Flip the image so that the origin is at top left. Blatanly copied from some forum, changed to C and some other minor adjustments.
; 426  : 	for(y = 0; y < (td->ysize >> 1); y++){

	mov	eax, DWORD PTR [esi+252]
	mov	edi, eax
	inc	edx
	sar	edi, 1
	mov	DWORD PTR _y$[ebp], edx
	cmp	edx, edi
	jl	$LL33@TakeScreen
$LN4@TakeScreen:

; 443  : 		}
; 444  : 	}
; 445  : 
; 446  : 	remove(fname);		//Kill it if it exists.

	lea	ecx, DWORD PTR _fname$[ebp]
	push	ecx
	call	_remove

; 447  : 	out_file = fopen(fname, "wb");

	lea	edx, DWORD PTR _fname$[ebp]
	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	push	edx
	call	_fopen

; 448  : 	write_png(out_file, td->xsize, td->ysize, bmp, NULL);

	mov	ecx, DWORD PTR [esi+248]
	push	0
	mov	edi, eax
	mov	eax, DWORD PTR [esi+252]
	push	ebx
	push	eax
	push	ecx
	push	edi
	call	_write_png

; 449  : 	fclose(out_file);

	push	edi
	call	_fclose

; 450  : 	free(bmp);

	push	ebx
	call	_free
	add	esp, 40					; 00000028H
	pop	edi
	pop	esi
	pop	ebx

; 451  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@TakeScreen:

; 408  : 				}
; 409  : 			}
; 410  : 	}else{	
; 411  : 		take_snapshot++;

	inc	DWORD PTR _take_snapshot

; 412  : 		update_display();

	call	_update_display

; 413  : 		Sleep(10);

	push	10					; 0000000aH
	call	DWORD PTR __imp__Sleep@4

; 414  : 		free(bmp);

	push	ebx
	call	_free

; 451  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 4
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TakeScreenshot ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@NODFBGI@GPU?5memory?5report?5not?5available?4@ ; `string'
PUBLIC	??_C@_0CI@IOAJLKML@NVIDIA?5GPU?5total?5videao?5memory?0?5@ ; `string'
PUBLIC	??_C@_0CB@EPAAADOB@NVIDIA?5GPU?5total?5memory?0?5KB?3?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0CH@IDAIJJNE@NVIDIA?5GPU?5video?5total?5memory?0?5K@ ; `string'
PUBLIC	??_C@_0CE@IBEIGABL@ATI?5GPU?5render?5buffer?5free?5memor@ ; `string'
PUBLIC	??_C@_0CA@MILDMMEI@Total?0?5KB?3?5?$CFd?5?5Largest?0?5KB?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0CL@JLFJOFPK@ATI?5GPU?5vertex?5buffer?5object?5fre@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_gpu_memory_report
EXTRN	_current_prompt:DWORD
EXTRN	_errmsg:BYTE
EXTRN	__imp__glGetIntegerv@8:PROC
EXTRN	_erroutstring:PROC
;	COMDAT ??_C@_0CC@NODFBGI@GPU?5memory?5report?5not?5available?4@
CONST	SEGMENT
??_C@_0CC@NODFBGI@GPU?5memory?5report?5not?5available?4@ DB 'GPU memory r'
	DB	'eport not available.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOAJLKML@NVIDIA?5GPU?5total?5videao?5memory?0?5@
CONST	SEGMENT
??_C@_0CI@IOAJLKML@NVIDIA?5GPU?5total?5videao?5memory?0?5@ DB 'NVIDIA GPU'
	DB	' total videao memory, KB: %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EPAAADOB@NVIDIA?5GPU?5total?5memory?0?5KB?3?5?$CFd?6@
CONST	SEGMENT
??_C@_0CB@EPAAADOB@NVIDIA?5GPU?5total?5memory?0?5KB?3?5?$CFd?6@ DB 'NVIDI'
	DB	'A GPU total memory, KB: %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@IDAIJJNE@NVIDIA?5GPU?5video?5total?5memory?0?5K@
CONST	SEGMENT
??_C@_0CH@IDAIJJNE@NVIDIA?5GPU?5video?5total?5memory?0?5K@ DB 'NVIDIA GPU'
	DB	' video total memory, KB: %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IBEIGABL@ATI?5GPU?5render?5buffer?5free?5memor@
CONST	SEGMENT
??_C@_0CE@IBEIGABL@ATI?5GPU?5render?5buffer?5free?5memor@ DB 'ATI GPU ren'
	DB	'der buffer free memory:', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MILDMMEI@Total?0?5KB?3?5?$CFd?5?5Largest?0?5KB?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0CA@MILDMMEI@Total?0?5KB?3?5?$CFd?5?5Largest?0?5KB?3?5?$CFd?6?$AA@ DB 'T'
	DB	'otal, KB: %d  Largest, KB: %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@JLFJOFPK@ATI?5GPU?5vertex?5buffer?5object?5fre@
CONST	SEGMENT
??_C@_0CL@JLFJOFPK@ATI?5GPU?5vertex?5buffer?5object?5fre@ DB 'ATI GPU ver'
	DB	'tex buffer object free memory:', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _gpu_memory_report
_TEXT	SEGMENT
_v$94572 = -20						; size = 16
_v$94566 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_gpu_memory_report PROC					; COMDAT

; 477  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 478  :   if ( ati_gpu_flag )

	cmp	DWORD PTR _ati_gpu_flag, 0
	push	esi
	je	$LN4@gpu_memory

; 479  :   { GLint v[4];
; 480  :     erroutstring("ATI GPU vertex buffer object free memory:\n");

	push	OFFSET ??_C@_0CL@JLFJOFPK@ATI?5GPU?5vertex?5buffer?5object?5fre@
	call	_erroutstring

; 481  :     glGetIntegerv(VBO_FREE_MEMORY_ATI,v);

	mov	esi, DWORD PTR __imp__glGetIntegerv@8
	add	esp, 4
	lea	eax, DWORD PTR _v$94566[ebp]
	push	eax
	push	34811					; 000087fbH
	call	esi

; 482  :     sprintf(errmsg,"Total, KB: %d  Largest, KB: %d\n",v[0],v[1]);

	mov	ecx, DWORD PTR _v$94566[ebp+4]
	mov	edx, DWORD PTR _v$94566[ebp]
	push	ecx
	push	edx
	push	OFFSET ??_C@_0CA@MILDMMEI@Total?0?5KB?3?5?$CFd?5?5Largest?0?5KB?3?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 483  :     erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 484  :     erroutstring("ATI GPU render buffer free memory:\n");

	push	OFFSET ??_C@_0CE@IBEIGABL@ATI?5GPU?5render?5buffer?5free?5memor@
	call	_erroutstring
	add	esp, 24					; 00000018H

; 485  :     glGetIntegerv(VBO_FREE_MEMORY_ATI,v);

	lea	eax, DWORD PTR _v$94566[ebp]
	push	eax
	push	34811					; 000087fbH
	call	esi

; 486  :     sprintf(errmsg,"Total, KB: %d  Largest, KB: %d\n",v[0],v[1]);

	mov	ecx, DWORD PTR _v$94566[ebp+4]
	mov	edx, DWORD PTR _v$94566[ebp]
	push	ecx
	push	edx
	push	OFFSET ??_C@_0CA@MILDMMEI@Total?0?5KB?3?5?$CFd?5?5Largest?0?5KB?3?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 487  :     erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 20					; 00000014H
	jmp	$LN1@gpu_memory
$LN4@gpu_memory:

; 488  :   }
; 489  :   else if ( nvidia_gpu_flag )

	cmp	DWORD PTR _nvidia_gpu_flag, 0
	je	$LN2@gpu_memory

; 490  :   { GLint v[4];
; 491  :     glGetIntegerv(GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX,v);

	mov	esi, DWORD PTR __imp__glGetIntegerv@8
	lea	eax, DWORD PTR _v$94572[ebp]
	push	eax
	push	36935					; 00009047H
	call	esi

; 492  :     sprintf(errmsg,"NVIDIA GPU video total memory, KB: %d\n",v[1]);

	mov	ecx, DWORD PTR _v$94572[ebp+4]
	push	ecx
	push	OFFSET ??_C@_0CH@IDAIJJNE@NVIDIA?5GPU?5video?5total?5memory?0?5K@
	push	OFFSET _errmsg
	call	_sprintf

; 493  :     erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 16					; 00000010H

; 494  :     glGetIntegerv(GPU_MEMORY_INFO_TOTAL_AVAILABLE_MEMORY_NVX,v);

	lea	edx, DWORD PTR _v$94572[ebp]
	push	edx
	push	36936					; 00009048H
	call	esi

; 495  :     sprintf(errmsg,"NVIDIA GPU total memory, KB: %d\n",v[1]);

	mov	eax, DWORD PTR _v$94572[ebp+4]
	push	eax
	push	OFFSET ??_C@_0CB@EPAAADOB@NVIDIA?5GPU?5total?5memory?0?5KB?3?5?$CFd?6@
	push	OFFSET _errmsg
	call	_sprintf

; 496  :     erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 16					; 00000010H

; 497  :     glGetIntegerv(GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX,v);

	lea	ecx, DWORD PTR _v$94572[ebp]
	push	ecx
	push	36937					; 00009049H
	call	esi

; 498  :     sprintf(errmsg,"NVIDIA GPU total videao memory, KB: %d\n",v[1]);

	mov	edx, DWORD PTR _v$94572[ebp+4]
	push	edx
	push	OFFSET ??_C@_0CI@IOAJLKML@NVIDIA?5GPU?5total?5videao?5memory?0?5@
	push	OFFSET _errmsg
	call	_sprintf

; 499  :     erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 16					; 00000010H

; 500  :   }
; 501  :   else

	jmp	SHORT $LN1@gpu_memory
$LN2@gpu_memory:

; 502  :   { erroutstring("GPU memory report not available.\n");

	push	OFFSET ??_C@_0CC@NODFBGI@GPU?5memory?5report?5not?5available?4@
	call	_erroutstring
	add	esp, 4
$LN1@gpu_memory:

; 503  :   }
; 504  :   erroutstring(current_prompt);

	mov	eax, DWORD PTR _current_prompt
	push	eax
	call	_erroutstring

; 505  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 4
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_gpu_memory_report ENDP
_TEXT	ENDS
PUBLIC	__real@3ff4cccccccccccd
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@3fa999999999999a
PUBLIC	__real@3f40624dd2f1a9fc
PUBLIC	__real@3f800000
PUBLIC	__real@4032000000000000
PUBLIC	__real@4034000000000000
PUBLIC	__real@402a000000000000
PUBLIC	__real@4026000000000000
PUBLIC	__real@4039000000000000
PUBLIC	__real@4020000000000000
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	_glut_text_display
EXTRN	__imp__glPopMatrix@0:PROC
EXTRN	_glutStrokeCharacter@8:PROC
EXTRN	__imp__glLineWidth@4:PROC
EXTRN	__imp__glScalef@12:PROC
EXTRN	__imp__glTranslatef@12:PROC
EXTRN	_glutBitmapCharacter@8:PROC
EXTRN	__imp__glRasterPos2d@16:PROC
EXTRN	__imp__glColor3f@12:PROC
EXTRN	_text_chunks:BYTE
EXTRN	__imp__glOrtho@48:PROC
EXTRN	__imp__glLoadIdentity@0:PROC
EXTRN	__imp__glPushMatrix@0:PROC
EXTRN	__imp__glMatrixMode@4:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@3ff4cccccccccccd
CONST	SEGMENT
__real@3ff4cccccccccccd DQ 03ff4cccccccccccdr	; 1.3
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@3fa999999999999a
CONST	SEGMENT
__real@3fa999999999999a DQ 03fa999999999999ar	; 0.05
CONST	ENDS
;	COMDAT __real@3f40624dd2f1a9fc
CONST	SEGMENT
__real@3f40624dd2f1a9fc DQ 03f40624dd2f1a9fcr	; 0.0005
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@4032000000000000
CONST	SEGMENT
__real@4032000000000000 DQ 04032000000000000r	; 18
CONST	ENDS
;	COMDAT __real@4034000000000000
CONST	SEGMENT
__real@4034000000000000 DQ 04034000000000000r	; 20
CONST	ENDS
;	COMDAT __real@402a000000000000
CONST	SEGMENT
__real@402a000000000000 DQ 0402a000000000000r	; 13
CONST	ENDS
;	COMDAT __real@4026000000000000
CONST	SEGMENT
__real@4026000000000000 DQ 04026000000000000r	; 11
CONST	ENDS
;	COMDAT __real@4039000000000000
CONST	SEGMENT
__real@4039000000000000 DQ 04039000000000000r	; 25
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _glut_text_display
_TEXT	SEGMENT
_yspot$94588 = -12					; size = 8
tv483 = -8						; size = 4
tv482 = -8						; size = 4
tv474 = -8						; size = 4
tv472 = -8						; size = 4
tv463 = -8						; size = 4
tv459 = -8						; size = 4
tv458 = -8						; size = 4
tv450 = -8						; size = 4
tv448 = -8						; size = 4
tv441 = -8						; size = 4
_font$ = -4						; size = 4
_lcount$94589 = -4					; size = 4
_glut_text_display PROC					; COMDAT

; 515  : { char *c;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi

; 516  :   int i;
; 517  :   struct graph_thread_data *td = GET_DATA;

	call	_glutGetWindow@0
	mov	ebx, eax
	imul	ebx, 9896				; 000026a8H

; 518  :   void *font;
; 519  :   double pixheight;
; 520  : 
; 521  :   /* set up window coords */
; 522  :   glMatrixMode(GL_PROJECTION);

	push	5889					; 00001701H
	add	ebx, OFFSET _gthread_data
	call	DWORD PTR __imp__glMatrixMode@4

; 523  :   glPushMatrix();

	mov	esi, DWORD PTR __imp__glPushMatrix@0
	call	esi

; 524  :   glLoadIdentity();

	mov	edi, DWORD PTR __imp__glLoadIdentity@0
	call	edi

; 525  :   glOrtho(0.0,1.0,0.0,1.0,0.0,1.0);

	fld1
	sub	esp, 48					; 00000030H
	fst	QWORD PTR [esp+40]
	fldz
	fst	QWORD PTR [esp+32]
	fxch	ST(1)
	fst	QWORD PTR [esp+24]
	fxch	ST(1)
	fst	QWORD PTR [esp+16]
	fxch	ST(1)
	fstp	QWORD PTR [esp+8]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__glOrtho@48

; 526  :   glMatrixMode(GL_MODELVIEW);

	push	5888					; 00001700H
	call	DWORD PTR __imp__glMatrixMode@4

; 527  :   glPushMatrix();

	call	esi
	mov	esi, OFFSET _text_chunks+16
	jmp	SHORT $LN48@glut_text_
	npad	11
$LL31@glut_text_:

; 516  :   int i;
; 517  :   struct graph_thread_data *td = GET_DATA;

	mov	edi, DWORD PTR __imp__glLoadIdentity@0
$LN48@glut_text_:

; 531  :   { REAL yspot;
; 532  :     int lcount = 0;
; 533  :     if ( text_chunks[i].text == NULL )

	cmp	DWORD PTR [esi-16], 0
	fldz
	mov	DWORD PTR _lcount$94589[ebp], 0
	je	$LN34@glut_text_

; 534  :       continue;
; 535  :     yspot = text_chunks[i].start_y;

	fld	QWORD PTR [esi]

; 536  :     glColor3f(0.0,0.0,0.0); /* black */

	sub	esp, 12					; 0000000cH
	fstp	QWORD PTR _yspot$94588[ebp]
	fst	DWORD PTR [esp+8]
	fst	DWORD PTR [esp+4]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glColor3f@12

; 537  :     pixheight = text_chunks[i].vsize*td->ysize;

	fild	DWORD PTR [ebx+252]
	fmul	QWORD PTR [esi+8]

; 538  :     if ( pixheight < 8 || pixheight > 25 )

	fld	QWORD PTR __real@4020000000000000
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN40@glut_text_
	fld	QWORD PTR __real@4039000000000000
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	$LN40@glut_text_

; 555  :     }
; 556  :     else // pick close bitmap font
; 557  :     { if ( pixheight < 11 )

	fld	QWORD PTR __real@4026000000000000
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN10@glut_text_
	fstp	ST(0)

; 558  :         font = GLUT_BITMAP_HELVETICA_10;

	mov	DWORD PTR _font$[ebp], 6
	jmp	SHORT $LN5@glut_text_
$LN10@glut_text_:

; 559  :       else if ( pixheight < 13 )

	fld	QWORD PTR __real@402a000000000000
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN8@glut_text_
	fstp	ST(0)

; 560  :         font = GLUT_BITMAP_HELVETICA_12;

	mov	DWORD PTR _font$[ebp], 7
	jmp	SHORT $LN5@glut_text_
$LN8@glut_text_:

; 561  :       else if ( pixheight < 20 )

	fcomp	QWORD PTR __real@4034000000000000

; 562  :         font = GLUT_BITMAP_HELVETICA_18;

	mov	DWORD PTR _font$[ebp], 8
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN5@glut_text_

; 563  :       else
; 564  :         font = GLUT_BITMAP_TIMES_ROMAN_24;

	mov	DWORD PTR _font$[ebp], 5
$LN5@glut_text_:

; 565  :       glLoadIdentity();

	call	edi

; 566  :       glRasterPos2d(text_chunks[i].start_x,text_chunks[i].start_y);

	fld	QWORD PTR [esi]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [esi-8]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__glRasterPos2d@16

; 567  :       for ( c = text_chunks[i].text ; *c ; c++ )

	mov	edi, DWORD PTR [esi-16]
	mov	al, BYTE PTR [edi]
	test	al, al
	je	$LN20@glut_text_
$LL4@glut_text_:

; 568  :       {  if ( *c == '\n' )

	cmp	al, 10					; 0000000aH
	jne	SHORT $LN1@glut_text_

; 569  :         { yspot -= 18.0/td->ysize;

	fild	DWORD PTR [ebx+252]

; 570  :           glRasterPos2d(text_chunks[i].start_x,yspot);

	sub	esp, 16					; 00000010H
	fdivr	QWORD PTR __real@4032000000000000
	fsubr	QWORD PTR _yspot$94588[ebp]
	fst	QWORD PTR _yspot$94588[ebp]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [esi-8]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__glRasterPos2d@16
$LN1@glut_text_:

; 571  :         }
; 572  :         glutBitmapCharacter(font,*c);

	movsx	eax, BYTE PTR [edi]
	mov	ecx, DWORD PTR _font$[ebp]
	push	eax
	push	ecx
	call	_glutBitmapCharacter@8
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL4@glut_text_

; 538  :     if ( pixheight < 8 || pixheight > 25 )

	jmp	$LN20@glut_text_
$LN40@glut_text_:
	fstp	ST(0)

; 539  :     { // do stroke text
; 540  :        glLoadIdentity();

	call	edi

; 541  :        glTranslatef(text_chunks[i].start_x,text_chunks[i].start_y,0.0);

	fldz
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	fld	QWORD PTR [esi]
	fstp	DWORD PTR tv483[ebp]
	fld	DWORD PTR tv483[ebp]
	fstp	DWORD PTR [esp+4]
	fld	QWORD PTR [esi-8]
	fstp	DWORD PTR tv482[ebp]
	fld	DWORD PTR tv482[ebp]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glTranslatef@12

; 542  :        glScalef(.0005*td->aspect*text_chunks[i].vsize/.05,.0005*text_chunks[i].vsize/.05,1.);  // stroke characters are big, 120 units high

	fld1
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	fld	QWORD PTR [esi+8]
	fld	QWORD PTR __real@3f40624dd2f1a9fc
	fmul	ST(1), ST(0)
	fld	QWORD PTR __real@3fa999999999999a
	fdiv	ST(2), ST(0)
	fxch	ST(2)
	fstp	DWORD PTR tv474[ebp]
	fld	DWORD PTR tv474[ebp]
	fstp	DWORD PTR [esp+4]
	fmul	QWORD PTR [ebx+216]
	fmul	QWORD PTR [esi+8]
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR tv472[ebp]
	fld	DWORD PTR tv472[ebp]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glScalef@12

; 543  :        glLineWidth(0.10*text_chunks[i].vsize*td->ysize);  // line width in pixels

	fld	QWORD PTR [esi+8]
	fmul	QWORD PTR __real@3fb999999999999a
	push	ecx
	fimul	DWORD PTR [ebx+252]
	fstp	DWORD PTR tv463[ebp]
	fld	DWORD PTR tv463[ebp]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glLineWidth@4

; 544  :        for ( c = text_chunks[i].text ; *c ; c++ )

	mov	edi, DWORD PTR [esi-16]
	mov	al, BYTE PTR [edi]
	test	al, al
	je	$LN13@glut_text_
$LL15@glut_text_:

; 545  :        {
; 546  :          if ( *c == '\n' )

	cmp	al, 10					; 0000000aH
	jne	$LN12@glut_text_

; 547  :          { lcount++;

	inc	DWORD PTR _lcount$94589[ebp]

; 548  :            glLoadIdentity();

	call	DWORD PTR __imp__glLoadIdentity@0

; 549  :            glTranslatef(text_chunks[i].start_x,text_chunks[i].start_y - lcount*1.3*text_chunks[i].vsize,0.0);

	fldz
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	fild	DWORD PTR _lcount$94589[ebp]
	fmul	QWORD PTR __real@3ff4cccccccccccd
	fmul	QWORD PTR [esi+8]
	fsubr	QWORD PTR [esi]
	fstp	DWORD PTR tv459[ebp]
	fld	DWORD PTR tv459[ebp]
	fstp	DWORD PTR [esp+4]
	fld	QWORD PTR [esi-8]
	fstp	DWORD PTR tv458[ebp]
	fld	DWORD PTR tv458[ebp]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glTranslatef@12

; 550  :            glScalef(.0005*td->aspect*text_chunks[i].vsize/.05,.0005*text_chunks[i].vsize/.05,1.);  // stroke characters are big, 120 units high

	fld1
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR [esp+8]
	fld	QWORD PTR [esi+8]
	fld	QWORD PTR __real@3f40624dd2f1a9fc
	fmul	ST(1), ST(0)
	fld	QWORD PTR __real@3fa999999999999a
	fdiv	ST(2), ST(0)
	fxch	ST(2)
	fstp	DWORD PTR tv450[ebp]
	fld	DWORD PTR tv450[ebp]
	fstp	DWORD PTR [esp+4]
	fmul	QWORD PTR [ebx+216]
	fmul	QWORD PTR [esi+8]
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR tv448[ebp]
	fld	DWORD PTR tv448[ebp]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glScalef@12
$LN12@glut_text_:

; 551  :          }
; 552  :          glutStrokeCharacter(GLUT_STROKE_ROMAN,*c);

	movsx	edx, BYTE PTR [edi]
	push	edx
	push	0
	call	_glutStrokeCharacter@8
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	$LL15@glut_text_
$LN13@glut_text_:

; 553  :        }
; 554  :        glLineWidth(td->linewidth);

	fld	QWORD PTR [ebx+1712]
	push	ecx
	fstp	DWORD PTR tv441[ebp]
	fld	DWORD PTR tv441[ebp]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glLineWidth@4
	jmp	SHORT $LN20@glut_text_
$LN34@glut_text_:
	fstp	ST(0)
$LN20@glut_text_:

; 528  : 
; 529  :   
; 530  :   for ( i = 0 ; i < MAXTEXTS ; i++ )

	add	esi, 32					; 00000020H
	cmp	esi, OFFSET _text_chunks+3216
	jl	$LL31@glut_text_

; 573  :       }
; 574  :     }
; 575  :   }  // end for
; 576  :  
; 577  :   glPopMatrix();  

	mov	esi, DWORD PTR __imp__glPopMatrix@0
	call	esi

; 578  :   glMatrixMode(GL_PROJECTION);

	push	5889					; 00001701H
	call	DWORD PTR __imp__glMatrixMode@4

; 579  :   glPopMatrix();

	call	esi
	pop	edi
	pop	esi
	pop	ebx

; 580  :  
; 581  : } // end glut_text_display()

	mov	esp, ebp
	pop	ebp
	ret	0
_glut_text_display ENDP
_TEXT	ENDS
PUBLIC	_my_glLoadName
EXTRN	__imp__glLoadName@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _my_glLoadName
_TEXT	SEGMENT
_id$ = 8						; size = 4
_my_glLoadName PROC					; COMDAT

; 601  : { GLuint name;

	push	ebp
	mov	ebp, esp

; 602  :   name = id_type(id) << NAMETYPESHIFT;

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	and	eax, -536870912				; e0000000H
	add	eax, eax

; 603  : #ifdef MPI_EVOLVER
; 604  :   name |= id_task(id) << NAMEOFFSETBITS;
; 605  : #endif
; 606  :   if ( valid_id(id) )

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN2@my_glLoadN

; 607  :     name |= id & OFFSETMASK & NAMEOFFSETMASK;

	and	ecx, 4194303				; 003fffffH
	or	eax, ecx

; 610  :   glLoadName(name);

	push	eax
	call	DWORD PTR __imp__glLoadName@4

; 611  : 
; 612  : } // end my_glLoadName()

	pop	ebp
	ret	0
$LN2@my_glLoadN:

; 608  :   else 
; 609  :     name |= NAMEOFFSETMASK;

	or	eax, 4194303				; 003fffffH

; 610  :   glLoadName(name);

	push	eax
	call	DWORD PTR __imp__glLoadName@4

; 611  : 
; 612  : } // end my_glLoadName()

	pop	ebp
	ret	0
_my_glLoadName ENDP
_TEXT	ENDS
PUBLIC	_name_to_id
; Function compile flags: /Ogtp
;	COMDAT _name_to_id
_TEXT	SEGMENT
_name$ = 8						; size = 4
_name_to_id PROC					; COMDAT

; 621  : { element_id id;

	push	ebp
	mov	ebp, esp

; 622  :   id = (element_id)((name & NAMETYPE_MASK) >> NAMETYPESHIFT) << TYPESHIFT;

	mov	ecx, DWORD PTR _name$[ebp]
	mov	eax, ecx
	shr	eax, 1

; 623  :   if ( (name & NAMEOFFSETMASK) != NAMEOFFSETMASK )

	and	ecx, 4194303				; 003fffffH
	and	eax, 1610612736				; 60000000H
	cmp	ecx, 4194303				; 003fffffH
	je	SHORT $LN1@name_to_id

; 624  :      id |=   VALIDMASK | (name & NAMEOFFSETMASK);

	or	ecx, 268435456				; 10000000H
	or	eax, ecx
$LN1@name_to_id:

; 625  : #ifdef MPI_EVOLVER
; 626  :   id |= (element_id)((name & NAMETASKMASK) >> NAMEOFFSETBITS) << TASK_ID_SHIFT;
; 627  : #endif
; 628  :   return id;
; 629  : 
; 630  : } // end name_to_id()

	pop	ebp
	ret	0
_name_to_id ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@NPPKKLCP@Trying?5to?5allocate?5?$CFd?5edge?5struc@ ; `string'
PUBLIC	??_C@_0EI@EHMFEGOO@Graphics?5too?5complicated?5for?5arr@ ; `string'
PUBLIC	_enlarge_edge_array
EXTRN	_glutPostRedisplay@0:PROC
EXTRN	_kb_error:PROC
EXTRN	_realloc:PROC
EXTRN	__imp__glEndList@0:PROC
EXTRN	__imp__glDrawArrays@12:PROC
EXTRN	__imp__glNewList@8:PROC
EXTRN	__imp__glVertexPointer@16:PROC
EXTRN	__imp__glNormalPointer@12:PROC
EXTRN	__imp__glColorPointer@16:PROC
EXTRN	__imp__glEnableClientState@4:PROC
EXTRN	__imp__glGenLists@4:PROC
;	COMDAT ??_C@_0DD@NPPKKLCP@Trying?5to?5allocate?5?$CFd?5edge?5struc@
CONST	SEGMENT
??_C@_0DD@NPPKKLCP@Trying?5to?5allocate?5?$CFd?5edge?5struc@ DB 'Trying t'
	DB	'o allocate %d edge structures of size %d', 0aH, '.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@EHMFEGOO@Graphics?5too?5complicated?5for?5arr@
CONST	SEGMENT
??_C@_0EI@EHMFEGOO@Graphics?5too?5complicated?5for?5arr@ DB 'Graphics too'
	DB	' complicated for arrays.  Switching to non-array graphics.', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _enlarge_edge_array
_TEXT	SEGMENT
_td$ = 8						; size = 4
_enlarge_edge_array PROC				; COMDAT

; 640  : { int more = td->edgemax + 10;

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, DWORD PTR _td$[ebp]

; 641  :   struct vercol *old_array = td->edgearray;
; 642  : 
; 643  :   if ( td->multi_dlist_flag )

	cmp	DWORD PTR [esi+1752], 0
	mov	eax, DWORD PTR [esi+9816]
	mov	ebx, DWORD PTR [esi+9808]
	push	edi
	lea	edi, DWORD PTR [eax+10]
	je	$LN3@enlarge_ed

; 644  :   { // dump current contents to display list
; 645  :     if ( td->edge_dlist_count >= td->edge_dlist_alloc )

	mov	eax, DWORD PTR [esi+5760]
	cmp	eax, DWORD PTR [esi+5756]
	jl	SHORT $LN2@enlarge_ed

; 646  :     { td->edge_dlists[td->edge_dlist_count] = glGenLists(1);

	push	1
	call	DWORD PTR __imp__glGenLists@4
	mov	ecx, DWORD PTR [esi+5760]
	mov	DWORD PTR [esi+ecx*4+1756], eax

; 647  :       td->edge_dlist_alloc = td->edge_dlist_count + 1;

	mov	edx, DWORD PTR [esi+5760]
	inc	edx
	mov	DWORD PTR [esi+5756], edx
$LN2@enlarge_ed:

; 648  :     };
; 649  : 
; 650  :     /* declare arrays to OpenGL */
; 651  :     glEnableClientState(GL_COLOR_ARRAY);

	mov	edi, DWORD PTR __imp__glEnableClientState@4
	push	32886					; 00008076H
	call	edi

; 652  :     glEnableClientState(GL_NORMAL_ARRAY);

	push	32885					; 00008075H
	call	edi

; 653  :     glEnableClientState(GL_VERTEX_ARRAY);

	push	32884					; 00008074H
	call	edi

; 654  : 
; 655  :     // glInterleavedArrays(GL_C4F_N3F_V3F,sizeof(struct vercol),(void*)td->edgearray);
; 656  :     glColorPointer(4,GL_FLOAT,sizeof(struct vercol),td->edgearray);      

	mov	eax, DWORD PTR [esi+9808]
	push	eax
	push	44					; 0000002cH
	push	5126					; 00001406H
	push	4
	call	DWORD PTR __imp__glColorPointer@16

; 657  :     glNormalPointer(GL_FLOAT,sizeof(struct vercol),td->edgearray->n);

	mov	ecx, DWORD PTR [esi+9808]
	add	ecx, 16					; 00000010H
	push	ecx
	push	44					; 0000002cH
	push	5126					; 00001406H
	call	DWORD PTR __imp__glNormalPointer@12

; 658  :     glVertexPointer(3,GL_FLOAT,sizeof(struct vercol),td->edgearray->x);

	mov	edx, DWORD PTR [esi+9808]
	add	edx, 28					; 0000001cH
	push	edx
	push	44					; 0000002cH
	push	5126					; 00001406H
	push	3
	call	DWORD PTR __imp__glVertexPointer@16

; 659  :  
; 660  :     glFlush();

	mov	edi, DWORD PTR __imp__glFlush@0
	call	edi

; 661  : 
; 662  :     // start display list
; 663  :     glNewList(td->edge_dlists[td->edge_dlist_count],GL_COMPILE);

	mov	eax, DWORD PTR [esi+5760]
	mov	ecx, DWORD PTR [esi+eax*4+1756]
	push	4864					; 00001300H
	push	ecx
	call	DWORD PTR __imp__glNewList@8

; 664  :     glDrawArrays(GL_LINES,0,td->edgecount);

	mov	edx, DWORD PTR [esi+9792]
	push	edx
	push	0
	push	1
	call	DWORD PTR __imp__glDrawArrays@12

; 665  :     glEndList();

	call	DWORD PTR __imp__glEndList@0

; 666  :     glFlush();

	call	edi

; 667  :     td->edge_dlist_count++;

	inc	DWORD PTR [esi+5760]
	pop	edi

; 668  :     td->edgecount = 0;

	mov	DWORD PTR [esi+9792], 0
	pop	esi
	pop	ebx

; 691  : 
; 692  : } // end enlarge_edge_array()

	pop	ebp
	ret	0
$LN3@enlarge_ed:

; 669  :     return;
; 670  :   }
; 671  : 
; 672  :   td->edgearray = (struct vercol*)realloc((char*)td->edgearray,
; 673  :                 (td->edgemax+more)*sizeof(struct vercol));

	add	eax, edi
	imul	eax, 44					; 0000002cH
	push	eax
	push	ebx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR [esi+9808], eax

; 674  : 
; 675  :   if ( td->edgearray == NULL )

	test	eax, eax
	jne	SHORT $LN1@enlarge_ed

; 676  :   { kb_error(5694,"Graphics too complicated for arrays.  Switching to non-array graphics.\n",
; 677  :        WARNING);

	push	2
	push	OFFSET ??_C@_0EI@EHMFEGOO@Graphics?5too?5complicated?5for?5arr@
	push	5694					; 0000163eH
	call	_kb_error

; 678  :     sprintf(errmsg,"Trying to allocate %d edge structures of size %d\n.",
; 679  :          td->edgemax+more,(int)sizeof(struct vercol));

	mov	eax, DWORD PTR [esi+9816]
	push	44					; 0000002cH
	add	eax, edi
	push	eax
	push	OFFSET ??_C@_0DD@NPPKKLCP@Trying?5to?5allocate?5?$CFd?5edge?5struc@
	push	OFFSET _errmsg
	call	_sprintf

; 680  :     erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 681  :     td->arraysflag = 0;

	xor	edi, edi

; 682  :     td->edgemax = 0;
; 683  :     free(old_array); 

	push	ebx
	mov	DWORD PTR [esi+9772], edi
	mov	DWORD PTR [esi+9816], edi
	call	_free

; 684  :     free(td->facetarray); td->facetarray = NULL;

	mov	ecx, DWORD PTR [esi+9812]
	push	ecx
	call	_free
	add	esp, 40					; 00000028H
	mov	DWORD PTR [esi+9812], edi

; 685  :     td->doing_lazy = 0;

	mov	DWORD PTR [esi+9864], edi
	pop	edi
	pop	esi
	pop	ebx

; 691  : 
; 692  : } // end enlarge_edge_array()

	pop	ebp

; 686  :     glutPostRedisplay();

	jmp	_glutPostRedisplay@0
$LN1@enlarge_ed:

; 687  :     return;
; 688  :   }
; 689  : 
; 690  :   td->edgemax += more;

	add	DWORD PTR [esi+9816], edi
	pop	edi
	pop	esi
	pop	ebx

; 691  : 
; 692  : } // end enlarge_edge_array()

	pop	ebp
	ret	0
_enlarge_edge_array ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@DOAKLLM@Trying?5to?5allocate?5?$CFd?5facet?5stru@ ; `string'
PUBLIC	_enlarge_facet_array
;	COMDAT ??_C@_0DE@DOAKLLM@Trying?5to?5allocate?5?$CFd?5facet?5stru@
CONST	SEGMENT
??_C@_0DE@DOAKLLM@Trying?5to?5allocate?5?$CFd?5facet?5stru@ DB 'Trying to'
	DB	' allocate %d facet structures of size %d', 0aH, '.', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _enlarge_facet_array
_TEXT	SEGMENT
_td$ = 8						; size = 4
_enlarge_facet_array PROC				; COMDAT

; 702  : { int more = 3*web.skel[FACET].count + 10;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _web+288
	push	ebx
	push	esi

; 703  :   struct vercol *old_array = td->facetarray;

	mov	esi, DWORD PTR _td$[ebp]

; 704  : 
; 705  :   if ( td->multi_dlist_flag )

	cmp	DWORD PTR [esi+1752], 0
	mov	ebx, DWORD PTR [esi+9812]
	push	edi
	lea	edi, DWORD PTR [eax+eax*2+10]
	je	$LN3@enlarge_fa

; 706  :   { // dump current contents to display list
; 707  :     if ( td->facet_dlist_count >= td->facet_dlist_alloc )

	mov	eax, DWORD PTR [esi+9768]
	cmp	eax, DWORD PTR [esi+9764]
	jl	SHORT $LN2@enlarge_fa

; 708  :     { td->facet_dlists[td->facet_dlist_count] = glGenLists(1);

	push	1
	call	DWORD PTR __imp__glGenLists@4
	mov	ecx, DWORD PTR [esi+9768]
	mov	DWORD PTR [esi+ecx*4+5764], eax

; 709  :       td->facet_dlist_alloc = td->facet_dlist_count + 1;

	mov	edx, DWORD PTR [esi+9768]
	inc	edx
	mov	DWORD PTR [esi+9764], edx
$LN2@enlarge_fa:

; 710  :     };
; 711  : 
; 712  :     /* declare arrays to OpenGL */
; 713  :     glEnableClientState(GL_COLOR_ARRAY);

	mov	edi, DWORD PTR __imp__glEnableClientState@4
	push	32886					; 00008076H
	call	edi

; 714  :     glEnableClientState(GL_NORMAL_ARRAY);

	push	32885					; 00008075H
	call	edi

; 715  :     glEnableClientState(GL_VERTEX_ARRAY);

	push	32884					; 00008074H
	call	edi

; 716  :     //glInterleavedArrays(GL_C4F_N3F_V3F,sizeof(struct vercol),(void*)td->facetarray);
; 717  :     glColorPointer(4,GL_FLOAT,sizeof(struct vercol),td->facetarray);      

	mov	eax, DWORD PTR [esi+9812]
	push	eax
	push	44					; 0000002cH
	push	5126					; 00001406H
	push	4
	call	DWORD PTR __imp__glColorPointer@16

; 718  :     glNormalPointer(GL_FLOAT,sizeof(struct vercol),td->facetarray->n);

	mov	ecx, DWORD PTR [esi+9812]
	add	ecx, 16					; 00000010H
	push	ecx
	push	44					; 0000002cH
	push	5126					; 00001406H
	call	DWORD PTR __imp__glNormalPointer@12

; 719  :     glVertexPointer(3,GL_FLOAT,sizeof(struct vercol),td->facetarray->x);

	mov	edx, DWORD PTR [esi+9812]
	add	edx, 28					; 0000001cH
	push	edx
	push	44					; 0000002cH
	push	5126					; 00001406H
	push	3
	call	DWORD PTR __imp__glVertexPointer@16

; 720  :     glFlush();

	mov	edi, DWORD PTR __imp__glFlush@0
	call	edi

; 721  : 
; 722  :     // start display list
; 723  :     glNewList(td->facet_dlists[td->facet_dlist_count],GL_COMPILE);

	mov	eax, DWORD PTR [esi+9768]
	mov	ecx, DWORD PTR [esi+eax*4+5764]
	push	4864					; 00001300H
	push	ecx
	call	DWORD PTR __imp__glNewList@8

; 724  :     glDrawArrays(GL_TRIANGLES,0,td->facetcount);

	mov	edx, DWORD PTR [esi+9800]
	push	edx
	push	0
	push	4
	call	DWORD PTR __imp__glDrawArrays@12

; 725  :     glEndList();

	call	DWORD PTR __imp__glEndList@0

; 726  :     glFlush();

	call	edi

; 727  :     td->facet_dlist_count++;

	inc	DWORD PTR [esi+9768]
	pop	edi

; 728  :     td->facetcount = 0;

	mov	DWORD PTR [esi+9800], 0
	pop	esi
	pop	ebx

; 750  : 
; 751  : } // end enlarge_facet_array()

	pop	ebp
	ret	0
$LN3@enlarge_fa:

; 729  :     return;
; 730  :   }
; 731  : 
; 732  :   td->facetarray = (struct vercol*)realloc((char*)td->facetarray,
; 733  :                      (td->facetmax+more)*sizeof(struct vercol));

	mov	eax, DWORD PTR [esi+9820]
	add	eax, edi
	imul	eax, 44					; 0000002cH
	push	eax
	push	ebx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR [esi+9812], eax

; 734  :   if ( td->facetarray == NULL )

	test	eax, eax
	jne	SHORT $LN1@enlarge_fa

; 735  :   { kb_error(5695,"Graphics too complicated for arrays.  Switching to non-array graphics.\n",
; 736  :        WARNING);

	push	2
	push	OFFSET ??_C@_0EI@EHMFEGOO@Graphics?5too?5complicated?5for?5arr@
	push	5695					; 0000163fH
	call	_kb_error

; 737  :     sprintf(errmsg,"Trying to allocate %d facet structures of size %d\n.",
; 738  :          td->facetmax+more,(int)sizeof(struct vercol));

	mov	ecx, DWORD PTR [esi+9820]
	push	44					; 0000002cH
	add	ecx, edi
	push	ecx
	push	OFFSET ??_C@_0DE@DOAKLLM@Trying?5to?5allocate?5?$CFd?5facet?5stru@
	push	OFFSET _errmsg
	call	_sprintf

; 739  :     erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 740  : 
; 741  :     td->arraysflag = 0;

	xor	edi, edi

; 742  :     td->facetmax = 0;
; 743  :     free(old_array);

	push	ebx
	mov	DWORD PTR [esi+9772], edi
	mov	DWORD PTR [esi+9820], edi
	call	_free

; 744  :     free(td->edgearray); td->edgearray = NULL;

	mov	edx, DWORD PTR [esi+9808]
	push	edx
	call	_free
	add	esp, 40					; 00000028H
	mov	DWORD PTR [esi+9808], edi

; 745  :     td->doing_lazy = 0;

	mov	DWORD PTR [esi+9864], edi
	pop	edi
	pop	esi
	pop	ebx

; 750  : 
; 751  : } // end enlarge_facet_array()

	pop	ebp

; 746  :     glutPostRedisplay();

	jmp	_glutPostRedisplay@0
$LN1@enlarge_fa:

; 747  :     return;
; 748  :   }
; 749  :   td->facetmax += more;

	add	DWORD PTR [esi+9820], edi
	pop	edi
	pop	esi
	pop	ebx

; 750  : 
; 751  : } // end enlarge_facet_array()

	pop	ebp
	ret	0
_enlarge_facet_array ENDP
_TEXT	ENDS
PUBLIC	_kb_glNormal3fv
EXTRN	__imp__glNormal3fv@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _kb_glNormal3fv
_TEXT	SEGMENT
_td$ = 8						; size = 4
_v$ = 12						; size = 4
_kb_glNormal3fv PROC					; COMDAT

; 763  : { if ( !td->arraysflag ) glNormal3fv(v);

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _td$[ebp]
	cmp	DWORD PTR [eax+9772], 0
	jne	SHORT $LN2@kb_glNorma
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	call	DWORD PTR __imp__glNormal3fv@4

; 765  : }

	pop	ebp
	ret	0
$LN2@kb_glNorma:

; 764  :   else { td->kb_norm[0] = v[0]; td->kb_norm[1] = v[1]; td->kb_norm[2] = v[2]; }

	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax+1616]
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [eax+1620]
	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR [eax+1624]

; 765  : }

	pop	ebp
	ret	0
_kb_glNormal3fv ENDP
_TEXT	ENDS
PUBLIC	_kb_glNormal3dv
; Function compile flags: /Ogtp
;	COMDAT _kb_glNormal3dv
_TEXT	SEGMENT
_td$ = 8						; size = 4
_v$ = 12						; size = 4
_kb_glNormal3dv PROC					; COMDAT

; 767  : { td->kb_norm[0] = (float)v[0]; td->kb_norm[1] = (float)v[1]; td->kb_norm[2] = (float)v[2]; 

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _td$[ebp]

; 768  :   if ( !td->arraysflag ) glNormal3fv(td->kb_norm);

	cmp	DWORD PTR [eax+9772], 0
	mov	ecx, DWORD PTR _v$[ebp]
	fld	QWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1616]
	fstp	DWORD PTR [edx]
	fld	QWORD PTR [ecx+8]
	fstp	DWORD PTR [eax+1620]
	fld	QWORD PTR [ecx+16]
	fstp	DWORD PTR [eax+1624]
	jne	SHORT $LN1@kb_glNorma@2
	push	edx
	call	DWORD PTR __imp__glNormal3fv@4
$LN1@kb_glNorma@2:

; 769  : }

	pop	ebp
	ret	0
_kb_glNormal3dv ENDP
_TEXT	ENDS
PUBLIC	_kb_glAntiNormal3dv
; Function compile flags: /Ogtp
;	COMDAT _kb_glAntiNormal3dv
_TEXT	SEGMENT
tv158 = 8						; size = 4
tv157 = 8						; size = 4
tv153 = 8						; size = 4
_td$ = 8						; size = 4
_v$ = 12						; size = 4
_kb_glAntiNormal3dv PROC				; COMDAT

; 771  : { td->kb_norm[0] = -(float)v[0]; td->kb_norm[1] = -(float)v[1]; td->kb_norm[2] = -(float)v[2]; 

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _td$[ebp]

; 772  :   if ( !td->arraysflag ) glNormal3fv(td->kb_norm);

	cmp	DWORD PTR [eax+9772], 0
	mov	ecx, DWORD PTR _v$[ebp]
	fld	QWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+1616]
	fstp	DWORD PTR tv158[ebp]
	fld	DWORD PTR tv158[ebp]
	fchs
	fstp	DWORD PTR [edx]
	fld	QWORD PTR [ecx+8]
	fstp	DWORD PTR tv157[ebp]
	fld	DWORD PTR tv157[ebp]
	fchs
	fstp	DWORD PTR [eax+1620]
	fld	QWORD PTR [ecx+16]
	fstp	DWORD PTR tv153[ebp]
	fld	DWORD PTR tv153[ebp]
	fchs
	fstp	DWORD PTR [eax+1624]
	jne	SHORT $LN1@kb_glAntiN
	push	edx
	call	DWORD PTR __imp__glNormal3fv@4
$LN1@kb_glAntiN:

; 773  : }

	pop	ebp
	ret	0
_kb_glAntiNormal3dv ENDP
_TEXT	ENDS
PUBLIC	__real@406fe00000000000
PUBLIC	_e_glColor
EXTRN	__imp__glColor4fv@4:PROC
EXTRN	__imp__glColor4ubv@4:PROC
EXTRN	_edge_rgb_color_attr:DWORD
_BSS	SEGMENT
_rgba	DD	040H DUP (?)
_ea	DD	01H DUP (?)
_eb	DD	01H DUP (?)
_eg	DD	01H DUP (?)
_er	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _e_glColor
_TEXT	SEGMENT
tv195 = -4						; size = 4
tv192 = -4						; size = 4
tv189 = -4						; size = 4
tv185 = -4						; size = 4
_td$ = 8						; size = 4
_c$ = 12						; size = 4
_e_glColor PROC						; COMDAT

; 784  : { 

	push	ebp
	mov	ebp, esp
	push	ecx

; 785  :   if ( edge_rgb_color_attr > 0 )

	cmp	DWORD PTR _edge_rgb_color_attr, 0

; 786  :   {
; 787  :     if ( !td->arraysflag ) 

	mov	eax, DWORD PTR _td$[ebp]
	jle	$LN6@e_glColor
	cmp	DWORD PTR [eax+9772], 0
	jne	SHORT $LN5@e_glColor

; 788  :       glColor4ubv((const GLubyte*)&c);

	lea	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	DWORD PTR __imp__glColor4ubv@4

; 799  :   }
; 800  : } // end e_glColor()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@e_glColor:

; 789  :     else 
; 790  :     { er=(float)(((c>>24)&0xFF)/255.0); eg=(float)(((c>>16)&0xFF)/255.0); 

	mov	eax, DWORD PTR _c$[ebp]
	mov	edx, eax
	sar	edx, 24					; 00000018H
	and	edx, 255				; 000000ffH
	mov	DWORD PTR tv195[ebp], edx
	fild	DWORD PTR tv195[ebp]
	mov	ecx, eax
	fld	QWORD PTR __real@406fe00000000000
	sar	ecx, 16					; 00000010H
	and	ecx, 255				; 000000ffH
	fdiv	ST(1), ST(0)
	mov	DWORD PTR tv192[ebp], ecx

; 791  :       eb=(float)(((c>>8)&0xFF)/255.0); ea= (float)(((c)&0xFF)/255.0); 

	mov	edx, eax
	sar	edx, 8
	and	edx, 255				; 000000ffH
	and	eax, 255				; 000000ffH
	fxch	ST(1)
	fstp	DWORD PTR _er
	fild	DWORD PTR tv192[ebp]
	mov	DWORD PTR tv189[ebp], edx
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _eg
	fild	DWORD PTR tv189[ebp]
	mov	DWORD PTR tv185[ebp], eax
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _eb
	fild	DWORD PTR tv185[ebp]
	fdivrp	ST(1), ST(0)

; 797  :     else 
; 798  :     { er = rgba[c][0]; eg = rgba[c][1]; eb = rgba[c][2]; ea = rgba[c][3]; }

	fstp	DWORD PTR _ea

; 799  :   }
; 800  : } // end e_glColor()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@e_glColor:

; 792  :     }
; 793  :   }
; 794  :   else 
; 795  :   { if ( !td->arraysflag ) 

	cmp	DWORD PTR [eax+9772], 0
	jne	SHORT $LN2@e_glColor

; 796  :       glColor4fv(rgba[c]);

	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 4
	add	ecx, OFFSET _rgba
	push	ecx
	call	DWORD PTR __imp__glColor4fv@4

; 799  :   }
; 800  : } // end e_glColor()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@e_glColor:

; 797  :     else 
; 798  :     { er = rgba[c][0]; eg = rgba[c][1]; eb = rgba[c][2]; ea = rgba[c][3]; }

	mov	eax, DWORD PTR _c$[ebp]
	shl	eax, 4
	fld	DWORD PTR _rgba[eax]
	fstp	DWORD PTR _er
	fld	DWORD PTR _rgba[eax+4]
	fstp	DWORD PTR _eg
	fld	DWORD PTR _rgba[eax+8]
	fstp	DWORD PTR _eb
	fld	DWORD PTR _rgba[eax+12]
	fstp	DWORD PTR _ea

; 799  :   }
; 800  : } // end e_glColor()

	mov	esp, ebp
	pop	ebp
	ret	0
_e_glColor ENDP
_TEXT	ENDS
PUBLIC	__real@40dd4c0000000000
PUBLIC	_e_glVertex3dv
EXTRN	__imp__glVertex3d@24:PROC
;	COMDAT __real@40dd4c0000000000
CONST	SEGMENT
__real@40dd4c0000000000 DQ 040dd4c0000000000r	; 30000
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _e_glVertex3dv
_TEXT	SEGMENT
tv306 = 8						; size = 4
tv303 = 8						; size = 4
tv297 = 8						; size = 4
tv294 = 8						; size = 4
tv288 = 8						; size = 4
tv285 = 8						; size = 4
_td$ = 8						; size = 4
_x$ = 12						; size = 4
_e_glVertex3dv PROC					; COMDAT

; 809  : { if ( !td->arraysflag ) 

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _td$[ebp]
	cmp	DWORD PTR [esi+9772], 0
	jne	SHORT $LN3@e_glVertex

; 810  :   { glVertex3d((GLdouble)x[0],(GLdouble)x[1],(GLdouble)x[2]); return; }

	mov	eax, DWORD PTR _x$[ebp]
	fld	QWORD PTR [eax+16]
	sub	esp, 24					; 00000018H
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR [eax+8]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [eax]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__glVertex3d@24
	pop	esi

; 826  : 
; 827  : } // end e_glVertex3dv()

	pop	ebp
	ret	0
$LN3@e_glVertex:

; 811  :   if ( !td->edgearray ) 

	cmp	DWORD PTR [esi+9808], 0
	jne	SHORT $LN2@e_glVertex

; 812  :      td->edgemax = 0;

	mov	DWORD PTR [esi+9816], 0
$LN2@e_glVertex:

; 813  :   if ( td->edgecount > td->edgemax-5 ) 

	mov	eax, DWORD PTR [esi+9816]
	sub	eax, 5
	cmp	DWORD PTR [esi+9792], eax
	jle	SHORT $LN1@e_glVertex

; 814  :      enlarge_edge_array(td);

	push	esi
	call	_enlarge_edge_array
	add	esp, 4
$LN1@e_glVertex:

; 815  :   td->edgearray[td->edgecount].c[0] = er;

	mov	ecx, DWORD PTR [esi+9792]
	fld	DWORD PTR _er
	mov	edx, DWORD PTR [esi+9808]
	imul	ecx, 44					; 0000002cH
	fstp	DWORD PTR [ecx+edx]

; 816  :   td->edgearray[td->edgecount].c[1] = eg;

	mov	eax, DWORD PTR [esi+9792]
	mov	ecx, DWORD PTR [esi+9808]
	fld	DWORD PTR _eg
	imul	eax, 44					; 0000002cH
	fstp	DWORD PTR [eax+ecx+4]

; 817  :   td->edgearray[td->edgecount].c[2] = eb;

	mov	edx, DWORD PTR [esi+9792]
	mov	eax, DWORD PTR [esi+9808]
	fld	DWORD PTR _eb
	imul	edx, 44					; 0000002cH
	fstp	DWORD PTR [edx+eax+8]

; 818  :   td->edgearray[td->edgecount].c[3] = ea;

	mov	ecx, DWORD PTR [esi+9792]
	mov	edx, DWORD PTR [esi+9808]
	fld	DWORD PTR _ea
	imul	ecx, 44					; 0000002cH
	fstp	DWORD PTR [ecx+edx+12]

; 819  :   td->edgearray[td->edgecount].x[0] = (fabs(x[0]) < 30000) ? (float)x[0] : 0.0;

	mov	ecx, DWORD PTR _x$[ebp]
	fld	QWORD PTR [ecx]
	fabs
	fld	QWORD PTR __real@40dd4c0000000000
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	fldz
	test	ah, 65					; 00000041H
	jne	SHORT $LN6@e_glVertex
	fld	QWORD PTR [ecx]
	fstp	DWORD PTR tv306[ebp]
	fld	DWORD PTR tv306[ebp]
	jmp	SHORT $LN7@e_glVertex
$LN6@e_glVertex:
	fld	ST(0)
$LN7@e_glVertex:
	mov	eax, DWORD PTR [esi+9792]
	fstp	DWORD PTR tv303[ebp]
	fld	DWORD PTR tv303[ebp]
	mov	edx, DWORD PTR [esi+9808]
	imul	eax, 44					; 0000002cH
	fstp	DWORD PTR [eax+edx+28]

; 820  :   td->edgearray[td->edgecount].x[1] = (fabs(x[1]) < 30000) ? (float)x[1] : 0.0;

	fld	QWORD PTR [ecx+8]
	fabs
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN8@e_glVertex
	fld	QWORD PTR [ecx+8]
	fstp	DWORD PTR tv297[ebp]
	fld	DWORD PTR tv297[ebp]
	jmp	SHORT $LN9@e_glVertex
$LN8@e_glVertex:
	fld	ST(0)
$LN9@e_glVertex:
	mov	eax, DWORD PTR [esi+9792]
	fstp	DWORD PTR tv294[ebp]
	fld	DWORD PTR tv294[ebp]
	mov	edx, DWORD PTR [esi+9808]
	imul	eax, 44					; 0000002cH
	fstp	DWORD PTR [eax+edx+32]

; 821  :   td->edgearray[td->edgecount].x[2] = (fabs(x[2]) < 30000) ? (float)x[2] : 0.0;

	fld	QWORD PTR [ecx+16]
	fabs
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN11@e_glVertex
	fstp	ST(0)
	fld	QWORD PTR [ecx+16]
	fstp	DWORD PTR tv288[ebp]
	fld	DWORD PTR tv288[ebp]
$LN11@e_glVertex:
	mov	eax, DWORD PTR [esi+9792]
	fstp	DWORD PTR tv285[ebp]
	mov	ecx, DWORD PTR [esi+9808]
	fld	DWORD PTR tv285[ebp]
	imul	eax, 44					; 0000002cH
	fstp	DWORD PTR [eax+ecx+36]

; 822  :   td->edgearray[td->edgecount].n[0] = td->kb_norm[0];

	mov	edx, DWORD PTR [esi+9792]
	mov	eax, DWORD PTR [esi+9808]
	fld	DWORD PTR [esi+1616]
	imul	edx, 44					; 0000002cH
	fstp	DWORD PTR [edx+eax+16]

; 823  :   td->edgearray[td->edgecount].n[1] = td->kb_norm[1];

	mov	ecx, DWORD PTR [esi+9792]
	mov	edx, DWORD PTR [esi+9808]
	fld	DWORD PTR [esi+1620]
	imul	ecx, 44					; 0000002cH
	fstp	DWORD PTR [ecx+edx+20]

; 824  :   td->edgearray[td->edgecount].n[2] = td->kb_norm[2];

	mov	eax, DWORD PTR [esi+9792]
	mov	ecx, DWORD PTR [esi+9808]
	fld	DWORD PTR [esi+1624]
	imul	eax, 44					; 0000002cH
	fstp	DWORD PTR [eax+ecx+24]

; 825  :   td->edgecount++;

	inc	DWORD PTR [esi+9792]
	pop	esi

; 826  : 
; 827  : } // end e_glVertex3dv()

	pop	ebp
	ret	0
_e_glVertex3dv ENDP
_TEXT	ENDS
PUBLIC	_f_glColor
EXTRN	_facet_rgb_color_attr:DWORD
_BSS	SEGMENT
_fb	DD	01H DUP (?)
_fg	DD	01H DUP (?)
_fr	DD	01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _f_glColor
_TEXT	SEGMENT
tv188 = -4						; size = 4
tv185 = -4						; size = 4
tv181 = -4						; size = 4
_td$ = 8						; size = 4
_c$ = 12						; size = 4
_f_glColor PROC						; COMDAT

; 838  : { 

	push	ebp
	mov	ebp, esp
	push	ecx

; 839  :   if ( facet_rgb_color_attr > 0 )

	cmp	DWORD PTR _facet_rgb_color_attr, 0
	jle	SHORT $LN6@f_glColor

; 840  :   {
; 841  :     if ( !td->arraysflag ) 

	mov	eax, DWORD PTR _td$[ebp]
	cmp	DWORD PTR [eax+9772], 0
	jne	SHORT $LN5@f_glColor

; 842  :        glColor4ubv((const GLubyte*)&c);

	lea	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	DWORD PTR __imp__glColor4ubv@4

; 853  :   }
; 854  :  
; 855  : } // end f_glColor()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@f_glColor:

; 843  :     else 
; 844  :     { fr=(float)(((c>>24)&0xFF)/255.); fg=(float)(((c>>16)&0xFF)/255.);

	mov	eax, DWORD PTR _c$[ebp]
	mov	edx, eax
	sar	edx, 24					; 00000018H
	and	edx, 255				; 000000ffH
	mov	DWORD PTR tv188[ebp], edx
	fild	DWORD PTR tv188[ebp]
	mov	ecx, eax
	fld	QWORD PTR __real@406fe00000000000
	sar	ecx, 16					; 00000010H
	and	ecx, 255				; 000000ffH
	fdiv	ST(1), ST(0)
	mov	DWORD PTR tv185[ebp], ecx

; 845  :       fb=(float)(((c>>8)&0xFF)/255.); 

	sar	eax, 8
	and	eax, 255				; 000000ffH
	fxch	ST(1)
	fstp	DWORD PTR _fr
	fild	DWORD PTR tv185[ebp]
	mov	DWORD PTR tv181[ebp], eax
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _fg
	fild	DWORD PTR tv181[ebp]
	fdivrp	ST(1), ST(0)

; 851  :     else 
; 852  :     { fr = rgba[c][0]; fg = rgba[c][1]; fb = rgba[c][2];  }

	fstp	DWORD PTR _fb

; 853  :   }
; 854  :  
; 855  : } // end f_glColor()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@f_glColor:

; 846  :     }
; 847  :   }
; 848  :   else 
; 849  :   { if ( !td->arraysflag ) 
; 850  :       glColor4fv(rgba[c]);

	mov	eax, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _td$[ebp]
	shl	eax, 4
	cmp	DWORD PTR [edx+9772], 0
	jne	SHORT $LN2@f_glColor
	add	eax, OFFSET _rgba
	push	eax
	call	DWORD PTR __imp__glColor4fv@4

; 853  :   }
; 854  :  
; 855  : } // end f_glColor()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@f_glColor:

; 851  :     else 
; 852  :     { fr = rgba[c][0]; fg = rgba[c][1]; fb = rgba[c][2];  }

	fld	DWORD PTR _rgba[eax]
	fstp	DWORD PTR _fr
	fld	DWORD PTR _rgba[eax+4]
	fstp	DWORD PTR _fg
	fld	DWORD PTR _rgba[eax+8]
	fstp	DWORD PTR _fb

; 853  :   }
; 854  :  
; 855  : } // end f_glColor()

	mov	esp, ebp
	pop	ebp
	ret	0
_f_glColor ENDP
_TEXT	ENDS
PUBLIC	_f_glVertex3dv
EXTRN	__imp__glVertex3f@12:PROC
_BSS	SEGMENT
_fa	DD	01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _f_glVertex3dv
_TEXT	SEGMENT
tv321 = 8						; size = 4
tv320 = 8						; size = 4
tv319 = 8						; size = 4
tv169 = 8						; size = 4
tv156 = 8						; size = 4
tv143 = 8						; size = 4
_td$ = 8						; size = 4
_x$ = 12						; size = 4
_f_glVertex3dv PROC					; COMDAT

; 864  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 865  :   if ( !td->arraysflag )

	mov	esi, DWORD PTR _td$[ebp]
	cmp	DWORD PTR [esi+9772], 0
	jne	SHORT $LN3@f_glVertex

; 866  :   { glVertex3f((float)x[0],(float)x[1],(float)x[2]); return; }

	mov	eax, DWORD PTR _x$[ebp]
	fld	QWORD PTR [eax+16]
	sub	esp, 12					; 0000000cH
	fstp	DWORD PTR tv321[ebp]
	fld	DWORD PTR tv321[ebp]
	fstp	DWORD PTR [esp+8]
	fld	QWORD PTR [eax+8]
	fstp	DWORD PTR tv320[ebp]
	fld	DWORD PTR tv320[ebp]
	fstp	DWORD PTR [esp+4]
	fld	QWORD PTR [eax]
	fstp	DWORD PTR tv319[ebp]
	fld	DWORD PTR tv319[ebp]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glVertex3f@12
	pop	esi

; 882  : 
; 883  : } // end f_glVertex3dv()

	pop	ebp
	ret	0
$LN3@f_glVertex:

; 867  :   if ( !td->facetarray ) 

	cmp	DWORD PTR [esi+9812], 0
	jne	SHORT $LN2@f_glVertex

; 868  :     td->facetmax = 0;

	mov	DWORD PTR [esi+9820], 0
$LN2@f_glVertex:

; 869  :   if ( td->facetcount > td->facetmax-5 ) 

	mov	eax, DWORD PTR [esi+9820]
	sub	eax, 5
	cmp	DWORD PTR [esi+9800], eax
	jle	SHORT $LN1@f_glVertex

; 870  :     enlarge_facet_array(td);

	push	esi
	call	_enlarge_facet_array
	add	esp, 4
$LN1@f_glVertex:

; 871  :   td->facetarray[td->facetcount].c[0] = fr;

	mov	ecx, DWORD PTR [esi+9800]
	fld	DWORD PTR _fr
	mov	edx, DWORD PTR [esi+9812]
	imul	ecx, 44					; 0000002cH
	fstp	DWORD PTR [ecx+edx]

; 872  :   td->facetarray[td->facetcount].c[1] = fg;

	mov	eax, DWORD PTR [esi+9800]
	mov	ecx, DWORD PTR [esi+9812]
	fld	DWORD PTR _fg
	imul	eax, 44					; 0000002cH
	fstp	DWORD PTR [eax+ecx+4]

; 873  :   td->facetarray[td->facetcount].c[2] = fb;

	mov	edx, DWORD PTR [esi+9800]
	mov	eax, DWORD PTR [esi+9812]
	fld	DWORD PTR _fb
	imul	edx, 44					; 0000002cH
	fstp	DWORD PTR [edx+eax+8]

; 874  :   td->facetarray[td->facetcount].c[3] = fa;

	mov	ecx, DWORD PTR [esi+9800]
	mov	edx, DWORD PTR [esi+9812]
	fld	DWORD PTR _fa
	imul	ecx, 44					; 0000002cH
	fstp	DWORD PTR [ecx+edx+12]

; 875  :   td->facetarray[td->facetcount].x[0] = (fabs(x[0]) < 30000) ? (float)x[0] : 0;

	mov	ecx, DWORD PTR _x$[ebp]
	fld	QWORD PTR [ecx]
	fabs
	fld	QWORD PTR __real@40dd4c0000000000
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	fldz
	test	ah, 65					; 00000041H
	jne	SHORT $LN6@f_glVertex
	fld	QWORD PTR [ecx]
	fstp	DWORD PTR tv143[ebp]
	jmp	SHORT $LN7@f_glVertex
$LN6@f_glVertex:
	fst	DWORD PTR tv143[ebp]
$LN7@f_glVertex:
	mov	eax, DWORD PTR [esi+9800]
	fld	DWORD PTR tv143[ebp]
	mov	edx, DWORD PTR [esi+9812]
	imul	eax, 44					; 0000002cH
	fstp	DWORD PTR [eax+edx+28]

; 876  :   td->facetarray[td->facetcount].x[1] = (fabs(x[1]) < 30000) ? (float)x[1] : 0;

	fld	QWORD PTR [ecx+8]
	fabs
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN8@f_glVertex
	fld	QWORD PTR [ecx+8]
	fstp	DWORD PTR tv156[ebp]
	jmp	SHORT $LN9@f_glVertex
$LN8@f_glVertex:
	fst	DWORD PTR tv156[ebp]
$LN9@f_glVertex:
	mov	eax, DWORD PTR [esi+9800]
	fld	DWORD PTR tv156[ebp]
	mov	edx, DWORD PTR [esi+9812]
	imul	eax, 44					; 0000002cH
	fstp	DWORD PTR [eax+edx+32]

; 877  :   td->facetarray[td->facetcount].x[2] = (fabs(x[2]) < 30000) ? (float)x[2] : 0;

	fld	QWORD PTR [ecx+16]
	fabs
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN10@f_glVertex
	fstp	ST(0)
	fld	QWORD PTR [ecx+16]
$LN10@f_glVertex:
	mov	eax, DWORD PTR [esi+9800]
	fstp	DWORD PTR tv169[ebp]
	mov	ecx, DWORD PTR [esi+9812]
	fld	DWORD PTR tv169[ebp]
	imul	eax, 44					; 0000002cH
	fstp	DWORD PTR [eax+ecx+36]

; 878  :   td->facetarray[td->facetcount].n[0] = td->kb_norm[0];

	mov	edx, DWORD PTR [esi+9800]
	mov	eax, DWORD PTR [esi+9812]
	fld	DWORD PTR [esi+1616]
	imul	edx, 44					; 0000002cH
	fstp	DWORD PTR [edx+eax+16]

; 879  :   td->facetarray[td->facetcount].n[1] = td->kb_norm[1];

	mov	ecx, DWORD PTR [esi+9800]
	mov	edx, DWORD PTR [esi+9812]
	fld	DWORD PTR [esi+1620]
	imul	ecx, 44					; 0000002cH
	fstp	DWORD PTR [ecx+edx+20]

; 880  :   td->facetarray[td->facetcount].n[2] = td->kb_norm[2];

	mov	eax, DWORD PTR [esi+9800]
	mov	ecx, DWORD PTR [esi+9812]
	fld	DWORD PTR [esi+1624]
	imul	eax, 44					; 0000002cH
	fstp	DWORD PTR [eax+ecx+24]

; 881  :   td->facetcount++;

	inc	DWORD PTR [esi+9800]
	pop	esi

; 882  : 
; 883  : } // end f_glVertex3dv()

	pop	ebp
	ret	0
_f_glVertex3dv ENDP
_TEXT	ENDS
PUBLIC	_Ogl_init
; Function compile flags: /Ogtp
;	COMDAT _Ogl_init
_TEXT	SEGMENT
_Ogl_init PROC						; COMDAT

; 931  : }

	ret	0
_Ogl_init ENDP
_TEXT	ENDS
PUBLIC	_Ogl_finish
; Function compile flags: /Ogtp
;	COMDAT _Ogl_finish
_TEXT	SEGMENT
_Ogl_finish PROC					; COMDAT

; 935  : }

	ret	0
_Ogl_finish ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@OHNHDFEH@?5?5?$CF1?4?$CKs?5?9?5Camera?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_06BHCLCNKA@?5?$CF1?4?$CKs?$AA@		; `string'
PUBLIC	_set_title
EXTRN	_graphics_title:BYTE
EXTRN	_graphics_title2:BYTE
EXTRN	_graphics_title3:BYTE
EXTRN	_GraphicsWindowTitleText:DWORD
EXTRN	_datafilename:BYTE
;	COMDAT ??_C@_0BE@OHNHDFEH@?5?5?$CF1?4?$CKs?5?9?5Camera?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BE@OHNHDFEH@?5?5?$CF1?4?$CKs?5?9?5Camera?5?$CFd?$AA@ DB '  %1.*s -'
	DB	' Camera %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06BHCLCNKA@?5?$CF1?4?$CKs?$AA@
CONST	SEGMENT
??_C@_06BHCLCNKA@?5?$CF1?4?$CKs?$AA@ DB ' %1.*s', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _set_title
_TEXT	SEGMENT
_titlespot$ = -4					; size = 4
_td$ = 8						; size = 4
_set_title PROC						; COMDAT

; 982  : { 

	push	ebp
	mov	ebp, esp
	push	ecx

; 983  :   size_t titlespot = ((int)strlen(datafilename) > 60) ? (strlen(datafilename)-60):0;

	mov	eax, OFFSET _datafilename
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL22@set_title:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL22@set_title
	sub	eax, edx
	cmp	eax, 60					; 0000003cH
	jle	SHORT $LN12@set_title
	add	eax, -60				; ffffffc4H
	mov	DWORD PTR _titlespot$[ebp], eax
	jmp	SHORT $LN13@set_title
$LN12@set_title:
	mov	DWORD PTR _titlespot$[ebp], 0
$LN13@set_title:
	push	ebx

; 984  :   size_t k = td - gthread_data;

	mov	ebx, DWORD PTR _td$[ebp]
	mov	ecx, ebx
	sub	ecx, OFFSET _gthread_data
	mov	eax, 1777706755				; 69f5a703H
	imul	ecx
	push	esi
	sar	edx, 12					; 0000000cH
	push	edi
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx

; 1011 :                 sprintf(td->wintitle," %1.*s",WINTITLESIZE-10,datafilename+titlespot);

	lea	esi, DWORD PTR [ebx+8]
	cmp	edi, 1
	jne	SHORT $LN9@set_title

; 985  : 
; 986  : #ifdef MPI_EVOLVER
; 987  : 
; 988  :     if ( this_task == MASTER_TASK )
; 989  :     {
; 990  :       if ( k == 1 )
; 991  :         sprintf(td->wintitle," %1.*s (task %d from task %d)  ",
; 992  :            WINTITLESIZE-30, datafilename+titlespot,
; 993  :             this_task,td->mpi_graph_task
; 994  :            );
; 995  :       else  sprintf(td->wintitle," %1.*s (task %d from task %d) - Camera %d",
; 996  :          WINTITLESIZE-45,datafilename+titlespot,this_task,td->mpi_graph_task,k);
; 997  :     }
; 998  :     else
; 999  :     {
; 1000 :       if ( k == 1 )
; 1001 :         sprintf(td->wintitle,"%1.*s (task %d)  ",WINTITLESIZE-20,
; 1002 :           datafilename+titlespot,this_task);
; 1003 :       else  sprintf(td->wintitle," %1.*s (task %d) - Camera %d",
; 1004 :           WINTITLESIZE-30, datafilename+titlespot,this_task,k);
; 1005 :     }
; 1006 : #else
; 1007 :     if ( k == 1 )
; 1008 : #ifdef __L_EVOLVER__
; 1009 :         {
; 1010 :         if (GraphicsWindowTitleText == NULL)

	mov	ecx, DWORD PTR _GraphicsWindowTitleText
	test	ecx, ecx
	jne	SHORT $LN8@set_title

; 1011 :                 sprintf(td->wintitle," %1.*s",WINTITLESIZE-10,datafilename+titlespot);

	mov	eax, DWORD PTR _titlespot$[ebp]
	lea	ecx, DWORD PTR _datafilename[eax]
	push	ecx
	push	110					; 0000006eH
	push	OFFSET ??_C@_06BHCLCNKA@?5?$CF1?4?$CKs?$AA@
	push	esi
	call	_sprintf
	add	esp, 16					; 00000010H

; 1012 :         else

	jmp	SHORT $LN6@set_title
$LN8@set_title:

; 1013 :                 strcpy(td->wintitle, GraphicsWindowTitleText);

	mov	edx, esi
	npad	4
$LL14@set_title:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL14@set_title

; 1014 :         }
; 1015 : #else
; 1016 :         sprintf(td->wintitle," %1.*s",WINTITLESIZE-10,datafilename+titlespot);
; 1017 : #endif
; 1018 : 
; 1019 :     else  

	jmp	SHORT $LN6@set_title
$LN9@set_title:

; 1020 : 		sprintf(td->wintitle,"  %1.*s - Camera %d",WINTITLESIZE-20, datafilename+titlespot,k);

	mov	edx, DWORD PTR _titlespot$[ebp]
	push	edi
	lea	eax, DWORD PTR _datafilename[edx]
	push	eax
	push	100					; 00000064H
	push	OFFSET ??_C@_0BE@OHNHDFEH@?5?5?$CF1?4?$CKs?5?9?5Camera?5?$CFd?$AA@
	push	esi
	call	_sprintf
	add	esp, 20					; 00000014H
$LN6@set_title:

; 1021 : #endif
; 1022 :     td->new_title_flag = 1;
; 1023 :     switch (k)

	dec	edi
	mov	DWORD PTR [ebx+4], 1
	je	SHORT $LN3@set_title
	dec	edi
	je	SHORT $LN2@set_title
	dec	edi
	jne	SHORT $LN4@set_title

; 1026 :       case 3: strcpy(graphics_title3,td->wintitle); break;

	mov	edx, OFFSET _graphics_title3
	mov	eax, esi
	sub	edx, esi
$LL17@set_title:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL17@set_title
	pop	edi
	pop	esi
	pop	ebx

; 1027 :     }
; 1028 :   
; 1029 : } /* end set_title() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@set_title:

; 1025 :       case 2: strcpy(graphics_title2,td->wintitle); break;

	mov	edx, OFFSET _graphics_title2
	mov	eax, esi
	sub	edx, esi
	npad	6
$LL16@set_title:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL16@set_title
	pop	edi
	pop	esi
	pop	ebx

; 1027 :     }
; 1028 :   
; 1029 : } /* end set_title() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@set_title:

; 1024 :     { case 1: strcpy(graphics_title,td->wintitle); break;

	mov	edx, OFFSET _graphics_title
	mov	eax, esi
	sub	edx, esi
	npad	6
$LL15@set_title:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL15@set_title
$LN4@set_title:
	pop	edi
	pop	esi
	pop	ebx

; 1027 :     }
; 1028 :   
; 1029 : } /* end set_title() */

	mov	esp, ebp
	pop	ebp
	ret	0
_set_title ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@MMECHPLH@Picked?5facet?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0BA@EHHONEJM@Picked?5edge?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0BC@FPEDBONN@Picked?5vertex?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	__real@46293e5939a08cea
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_my_own_pick_func
EXTRN	_pickfnum:DWORD
EXTRN	_pickenum:DWORD
EXTRN	_msg:DWORD
EXTRN	_pickvnum:DWORD
EXTRN	_elnames:BYTE
EXTRN	_graphgen:PROC
EXTRN	__imp__glGetFloatv@8:PROC
_BSS	SEGMENT
_my_own_pick_facet_depth DQ 01H DUP (?)
_my_own_pick_facet DD 01H DUP (?)
	ALIGN	8

_my_own_pick_edge_depth DQ 01H DUP (?)
_my_own_pick_edge DD 01H DUP (?)
	ALIGN	8

_my_own_pick_vertex_depth DQ 01H DUP (?)
_my_own_pick_vertex DD 01H DUP (?)
	ALIGN	8

_my_own_pick_radsq DQ 01H DUP (?)
_my_own_pick_y DQ 01H DUP (?)
_my_own_pick_x DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BB@MMECHPLH@Picked?5facet?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BB@MMECHPLH@Picked?5facet?5?$CFs?6?$AA@ DB 'Picked facet %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EHHONEJM@Picked?5edge?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BA@EHHONEJM@Picked?5edge?5?$CFs?6?$AA@ DB 'Picked edge %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FPEDBONN@Picked?5vertex?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BC@FPEDBONN@Picked?5vertex?5?$CFs?6?$AA@ DB 'Picked vertex %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT __real@46293e5939a08cea
CONST	SEGMENT
__real@46293e5939a08cea DQ 046293e5939a08cear	; 1e+030
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _my_own_pick_func
_TEXT	SEGMENT
_viewport$ = -148					; size = 16
_modelmat$ = -132					; size = 64
_projmat$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_my_own_pick_func PROC					; COMDAT

; 1212 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1213 :   int i,j,k;
; 1214 :   float projmat[4][4];
; 1215 :   float modelmat[4][4];
; 1216 :   GLint viewport[4];
; 1217 : 
; 1218 :   glGetIntegerv(GL_VIEWPORT,viewport);

	lea	eax, DWORD PTR _viewport$[ebp]
	push	eax
	push	2978					; 00000ba2H
	call	DWORD PTR __imp__glGetIntegerv@8

; 1219 :   my_own_pick_x = 2*(REAL)x/viewport[2] - 1.0;

	fild	DWORD PTR _viewport$[ebp+8]
	fild	DWORD PTR _x$[ebp]

; 1220 :   my_own_pick_y = -(2*(REAL)y/viewport[3] - 1.0);
; 1221 :   my_own_pick_radsq = 10*2.0/viewport[2]*2.0/viewport[3];
; 1222 : 
; 1223 :   /* Get current transformation matrices; note these are transposed
; 1224 :      from my convention */
; 1225 :   glGetFloatv(GL_PROJECTION_MATRIX,projmat[0]); 

	mov	esi, DWORD PTR __imp__glGetFloatv@8
	fld	QWORD PTR __real@4000000000000000
	lea	ecx, DWORD PTR _projmat$[ebp]
	push	ecx
	fmul	ST(1), ST(0)
	push	2983					; 00000ba7H
	fxch	ST(1)
	fdiv	ST(0), ST(2)
	fld1
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _my_own_pick_x
	fild	DWORD PTR _viewport$[ebp+12]
	fild	DWORD PTR _y$[ebp]
	fmul	ST(0), ST(3)
	fdiv	ST(0), ST(1)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fchs
	fstp	QWORD PTR _my_own_pick_y
	fld	QWORD PTR __real@4034000000000000
	fdivrp	ST(3), ST(0)
	fxch	ST(2)
	fmulp	ST(1), ST(0)
	fdivrp	ST(1), ST(0)
	fstp	QWORD PTR _my_own_pick_radsq
	call	esi

; 1226 :   glGetFloatv(GL_MODELVIEW_MATRIX,modelmat[0]); 

	lea	edx, DWORD PTR _modelmat$[ebp]
	push	edx
	push	2982					; 00000ba6H
	call	esi

; 1227 : 
; 1228 :   /* get product */
; 1229 :   for ( i = 0 ; i < 4 ; i++ )

	fldz
	xor	esi, esi
	xor	eax, eax
$LN33@my_own_pic:

; 1230 :   { for ( j = 0 ; j < 4 ; j++ )
; 1231 :     { REAL sum = 0;
; 1232 :       for ( k = 0 ; k < 4 ; k++ )
; 1233 :       sum += projmat[k][i]*modelmat[j][k]; 

	fld	DWORD PTR _projmat$[ebp+eax]

; 1234 :       my_own_pick_transmat[i][j] = sum;

	mov	ecx, DWORD PTR _my_own_pick_transmat[eax]
	fmul	DWORD PTR _modelmat$[ebp]
	fadd	ST(0), ST(1)
	fld	DWORD PTR _projmat$[ebp+eax+16]
	fmul	DWORD PTR _modelmat$[ebp+4]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _modelmat$[ebp+8]
	fmul	DWORD PTR _projmat$[ebp+eax+32]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _projmat$[ebp+eax+48]
	fmul	DWORD PTR _modelmat$[ebp+12]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx]
	mov	edx, DWORD PTR _my_own_pick_transmat[eax]
	fld	DWORD PTR _projmat$[ebp+eax]
	fmul	DWORD PTR _modelmat$[ebp+16]
	fadd	ST(0), ST(1)
	fld	DWORD PTR _projmat$[ebp+eax+16]
	fmul	DWORD PTR _modelmat$[ebp+20]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _modelmat$[ebp+24]
	fmul	DWORD PTR _projmat$[ebp+eax+32]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _projmat$[ebp+eax+48]
	fmul	DWORD PTR _modelmat$[ebp+28]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx+8]
	mov	ecx, DWORD PTR _my_own_pick_transmat[eax]
	fld	DWORD PTR _projmat$[ebp+eax]
	fmul	DWORD PTR _modelmat$[ebp+32]
	fadd	ST(0), ST(1)
	fld	DWORD PTR _projmat$[ebp+eax+16]
	fmul	DWORD PTR _modelmat$[ebp+36]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _modelmat$[ebp+40]
	fmul	DWORD PTR _projmat$[ebp+eax+32]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _projmat$[ebp+eax+48]
	fmul	DWORD PTR _modelmat$[ebp+44]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+16]
	mov	edx, DWORD PTR _my_own_pick_transmat[eax]
	fld	DWORD PTR _projmat$[ebp+eax]
	mov	ecx, 4
	fmul	DWORD PTR _modelmat$[ebp+48]
	fadd	ST(0), ST(1)
	fld	DWORD PTR _projmat$[ebp+eax+16]
	fmul	DWORD PTR _modelmat$[ebp+52]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _modelmat$[ebp+56]
	fmul	DWORD PTR _projmat$[ebp+eax+32]
	faddp	ST(1), ST(0)
	fld	DWORD PTR _projmat$[ebp+eax+48]
	fmul	DWORD PTR _modelmat$[ebp+60]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx+24]

; 1235 :     }
; 1236 :     for ( ; j < SDIM ; j++ )

	mov	edx, DWORD PTR _web+616
	cmp	edx, ecx
	jle	SHORT $LN22@my_own_pic
$LN24@my_own_pic:

; 1237 :       my_own_pick_transmat[i][j] = 0.0;

	mov	edx, DWORD PTR _my_own_pick_transmat[eax]
	fst	QWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _web+616
	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LN24@my_own_pic
$LN22@my_own_pic:

; 1238 :     my_own_pick_transmat[i][SDIM] = my_own_pick_transmat[i][3];

	mov	ecx, DWORD PTR _my_own_pick_transmat[eax]
	fld	QWORD PTR [ecx+24]
	add	eax, 4
	fstp	QWORD PTR [ecx+edx*8]
	cmp	eax, 16					; 00000010H
	jl	$LN33@my_own_pic

; 1239 :   }
; 1240 :   if ( SDIM == 2 )

	mov	edx, DWORD PTR _web+616
	cmp	edx, 2
	jne	$LN21@my_own_pic

; 1241 :   { // not using z coordinate
; 1242 :     for ( i = 0 ; i < 4 ; i++ )
; 1243 :       my_own_pick_transmat[i][2] = my_own_pick_transmat[i][3];

	mov	eax, DWORD PTR _my_own_pick_transmat
	fstp	ST(0)
	fld	QWORD PTR [eax+24]
	fstp	QWORD PTR [eax+16]
	mov	eax, DWORD PTR _my_own_pick_transmat+4
	fld	QWORD PTR [eax+24]
	fstp	QWORD PTR [eax+16]
	mov	eax, DWORD PTR _my_own_pick_transmat+8
	fld	QWORD PTR [eax+24]
	fstp	QWORD PTR [eax+16]
	mov	eax, DWORD PTR _my_own_pick_transmat+12
	fld	QWORD PTR [eax+24]
	fstp	QWORD PTR [eax+16]

; 1244 :    // and have to undo baffling factor of 2 from vt2[]
; 1245 :    for ( i = 0 ; i < 3 ; i++ )
; 1246 :      for ( j = 0 ; j < 3 ; j++ )
; 1247 :        my_own_pick_transmat[i][j] /= 2;

	mov	eax, DWORD PTR _my_own_pick_transmat
	fld	QWORD PTR [eax]
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR _my_own_pick_transmat
	fld	QWORD PTR [eax+8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax+8]
	mov	eax, DWORD PTR _my_own_pick_transmat
	fld	QWORD PTR [eax+16]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax+16]
	mov	eax, DWORD PTR _my_own_pick_transmat+4
	fld	QWORD PTR [eax]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR _my_own_pick_transmat+4
	fld	QWORD PTR [eax+8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax+8]
	mov	eax, DWORD PTR _my_own_pick_transmat+4
	fld	QWORD PTR [eax+16]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax+16]
	mov	eax, DWORD PTR _my_own_pick_transmat+8
	fld	QWORD PTR [eax]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR _my_own_pick_transmat+8
	fld	QWORD PTR [eax+8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax+8]
	mov	eax, DWORD PTR _my_own_pick_transmat+8
	fmul	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+16]

; 1248 : 
; 1249 :   }
; 1250 :   
; 1251 :   else if ( SDIM > 3 )

	jmp	SHORT $LN7@my_own_pic
$LN21@my_own_pic:
	cmp	edx, 3
	jle	SHORT $LN142@my_own_pic

; 1252 :   {
; 1253 :     for ( i = 0 ; i < 4 ; i++ )

	mov	ecx, OFFSET _my_own_pick_transmat
$LN9@my_own_pic:

; 1254 :     {  my_own_pick_transmat[i][SDIM] = my_own_pick_transmat[i][3];

	mov	eax, DWORD PTR [ecx]
	fld	QWORD PTR [eax+24]
	fstp	QWORD PTR [eax+edx*8]

; 1255 :        for ( j = 3; j < SDIM ; j++ )

	mov	edx, DWORD PTR _web+616
	mov	eax, 3
	cmp	edx, eax
	jle	SHORT $LN8@my_own_pic
$LN6@my_own_pic:

; 1256 :         my_own_pick_transmat[i][j] = 0.0;

	mov	edx, DWORD PTR [ecx]
	fst	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _web+616
	inc	eax
	cmp	eax, edx
	jl	SHORT $LN6@my_own_pic
$LN8@my_own_pic:

; 1252 :   {
; 1253 :     for ( i = 0 ; i < 4 ; i++ )

	add	ecx, 4
	cmp	ecx, OFFSET _my_own_pick_transmat+16
	jl	SHORT $LN9@my_own_pic
$LN142@my_own_pic:

; 1255 :        for ( j = 3; j < SDIM ; j++ )

	fstp	ST(0)
$LN7@my_own_pic:

; 1257 :     }
; 1258 :   }
; 1259 :   
; 1260 :    
; 1261 : 
; 1262 :   my_own_pick_vertex = NULLID;
; 1263 :   my_own_pick_edge = NULLID;
; 1264 :   my_own_pick_facet = NULLID;
; 1265 :   my_own_pick_vertex_depth = 1e30;

	fld	QWORD PTR __real@46293e5939a08cea
	mov	DWORD PTR _my_own_pick_vertex, esi
	fst	QWORD PTR _my_own_pick_vertex_depth
	mov	DWORD PTR _my_own_pick_edge, esi

; 1266 :   my_own_pick_edge_depth = 1e30;

	fst	QWORD PTR _my_own_pick_edge_depth
	mov	DWORD PTR _my_own_pick_facet, esi

; 1267 :   my_own_pick_facet_depth = 1e30;

	fstp	QWORD PTR _my_own_pick_facet_depth

; 1268 :   my_own_pick_flag = 1;

	mov	DWORD PTR _my_own_pick_flag, 1

; 1269 :   graphgen();

	call	_graphgen

; 1270 :   my_own_pick_flag = 0;
; 1271 : 
; 1272 :   erroutstring("\n");  /* to get to next line after prompt */

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	DWORD PTR _my_own_pick_flag, esi
	call	_erroutstring

; 1273 :   if ( valid_id(my_own_pick_vertex) )

	mov	eax, DWORD PTR _my_own_pick_vertex
	add	esp, 4
	pop	esi
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@my_own_pic

; 1274 :     { pickvnum = ordinal(my_own_pick_vertex) + 1;

	and	eax, 134217727				; 07ffffffH
	inc	eax

; 1275 :       sprintf(msg,"Picked vertex %s\n",ELNAME(my_own_pick_vertex));

	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	mov	DWORD PTR _pickvnum, eax
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0BC@FPEDBONN@Picked?5vertex?5?$CFs?6?$AA@
	push	eax
	call	_sprintf

; 1276 :       erroutstring(msg); 

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring
	add	esp, 28					; 0000001cH
$LN3@my_own_pic:

; 1277 :     }
; 1278 : 
; 1279 :   if ( valid_id(my_own_pick_edge) ) 

	mov	eax, DWORD PTR _my_own_pick_edge
	test	eax, 268435456				; 10000000H
	je	SHORT $LN2@my_own_pic

; 1280 :   { 
; 1281 :     pickenum = ordinal(my_own_pick_edge) + 1;

	and	eax, 134217727				; 07ffffffH
	inc	eax

; 1282 :     sprintf(msg,"Picked edge %s\n",ELNAME(my_own_pick_edge));

	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	mov	DWORD PTR _pickenum, eax
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0BA@EHHONEJM@Picked?5edge?5?$CFs?6?$AA@
	push	edx
	call	_sprintf

; 1283 :     erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring
	add	esp, 28					; 0000001cH
$LN2@my_own_pic:

; 1284 :   }
; 1285 : 
; 1286 :   if ( valid_id(my_own_pick_facet) ) 

	mov	eax, DWORD PTR _my_own_pick_facet
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@my_own_pic

; 1287 :   { pickfnum = ordinal(my_own_pick_facet) + 1;

	and	eax, 134217727				; 07ffffffH
	inc	eax

; 1288 :     sprintf(msg,"Picked facet %s\n",ELNAME(my_own_pick_facet));

	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	mov	DWORD PTR _pickfnum, eax
	call	_sprintf
	mov	ecx, DWORD PTR _msg
	push	OFFSET _elnames
	push	OFFSET ??_C@_0BB@MMECHPLH@Picked?5facet?5?$CFs?6?$AA@
	push	ecx
	call	_sprintf

; 1289 :     erroutstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_erroutstring
	add	esp, 28					; 0000001cH
$LN1@my_own_pic:

; 1290 :   }
; 1291 :   erroutstring(current_prompt);

	mov	eax, DWORD PTR _current_prompt
	push	eax
	call	_erroutstring

; 1292 : 
; 1293 : } /* end my_own_pick_func() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	add	esp, 4
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_my_own_pick_func ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_my_own_edge_pick
EXTRN	_matvec_mul:PROC
; Function compile flags: /Ogtp
;	COMDAT _my_own_edge_pick
_TEXT	SEGMENT
_qy$ = -84						; size = 8
tv388 = -76						; size = 8
_tailx$ = -68						; size = 32
_headx$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_gtail$ = 8						; size = 4
_ghead$ = 12						; size = 4
_e_id$ = 16						; size = 4
_my_own_edge_pick PROC					; COMDAT

; 1307 : { int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 1308 :   REAL tailx[4],headx[4];
; 1309 :   REAL px,py,qx,qy,ex,ey,lensq,dotprod,lambda,this_z,distsq;
; 1310 : 
; 1311 :   if ( ! valid_id(e_id) )

	mov	ebx, DWORD PTR _e_id$[ebp]
	push	esi
	mov	esi, DWORD PTR _gtail$[ebp]
	push	edi
	mov	edi, DWORD PTR _ghead$[ebp]
	test	ebx, 268435456				; 10000000H
	je	$LN3@my_own_edg

; 1312 :      return;
; 1313 : 
; 1314 :   /* get endpoint pixel coordinates */
; 1315 :   matvec_mul(my_own_pick_transmat,gtail->x,tailx,4,SDIM+1);

	mov	eax, DWORD PTR _web+616
	inc	eax
	push	eax
	push	4
	lea	ecx, DWORD PTR _tailx$[ebp]
	push	ecx
	push	esi
	push	OFFSET _my_own_pick_transmat
	call	_matvec_mul

; 1316 :   matvec_mul(my_own_pick_transmat,ghead->x,headx,4,SDIM+1);

	mov	edx, DWORD PTR _web+616
	inc	edx
	push	edx
	push	4
	lea	eax, DWORD PTR _headx$[ebp]
	push	eax
	push	edi
	push	OFFSET _my_own_pick_transmat
	call	_matvec_mul

; 1317 :   for ( i = 0 ; i < 3 ; i++ ) // apply homogeneous coordinate
; 1318 :   { tailx[i] /= tailx[3];

	fld	QWORD PTR _tailx$[ebp]
	fld	QWORD PTR _tailx$[ebp+24]
	add	esp, 40					; 00000028H
	fdiv	ST(1), ST(0)

; 1319 :     headx[i] /= headx[3];

	fld	QWORD PTR _headx$[ebp]
	fld	QWORD PTR _headx$[ebp+24]
	fdiv	ST(1), ST(0)
	fld	QWORD PTR _tailx$[ebp+8]
	fdiv	ST(0), ST(3)
	fld	QWORD PTR _headx$[ebp+8]
	fdiv	ST(0), ST(2)
	fst	QWORD PTR _headx$[ebp+8]
	fld	QWORD PTR _tailx$[ebp+16]
	fdivrp	ST(5), ST(0)
	fxch	ST(4)
	fstp	QWORD PTR _tailx$[ebp+16]
	fld	QWORD PTR _headx$[ebp+16]
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _headx$[ebp+16]

; 1320 :   }
; 1321 : 
; 1322 :   px = my_own_pick_x - tailx[0];

	fld	QWORD PTR _my_own_pick_x
	fld	ST(0)
	fsub	ST(0), ST(5)

; 1323 :   py = my_own_pick_y - tailx[1];

	fld	QWORD PTR _my_own_pick_y
	fld	ST(0)
	fsub	ST(0), ST(4)

; 1324 :   qx = my_own_pick_x - headx[0];

	fxch	ST(3)
	fsub	ST(0), ST(5)

; 1325 :   qy = my_own_pick_y - headx[1];

	fxch	ST(1)
	fsubrp	ST(6), ST(0)
	fxch	ST(5)
	fstp	QWORD PTR _qy$[ebp]

; 1326 : 
; 1327 :   /* see if endpoints in pick circle */
; 1328 :   if ( px*px + py*py < my_own_pick_radsq )

	fld	ST(1)
	fmul	ST(0), ST(2)
	fld	ST(1)
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fst	QWORD PTR tv388[ebp]
	fcomp	QWORD PTR _my_own_pick_radsq
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN22@my_own_edg

; 1329 :   { if ( valid_id(gtail->v_id) && (tailx[2] < my_own_pick_vertex_depth) )

	mov	esi, DWORD PTR [esi+132]
	test	esi, 268435456				; 10000000H
	je	SHORT $LN22@my_own_edg
	fld	QWORD PTR _my_own_pick_vertex_depth
	fld	QWORD PTR _tailx$[ebp+16]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN29@my_own_edg

; 1330 :     { my_own_pick_vertex = gtail->v_id;
; 1331 :       my_own_pick_vertex_depth = tailx[2];

	fstp	QWORD PTR _my_own_pick_vertex_depth
	mov	DWORD PTR _my_own_pick_vertex, esi
	jmp	SHORT $LN22@my_own_edg
$LN29@my_own_edg:

; 1329 :   { if ( valid_id(gtail->v_id) && (tailx[2] < my_own_pick_vertex_depth) )

	fstp	ST(0)
$LN22@my_own_edg:

; 1332 :     }
; 1333 :   }
; 1334 :   if ( qx*qx + qy*qy < my_own_pick_radsq )

	fld	QWORD PTR _qy$[ebp]
	fmul	ST(0), ST(0)
	fld	ST(5)
	fmulp	ST(6), ST(0)
	faddp	ST(5), ST(0)
	fld	QWORD PTR _my_own_pick_radsq
	fcom	ST(5)
	fnstsw	ax
	fstp	ST(5)
	test	ah, 65					; 00000041H
	jne	SHORT $LN5@my_own_edg

; 1335 :   { if ( valid_id(ghead->v_id) && (headx[2] < my_own_pick_vertex_depth) )

	mov	edi, DWORD PTR [edi+132]
	test	edi, 268435456				; 10000000H
	je	SHORT $LN5@my_own_edg
	fld	QWORD PTR _my_own_pick_vertex_depth
	fld	QWORD PTR _headx$[ebp+16]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN37@my_own_edg

; 1336 :     { my_own_pick_vertex = ghead->v_id;
; 1337 :       my_own_pick_vertex_depth = headx[2];

	fstp	QWORD PTR _my_own_pick_vertex_depth
	mov	DWORD PTR _my_own_pick_vertex, edi
	jmp	SHORT $LN5@my_own_edg
$LN37@my_own_edg:

; 1335 :   { if ( valid_id(ghead->v_id) && (headx[2] < my_own_pick_vertex_depth) )

	fstp	ST(0)
$LN5@my_own_edg:

; 1338 :     }
; 1339 :   }
; 1340 : 
; 1341 :   
; 1342 :   /* now find closest point on edge, via barycentric parameter lambda */
; 1343 :   ex = headx[0] - tailx[0];

	fxch	ST(3)
	fsubrp	ST(5), ST(0)

; 1344 :   ey = headx[1] - tailx[1];

	fld	QWORD PTR _headx$[ebp+8]
	fsubrp	ST(2), ST(0)

; 1345 :   lensq = ex*ex + ey*ey;

	fld	ST(1)
	fmul	ST(0), ST(2)
	fld	ST(5)
	fmul	ST(0), ST(6)
	faddp	ST(1), ST(0)

; 1346 :   dotprod = px*ex + py*ey;

	fxch	ST(2)
	fmulp	ST(1), ST(0)
	fxch	ST(4)
	fmulp	ST(2), ST(0)
	fxch	ST(3)
	faddp	ST(1), ST(0)

; 1347 :   lambda = dotprod/lensq;

	fdiv	ST(0), ST(2)

; 1348 :   if ( lambda < 0.0 || lambda > 1.0 )

	fldz
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN40@my_own_edg
	fld1
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN43@my_own_edg

; 1349 :     return;
; 1350 : 
; 1351 :   distsq = px*px + py*py - lambda*lambda*(ex*ex + ey*ey);

	fld	ST(1)
	fmul	ST(0), ST(2)
	fmulp	ST(4), ST(0)
	fld	QWORD PTR tv388[ebp]
	fsubrp	ST(4), ST(0)

; 1352 :   if ( distsq > my_own_pick_radsq )

	fxch	ST(3)
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	je	SHORT $LN46@my_own_edg

; 1353 :      return;
; 1354 : 
; 1355 :   this_z = (1-lambda)*tailx[2] + lambda*tailx[2];

	fsub	ST(1), ST(0)
	fld	QWORD PTR _tailx$[ebp+16]
	fmul	ST(2), ST(0)
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)

; 1356 :   if ( this_z < my_own_pick_edge_depth )

	fld	QWORD PTR _my_own_pick_edge_depth
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN49@my_own_edg

; 1357 :   { my_own_pick_edge = e_id;
; 1358 :     my_own_pick_edge_depth = this_z;

	pop	edi
	fstp	QWORD PTR _my_own_pick_edge_depth
	pop	esi
	mov	DWORD PTR _my_own_pick_edge, ebx
	pop	ebx

; 1359 :   }
; 1360 : } /* end my_own_edge_pick() */ 

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@my_own_edg:

; 1348 :   if ( lambda < 0.0 || lambda > 1.0 )

	fstp	ST(1)
$LN40@my_own_edg:
	fstp	ST(0)
	pop	edi
	fstp	ST(1)
	pop	esi

; 1356 :   if ( this_z < my_own_pick_edge_depth )

	fstp	ST(0)
	pop	ebx

; 1359 :   }
; 1360 : } /* end my_own_edge_pick() */ 

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@my_own_edg:

; 1352 :   if ( distsq > my_own_pick_radsq )

	fstp	ST(0)
$LN49@my_own_edg:

; 1356 :   if ( this_z < my_own_pick_edge_depth )

	fstp	ST(0)
$LN3@my_own_edg:

; 1359 :   }
; 1360 : } /* end my_own_edge_pick() */ 

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_my_own_edge_pick ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_my_own_facet_pick
; Function compile flags: /Ogtp
;	COMDAT _my_own_facet_pick
_TEXT	SEGMENT
_py$ = -108						; size = 8
_base$ = -100						; size = 32
_head2$ = -68						; size = 32
_head1$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_g$ = 8							; size = 4
_f_id$ = 12						; size = 4
_my_own_facet_pick PROC					; COMDAT

; 1373 : { int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, DWORD PTR _g$[ebp]
	push	edi

; 1374 :   REAL base[4],head1[4],head2[4];
; 1375 :   REAL px,py,ax,ay,bx,by;
; 1376 :   REAL det,alpha,beta;
; 1377 :   REAL this_z;
; 1378 : 
; 1379 :   if ( ! valid_id(f_id) )

	mov	edi, DWORD PTR _f_id$[ebp]
	test	edi, 268435456				; 10000000H
	je	$LN2@my_own_fac

; 1380 :      return;
; 1381 : 
; 1382 :   /* get vertex pixel coordinates */
; 1383 :   matvec_mul(my_own_pick_transmat,g[0].x,base,4,SDIM+1);

	mov	eax, DWORD PTR _web+616
	inc	eax
	push	eax
	push	4
	lea	ecx, DWORD PTR _base$[ebp]
	push	ecx
	push	esi
	push	OFFSET _my_own_pick_transmat
	call	_matvec_mul

; 1384 :   matvec_mul(my_own_pick_transmat,g[1].x,head1,4,SDIM+1);

	mov	edx, DWORD PTR _web+616
	inc	edx
	push	edx
	push	4
	lea	eax, DWORD PTR _head1$[ebp]
	push	eax
	lea	ecx, DWORD PTR [esi+144]
	push	ecx
	push	OFFSET _my_own_pick_transmat
	call	_matvec_mul

; 1385 :   matvec_mul(my_own_pick_transmat,g[2].x,head2,4,SDIM+1);

	mov	edx, DWORD PTR _web+616
	inc	edx
	push	edx
	push	4
	lea	eax, DWORD PTR _head2$[ebp]
	push	eax
	add	esi, 288				; 00000120H
	push	esi
	push	OFFSET _my_own_pick_transmat
	call	_matvec_mul

; 1386 :   for ( i = 0 ; i < 3 ; i++ ) // apply homogeneous coordinate
; 1387 :   { base[i] /= base[3];

	fld	QWORD PTR _base$[ebp]
	fld	QWORD PTR _base$[ebp+24]
	add	esp, 60					; 0000003cH
	fdiv	ST(1), ST(0)

; 1388 :     head1[i] /= head1[3];

	fld	QWORD PTR _head1$[ebp]
	fld	QWORD PTR _head1$[ebp+24]
	fdiv	ST(1), ST(0)

; 1389 :     head2[i] /= head2[3];

	fld	QWORD PTR _head2$[ebp]
	fld	QWORD PTR _head2$[ebp+24]
	fdiv	ST(1), ST(0)
	fld	QWORD PTR _base$[ebp+8]
	fdiv	ST(0), ST(5)
	fld	QWORD PTR _head1$[ebp+8]
	fdiv	ST(0), ST(4)
	fstp	QWORD PTR _head1$[ebp+8]
	fld	QWORD PTR _head2$[ebp+8]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _head2$[ebp+8]
	fld	QWORD PTR _base$[ebp+16]
	fdivrp	ST(6), ST(0)
	fxch	ST(5)
	fstp	QWORD PTR _base$[ebp+16]
	fld	QWORD PTR _head1$[ebp+16]
	fdivrp	ST(3), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR _head1$[ebp+16]
	fld	QWORD PTR _head2$[ebp+16]
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _head2$[ebp+16]

; 1390 :   }
; 1391 : 
; 1392 : 
; 1393 :   px = my_own_pick_x - base[0];

	fld	QWORD PTR _my_own_pick_x
	fsub	ST(0), ST(4)

; 1394 :   py = my_own_pick_y - base[1];

	fld	QWORD PTR _my_own_pick_y
	fsub	ST(0), ST(4)
	fstp	QWORD PTR _py$[ebp]

; 1395 :   ax = head1[0] - base[0];

	fxch	ST(2)
	fsub	ST(0), ST(4)

; 1396 :   ay = head1[1] - base[1];

	fld	QWORD PTR _head1$[ebp+8]
	fsub	ST(0), ST(4)

; 1397 :   bx = head2[0] - base[0];

	fxch	ST(2)
	fsubrp	ST(5), ST(0)

; 1398 :   by = head2[1] - base[1];

	fld	QWORD PTR _head2$[ebp+8]
	fsubrp	ST(4), ST(0)

; 1399 : 
; 1400 :   /* Calculate barycentric parameters of pick point */
; 1401 :   det = ax*by - ay*bx;

	fld	ST(3)
	fmul	ST(0), ST(1)
	fld	ST(5)
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)

; 1402 :   if ( det == 0 ) return;

	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN18@my_own_fac

; 1403 :   alpha = (by*px - bx*py)/det;

	fxch	ST(4)
	fmul	ST(0), ST(3)
	fld	QWORD PTR _py$[ebp]
	fmul	ST(6), ST(0)
	fxch	ST(1)
	fsubrp	ST(6), ST(0)
	fxch	ST(5)
	fdiv	ST(0), ST(4)

; 1404 :   beta  = (ax*py - ay*px)/det;

	fxch	ST(1)
	fmulp	ST(5), ST(0)
	fxch	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(3)
	fsubrp	ST(1), ST(0)
	fdivrp	ST(1), ST(0)

; 1405 : 
; 1406 :   if ( alpha < 0.0 || beta < 0.0 || alpha+beta > 1.0 )

	fldz
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN27@my_own_fac
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN24@my_own_fac
	fld	ST(0)
	fadd	ST(0), ST(2)
	fld1
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jnp	SHORT $LN27@my_own_fac

; 1407 :     return;
; 1408 : 
; 1409 :   this_z = (1-alpha-beta)*base[2] + alpha*head1[2] + beta*head2[2];

	fsub	ST(0), ST(2)
	fsub	ST(0), ST(1)
	fmul	QWORD PTR _base$[ebp+16]
	fld	QWORD PTR _head1$[ebp+16]
	fmulp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fmul	QWORD PTR _head2$[ebp+16]
	faddp	ST(1), ST(0)

; 1410 :   if ( this_z < my_own_pick_facet_depth )

	fld	QWORD PTR _my_own_pick_facet_depth
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN30@my_own_fac

; 1411 :   { my_own_pick_facet = f_id;

	mov	DWORD PTR _my_own_pick_facet, edi

; 1412 :     my_own_pick_facet_depth = this_z;

	fstp	QWORD PTR _my_own_pick_facet_depth
	pop	edi
	pop	esi

; 1413 :   }} /* end my_own_facet_pick() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@my_own_fac:

; 1402 :   if ( det == 0 ) return;

	fstp	ST(0)
	fstp	ST(3)
	fstp	ST(2)
$LN27@my_own_fac:

; 1405 : 
; 1406 :   if ( alpha < 0.0 || beta < 0.0 || alpha+beta > 1.0 )

	fstp	ST(1)
	fstp	ST(1)
$LN30@my_own_fac:

; 1410 :   if ( this_z < my_own_pick_facet_depth )

	fstp	ST(0)
$LN2@my_own_fac:
	pop	edi
	pop	esi

; 1413 :   }} /* end my_own_facet_pick() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@my_own_fac:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	pop	edi
	fstp	ST(0)
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_my_own_facet_pick ENDP
_TEXT	ENDS
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@4072c00000000000
PUBLIC	__real@3f60624dd2f1a9fc
PUBLIC	__$ArrayPad$
PUBLIC	_mouse_loc_func
EXTRN	_clip_coeff_set_flag:DWORD
EXTRN	_dot:PROC
EXTRN	_mat2d_setup:PROC
EXTRN	_fix_ctm:PROC
EXTRN	_mat_mult:PROC
EXTRN	_HOMDIM:DWORD
EXTRN	_clip_coeff:BYTE
EXTRN	_clip_view_flag:DWORD
EXTRN	_slice_coeff:BYTE
EXTRN	_slice_coeff_set_flag:DWORD
EXTRN	_view:DWORD
EXTRN	_slice_view_flag:DWORD
EXTRN	__CIsin:PROC
EXTRN	__CIcos:PROC
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@4072c00000000000
CONST	SEGMENT
__real@4072c00000000000 DQ 04072c00000000000r	; 300
CONST	ENDS
;	COMDAT __real@3f60624dd2f1a9fc
CONST	SEGMENT
__real@3f60624dd2f1a9fc DQ 03f60624dd2f1a9fcr	; 0.002
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _mouse_loc_func
_TEXT	SEGMENT
_rotqXvS$95102 = -480					; size = 28
_temp2$95120 = -476					; size = 24
_cfudge$95121 = -452					; size = 8
tv876 = -444						; size = 8
tv868 = -444						; size = 8
_dang$95118 = -436					; size = 8
tv1230 = -432						; size = 4
tv1176 = -432						; size = 4
tv1174 = -432						; size = 4
tv1171 = -432						; size = 4
tv1169 = -432						; size = 4
tv1104 = -432						; size = 4
_dth$95117 = -428					; size = 8
_dth$95106 = -428					; size = 8
tv1163 = -424						; size = 4
tv1161 = -424						; size = 4
tv1159 = -424						; size = 4
tv1156 = -424						; size = 4
tv1153 = -424						; size = 4
tv1151 = -424						; size = 4
tv1149 = -424						; size = 4
tv1146 = -424						; size = 4
tv1144 = -424						; size = 4
tv1141 = -424						; size = 4
tv1138 = -424						; size = 4
tv1136 = -424						; size = 4
tv1134 = -424						; size = 4
tv1126 = -424						; size = 4
tv1094 = -424						; size = 4
tv1092 = -424						; size = 4
_rotxJ$95103 = -420					; size = 392
_temp1$95119 = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_mouse_loc_func PROC					; COMDAT

; 1473 : { struct graph_thread_data *td = GET_DATA;

	push	ebp
	mov	ebp, esp
	sub	esp, 480				; 000001e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	call	_glutGetWindow@0

; 1474 :   int i,j;
; 1475 :   int update_global_view_flag = 0;
; 1476 : 
; 1477 :   td->newx = x;
; 1478 :   td->newy = y; 

	mov	ecx, DWORD PTR _y$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR _x$[ebp]
	imul	esi, 9896				; 000026a8H
	add	esi, OFFSET _gthread_data
	xor	ebx, ebx
	mov	DWORD PTR [esi+264], eax
	mov	DWORD PTR [esi+268], ecx

; 1479 :   if ( td->mouse_left_state == GLUT_DOWN )

	cmp	DWORD PTR [esi+1732], ebx
	jne	$LN4@mouse_loc_

; 1480 : 
; 1481 :   { switch ( td->mouse_mode )

	mov	edx, DWORD PTR [esi+1728]
	dec	edx
	push	edi
	cmp	edx, 5
	ja	$LN53@mouse_loc_
	jmp	DWORD PTR $LN76@mouse_loc_[edx*4]
$LN35@mouse_loc_:

; 1482 :     {  case MM_SLICE:
; 1483 :          if ( slice_view_flag )

	cmp	DWORD PTR _slice_view_flag, ebx
	je	SHORT $LN34@mouse_loc_

; 1484 :           { slice_coeff[SDIM] += (td->newx-td->oldx)*td->xscale/view[0][0];

	sub	eax, DWORD PTR [esi+256]
	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR tv1176[ebp], eax
	fild	DWORD PTR tv1176[ebp]
	mov	eax, DWORD PTR _view
	mov	edx, DWORD PTR [eax]

; 1485 :             slice_coeff_set_flag = 1;

	mov	eax, 1
	fmul	QWORD PTR [esi+232]
	fdiv	QWORD PTR [edx]
	mov	DWORD PTR _slice_coeff_set_flag, eax
	fadd	QWORD PTR _slice_coeff[ecx*8]
	fstp	QWORD PTR _slice_coeff[ecx*8]

; 1486 :             td->newarraysflag = 1;
; 1487 :             break;

	jmp	$LN74@mouse_loc_
$LN34@mouse_loc_:

; 1488 :           }
; 1489 :           else if ( clip_view_flag )

	cmp	DWORD PTR _clip_view_flag, ebx
	je	SHORT $LN32@mouse_loc_

; 1490 :           { clip_coeff[0][SDIM] += (td->newx-td->oldx)*td->xscale/view[0][0];

	sub	eax, DWORD PTR [esi+256]
	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR tv1174[ebp], eax
	fild	DWORD PTR tv1174[ebp]
	mov	eax, DWORD PTR _view
	mov	edx, DWORD PTR [eax]
	fmul	QWORD PTR [esi+232]
	fdiv	QWORD PTR [edx]
	fadd	QWORD PTR _clip_coeff[ecx*8]
	fstp	QWORD PTR _clip_coeff[ecx*8]

; 1491 :             clip_coeff_set_flag = 1;
; 1492 :             td->newarraysflag = 1;
; 1493 :             break;

	jmp	$LN75@mouse_loc_
$LN32@mouse_loc_:

; 1494 :           }
; 1495 :           else
; 1496 :           /* reset back to rotate by default and fall through */
; 1497 :             td->mouse_mode = MM_ROTATE;

	mov	DWORD PTR [esi+1728], 1
$LN54@mouse_loc_:

; 1498 :  
; 1499 :       case MM_ROTATE:    
; 1500 :        mat_mult(td->to_focus,td->view,td->view,HOMDIM,HOMDIM,HOMDIM);

	mov	eax, DWORD PTR _HOMDIM
	push	eax
	push	eax
	push	eax
	lea	edi, DWORD PTR [esi+280]
	push	edi
	lea	eax, DWORD PTR [esi+768]
	push	edi
	push	eax
	call	_mat_mult

; 1501 :        fix_ctm(td->view,(REAL)( td->newx - td->oldx),
; 1502 :                        -(REAL)(td->newy - td->oldy));

	mov	ecx, DWORD PTR [esi+268]
	sub	ecx, DWORD PTR [esi+260]
	mov	edx, DWORD PTR [esi+264]
	sub	edx, DWORD PTR [esi+256]
	mov	DWORD PTR tv1171[ebp], ecx
	fild	DWORD PTR tv1171[ebp]
	add	esp, 8
	mov	DWORD PTR tv1169[ebp], edx
	fchs
	fstp	QWORD PTR [esp+8]
	fild	DWORD PTR tv1169[ebp]
	fstp	QWORD PTR [esp]
	push	edi
	call	_fix_ctm

; 1503 :        mat_mult(td->from_focus,td->view,td->view,HOMDIM,HOMDIM,HOMDIM);

	mov	eax, DWORD PTR _HOMDIM
	push	eax
	push	eax
	push	eax
	push	edi
	lea	eax, DWORD PTR [esi+1192]
	push	edi
	push	eax
	call	_mat_mult
	add	esp, 44					; 0000002cH

; 1504 :        update_global_view_flag = 1;

	mov	ebx, 1

; 1505 :        break;

	jmp	$LN53@mouse_loc_
$LN29@mouse_loc_:

; 1506 : 
; 1507 :       case MM_SCALE:
; 1508 :         mat_mult(td->to_focus,td->view,td->view,HOMDIM,HOMDIM,HOMDIM);

	mov	eax, DWORD PTR _HOMDIM
	push	eax
	push	eax
	push	eax
	lea	edi, DWORD PTR [esi+280]
	push	edi
	lea	ecx, DWORD PTR [esi+768]
	push	edi
	push	ecx
	call	_mat_mult

; 1509 :         for(i = 0 ; i < HOMDIM-1; i++ )

	mov	ecx, DWORD PTR _HOMDIM
	lea	edx, DWORD PTR [ecx-1]
	add	esp, 24					; 00000018H
	xor	ebx, ebx
	test	edx, edx
	jle	SHORT $LN26@mouse_loc_

; 1506 : 
; 1507 :       case MM_SCALE:
; 1508 :         mat_mult(td->to_focus,td->view,td->view,HOMDIM,HOMDIM,HOMDIM);

	fld	QWORD PTR __real@3f60624dd2f1a9fc
	mov	DWORD PTR tv1104[ebp], edi
	fld1
$LN55@mouse_loc_:

; 1510 :             for ( j = 0 ; j < HOMDIM ; j++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN27@mouse_loc_
	mov	eax, DWORD PTR tv1104[ebp]
	mov	eax, DWORD PTR [eax]
$LN25@mouse_loc_:

; 1511 :                 td->view[i][j] *= 1.0 +0.002*(td->newx-td->oldx);

	mov	ecx, DWORD PTR [esi+264]
	sub	ecx, DWORD PTR [esi+256]
	inc	edx
	mov	DWORD PTR tv1163[ebp], ecx
	fild	DWORD PTR tv1163[ebp]
	add	eax, 8
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _HOMDIM
	cmp	edx, ecx
	jl	SHORT $LN25@mouse_loc_
$LN27@mouse_loc_:

; 1509 :         for(i = 0 ; i < HOMDIM-1; i++ )

	add	DWORD PTR tv1104[ebp], 4
	inc	ebx
	lea	edx, DWORD PTR [ecx-1]
	cmp	ebx, edx
	jl	SHORT $LN55@mouse_loc_
	fstp	ST(1)
	fstp	ST(0)
$LN26@mouse_loc_:

; 1512 :         mat_mult(td->from_focus,td->view,td->view,HOMDIM,HOMDIM,HOMDIM);

	push	ecx
	push	ecx
	push	ecx
	push	edi
	lea	eax, DWORD PTR [esi+1192]
	push	edi
	push	eax
	call	_mat_mult
	add	esp, 24					; 00000018H

; 1513 :         update_global_view_flag = 1;

	mov	ebx, 1

; 1514 :         break;

	jmp	$LN53@mouse_loc_
$LN22@mouse_loc_:

; 1515 : 
; 1516 :       case MM_TRANSLATE:
; 1517 :         if ( SDIM == 2 )
; 1518 :         { td->view[0][2] += (td->newx-td->oldx)*td->xscale;

	sub	eax, DWORD PTR [esi+256]
	cmp	DWORD PTR _web+616, 2
	jne	$LN21@mouse_loc_
	mov	ecx, DWORD PTR [esi+280]
	mov	DWORD PTR tv1161[ebp], eax
	fild	DWORD PTR tv1161[ebp]

; 1527 :           td->view[2][HOMDIM-1] -= (td->newy-td->oldy)*td->yscale;
; 1528 :           td->to_focus[1][HOMDIM-1] -= (td->newx-td->oldx)*td->xscale;
; 1529 :           td->to_focus[2][HOMDIM-1] += (td->newy-td->oldy)*td->yscale;
; 1530 :           td->from_focus[1][HOMDIM-1] += (td->newx-td->oldx)*td->xscale;
; 1531 :           td->from_focus[2][HOMDIM-1] -= (td->newy-td->oldy)*td->yscale;
; 1532 :         };
; 1533 :         update_global_view_flag = 1;

	mov	ebx, 1
	fmul	QWORD PTR [esi+232]
	fadd	QWORD PTR [ecx+16]
	fstp	QWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [esi+268]
	sub	ecx, DWORD PTR [esi+260]
	mov	eax, DWORD PTR [esi+284]
	mov	DWORD PTR tv1159[ebp], ecx
	fild	DWORD PTR tv1159[ebp]
	fmul	QWORD PTR [esi+240]
	fsubr	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+16]
	mov	edx, DWORD PTR [esi+264]
	sub	edx, DWORD PTR [esi+256]
	mov	eax, DWORD PTR [esi+768]
	mov	DWORD PTR tv1156[ebp], edx
	fild	DWORD PTR tv1156[ebp]
	fmul	QWORD PTR [esi+232]
	fsubr	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+16]
	mov	ecx, DWORD PTR [esi+268]
	sub	ecx, DWORD PTR [esi+260]
	mov	eax, DWORD PTR [esi+772]
	mov	DWORD PTR tv1153[ebp], ecx
	fild	DWORD PTR tv1153[ebp]
	fmul	QWORD PTR [esi+240]
	fadd	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+16]
	mov	edx, DWORD PTR [esi+264]
	sub	edx, DWORD PTR [esi+256]
	mov	eax, DWORD PTR [esi+1192]
	mov	DWORD PTR tv1151[ebp], edx
	fild	DWORD PTR tv1151[ebp]
	fmul	QWORD PTR [esi+232]
	fadd	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+16]
	mov	ecx, DWORD PTR [esi+268]
	sub	ecx, DWORD PTR [esi+260]
	mov	eax, DWORD PTR [esi+1196]
	mov	DWORD PTR tv1149[ebp], ecx
	fild	DWORD PTR tv1149[ebp]
	fmul	QWORD PTR [esi+240]
	fsubr	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+16]

; 1534 :         break;

	jmp	$LN53@mouse_loc_
$LN21@mouse_loc_:

; 1519 :           td->view[1][2] -= (td->newy-td->oldy)*td->yscale;
; 1520 :           td->to_focus[0][2] -= (td->newx-td->oldx)*td->xscale;
; 1521 :           td->to_focus[1][2] += (td->newy-td->oldy)*td->yscale;
; 1522 :           td->from_focus[0][2] += (td->newx-td->oldx)*td->xscale;
; 1523 :           td->from_focus[1][2] -= (td->newy-td->oldy)*td->yscale;
; 1524 :         } else
; 1525 :         {
; 1526 :           td->view[1][HOMDIM-1] += (td->newx-td->oldx)*td->xscale;

	mov	edx, DWORD PTR [esi+284]
	mov	ecx, DWORD PTR _HOMDIM
	mov	DWORD PTR tv1146[ebp], eax
	fild	DWORD PTR tv1146[ebp]
	lea	ecx, DWORD PTR [edx+ecx*8-8]

; 1527 :           td->view[2][HOMDIM-1] -= (td->newy-td->oldy)*td->yscale;
; 1528 :           td->to_focus[1][HOMDIM-1] -= (td->newx-td->oldx)*td->xscale;
; 1529 :           td->to_focus[2][HOMDIM-1] += (td->newy-td->oldy)*td->yscale;
; 1530 :           td->from_focus[1][HOMDIM-1] += (td->newx-td->oldx)*td->xscale;
; 1531 :           td->from_focus[2][HOMDIM-1] -= (td->newy-td->oldy)*td->yscale;
; 1532 :         };
; 1533 :         update_global_view_flag = 1;

	mov	ebx, 1
	fmul	QWORD PTR [esi+232]
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+268]
	sub	ecx, DWORD PTR [esi+260]
	mov	edx, DWORD PTR [esi+288]
	mov	eax, DWORD PTR _HOMDIM
	mov	DWORD PTR tv1144[ebp], ecx
	fild	DWORD PTR tv1144[ebp]
	lea	eax, DWORD PTR [edx+eax*8-8]
	fmul	QWORD PTR [esi+240]
	fsubr	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR [esi+264]
	sub	ecx, DWORD PTR [esi+256]
	mov	edx, DWORD PTR [esi+772]
	mov	eax, DWORD PTR _HOMDIM
	mov	DWORD PTR tv1141[ebp], ecx
	fild	DWORD PTR tv1141[ebp]
	lea	eax, DWORD PTR [edx+eax*8-8]
	fmul	QWORD PTR [esi+232]
	fsubr	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR [esi+268]
	sub	ecx, DWORD PTR [esi+260]
	mov	edx, DWORD PTR [esi+776]
	mov	eax, DWORD PTR _HOMDIM
	mov	DWORD PTR tv1138[ebp], ecx
	fild	DWORD PTR tv1138[ebp]
	lea	eax, DWORD PTR [edx+eax*8-8]
	fmul	QWORD PTR [esi+240]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR [esi+264]
	sub	ecx, DWORD PTR [esi+256]
	mov	edx, DWORD PTR [esi+1196]
	mov	eax, DWORD PTR _HOMDIM
	mov	DWORD PTR tv1136[ebp], ecx
	fild	DWORD PTR tv1136[ebp]
	lea	eax, DWORD PTR [edx+eax*8-8]
	fmul	QWORD PTR [esi+232]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR [esi+268]
	sub	ecx, DWORD PTR [esi+260]
	mov	edx, DWORD PTR [esi+1200]
	mov	eax, DWORD PTR _HOMDIM
	mov	DWORD PTR tv1134[ebp], ecx
	fild	DWORD PTR tv1134[ebp]
	lea	eax, DWORD PTR [edx+eax*8-8]
	fmul	QWORD PTR [esi+240]
	fsubr	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 1534 :         break;

	jmp	$LN53@mouse_loc_
$LN19@mouse_loc_:

; 1535 : 
; 1536 :       case MM_SPIN: /* about z axis */
; 1537 :         { MAT2D(rot,MAXCOORD+1,MAXCOORD+1);

	push	7
	push	7
	lea	edx, DWORD PTR _rotxJ$95103[ebp]
	push	edx
	lea	eax, DWORD PTR _rotqXvS$95102[ebp]
	push	eax
	call	_mat2d_setup
	mov	ebx, eax

; 1538 :           REAL dth;
; 1539 :           REAL dang; /* fourth dimension */
; 1540 :           for ( i = 0 ; i < HOMDIM ; i++ )

	mov	eax, DWORD PTR _HOMDIM
	add	esp, 16					; 00000010H
	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN16@mouse_loc_
	fld1
	fldz
	jmp	SHORT $LN18@mouse_loc_
$LN70@mouse_loc_:
	fxch	ST(1)
$LN18@mouse_loc_:

; 1541 :           { for ( j = 0 ; j < HOMDIM ; j++ )

	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN13@mouse_loc_

; 1538 :           REAL dth;
; 1539 :           REAL dang; /* fourth dimension */
; 1540 :           for ( i = 0 ; i < HOMDIM ; i++ )

	mov	eax, DWORD PTR [ebx+edx*4]
$LN15@mouse_loc_:

; 1542 :               rot[i][j] = 0.0;

	fst	QWORD PTR [eax]
	inc	ecx
	add	eax, 8
	cmp	ecx, DWORD PTR _HOMDIM
	jl	SHORT $LN15@mouse_loc_
$LN13@mouse_loc_:

; 1543 :             rot[i][i] = 1.0;

	mov	ecx, DWORD PTR [ebx+edx*4]
	fxch	ST(1)
	fst	QWORD PTR [ecx+edx*8]
	mov	eax, DWORD PTR _HOMDIM
	inc	edx
	cmp	edx, eax
	jl	SHORT $LN70@mouse_loc_

; 1538 :           REAL dth;
; 1539 :           REAL dang; /* fourth dimension */
; 1540 :           for ( i = 0 ; i < HOMDIM ; i++ )

	fstp	ST(1)
	fstp	ST(0)
$LN16@mouse_loc_:

; 1544 :           }
; 1545 :           dth = (td->newx - td->oldx)/300.0*M_PI;

	mov	edx, DWORD PTR [esi+264]
	sub	edx, DWORD PTR [esi+256]
	mov	DWORD PTR tv1126[ebp], edx
	fild	DWORD PTR tv1126[ebp]
	fdiv	QWORD PTR __real@4072c00000000000
	fmul	QWORD PTR __real@400921fb54442d18
	fst	QWORD PTR _dth$95106[ebp]

; 1546 :           dang = (td->newy - td->oldy)/300.0*M_PI;
; 1547 :           if ( SDIM == 2 )
; 1548 :           { rot[0][0] = rot[1][1] = cos(dth);

	call	__CIcos
	cmp	DWORD PTR _web+616, 2
	jne	SHORT $LN12@mouse_loc_
	mov	edi, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx]
	fst	QWORD PTR [edi+8]
	fstp	QWORD PTR [eax]

; 1549 :             rot[0][1] = -(rot[1][0] = sin(dth));

	fld	QWORD PTR _dth$95106[ebp]
	call	__CIsin
	fst	QWORD PTR [edi]
	mov	eax, DWORD PTR [ebx]
	fchs
	fstp	QWORD PTR [eax+8]

; 1550 :           } else

	jmp	SHORT $LN11@mouse_loc_
$LN12@mouse_loc_:

; 1551 :           { rot[1][1] = rot[2][2] = cos(dth);

	mov	edi, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+4]
	fst	QWORD PTR [edi+16]
	fstp	QWORD PTR [eax+8]

; 1552 :             rot[1][2] = -(rot[2][1] = sin(dth));

	fld	QWORD PTR _dth$95106[ebp]
	call	__CIsin
	fst	QWORD PTR [edi+8]
	mov	eax, DWORD PTR [ebx+4]
	fchs
	fstp	QWORD PTR [eax+16]
$LN11@mouse_loc_:

; 1553 :           } 
; 1554 :           mat_mult(td->to_focus,td->view,td->view,HOMDIM,HOMDIM,HOMDIM);

	mov	eax, DWORD PTR _HOMDIM
	push	eax
	push	eax
	push	eax
	lea	edi, DWORD PTR [esi+280]
	push	edi
	lea	eax, DWORD PTR [esi+768]
	push	edi
	push	eax
	call	_mat_mult

; 1555 :           mat_mult(rot,td->view,td->view,HOMDIM,HOMDIM,HOMDIM);

	mov	eax, DWORD PTR _HOMDIM
	push	eax
	push	eax
	push	eax
	push	edi
	push	edi
	push	ebx
	call	_mat_mult

; 1556 :           mat_mult(td->from_focus,td->view,td->view,HOMDIM,HOMDIM,HOMDIM);

	mov	eax, DWORD PTR _HOMDIM
	push	eax
	push	eax
	push	eax
	push	edi
	lea	ecx, DWORD PTR [esi+1192]
	push	edi
	push	ecx
	call	_mat_mult
	add	esp, 72					; 00000048H

; 1557 :           update_global_view_flag = 1;

	mov	ebx, 1

; 1558 :         }
; 1559 :         break;

	jmp	$LN53@mouse_loc_
$LN10@mouse_loc_:

; 1560 : 
; 1561 :       case MM_SLICE_SPIN:
; 1562 :         {
; 1563 :           REAL dth;
; 1564 :           REAL dang; 
; 1565 :           REAL temp1[3];
; 1566 :           REAL temp2[3];
; 1567 :           REAL cfudge; 
; 1568 : 
; 1569 :           dang = (td->newx - td->oldx)/300.0*M_PI;

	sub	eax, DWORD PTR [esi+256]

; 1570 :           dth = (td->newy - td->oldy)/300.0*M_PI;

	sub	ecx, DWORD PTR [esi+260]
	mov	DWORD PTR tv1094[ebp], eax
	fild	DWORD PTR tv1094[ebp]
	mov	DWORD PTR tv1092[ebp], ecx
	fld	QWORD PTR __real@4072c00000000000

; 1571 : 
; 1572 :           cfudge = SDIM_dot(td->focus_coord,clip_coeff[0]);

	mov	edx, DWORD PTR _web+616
	push	edx
	fdiv	ST(1), ST(0)
	lea	edi, DWORD PTR [esi+712]
	push	OFFSET _clip_coeff
	push	edi
	fld	QWORD PTR __real@400921fb54442d18
	fmul	ST(2), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR _dang$95118[ebp]
	fild	DWORD PTR tv1092[ebp]
	fdivrp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR _dth$95117[ebp]
	call	_dot

; 1573 :           matvec_mul(td->from_focus,clip_coeff[0],temp1,3,3);

	push	3
	fstp	QWORD PTR _cfudge$95121[ebp]
	push	3
	lea	eax, DWORD PTR _temp1$95119[ebp]
	push	eax
	lea	ecx, DWORD PTR [esi+1192]
	push	OFFSET _clip_coeff
	push	ecx
	call	_matvec_mul

; 1574 :           temp2[0] = cos(dth)*temp1[0] - sin(dth)*temp1[2];

	fld	QWORD PTR _dth$95117[ebp]
	add	esp, 32					; 00000020H
	call	__CIcos
	fstp	QWORD PTR tv868[ebp]
	fld	QWORD PTR _dth$95117[ebp]
	call	__CIsin
	fld	QWORD PTR tv868[ebp]
	fld	ST(0)
	fld	QWORD PTR _temp1$95119[ebp]
	fmul	ST(1), ST(0)
	fld	ST(3)
	fld	QWORD PTR _temp1$95119[ebp+16]
	fmul	ST(1), ST(0)
	fxch	ST(3)
	fsubrp	ST(1), ST(0)
	fstp	QWORD PTR _temp2$95120[ebp]

; 1575 :           temp2[1] = temp1[1];
; 1576 :           temp2[2] = sin(dth)*temp1[0] + cos(dth)*temp1[2];

	fmulp	ST(3), ST(0)
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)

; 1577 :           temp1[2] = temp2[2];

	fstp	QWORD PTR _temp1$95119[ebp+16]

; 1578 :           temp1[0] = cos(dang)*temp2[0] - sin(dang)*temp2[1];

	fld	QWORD PTR _dang$95118[ebp]
	call	__CIcos
	fstp	QWORD PTR tv876[ebp]
	fld	QWORD PTR _dang$95118[ebp]
	call	__CIsin
	fld	QWORD PTR tv876[ebp]
	fld	ST(0)

; 1579 :           temp1[1] = sin(dang)*temp2[0] + cos(dang)*temp2[1];
; 1580 :           matvec_mul(td->to_focus,temp1,clip_coeff[0],3,3);

	push	3
	fld	QWORD PTR _temp2$95120[ebp]
	push	3
	fmul	ST(1), ST(0)
	push	OFFSET _clip_coeff
	fld	ST(3)
	lea	edx, DWORD PTR _temp1$95119[ebp]
	fld	QWORD PTR _temp1$95119[ebp+8]
	push	edx
	fmul	ST(1), ST(0)
	lea	eax, DWORD PTR [esi+768]
	fxch	ST(3)
	push	eax
	fsubrp	ST(1), ST(0)
	fstp	QWORD PTR _temp1$95119[ebp]
	fmulp	ST(3), ST(0)
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _temp1$95119[ebp+8]
	call	_matvec_mul

; 1581 :           cfudge -= SDIM_dot(td->focus_coord,clip_coeff[0]);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	push	OFFSET _clip_coeff
	push	edi
	call	_dot
	fsubr	QWORD PTR _cfudge$95121[ebp]
	add	esp, 32					; 00000020H

; 1582 :           clip_coeff[0][3] -= cfudge;

	fsubr	QWORD PTR _clip_coeff+24
	fstp	QWORD PTR _clip_coeff+24
$LN75@mouse_loc_:

; 1583 :           clip_coeff_set_flag = 1;

	mov	eax, 1
	mov	DWORD PTR _clip_coeff_set_flag, eax
$LN74@mouse_loc_:

; 1584 :           td->newarraysflag = 1;

	mov	DWORD PTR [esi+128], eax
$LN53@mouse_loc_:

; 1585 :           break;
; 1586 :         }
; 1587 :       }
; 1588 :       if ( td->idle_flag )

	cmp	DWORD PTR [esi+1736], 0
	je	SHORT $LN9@mouse_loc_

; 1589 :          glutPostRedisplay();

	call	_glutPostRedisplay@0
$LN9@mouse_loc_:

; 1590 : 
; 1591 :       if ( update_global_view_flag )

	test	ebx, ebx
	je	SHORT $LN57@mouse_loc_

; 1592 :       { if ( td->win_id == 1 )

	cmp	DWORD PTR [esi+140], 1
	jne	SHORT $LN57@mouse_loc_

; 1593 :         { 
; 1594 :           for ( i = 0 ; i < HOMDIM ; i++ )

	mov	edi, DWORD PTR _HOMDIM
	xor	ebx, ebx
	test	edi, edi
	jle	SHORT $LN57@mouse_loc_
	lea	edx, DWORD PTR [esi+280]
	mov	DWORD PTR tv1230[ebp], edx
$LL56@mouse_loc_:

; 1595 :            for ( j = 0 ; j < HOMDIM ; j++ )

	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN5@mouse_loc_
	mov	eax, DWORD PTR _view
	mov	edx, DWORD PTR tv1230[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	edx, DWORD PTR [edx]
	sub	edx, eax
	npad	4
$LL3@mouse_loc_:

; 1596 :             view[i][j] = td->view[i][j];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	mov	edi, DWORD PTR _HOMDIM
	add	eax, 8
	cmp	ecx, edi
	jl	SHORT $LL3@mouse_loc_
$LN5@mouse_loc_:

; 1593 :         { 
; 1594 :           for ( i = 0 ; i < HOMDIM ; i++ )

	add	DWORD PTR tv1230[ebp], 4
	inc	ebx
	cmp	ebx, edi
	jl	SHORT $LL56@mouse_loc_
$LN57@mouse_loc_:
	pop	edi
$LN4@mouse_loc_:

; 1597 :         }
; 1598 :       }
; 1599 :     }
; 1600 : 
; 1601 :   td->oldx = td->newx; td->oldy = td->newy;

	mov	ecx, DWORD PTR [esi+268]
	mov	eax, DWORD PTR [esi+264]
	mov	DWORD PTR [esi+260], ecx

; 1602 : 
; 1603 : } // end mouse_loc_func()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	DWORD PTR [esi+256], eax
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN76@mouse_loc_:
	DD	$LN54@mouse_loc_
	DD	$LN22@mouse_loc_
	DD	$LN29@mouse_loc_
	DD	$LN19@mouse_loc_
	DD	$LN35@mouse_loc_
	DD	$LN10@mouse_loc_
_mouse_loc_func ENDP
_TEXT	ENDS
PUBLIC	__real@400921f9f01b866e
PUBLIC	__real@4066800000000000
PUBLIC	__real@4099000000000000
PUBLIC	__real@c034000000000000
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@bff8000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__real@4006666666666666
PUBLIC	_reshape_func
EXTRN	__imp__glMultMatrixd@4:PROC
EXTRN	_gluPerspective@32:PROC
EXTRN	_maxclipy:QWORD
EXTRN	_minclipy:QWORD
EXTRN	_maxclipx:QWORD
EXTRN	_minclipx:QWORD
EXTRN	__imp__glViewport@16:PROC
EXTRN	_glutReshapeWindow@8:PROC
EXTRN	_window_aspect_ratio:QWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@400921f9f01b866e
CONST	SEGMENT
__real@400921f9f01b866e DQ 0400921f9f01b866er	; 3.14159
CONST	ENDS
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
CONST	ENDS
;	COMDAT __real@4099000000000000
CONST	SEGMENT
__real@4099000000000000 DQ 04099000000000000r	; 1600
CONST	ENDS
;	COMDAT __real@c034000000000000
CONST	SEGMENT
__real@c034000000000000 DQ 0c034000000000000r	; -20
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@bff8000000000000
CONST	SEGMENT
__real@bff8000000000000 DQ 0bff8000000000000r	; -1.5
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4006666666666666
CONST	SEGMENT
__real@4006666666666666 DQ 04006666666666666r	; 2.8
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _reshape_func
_TEXT	SEGMENT
tv338 = -16						; size = 8
tv334 = -8						; size = 8
_x$ = 8							; size = 4
tv349 = 12						; size = 4
_y$ = 12						; size = 4
_reshape_func PROC					; COMDAT

; 1613 : { struct graph_thread_data *td = GET_DATA;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	call	_glutGetWindow@0

; 1614 : 
; 1615 :   if ( window_aspect_ratio != 0.0 )

	fld	QWORD PTR _window_aspect_ratio

; 1616 :   { /* munge x,y */
; 1617 :     
; 1618 :     /* see if moving just one side of frame */
; 1619 :     if ( abs(td->xsize - x) < abs(td->ysize - y) )

	mov	ebx, DWORD PTR _x$[ebp]
	fld	ST(0)
	fldz
	mov	edi, DWORD PTR _y$[ebp]
	mov	esi, eax
	fucompp
	imul	esi, 9896				; 000026a8H
	fnstsw	ax
	add	esi, OFFSET _gthread_data
	test	ah, 68					; 00000044H
	jnp	SHORT $LN24@reshape_fu
	mov	eax, DWORD PTR [esi+248]
	sub	eax, ebx
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+252]
	xor	ecx, edx
	sub	eax, edi
	sub	ecx, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	ecx, eax
	jge	SHORT $LN18@reshape_fu

; 1620 :     { /* moving y */
; 1621 :       /* if ( td->ysize == y ) return; */ /* not changing */
; 1622 :       x = (int)(y/fabs(window_aspect_ratio));

	fild	DWORD PTR _y$[ebp]
	fld	ST(1)
	fabs
	fdivp	ST(1), ST(0)
	call	__ftol2_sse
	mov	ebx, eax
	mov	DWORD PTR _x$[ebp], ebx

; 1623 :     }
; 1624 :     else 

	jmp	SHORT $LN17@reshape_fu
$LN18@reshape_fu:

; 1625 :     { /* moving x */
; 1626 :       y = (int)(x*fabs(window_aspect_ratio));

	fld	ST(0)
	fabs
	fimul	DWORD PTR _x$[ebp]
	call	__ftol2_sse
	mov	edi, eax
	mov	DWORD PTR _y$[ebp], edi
$LN17@reshape_fu:

; 1627 :     }
; 1628 :     td->window_aspect = window_aspect_ratio;
; 1629 :     td->aspect_flag = 0;
; 1630 :     glutReshapeWindow(x,y);

	push	edi
	fstp	QWORD PTR [esi+224]
	push	ebx
	mov	DWORD PTR [esi+1744], 0
	call	_glutReshapeWindow@8
	jmp	SHORT $LN19@reshape_fu
$LN24@reshape_fu:

; 1614 : 
; 1615 :   if ( window_aspect_ratio != 0.0 )

	fstp	ST(0)
$LN19@reshape_fu:

; 1631 :   }
; 1632 :   
; 1633 :   td->xsize = x; td->ysize = y;
; 1634 :   td->aspect = (double)y/x;

	fild	DWORD PTR _y$[ebp]

; 1635 :   glViewport(0,0,x,y);

	push	edi
	push	ebx
	push	0
	fst	QWORD PTR tv334[ebp]
	push	0
	fild	DWORD PTR _x$[ebp]
	mov	DWORD PTR [esi+248], ebx
	mov	DWORD PTR [esi+252], edi
	fst	QWORD PTR tv338[ebp]
	fdivp	ST(1), ST(0)
	fstp	QWORD PTR [esi+216]
	call	DWORD PTR __imp__glViewport@16

; 1636 :   if ( td->aspect > 1 ) 

	fld1
	fcomp	QWORD PTR [esi+216]
	fnstsw	ax

; 1637 :   { td->xscale = 2.8/td->aspect/x; td->yscale = 2.8/y; 

	fld	QWORD PTR __real@4006666666666666
	fld	ST(0)
	test	ah, 5
	jp	SHORT $LN16@reshape_fu
	fdiv	QWORD PTR [esi+216]
	fld	QWORD PTR tv338[ebp]
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [esi+232]
	fld	QWORD PTR tv334[ebp]
	fdiv	ST(2), ST(0)
	fxch	ST(2)
	fst	QWORD PTR [esi+240]

; 1638 :     imagescale = td->yscale*100;
; 1639 :   }
; 1640 :   else 

	jmp	SHORT $LN37@reshape_fu
$LN16@reshape_fu:

; 1641 :   { td->xscale = 2.8/x; td->yscale = 2.8*td->aspect/y; 

	fld	QWORD PTR tv338[ebp]
	fdiv	ST(1), ST(0)
	fxch	ST(1)
	fst	QWORD PTR [esi+232]
	fld	QWORD PTR [esi+216]
	fmulp	ST(3), ST(0)
	fld	QWORD PTR tv334[ebp]
	fdiv	ST(3), ST(0)
	fxch	ST(3)
	fstp	QWORD PTR [esi+240]
$LN37@reshape_fu:

; 1642 :     imagescale = td->xscale*100;

	fmul	QWORD PTR __real@4059000000000000
	fstp	QWORD PTR _imagescale

; 1643 :   }
; 1644 :   if ( td == gthread_data+1 )

	cmp	esi, OFFSET _gthread_data+9896
	jne	SHORT $LN32@reshape_fu

; 1645 :   { /* first window corresponds to printing graphics state */
; 1646 :     if ( x < y ) 

	cmp	ebx, edi
	jge	SHORT $LN13@reshape_fu

; 1647 :     { minclipx = -1.5; maxclipx = 1.5;

	fld	QWORD PTR __real@bff8000000000000
	fst	QWORD PTR _minclipx
	fld	QWORD PTR __real@3ff8000000000000
	fst	QWORD PTR _maxclipx

; 1648 :       minclipy = -1.5*y/x; maxclipy = 1.5*y/x;

	fld	ST(3)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _minclipy
	fmulp	ST(2), ST(0)
	fdivp	ST(1), ST(0)
	fstp	QWORD PTR _maxclipy

; 1649 :     }
; 1650 :     else

	jmp	SHORT $LN12@reshape_fu
$LN13@reshape_fu:

; 1651 :     { minclipx = -1.5*x/y; maxclipx = 1.5*x/y;

	fld	ST(0)
	fld	QWORD PTR __real@bff8000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(3)
	fstp	QWORD PTR _minclipx
	fld	QWORD PTR __real@3ff8000000000000
	fmul	ST(2), ST(0)
	fxch	ST(2)
	fdivrp	ST(3), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR _maxclipx

; 1652 :       minclipy = -1.5; maxclipy = 1.5;

	fxch	ST(1)
	fstp	QWORD PTR _minclipy
	fstp	QWORD PTR _maxclipy
	jmp	SHORT $LN12@reshape_fu
$LN32@reshape_fu:
	fstp	ST(1)
	fstp	ST(0)
$LN12@reshape_fu:

; 1653 :     }
; 1654 :   } 
; 1655 :   glMatrixMode(GL_PROJECTION);

	push	5889					; 00001701H
	call	DWORD PTR __imp__glMatrixMode@4

; 1656 :   glLoadIdentity();

	call	DWORD PTR __imp__glLoadIdentity@0

; 1657 :   
; 1658 :   if ( (td->projmode == P_PERSP) || td->stereomode )

	cmp	DWORD PTR [esi+1632], 1
	je	$LN10@reshape_fu
	cmp	DWORD PTR [esi+1700], 0
	jne	$LN10@reshape_fu

; 1663 :   }
; 1664 :   else
; 1665 :   {
; 1666 :     if ( td->aspect >= 1.0 )

	fld1

; 1667 :     { glOrtho(td->scrx[0],td->scrx[2],td->aspect*td->scry[0],
; 1668 :              td->aspect*td->scry[2],-20.0,20.0);

	sub	esp, 48					; 00000030H
	fcomp	QWORD PTR [esi+216]
	fnstsw	ax
	fld	QWORD PTR __real@4034000000000000
	fstp	QWORD PTR [esp+40]
	fld	QWORD PTR __real@c034000000000000
	fstp	QWORD PTR [esp+32]
	fld	QWORD PTR [esi+200]
	test	ah, 65					; 00000041H
	jp	SHORT $LN6@reshape_fu
	fmul	QWORD PTR [esi+216]
	fstp	QWORD PTR [esp+24]
	fld	QWORD PTR [esi+184]
	fmul	QWORD PTR [esi+216]
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR [esi+168]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [esi+152]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__glOrtho@48

; 1669 :       if ( td == gthread_data+1 )

	cmp	esi, OFFSET _gthread_data+9896
	jne	$LN3@reshape_fu

; 1670 :       { minclipx = td->scrx[0]; maxclipx = td->scrx[2]; 

	fld	QWORD PTR [esi+152]
	fstp	QWORD PTR _minclipx
	fld	QWORD PTR [esi+168]
	fstp	QWORD PTR _maxclipx

; 1671 :         minclipy = td->aspect*td->scry[2]; maxclipy = td->aspect*td->scry[0];

	fld	QWORD PTR [esi+200]
	fmul	QWORD PTR [esi+216]
	fstp	QWORD PTR _minclipy
	fld	QWORD PTR [esi+184]
	fmul	QWORD PTR [esi+216]

; 1672 :       }
; 1673 :     }
; 1674 :     else

	jmp	SHORT $LN38@reshape_fu
$LN6@reshape_fu:

; 1675 :     { glOrtho(td->scrx[0]/td->aspect,td->scrx[2]/td->aspect,td->scry[0],
; 1676 :           td->scry[2],-20.0,20.0);

	fstp	QWORD PTR [esp+24]
	fld	QWORD PTR [esi+184]
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR [esi+168]
	fdiv	QWORD PTR [esi+216]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [esi+152]
	fdiv	QWORD PTR [esi+216]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__glOrtho@48

; 1677 :       if ( td == gthread_data+1 )

	cmp	esi, OFFSET _gthread_data+9896
	jne	SHORT $LN3@reshape_fu

; 1678 :       { minclipx = td->scrx[0]/td->aspect; maxclipx = td->scrx[2]/td->aspect; 

	fld	QWORD PTR [esi+152]
	fdiv	QWORD PTR [esi+216]
	fstp	QWORD PTR _minclipx
	fld	QWORD PTR [esi+168]
	fdiv	QWORD PTR [esi+216]
	fstp	QWORD PTR _maxclipx

; 1679 :         minclipy = td->scry[2]; maxclipy = td->scry[0];

	fld	QWORD PTR [esi+200]
	fstp	QWORD PTR _minclipy
	fld	QWORD PTR [esi+184]
$LN38@reshape_fu:
	fstp	QWORD PTR _maxclipy
$LN3@reshape_fu:

; 1680 :       }
; 1681 :     }
; 1682 :  
; 1683 :     if ( SDIM == 2 ) glMultMatrixd(vt2[0]); /* upside down */

	cmp	DWORD PTR _web+616, 2
	jne	SHORT $LN2@reshape_fu
$LN40@reshape_fu:
	push	OFFSET _vt2
	jmp	SHORT $LN39@reshape_fu
$LN2@reshape_fu:

; 1684 :     else glMultMatrixd(vt3[0]);  /* upside down and rotate axes */

	push	OFFSET _vt3
	jmp	SHORT $LN39@reshape_fu
$LN10@reshape_fu:

; 1659 :   {     
; 1660 :      gluPerspective((float)(y/1600.*180/3.14159),1/td->aspect,1.0,20.0);

	fld	QWORD PTR __real@4034000000000000
	sub	esp, 32					; 00000020H
	fstp	QWORD PTR [esp+24]
	fld1
	fst	QWORD PTR [esp+16]
	fdiv	QWORD PTR [esi+216]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR tv334[ebp]
	fdiv	QWORD PTR __real@4099000000000000
	fmul	QWORD PTR __real@4066800000000000
	fdiv	QWORD PTR __real@400921f9f01b866e
	fstp	DWORD PTR tv349[ebp]
	fld	DWORD PTR tv349[ebp]
	fstp	QWORD PTR [esp]
	call	_gluPerspective@32

; 1661 :      if ( SDIM == 2 ) glMultMatrixd(vt2[0]); 

	cmp	DWORD PTR _web+616, 2
	je	SHORT $LN40@reshape_fu

; 1662 :      else glMultMatrixd(vt3p[0]);  /* rotate axes */

	push	OFFSET _vt3p
$LN39@reshape_fu:
	call	DWORD PTR __imp__glMultMatrixd@4

; 1685 :    }
; 1686 : 
; 1687 :   glGetFloatv(GL_PROJECTION_MATRIX,td->projmat); /* save */

	add	esi, 1636				; 00000664H
	push	esi
	push	2983					; 00000ba7H
	call	DWORD PTR __imp__glGetFloatv@8
	pop	edi
	pop	esi
	pop	ebx

; 1688 : 
; 1689 :   GL_ERROR_CHECK
; 1690 : 
; 1691 : #ifdef resizequick
; 1692 :   td->resize_flag = 1; /* So Mac OS X won't try too much redrawing */
; 1693 :   glutIdleFunc(idle_func);
; 1694 : #endif
; 1695 : 
; 1696 : } // end reshape_func()

	mov	esp, ebp
	pop	ebp
	ret	0
_reshape_func ENDP
_TEXT	ENDS
PUBLIC	__real@3fd0000000000000
PUBLIC	_specialkey_func
EXTRN	_breakflag:DWORD
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _specialkey_func
_TEXT	SEGMENT
_key$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_specialkey_func PROC					; COMDAT

; 1707 : { struct graph_thread_data *td = GET_DATA;

	push	ebp
	mov	ebp, esp
	call	_glutGetWindow@0
	imul	eax, 9896				; 000026a8H

; 1708 :   switch ( key )

	mov	ecx, DWORD PTR _key$[ebp]
	add	ecx, -3					; fffffffdH
	add	eax, OFFSET _gthread_data
	cmp	ecx, 100				; 00000064H
	ja	$LN9@specialkey
	movzx	ecx, BYTE PTR $LN13@specialkey[ecx]
	jmp	DWORD PTR $LN16@specialkey[ecx*4]
$LN8@specialkey:

; 1709 :   { 
; 1710 :     case GLUT_KEY_RIGHT: /* right arrow */
; 1711 :       td->view[SDIM>2?1:0][HOMDIM-1] += .25; break;

	mov	ecx, DWORD PTR _HOMDIM
	xor	edx, edx
	cmp	DWORD PTR _web+616, 2
	setg	dl
	mov	eax, DWORD PTR [eax+edx*4+280]
	fld	QWORD PTR [eax+ecx*8-8]
	lea	eax, DWORD PTR [eax+ecx*8-8]
	fadd	QWORD PTR __real@3fd0000000000000
	fstp	QWORD PTR [eax]

; 1738 : } // end specialkey_func()

	pop	ebp

; 1735 : #endif
; 1736 :   }
; 1737 :   glutPostRedisplay();  /* generate redraw message */

	jmp	_glutPostRedisplay@0
$LN7@specialkey:

; 1712 :     case GLUT_KEY_LEFT:  /* left arrow */ 
; 1713 :       td->view[SDIM>2?1:0][HOMDIM-1] -= .25; break;

	mov	ecx, DWORD PTR _HOMDIM
	xor	edx, edx
	cmp	DWORD PTR _web+616, 2
	setg	dl
	mov	eax, DWORD PTR [eax+edx*4+280]
	fld	QWORD PTR [eax+ecx*8-8]
	lea	eax, DWORD PTR [eax+ecx*8-8]
	fsub	QWORD PTR __real@3fd0000000000000
	fstp	QWORD PTR [eax]

; 1738 : } // end specialkey_func()

	pop	ebp

; 1735 : #endif
; 1736 :   }
; 1737 :   glutPostRedisplay();  /* generate redraw message */

	jmp	_glutPostRedisplay@0
$LN6@specialkey:

; 1714 :     case GLUT_KEY_UP:    /* up arrow */  
; 1715 :       td->view[SDIM>2?2:1][HOMDIM-1] += .25; break;

	mov	ecx, DWORD PTR _HOMDIM
	xor	edx, edx
	cmp	DWORD PTR _web+616, 2
	setg	dl
	mov	eax, DWORD PTR [eax+edx*4+284]
	fld	QWORD PTR [eax+ecx*8-8]
	lea	eax, DWORD PTR [eax+ecx*8-8]
	fadd	QWORD PTR __real@3fd0000000000000
	fstp	QWORD PTR [eax]

; 1738 : } // end specialkey_func()

	pop	ebp

; 1735 : #endif
; 1736 :   }
; 1737 :   glutPostRedisplay();  /* generate redraw message */

	jmp	_glutPostRedisplay@0
$LN5@specialkey:

; 1716 :     case GLUT_KEY_DOWN:  /* down arrow */
; 1717 :       td->view[SDIM>2?2:1][HOMDIM-1] -= .25; break;

	mov	ecx, DWORD PTR _HOMDIM
	xor	edx, edx
	cmp	DWORD PTR _web+616, 2
	setg	dl
	mov	eax, DWORD PTR [eax+edx*4+284]
	fld	QWORD PTR [eax+ecx*8-8]
	lea	eax, DWORD PTR [eax+ecx*8-8]
	fsub	QWORD PTR __real@3fd0000000000000
	fstp	QWORD PTR [eax]

; 1738 : } // end specialkey_func()

	pop	ebp

; 1735 : #endif
; 1736 :   }
; 1737 :   glutPostRedisplay();  /* generate redraw message */

	jmp	_glutPostRedisplay@0
$LN4@specialkey:

; 1718 : #ifdef __L_EVOLVER__
; 1719 :     case GLUT_KEY_F3:  //Added by PSU.
; 1720 :       l_OpenGL_key |= LEVOLVER_PAUSE_OPENGL_KEYPRESS; 

	or	DWORD PTR _l_OpenGL_key, 1

; 1738 : } // end specialkey_func()

	pop	ebp

; 1735 : #endif
; 1736 :   }
; 1737 :   glutPostRedisplay();  /* generate redraw message */

	jmp	_glutPostRedisplay@0
$LN3@specialkey:

; 1721 : 	  //fputs("f3 ",l_outfd);
; 1722 : 	  //fflush(l_outfd);
; 1723 : 	  //outstring("f3 ");
; 1724 : 	  break;
; 1725 :     case GLUT_KEY_F5:  //Added by PSU.
; 1726 :       breakflag = BREAKABORT; break;

	mov	DWORD PTR _breakflag, 5

; 1738 : } // end specialkey_func()

	pop	ebp

; 1735 : #endif
; 1736 :   }
; 1737 :   glutPostRedisplay();  /* generate redraw message */

	jmp	_glutPostRedisplay@0
$LN2@specialkey:

; 1727 :     case GLUT_KEY_F7:  //Added by PSU.
; 1728 :       l_OpenGL_key |= LEVOLVER_BREAK_OPENGL_KEYPRESS; 

	or	DWORD PTR _l_OpenGL_key, 2

; 1738 : } // end specialkey_func()

	pop	ebp

; 1735 : #endif
; 1736 :   }
; 1737 :   glutPostRedisplay();  /* generate redraw message */

	jmp	_glutPostRedisplay@0
$LN1@specialkey:

; 1729 : 	  //fputs("f7 ",l_outfd);
; 1730 : 	  //fflush(l_outfd);
; 1731 : 	  //outstring("f7 ");
; 1732 : 	  break;
; 1733 :     case GLUT_KEY_F12:  //Added by PSU.
; 1734 :       TakeScreenshot(TRUE); break;

	push	1
	call	_TakeScreenshot
	add	esp, 4
$LN9@specialkey:

; 1738 : } // end specialkey_func()

	pop	ebp

; 1735 : #endif
; 1736 :   }
; 1737 :   glutPostRedisplay();  /* generate redraw message */

	jmp	_glutPostRedisplay@0
	npad	2
$LN16@specialkey:

; 1738 : } // end specialkey_func()

	DD	$LN4@specialkey
	DD	$LN3@specialkey
	DD	$LN2@specialkey
	DD	$LN1@specialkey
	DD	$LN7@specialkey
	DD	$LN6@specialkey
	DD	$LN8@specialkey
	DD	$LN5@specialkey
	DD	$LN9@specialkey
$LN13@specialkey:
	DB	0
	DB	8
	DB	1
	DB	8
	DB	2
	DB	8
	DB	8
	DB	8
	DB	8
	DB	3
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	4
	DB	5
	DB	6
	DB	7
_specialkey_func ENDP
_TEXT	ENDS
PUBLIC	_handle_func@8
; Function compile flags: /Ogtp
;	COMDAT _handle_func@8
_TEXT	SEGMENT
_hwnd$ = 8						; size = 4
_lParam$ = 12						; size = 4
_handle_func@8 PROC					; COMDAT

; 2263 : { int i;

	push	ebp
	mov	ebp, esp
	push	esi

; 2264 :   for ( i = 1 ; i < MAXGRAPHWINDOWS ; i++ )

	mov	esi, DWORD PTR _hwnd$[ebp]
	mov	edx, 1
	mov	eax, OFFSET _gthread_data+10040
$LL5@handle_fun:

; 2265 :   { if ( gthread_data[i].draw_hwnd == hwnd ) return TRUE;

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, esi
	je	SHORT $LN3@handle_fun

; 2266 :     if ( !gthread_data[i].draw_hwnd )

	test	ecx, ecx
	je	SHORT $LN10@handle_fun

; 2264 :   for ( i = 1 ; i < MAXGRAPHWINDOWS ; i++ )

	add	eax, 9896				; 000026a8H
	inc	edx
	cmp	eax, OFFSET _gthread_data+99104
	jl	SHORT $LL5@handle_fun

; 2268 :       break;
; 2269 :     }    
; 2270 :   }
; 2271 :   return TRUE;

	mov	eax, 1
	pop	esi

; 2272 : }

	pop	ebp
	ret	8
$LN10@handle_fun:

; 2267 :     { gthread_data[i].draw_hwnd = hwnd;

	imul	edx, 9896				; 000026a8H
	mov	DWORD PTR _gthread_data[edx+144], esi
$LN3@handle_fun:

; 2268 :       break;
; 2269 :     }    
; 2270 :   }
; 2271 :   return TRUE;

	mov	eax, 1
	pop	esi

; 2272 : }

	pop	ebp
	ret	8
_handle_func@8 ENDP
_TEXT	ENDS
PUBLIC	_Oglz_edge
EXTRN	__imp__glEnd@0:PROC
EXTRN	__imp__glBegin@4:PROC
EXTRN	_rgb_colors_flag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _Oglz_edge
_TEXT	SEGMENT
_g$ = 8							; size = 4
_e_id$ = 12						; size = 4
_Oglz_edge PROC						; COMDAT

; 2694 : { struct graph_thread_data *td = GET_DATA;

	push	ebp
	mov	ebp, esp
	push	esi
	call	_glutGetWindow@0
	mov	esi, eax
	imul	esi, 9896				; 000026a8H
	add	esi, OFFSET _gthread_data

; 2695 :   int k;
; 2696 :   int e_color;
; 2697 : 
; 2698 :   if ( my_own_pick_flag )

	cmp	DWORD PTR _my_own_pick_flag, 0
	je	SHORT $LN15@Oglz_edge

; 2699 :   { my_own_edge_pick(g,g+1,e_id);

	mov	eax, DWORD PTR _e_id$[ebp]
	push	eax
	mov	eax, DWORD PTR _g$[ebp]
	lea	ecx, DWORD PTR [eax+144]
	push	ecx
	push	eax
	call	_my_own_edge_pick
	add	esp, 12					; 0000000cH
	pop	esi

; 2730 :     }
; 2731 :   }
; 2732 : 
; 2733 : } // end Oglz_edge()

	pop	ebp
	ret	0
$LN15@Oglz_edge:
	push	ebx
	push	edi

; 2700 :     return;
; 2701 :   }
; 2702 : 
; 2703 :   e_color = g[0].ecolor;

	mov	edi, DWORD PTR _g$[ebp]
	mov	ebx, DWORD PTR [edi+120]

; 2704 :   if ( e_color == CLEAR ) return;

	cmp	ebx, -1
	je	$LN23@Oglz_edge

; 2705 :   if ( !rgb_colors_flag )

	cmp	DWORD PTR _rgb_colors_flag, 0
	jne	SHORT $LN12@Oglz_edge

; 2706 :   {
; 2707 :     if ( (e_color < 0) || (e_color >= IRIS_COLOR_MAX) )

	test	ebx, ebx
	js	SHORT $LN11@Oglz_edge
	cmp	ebx, 16					; 00000010H
	jl	SHORT $LN12@Oglz_edge
$LN11@Oglz_edge:

; 2708 :       e_color = DEFAULT_EDGE_COLOR;

	xor	ebx, ebx
$LN12@Oglz_edge:

; 2709 :   }
; 2710 : 
; 2711 :   if ( pick_flag )

	cmp	DWORD PTR _pick_flag, 0
	je	SHORT $LN10@Oglz_edge

; 2712 :     my_glLoadName(e_id); /* for picking */

	mov	edx, DWORD PTR _e_id$[ebp]
	push	edx
	call	_my_glLoadName
	add	esp, 4
$LN10@Oglz_edge:

; 2713 : 
; 2714 :   /* display */ 
; 2715 :   e_glColor(td,e_color);

	push	ebx
	push	esi
	call	_e_glColor
	add	esp, 8

; 2716 :   if ( !td->arraysflag )

	cmp	DWORD PTR [esi+9772], 0
	jne	SHORT $LN22@Oglz_edge

; 2717 :         glBegin(GL_LINES);

	push	1
	call	DWORD PTR __imp__glBegin@4
$LN22@Oglz_edge:

; 2718 :   for ( k = 0 ; k < 2 ; k++ )

	mov	ebx, 2
$LL8@Oglz_edge:

; 2719 :      e_glVertex3dv(td,g[k].x);

	push	edi
	push	esi
	call	_e_glVertex3dv
	add	esp, 8
	add	edi, 144				; 00000090H
	dec	ebx
	jne	SHORT $LL8@Oglz_edge

; 2720 :   if ( !td->arraysflag )

	cmp	DWORD PTR [esi+9772], ebx
	jne	SHORT $LN5@Oglz_edge

; 2721 :         glEnd();

	call	DWORD PTR __imp__glEnd@0
$LN5@Oglz_edge:

; 2722 : 
; 2723 :   /* pickable vertices */
; 2724 :   if ( pick_flag )

	cmp	DWORD PTR _pick_flag, 0
	je	SHORT $LN23@Oglz_edge

; 2725 :   { for ( k = 0 ; k < 2 ; k++ )

	mov	esi, DWORD PTR _g$[ebp]
	mov	ebx, DWORD PTR __imp__glVertex3d@24
	add	esi, 16					; 00000010H
	mov	edi, 2
	npad	1
$LL3@Oglz_edge:

; 2726 :     { my_glLoadName(g[k].v_id); /* for picking */

	mov	eax, DWORD PTR [esi+116]
	push	eax
	call	_my_glLoadName
	add	esp, 4

; 2727 :       glBegin(GL_POINTS);

	push	0
	call	DWORD PTR __imp__glBegin@4

; 2728 :         glVertex3d((GLdouble)g[k].x[0],(GLdouble)g[k].x[1],(GLdouble)g[k].x[2]);

	fld	QWORD PTR [esi]
	sub	esp, 24					; 00000018H
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR [esi-8]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [esi-16]
	fstp	QWORD PTR [esp]
	call	ebx

; 2729 :       glEnd();

	call	DWORD PTR __imp__glEnd@0
	add	esi, 144				; 00000090H
	dec	edi
	jne	SHORT $LL3@Oglz_edge
$LN23@Oglz_edge:
	pop	edi
	pop	ebx
	pop	esi

; 2730 :     }
; 2731 :   }
; 2732 : 
; 2733 : } // end Oglz_edge()

	pop	ebp
	ret	0
_Oglz_edge ENDP
_TEXT	ENDS
PUBLIC	_g$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_Oglz_facet
EXTRN	_edgeshow_flag:DWORD
EXTRN	_thickness:QWORD
EXTRN	_INDEX_TO_RGBA:PROC
EXTRN	_color_flag:DWORD
EXTRN	_dotf:PROC
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogtp
;	COMDAT _Oglz_facet
_TEXT	SEGMENT
tv1021 = -92						; size = 4
_g$GSCopy$ = -88					; size = 4
_kk$95651 = -84						; size = 4
_k$ = -84						; size = 4
tv1656 = -80						; size = 4
tv341 = -80						; size = 4
_fe$ = -80						; size = 4
_x$95633 = -76						; size = 48
_backnorm$ = -28					; size = 12
_norm$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_g$ = 8							; size = 4
_f_id$ = 12						; size = 4
_Oglz_facet PROC					; COMDAT

; 2747 : {  

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _g$[ebp]

; 2823 :   for ( k = 0 ; k < 3 ; k++, fe = valid_id(fe)?get_next_edge(fe):NULLID )

	mov	DWORD PTR _g$GSCopy$[ebp], edi
	call	_glutGetWindow@0
	mov	ebx, eax
	imul	ebx, 9896				; 000026a8H
	add	ebx, OFFSET _gthread_data
	cmp	DWORD PTR _web+616, 2
	jne	SHORT $LN51@Oglz_facet

; 2748 :   int i,k;
; 2749 :   REAL len;
; 2750 :   facetedge_id fe;
; 2751 :   struct graph_thread_data *td = GET_DATA;
; 2752 :   float norm[3];
; 2753 :   float backnorm[3];
; 2754 : 
; 2755 :   /* need normal for lighting */
; 2756 :   if ( web.sdim == 2 )
; 2757 :   { norm[0] = norm[1] = 0.0;

	fldz
	fst	DWORD PTR _norm$[ebp+4]
	fstp	DWORD PTR _norm$[ebp]

; 2758 :     norm[2] = 1.0;

	fld1

; 2759 :   }
; 2760 :   else

	jmp	$LN116@Oglz_facet
$LN51@Oglz_facet:

; 2761 :   {
; 2762 :     for ( i = 0 ; i < 3 ; i++ )
; 2763 :     { int ii = (i+1)%3;
; 2764 :       int iii = (i+2)%3;
; 2765 :       norm[i] = (float)((g[1].x[ii]-g[0].x[ii])*(g[2].x[iii]-g[0].x[iii])
; 2766 :                -  (g[1].x[iii]-g[0].x[iii])*(g[2].x[ii]-g[0].x[ii]));

	fld	QWORD PTR [edi+304]

; 2767 :     }
; 2768 :     len = sqrt(dotf(norm,norm,3));

	lea	eax, DWORD PTR _norm$[ebp]
	fsub	QWORD PTR [edi+16]
	push	3
	fld	QWORD PTR [edi+152]
	push	eax
	fsub	QWORD PTR [edi+8]
	mov	ecx, eax
	push	ecx
	fmulp	ST(1), ST(0)
	fld	QWORD PTR [edi+296]
	fsub	QWORD PTR [edi+8]
	fld	QWORD PTR [edi+160]
	fsub	QWORD PTR [edi+16]
	fmulp	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _norm$[ebp]
	fld	QWORD PTR [edi+288]
	fsub	QWORD PTR [edi]
	fld	QWORD PTR [edi+144]
	fsub	QWORD PTR [edi]
	fld	QWORD PTR [edi+160]
	fsub	QWORD PTR [edi+16]
	fmul	ST(0), ST(2)
	fld	QWORD PTR [edi+304]
	fsub	QWORD PTR [edi+16]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _norm$[ebp+4]
	fld	QWORD PTR [edi+296]
	fsub	QWORD PTR [edi+8]
	fmulp	ST(1), ST(0)
	fld	QWORD PTR [edi+152]
	fsub	QWORD PTR [edi+8]
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)
	fstp	DWORD PTR _norm$[ebp+8]
	call	_dotf
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 2769 :     if ( len <= 0.0 ) goto do_the_edges;

	fldz
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 1
	je	$LN114@Oglz_facet

; 2770 :     for ( i = 0 ; i < 3 ; i++ ) 
; 2771 :       norm[i]= (float)(norm[i]/len);

	fld	DWORD PTR _norm$[ebp]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _norm$[ebp]
	fld	DWORD PTR _norm$[ebp+4]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR _norm$[ebp+4]
	fdivr	DWORD PTR _norm$[ebp+8]
$LN116@Oglz_facet:

; 2772 :   }
; 2773 : 
; 2774 :   if ( (g[0].color != UNSHOWN) && td->facetshow_flag )

	cmp	DWORD PTR [edi+104], -3			; fffffffdH
	fstp	DWORD PTR _norm$[ebp+8]
	je	$do_the_edges$95612
	cmp	DWORD PTR [ebx+1704], 0
	je	$do_the_edges$95612

; 2775 :   { if ( pick_flag ) my_glLoadName(f_id); /* for picking */

	cmp	DWORD PTR _pick_flag, 0
	je	SHORT $LN109@Oglz_facet
	mov	edx, DWORD PTR _f_id$[ebp]
	push	edx
	call	_my_glLoadName
	add	esp, 4
$LN109@Oglz_facet:

; 2776 :     if ( g[0].color != CLEAR )

	mov	eax, DWORD PTR [edi+104]
	cmp	eax, -1
	je	$LN96@Oglz_facet

; 2777 :     { if ( my_own_pick_flag )

	cmp	DWORD PTR _my_own_pick_flag, 0
	je	SHORT $LN39@Oglz_facet

; 2778 :         my_own_facet_pick(g,f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	eax
	push	edi
	call	_my_own_facet_pick
	add	esp, 8

; 2779 :       else

	jmp	$LN96@Oglz_facet
$LN39@Oglz_facet:

; 2780 :       {
; 2781 :         if ( color_flag ) 

	cmp	DWORD PTR _color_flag, 0
	je	SHORT $LN37@Oglz_facet

; 2782 :           f_glColor(td,g->color);

	push	eax
	push	ebx
	call	_f_glColor
	add	esp, 8

; 2783 :         else 

	jmp	SHORT $LN36@Oglz_facet
$LN37@Oglz_facet:

; 2784 :           f_glColor(td,INDEX_TO_RGBA(WHITE));

	push	15					; 0000000fH
	call	_INDEX_TO_RGBA
	push	eax
	push	ebx
	call	_f_glColor
	add	esp, 12					; 0000000cH
$LN36@Oglz_facet:

; 2785 :         fa = g[0].opacity;

	fld	QWORD PTR [edi+112]

; 2786 :         kb_glNormal3fv(td,norm);

	lea	ecx, DWORD PTR _norm$[ebp]
	push	ecx
	fstp	DWORD PTR _fa
	push	ebx
	call	_kb_glNormal3fv
	add	esp, 8

; 2787 :         if ( !td->arraysflag )

	cmp	DWORD PTR [ebx+9772], 0
	jne	SHORT $LN99@Oglz_facet

; 2788 :           glBegin(GL_TRIANGLES);

	push	4
	call	DWORD PTR __imp__glBegin@4
$LN99@Oglz_facet:

; 2789 :         for ( k = 0 ; k < 3 ; k++ )

	mov	esi, edi
	mov	DWORD PTR tv341[ebp], 3
	npad	5
$LL34@Oglz_facet:

; 2790 :         { if ( td->normflag ) 

	cmp	DWORD PTR [ebx+1708], 0
	je	SHORT $LN31@Oglz_facet

; 2791 :             kb_glNormal3dv(td,g[k].norm);

	lea	edx, DWORD PTR [esi+56]
	push	edx
	push	ebx
	call	_kb_glNormal3dv
	add	esp, 8
$LN31@Oglz_facet:

; 2792 :           f_glVertex3dv(td,g[k].x);

	push	esi
	push	ebx
	call	_f_glVertex3dv
	add	esp, 8
	add	esi, 144				; 00000090H
	dec	DWORD PTR tv341[ebp]
	jne	SHORT $LL34@Oglz_facet

; 2793 :         }
; 2794 :         if ( !td->arraysflag )

	cmp	DWORD PTR [ebx+9772], 0
	jne	SHORT $LN96@Oglz_facet

; 2795 :           glEnd();

	call	DWORD PTR __imp__glEnd@0
$LN96@Oglz_facet:

; 2796 :       }
; 2797 :     }
; 2798 :     if ( my_own_pick_flag && (g->backcolor != g->color) && (g->backcolor != CLEAR) )

	cmp	DWORD PTR _my_own_pick_flag, 0
	je	SHORT $LN112@Oglz_facet
	mov	eax, DWORD PTR [edi+108]
	cmp	eax, DWORD PTR [edi+104]
	je	SHORT $LN112@Oglz_facet
	cmp	eax, -1
	je	SHORT $LN112@Oglz_facet

; 2799 :       my_own_facet_pick(g,f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	eax
	push	edi
	call	_my_own_facet_pick
	add	esp, 8

; 2800 :     else

	jmp	$do_the_edges$95612
$LN112@Oglz_facet:

; 2801 :     if ( (g->color != g->backcolor) && (g->backcolor != CLEAR) )

	mov	eax, DWORD PTR [edi+108]
	cmp	DWORD PTR [edi+104], eax
	je	$do_the_edges$95612
	cmp	eax, -1
	je	$do_the_edges$95612

; 2802 :     { REAL x[MAXCOORD];
; 2803 :       f_glColor(td,g->backcolor);

	push	eax
	push	ebx
	call	_f_glColor

; 2804 :       for ( i = 0 ; i < 3 ; i++ ) 
; 2805 :         backnorm[i] = -norm[i];

	fld	DWORD PTR _norm$[ebp]
	fchs

; 2806 :       kb_glNormal3fv(td,backnorm);

	lea	ecx, DWORD PTR _backnorm$[ebp]
	fstp	DWORD PTR _backnorm$[ebp]
	push	ecx
	fld	DWORD PTR _norm$[ebp+4]
	push	ebx
	fchs
	fstp	DWORD PTR _backnorm$[ebp+4]
	fld	DWORD PTR _norm$[ebp+8]
	fchs
	fstp	DWORD PTR _backnorm$[ebp+8]
	call	_kb_glNormal3fv
	add	esp, 16					; 00000010H

; 2807 :       if ( !td->arraysflag )

	cmp	DWORD PTR [ebx+9772], 0
	jne	SHORT $LN23@Oglz_facet

; 2808 :         glBegin(GL_TRIANGLES);

	push	4
	call	DWORD PTR __imp__glBegin@4
$LN23@Oglz_facet:

; 2809 :       for ( k = 2 ; k >= 0 ; k-- )

	lea	edx, DWORD PTR [edi+344]
	mov	DWORD PTR _k$[ebp], 2
	mov	DWORD PTR tv1656[ebp], edx
	lea	esi, DWORD PTR [edi+304]
	npad	6
$LL110@Oglz_facet:

; 2810 :       { for ( i = 0 ; i < 3 ; i++ )
; 2811 :         x[i] = g[k].x[i] + thickness*backnorm[i];
; 2812 :         if ( td->normflag ) 

	cmp	DWORD PTR [ebx+1708], 0
	fld	DWORD PTR _backnorm$[ebp]
	fld	QWORD PTR _thickness
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR [esi-16]
	fstp	QWORD PTR _x$95633[ebp]
	fld	DWORD PTR _backnorm$[ebp+4]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [esi-8]
	fstp	QWORD PTR _x$95633[ebp+8]
	fmul	DWORD PTR _backnorm$[ebp+8]
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR _x$95633[ebp+16]
	je	SHORT $LN16@Oglz_facet

; 2813 :            kb_glAntiNormal3dv(td,g[k].norm);

	mov	eax, DWORD PTR tv1656[ebp]
	push	eax
	push	ebx
	call	_kb_glAntiNormal3dv
	add	esp, 8
$LN16@Oglz_facet:

; 2814 :         f_glVertex3dv(td,x);

	lea	ecx, DWORD PTR _x$95633[ebp]
	push	ecx
	push	ebx
	call	_f_glVertex3dv
	mov	eax, DWORD PTR _k$[ebp]
	sub	DWORD PTR tv1656[ebp], 144		; 00000090H
	dec	eax
	add	esp, 8
	sub	esi, 144				; 00000090H
	mov	DWORD PTR _k$[ebp], eax
	test	eax, eax
	jns	SHORT $LL110@Oglz_facet

; 2815 :       }
; 2816 :       if ( !td->arraysflag )

	cmp	DWORD PTR [ebx+9772], 0
	jne	SHORT $do_the_edges$95612

; 2817 :         glEnd();

	call	DWORD PTR __imp__glEnd@0
	jmp	SHORT $do_the_edges$95612
$LN114@Oglz_facet:
	fstp	ST(0)
$do_the_edges$95612:

; 2818 :     }
; 2819 :   }
; 2820 :  
; 2821 : do_the_edges:
; 2822 :   fe = valid_id(f_id) ? get_facet_fe(f_id) : NULLID;          

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN54@Oglz_facet
	mov	edx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	test	DWORD PTR _f_id$[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR [edx+eax*4]
	mov	esi, DWORD PTR [eax+28]
	je	SHORT $LN55@Oglz_facet
	xor	esi, 134217728				; 08000000H

; 2823 :   for ( k = 0 ; k < 3 ; k++, fe = valid_id(fe)?get_next_edge(fe):NULLID )

	xor	ecx, ecx
	mov	DWORD PTR _fe$[ebp], esi
	sub	edi, -128				; ffffff80H
	jmp	SHORT $LN14@Oglz_facet
$LN54@Oglz_facet:

; 2818 :     }
; 2819 :   }
; 2820 :  
; 2821 : do_the_edges:
; 2822 :   fe = valid_id(f_id) ? get_facet_fe(f_id) : NULLID;          

	xor	esi, esi
$LN55@Oglz_facet:

; 2823 :   for ( k = 0 ; k < 3 ; k++, fe = valid_id(fe)?get_next_edge(fe):NULLID )

	xor	ecx, ecx
	mov	DWORD PTR _fe$[ebp], esi
	sub	edi, -128				; ffffff80H
	jmp	SHORT $LN14@Oglz_facet
$LL104@Oglz_facet:

; 2818 :     }
; 2819 :   }
; 2820 :  
; 2821 : do_the_edges:
; 2822 :   fe = valid_id(f_id) ? get_facet_fe(f_id) : NULLID;          

	mov	esi, DWORD PTR _fe$[ebp]
$LN14@Oglz_facet:

; 2824 :   { int kk = (k+1)%3;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR tv1021[ebp], eax
	cdq
	mov	ecx, 3
	idiv	ecx

; 2825 :     if ( g[k].ecolor == CLEAR ) continue;

	cmp	DWORD PTR [edi-8], -1
	mov	DWORD PTR _kk$95651[ebp], edx
	je	$LN13@Oglz_facet

; 2826 :     if ( !edgeshow_flag || (g[0].color == UNSHOWN) )

	cmp	DWORD PTR _edgeshow_flag, 0
	je	SHORT $LN105@Oglz_facet
	mov	eax, DWORD PTR _g$GSCopy$[ebp]
	cmp	DWORD PTR [eax+104], -3			; fffffffdH
	jne	SHORT $LN8@Oglz_facet
$LN105@Oglz_facet:

; 2827 :     { if ( (g[k].etype & EBITS) == INVISIBLE_EDGE ) continue;      

	mov	ecx, 767				; 000002ffH
	test	WORD PTR [edi-4], cx
	je	$LN13@Oglz_facet
$LN8@Oglz_facet:

; 2828 :     }
; 2829 :     if ( my_own_pick_flag )

	cmp	DWORD PTR _my_own_pick_flag, 0
	je	SHORT $LN7@Oglz_facet

; 2830 :     { my_own_edge_pick(g+k,g+kk,g[k].id);

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [edx+edx*8]
	shl	ecx, 4
	add	ecx, DWORD PTR _g$GSCopy$[ebp]
	push	eax
	push	ecx
	lea	edx, DWORD PTR [edi-128]
	push	edx
	call	_my_own_edge_pick
	add	esp, 12					; 0000000cH

; 2831 :         continue;

	jmp	$LN13@Oglz_facet
$LN7@Oglz_facet:

; 2832 :     }
; 2833 : 
; 2834 :     if ( pick_flag ) 

	cmp	DWORD PTR _pick_flag, 0
	je	SHORT $LN6@Oglz_facet

; 2835 : 	    my_glLoadName(g[k].id); /* for picking */

	mov	eax, DWORD PTR [edi]
	push	eax
	call	_my_glLoadName
	add	esp, 4
$LN6@Oglz_facet:

; 2836 :     e_glColor(td,g[k].ecolor);

	mov	ecx, DWORD PTR [edi-8]
	push	ecx
	push	ebx
	call	_e_glColor

; 2837 :     kb_glNormal3fv(td,norm);

	lea	edx, DWORD PTR _norm$[ebp]
	push	edx
	push	ebx
	call	_kb_glNormal3fv
	add	esp, 16					; 00000010H

; 2838 :     if ( !td->arraysflag )

	cmp	DWORD PTR [ebx+9772], 0
	jne	SHORT $LN5@Oglz_facet

; 2839 :         glBegin(GL_LINES);

	push	1
	call	DWORD PTR __imp__glBegin@4
$LN5@Oglz_facet:

; 2840 :       if ( td->normflag ) 

	cmp	DWORD PTR [ebx+1708], 0
	je	SHORT $LN4@Oglz_facet

; 2841 :         kb_glNormal3dv(td,g[k].norm);

	lea	eax, DWORD PTR [edi-72]
	push	eax
	push	ebx
	call	_kb_glNormal3dv
	add	esp, 8
$LN4@Oglz_facet:

; 2842 :       e_glVertex3dv(td,g[k].x);

	lea	eax, DWORD PTR [edi-128]
	push	eax
	push	ebx
	call	_e_glVertex3dv

; 2843 :       if ( td->normflag ) 
; 2844 :         kb_glNormal3dv(td,g[kk].norm);

	mov	esi, DWORD PTR _kk$95651[ebp]
	add	esp, 8
	cmp	DWORD PTR [ebx+1708], 0
	je	SHORT $LN3@Oglz_facet
	mov	edx, DWORD PTR _g$GSCopy$[ebp]
	lea	ecx, DWORD PTR [esi+esi*8]
	add	ecx, ecx
	lea	eax, DWORD PTR [edx+ecx*8+56]
	push	eax
	push	ebx
	call	_kb_glNormal3dv
	add	esp, 8
$LN3@Oglz_facet:

; 2845 :       e_glVertex3dv(td,g[kk].x);

	lea	esi, DWORD PTR [esi+esi*8]
	shl	esi, 4
	add	esi, DWORD PTR _g$GSCopy$[ebp]
	push	esi
	push	ebx
	call	_e_glVertex3dv
	add	esp, 8

; 2846 :     if ( !td->arraysflag )

	cmp	DWORD PTR [ebx+9772], 0
	jne	SHORT $LN2@Oglz_facet

; 2847 :         glEnd();

	call	DWORD PTR __imp__glEnd@0
$LN2@Oglz_facet:

; 2848 : 	if ( pick_flag ) 

	cmp	DWORD PTR _pick_flag, 0
	je	SHORT $LN98@Oglz_facet

; 2849 : 	{ 
; 2850 :       my_glLoadName(g[k].v_id);

	mov	eax, DWORD PTR [edi+4]
	push	eax
	call	_my_glLoadName
	add	esp, 4

; 2851 : 	  glBegin(GL_POINTS);

	push	0
	call	DWORD PTR __imp__glBegin@4

; 2852 :         glVertex3d((GLdouble)g[k].x[0],(GLdouble)g[k].x[1],(GLdouble)g[k].x[2]);

	fld	QWORD PTR [edi-112]
	sub	esp, 24					; 00000018H
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR [edi-120]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [edi-128]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__glVertex3d@24

; 2853 :       glEnd();

	call	DWORD PTR __imp__glEnd@0

; 2854 : 	  my_glLoadName(g[kk].v_id);

	mov	ecx, DWORD PTR [esi+132]
	push	ecx
	call	_my_glLoadName
	add	esp, 4

; 2855 : 	  glBegin(GL_POINTS);

	push	0
	call	DWORD PTR __imp__glBegin@4

; 2856 :         glVertex3d((GLdouble)g[kk].x[0],(GLdouble)g[kk].x[1],(GLdouble)g[kk].x[2]);

	fld	QWORD PTR [esi+16]
	sub	esp, 24					; 00000018H
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR [esi+8]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [esi]
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__glVertex3d@24

; 2857 :       glEnd();

	call	DWORD PTR __imp__glEnd@0
$LN98@Oglz_facet:

; 2831 :         continue;

	mov	esi, DWORD PTR _fe$[ebp]
$LN13@Oglz_facet:

; 2823 :   for ( k = 0 ; k < 3 ; k++, fe = valid_id(fe)?get_next_edge(fe):NULLID )

	mov	ecx, DWORD PTR tv1021[ebp]
	add	edi, 144				; 00000090H
	test	esi, 268435456				; 10000000H
	je	SHORT $LN56@Oglz_facet
	mov	edx, DWORD PTR _web+460
	test	esi, 134217728				; 08000000H
	je	SHORT $LN63@Oglz_facet
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN57@Oglz_facet
$LN63@Oglz_facet:
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [eax+32]
	jmp	SHORT $LN57@Oglz_facet
$LN56@Oglz_facet:
	xor	eax, eax
$LN57@Oglz_facet:
	mov	DWORD PTR _fe$[ebp], eax
	cmp	ecx, 3
	jl	$LL104@Oglz_facet

; 2858 : 	}
; 2859 :    }
; 2860 : 
; 2861 : } /* end Oglz_facet() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_Oglz_facet ENDP
_TEXT	ENDS
PUBLIC	_Oglz_end
EXTRN	_graph_timestamp:DWORD
_BSS	SEGMENT
_prev_timestamp DD 01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _Oglz_end
_TEXT	SEGMENT
_Oglz_end PROC						; COMDAT

; 2873 :   prev_timestamp = graph_timestamp;

	mov	eax, DWORD PTR _graph_timestamp
	mov	DWORD PTR _prev_timestamp, eax

; 2874 : }

	ret	0
_Oglz_end ENDP
_TEXT	ENDS
PUBLIC	_Ogl_close
EXTRN	__imp__ExitThread@4:PROC
EXTRN	_init_flag:DWORD
EXTRN	_go_display_flag:DWORD
EXTRN	__imp__glDeleteLists@8:PROC
EXTRN	_glutDestroyWindow@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _Ogl_close
_TEXT	SEGMENT
_Ogl_close PROC						; COMDAT

; 2884 : { 

	push	esi
	push	edi

; 2885 :   struct graph_thread_data *td = GET_DATA;

	call	_glutGetWindow@0
	mov	esi, eax
	imul	esi, 9896				; 000026a8H
	add	esi, OFFSET _gthread_data

; 2886 : 
; 2887 :   glutDestroyWindow(td->win_id);

	mov	eax, DWORD PTR [esi+140]
	push	eax
	call	_glutDestroyWindow@4

; 2888 :   memset((char*)td,0,sizeof(struct graph_thread_data));

	push	9896					; 000026a8H
	xor	edi, edi
	push	edi
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 2889 : 
; 2890 : #ifndef MAC_OS_X
; 2891 :  /* Mac objects to closing graphics thread */
; 2892 : 
; 2893 :  { int i;
; 2894 :   for ( i = 0 ; i < MAXGRAPHWINDOWS ; i++ )

	xor	ecx, ecx
	mov	eax, OFFSET _gthread_data
	npad	7
$LL5@Ogl_close:

; 2895 :   { if ( gthread_data[i].in_use != 0 ) break;

	cmp	DWORD PTR [eax], edi
	jne	SHORT $LN9@Ogl_close

; 2889 : 
; 2890 : #ifndef MAC_OS_X
; 2891 :  /* Mac objects to closing graphics thread */
; 2892 : 
; 2893 :  { int i;
; 2894 :   for ( i = 0 ; i < MAXGRAPHWINDOWS ; i++ )

	add	eax, 9896				; 000026a8H
	inc	ecx
	cmp	eax, OFFSET _gthread_data+98960
	jl	SHORT $LL5@Ogl_close
$LN9@Ogl_close:

; 2896 :   }
; 2897 :   if ( i == MAXGRAPHWINDOWS )

	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN1@Ogl_close

; 2898 :   { /* all graph windows closed */
; 2899 :     glDeleteLists(dindex,1);

	mov	ecx, DWORD PTR _dindex
	push	1
	push	ecx
	call	DWORD PTR __imp__glDeleteLists@8

; 2900 :     go_display_flag = 0;
; 2901 :     init_flag = 0;
; 2902 :     initz_flag = 0;
; 2903 :     td->arrays_timestamp = 0;
; 2904 :     graph_thread_running = 0;
; 2905 :   
; 2906 : #ifdef WIN32
; 2907 :   ExitThread(0);

	push	edi
	mov	DWORD PTR _go_display_flag, edi
	mov	DWORD PTR _init_flag, edi
	mov	DWORD PTR _initz_flag, edi
	mov	DWORD PTR [esi+132], edi
	mov	DWORD PTR _graph_thread_running, edi
	call	DWORD PTR __imp__ExitThread@4
$LN12@Ogl_close:
$LN1@Ogl_close:
	pop	edi
	pop	esi

; 2908 : #elif defined(PTHREADS)
; 2909 :   pthread_exit(NULL);
; 2910 : #endif
; 2911 :   }
; 2912 : }
; 2913 : #endif
; 2914 : 
; 2915 : } // end Ogl_close()

	ret	0
$LN11@Ogl_close:
_Ogl_close ENDP
_TEXT	ENDS
PUBLIC	_Ogl_close_show
; Function compile flags: /Ogtp
;	COMDAT _Ogl_close_show
_TEXT	SEGMENT
_Ogl_close_show PROC					; COMDAT

; 2925 : { close_flag = 1;

	mov	DWORD PTR _close_flag, 1

; 2926 : }

	ret	0
_Ogl_close_show ENDP
_TEXT	ENDS
PUBLIC	_vercolcomp
; Function compile flags: /Ogtp
;	COMDAT _vercolcomp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_vercolcomp PROC					; COMDAT

; 2937 : { 

	push	ebp
	mov	ebp, esp

; 2938 :   int i;
; 2939 :   for ( i = 0 ; i < 10 ; i++ )

	fld	QWORD PTR _gleps
	mov	edx, DWORD PTR _b$[ebp]
	push	esi
	fld	ST(0)
	mov	esi, DWORD PTR _a$[ebp]
	fchs
	xor	ecx, ecx
	sub	esi, edx
$LN5@vercolcomp:

; 2940 :   { REAL diff = ((float*)a)[i] - ((float*)b)[i];

	fld	DWORD PTR [esi+edx]
	fsub	DWORD PTR [edx]

; 2941 :     if ( diff < -gleps ) return -1;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN14@vercolcomp

; 2942 :     if ( diff > gleps ) return 1;

	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN17@vercolcomp

; 2938 :   int i;
; 2939 :   for ( i = 0 ; i < 10 ; i++ )

	inc	ecx
	add	edx, 4
	cmp	ecx, 10					; 0000000aH
	jl	SHORT $LN5@vercolcomp
	fstp	ST(1)

; 2943 :   }
; 2944 :   return 0;

	xor	eax, eax
	fstp	ST(0)
	pop	esi

; 2945 : } // end vercolcomp()

	pop	ebp
	ret	0
$LN14@vercolcomp:

; 2941 :     if ( diff < -gleps ) return -1;

	fstp	ST(0)
	or	eax, -1
	fstp	ST(1)
	pop	esi
	fstp	ST(0)

; 2945 : } // end vercolcomp()

	pop	ebp
	ret	0
$LN17@vercolcomp:

; 2942 :     if ( diff > gleps ) return 1;

	fstp	ST(1)
	mov	eax, 1
	fstp	ST(0)
	pop	esi

; 2945 : } // end vercolcomp()

	pop	ebp
	ret	0
_vercolcomp ENDP
_TEXT	ENDS
PUBLIC	_depth_comp
; Function compile flags: /Ogtp
;	COMDAT _depth_comp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_depth_comp PROC					; COMDAT

; 2957 : { if ( ((struct depth_s*)a)->depth < ((struct depth_s*)b)->depth ) return -1;

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	fld	QWORD PTR [edx+8]
	fcomp	QWORD PTR [ecx+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@depth_comp
	or	eax, -1

; 2960 : }

	pop	ebp
	ret	0
$LN2@depth_comp:

; 2958 :   if ( ((struct depth_s*)a)->depth > ((struct depth_s*)b)->depth ) return  1;

	fld	QWORD PTR [edx+8]
	fcomp	QWORD PTR [ecx+8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@depth_comp
	mov	eax, 1

; 2960 : }

	pop	ebp
	ret	0
$LN1@depth_comp:

; 2959 :   return 0;

	xor	eax, eax

; 2960 : }

	pop	ebp
	ret	0
_depth_comp ENDP
_TEXT	ENDS
PUBLIC	__real@4024000000000000
PUBLIC	_opacity_sort
EXTRN	_qsort:PROC
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _opacity_sort
_TEXT	SEGMENT
tv1229 = -28						; size = 4
_fcount$ = -24						; size = 4
_i$ = -20						; size = 4
tv1165 = -16						; size = 4
_ecount$ = -16						; size = 4
_vspot$ = -12						; size = 4
tv155 = -8						; size = 4
tv2088 = -4						; size = 4
tv1717 = -4						; size = 4
_opacity_sort PROC					; COMDAT

; 2967 : { struct graph_thread_data *td = GET_DATA;

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	call	_glutGetWindow@0
	mov	esi, eax
	imul	esi, 9896				; 000026a8H
	add	esi, OFFSET _gthread_data

; 2968 :   int *vspot;
; 2969 :   int i;
; 2970 :   struct depth_s *ds;
; 2971 :   int fcount = td->facetcount/3;

	mov	eax, 1431655766				; 55555556H
	imul	DWORD PTR [esi+9800]

; 2972 :   int ecount = td->edgecount/2;

	mov	eax, DWORD PTR [esi+9792]
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cdq
	sub	eax, edx
	mov	ebx, eax
	sar	ebx, 1

; 2973 : 
; 2974 :   if ( td->opacity_alloc < fcount+ecount )

	lea	edi, DWORD PTR [ebx+ecx]
	mov	DWORD PTR _fcount$[ebp], ecx
	mov	DWORD PTR _ecount$[ebp], ebx
	mov	DWORD PTR tv1229[ebp], edi
	cmp	DWORD PTR [esi+9876], edi
	jge	SHORT $LN8@opacity_so

; 2975 :   { 
; 2976 :     td->opacity_list = (struct depth_s*)realloc(td->opacity_list,(fcount+ecount)*sizeof(struct depth_s));

	mov	ecx, DWORD PTR [esi+9884]
	mov	eax, edi
	shl	eax, 4
	push	eax
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR [esi+9884], eax

; 2977 :     td->opacity_alloc = fcount+ecount;

	mov	DWORD PTR [esi+9876], edi
$LN8@opacity_so:

; 2978 :   }
; 2979 :   // set up depth sort, just using first vertex of facet
; 2980 :   vspot =  td->indexarray+td->edgestart;

	mov	edx, DWORD PTR [esi+9788]

; 2981 :   for ( i = 0, ds = td->opacity_list ; i < ecount ; i++,ds++ )

	fld	QWORD PTR _imagescale
	mov	eax, DWORD PTR [esi+9832]
	mov	ecx, DWORD PTR [esi+9884]
	lea	edx, DWORD PTR [eax+edx*4]
	xor	edi, edi
	mov	DWORD PTR _vspot$[ebp], edx
	cmp	ebx, 4
	jl	$LC20@opacity_so

; 2978 :   }
; 2979 :   // set up depth sort, just using first vertex of facet
; 2980 :   vspot =  td->indexarray+td->edgestart;

	lea	eax, DWORD PTR [ebx-4]
	shr	eax, 2
	inc	eax
	mov	DWORD PTR tv155[ebp], eax
	add	eax, eax
	add	edx, 8
	add	eax, eax
	mov	DWORD PTR tv1717[ebp], 4
	mov	DWORD PTR _i$[ebp], eax
$LN32@opacity_so:

; 2982 :   { struct vercol *xspot;
; 2983 :     REAL depth1,depth2;
; 2984 : 
; 2985 :     ds->index = 2*i;

	mov	eax, DWORD PTR tv1717[ebp]

; 2986 :     ds->type = EDGE;

	mov	DWORD PTR [ecx+4], 1
	add	eax, -4					; fffffffcH
	mov	DWORD PTR [ecx], eax

; 2987 :     // using deepest vertex with bias, so appears in front of adjacent facets
; 2988 :     xspot = td->fullarray + vspot[2*i];

	mov	eax, DWORD PTR [edx-8]
	mov	ebx, DWORD PTR [esi+9776]
	imul	eax, 44					; 0000002cH

; 2989 :     depth1 =  td->view[0][0]*xspot->x[0]
; 2990 :                + td->view[0][1]*xspot->x[1]
; 2991 :                + td->view[0][2]*xspot->x[2];

	mov	edi, DWORD PTR [esi+280]
	fld	DWORD PTR [eax+ebx+28]
	fmul	QWORD PTR [edi]
	fld	DWORD PTR [eax+ebx+32]
	fmul	QWORD PTR [edi+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+ebx+36]

; 2992 :     xspot = td->fullarray + vspot[2*i+1];

	mov	eax, DWORD PTR [edx-4]
	fmul	QWORD PTR [edi+16]
	imul	eax, 44					; 0000002cH
	faddp	ST(1), ST(0)

; 2993 :     depth2 =  td->view[0][0]*xspot->x[0]
; 2994 :                + td->view[0][1]*xspot->x[1]
; 2995 :                + td->view[0][2]*xspot->x[2];

	fld	DWORD PTR [eax+ebx+28]
	fmul	QWORD PTR [edi]
	fld	DWORD PTR [eax+ebx+32]
	fmul	QWORD PTR [edi+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+ebx+36]
	fmul	QWORD PTR [edi+16]
	faddp	ST(1), ST(0)

; 2996 :     ds->depth = (depth1 < depth2) ? depth1 : depth2;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN39@opacity_so
	fstp	ST(0)
	jmp	SHORT $LN22@opacity_so
$LN39@opacity_so:
	fstp	ST(1)
$LN22@opacity_so:

; 2982 :   { struct vercol *xspot;
; 2983 :     REAL depth1,depth2;
; 2984 : 
; 2985 :     ds->index = 2*i;

	mov	eax, DWORD PTR tv1717[ebp]

; 2996 :     ds->depth = (depth1 < depth2) ? depth1 : depth2;

	fst	QWORD PTR [ecx+8]

; 2997 :     ds->depth += td->edge_bias*imagescale;

	fld	QWORD PTR [esi+1720]
	mov	DWORD PTR [ecx+20], 1
	fmul	ST(0), ST(2)
	add	eax, -2					; fffffffeH
	mov	DWORD PTR [ecx+16], eax
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx]
	mov	ebx, DWORD PTR [esi+9776]
	imul	eax, 44					; 0000002cH
	mov	edi, DWORD PTR [esi+280]
	fld	DWORD PTR [eax+ebx+28]
	fmul	QWORD PTR [edi]
	fld	DWORD PTR [eax+ebx+32]
	fmul	QWORD PTR [edi+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+ebx+36]
	mov	eax, DWORD PTR [edx+4]
	fmul	QWORD PTR [edi+16]
	imul	eax, 44					; 0000002cH
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+ebx+28]
	fmul	QWORD PTR [edi]
	fld	DWORD PTR [eax+ebx+32]
	fmul	QWORD PTR [edi+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+ebx+36]
	fmul	QWORD PTR [edi+16]
	faddp	ST(1), ST(0)
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN43@opacity_so

; 2996 :     ds->depth = (depth1 < depth2) ? depth1 : depth2;

	fstp	ST(0)
	jmp	SHORT $LN24@opacity_so
$LN43@opacity_so:
	fstp	ST(1)
$LN24@opacity_so:

; 2982 :   { struct vercol *xspot;
; 2983 :     REAL depth1,depth2;
; 2984 : 
; 2985 :     ds->index = 2*i;

	mov	eax, DWORD PTR tv1717[ebp]

; 2996 :     ds->depth = (depth1 < depth2) ? depth1 : depth2;

	fst	QWORD PTR [ecx+24]

; 2997 :     ds->depth += td->edge_bias*imagescale;

	fld	QWORD PTR [esi+1720]
	mov	DWORD PTR [ecx+32], eax
	fmul	ST(0), ST(2)
	mov	DWORD PTR [ecx+36], 1
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+8]
	mov	ebx, DWORD PTR [esi+9776]
	imul	eax, 44					; 0000002cH
	mov	edi, DWORD PTR [esi+280]
	fld	DWORD PTR [eax+ebx+28]
	fmul	QWORD PTR [edi]
	fld	DWORD PTR [eax+ebx+32]
	fmul	QWORD PTR [edi+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+ebx+36]
	mov	eax, DWORD PTR [edx+12]
	fmul	QWORD PTR [edi+16]
	imul	eax, 44					; 0000002cH
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+ebx+28]
	fmul	QWORD PTR [edi]
	fld	DWORD PTR [eax+ebx+32]
	fmul	QWORD PTR [edi+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+ebx+36]
	fmul	QWORD PTR [edi+16]
	faddp	ST(1), ST(0)
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN47@opacity_so

; 2996 :     ds->depth = (depth1 < depth2) ? depth1 : depth2;

	fstp	ST(0)
	jmp	SHORT $LN26@opacity_so
$LN47@opacity_so:
	fstp	ST(1)
$LN26@opacity_so:

; 2997 :     ds->depth += td->edge_bias*imagescale;

	mov	eax, DWORD PTR tv1717[ebp]
	fst	QWORD PTR [ecx+40]
	fld	QWORD PTR [esi+1720]
	mov	DWORD PTR [ecx+52], 1
	fmul	ST(0), ST(2)
	add	eax, 2
	mov	DWORD PTR [ecx+48], eax
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+40]
	mov	eax, DWORD PTR [edx+16]
	mov	ebx, DWORD PTR [esi+9776]
	imul	eax, 44					; 0000002cH
	mov	edi, DWORD PTR [esi+280]
	fld	DWORD PTR [eax+ebx+28]
	fmul	QWORD PTR [edi]
	fld	DWORD PTR [eax+ebx+32]
	fmul	QWORD PTR [edi+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+ebx+36]
	mov	eax, DWORD PTR [edx+20]
	fmul	QWORD PTR [edi+16]
	imul	eax, 44					; 0000002cH
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+ebx+28]
	fmul	QWORD PTR [edi]
	fld	DWORD PTR [eax+ebx+32]
	fmul	QWORD PTR [edi+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+ebx+36]
	fmul	QWORD PTR [edi+16]
	faddp	ST(1), ST(0)
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN51@opacity_so

; 2996 :     ds->depth = (depth1 < depth2) ? depth1 : depth2;

	fstp	ST(0)
	jmp	SHORT $LN28@opacity_so
$LN51@opacity_so:
	fstp	ST(1)
$LN28@opacity_so:

; 2997 :     ds->depth += td->edge_bias*imagescale;

	add	DWORD PTR tv1717[ebp], 8
	fst	QWORD PTR [ecx+56]
	fld	QWORD PTR [esi+1720]
	add	ecx, 64					; 00000040H
	fmul	ST(0), ST(2)
	add	edx, 32					; 00000020H
	dec	DWORD PTR tv155[ebp]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx-8]
	jne	$LN32@opacity_so

; 2978 :   }
; 2979 :   // set up depth sort, just using first vertex of facet
; 2980 :   vspot =  td->indexarray+td->edgestart;

	mov	ebx, DWORD PTR _ecount$[ebp]
	mov	edi, DWORD PTR _i$[ebp]
$LC20@opacity_so:

; 2981 :   for ( i = 0, ds = td->opacity_list ; i < ecount ; i++,ds++ )

	cmp	edi, ebx
	jge	$LN62@opacity_so
$LN30@opacity_so:

; 2987 :     // using deepest vertex with bias, so appears in front of adjacent facets
; 2988 :     xspot = td->fullarray + vspot[2*i];

	mov	eax, DWORD PTR _vspot$[ebp]
	mov	DWORD PTR [ecx+4], 1
	lea	edx, DWORD PTR [edi+edi]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR [eax+edi*8]
	mov	ebx, DWORD PTR [esi+9776]
	imul	eax, 44					; 0000002cH

; 2989 :     depth1 =  td->view[0][0]*xspot->x[0]
; 2990 :                + td->view[0][1]*xspot->x[1]
; 2991 :                + td->view[0][2]*xspot->x[2];

	mov	edx, DWORD PTR [esi+280]
	fld	DWORD PTR [eax+ebx+28]
	fmul	QWORD PTR [edx]
	fld	DWORD PTR [eax+ebx+32]
	fmul	QWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+ebx+36]

; 2992 :     xspot = td->fullarray + vspot[2*i+1];

	mov	eax, DWORD PTR _vspot$[ebp]
	mov	eax, DWORD PTR [eax+edi*8+4]
	fmul	QWORD PTR [edx+16]
	imul	eax, 44					; 0000002cH
	faddp	ST(1), ST(0)

; 2993 :     depth2 =  td->view[0][0]*xspot->x[0]
; 2994 :                + td->view[0][1]*xspot->x[1]
; 2995 :                + td->view[0][2]*xspot->x[2];

	fld	DWORD PTR [eax+ebx+28]
	fmul	QWORD PTR [edx]
	fld	DWORD PTR [eax+ebx+32]
	fmul	QWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+ebx+36]
	fmul	QWORD PTR [edx+16]
	faddp	ST(1), ST(0)

; 2996 :     ds->depth = (depth1 < depth2) ? depth1 : depth2;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN59@opacity_so
	fstp	ST(0)
	jmp	SHORT $LN12@opacity_so
$LN59@opacity_so:
	fstp	ST(1)
$LN12@opacity_so:
	fst	QWORD PTR [ecx+8]
	inc	edi

; 2997 :     ds->depth += td->edge_bias*imagescale;

	fld	QWORD PTR [esi+1720]
	add	ecx, 16					; 00000010H
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx-8]
	cmp	edi, DWORD PTR _ecount$[ebp]
	jl	$LN30@opacity_so
$LN62@opacity_so:

; 2998 :   }
; 2999 :   vspot =  td->indexarray+td->facetstart;

	mov	eax, DWORD PTR [esi+9832]
	fstp	ST(0)
	mov	edx, DWORD PTR [esi+9796]
	lea	edi, DWORD PTR [eax+edx*4+8]

; 3000 :   for ( i = 0 ; i < fcount ; i++,ds++ )

	mov	eax, DWORD PTR _fcount$[ebp]
	test	eax, eax
	jle	$LN2@opacity_so

; 2998 :   }
; 2999 :   vspot =  td->indexarray+td->facetstart;

	fld	QWORD PTR __real@4024000000000000
	lea	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv2088[ebp], 0
	mov	DWORD PTR tv1165[ebp], eax
$LN31@opacity_so:

; 3001 :   { struct vercol *xspot = td->fullarray + vspot[3*i];
; 3002 :     REAL depth1,depth2,depth3;
; 3003 :     
; 3004 :     ds->index = td->facetstart+3*i;

	mov	ecx, DWORD PTR [esi+9796]
	add	ecx, DWORD PTR tv2088[ebp]

; 3005 :     ds->type = FACET;

	mov	DWORD PTR [edx-4], 2
	mov	DWORD PTR [edx-8], ecx

; 3006 :     xspot = td->fullarray + vspot[3*i];

	mov	ecx, DWORD PTR [edi-8]
	mov	ebx, DWORD PTR [esi+9776]
	imul	ecx, 44					; 0000002cH

; 3007 :     depth1 =  td->view[0][0]*xspot->x[0]
; 3008 :                + td->view[0][1]*xspot->x[1]
; 3009 :                + td->view[0][2]*xspot->x[2];

	mov	eax, DWORD PTR [esi+280]
	fld	DWORD PTR [ecx+ebx+28]
	fmul	QWORD PTR [eax]
	fld	DWORD PTR [ecx+ebx+32]
	fmul	QWORD PTR [eax+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ecx+ebx+36]

; 3010 :     xspot = td->fullarray + vspot[3*i+1];

	mov	ecx, DWORD PTR [edi-4]
	fmul	QWORD PTR [eax+16]
	imul	ecx, 44					; 0000002cH
	faddp	ST(1), ST(0)

; 3011 :     depth2 =  td->view[0][0]*xspot->x[0]
; 3012 :                + td->view[0][1]*xspot->x[1]
; 3013 :                + td->view[0][2]*xspot->x[2];

	fld	DWORD PTR [ecx+ebx+28]
	fmul	QWORD PTR [eax]
	fld	DWORD PTR [ecx+ebx+32]
	fmul	QWORD PTR [eax+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ecx+ebx+36]

; 3014 :     xspot = td->fullarray + vspot[3*i+2];

	mov	ecx, DWORD PTR [edi]
	fmul	QWORD PTR [eax+16]
	imul	ecx, 44					; 0000002cH
	faddp	ST(1), ST(0)

; 3015 :     depth3 =  td->view[0][0]*xspot->x[0]
; 3016 :                + td->view[0][1]*xspot->x[1]
; 3017 :                + td->view[0][2]*xspot->x[2];

	fld	DWORD PTR [ecx+ebx+28]
	fmul	QWORD PTR [eax]
	fld	DWORD PTR [ecx+ebx+32]
	fmul	QWORD PTR [eax+8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ecx+ebx+36]
	fmul	QWORD PTR [eax+16]
	faddp	ST(1), ST(0)

; 3018 :     ds->depth = (depth1 < depth2) ? depth1 : depth2;

	fxch	ST(2)
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN13@opacity_so
	fld	ST(0)
	jmp	SHORT $LN14@opacity_so
$LN13@opacity_so:
	fld	ST(1)
$LN14@opacity_so:
	fst	QWORD PTR [edx]

; 3019 :     if ( depth3 < ds->depth ) ds->depth = depth3;

	fcomp	ST(3)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@opacity_so
	fxch	ST(2)
	fst	QWORD PTR [edx]
	fxch	ST(2)
$LN1@opacity_so:

; 3020 :     ds->depth += td->edge_bias/10.0*(depth1+depth2+depth3); // bias towards front facets drawn later, but less than edge bias

	faddp	ST(1), ST(0)
	add	DWORD PTR tv2088[ebp], 3
	add	edi, 12					; 0000000cH
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv1165[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [esi+1720]
	fdiv	ST(0), ST(2)
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR [edx-16]
	fstp	QWORD PTR [edx-16]
	jne	$LN31@opacity_so

; 3000 :   for ( i = 0 ; i < fcount ; i++,ds++ )

	fstp	ST(0)
$LN2@opacity_so:

; 3021 :   }
; 3022 :   qsort(td->opacity_list,fcount+ecount,sizeof(struct depth_s),depth_comp);

	mov	edx, DWORD PTR tv1229[ebp]
	mov	eax, DWORD PTR [esi+9884]
	push	OFFSET _depth_comp
	push	16					; 00000010H
	push	edx
	push	eax
	call	_qsort
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 3023 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_opacity_sort ENDP
_TEXT	ENDS
PUBLIC	_eecomp
; Function compile flags: /Ogtp
;	COMDAT _eecomp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_eecomp	PROC						; COMDAT

; 3033 : { if ( *a < *b ) return -1;

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [esi]
	cmp	eax, ecx
	jge	SHORT $LN7@eecomp
	or	eax, -1
	pop	esi

; 3037 :   return 0;
; 3038 : } // end eecomp()

	pop	ebp
	ret	0
$LN7@eecomp:

; 3034 :   if ( *a > *b ) return 1;

	jle	SHORT $LN3@eecomp
$LN8@eecomp:
	mov	eax, 1
	pop	esi

; 3037 :   return 0;
; 3038 : } // end eecomp()

	pop	ebp
	ret	0
$LN3@eecomp:

; 3035 :   if ( a[1] > b[1] ) return 1;

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [esi+4]
	cmp	eax, ecx
	jg	SHORT $LN8@eecomp

; 3036 :   if ( a[1] < b[1] ) return -1;

	xor	edx, edx
	cmp	eax, ecx
	setge	dl
	pop	esi
	lea	eax, DWORD PTR [edx-1]

; 3037 :   return 0;
; 3038 : } // end eecomp()

	pop	ebp
	ret	0
_eecomp	ENDP
_TEXT	ENDS
PUBLIC	_declare_arrays
; Function compile flags: /Ogtp
;	COMDAT _declare_arrays
_TEXT	SEGMENT
_declare_arrays PROC					; COMDAT

; 3049 : { struct graph_thread_data *td = GET_DATA;

	push	esi
	call	_glutGetWindow@0
	mov	esi, eax
	imul	esi, 9896				; 000026a8H
	add	esi, OFFSET _gthread_data

; 3050 : 
; 3051 :   GL_ERROR_CHECK
; 3052 : 
; 3053 :   if ( td->arraysflag )

	cmp	DWORD PTR [esi+9772], 0
	je	$LN6@declare_ar

; 3054 :   {
; 3055 :     glEnableClientState(GL_COLOR_ARRAY);

	push	edi
	mov	edi, DWORD PTR __imp__glEnableClientState@4
	push	32886					; 00008076H
	call	edi

; 3056 :     glEnableClientState(GL_NORMAL_ARRAY);

	push	32885					; 00008075H
	call	edi

; 3057 :     glEnableClientState(GL_VERTEX_ARRAY);

	push	32884					; 00008074H
	call	edi

; 3058 : 
; 3059 :     /* declare arrays to OpenGL */
; 3060 :     if ( td->interleaved_flag )

	cmp	DWORD PTR [esi+9824], 0
	pop	edi
	je	SHORT $LN2@declare_ar

; 3061 :     {
; 3062 :       //glInterleavedArrays(GL_C4F_N3F_V3F,sizeof(struct vercol),(void*)td->fullarray);
; 3063 :       glColorPointer(4,GL_FLOAT,sizeof(struct vercol),td->fullarray);      

	mov	eax, DWORD PTR [esi+9776]
	push	eax
	push	44					; 0000002cH
	push	5126					; 00001406H
	push	4
	call	DWORD PTR __imp__glColorPointer@16

; 3064 :       glNormalPointer(GL_FLOAT,sizeof(struct vercol),td->fullarray->n);

	mov	ecx, DWORD PTR [esi+9776]
	add	ecx, 16					; 00000010H
	push	ecx
	push	44					; 0000002cH
	push	5126					; 00001406H
	call	DWORD PTR __imp__glNormalPointer@12

; 3065 :       glVertexPointer(3,GL_FLOAT,sizeof(struct vercol),td->fullarray->x);

	mov	edx, DWORD PTR [esi+9776]
	add	edx, 28					; 0000001cH
	push	edx
	push	44					; 0000002cH
	push	5126					; 00001406H
	push	3
	call	DWORD PTR __imp__glVertexPointer@16

; 3073 :     }
; 3074 :   }
; 3075 :   td->declared_timestamp = td->arrays_timestamp;

	mov	eax, DWORD PTR [esi+132]
	mov	DWORD PTR [esi+136], eax
	pop	esi

; 3076 :   GL_ERROR_CHECK
; 3077 : } // end declare_arrays()

	ret	0
$LN2@declare_ar:

; 3066 : 
; 3067 :     }
; 3068 :     else /* indexed */
; 3069 :     { 
; 3070 :       glColorPointer(4,GL_FLOAT,0,td->colorarray);      

	mov	ecx, DWORD PTR [esi+9784]
	push	ecx
	push	0
	push	5126					; 00001406H
	push	4
	call	DWORD PTR __imp__glColorPointer@16

; 3071 :       glNormalPointer(GL_FLOAT,sizeof(struct vercol),td->fullarray->n);

	mov	edx, DWORD PTR [esi+9776]
	add	edx, 16					; 00000010H
	push	edx
	push	44					; 0000002cH
	push	5126					; 00001406H
	call	DWORD PTR __imp__glNormalPointer@12

; 3072 :       glVertexPointer(3,GL_FLOAT,sizeof(struct vercol),td->fullarray->x);

	mov	eax, DWORD PTR [esi+9776]
	add	eax, 28					; 0000001cH
	push	eax
	push	44					; 0000002cH
	push	5126					; 00001406H
	push	3
	call	DWORD PTR __imp__glVertexPointer@16

; 3073 :     }
; 3074 :   }
; 3075 :   td->declared_timestamp = td->arrays_timestamp;

	mov	ecx, DWORD PTR [esi+132]
	mov	DWORD PTR [esi+136], ecx
	pop	esi

; 3076 :   GL_ERROR_CHECK
; 3077 : } // end declare_arrays()

	ret	0
$LN6@declare_ar:

; 3073 :     }
; 3074 :   }
; 3075 :   td->declared_timestamp = td->arrays_timestamp;

	mov	edx, DWORD PTR [esi+132]
	mov	DWORD PTR [esi+136], edx
	pop	esi

; 3076 :   GL_ERROR_CHECK
; 3077 : } // end declare_arrays()

	ret	0
_declare_arrays ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_draw_one_image
EXTRN	_bounding_box:BYTE
EXTRN	__imp__glVertex3dv@4:PROC
EXTRN	_bounding_box_color:DWORD
EXTRN	_box_flag:DWORD
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	_normflag:DWORD
EXTRN	__imp__glArrayElement@4:PROC
EXTRN	__imp__glEnable@4:PROC
EXTRN	__imp__glBlendFunc@8:PROC
EXTRN	_opacity_attr:DWORD
EXTRN	__imp__glDisable@4:PROC
EXTRN	__imp__glDrawElements@16:PROC
EXTRN	__imp__glMultMatrixf@4:PROC
EXTRN	_view_transform_det:DWORD
EXTRN	_transform_count:DWORD
EXTRN	_view_transforms:DWORD
EXTRN	_transforms_flag:DWORD
EXTRN	__imp__MsgWaitForMultipleObjects@20:PROC
EXTRN	_graphmutex:DWORD
EXTRN	_locking_thread:DWORD
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__glTranslated@24:PROC
EXTRN	__imp__glCallList@4:PROC
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _draw_one_image
_TEXT	SEGMENT
tv3046 = -160						; size = 4
_did_graphlock_here$95777 = -156			; size = 4
tv2986 = -152						; size = 4
tv256 = -152						; size = 4
_hi$95793 = -148					; size = 4
_m$95776 = -144						; size = 4
_tmat$95784 = -140					; size = 64
_tail$95861 = -76					; size = 24
_head$95862 = -52					; size = 24
_a$95860 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_draw_one_image PROC					; COMDAT

; 3087 : { struct graph_thread_data *td = GET_DATA;

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	call	_glutGetWindow@0
	mov	esi, eax
	imul	esi, 9896				; 000026a8H
	add	esi, OFFSET _gthread_data

; 3088 : 
; 3089 :   if ( td->dlistflag )

	xor	edi, edi
	cmp	DWORD PTR [esi+1748], edi
	je	SHORT $LN111@draw_one_i

; 3090 :     glCallList(dindex);    

	mov	eax, DWORD PTR _dindex
	push	eax
	call	DWORD PTR __imp__glCallList@4
	jmp	$LN242@draw_one_i
$LN111@draw_one_i:

; 3091 :   else if ( td->multi_dlist_flag )

	cmp	DWORD PTR [esi+1752], edi
	je	$LN109@draw_one_i

; 3092 :   { int i;
; 3093 :     for ( i = 0 ; i < td->facet_dlist_count ; i++ )

	xor	ebx, ebx
	cmp	DWORD PTR [esi+9768], edi
	jle	SHORT $LN106@draw_one_i
	lea	edi, DWORD PTR [esi+5764]
$LL108@draw_one_i:

; 3094 :       glCallList(td->facet_dlists[i]);

	mov	ecx, DWORD PTR [edi]
	push	ecx
	call	DWORD PTR __imp__glCallList@4
	inc	ebx
	add	edi, 4
	cmp	ebx, DWORD PTR [esi+9768]
	jl	SHORT $LL108@draw_one_i
$LN106@draw_one_i:

; 3095 :     glMatrixMode(GL_PROJECTION);

	push	5889					; 00001701H
	call	DWORD PTR __imp__glMatrixMode@4

; 3096 :     glTranslated(td->edge_bias*imagescale,0.0,0.0);    /* edges in front */

	fldz
	sub	esp, 24					; 00000018H
	fst	QWORD PTR [esp+16]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [esi+1720]
	fmul	QWORD PTR _imagescale
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__glTranslated@24

; 3097 :     for ( i = 0 ; i < td->edge_dlist_count ; i++ )

	xor	ebx, ebx
	cmp	DWORD PTR [esi+5760], ebx
	jle	SHORT $LN103@draw_one_i

; 3095 :     glMatrixMode(GL_PROJECTION);

	lea	edi, DWORD PTR [esi+1756]
$LL105@draw_one_i:

; 3098 :       glCallList(td->edge_dlists[i]);

	mov	edx, DWORD PTR [edi]
	push	edx
	call	DWORD PTR __imp__glCallList@4
	inc	ebx
	add	edi, 4
	cmp	ebx, DWORD PTR [esi+5760]
	jl	SHORT $LL105@draw_one_i
$LN103@draw_one_i:

; 3099 :     glTranslated(-td->edge_bias*imagescale,0.0,0.0);

	fldz
	sub	esp, 24					; 00000018H
	fst	QWORD PTR [esp+16]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [esi+1720]
	fmul	QWORD PTR _imagescale
	fchs
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__glTranslated@24

; 3100 :     glMatrixMode(GL_MODELVIEW);

	push	5888					; 00001700H
	call	DWORD PTR __imp__glMatrixMode@4
	jmp	$LN242@draw_one_i
$LN109@draw_one_i:

; 3101 :   }
; 3102 :   else if ( td->arraysflag )
; 3103 :   { int i,j,m;
; 3104 : 
; 3105 :   GL_ERROR_CHECK
; 3106 : 
; 3107 :     ENTER_GRAPH_MUTEX;

	mov	ebx, DWORD PTR __imp__GetCurrentThreadId@0
	cmp	DWORD PTR [esi+9772], edi
	je	$LN101@draw_one_i
	call	ebx
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN100@draw_one_i
	push	edi
	push	100000					; 000186a0H
	push	edi
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	ebx
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$95777[ebp], 1
	jmp	SHORT $LN99@draw_one_i
$LN100@draw_one_i:
	mov	DWORD PTR _did_graphlock_here$95777[ebp], edi
$LN99@draw_one_i:

; 3108 : 
; 3109 :     for ( m = 0 ; (m < transform_count) || (m < 1) ; m++ )

	fld	QWORD PTR __real@bff0000000000000
	mov	ecx, DWORD PTR _transforms_flag
	mov	ebx, DWORD PTR _view_transforms
	mov	DWORD PTR _m$95776[ebp], edi
	mov	edi, DWORD PTR __imp__glTranslated@24
$LN332@draw_one_i:
	mov	eax, DWORD PTR _m$95776[ebp]
	fld1
	cmp	eax, DWORD PTR _transform_count
	jl	SHORT $LN95@draw_one_i
	cmp	eax, 1
	jge	$LN256@draw_one_i
$LN95@draw_one_i:

; 3110 :     { float tmat[4][4];  /* transform matrix in proper form */
; 3111 : 
; 3112 :       if ( transforms_flag && td->doing_lazy && view_transform_det 
; 3113 :                                   && (view_transform_det[m] == -1.0) )

	test	ecx, ecx
	je	$LN258@draw_one_i
	cmp	DWORD PTR [esi+9864], 0
	je	$LN270@draw_one_i
	cmp	DWORD PTR _view_transform_det, 0
	je	$LN270@draw_one_i
	mov	eax, DWORD PTR _view_transform_det
	mov	edx, DWORD PTR _m$95776[ebp]
	fild	DWORD PTR [eax+edx*4]
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN270@draw_one_i

; 3114 :       { /* have to flip normals */
; 3115 :         for ( i = 0 ; i < td->edgecount+td->facetcount ; i++ )

	mov	eax, DWORD PTR [esi+9800]
	add	eax, DWORD PTR [esi+9792]
	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN270@draw_one_i
	mov	eax, 20					; 00000014H
$LN93@draw_one_i:

; 3116 :          for ( j = 0 ; j < 3 ; j++ )
; 3117 :           td->fullarray[i].n[j] *= -1.0;

	mov	ecx, DWORD PTR [esi+9776]
	fld	DWORD PTR [eax+ecx-4]
	lea	ecx, DWORD PTR [eax+ecx-4]
	fmul	ST(0), ST(2)
	inc	edx
	fstp	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+9776]
	fld	DWORD PTR [ecx+eax]
	fmul	ST(0), ST(2)
	fstp	DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR [esi+9776]
	fld	DWORD PTR [eax+ecx+4]
	lea	ecx, DWORD PTR [eax+ecx+4]
	fmul	ST(0), ST(2)
	add	eax, 44					; 0000002cH
	fstp	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+9800]
	add	ecx, DWORD PTR [esi+9792]
	cmp	edx, ecx
	jl	SHORT $LN93@draw_one_i

; 3114 :       { /* have to flip normals */
; 3115 :         for ( i = 0 ; i < td->edgecount+td->facetcount ; i++ )

	mov	ecx, DWORD PTR _transforms_flag
	mov	ebx, DWORD PTR _view_transforms
$LN270@draw_one_i:
	fstp	ST(1)

; 3118 :       }
; 3119 : 
; 3120 :       if ( transforms_flag && td->doing_lazy && view_transforms )

	test	ecx, ecx
	je	$LN282@draw_one_i
	cmp	DWORD PTR [esi+9864], 0
	je	$LN282@draw_one_i
	test	ebx, ebx
	je	$LN282@draw_one_i

; 3121 :       { int hi = (SDIM <= 3) ? SDIM : 3;

	mov	edi, DWORD PTR _web+616
	cmp	edi, 3
	jg	SHORT $LN114@draw_one_i
	mov	eax, edi
	mov	DWORD PTR _hi$95793[ebp], edi
	jmp	SHORT $LN115@draw_one_i
$LN114@draw_one_i:
	mov	eax, 3
	mov	DWORD PTR _hi$95793[ebp], eax
$LN115@draw_one_i:

; 3122 :         for ( i = 0 ; i < hi; i++ )

	xor	edx, edx
	test	eax, eax
	jle	$LN209@draw_one_i
	lea	eax, DWORD PTR _tmat$95784[ebp+12]
	mov	DWORD PTR tv2986[ebp], eax
$LN86@draw_one_i:

; 3123 :         { for ( j = 0 ; j < hi; j++ )

	xor	eax, eax
	cmp	DWORD PTR _hi$95793[ebp], 4
	jl	SHORT $LN235@draw_one_i
	mov	ecx, DWORD PTR tv2986[ebp]
	add	ecx, -8					; fffffff8H
$LN233@draw_one_i:

; 3124 :             tmat[i][j] = (float)view_transforms[m][j][i];

	mov	edi, DWORD PTR _m$95776[ebp]
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR _m$95776[ebp]
	fstp	DWORD PTR [ecx-4]
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	edi, DWORD PTR [edi+eax*4+4]
	fld	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR _m$95776[ebp]
	fstp	DWORD PTR [ecx]
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	edi, DWORD PTR [edi+eax*4+8]
	fld	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR _m$95776[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	edi, DWORD PTR [edi+eax*4+12]
	fld	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR _hi$95793[ebp]
	fstp	DWORD PTR [ecx+8]
	add	eax, 4
	add	edi, -3					; fffffffdH
	add	ecx, 16					; 00000010H
	cmp	eax, edi
	jl	SHORT $LN233@draw_one_i
	mov	edi, DWORD PTR _web+616
$LN235@draw_one_i:

; 3123 :         { for ( j = 0 ; j < hi; j++ )

	cmp	eax, DWORD PTR _hi$95793[ebp]
	jge	SHORT $LN236@draw_one_i
	lea	ecx, DWORD PTR [eax+edx*4]
	lea	ecx, DWORD PTR _tmat$95784[ebp+ecx*4]
$LN234@draw_one_i:

; 3124 :             tmat[i][j] = (float)view_transforms[m][j][i];

	mov	edi, DWORD PTR _m$95776[ebp]
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edi+edx*8]
	inc	eax
	fstp	DWORD PTR [ecx]
	add	ecx, 4
	cmp	eax, DWORD PTR _hi$95793[ebp]
	jl	SHORT $LN234@draw_one_i

; 3123 :         { for ( j = 0 ; j < hi; j++ )

	mov	edi, DWORD PTR _web+616
$LN236@draw_one_i:

; 3125 :           for ( ; j < 3 ; j++ ) tmat[i][j] = 0.0;

	cmp	eax, 3
	jge	SHORT $LN80@draw_one_i
	lea	edi, DWORD PTR [eax+edx*4]
	mov	ecx, 3
	sub	ecx, eax
	lea	edi, DWORD PTR _tmat$95784[ebp+edi*4]
	xor	eax, eax
	rep stosd
	mov	edi, DWORD PTR _web+616
$LN80@draw_one_i:

; 3126 :           tmat[i][3] = (float)view_transforms[m][SDIM][i];

	mov	ecx, DWORD PTR _m$95776[ebp]
	mov	eax, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR tv2986[ebp]
	fld	QWORD PTR [ecx+edx*8]
	fstp	DWORD PTR [eax]
	inc	edx
	add	eax, 16					; 00000010H
	mov	DWORD PTR tv2986[ebp], eax
	cmp	edx, DWORD PTR _hi$95793[ebp]
	jl	$LN86@draw_one_i

; 3127 :         }
; 3128 :         for ( ; i < 3 ; i++ )

	cmp	edx, 3
	jge	SHORT $LN311@draw_one_i
$LN209@draw_one_i:

; 3129 :         { for ( j = 0 ; j < 4 ; j++ ) tmat[i][j] = 0.0;

	lea	eax, DWORD PTR [edx+edx*4]
	lea	ecx, DWORD PTR _tmat$95784[ebp+eax*4]
	mov	DWORD PTR tv3046[ebp], ecx
	mov	eax, edx
	add	eax, eax
	mov	ecx, 3
	sub	ecx, edx
	mov	edx, DWORD PTR tv3046[ebp]
	lea	eax, DWORD PTR _tmat$95784[ebp+eax*8]
	mov	DWORD PTR tv256[ebp], ecx
$LN208@draw_one_i:
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 3130 :           tmat[i][i] = 1.0;

	fst	DWORD PTR [edx]
	add	eax, 16					; 00000010H
	add	edx, 20					; 00000014H
	dec	DWORD PTR tv256[ebp]
	jne	SHORT $LN208@draw_one_i
$LN311@draw_one_i:

; 3131 :         }
; 3132 :         for ( j = 0 ; j < hi ; j++ )

	mov	ecx, DWORD PTR _hi$95793[ebp]
	fstp	ST(0)
	xor	eax, eax
	cmp	ecx, 4
	jl	SHORT $LC180@draw_one_i
	lea	ecx, DWORD PTR [eax+12]
	npad	4
$LL181@draw_one_i:

; 3133 :           tmat[3][j] = (float)view_transforms[m][j][SDIM];

	mov	edx, DWORD PTR _m$95776[ebp]
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR [edx+eax*4]
	fld	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR _m$95776[ebp]
	fstp	DWORD PTR _tmat$95784[ebp+eax*4+48]
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR [edx+eax*4+4]
	fld	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR _m$95776[ebp]
	fstp	DWORD PTR _tmat$95784[ebp+eax*4+52]
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR [edx+ecx-4]
	fld	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR _m$95776[ebp]
	fstp	DWORD PTR _tmat$95784[ebp+eax*4+56]
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR [edx+ecx]
	fld	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR _hi$95793[ebp]
	fstp	DWORD PTR _tmat$95784[ebp+eax*4+60]
	add	eax, 4
	add	edx, -3					; fffffffdH
	add	ecx, 16					; 00000010H
	cmp	eax, edx
	jl	SHORT $LL181@draw_one_i
	mov	ecx, DWORD PTR _hi$95793[ebp]
$LC180@draw_one_i:

; 3131 :         }
; 3132 :         for ( j = 0 ; j < hi ; j++ )

	cmp	eax, ecx
	jge	SHORT $LN179@draw_one_i
	npad	5
$LL238@draw_one_i:

; 3133 :           tmat[3][j] = (float)view_transforms[m][j][SDIM];

	mov	edx, DWORD PTR _m$95776[ebp]
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	edx, DWORD PTR [edx+eax*4]
	fld	QWORD PTR [edx+edi*8]
	inc	eax
	fstp	DWORD PTR _tmat$95784[ebp+eax*4+44]
	cmp	eax, ecx
	jl	SHORT $LL238@draw_one_i
$LN179@draw_one_i:

; 3134 :         for ( ; j < 3 ; j++ )

	cmp	eax, 3
	jge	SHORT $LN68@draw_one_i
	mov	ecx, 3
	lea	edi, DWORD PTR _tmat$95784[ebp+eax*4+48]
	sub	ecx, eax
	xor	eax, eax
	rep stosd
	mov	edi, DWORD PTR _web+616
$LN68@draw_one_i:

; 3135 :           tmat[3][j] = 0.0;
; 3136 :         tmat[3][3] = (float)view_transforms[m][SDIM][SDIM];

	mov	eax, DWORD PTR _m$95776[ebp]
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	edx, DWORD PTR [ecx+edi*4]
	fld	QWORD PTR [edx+edi*8]

; 3137 :       
; 3138 :         glMatrixMode(GL_MODELVIEW);

	push	5888					; 00001700H
	fstp	DWORD PTR _tmat$95784[ebp+60]
	call	DWORD PTR __imp__glMatrixMode@4

; 3139 :         glPushMatrix();

	call	DWORD PTR __imp__glPushMatrix@0

; 3140 :         glMultMatrixf((float*)tmat); 

	lea	eax, DWORD PTR _tmat$95784[ebp]
	push	eax
	call	DWORD PTR __imp__glMultMatrixf@4
	mov	edi, DWORD PTR __imp__glTranslated@24
	jmp	SHORT $LN87@draw_one_i
$LN258@draw_one_i:
	fstp	ST(1)
$LN282@draw_one_i:

; 3118 :       }
; 3119 : 
; 3120 :       if ( transforms_flag && td->doing_lazy && view_transforms )

	fstp	ST(0)
$LN87@draw_one_i:

; 3141 :       }
; 3142 : 
; 3143 :   GL_ERROR_CHECK
; 3144 : 
; 3145 :       if ( td->strips_flag )

	cmp	DWORD PTR [esi+9836], 0
	je	$LN65@draw_one_i

; 3146 :       { int i;
; 3147 :         /* do facets first, then edges in front */
; 3148 :         for ( i = td->estripcount ; i < td->stripcount ; i++ )

	mov	ebx, DWORD PTR [esi+9852]
	cmp	ebx, DWORD PTR [esi+9848]
	jge	SHORT $LN62@draw_one_i
	lea	edi, DWORD PTR [ebx+ebx*2]
	add	edi, edi
	add	edi, edi
$LL64@draw_one_i:

; 3149 :           glDrawElements(td->striparray[i].mode,td->striparray[i].count,
; 3150 :                         GL_UNSIGNED_INT,td->stripdata+td->striparray[i].start);

	mov	eax, DWORD PTR [esi+9844]
	mov	ecx, DWORD PTR [esi+9860]
	mov	edx, DWORD PTR [eax+edi+4]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+edi+8]
	push	edx
	mov	edx, DWORD PTR [eax+edi]
	push	5125					; 00001405H
	push	ecx
	push	edx
	call	DWORD PTR __imp__glDrawElements@16
	inc	ebx
	add	edi, 12					; 0000000cH
	cmp	ebx, DWORD PTR [esi+9848]
	jl	SHORT $LL64@draw_one_i
$LN62@draw_one_i:

; 3151 :         glMatrixMode(GL_PROJECTION);

	push	5889					; 00001701H
	call	DWORD PTR __imp__glMatrixMode@4

; 3152 :         glTranslated(td->edge_bias*imagescale,0.0,0.0);

	fldz
	sub	esp, 24					; 00000018H
	fst	QWORD PTR [esp+16]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [esi+1720]
	fmul	QWORD PTR _imagescale
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__glTranslated@24

; 3153 :         for ( i = 0 ; i < td->estripcount ; i++ )

	xor	edi, edi
	cmp	DWORD PTR [esi+9852], edi
	jle	SHORT $LN59@draw_one_i

; 3151 :         glMatrixMode(GL_PROJECTION);

	xor	ebx, ebx
	npad	3
$LL61@draw_one_i:

; 3154 :           glDrawElements(td->striparray[i].mode,td->striparray[i].count,
; 3155 :                         GL_UNSIGNED_INT,td->stripdata+td->striparray[i].start);

	mov	eax, DWORD PTR [esi+9844]
	mov	ecx, DWORD PTR [eax+ebx+4]
	mov	edx, DWORD PTR [esi+9860]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [eax+ebx+8]
	mov	eax, DWORD PTR [eax+ebx]
	push	ecx
	push	5125					; 00001405H
	push	edx
	push	eax
	call	DWORD PTR __imp__glDrawElements@16
	inc	edi
	add	ebx, 12					; 0000000cH
	cmp	edi, DWORD PTR [esi+9852]
	jl	SHORT $LL61@draw_one_i
$LN59@draw_one_i:

; 3156 :         glTranslated(-td->edge_bias*imagescale,0.0,0.0);

	fldz
	sub	esp, 24					; 00000018H
	fst	QWORD PTR [esp+16]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [esi+1720]
	fmul	QWORD PTR _imagescale
	fchs
	fstp	QWORD PTR [esp]
	call	DWORD PTR __imp__glTranslated@24
	mov	edi, DWORD PTR __imp__glTranslated@24
	jmp	$LN48@draw_one_i
$LN65@draw_one_i:

; 3157 :       }     
; 3158 :       else if ( td->indexing_flag )

	cmp	DWORD PTR [esi+9828], 0
	je	$LN57@draw_one_i

; 3159 :       {
; 3160 :         if ( web.sdim == 2 ) // strange things with transforms

	cmp	DWORD PTR _web+616, 2
	jne	SHORT $LN56@draw_one_i

; 3161 :            glDisable(GL_LIGHTING);

	push	2896					; 00000b50H
	call	DWORD PTR __imp__glDisable@4
$LN56@draw_one_i:

; 3162 :         if ( opacity_attr && td->opacity_flag )

	cmp	DWORD PTR _opacity_attr, 0
	je	$LN55@draw_one_i
	cmp	DWORD PTR [esi+9872], 0
	je	$LN55@draw_one_i

; 3163 :         { // have to depth-sort facets to get proper display order
; 3164 :           struct depth_s *ds;
; 3165 :           int to_do;
; 3166 :           opacity_sort();  

	call	_opacity_sort

; 3167 :           glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR __imp__glBlendFunc@8

; 3168 :           glEnable(GL_BLEND);

	push	3042					; 00000be2H
	call	DWORD PTR __imp__glEnable@4

; 3169 :           glDisable(GL_DEPTH_TEST);  // otherwise very patchy

	push	2929					; 00000b71H
	call	DWORD PTR __imp__glDisable@4

; 3170 :           to_do = td->edgecount/2 + td->facetcount/3;
; 3171 : //printf("Opacity list\n");
; 3172 :           for ( i = 0, ds = td->opacity_list ; i < to_do ; i++,ds++ )

	mov	ebx, DWORD PTR [esi+9884]
	mov	eax, 1431655766				; 55555556H
	imul	DWORD PTR [esi+9800]
	mov	eax, DWORD PTR [esi+9792]
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	ecx, eax
	test	ecx, ecx
	jle	$LN239@draw_one_i

; 3163 :         { // have to depth-sort facets to get proper display order
; 3164 :           struct depth_s *ds;
; 3165 :           int to_do;
; 3166 :           opacity_sort();  

	mov	edi, ecx
$LL54@draw_one_i:

; 3173 :           { if ( ds->type == EDGE ) 

	cmp	DWORD PTR [ebx+4], 1
	jne	SHORT $LN51@draw_one_i

; 3174 :             { glBegin(GL_LINES);

	push	1
	call	DWORD PTR __imp__glBegin@4

; 3175 : //printf("%f %f %f      %f %f %f\n",
; 3176 : //    td->fullarray[ds->index].x[0], td->fullarray[ds->index].x[1], td->fullarray[ds->index].x[2],
; 3177 : //     td->fullarray[ds->index+1].x[0], td->fullarray[ds->index+1].x[1], td->fullarray[ds->index+1].x[2]);
; 3178 :               glArrayElement(td->indexarray[ds->index]);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [esi+9832]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR __imp__glArrayElement@4

; 3179 :               glArrayElement(td->indexarray[ds->index+1]);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [esi+9832]
	mov	eax, DWORD PTR [edx+ecx*4+4]

; 3180 :               glEnd();
; 3181 :             }
; 3182 :             else

	jmp	SHORT $LN329@draw_one_i
$LN51@draw_one_i:

; 3183 :             { glBegin(GL_TRIANGLES);

	push	4
	call	DWORD PTR __imp__glBegin@4

; 3184 :               glArrayElement(td->indexarray[ds->index]);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [esi+9832]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR __imp__glArrayElement@4

; 3185 :               glArrayElement(td->indexarray[ds->index+1]);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [esi+9832]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	push	eax
	call	DWORD PTR __imp__glArrayElement@4

; 3186 :               glArrayElement(td->indexarray[ds->index+2]);

	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [esi+9832]
	mov	eax, DWORD PTR [edx+ecx*4+8]
$LN329@draw_one_i:
	push	eax
	call	DWORD PTR __imp__glArrayElement@4

; 3187 :               glEnd();

	call	DWORD PTR __imp__glEnd@0
	add	ebx, 16					; 00000010H
	dec	edi
	jne	SHORT $LL54@draw_one_i

; 3170 :           to_do = td->edgecount/2 + td->facetcount/3;
; 3171 : //printf("Opacity list\n");
; 3172 :           for ( i = 0, ds = td->opacity_list ; i < to_do ; i++,ds++ )

	mov	edi, DWORD PTR __imp__glTranslated@24
$LN239@draw_one_i:

; 3188 :             }
; 3189 :           }          
; 3190 :           glDisable(GL_BLEND);

	push	3042					; 00000be2H
	call	DWORD PTR __imp__glDisable@4

; 3191 :           glEnable(GL_DEPTH_TEST);  // otherwise very patchy

	push	2929					; 00000b71H
	call	DWORD PTR __imp__glEnable@4

; 3192 :         }
; 3193 :         else 

	jmp	$LN48@draw_one_i
$LN55@draw_one_i:

; 3194 :         {
; 3195 :           glDrawElements(GL_TRIANGLES,td->facetcount,GL_UNSIGNED_INT,
; 3196 :              td->indexarray+td->facetstart);

	mov	ecx, DWORD PTR [esi+9796]
	mov	edx, DWORD PTR [esi+9832]
	mov	ebx, DWORD PTR __imp__glDrawElements@16
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [esi+9800]
	push	eax
	push	5125					; 00001405H
	push	ecx
	push	4
	call	ebx

; 3197 :         
; 3198 :           glMatrixMode(GL_PROJECTION);

	push	5889					; 00001701H
	call	DWORD PTR __imp__glMatrixMode@4

; 3199 :           glTranslated(td->edge_bias*imagescale,0.0,0.0);

	fldz
	sub	esp, 24					; 00000018H
	fst	QWORD PTR [esp+16]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [esi+1720]
	fmul	QWORD PTR _imagescale
	fstp	QWORD PTR [esp]
	call	edi

; 3200 :   glDisable(GL_LIGHTING);

	push	2896					; 00000b50H
	call	DWORD PTR __imp__glDisable@4

; 3201 :           glDrawElements(GL_LINES,td->edgecount,GL_UNSIGNED_INT,td->indexarray+td->edgestart);

	mov	edx, DWORD PTR [esi+9788]
	mov	eax, DWORD PTR [esi+9832]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [esi+9792]
	push	ecx
	push	5125					; 00001405H
	push	edx
	push	1
	call	ebx

; 3202 :   glEnable(GL_LIGHTING);

	push	2896					; 00000b50H
	call	DWORD PTR __imp__glEnable@4

; 3203 :           glTranslated(-td->edge_bias*imagescale,0.0,0.0);
; 3204 :         }
; 3205 :       }
; 3206 :       else

	jmp	SHORT $LN330@draw_one_i
$LN57@draw_one_i:

; 3207 :       {
; 3208 :         glDrawArrays(GL_TRIANGLES,td->facetstart,td->facetcount);

	mov	eax, DWORD PTR [esi+9800]
	mov	ecx, DWORD PTR [esi+9796]
	mov	ebx, DWORD PTR __imp__glDrawArrays@12
	push	eax
	push	ecx
	push	4
	call	ebx

; 3209 :         glMatrixMode(GL_PROJECTION);

	push	5889					; 00001701H
	call	DWORD PTR __imp__glMatrixMode@4

; 3210 :         glTranslated(td->edge_bias*imagescale,0.0,0.0);

	fldz
	sub	esp, 24					; 00000018H
	fst	QWORD PTR [esp+16]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [esi+1720]
	fmul	QWORD PTR _imagescale
	fstp	QWORD PTR [esp]
	call	edi

; 3211 :         glDrawArrays(GL_LINES,td->edgestart,td->edgecount);

	mov	edx, DWORD PTR [esi+9792]
	mov	eax, DWORD PTR [esi+9788]
	push	edx
	push	eax
	push	1
	call	ebx
$LN330@draw_one_i:

; 3212 :         glTranslated(-td->edge_bias*imagescale,0.0,0.0);

	fldz
	sub	esp, 24					; 00000018H
	fst	QWORD PTR [esp+16]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [esi+1720]
	fmul	QWORD PTR _imagescale
	fchs
	fstp	QWORD PTR [esp]
	call	edi
$LN48@draw_one_i:

; 3213 :       }
; 3214 :       if ( transforms_flag && td->doing_lazy && view_transforms )

	mov	ecx, DWORD PTR _transforms_flag
	mov	ebx, DWORD PTR _view_transforms
	test	ecx, ecx
	je	$LN232@draw_one_i
	cmp	DWORD PTR [esi+9864], 0
	je	SHORT $LN47@draw_one_i
	test	ebx, ebx
	je	SHORT $LN47@draw_one_i

; 3215 :       { glMatrixMode(GL_MODELVIEW); glPopMatrix(); }

	push	5888					; 00001700H
	call	DWORD PTR __imp__glMatrixMode@4
	call	DWORD PTR __imp__glPopMatrix@0
	mov	ecx, DWORD PTR _transforms_flag
	mov	ebx, DWORD PTR _view_transforms
$LN47@draw_one_i:

; 3216 : 
; 3217 :       if ( transforms_flag &&  td->doing_lazy && view_transform_det 
; 3218 :                  && (view_transform_det[m] == -1.0) )

	test	ecx, ecx
	je	$LN232@draw_one_i
	cmp	DWORD PTR [esi+9864], 0
	je	$LN232@draw_one_i
	mov	eax, DWORD PTR _view_transform_det
	test	eax, eax
	je	$LN232@draw_one_i
	mov	edx, DWORD PTR _m$95776[ebp]
	fild	DWORD PTR [eax+edx*4]
	fld	QWORD PTR __real@bff0000000000000
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN240@draw_one_i

; 3219 :       { /* have to flip normals back */
; 3220 :         for ( i = 0 ; i < td->edgecount+td->facetcount ; i++ )

	mov	eax, DWORD PTR [esi+9800]
	add	eax, DWORD PTR [esi+9792]
	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN240@draw_one_i
	mov	eax, 20					; 00000014H
$LN45@draw_one_i:

; 3221 :          for ( j = 0 ; j < 3 ; j++ )
; 3222 :           td->fullarray[i].n[j] *= -1.0;

	mov	ecx, DWORD PTR [esi+9776]
	fld	DWORD PTR [eax+ecx-4]
	lea	ecx, DWORD PTR [eax+ecx-4]
	fmul	ST(0), ST(1)
	inc	edx
	fstp	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+9776]
	fld	DWORD PTR [ecx+eax]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR [esi+9776]
	fld	DWORD PTR [eax+ecx+4]
	lea	ecx, DWORD PTR [eax+ecx+4]
	fmul	ST(0), ST(1)
	add	eax, 44					; 0000002cH
	fstp	DWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+9800]
	add	ecx, DWORD PTR [esi+9792]
	cmp	edx, ecx
	jl	SHORT $LN45@draw_one_i

; 3219 :       { /* have to flip normals back */
; 3220 :         for ( i = 0 ; i < td->edgecount+td->facetcount ; i++ )

	mov	ecx, DWORD PTR _transforms_flag
	mov	ebx, DWORD PTR _view_transforms
	jmp	SHORT $LN240@draw_one_i
$LN232@draw_one_i:
	fld	QWORD PTR __real@bff0000000000000
$LN240@draw_one_i:

; 3223 :       }
; 3224 : 
; 3225 :       if ( !td->doing_lazy  || !transforms_flag || !view_transforms ) break;

	cmp	DWORD PTR [esi+9864], 0
	je	SHORT $LN327@draw_one_i
	test	ecx, ecx
	je	SHORT $LN327@draw_one_i
	test	ebx, ebx
	je	SHORT $LN327@draw_one_i

; 3108 : 
; 3109 :     for ( m = 0 ; (m < transform_count) || (m < 1) ; m++ )

	inc	DWORD PTR _m$95776[ebp]
	jmp	$LN332@draw_one_i
$LN256@draw_one_i:
	fstp	ST(1)
$LN327@draw_one_i:

; 3226 :     } /* end transform loop */
; 3227 :     LEAVE_GRAPH_MUTEX

	cmp	DWORD PTR _did_graphlock_here$95777[ebp], 0
	fstp	ST(0)
	je	SHORT $LN242@draw_one_i
	mov	edx, DWORD PTR _graphmutex
	mov	DWORD PTR _locking_thread, 0
	push	edx

; 3228 :   } /* end arraysflag */
; 3229 :   else /* not using display list or arrays */

	jmp	SHORT $LN333@draw_one_i
$LN101@draw_one_i:

; 3230 :   {
; 3231 :     ENTER_GRAPH_MUTEX

	call	ebx
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN35@draw_one_i
	push	edi
	push	100000					; 000186a0H
	push	edi
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	ebx
	mov	DWORD PTR _locking_thread, eax
	mov	ebx, 1
	jmp	SHORT $LN34@draw_one_i
$LN35@draw_one_i:
	xor	ebx, ebx
$LN34@draw_one_i:

; 3232 :     normflag = td->normflag;

	mov	eax, DWORD PTR [esi+1708]
	mov	DWORD PTR _normflag, eax

; 3233 :     graphgen();

	call	_graphgen

; 3234 :     LEAVE_GRAPH_MUTEX

	cmp	ebx, edi
	je	SHORT $LN242@draw_one_i
	mov	ecx, DWORD PTR _graphmutex
	mov	DWORD PTR _locking_thread, edi
	push	ecx
$LN333@draw_one_i:
	call	DWORD PTR __imp__ReleaseMutex@4
$LN242@draw_one_i:

; 3235 :   }
; 3236 : 
; 3237 :   /* Bounding box, if using lazy_transforms */
; 3238 :   if ( box_flag && td->arraysflag && td->doing_lazy && !web.torus_flag )

	xor	edi, edi
	cmp	DWORD PTR _box_flag, edi
	je	$LN14@draw_one_i
	cmp	DWORD PTR [esi+9772], edi
	je	$LN14@draw_one_i
	cmp	DWORD PTR [esi+9864], edi
	je	$LN14@draw_one_i
	cmp	DWORD PTR _web+860, edi
	jne	$LN14@draw_one_i

; 3239 :   { int k,m,a[MAXCOORD];
; 3240 :     GLdouble tail[3],head[3];
; 3241 :     glColor4fv(rgba[bounding_box_color]);

	mov	edx, DWORD PTR _bounding_box_color
	shl	edx, 4
	add	edx, OFFSET _rgba
	push	edx
	call	DWORD PTR __imp__glColor4fv@4

; 3242 :     if ( SDIM == 2 )

	mov	edx, DWORD PTR _web+616

; 3243 :     { for ( a[0] = 0 ; a[0] <= 1 ; a[0]++ )

	mov	DWORD PTR _a$95860[ebp], edi
	cmp	edx, 2
	jne	$LN31@draw_one_i
	mov	ebx, DWORD PTR __imp__glVertex3dv@4
	npad	5
$LL246@draw_one_i:

; 3244 :       for ( a[1] = 0 ; a[1] <= 1 ; a[1]++ )

	mov	DWORD PTR _a$95860[ebp+4], 0
	npad	9
$LL247@draw_one_i:

; 3245 :        for ( k = 0 ; k < 2 ; k++ )

	xor	esi, esi
$LL248@draw_one_i:

; 3246 :          if ( a[k] == 0 )

	cmp	DWORD PTR _a$95860[ebp+esi*4], 0
	jne	$LN23@draw_one_i

; 3247 :          { for ( m = 0 ; m < SDIM ; m++ )

	xor	eax, eax
	cmp	edx, 4
	jl	$LC187@draw_one_i
	lea	ebx, DWORD PTR [edx-3]
	lea	ecx, DWORD PTR [eax+2]
	npad	2
$LL196@draw_one_i:

; 3248 :            { tail[m] = bounding_box[m][a[m]];

	mov	edx, DWORD PTR _a$95860[ebp+eax*4]
	lea	edi, DWORD PTR [edx+eax*2]
	fld	QWORD PTR _bounding_box[edi*8]
	fstp	QWORD PTR _tail$95861[ebp+eax*8]

; 3249 :              head[m] = bounding_box[m][m==k?1:a[m]];

	cmp	eax, esi
	jne	SHORT $LN188@draw_one_i
	mov	edx, 1
$LN188@draw_one_i:
	lea	edx, DWORD PTR [edx+eax*2]
	fld	QWORD PTR _bounding_box[edx*8]
	mov	edx, DWORD PTR _a$95860[ebp+eax*4+4]
	lea	edi, DWORD PTR [edx+eax*2]
	fstp	QWORD PTR _head$95862[ebp+eax*8]
	fld	QWORD PTR _bounding_box[edi*8+16]
	lea	edi, DWORD PTR [ecx-1]
	fstp	QWORD PTR _tail$95861[ebp+eax*8+8]
	cmp	edi, esi
	jne	SHORT $LN190@draw_one_i
	mov	edx, 1
$LN190@draw_one_i:
	lea	edx, DWORD PTR [edx+eax*2]
	fld	QWORD PTR _bounding_box[edx*8+16]
	mov	edx, DWORD PTR _a$95860[ebp+eax*4+8]
	fstp	QWORD PTR _head$95862[ebp+eax*8+8]
	lea	edi, DWORD PTR [edx+eax*2]
	fld	QWORD PTR _bounding_box[edi*8+32]
	fstp	QWORD PTR _tail$95861[ebp+eax*8+16]
	cmp	ecx, esi
	jne	SHORT $LN192@draw_one_i
	mov	edx, 1
$LN192@draw_one_i:
	lea	edx, DWORD PTR [edx+eax*2]
	fld	QWORD PTR _bounding_box[edx*8+32]
	mov	edx, DWORD PTR _a$95860[ebp+eax*4+12]
	lea	edi, DWORD PTR [edx+eax*2]
	fstp	QWORD PTR _head$95862[ebp+eax*8+16]
	fld	QWORD PTR _bounding_box[edi*8+48]
	lea	edi, DWORD PTR [ecx+1]
	fstp	QWORD PTR _tail$95861[ebp+eax*8+24]
	cmp	edi, esi
	jne	SHORT $LN194@draw_one_i
	mov	edx, 1
$LN194@draw_one_i:
	lea	edx, DWORD PTR [edx+eax*2]
	fld	QWORD PTR _bounding_box[edx*8+48]
	add	eax, 4
	fstp	QWORD PTR _head$95862[ebp+eax*8-8]
	add	ecx, 4
	cmp	eax, ebx
	jl	$LL196@draw_one_i
	mov	ebx, DWORD PTR __imp__glVertex3dv@4
	mov	edx, DWORD PTR _web+616
$LC187@draw_one_i:

; 3247 :          { for ( m = 0 ; m < SDIM ; m++ )

	cmp	eax, edx
	jge	SHORT $LN243@draw_one_i
	npad	8
$LC20@draw_one_i:

; 3248 :            { tail[m] = bounding_box[m][a[m]];

	mov	ecx, DWORD PTR _a$95860[ebp+eax*4]
	lea	edi, DWORD PTR [ecx+eax*2]
	fld	QWORD PTR _bounding_box[edi*8]
	fstp	QWORD PTR _tail$95861[ebp+eax*8]

; 3249 :              head[m] = bounding_box[m][m==k?1:a[m]];

	cmp	eax, esi
	jne	SHORT $LN116@draw_one_i
	mov	ecx, 1
$LN116@draw_one_i:
	lea	ecx, DWORD PTR [ecx+eax*2]
	fld	QWORD PTR _bounding_box[ecx*8]
	inc	eax
	fstp	QWORD PTR _head$95862[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC20@draw_one_i
$LN243@draw_one_i:

; 3250 :            }
; 3251 :            glBegin(GL_LINES);

	push	1
	call	DWORD PTR __imp__glBegin@4

; 3252 :              glVertex3dv(tail);

	lea	edx, DWORD PTR _tail$95861[ebp]
	push	edx
	call	ebx

; 3253 :              glVertex3dv(head);

	lea	eax, DWORD PTR _head$95862[ebp]
	push	eax
	call	ebx

; 3254 :            glEnd();

	call	DWORD PTR __imp__glEnd@0
	mov	edx, DWORD PTR _web+616
$LN23@draw_one_i:

; 3245 :        for ( k = 0 ; k < 2 ; k++ )

	inc	esi
	cmp	esi, 2
	jl	$LL248@draw_one_i

; 3244 :       for ( a[1] = 0 ; a[1] <= 1 ; a[1]++ )

	mov	eax, DWORD PTR _a$95860[ebp+4]
	inc	eax
	mov	DWORD PTR _a$95860[ebp+4], eax
	cmp	eax, 1
	jle	$LL247@draw_one_i

; 3243 :     { for ( a[0] = 0 ; a[0] <= 1 ; a[0]++ )

	mov	eax, DWORD PTR _a$95860[ebp]
	inc	eax
	mov	DWORD PTR _a$95860[ebp], eax
	cmp	eax, 1
	jle	$LL246@draw_one_i
	pop	edi
	pop	esi
	pop	ebx

; 3271 :         }
; 3272 :   } // end bounding box
; 3273 : 
; 3274 :   GL_ERROR_CHECK
; 3275 : } /* end draw_one_image() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@draw_one_i:

; 3255 :          }
; 3256 :     }
; 3257 :     else
; 3258 :     for ( a[0] = 0 ; a[0] <= 1 ; a[0]++ )

	mov	edi, DWORD PTR __imp__glVertex3dv@4
	npad	1
$LL16@draw_one_i:

; 3259 :      for ( a[1] = 0 ; a[1] <= 1 ; a[1]++ )

	mov	DWORD PTR _a$95860[ebp+4], 0
	npad	9
$LL249@draw_one_i:

; 3260 :       for ( a[2] = 0 ; a[2] <= 1 ; a[2]++ )

	mov	DWORD PTR _a$95860[ebp+8], 0
	npad	9
$LL250@draw_one_i:

; 3261 :        for ( k = 0 ; k < 3 ; k++ )

	xor	esi, esi
$LL251@draw_one_i:

; 3262 :         if ( a[k] == 0 )

	cmp	DWORD PTR _a$95860[ebp+esi*4], 0
	jne	$LN6@draw_one_i

; 3263 :         { for ( m = 0 ; m < SDIM ; m++ )

	xor	eax, eax
	cmp	edx, 4
	jl	$LN244@draw_one_i
	lea	ebx, DWORD PTR [edx-3]
	lea	ecx, DWORD PTR [eax+2]
	npad	2
$LL207@draw_one_i:

; 3264 :           { tail[m] = bounding_box[m][a[m]];

	mov	edx, DWORD PTR _a$95860[ebp+eax*4]
	lea	edi, DWORD PTR [edx+eax*2]
	fld	QWORD PTR _bounding_box[edi*8]
	fstp	QWORD PTR _tail$95861[ebp+eax*8]

; 3265 :             head[m] = bounding_box[m][m==k?1:a[m]];

	cmp	eax, esi
	jne	SHORT $LN199@draw_one_i
	mov	edx, 1
$LN199@draw_one_i:
	lea	edx, DWORD PTR [edx+eax*2]
	fld	QWORD PTR _bounding_box[edx*8]
	mov	edx, DWORD PTR _a$95860[ebp+eax*4+4]
	lea	edi, DWORD PTR [edx+eax*2]
	fstp	QWORD PTR _head$95862[ebp+eax*8]
	fld	QWORD PTR _bounding_box[edi*8+16]
	lea	edi, DWORD PTR [ecx-1]
	fstp	QWORD PTR _tail$95861[ebp+eax*8+8]
	cmp	edi, esi
	jne	SHORT $LN201@draw_one_i
	mov	edx, 1
$LN201@draw_one_i:
	lea	edx, DWORD PTR [edx+eax*2]
	fld	QWORD PTR _bounding_box[edx*8+16]
	mov	edx, DWORD PTR _a$95860[ebp+eax*4+8]
	fstp	QWORD PTR _head$95862[ebp+eax*8+8]
	lea	edi, DWORD PTR [edx+eax*2]
	fld	QWORD PTR _bounding_box[edi*8+32]
	fstp	QWORD PTR _tail$95861[ebp+eax*8+16]
	cmp	ecx, esi
	jne	SHORT $LN203@draw_one_i
	mov	edx, 1
$LN203@draw_one_i:
	lea	edx, DWORD PTR [edx+eax*2]
	fld	QWORD PTR _bounding_box[edx*8+32]
	mov	edx, DWORD PTR _a$95860[ebp+eax*4+12]
	lea	edi, DWORD PTR [edx+eax*2]
	fstp	QWORD PTR _head$95862[ebp+eax*8+16]
	fld	QWORD PTR _bounding_box[edi*8+48]
	lea	edi, DWORD PTR [ecx+1]
	fstp	QWORD PTR _tail$95861[ebp+eax*8+24]
	cmp	edi, esi
	jne	SHORT $LN205@draw_one_i
	mov	edx, 1
$LN205@draw_one_i:
	lea	edx, DWORD PTR [edx+eax*2]
	fld	QWORD PTR _bounding_box[edx*8+48]
	add	eax, 4
	fstp	QWORD PTR _head$95862[ebp+eax*8-8]
	add	ecx, 4
	cmp	eax, ebx
	jl	$LL207@draw_one_i
	mov	edx, DWORD PTR _web+616
	mov	edi, DWORD PTR __imp__glVertex3dv@4
$LN244@draw_one_i:

; 3263 :         { for ( m = 0 ; m < SDIM ; m++ )

	cmp	eax, edx
	jge	SHORT $LN245@draw_one_i
	npad	8
$LC3@draw_one_i:

; 3264 :           { tail[m] = bounding_box[m][a[m]];

	mov	ecx, DWORD PTR _a$95860[ebp+eax*4]
	lea	ebx, DWORD PTR [ecx+eax*2]
	fld	QWORD PTR _bounding_box[ebx*8]
	fstp	QWORD PTR _tail$95861[ebp+eax*8]

; 3265 :             head[m] = bounding_box[m][m==k?1:a[m]];

	cmp	eax, esi
	jne	SHORT $LN118@draw_one_i
	mov	ecx, 1
$LN118@draw_one_i:
	lea	ecx, DWORD PTR [ecx+eax*2]
	fld	QWORD PTR _bounding_box[ecx*8]
	inc	eax
	fstp	QWORD PTR _head$95862[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC3@draw_one_i
$LN245@draw_one_i:

; 3266 :           }
; 3267 :           glBegin(GL_LINES);

	push	1
	call	DWORD PTR __imp__glBegin@4

; 3268 :              glVertex3dv(tail);

	lea	edx, DWORD PTR _tail$95861[ebp]
	push	edx
	call	edi

; 3269 :              glVertex3dv(head);

	lea	eax, DWORD PTR _head$95862[ebp]
	push	eax
	call	edi

; 3270 :           glEnd();      

	call	DWORD PTR __imp__glEnd@0
	mov	edx, DWORD PTR _web+616
$LN6@draw_one_i:

; 3261 :        for ( k = 0 ; k < 3 ; k++ )

	inc	esi
	cmp	esi, 3
	jl	$LL251@draw_one_i

; 3260 :       for ( a[2] = 0 ; a[2] <= 1 ; a[2]++ )

	mov	eax, DWORD PTR _a$95860[ebp+8]
	inc	eax
	mov	DWORD PTR _a$95860[ebp+8], eax
	cmp	eax, 1
	jle	$LL250@draw_one_i

; 3259 :      for ( a[1] = 0 ; a[1] <= 1 ; a[1]++ )

	mov	eax, DWORD PTR _a$95860[ebp+4]
	inc	eax
	mov	DWORD PTR _a$95860[ebp+4], eax
	cmp	eax, 1
	jle	$LL249@draw_one_i

; 3255 :          }
; 3256 :     }
; 3257 :     else
; 3258 :     for ( a[0] = 0 ; a[0] <= 1 ; a[0]++ )

	mov	eax, DWORD PTR _a$95860[ebp]
	inc	eax
	mov	DWORD PTR _a$95860[ebp], eax
	cmp	eax, 1
	jle	$LL16@draw_one_i
$LN14@draw_one_i:

; 3271 :         }
; 3272 :   } // end bounding box
; 3273 : 
; 3274 :   GL_ERROR_CHECK
; 3275 : } /* end draw_one_image() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_draw_one_image ENDP
_TEXT	ENDS
PUBLIC	_idle_func
EXTRN	_catcher:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	_glutIdleFunc@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _idle_func
_TEXT	SEGMENT
_pHandles$96018 = -284					; size = 256
_mssg$ = -28						; size = 28
_idle_func PROC						; COMDAT

; 3719 : { struct graph_thread_data *td = GET_DATA;

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	esi
	call	_glutGetWindow@0
	mov	esi, eax
	imul	esi, 9896				; 000026a8H
	add	esi, OFFSET _gthread_data

; 3720 : #ifdef __L_EVOLVER__
; 3721 :    MSG mssg;	//Added by PSU.
; 3722 : #endif
; 3723 :   if ( close_flag ) 

	cmp	DWORD PTR _close_flag, 0
	je	SHORT $LN4@idle_func

; 3724 :      Ogl_close();

	call	_Ogl_close
$LN4@idle_func:

; 3725 : 
; 3726 :   td->idle_flag = 1;
; 3727 : #ifdef quickresize
; 3728 :   if ( td->resize_flag ) 
; 3729 :      glutPostRedisplay();
; 3730 :   td->resize_flag = 0;
; 3731 : #endif
; 3732 :   if ( draw_pid != main_pid ) /* can use signals */

	mov	eax, DWORD PTR _draw_pid
	mov	DWORD PTR [esi+1736], 1
	cmp	eax, DWORD PTR _main_pid
	je	SHORT $LN3@idle_func

; 3733 :     glutIdleFunc(NULL); 

	push	0
	call	_glutIdleFunc@4
	pop	esi

; 3759 :   #endif
; 3760 : #endif
; 3761 :   }
; 3762 : } // end idle_func()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@idle_func:

; 3734 :   /* else relying on idle_func to pick up redraw messages */
; 3735 :   else
; 3736 :   {
; 3737 : #if (defined(SUN) || defined(LINUX)) && !defined(__STRICT_ANSI__)
; 3738 :     /* let the thread could sleep .02 sec; need link with -lrt */
; 3739 :     struct timespec delay;
; 3740 :     delay.tv_sec = 0; delay.tv_nsec = 20000000;
; 3741 : #ifdef SUN
; 3742 :     __nanosleep(&delay,NULL); 
; 3743 : #else
; 3744 :     nanosleep(&delay,NULL); 
; 3745 : #endif
; 3746 : #endif
; 3747 : 
; 3748 : #ifdef WIN32
; 3749 :     /* sleep until some event */
; 3750 :     { HANDLE pHandles[MAXIMUM_WAIT_OBJECTS];
; 3751 :       MsgWaitForMultipleObjects(0,pHandles,FALSE,100,QS_ALLINPUT);

	push	1279					; 000004ffH
	push	100					; 00000064H
	push	0
	lea	ecx, DWORD PTR _pHandles$96018[ebp]
	push	ecx
	push	0
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20

; 3752 :     }
; 3753 :   #ifdef __L_EVOLVER__
; 3754 : 	//Following message sensor added by PSU. Note that per above, messages will be dealt with every 0.1 s.
; 3755 : 	memset(&mssg, 0, sizeof(MSG));
; 3756 : 
; 3757 : 	if(PeekMessage(&mssg, td->draw_hwnd, WM_USER, 0x7FFF, PM_REMOVE))

	mov	edx, DWORD PTR [esi+144]
	xor	eax, eax
	push	1
	push	32767					; 00007fffH
	push	1024					; 00000400H
	mov	DWORD PTR _mssg$[ebp], eax
	mov	DWORD PTR _mssg$[ebp+4], eax
	mov	DWORD PTR _mssg$[ebp+8], eax
	mov	DWORD PTR _mssg$[ebp+12], eax
	mov	DWORD PTR _mssg$[ebp+16], eax
	mov	DWORD PTR _mssg$[ebp+20], eax
	mov	DWORD PTR _mssg$[ebp+24], eax
	push	edx
	lea	eax, DWORD PTR _mssg$[ebp]
	push	eax
	call	DWORD PTR __imp__PeekMessageA@20
	test	eax, eax
	je	SHORT $LN1@idle_func

; 3758 : 		catcher(SIGINT);

	push	2
	call	_catcher
	add	esp, 4
$LN1@idle_func:
	pop	esi

; 3759 :   #endif
; 3760 : #endif
; 3761 :   }
; 3762 : } // end idle_func()

	mov	esp, ebp
	pop	ebp
	ret	0
_idle_func ENDP
_TEXT	ENDS
PUBLIC	_ecomp
; Function compile flags: /Ogtp
;	COMDAT _ecomp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_ecomp	PROC						; COMDAT

; 3830 : { struct graph_thread_data *td = GET_DATA;

	push	ebp
	mov	ebp, esp
	push	esi
	call	_glutGetWindow@0
	imul	eax, 9896				; 000026a8H

; 3831 :   int ai = td->indexarray[td->edgestart+*(int*)a]; 

	mov	edx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [edx]

; 3832 :   int bi = td->indexarray[td->edgestart+*(int*)b]; 

	mov	esi, DWORD PTR _b$[ebp]
	mov	esi, DWORD PTR [esi]
	add	eax, OFFSET _gthread_data
	mov	ecx, DWORD PTR [eax+9788]
	mov	eax, DWORD PTR [eax+9832]
	add	edx, ecx
	mov	edx, DWORD PTR [eax+edx*4]
	add	esi, ecx
	mov	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 3833 :   if ( ai < bi ) return -1;

	cmp	edx, eax
	jge	SHORT $LN2@ecomp
	or	eax, -1

; 3835 :   return 0;
; 3836 : } // end ecomp()

	pop	ebp
	ret	0
$LN2@ecomp:

; 3834 :   if ( bi < ai ) return 1;

	xor	ecx, ecx
	cmp	eax, edx
	setl	cl
	mov	eax, ecx

; 3835 :   return 0;
; 3836 : } // end ecomp()

	pop	ebp
	ret	0
_ecomp	ENDP
_TEXT	ENDS
PUBLIC	_fecomp
; Function compile flags: /Ogtp
;	COMDAT _fecomp
_TEXT	SEGMENT
_aa$ = 8						; size = 4
_bb$ = 12						; size = 4
_fecomp	PROC						; COMDAT

; 3843 : {

	push	ebp
	mov	ebp, esp

; 3844 :   struct festruct *a = (struct festruct *)aa;
; 3845 :   struct festruct *b = (struct festruct *)bb;
; 3846 :   if ( a->v[0] < b->v[0] ) return -1;

	mov	edx, DWORD PTR _aa$[ebp]
	mov	eax, DWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR _bb$[ebp]
	mov	ecx, DWORD PTR [esi]
	cmp	eax, ecx
	jge	SHORT $LN7@fecomp
$LN8@fecomp:
	or	eax, -1
	pop	esi

; 3850 :   return 0;
; 3851 : } // end fecomp()

	pop	ebp
	ret	0
$LN7@fecomp:

; 3847 :   if ( a->v[0] > b->v[0] ) return  1;

	jle	SHORT $LN3@fecomp
	mov	eax, 1
	pop	esi

; 3850 :   return 0;
; 3851 : } // end fecomp()

	pop	ebp
	ret	0
$LN3@fecomp:

; 3848 :   if ( a->v[1] < b->v[1] ) return -1;

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [esi+4]
	cmp	eax, ecx
	jl	SHORT $LN8@fecomp

; 3849 :   if ( a->v[1] > b->v[1] ) return  1;

	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	pop	esi
	mov	eax, edx

; 3850 :   return 0;
; 3851 : } // end fecomp()

	pop	ebp
	ret	0
_fecomp	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@ECDCEBIF@After?5stripping?3?5?$CFd?5edgestrips?0?5@ ; `string'
PUBLIC	??_C@_0M@CGDDLMBP@glutgraph?4c?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_make_strips
EXTRN	_outstring:PROC
EXTRN	_bsearch:PROC
EXTRN	_temp_free:PROC
EXTRN	_kb_temp_calloc:PROC
;	COMDAT ??_C@_0DA@ECDCEBIF@After?5stripping?3?5?$CFd?5edgestrips?0?5@
CONST	SEGMENT
??_C@_0DA@ECDCEBIF@After?5stripping?3?5?$CFd?5edgestrips?0?5@ DB 'After s'
	DB	'tripping: %d edgestrips, %d facetstrips', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CGDDLMBP@glutgraph?4c?$AA@
CONST	SEGMENT
??_C@_0M@CGDDLMBP@glutgraph?4c?$AA@ DB 'glutgraph.c', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _make_strips
_TEXT	SEGMENT
tv1313 = -124						; size = 4
_temp$96202 = -120					; size = 4
tv1314 = -116						; size = 4
tv1196 = -116						; size = 4
_temp$96225 = -112					; size = 4
_firstcount$96176 = -112				; size = 4
_way$ = -108						; size = 4
tv2212 = -104						; size = 4
_bestverts$ = -100					; size = 4
_temp$96138 = -100					; size = 4
tv1124 = -96						; size = 4
_whichway$96175 = -96					; size = 4
_fstripno$ = -92					; size = 4
_i$ = -88						; size = 4
tv1852 = -84						; size = 4
_bestfacets$ = -84					; size = 4
tv1715 = -80						; size = 4
_fe$96186 = -80						; size = 4
_m$96182 = -80						; size = 4
tv1850 = -76						; size = 4
_felist$ = -76						; size = 4
_stripnum$ = -72					; size = 4
tv1193 = -68						; size = 4
_edgeinx$ = -68						; size = 4
_bestlength$ = -64					; size = 4
_evlist$ = -64						; size = 4
tv1376 = -60						; size = 4
_vc$96174 = -60						; size = 4
_kk$ = -60						; size = 4
_estripno$ = -60					; size = 4
_trialstrip$ = -56					; size = 4
_nexte$96124 = -56					; size = 4
_vb$96173 = -52						; size = 4
_k$ = -52						; size = 4
_key$96207 = -48					; size = 16
_key$96187 = -32					; size = 16
_striplength$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_make_strips PROC					; COMDAT

; 3855 : { int *edgeinx; /* oriented edge numbers, sorted by first vertex */

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 3856 :   int *evlist;  /* vertex indexed list of offsets into edgeinx */
; 3857 :   int v;
; 3858 :   int i,k,kk;
; 3859 :   int *estripno; /* number of current strip */
; 3860 :   int *fstripno; /* number of current strip */
; 3861 :   int stripnum;
; 3862 :   int dataspot;
; 3863 :   struct festruct *felist;
; 3864 :   int striplength[3];  /* for testing 3 ways from each starting facet */
; 3865 :   int *trialstrip;  /* for unerasing markings */
; 3866 :   int bestlength;
; 3867 :   int *bestverts;
; 3868 :   int *bestfacets;
; 3869 :   int way;
; 3870 :   int bestway;
; 3871 :   struct graph_thread_data *td = GET_DATA;

	call	_glutGetWindow@0
	mov	esi, eax
	imul	esi, 9896				; 000026a8H
	add	esi, OFFSET _gthread_data

; 3872 : 
; 3873 :   /* strip arrays */
; 3874 :   if ( td->stripdata ) free((char*)td->stripdata);

	mov	eax, DWORD PTR [esi+9860]
	test	eax, eax
	je	SHORT $LN73@make_strip
	push	eax
	call	_free
	add	esp, 4
$LN73@make_strip:

; 3875 :   if ( td->striparray ) free((char*)td->striparray);

	mov	eax, DWORD PTR [esi+9844]
	test	eax, eax
	je	SHORT $LN72@make_strip
	push	eax
	call	_free
	add	esp, 4
$LN72@make_strip:

; 3876 :   td->stripdata = (int*)calloc(td->edgecount+td->facetcount+5,sizeof(int));

	mov	edi, DWORD PTR [esi+9800]
	mov	ebx, DWORD PTR [esi+9792]
	lea	eax, DWORD PTR [ebx+edi+5]
	push	4
	push	eax
	call	_calloc
	add	esp, 8
	mov	DWORD PTR [esi+9860], eax

; 3877 :   if ( td->stripdata == NULL )

	test	eax, eax
	jne	SHORT $LN71@make_strip

; 3878 :   { kb_error(5697,"Graphics too complicated for arrays.  Switching to non-array graphics.\n",
; 3879 :        WARNING);

	push	2
	push	OFFSET ??_C@_0EI@EHMFEGOO@Graphics?5too?5complicated?5for?5arr@
	push	5697					; 00001641H
	call	_kb_error

; 3880 :     td->arraysflag = 0;

	xor	eax, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+9772], eax

; 3881 :     td->doing_lazy = 0;

	mov	DWORD PTR [esi+9864], eax

; 3882 :     glutPostRedisplay();

	call	_glutPostRedisplay@0
	pop	edi
	pop	esi
	pop	ebx

; 4119 :   }
; 4120 : } // end make_strips()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@make_strip:

; 3883 :     return;
; 3884 :   }
; 3885 :   td->striparray = (struct stripstruct *)calloc(td->edgecount/2+td->facetcount/3 + 10,
; 3886 :                                          sizeof(struct stripstruct));

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, 1431655766				; 55555556H
	imul	edi
	sar	ecx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	ecx, edx
	lea	ecx, DWORD PTR [eax+ecx+10]
	push	12					; 0000000cH
	push	ecx
	call	_calloc

; 3887 :   if ( td->striparray == NULL )

	xor	edi, edi
	add	esp, 8
	mov	DWORD PTR [esi+9844], eax
	cmp	eax, edi
	jne	SHORT $LN70@make_strip

; 3888 :   { kb_error(5698,"Graphics too complicated for arrays.  Switching to non-array graphics.\n",
; 3889 :        WARNING);

	push	2
	push	OFFSET ??_C@_0EI@EHMFEGOO@Graphics?5too?5complicated?5for?5arr@
	push	5698					; 00001642H
	call	_kb_error

; 3890 :     td->arraysflag = 0;
; 3891 :     free(td->stripdata);

	mov	edx, DWORD PTR [esi+9860]
	push	edx
	mov	DWORD PTR [esi+9772], edi
	call	_free
	add	esp, 16					; 00000010H

; 3892 :     td->stripdata = NULL;

	mov	DWORD PTR [esi+9860], edi

; 3893 :     td->doing_lazy = 0;

	mov	DWORD PTR [esi+9864], edi

; 3894 :     glutPostRedisplay();

	call	_glutPostRedisplay@0
	pop	edi
	pop	esi
	pop	ebx

; 4119 :   }
; 4120 : } // end make_strips()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN70@make_strip:

; 3895 :     return;
; 3896 :   }
; 3897 : 
; 3898 :   
; 3899 :   dataspot = 0; stripnum = 0;
; 3900 : 
; 3901 :   /* edges */
; 3902 :   /* make list indexed by vertex */
; 3903 :   /* in einx, entry is 2*edgeindex+orientationbit */
; 3904 :   edgeinx = (int *)temp_calloc(td->edgecount,sizeof(int));

	push	3904					; 00000f40H
	push	OFFSET ??_C@_0M@CGDDLMBP@glutgraph?4c?$AA@
	push	4
	push	ebx
	mov	DWORD PTR _stripnum$[ebp], edi
	call	_kb_temp_calloc
	mov	ebx, eax

; 3905 :   for ( i = 0 ; i < td->edgecount ; i++ )

	xor	eax, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _edgeinx$[ebp], ebx
	cmp	DWORD PTR [esi+9792], eax
	jle	SHORT $LN67@make_strip
	npad	6
$LL69@make_strip:

; 3906 :   { edgeinx[i] = i;  } /* using bit for orientation */  

	mov	DWORD PTR [ebx+eax*4], eax
	inc	eax
	cmp	eax, DWORD PTR [esi+9792]
	jl	SHORT $LL69@make_strip
$LN67@make_strip:

; 3907 :   qsort((void*)edgeinx,td->edgecount,sizeof(int),FCAST ecomp);

	mov	eax, DWORD PTR [esi+9792]
	push	OFFSET _ecomp
	push	4
	push	eax
	push	ebx
	call	_qsort

; 3908 :   /* find where individual vertex segments start */
; 3909 :   evlist = (int *)temp_calloc(td->edgecount+10,sizeof(int));

	mov	ecx, DWORD PTR [esi+9792]
	push	3909					; 00000f45H
	push	OFFSET ??_C@_0M@CGDDLMBP@glutgraph?4c?$AA@
	add	ecx, 10					; 0000000aH
	push	4
	push	ecx
	call	_kb_temp_calloc

; 3910 :   for ( i = 0, v = 0 ; i < td->edgecount ; i++ )

	xor	ecx, ecx
	add	esp, 32					; 00000020H
	xor	edx, edx
	mov	DWORD PTR _evlist$[ebp], eax
	cmp	DWORD PTR [esi+9792], ecx
	jle	SHORT $LN64@make_strip

; 3907 :   qsort((void*)edgeinx,td->edgecount,sizeof(int),FCAST ecomp);

	mov	DWORD PTR tv1715[ebp], ebx
$LL66@make_strip:

; 3911 :   { while ( td->indexarray[td->edgestart+edgeinx[i]] > v ) evlist[++v] = i;

	mov	eax, DWORD PTR [ebx]
	add	eax, DWORD PTR [esi+9788]
	mov	ebx, DWORD PTR [esi+9832]
	cmp	DWORD PTR [ebx+eax*4], ecx
	jle	SHORT $LN65@make_strip
$LL63@make_strip:
	mov	eax, DWORD PTR _evlist$[ebp]
	mov	DWORD PTR [eax+ecx*4+4], edx
	mov	eax, DWORD PTR tv1715[ebp]
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR [esi+9788]
	mov	ebx, DWORD PTR [esi+9832]
	inc	ecx
	cmp	DWORD PTR [ebx+eax*4], ecx
	jg	SHORT $LL63@make_strip
$LN65@make_strip:

; 3910 :   for ( i = 0, v = 0 ; i < td->edgecount ; i++ )

	mov	ebx, DWORD PTR tv1715[ebp]
	inc	edx
	add	ebx, 4
	mov	DWORD PTR tv1715[ebp], ebx
	cmp	edx, DWORD PTR [esi+9792]
	jl	SHORT $LL66@make_strip
$LN64@make_strip:

; 3912 :   }
; 3913 :   evlist[++v] = i;  /* last sentinel */

	mov	eax, DWORD PTR _evlist$[ebp]

; 3914 : 
; 3915 :   /* now make strips.  start with some edge and just keep going. */
; 3916 :   estripno = (int*)temp_calloc(td->edgecount+5,sizeof(int));

	push	3916					; 00000f4cH
	mov	DWORD PTR [eax+ecx*4+4], edx
	mov	ecx, DWORD PTR [esi+9792]
	push	OFFSET ??_C@_0M@CGDDLMBP@glutgraph?4c?$AA@
	add	ecx, 5
	push	4
	push	ecx
	call	_kb_temp_calloc
	mov	ebx, eax

; 3917 :   for ( i = 0 ; i < td->edgecount/2 ; i++ )

	mov	eax, DWORD PTR [esi+9792]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esp, 16					; 00000010H
	mov	DWORD PTR _estripno$[ebp], ebx
	mov	DWORD PTR _i$[ebp], edi
	test	eax, eax
	jle	$LN59@make_strip

; 3918 :   { int nexte,headv;
; 3919 :     if ( estripno[i] ) continue;

	mov	DWORD PTR tv1850[ebp], edi

; 3958 : 
; 3959 :     stripnum++;

	mov	DWORD PTR tv1852[ebp], 1
	npad	3
$LL61@make_strip:

; 3918 :   { int nexte,headv;
; 3919 :     if ( estripno[i] ) continue;

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ebx+ecx*4], 0
	jne	$LN60@make_strip

; 3920 :     /* new strip */
; 3921 :     td->striparray[stripnum].mode = GL_LINE_STRIP;

	mov	edx, DWORD PTR [esi+9844]
	mov	eax, DWORD PTR tv1850[ebp]
	mov	DWORD PTR [eax+edx], 3

; 3922 :     td->striparray[stripnum].start = dataspot;

	mov	edx, DWORD PTR [esi+9844]
	mov	DWORD PTR [eax+edx+4], edi
	lea	eax, DWORD PTR [ecx+ecx]

; 3923 :     nexte = 2*i;

	mov	DWORD PTR _nexte$96124[ebp], eax
	jmp	SHORT $LN57@make_strip
	npad	1
$LL133@make_strip:
	mov	eax, DWORD PTR _nexte$96124[ebp]
$LN57@make_strip:

; 3924 :     for (;;)
; 3925 :     { 
; 3926 :       estripno[nexte>>1] = stripnum+1;

	mov	edx, DWORD PTR tv1852[ebp]
	mov	ecx, eax
	sar	ecx, 1
	mov	DWORD PTR [ebx+ecx*4], edx

; 3927 :       headv = td->indexarray[td->edgestart+(nexte^1)];

	mov	ecx, DWORD PTR [esi+9832]

; 3928 :       td->stripdata[dataspot++] = headv;

	mov	edx, DWORD PTR [esi+9860]
	xor	eax, 1
	add	eax, DWORD PTR [esi+9788]
	inc	edi
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+edi*4-4], ecx

; 3929 :       for ( k = evlist[headv] ; k < evlist[headv+1] ; k++ )

	mov	edx, DWORD PTR _evlist$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [edx+ecx*4+4]
	cmp	eax, ecx
	jge	SHORT $LN134@make_strip
$LL131@make_strip:

; 3930 :       { if ( estripno[edgeinx[k]>>1] == 0 )

	mov	edx, DWORD PTR _edgeinx$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	sar	edx, 1
	cmp	DWORD PTR [ebx+edx*4], 0
	je	SHORT $LN96@make_strip

; 3929 :       for ( k = evlist[headv] ; k < evlist[headv+1] ; k++ )

	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL131@make_strip

; 4048 :         if ( fe==NULL ) break;  /* done; maybe hit edge of surface */
; 4049 : 
; 4050 :         /*see if facet done yet */
; 4051 :         if ( fstripno[fe->f] != 0 ) break;  /* done in this direction */

	jmp	SHORT $LN124@make_strip
$LN96@make_strip:

; 3931 :         { nexte = edgeinx[k]; 

	mov	edx, DWORD PTR _edgeinx$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _nexte$96124[ebp], edx
$LN124@make_strip:

; 3932 :           break;
; 3933 :         }
; 3934 :       }
; 3935 :       if ( k == evlist[headv+1] ) break; /* end of strip */

	cmp	eax, ecx
$LN134@make_strip:
	jne	SHORT $LL133@make_strip

; 3936 :     }
; 3937 :     /* flip list around */
; 3938 :     for ( k = td->striparray[stripnum].start, kk = dataspot-1 ; k < kk ; k++,kk-- )

	mov	ecx, DWORD PTR tv1850[ebp]
	mov	eax, DWORD PTR [esi+9844]
	mov	eax, DWORD PTR [ecx+eax+4]
	lea	ecx, DWORD PTR [edi-1]
	cmp	eax, ecx
	jge	SHORT $LN125@make_strip
	npad	2
$LL50@make_strip:

; 3939 :       { int temp = td->stripdata[k]; td->stripdata[k] = td->stripdata[kk]; 

	mov	edx, DWORD PTR [esi+9860]
	mov	ebx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _temp$96138[ebp], ebx
	mov	ebx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [edx+eax*4], ebx

; 3940 :         td->stripdata[kk] = temp;

	mov	edx, DWORD PTR [esi+9860]
	mov	ebx, DWORD PTR _temp$96138[ebp]
	mov	DWORD PTR [edx+ecx*4], ebx
	inc	eax
	dec	ecx
	cmp	eax, ecx
	jl	SHORT $LL50@make_strip

; 3936 :     }
; 3937 :     /* flip list around */
; 3938 :     for ( k = td->striparray[stripnum].start, kk = dataspot-1 ; k < kk ; k++,kk-- )

	mov	ebx, DWORD PTR _estripno$[ebp]
$LN125@make_strip:

; 3917 :   for ( i = 0 ; i < td->edgecount/2 ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, eax
	inc	eax
	mov	DWORD PTR _nexte$96124[ebp], eax
	jmp	SHORT $LN47@make_strip
$LL126@make_strip:
	mov	eax, DWORD PTR _nexte$96124[ebp]
$LN47@make_strip:

; 3941 :       }
; 3942 :     /* now backwards */
; 3943 :     nexte = 2*i+1;
; 3944 :     for (;;)
; 3945 :     {
; 3946 :       estripno[nexte>>1] = stripnum+1; 

	mov	edx, DWORD PTR tv1852[ebp]
	mov	ecx, eax
	sar	ecx, 1
	mov	DWORD PTR [ebx+ecx*4], edx

; 3947 :       headv = td->indexarray[td->edgestart+(nexte^1)];

	mov	ecx, DWORD PTR [esi+9832]

; 3948 :       td->stripdata[dataspot++] = headv;

	mov	edx, DWORD PTR [esi+9860]
	xor	eax, 1
	add	eax, DWORD PTR [esi+9788]
	inc	edi
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+edi*4-4], ecx

; 3949 :       for ( k = evlist[headv] ; k < evlist[headv+1] ; k++ )

	mov	edx, DWORD PTR _evlist$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [edx+ecx*4+4]
	cmp	eax, ecx
	jge	SHORT $LN135@make_strip
	npad	6
$LL130@make_strip:

; 3950 :       { if ( estripno[edgeinx[k]>>1] == 0 )

	mov	edx, DWORD PTR _edgeinx$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	sar	edx, 1
	cmp	DWORD PTR [ebx+edx*4], 0
	je	SHORT $LN98@make_strip

; 3949 :       for ( k = evlist[headv] ; k < evlist[headv+1] ; k++ )

	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL130@make_strip

; 4048 :         if ( fe==NULL ) break;  /* done; maybe hit edge of surface */
; 4049 : 
; 4050 :         /*see if facet done yet */
; 4051 :         if ( fstripno[fe->f] != 0 ) break;  /* done in this direction */

	jmp	SHORT $LN127@make_strip
$LN98@make_strip:

; 3951 :         { nexte = edgeinx[k]; 

	mov	edx, DWORD PTR _edgeinx$[ebp]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _nexte$96124[ebp], edx
$LN127@make_strip:

; 3952 :           break;
; 3953 :         }
; 3954 :       }
; 3955 :       if ( k == evlist[headv+1] ) break; /* end of strip */

	cmp	eax, ecx
$LN135@make_strip:
	jne	SHORT $LL126@make_strip

; 3956 :     }
; 3957 :     td->striparray[stripnum].count = dataspot - td->striparray[stripnum].start;

	mov	ecx, DWORD PTR tv1850[ebp]
	mov	eax, DWORD PTR [esi+9844]
	mov	edx, edi
	sub	edx, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR [eax+ecx+8], edx

; 3958 : 
; 3959 :     stripnum++;

	mov	eax, 1
	add	DWORD PTR _stripnum$[ebp], eax
	add	DWORD PTR tv1852[ebp], eax
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR tv1850[ebp], ecx
$LN60@make_strip:

; 3917 :   for ( i = 0 ; i < td->edgecount/2 ; i++ )

	mov	eax, DWORD PTR [esi+9792]
	mov	ecx, DWORD PTR _i$[ebp]
	cdq
	sub	eax, edx
	inc	ecx
	sar	eax, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, eax
	jl	$LL61@make_strip
$LN59@make_strip:

; 3963 :   temp_free((char*)evlist);

	mov	ecx, DWORD PTR _evlist$[ebp]
	mov	eax, DWORD PTR _stripnum$[ebp]
	push	ecx
	mov	DWORD PTR [esi+9852], eax
	call	_temp_free

; 3964 :   temp_free((char*)estripno); 

	push	ebx
	call	_temp_free

; 3965 :   temp_free((char*)edgeinx); 

	mov	edx, DWORD PTR _edgeinx$[ebp]
	push	edx
	call	_temp_free

; 3966 : 
; 3967 :   /* facets */
; 3968 : 
; 3969 :   /* make list of edges with left-hand facets */
; 3970 :   felist = (struct festruct *)temp_calloc(td->facetcount,sizeof(struct festruct));

	mov	eax, DWORD PTR [esi+9800]
	push	3970					; 00000f82H
	push	OFFSET ??_C@_0M@CGDDLMBP@glutgraph?4c?$AA@
	push	16					; 00000010H
	push	eax
	call	_kb_temp_calloc

; 3971 :   for ( i = 0, k = 0 ; i < td->facetcount ; i += 3, k++ )

	xor	ecx, ecx
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _felist$[ebp], eax
	mov	DWORD PTR _k$[ebp], ecx
	cmp	DWORD PTR [esi+9800], ecx
	jle	$LN128@make_strip

; 3960 :   }
; 3961 : 
; 3962 :   td->estripcount = stripnum;

	add	eax, 8
	npad	13
$LL40@make_strip:

; 3972 :   { felist[i].v[0] = td->indexarray[td->facetstart+i];

	mov	edx, DWORD PTR [esi+9796]
	mov	ebx, DWORD PTR [esi+9832]
	add	edx, ecx
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [eax-8], edx

; 3973 :     felist[i].v[1] = td->indexarray[td->facetstart+i+1];

	mov	edx, DWORD PTR [esi+9796]
	mov	ebx, DWORD PTR [esi+9832]
	add	edx, ecx
	mov	edx, DWORD PTR [ebx+edx*4+4]
	mov	DWORD PTR [eax-4], edx

; 3974 :     felist[i].v[2] = td->indexarray[td->facetstart+i+2];

	mov	edx, DWORD PTR [esi+9796]
	mov	ebx, DWORD PTR [esi+9832]
	add	edx, ecx
	mov	edx, DWORD PTR [ebx+edx*4+8]
	mov	DWORD PTR [eax], edx

; 3975 :     felist[i].f = k;

	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [eax+4], edx

; 3976 :     felist[i+1].v[0] = td->indexarray[td->facetstart+i+1];

	mov	edx, DWORD PTR [esi+9796]
	mov	ebx, DWORD PTR [esi+9832]
	add	edx, ecx
	mov	edx, DWORD PTR [ebx+edx*4+4]
	mov	DWORD PTR [eax+8], edx

; 3977 :     felist[i+1].v[1] = td->indexarray[td->facetstart+i+2];

	mov	edx, DWORD PTR [esi+9796]
	mov	ebx, DWORD PTR [esi+9832]
	add	edx, ecx
	mov	edx, DWORD PTR [ebx+edx*4+8]
	mov	DWORD PTR [eax+12], edx

; 3978 :     felist[i+1].v[2] = td->indexarray[td->facetstart+i];

	mov	edx, DWORD PTR [esi+9796]
	mov	ebx, DWORD PTR [esi+9832]
	add	edx, ecx
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [eax+16], edx

; 3979 :     felist[i+1].f = k;

	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [eax+20], edx

; 3980 :     felist[i+2].v[0] = td->indexarray[td->facetstart+i+2];

	mov	edx, DWORD PTR [esi+9796]
	mov	ebx, DWORD PTR [esi+9832]
	add	edx, ecx
	mov	edx, DWORD PTR [ebx+edx*4+8]
	mov	DWORD PTR [eax+24], edx

; 3981 :     felist[i+2].v[1] = td->indexarray[td->facetstart+i];

	mov	edx, DWORD PTR [esi+9796]
	mov	ebx, DWORD PTR [esi+9832]
	add	edx, ecx
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [eax+28], edx

; 3982 :     felist[i+2].v[2] = td->indexarray[td->facetstart+i+1];

	mov	edx, DWORD PTR [esi+9796]
	mov	ebx, DWORD PTR [esi+9832]
	add	edx, ecx
	mov	edx, DWORD PTR [ebx+edx*4+4]
	mov	DWORD PTR [eax+32], edx

; 3983 :     felist[i+2].f = k;

	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [eax+36], edx
	add	ecx, 3
	inc	edx
	add	eax, 48					; 00000030H
	mov	DWORD PTR _k$[ebp], edx
	cmp	ecx, DWORD PTR [esi+9800]
	jl	$LL40@make_strip
$LN128@make_strip:

; 3984 :   }
; 3985 :   qsort((void*)felist,td->facetcount,sizeof(struct festruct),FCAST fecomp);

	mov	eax, DWORD PTR [esi+9800]
	mov	ecx, DWORD PTR _felist$[ebp]
	mov	ebx, DWORD PTR _stripnum$[ebp]
	push	OFFSET _fecomp
	push	16					; 00000010H
	push	eax
	push	ecx
	call	_qsort

; 3986 : 
; 3987 :   fstripno = (int *)temp_calloc(td->facetcount+5,sizeof(int));

	mov	edx, DWORD PTR [esi+9800]
	push	3987					; 00000f93H
	push	OFFSET ??_C@_0M@CGDDLMBP@glutgraph?4c?$AA@
	add	edx, 5
	push	4
	push	edx
	call	_kb_temp_calloc

; 3988 :   trialstrip = (int *)temp_calloc(td->facetcount+5,sizeof(int));

	push	3988					; 00000f94H
	mov	DWORD PTR _fstripno$[ebp], eax
	mov	eax, DWORD PTR [esi+9800]
	push	OFFSET ??_C@_0M@CGDDLMBP@glutgraph?4c?$AA@
	add	eax, 5
	push	4
	push	eax
	call	_kb_temp_calloc

; 3989 :   bestverts = (int *)temp_calloc(td->facetcount+5,sizeof(int));

	mov	ecx, DWORD PTR [esi+9800]
	push	3989					; 00000f95H
	push	OFFSET ??_C@_0M@CGDDLMBP@glutgraph?4c?$AA@
	add	ecx, 5
	push	4
	push	ecx
	mov	DWORD PTR _trialstrip$[ebp], eax
	call	_kb_temp_calloc

; 3990 :   bestfacets = (int *)temp_calloc(td->facetcount+5,sizeof(int));

	mov	edx, DWORD PTR [esi+9800]
	add	esp, 64					; 00000040H
	push	3990					; 00000f96H
	push	OFFSET ??_C@_0M@CGDDLMBP@glutgraph?4c?$AA@
	add	edx, 5
	push	4
	push	edx
	mov	DWORD PTR _bestverts$[ebp], eax
	call	_kb_temp_calloc
	mov	DWORD PTR _bestfacets$[ebp], eax

; 3991 : 
; 3992 :   /* now make strips.  start with some facet and just keep going. */
; 3993 :   for ( i = 0 ; i < td->facetcount/3 ; i++ )

	mov	eax, 1431655766				; 55555556H
	imul	DWORD PTR [esi+9800]
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	xor	ecx, ecx
	add	eax, edx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _i$[ebp], ecx
	test	eax, eax
	jle	$LN35@make_strip
$LL37@make_strip:

; 3994 :   { int nextf,va,vb,vc,whichway;
; 3995 :     int firstcount,secondcount; /* for checking orientation at start */
; 3996 :     if ( fstripno[i] ) continue;

	mov	eax, DWORD PTR _fstripno$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [eax+ecx*4], edx
	jne	$LN36@make_strip

; 3997 :     /* new strip */
; 3998 :     td->striparray[stripnum].mode = GL_TRIANGLE_STRIP;

	lea	eax, DWORD PTR [ebx+ebx*2]
	mov	ebx, DWORD PTR [esi+9844]
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR [eax+ebx], 5

; 3999 :     td->striparray[stripnum].start = dataspot;

	mov	ebx, DWORD PTR [esi+9844]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	mov	DWORD PTR tv1193[ebp], eax
	mov	DWORD PTR [ebx+eax+4], edi

; 4000 :     bestlength = 0;

	mov	DWORD PTR _bestlength$[ebp], edx

; 4001 :     for ( way = 0 ; way < 3 ; way++)

	mov	DWORD PTR _way$[ebp], edx
	mov	DWORD PTR tv2212[ebp], ecx
$LL33@make_strip:

; 4002 :     { int m = 0;  /* trialstrip index */
; 4003 :       dataspot = td->striparray[stripnum].start;

	mov	edx, DWORD PTR [esi+9844]
	mov	eax, DWORD PTR tv1193[ebp]
	mov	edi, DWORD PTR [edx+eax+4]

; 4004 :       nextf = 3*i;
; 4005 :       td->stripdata[dataspot++] = va = td->indexarray[td->facetstart+nextf+((1+way)%3)];

	mov	eax, DWORD PTR _way$[ebp]
	inc	eax
	mov	DWORD PTR tv1313[ebp], eax
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	eax, DWORD PTR [esi+9796]
	mov	ecx, DWORD PTR tv2212[ebp]
	xor	ebx, ebx

; 4006 :       td->stripdata[dataspot++] = vb = td->indexarray[td->facetstart+nextf+way];
; 4007 :       whichway = 1;

	mov	DWORD PTR _whichway$96175[ebp], 1
	add	eax, edx
	mov	DWORD PTR tv1314[ebp], edx
	mov	edx, DWORD PTR [esi+9832]
	add	eax, ecx
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [esi+9860]
	mov	DWORD PTR [edx+edi*4], eax
	mov	edx, DWORD PTR [esi+9796]
	add	edx, ecx
	add	edx, DWORD PTR _way$[ebp]
	mov	ecx, DWORD PTR [esi+9832]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [esi+9860]
	mov	DWORD PTR [edx+edi*4+4], ecx
	mov	DWORD PTR _vb$96173[ebp], ecx
	add	edi, 2
	npad	2
$LL30@make_strip:

; 4008 :       for (;;)
; 4009 :       { struct festruct *fe,key;
; 4010 :         /* find in felist */
; 4011 :         if ( whichway ) { key.v[0] = va; key.v[1] = vb; }

	cmp	DWORD PTR _whichway$96175[ebp], 0
	je	SHORT $LN28@make_strip
	mov	DWORD PTR _key$96187[ebp], eax
	mov	DWORD PTR _key$96187[ebp+4], ecx
	jmp	SHORT $LN27@make_strip
$LN28@make_strip:

; 4012 :         else { key.v[1] = va; key.v[0] = vb; }

	mov	DWORD PTR _key$96187[ebp+4], eax
	mov	DWORD PTR _key$96187[ebp], ecx
$LN27@make_strip:

; 4013 :         fe = (struct festruct *)bsearch(&key,(void*)felist,td->facetcount,
; 4014 :             sizeof(struct festruct), FCAST fecomp);

	mov	eax, DWORD PTR [esi+9800]
	mov	ecx, DWORD PTR _felist$[ebp]
	push	OFFSET _fecomp
	push	16					; 00000010H
	push	eax
	push	ecx
	lea	edx, DWORD PTR _key$96187[ebp]
	push	edx
	call	_bsearch
	add	esp, 20					; 00000014H
	mov	DWORD PTR _fe$96186[ebp], eax

; 4015 :         if ( fe==NULL ) break;  /* done; maybe hit edge of surface */

	test	eax, eax
	je	SHORT $LN123@make_strip

; 4016 :   
; 4017 :         /*see if facet done yet */
; 4018 :         if ( fstripno[fe->f] != 0 ) break;  /* done in this direction */

	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _fstripno$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $LN123@make_strip

; 4019 : 
; 4020 :         /*add opposite vertex */
; 4021 :         vc = fe->v[2];

	mov	ecx, DWORD PTR [eax+8]

; 4022 :         td->stripdata[dataspot++] = vc;                                 

	mov	edx, DWORD PTR [esi+9860]
	mov	DWORD PTR [edx+edi*4], ecx

; 4023 :         fstripno[fe->f] = stripnum+1;

	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _fstripno$[ebp]
	mov	DWORD PTR _vc$96174[ebp], ecx
	mov	ecx, DWORD PTR _stripnum$[ebp]
	inc	ecx
	mov	DWORD PTR [eax+edx*4], ecx

; 4024 :         trialstrip[m++] = fe->f;

	mov	ecx, DWORD PTR _fe$96186[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _trialstrip$[ebp]

; 4025 :   
; 4026 :         /* ready for next time around */
; 4027 :         va = vb;
; 4028 :         vb = vc;

	mov	ecx, DWORD PTR _vc$96174[ebp]
	mov	DWORD PTR [eax+ebx*4], edx
	mov	eax, DWORD PTR _vb$96173[ebp]

; 4029 :         whichway = !whichway;

	xor	edx, edx
	inc	edi
	inc	ebx
	cmp	DWORD PTR _whichway$96175[ebp], edx
	mov	DWORD PTR _vb$96173[ebp], ecx
	sete	dl
	mov	DWORD PTR _whichway$96175[ebp], edx

; 4030 :       }

	jmp	$LL30@make_strip
$LN123@make_strip:

; 4031 :       firstcount = dataspot - td->striparray[stripnum].start;

	mov	ecx, DWORD PTR tv1193[ebp]
	mov	eax, DWORD PTR [esi+9844]
	mov	eax, DWORD PTR [eax+ecx+4]
	mov	ecx, edi
	sub	ecx, eax
	mov	DWORD PTR _firstcount$96176[ebp], ecx

; 4032 :       /* flip list around */
; 4033 :       for ( k = td->striparray[stripnum].start, kk = dataspot-1 ; k < kk ; k++,kk-- )

	lea	ecx, DWORD PTR [edi-1]
	mov	DWORD PTR _m$96182[ebp], ebx
	mov	DWORD PTR _k$[ebp], eax
	mov	DWORD PTR _kk$[ebp], ecx
	cmp	eax, ecx
	jge	SHORT $LN117@make_strip
	npad	4
$LL24@make_strip:

; 4034 :       { int temp = td->stripdata[k]; td->stripdata[k] = td->stripdata[kk]; 

	mov	edx, DWORD PTR [esi+9860]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _temp$96202[ebp], edx
	mov	edx, DWORD PTR [esi+9860]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [edx+eax*4], ecx

; 4035 :         td->stripdata[kk] = temp;

	mov	ecx, DWORD PTR _kk$[ebp]
	mov	eax, DWORD PTR _temp$96202[ebp]
	mov	edx, DWORD PTR [esi+9860]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	dec	ecx
	mov	DWORD PTR _k$[ebp], eax
	mov	DWORD PTR _kk$[ebp], ecx
	cmp	eax, ecx
	jl	SHORT $LL24@make_strip
$LN117@make_strip:

; 4036 :       }
; 4037 :       /* now backwards */
; 4038 :       va = td->indexarray[td->facetstart+nextf+way];

	mov	eax, DWORD PTR [esi+9796]
	mov	edx, DWORD PTR tv2212[ebp]
	mov	ecx, DWORD PTR [esi+9832]
	add	edx, eax
	add	edx, DWORD PTR _way$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]

; 4039 :       vb = td->indexarray[td->facetstart+nextf+((way+1)%3)];

	mov	ecx, DWORD PTR tv1314[ebp]
	add	ecx, eax
	add	ecx, DWORD PTR tv2212[ebp]
	mov	eax, DWORD PTR [esi+9832]
	mov	eax, DWORD PTR [eax+ecx*4]

; 4040 :       whichway = 1;

	mov	ecx, 1
$LN136@make_strip:
	mov	DWORD PTR _whichway$96175[ebp], ecx
	mov	DWORD PTR _vb$96173[ebp], eax

; 4041 :       for (;;)
; 4042 :       { struct festruct *fe,key;
; 4043 :         /*find in felist */
; 4044 :         if ( whichway ) { key.v[0] = va; key.v[1] = vb; }

	test	ecx, ecx
	je	SHORT $LN19@make_strip
	mov	DWORD PTR _key$96207[ebp], edx
	mov	DWORD PTR _key$96207[ebp+4], eax
	jmp	SHORT $LN18@make_strip
$LN19@make_strip:

; 4045 :         else { key.v[1] = va; key.v[0] = vb; }

	mov	DWORD PTR _key$96207[ebp+4], edx
	mov	DWORD PTR _key$96207[ebp], eax
$LN18@make_strip:

; 4046 :         fe = (struct festruct*)bsearch(&key,(void*)felist,td->facetcount,
; 4047 :           sizeof(struct festruct), FCAST fecomp);

	mov	edx, DWORD PTR [esi+9800]
	mov	eax, DWORD PTR _felist$[ebp]
	push	OFFSET _fecomp
	push	16					; 00000010H
	push	edx
	push	eax
	lea	ecx, DWORD PTR _key$96207[ebp]
	push	ecx
	call	_bsearch

; 4048 :         if ( fe==NULL ) break;  /* done; maybe hit edge of surface */
; 4049 : 
; 4050 :         /*see if facet done yet */
; 4051 :         if ( fstripno[fe->f] != 0 ) break;  /* done in this direction */

	mov	edx, DWORD PTR _fstripno$[ebp]
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN102@make_strip
	mov	ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $LN102@make_strip

; 4052 : 
; 4053 :         /*add opposite vertex */
; 4054 :         vc = fe->v[2];

	mov	ecx, DWORD PTR [eax+8]

; 4055 :         td->stripdata[dataspot++] = vc;

	mov	ebx, DWORD PTR [esi+9860]
	mov	DWORD PTR [ebx+edi*4], ecx

; 4056 :         fstripno[fe->f] = stripnum+1;

	mov	ebx, DWORD PTR [eax+12]
	mov	DWORD PTR _vc$96174[ebp], ecx
	mov	ecx, DWORD PTR _stripnum$[ebp]
	inc	ecx
	mov	DWORD PTR [edx+ebx*4], ecx

; 4057 :         trialstrip[m++] = fe->f;

	mov	edx, DWORD PTR [eax+12]
	mov	ebx, DWORD PTR _m$96182[ebp]
	mov	eax, DWORD PTR _trialstrip$[ebp]
	mov	DWORD PTR [eax+ebx*4], edx

; 4058 :         /* ready for next time around */
; 4059 :         va = vb;

	mov	edx, DWORD PTR _vb$96173[ebp]

; 4060 :         vb = vc;

	mov	eax, DWORD PTR _vc$96174[ebp]

; 4061 :         whichway = !whichway;

	xor	ecx, ecx
	inc	ebx
	inc	edi
	cmp	DWORD PTR _whichway$96175[ebp], ecx
	mov	DWORD PTR _m$96182[ebp], ebx
	sete	cl

; 4062 :       }

	jmp	SHORT $LN136@make_strip
$LN102@make_strip:

; 4063 :       striplength[way] = dataspot - td->striparray[stripnum].start;

	mov	ecx, DWORD PTR [esi+9844]
	mov	eax, DWORD PTR tv1193[ebp]
	sub	edi, DWORD PTR [ecx+eax+4]
	lea	eax, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR tv1196[ebp], eax
	mov	eax, DWORD PTR _way$[ebp]
	lea	eax, DWORD PTR _striplength$[ebp+eax*4]
	mov	DWORD PTR tv1376[ebp], eax
	mov	DWORD PTR [eax], edi

; 4065 : 
; 4066 :       /* check orientation at start */
; 4067 :       if ( firstcount & 1 )

	mov	eax, DWORD PTR _firstcount$96176[ebp]
	test	al, 1
	je	SHORT $LN121@make_strip

; 4064 :       secondcount = striplength[way] - firstcount;

	mov	ecx, edi
	sub	ecx, eax

; 4068 :       { if ( secondcount & 1 ) 

	test	cl, 1
	je	SHORT $LN119@make_strip

; 4069 :         { striplength[way]--;  /* omit last, if necessary */

	mov	eax, DWORD PTR tv1376[ebp]

; 4070 :           if ( i == trialstrip[m-1] ) i--;  /* so loop doesn't skip omitted facet */

	mov	ecx, DWORD PTR _trialstrip$[ebp]
	dec	edi
	mov	DWORD PTR [eax], edi
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [ecx+ebx*4-4]
	jne	SHORT $LN119@make_strip
	dec	DWORD PTR _i$[ebp]
	sub	DWORD PTR tv2212[ebp], 3
$LN119@make_strip:

; 4071 :         }
; 4072 :         /* flip order */
; 4073 :         for ( k = td->striparray[stripnum].start, 
; 4074 :             kk = td->striparray[stripnum].start+striplength[way]-1 ; k < kk ; k++,kk-- )

	mov	ecx, DWORD PTR tv1196[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1376[ebp]
	mov	ecx, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+ecx-1]
	cmp	eax, ecx
	jge	SHORT $LN121@make_strip
	npad	2
$LL12@make_strip:

; 4075 :         { int temp = td->stripdata[k]; td->stripdata[k] = td->stripdata[kk]; 

	mov	edx, DWORD PTR [esi+9860]
	mov	edi, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _temp$96225[ebp], edi
	mov	edi, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [edx+eax*4], edi

; 4076 :           td->stripdata[kk] = temp;

	mov	edx, DWORD PTR [esi+9860]
	mov	edi, DWORD PTR _temp$96225[ebp]
	mov	DWORD PTR [edx+ecx*4], edi
	inc	eax
	dec	ecx
	cmp	eax, ecx
	jl	SHORT $LL12@make_strip

; 4071 :         }
; 4072 :         /* flip order */
; 4073 :         for ( k = td->striparray[stripnum].start, 
; 4074 :             kk = td->striparray[stripnum].start+striplength[way]-1 ; k < kk ; k++,kk-- )

	mov	edx, DWORD PTR _fstripno$[ebp]
$LN121@make_strip:

; 4077 :         }
; 4078 :       }
; 4079 : 
; 4080 :       if ( striplength[way] > bestlength )

	mov	eax, DWORD PTR tv1376[ebp]
	mov	edi, DWORD PTR [eax]
	cmp	edi, DWORD PTR _bestlength$[ebp]
	jle	SHORT $LN9@make_strip

; 4081 :       { bestlength = striplength[way];
; 4082 :         bestway = way;
; 4083 :         memcpy(bestverts,td->stripdata+td->striparray[stripnum].start,bestlength*sizeof(int));

	mov	edx, DWORD PTR [esi+9844]
	mov	eax, DWORD PTR tv1193[ebp]
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	mov	ecx, DWORD PTR [edx+eax+4]
	mov	edx, DWORD PTR [esi+9860]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _bestverts$[ebp]
	push	eax
	push	ecx
	mov	DWORD PTR _bestlength$[ebp], edi
	call	_memcpy

; 4084 :         memcpy(bestfacets,trialstrip,(bestlength-2)*sizeof(int));

	mov	eax, DWORD PTR _trialstrip$[ebp]
	mov	ecx, DWORD PTR _bestfacets$[ebp]
	lea	edx, DWORD PTR [edi*4-8]
	push	edx
	push	eax
	push	ecx
	call	_memcpy
	mov	edx, DWORD PTR _fstripno$[ebp]
	add	esp, 24					; 00000018H
$LN9@make_strip:

; 4085 :       }
; 4086 :       for ( k = 0 ; k < m ; k++ )  /* unmark */

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN32@make_strip
	npad	3
$LL8@make_strip:

; 4087 :         fstripno[trialstrip[k]] = 0;

	mov	ecx, DWORD PTR _trialstrip$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	inc	eax
	mov	DWORD PTR [edx+ecx*4], 0
	cmp	eax, ebx
	jl	SHORT $LL8@make_strip
$LN32@make_strip:

; 4001 :     for ( way = 0 ; way < 3 ; way++)

	mov	eax, DWORD PTR tv1313[ebp]
	mov	DWORD PTR _way$[ebp], eax
	cmp	eax, 3
	jl	$LL33@make_strip

; 4088 :     }  /* end ways */
; 4089 : 
; 4090 :     memcpy(td->stripdata+td->striparray[stripnum].start,bestverts,bestlength*sizeof(int));

	mov	ebx, DWORD PTR _bestlength$[ebp]
	mov	eax, DWORD PTR _bestverts$[ebp]
	mov	ecx, DWORD PTR [esi+9844]
	mov	edi, DWORD PTR tv1193[ebp]
	lea	edx, DWORD PTR [ebx*4]
	push	edx
	mov	edx, DWORD PTR [ecx+edi+4]
	push	eax
	mov	eax, DWORD PTR [esi+9860]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_memcpy

; 4091 :     for ( k = 0 ; k < bestlength-2 ; k++ )  /* remark */

	lea	eax, DWORD PTR [ebx-2]
	mov	ebx, DWORD PTR _stripnum$[ebp]
	add	esp, 12					; 0000000cH
	xor	ecx, ecx
	test	eax, eax
	jle	$LN3@make_strip
	npad	1
$LL5@make_strip:

; 4092 :     { fstripno[bestfacets[k]] = stripnum+1;

	mov	edx, DWORD PTR _bestfacets$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	edi, DWORD PTR _fstripno$[ebp]
	lea	eax, DWORD PTR [ebx+1]
	mov	DWORD PTR [edi+edx*4], eax

; 4093 :       if ( td->strip_color_flag && (bestfacets[k] < web.skel[FACET].maxcount) ) 

	cmp	DWORD PTR [esi+9840], 0
	je	SHORT $LN4@make_strip
	mov	edi, DWORD PTR _bestfacets$[ebp]
	mov	eax, DWORD PTR [edi+ecx*4]
	cmp	eax, DWORD PTR _web+244
	jge	SHORT $LN4@make_strip

; 4094 :         set_facet_color(bestfacets[k],(stripnum % 14) + 1);

	mov	eax, -1840700269			; 92492493H
	imul	ebx
	add	edx, ebx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	add	edx, edx
	mov	eax, ebx
	sub	eax, edx
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR _web+236
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	inc	eax
	mov	WORD PTR [edx+50], ax
	mov	edx, DWORD PTR _bestfacets$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	edi, DWORD PTR _web+236
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	WORD PTR [edx+48], ax
$LN4@make_strip:

; 4091 :     for ( k = 0 ; k < bestlength-2 ; k++ )  /* remark */

	mov	eax, DWORD PTR _bestlength$[ebp]
	inc	ecx
	add	eax, -2					; fffffffeH
	cmp	ecx, eax
	jl	$LL5@make_strip
	mov	edi, DWORD PTR tv1193[ebp]
$LN3@make_strip:

; 4095 :     }
; 4096 : 
; 4097 :     td->striparray[stripnum].count = bestlength;

	mov	ecx, DWORD PTR _bestlength$[ebp]
	mov	eax, DWORD PTR [esi+9844]
	mov	DWORD PTR [eax+edi+8], ecx

; 4098 :     dataspot = td->striparray[stripnum].start + bestlength;

	mov	edx, DWORD PTR [esi+9844]
	mov	edi, DWORD PTR [edx+edi+4]
	add	edi, ecx

; 4099 : 
; 4100 :     stripnum++;

	mov	ecx, DWORD PTR _i$[ebp]
	inc	ebx
	mov	DWORD PTR _stripnum$[ebp], ebx
$LN36@make_strip:

; 3991 : 
; 3992 :   /* now make strips.  start with some facet and just keep going. */
; 3993 :   for ( i = 0 ; i < td->facetcount/3 ; i++ )

	mov	eax, 1431655766				; 55555556H
	imul	DWORD PTR [esi+9800]
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ecx
	add	eax, edx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, eax
	jl	$LL37@make_strip
$LN35@make_strip:

; 4101 :   }
; 4102 : 
; 4103 :   temp_free((char*)fstripno); 

	mov	ecx, DWORD PTR _fstripno$[ebp]
	push	ecx
	call	_temp_free

; 4104 :   temp_free((char*)felist); 

	mov	edx, DWORD PTR _felist$[ebp]
	push	edx
	call	_temp_free

; 4105 :   temp_free((char*)trialstrip); 

	mov	eax, DWORD PTR _trialstrip$[ebp]
	push	eax
	call	_temp_free

; 4106 :   temp_free((char*)bestverts); 

	mov	ecx, DWORD PTR _bestverts$[ebp]
	push	ecx
	call	_temp_free

; 4107 :   temp_free((char*)bestfacets); 

	mov	edx, DWORD PTR _bestfacets$[ebp]
	push	edx
	call	_temp_free

; 4108 : 
; 4109 :   td->stripcount = stripnum;
; 4110 :   td->fstripcount = td->stripcount - td->estripcount;
; 4111 :   /* cut down arrays to needed size */
; 4112 :   td->stripdata = (int*)realloc((char*)td->stripdata,dataspot*sizeof(int));

	mov	ecx, DWORD PTR [esi+9860]
	lea	eax, DWORD PTR [edi*4]
	mov	DWORD PTR [esi+9848], ebx
	sub	ebx, DWORD PTR [esi+9852]
	push	eax
	push	ecx
	mov	DWORD PTR [esi+9856], ebx
	call	_realloc
	mov	DWORD PTR [esi+9860], eax

; 4113 :   td->striparray = (struct stripstruct *)realloc((char*)td->striparray,
; 4114 :                      td->stripcount*sizeof(struct stripstruct));

	mov	eax, DWORD PTR [esi+9848]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+9844]
	add	edx, edx
	add	edx, edx
	push	edx
	push	eax
	call	_realloc
	add	esp, 36					; 00000024H

; 4115 :   if ( td->q_flag )

	cmp	DWORD PTR [esi+9868], 0
	mov	DWORD PTR [esi+9844], eax
	je	SHORT $LN1@make_strip

; 4116 :   { sprintf(msg,"After stripping: %d edgestrips, %d facetstrips\n",
; 4117 :               td->estripcount,td->fstripcount);

	mov	ecx, DWORD PTR [esi+9856]
	mov	edx, DWORD PTR [esi+9852]
	mov	eax, DWORD PTR _msg
	push	ecx
	push	edx
	push	OFFSET ??_C@_0DA@ECDCEBIF@After?5stripping?3?5?$CFd?5edgestrips?0?5@
	push	eax
	call	_sprintf

; 4118 :     outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 20					; 00000014H
$LN1@make_strip:

; 4119 :   }
; 4120 : } // end make_strips()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_make_strips ENDP
_TEXT	ENDS
PUBLIC	__real@3ec92a737110e454
PUBLIC	__real@40f86a0000000000
PUBLIC	_hashfunc
;	COMDAT __real@3ec92a737110e454
CONST	SEGMENT
__real@3ec92a737110e454 DQ 03ec92a737110e454r	; 3e-006
CONST	ENDS
;	COMDAT __real@40f86a0000000000
CONST	SEGMENT
__real@40f86a0000000000 DQ 040f86a0000000000r	; 100000
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _hashfunc
_TEXT	SEGMENT
_a$ = 8							; size = 4
_hashfunc PROC						; COMDAT

; 4130 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 4131 :   int h;
; 4132 :   int scale = 100000;
; 4133 :   double eps = 3.e-6;  /* to prevent coincidences */
; 4134 :   h = 15187*(int)(scale*a->x[0]+eps);
; 4135 :   h += 4021*(int)(scale*a->x[1]+eps);
; 4136 :   h += 2437*(int)(scale*a->x[2]+eps);
; 4137 :   h += 7043*(int)(scale*a->n[0]+eps);
; 4138 :   h += 5119*(int)(scale*a->n[1]+eps);
; 4139 :   h += 8597*(int)(scale*a->n[2]+eps);
; 4140 :   h += 1741*(int)(scale*a->c[0]+eps);
; 4141 :   h += 4937*(int)(scale*a->c[1]+eps);
; 4142 :   h += 1223*(int)(scale*a->c[2]+eps);
; 4143 :   h = h % hashsize;

	mov	esi, DWORD PTR _a$[ebp]
	fld	DWORD PTR [esi+28]
	push	edi
	fld	QWORD PTR __real@40f86a0000000000
	fmul	ST(1), ST(0)
	fld	QWORD PTR __real@3ec92a737110e454
	fadd	ST(2), ST(0)
	fxch	ST(2)
	call	__ftol2_sse
	fld	DWORD PTR [esi+24]
	fmul	ST(0), ST(1)
	mov	edi, eax
	imul	edi, 15187				; 00003b53H
	fadd	ST(0), ST(2)
	call	__ftol2_sse
	imul	eax, 8597				; 00002195H
	fld	DWORD PTR [esi+16]
	fmul	ST(0), ST(1)
	fadd	ST(0), ST(2)
	add	edi, eax
	call	__ftol2_sse
	imul	eax, 7043				; 00001b83H
	fld	DWORD PTR [esi+20]
	fmul	ST(0), ST(1)
	fadd	ST(0), ST(2)
	add	edi, eax
	call	__ftol2_sse
	imul	eax, 5119				; 000013ffH
	fld	DWORD PTR [esi+4]
	fmul	ST(0), ST(1)
	fadd	ST(0), ST(2)
	add	edi, eax
	call	__ftol2_sse
	imul	eax, 4937				; 00001349H
	fld	DWORD PTR [esi+32]
	fmul	ST(0), ST(1)
	fadd	ST(0), ST(2)
	add	edi, eax
	call	__ftol2_sse
	imul	eax, 4021				; 00000fb5H
	fld	DWORD PTR [esi+36]
	fmul	ST(0), ST(1)
	fadd	ST(0), ST(2)
	add	edi, eax
	call	__ftol2_sse
	imul	eax, 2437				; 00000985H
	fld	DWORD PTR [esi+8]
	fmul	ST(0), ST(1)
	fadd	ST(0), ST(2)
	add	edi, eax
	call	__ftol2_sse
	imul	eax, 1223				; 000004c7H
	fmul	DWORD PTR [esi]
	faddp	ST(1), ST(0)
	add	edi, eax
	call	__ftol2_sse
	imul	eax, 1741				; 000006cdH
	mov	ecx, DWORD PTR _hashsize
	add	eax, edi
	cdq
	idiv	ecx
	pop	edi
	pop	esi
	mov	eax, edx

; 4144 :   if ( h < 0 ) h += hashsize;

	test	eax, eax
	jns	SHORT $LN1@hashfunc
	add	eax, ecx
$LN1@hashfunc:

; 4145 :   return h;
; 4146 : } // end hashfunc()

	pop	ebp
	ret	0
_hashfunc ENDP
_TEXT	ENDS
PUBLIC	__real@3ee4f8b588e368f1
PUBLIC	__$ArrayPad$
PUBLIC	_make_indexlists
;	COMDAT __real@3ee4f8b588e368f1
CONST	SEGMENT
__real@3ee4f8b588e368f1 DQ 03ee4f8b588e368f1r	; 1e-005
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _make_indexlists
_TEXT	SEGMENT
tv574 = -100						; size = 4
tv568 = -96						; size = 4
tv483 = -92						; size = 4
_rawcount$ = -92					; size = 4
tv570 = -88						; size = 4
_j$ = -84						; size = 4
tv95 = -80						; size = 4
_i$ = -80						; size = 4
_h$96292 = -76						; size = 4
_hashlist$ = -72					; size = 4
_mat$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_make_indexlists PROC					; COMDAT

; 4157 : { struct graph_thread_data *td = GET_DATA;

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	call	_glutGetWindow@0
	mov	ebx, eax
	imul	ebx, 9896				; 000026a8H
	add	ebx, OFFSET _gthread_data

; 4158 :   int i,j;
; 4159 :   int rawcount = td->edgecount+td->facetcount;  /* number of unsorted vertices */

	mov	edi, DWORD PTR [ebx+9800]
	add	edi, DWORD PTR [ebx+9792]

; 4160 :   struct vercol **hashlist;
; 4161 :   float mat[4][4];
; 4162 : 
; 4163 :   /* get reasonable epsilon for identifying vertices */
; 4164 :   glGetFloatv(GL_MODELVIEW_MATRIX,mat[0]);

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	push	2982					; 00000ba6H
	mov	DWORD PTR _rawcount$[ebp], edi
	call	DWORD PTR __imp__glGetFloatv@8

; 4165 :   gleps = 1e-5/sqrt(mat[0][0]*mat[0][0]+mat[0][1]*mat[0][1]
; 4166 :                        +mat[0][2]*mat[0][2]);

	fld	DWORD PTR _mat$[ebp+4]
	fld	DWORD PTR _mat$[ebp]
	fld	DWORD PTR _mat$[ebp+8]
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fld	ST(2)
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fdivr	QWORD PTR __real@3ee4f8b588e368f1

; 4167 :   
; 4168 :   /* Uniquify using hash table */
; 4169 :   /* qsort here is a time hog */
; 4170 :   if ( td->indexarray ) free((char*)td->indexarray);

	mov	eax, DWORD PTR [ebx+9832]
	xor	esi, esi
	fstp	QWORD PTR _gleps
	cmp	eax, esi
	je	SHORT $LN21@make_index
	push	eax
	call	_free
	add	esp, 4
$LN21@make_index:

; 4171 :   td->indexarray = (int*)calloc(rawcount+10,sizeof(int));

	lea	ecx, DWORD PTR [edi+10]
	push	4
	push	ecx
	call	_calloc
	add	esp, 8
	mov	DWORD PTR tv95[ebp], eax
	mov	DWORD PTR [ebx+9832], eax

; 4172 :   if ( td->indexarray == NULL )

	cmp	eax, esi
	jne	SHORT $LN20@make_index

; 4173 :   { kb_error(5699,"Graphics too complicated for arrays.  Switching to non-array graphics.\n",
; 4174 :        WARNING);

	push	2
	push	OFFSET ??_C@_0EI@EHMFEGOO@Graphics?5too?5complicated?5for?5arr@
	push	5699					; 00001643H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 4175 :     td->arraysflag = 0;

	mov	DWORD PTR [ebx+9772], esi

; 4176 :     td->doing_lazy = 0;

	mov	DWORD PTR [ebx+9864], esi

; 4177 :     glutPostRedisplay();

	call	_glutPostRedisplay@0
	pop	edi
	pop	esi
	pop	ebx

; 4234 : 
; 4235 : } /* end make_indexlists() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@make_index:

; 4178 :     return;
; 4179 :   }
; 4180 : 
; 4181 :   if ( !td->fullarray ) return;

	cmp	DWORD PTR [ebx+9776], esi
	je	$LN1@make_index

; 4182 :   hashsize = 2*rawcount + 10;

	lea	eax, DWORD PTR [edi+edi+10]

; 4183 :   hashlist = (struct vercol**)calloc(hashsize,sizeof(struct vercol *));

	push	4
	push	eax
	mov	DWORD PTR _hashsize, eax
	call	_calloc
	mov	esi, eax
	add	esp, 8
	mov	DWORD PTR _hashlist$[ebp], esi

; 4184 :   if ( hashlist == NULL )

	test	esi, esi
	jne	SHORT $LN18@make_index

; 4185 :   { kb_error(5700,"Graphics too complicated for arrays.  Switching to non-array graphics.\n",
; 4186 :        WARNING);

	push	2
	push	OFFSET ??_C@_0EI@EHMFEGOO@Graphics?5too?5complicated?5for?5arr@
	push	5700					; 00001644H
	call	_kb_error

; 4187 :     td->arraysflag = 0;
; 4188 :     free(td->indexarray);

	mov	edx, DWORD PTR [ebx+9832]
	push	edx
	mov	DWORD PTR [ebx+9772], esi
	call	_free
	add	esp, 16					; 00000010H

; 4189 :     td->indexarray = NULL;

	mov	DWORD PTR [ebx+9832], esi

; 4190 :     td->doing_lazy = 0;

	mov	DWORD PTR [ebx+9864], esi

; 4191 :     glutPostRedisplay();

	call	_glutPostRedisplay@0
	pop	edi
	pop	esi
	pop	ebx

; 4234 : 
; 4235 : } /* end make_indexlists() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@make_index:

; 4192 :     return;
; 4193 :   }
; 4194 : 
; 4195 :   hashlist[hashfunc(td->fullarray)] = td->fullarray;

	mov	eax, DWORD PTR [ebx+9776]
	push	eax
	call	_hashfunc
	mov	ecx, DWORD PTR [ebx+9776]
	mov	DWORD PTR [esi+eax*4], ecx

; 4196 :   td->indexarray[0] = 0;

	mov	eax, DWORD PTR tv95[ebp]
	mov	DWORD PTR [eax], 0

; 4197 :   for ( i = 1, j = 1 ; i < rawcount ; i++ )

	mov	eax, 1
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	edi, eax
	jle	$LN15@make_index

; 4192 :     return;
; 4193 :   }
; 4194 : 
; 4195 :   hashlist[hashfunc(td->fullarray)] = td->fullarray;

	mov	eax, 44					; 0000002cH
	mov	DWORD PTR tv568[ebp], eax
	mov	DWORD PTR tv570[ebp], eax
$LL31@make_index:

; 4198 :   { int h = hashfunc(td->fullarray+i);

	mov	esi, DWORD PTR [ebx+9776]
	mov	eax, DWORD PTR tv570[ebp]
	add	eax, esi
	push	eax
	mov	DWORD PTR tv574[ebp], eax
	call	_hashfunc

; 4199 :     while ( hashlist[h] && vercolcomp(hashlist[h],td->fullarray+i) ) 

	mov	edx, DWORD PTR _hashlist$[ebp]
	mov	edi, eax
	add	esp, 4
	cmp	DWORD PTR [edx+edi*4], 0
	mov	DWORD PTR _h$96292[ebp], edi
	je	SHORT $LN34@make_index
	npad	7
$LL14@make_index:
	mov	eax, DWORD PTR tv574[ebp]
	mov	ecx, DWORD PTR _hashlist$[ebp]
	mov	edx, DWORD PTR [ecx+edi*4]
	push	eax
	push	edx
	call	_vercolcomp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN34@make_index

; 4200 :     { h++; if ( h == hashsize ) h = 0; }

	inc	edi
	mov	DWORD PTR _h$96292[ebp], edi
	cmp	edi, DWORD PTR _hashsize
	jne	SHORT $LN33@make_index
	mov	DWORD PTR _h$96292[ebp], 0
	mov	edi, DWORD PTR _h$96292[ebp]
$LN33@make_index:

; 4199 :     while ( hashlist[h] && vercolcomp(hashlist[h],td->fullarray+i) ) 

	mov	eax, DWORD PTR _hashlist$[ebp]
	cmp	DWORD PTR [eax+edi*4], 0
	jne	SHORT $LL14@make_index
$LN34@make_index:

; 4201 :     if ( hashlist[h] == NULL ) /* new one */

	mov	ecx, DWORD PTR _hashlist$[ebp]
	cmp	DWORD PTR [ecx+edi*4], 0
	jne	SHORT $LN11@make_index

; 4202 :     { 
; 4203 :       td->fullarray[j] = td->fullarray[i];

	mov	edi, DWORD PTR tv568[ebp]

; 4204 :       hashlist[h] = td->fullarray+j;

	mov	eax, DWORD PTR tv568[ebp]

; 4205 :       j++;

	inc	DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _hashlist$[ebp]
	add	edi, esi
	mov	esi, DWORD PTR tv574[ebp]
	mov	ecx, 11					; 0000000bH
	rep movsd
	mov	esi, DWORD PTR [ebx+9776]
	mov	edi, DWORD PTR _h$96292[ebp]
	lea	ecx, DWORD PTR [eax+esi]
	add	eax, 44					; 0000002cH
	mov	DWORD PTR [edx+edi*4], ecx
	mov	DWORD PTR tv568[ebp], eax
$LN11@make_index:

; 4206 :     }
; 4207 :     td->indexarray[i] = hashlist[h]-td->fullarray;

	mov	eax, DWORD PTR _hashlist$[ebp]
	mov	edi, DWORD PTR [eax+edi*4]
	add	DWORD PTR tv570[ebp], 44		; 0000002cH
	sub	edi, esi
	mov	eax, 780903145				; 2e8ba2e9H
	imul	edi
	mov	eax, DWORD PTR _i$[ebp]
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	edx, DWORD PTR [ebx+9832]
	mov	DWORD PTR [edx+eax*4], ecx
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _rawcount$[ebp]
	jl	$LL31@make_index

; 4197 :   for ( i = 1, j = 1 ; i < rawcount ; i++ )

	mov	esi, DWORD PTR _hashlist$[ebp]
$LN15@make_index:

; 4208 :   } 
; 4209 :   free((char*)hashlist);

	push	esi
	call	_free

; 4210 :   td->vertexcount = j;

	mov	eax, DWORD PTR _j$[ebp]

; 4211 : 
; 4212 : 
; 4213 :    /* Uniquify edges */
; 4214 :    for ( i = td->edgestart ; i < td->edgestart+td->edgecount ; i += 2 )

	mov	ecx, DWORD PTR [ebx+9792]
	mov	DWORD PTR [ebx+9804], eax
	mov	eax, DWORD PTR [ebx+9788]
	add	ecx, eax
	add	esp, 4
	cmp	eax, ecx
	jge	SHORT $LN8@make_index
	npad	7
$LL10@make_index:
	mov	edx, DWORD PTR [ebx+9832]
	lea	ecx, DWORD PTR [edx+eax*4]

; 4215 :    { if ( td->indexarray[i] > td->indexarray[i+1] )

	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [ecx], edx
	jle	SHORT $LN9@make_index

; 4216 :      { int temp = td->indexarray[i];

	mov	esi, DWORD PTR [ecx]

; 4217 :        td->indexarray[i] = td->indexarray[i+1];

	mov	DWORD PTR [ecx], edx

; 4218 :        td->indexarray[i+1] = temp;

	mov	ecx, DWORD PTR [ebx+9832]
	mov	DWORD PTR [ecx+eax*4+4], esi
$LN9@make_index:

; 4211 : 
; 4212 : 
; 4213 :    /* Uniquify edges */
; 4214 :    for ( i = td->edgestart ; i < td->edgestart+td->edgecount ; i += 2 )

	mov	edx, DWORD PTR [ebx+9792]
	add	edx, DWORD PTR [ebx+9788]
	add	eax, 2
	cmp	eax, edx
	jl	SHORT $LL10@make_index
$LN8@make_index:

; 4219 :      }
; 4220 :    }
; 4221 :    /* qsort here relatively minor in time */
; 4222 :    qsort((void*)(td->indexarray+td->edgestart),td->edgecount/2,2*sizeof(int), FCAST eecomp);

	mov	eax, DWORD PTR [ebx+9792]
	mov	ecx, DWORD PTR [ebx+9832]
	cdq
	sub	eax, edx
	push	OFFSET _eecomp
	sar	eax, 1
	push	8
	push	eax
	mov	eax, DWORD PTR [ebx+9788]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_qsort

; 4223 :    for ( i = 2, j = 0 ; i < td->edgecount ; i += 2 )

	mov	edi, 2
	add	esp, 16					; 00000010H
	xor	esi, esi
	cmp	DWORD PTR [ebx+9792], edi
	jle	SHORT $LN4@make_index
	npad	5
$LL6@make_index:

; 4224 :    { if ( eecomp(td->indexarray+td->edgestart+i,td->indexarray+td->edgestart+j) != 0 )

	mov	eax, DWORD PTR [ebx+9788]
	mov	ecx, DWORD PTR [ebx+9832]
	lea	edx, DWORD PTR [eax+edi]
	add	eax, esi
	lea	eax, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	eax
	push	edx
	mov	DWORD PTR tv483[ebp], edx
	call	_eecomp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@make_index

; 4225 :      { j += 2;

	add	esi, 2

; 4226 :        if ( i > j )

	cmp	edi, esi
	jle	SHORT $LN5@make_index

; 4227 :        { td->indexarray[td->edgestart+j] = td->indexarray[td->edgestart+i];

	mov	ecx, DWORD PTR [ebx+9788]
	mov	edx, DWORD PTR tv483[ebp]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [ebx+9832]
	add	ecx, esi
	mov	DWORD PTR [eax+ecx*4], edx

; 4228 :          td->indexarray[td->edgestart+j+1] = td->indexarray[td->edgestart+i+1];

	mov	eax, DWORD PTR [ebx+9788]
	mov	ecx, DWORD PTR [ebx+9832]
	lea	edx, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [ecx+edx*4+4]
	add	eax, esi
	mov	DWORD PTR [ecx+eax*4+4], edx
$LN5@make_index:

; 4223 :    for ( i = 2, j = 0 ; i < td->edgecount ; i += 2 )

	add	edi, 2
	cmp	edi, DWORD PTR [ebx+9792]
	jl	SHORT $LL6@make_index
$LN4@make_index:

; 4229 :        }
; 4230 :      }
; 4231 :    }
; 4232 :    if ( td->edgecount ) 

	cmp	DWORD PTR [ebx+9792], 0
	je	SHORT $LN1@make_index

; 4233 :      td->edgecount = j+2;

	add	esi, 2
	mov	DWORD PTR [ebx+9792], esi
$LN1@make_index:

; 4234 : 
; 4235 : } /* end make_indexlists() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_make_indexlists ENDP
_TEXT	ENDS
PUBLIC	_graph_new_surface
EXTRN	_matcopy:PROC
EXTRN	_identmat:DWORD
; Function compile flags: /Ogtp
;	COMDAT _graph_new_surface
_TEXT	SEGMENT
_did_graphlock_here$94794 = -4				; size = 4
_graph_new_surface PROC					; COMDAT

; 938  : { int k;

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi

; 939  :   struct graph_thread_data *td;
; 940  :  
; 941  :   ENTER_GRAPH_MUTEX; 

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	push	edi
	call	esi
	mov	edi, 1
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN7@graph_new_
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	edi
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$94794[ebp], edi
	jmp	SHORT $LN6@graph_new_
$LN7@graph_new_:
	mov	DWORD PTR _did_graphlock_here$94794[ebp], 0
$LN6@graph_new_:

; 942  : 
; 943  :   /* to account for global deallocation at start of new surface */
; 944  :   /* but we've given that up due to synchronization problems */
; 945  :   /*
; 946  :   td->fullarray = NULL;
; 947  :   td->colorarray = NULL;
; 948  :   td->edgearray = NULL;
; 949  :   td->facetarray = NULL;
; 950  :   td->indexarray = NULL;
; 951  :   td->striparray = NULL;
; 952  :   td->stripdata = NULL;
; 953  :   */
; 954  :   for ( k = 0, td = gthread_data ; k < MAXGRAPHWINDOWS ; k++,td++ )

	mov	esi, OFFSET _gthread_data+9828
	mov	ebx, 10					; 0000000aH
	npad	2
$LL12@graph_new_:

; 955  :   { int win_id = td->win_id;
; 956  :     td->interleaved_flag = 1; /* whether to do arrays as interleaved */
; 957  :     td->indexing_flag = 1; /* whether to use indexed arrays (smaller,but random access) */
; 958  :     td->opacity_flag = 1;
; 959  :     td->kb_norm[3] = 1.0;

	fld1

; 960  :     td->win_id = win_id;
; 961  :     td->view_initialized = 0;
; 962  :     td->mouse_mode = MM_ROTATE; 
; 963  :   	td->mpi_graph_task = 1;
; 964  :     set_title(td);

	lea	eax, DWORD PTR [esi-9828]
	push	eax
	fstp	DWORD PTR [esi-8200]
	mov	DWORD PTR [esi-4], edi
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+44], edi
	mov	DWORD PTR [esi-9124], 0
	mov	DWORD PTR [esi-8100], edi
	mov	DWORD PTR [esi+60], edi
	call	_set_title

; 965  :     if ( td->to_focus[0] )

	lea	eax, DWORD PTR [esi-9060]
	add	esp, 4
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@graph_new_

; 966  :     {
; 967  :         matcopy(td->to_focus,identmat,HOMDIM,HOMDIM);

	mov	ecx, DWORD PTR _HOMDIM
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR _identmat
	push	ecx
	push	eax
	call	_matcopy

; 968  :         matcopy(td->from_focus,identmat,HOMDIM,HOMDIM);

	mov	eax, DWORD PTR _HOMDIM
	mov	edx, DWORD PTR _identmat
	push	eax
	push	eax
	push	edx
	lea	eax, DWORD PTR [esi-8636]
	push	eax
	call	_matcopy
	add	esp, 32					; 00000020H
$LN4@graph_new_:

; 942  : 
; 943  :   /* to account for global deallocation at start of new surface */
; 944  :   /* but we've given that up due to synchronization problems */
; 945  :   /*
; 946  :   td->fullarray = NULL;
; 947  :   td->colorarray = NULL;
; 948  :   td->edgearray = NULL;
; 949  :   td->facetarray = NULL;
; 950  :   td->indexarray = NULL;
; 951  :   td->striparray = NULL;
; 952  :   td->stripdata = NULL;
; 953  :   */
; 954  :   for ( k = 0, td = gthread_data ; k < MAXGRAPHWINDOWS ; k++,td++ )

	add	esi, 9896				; 000026a8H
	sub	ebx, edi
	jne	SHORT $LL12@graph_new_

; 969  :     }
; 970  :   }
; 971  :   LEAVE_GRAPH_MUTEX; 

	cmp	DWORD PTR _did_graphlock_here$94794[ebp], 0
	pop	edi
	pop	esi
	pop	ebx
	je	SHORT $LN1@graph_new_
	mov	ecx, DWORD PTR _graphmutex
	push	ecx
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@graph_new_:

; 972  : 
; 973  : } // end graph_new_surface()

	mov	esp, ebp
	pop	ebp
	ret	0
_graph_new_surface ENDP
_TEXT	ENDS
PUBLIC	_mouse_func
; Function compile flags: /Ogtp
;	COMDAT _mouse_func
_TEXT	SEGMENT
_button$ = 8						; size = 4
_state$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_mouse_func PROC					; COMDAT

; 1434 : { struct graph_thread_data *td = GET_DATA;

	push	ebp
	mov	ebp, esp
	call	_glutGetWindow@0
	imul	eax, 9896				; 000026a8H

; 1435 :   switch ( button )

	mov	ecx, DWORD PTR _button$[ebp]
	add	eax, OFFSET _gthread_data
	sub	ecx, 0
	je	SHORT $LN9@mouse_func
	sub	ecx, 2
	jne	SHORT $LN7@mouse_func

; 1448 :            glutIdleFunc(idle_func);
; 1449 :            break;
; 1450 :       }
; 1451 :       break;
; 1452 : 
; 1453 :     case GLUT_RIGHT_BUTTON:
; 1454 :       switch ( state )

	cmp	DWORD PTR _state$[ebp], ecx
	jne	SHORT $LN7@mouse_func

; 1455 :       { case GLUT_DOWN: 
; 1456 :           // pick_func(x,y);
; 1457 :           my_own_pick_func(x,y);

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	push	eax
	push	ecx
	call	_my_own_pick_func
	add	esp, 8

; 1459 :           break;
; 1460 :       }
; 1461 :       break;
; 1462 :   }
; 1463 : } // end mouse_func()

	pop	ebp

; 1458 :           glutPostRedisplay();  /* get image back */  

	jmp	_glutPostRedisplay@0
$LN9@mouse_func:

; 1436 :   { case GLUT_LEFT_BUTTON:
; 1437 :       switch ( state )

	mov	ecx, DWORD PTR _state$[ebp]
	sub	ecx, 0
	je	SHORT $LN6@mouse_func
	dec	ecx
	jne	SHORT $LN7@mouse_func

; 1442 :            break;
; 1443 :         case GLUT_UP:  /* stop tracking */
; 1444 :            td->basex = td->newx;

	mov	edx, DWORD PTR [eax+264]

; 1445 :            td->basey = td->newy;

	mov	ecx, DWORD PTR [eax+268]
	mov	DWORD PTR [eax+272], edx
	mov	DWORD PTR [eax+276], ecx

; 1446 :            td->mouse_left_state = GLUT_UP;

	mov	DWORD PTR [eax+1732], 1

; 1447 :            glutPostRedisplay();

	call	_glutPostRedisplay@0
	push	OFFSET _idle_func
	call	_glutIdleFunc@4

; 1459 :           break;
; 1460 :       }
; 1461 :       break;
; 1462 :   }
; 1463 : } // end mouse_func()

	pop	ebp
	ret	0
$LN6@mouse_func:

; 1438 :       { case GLUT_DOWN:  /* start tracking */
; 1439 :            td->oldx = x; td->oldy = y;

	mov	edx, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _y$[ebp]

; 1440 :            td->mouse_left_state = GLUT_DOWN;
; 1441 :            glutIdleFunc(idle_func);

	push	OFFSET _idle_func
	mov	DWORD PTR [eax+256], edx
	mov	DWORD PTR [eax+260], ecx
	mov	DWORD PTR [eax+1732], 0
	call	_glutIdleFunc@4
$LN7@mouse_func:

; 1459 :           break;
; 1460 :       }
; 1461 :       break;
; 1462 :   }
; 1463 : } // end mouse_func()

	pop	ebp
	ret	0
_mouse_func ENDP
_TEXT	ENDS
PUBLIC	??_C@_06PJLGDGG@?$CFs?4png?$AA@			; `string'
PUBLIC	??_C@_0M@ILKLMOHH@?$CFs_?$CF06u?4png?$AA@	; `string'
PUBLIC	__real@4008000000000000
PUBLIC	_Oglz_start
PUBLIC	__real@3f8ccccd
PUBLIC	__real@3ff19999a0000000
PUBLIC	??_C@_0DF@EHNHCPAK@After?5indexing?3?5?$CFd?5unique?5vertic@ ; `string'
PUBLIC	_build_arrays
PUBLIC	__real@4030000000000000
PUBLIC	??_C@_0BB@HBLIDNMI@?4?1Screenshot?4png?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_draw_screen
EXTRN	_png_prefix:BYTE
EXTRN	_png_full_name:BYTE
EXTRN	_temp_free_all:PROC
EXTRN	_glutSwapBuffers@0:PROC
EXTRN	_display_text_count:DWORD
EXTRN	__imp__glPushName@4:PROC
EXTRN	__imp__glInitNames@0:PROC
EXTRN	__imp__glDepthFunc@4:PROC
EXTRN	_backcull_flag:DWORD
EXTRN	__imp__glClear@4:PROC
EXTRN	__imp__glClearColor@16:PROC
EXTRN	_background_color:DWORD
EXTRN	_close_graphics:DWORD
EXTRN	_finish_graphics:DWORD
EXTRN	_init_graphics:DWORD
EXTRN	_graph_end:DWORD
EXTRN	_graph_edge:DWORD
EXTRN	_graph_facet:DWORD
EXTRN	_graph_start:DWORD
EXTRN	_get_internal_variable:PROC
EXTRN	_facet_alpha_flag:DWORD
EXTRN	__imp__glLightfv@12:PROC
EXTRN	_rotate_lights_flag:DWORD
EXTRN	__imp__glLoadMatrixd@4:PROC
EXTRN	_graphjumpbuf:BYTE
EXTRN	_glutSetWindowTitle@4:PROC
EXTRN	_lazy_transforms_flag:DWORD
_BSS	SEGMENT
?TimeString@?1??draw_screen@@9@9 DB 040H DUP (?)	; `draw_screen'::`2'::TimeString
	ALIGN	8

?last_mutex_time@?BC@??draw_screen@@9@9 DQ 01H DUP (?)	; `draw_screen'::`18'::last_mutex_time
_BSS	ENDS
;	COMDAT ??_C@_06PJLGDGG@?$CFs?4png?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
CONST	SEGMENT
??_C@_06PJLGDGG@?$CFs?4png?$AA@ DB '%s.png', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ILKLMOHH@?$CFs_?$CF06u?4png?$AA@
CONST	SEGMENT
??_C@_0M@ILKLMOHH@?$CFs_?$CF06u?4png?$AA@ DB '%s_%06u.png', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@3f8ccccd
CONST	SEGMENT
__real@3f8ccccd DD 03f8ccccdr			; 1.1
CONST	ENDS
;	COMDAT __real@3ff19999a0000000
CONST	SEGMENT
__real@3ff19999a0000000 DQ 03ff19999a0000000r	; 1.1
CONST	ENDS
;	COMDAT ??_C@_0DF@EHNHCPAK@After?5indexing?3?5?$CFd?5unique?5vertic@
CONST	SEGMENT
??_C@_0DF@EHNHCPAK@After?5indexing?3?5?$CFd?5unique?5vertic@ DB 'After in'
	DB	'dexing: %d unique vertices, %d unique edges', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@4030000000000000
CONST	SEGMENT
__real@4030000000000000 DQ 04030000000000000r	; 16
CONST	ENDS
;	COMDAT ??_C@_0BB@HBLIDNMI@?4?1Screenshot?4png?$AA@
CONST	SEGMENT
??_C@_0BB@HBLIDNMI@?4?1Screenshot?4png?$AA@ DB './Screenshot.png', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\glutgraph.c
CONST	ENDS
;	COMDAT _draw_screen
_TEXT	SEGMENT
_t$95993 = -1188					; size = 8
_now$95974 = -1180					; size = 8
_swapY$96004 = -1176					; size = 4
_td$ = -1172						; size = 4
_bmp$ = -1168						; size = 4
_y$ = -1164						; size = 4
_i$ = -1164						; size = 4
_t$ = -1157						; size = 1
_viewf$ = -1156						; size = 128
_fname$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_draw_screen PROC					; COMDAT

; 3285 : { struct graph_thread_data *td = GET_DATA;

	push	ebp
	mov	ebp, esp
	sub	esp, 1188				; 000004a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	call	_glutGetWindow@0
	mov	esi, eax
	imul	esi, 9896				; 000026a8H
	add	esi, OFFSET _gthread_data

; 3286 :  
; 3287 :   Matrix viewf;
; 3288 :   int i,j;
; 3289 : #ifdef __L_EVOLVER__
; 3290 : //psu
; 3291 :   	//xsize, ysize contain the window size. So create a 24 bit bitmap.
; 3292 : 	int bmp_size = 3*td->xsize*td->ysize, x, y;

	mov	eax, DWORD PTR [esi+252]
	imul	eax, DWORD PTR [esi+248]
	lea	eax, DWORD PTR [eax+eax*2]

; 3293 : 	unsigned char t, *bmp = calloc(bmp_size, 1);

	push	1
	push	eax
	mov	DWORD PTR _td$[ebp], esi
	call	_calloc

; 3294 : 	char fname[1024] = "./Screenshot.png";

	mov	ecx, DWORD PTR ??_C@_0BB@HBLIDNMI@?4?1Screenshot?4png?$AA@+4
	mov	edx, DWORD PTR ??_C@_0BB@HBLIDNMI@?4?1Screenshot?4png?$AA@+8
	mov	DWORD PTR _bmp$[ebp], eax
	mov	eax, DWORD PTR ??_C@_0BB@HBLIDNMI@?4?1Screenshot?4png?$AA@
	push	1007					; 000003efH
	mov	DWORD PTR _fname$[ebp+8], edx
	xor	edi, edi
	mov	DWORD PTR _fname$[ebp], eax
	mov	eax, DWORD PTR ??_C@_0BB@HBLIDNMI@?4?1Screenshot?4png?$AA@+12
	mov	DWORD PTR _fname$[ebp+4], ecx
	mov	cl, BYTE PTR ??_C@_0BB@HBLIDNMI@?4?1Screenshot?4png?$AA@+16
	lea	edx, DWORD PTR _fname$[ebp+17]
	push	edi
	push	edx
	mov	DWORD PTR _fname$[ebp+12], eax
	mov	BYTE PTR _fname$[ebp+16], cl
	call	_memset
	add	esp, 20					; 00000014H

; 3295 : 	FILE *out_file;
; 3296 : 	static char TimeString[64];				//Prefix on filenames.
; 3297 : 	static unsigned int FileCounter = 0;		//Counter after the prefix above.
; 3298 :   //
; 3299 : #endif
; 3300 :   if ( td->aspect_flag )

	cmp	DWORD PTR [esi+1744], edi
	je	SHORT $LN80@draw_scree

; 3301 :     reshape_func(td->xsize,td->ysize);

	mov	eax, DWORD PTR [esi+252]
	mov	ecx, DWORD PTR [esi+248]
	push	eax
	push	ecx
	call	_reshape_func
	add	esp, 8
$LN80@draw_scree:

; 3302 : 
; 3303 : #ifdef quickresize
; 3304 :   if ( td->resize_flag && !td->idle_flag ) /* Mac OS X resize recombine */
; 3305 :   { glutIdleFunc(idle_func);
; 3306 :     return; 
; 3307 :   }
; 3308 :   td->resize_flag = 0;
; 3309 : #endif
; 3310 : 
; 3311 :   td->idle_flag = 0;

	mov	DWORD PTR [esi+1736], edi

; 3312 : 
; 3313 :   if ( slice_view_flag || clip_view_flag )

	cmp	DWORD PTR _slice_view_flag, edi
	jne	SHORT $LN78@draw_scree
	cmp	DWORD PTR _clip_view_flag, edi
	je	SHORT $LN79@draw_scree
$LN78@draw_scree:

; 3314 :     lazy_transforms_flag =0;

	mov	DWORD PTR _lazy_transforms_flag, edi
$LN79@draw_scree:

; 3315 : 
; 3316 : #ifdef ASADS
; 3317 :   // this almost works; clip plane seems to move twice as much as it should
; 3318 :   if ( clip_view_flag )
; 3319 :   { // use OpenGL clipping
; 3320 :     REAL viewclip[MAXCOORD+1];
; 3321 :     REAL *viewclip_ptr = viewclip;
; 3322 :     REAL *clip_coeff_ptr;
; 3323 :     GLdouble glclip[4];
; 3324 :     MAT2D(invview,MAXCOORD+1,MAXCOORD+1);
; 3325 :     matcopy(invview,td->view,SDIM+1,SDIM+1);
; 3326 :     mat_inv(invview,SDIM+1);
; 3327 : 
; 3328 :     clip_coeff[0][SDIM] = -clip_coeff[0][SDIM]; // for OpenGL sign convention
; 3329 :     clip_coeff_ptr = clip_coeff[0];
; 3330 :     mat_mult(&clip_coeff_ptr,invview,&viewclip_ptr,1,SDIM+1,SDIM+1);
; 3331 :     clip_coeff[0][SDIM] = -clip_coeff[0][SDIM]; // restore
; 3332 :     glclip[0] = viewclip[0];
; 3333 :     glclip[1] = viewclip[1];
; 3334 :     glclip[2] = viewclip[2];
; 3335 :     glclip[3] = viewclip[SDIM];
; 3336 : 
; 3337 : /* this doesn't work at all
; 3338 :     glclip[0] = -clip_coeff[0][0];
; 3339 :     glclip[1] = -clip_coeff[0][1];
; 3340 :     glclip[2] = -clip_coeff[0][2];
; 3341 :     glclip[3] = clip_coeff[0][SDIM];
; 3342 : */
; 3343 :     glClipPlane(GL_CLIP_PLANE0,glclip);
; 3344 :     glEnable(GL_CLIP_PLANE0);
; 3345 :   }
; 3346 :   else
; 3347 :     glDisable(GL_CLIP_PLANE0);
; 3348 : #endif  
; 3349 : 
; 3350 :   if ( td->new_title_flag )

	cmp	DWORD PTR [esi+4], edi
	je	SHORT $LN77@draw_scree

; 3351 :     glutSetWindowTitle(td->wintitle);

	lea	edx, DWORD PTR [esi+8]
	push	edx
	call	_glutSetWindowTitle@4
$LN77@draw_scree:

; 3352 :   td->new_title_flag = 0;
; 3353 : 
; 3354 : #ifdef __cplusplus
; 3355 :   try
; 3356 :   {
; 3357 : #else
; 3358 :   /* Set up longjmp to return here in case of error  */
; 3359 :   if ( setjmp(graphjumpbuf) )

	push	edi
	push	OFFSET _graphjumpbuf
	mov	DWORD PTR [esi+4], edi
	call	__setjmp3
	add	esp, 8
	test	eax, eax
	jne	$LN81@draw_scree

; 3360 :   { return; }
; 3361 : #endif
; 3362 : 
; 3363 : 
; 3364 : 
; 3365 :   /* New view loading point to try to eliminate problem with first load
; 3366 :      of very small surfaces. Works.  It needs to have view matrix loaded
; 3367 :      before setting arrays so it knows the proper rounding scale.
; 3368 :   */
; 3369 :   
; 3370 :   glMatrixMode(GL_MODELVIEW);

	push	5888					; 00001700H
	call	DWORD PTR __imp__glMatrixMode@4

; 3371 :   for ( i = 0 ; i < 4 ; i++ )

	mov	edi, DWORD PTR _td$[ebp]

; 3372 :     for ( j = 0 ; j < 4 ; j++ )
; 3373 :       viewf[i][j] = td->view[(j<3)?j:(SDIM)][(i<3)?i:(SDIM)];

	mov	esi, DWORD PTR _web+616
	xor	eax, eax
	lea	ecx, DWORD PTR _viewf$[ebp+8]
$LN75@draw_scree:
	mov	edx, eax
	cmp	eax, 3
	jl	SHORT $LN86@draw_scree
	mov	edx, esi
$LN86@draw_scree:
	mov	ebx, DWORD PTR [edi+280]
	fld	QWORD PTR [ebx+edx*8]
	mov	edx, eax
	fstp	QWORD PTR [ecx-8]
	cmp	eax, 3
	jl	SHORT $LN121@draw_scree
	mov	edx, esi
$LN121@draw_scree:
	mov	ebx, DWORD PTR [edi+284]
	fld	QWORD PTR [ebx+edx*8]
	mov	edx, eax
	fstp	QWORD PTR [ecx]
	cmp	eax, 3
	jl	SHORT $LN126@draw_scree
	mov	edx, esi
$LN126@draw_scree:
	mov	ebx, DWORD PTR [edi+288]
	fld	QWORD PTR [ebx+edx*8]
	mov	edx, eax
	fstp	QWORD PTR [ecx+8]
	cmp	eax, 3
	jl	SHORT $LN131@draw_scree
	mov	edx, esi
$LN131@draw_scree:
	mov	ebx, DWORD PTR [edi+esi*4+280]
	fld	QWORD PTR [ebx+edx*8]
	inc	eax
	fstp	QWORD PTR [ecx+16]
	add	ecx, 32					; 00000020H
	cmp	eax, 4
	jl	SHORT $LN75@draw_scree

; 3374 :   if ( SDIM == 2 ) 

	fldz
	cmp	esi, 2
	jne	SHORT $LN153@draw_scree

; 3375 :   { for ( i = 0 ; i < 3 ; i++ ) viewf[i][2] = viewf[2][i] = 0.0;

	fst	QWORD PTR _viewf$[ebp+64]
	fst	QWORD PTR _viewf$[ebp+16]
	fst	QWORD PTR _viewf$[ebp+72]
	fstp	QWORD PTR _viewf$[ebp+48]

; 3376 :     viewf[2][2] = 1.0;

	fld1
	fstp	QWORD PTR _viewf$[ebp+80]
	jmp	SHORT $LN69@draw_scree
$LN153@draw_scree:
	fstp	ST(0)
$LN69@draw_scree:

; 3377 :   }
; 3378 :   /* transpose, picking first 3 coordinates */
; 3379 :   if ( (td->projmode == P_PERSP) || td->stereomode ) 

	xor	ebx, ebx
	cmp	DWORD PTR [edi+1632], 1
	je	SHORT $LN64@draw_scree
	cmp	DWORD PTR [edi+1700], ebx
	je	SHORT $LN62@draw_scree
$LN64@draw_scree:

; 3380 :   {   if ( SDIM == 2 ) viewf[3][2] -= 16;

	cmp	esi, 2
	jne	SHORT $LN63@draw_scree
	fld	QWORD PTR _viewf$[ebp+112]
	fsub	QWORD PTR __real@4030000000000000
	fstp	QWORD PTR _viewf$[ebp+112]
	jmp	SHORT $LN62@draw_scree
$LN63@draw_scree:

; 3381 :       else viewf[3][0] -= 16.0;

	fld	QWORD PTR _viewf$[ebp+96]
	fsub	QWORD PTR __real@4030000000000000
	fstp	QWORD PTR _viewf$[ebp+96]
$LN62@draw_scree:

; 3382 :   } 
; 3383 :   GL_ERROR_CHECK
; 3384 : 
; 3385 : 
; 3386 :   glLoadMatrixd(viewf[0]); 

	lea	eax, DWORD PTR _viewf$[ebp]
	push	eax
	call	DWORD PTR __imp__glLoadMatrixd@4

; 3387 :   /* end new view load */
; 3388 : 
; 3389 :   if ( rotate_lights_flag )

	cmp	DWORD PTR _rotate_lights_flag, ebx
	je	SHORT $LN61@draw_scree

; 3390 :   {
; 3391 :     glLightfv(GL_LIGHT0, GL_POSITION, light0_position);   

	mov	esi, DWORD PTR __imp__glLightfv@12
	push	OFFSET _light0_position
	push	4611					; 00001203H
	push	16384					; 00004000H
	call	esi

; 3392 :     glLightfv(GL_LIGHT1, GL_POSITION, light1_position); 

	push	OFFSET _light1_position
	push	4611					; 00001203H
	push	16385					; 00004001H
	call	esi
$LN61@draw_scree:

; 3393 :   }
; 3394 : 
; 3395 :   /* build arrays if needed */
; 3396 :   if ( td->arraysflag && (
; 3397 :       ((graph_timestamp != td->arrays_timestamp) && go_display_flag )
; 3398 :          || td->newarraysflag || (td->dlistflag == RESETLIST))
; 3399 :      )

	mov	ecx, DWORD PTR _graph_timestamp
	mov	eax, DWORD PTR _go_display_flag
	cmp	DWORD PTR [edi+9772], ebx
	je	$LN60@draw_scree
	cmp	ecx, DWORD PTR [edi+132]
	je	SHORT $LN58@draw_scree
	cmp	eax, ebx
	jne	SHORT $LN59@draw_scree
$LN58@draw_scree:
	cmp	DWORD PTR [edi+128], ebx
	jne	SHORT $LN59@draw_scree
	cmp	DWORD PTR [edi+1748], 2
	jne	$LN60@draw_scree
$LN59@draw_scree:

; 3400 :   {
; 3401 :     if ( td->multi_dlist_flag )

	cmp	DWORD PTR [edi+1752], ebx
	je	SHORT $LN57@draw_scree

; 3402 :     { int i;
; 3403 :       for ( i = 0 ; i < td->edge_dlist_alloc ; i++ )

	xor	esi, esi
	cmp	DWORD PTR [edi+5756], ebx
	jle	SHORT $LN54@draw_scree
	lea	ebx, DWORD PTR [edi+1756]
$LL56@draw_scree:

; 3404 :         glDeleteLists(td->edge_dlists[i],1);

	mov	ecx, DWORD PTR [ebx]
	push	1
	push	ecx
	call	DWORD PTR __imp__glDeleteLists@8
	inc	esi
	add	ebx, 4
	cmp	esi, DWORD PTR [edi+5756]
	jl	SHORT $LL56@draw_scree
$LN54@draw_scree:

; 3405 :       for ( i = 0 ; i < td->edge_dlist_alloc ; i++ )

	xor	esi, esi
	cmp	DWORD PTR [edi+5756], esi
	jle	SHORT $LN51@draw_scree
	lea	ebx, DWORD PTR [edi+5764]
$LL53@draw_scree:

; 3406 :         glDeleteLists(td->facet_dlists[i],1);

	mov	edx, DWORD PTR [ebx]
	push	1
	push	edx
	call	DWORD PTR __imp__glDeleteLists@8
	inc	esi
	add	ebx, 4
	cmp	esi, DWORD PTR [edi+5756]
	jl	SHORT $LL53@draw_scree
$LN51@draw_scree:

; 3407 :       td->edge_dlist_alloc = 0;

	xor	eax, eax
	mov	DWORD PTR [edi+5756], eax

; 3408 :       td->edge_dlist_count = 0;

	mov	DWORD PTR [edi+5760], eax

; 3409 :       td->facet_dlist_alloc = 0;

	mov	DWORD PTR [edi+9764], eax

; 3410 :       td->facet_dlist_count = 0;

	mov	DWORD PTR [edi+9768], eax
	xor	ebx, ebx
$LN57@draw_scree:

; 3411 :     }
; 3412 : 
; 3413 :     td->newarraysflag = 1;

	mov	DWORD PTR [edi+128], 1

; 3414 :     if ( build_arrays() )

	call	_build_arrays
	test	eax, eax
	je	$LN26@draw_scree

; 3415 :     {
; 3416 :       declare_arrays();

	call	_declare_arrays

; 3417 :    
; 3418 :       /* doing this here since facet_alpha_flag set in graphgen */
; 3419 :       if ( facet_alpha_flag ) glEnable(GL_BLEND);

	push	3042					; 00000be2H
	cmp	DWORD PTR _facet_alpha_flag, ebx
	je	SHORT $LN49@draw_scree
	call	DWORD PTR __imp__glEnable@4
	jmp	SHORT $LN48@draw_scree
$LN49@draw_scree:

; 3420 :       else glDisable(GL_BLEND);

	call	DWORD PTR __imp__glDisable@4
$LN48@draw_scree:

; 3421 :       glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);

	push	771					; 00000303H
	push	770					; 00000302H
	call	DWORD PTR __imp__glBlendFunc@8

; 3422 :       
; 3423 :       if ( td->indexing_flag ) 

	cmp	DWORD PTR [edi+9828], ebx
	je	SHORT $LN45@draw_scree

; 3424 :       { 
; 3425 :         make_indexlists();

	call	_make_indexlists

; 3426 :         if ( td->q_flag )

	cmp	DWORD PTR [edi+9868], ebx
	je	SHORT $LN46@draw_scree

; 3427 :         { sprintf(msg,"After indexing: %d unique vertices, %d unique edges\n",
; 3428 :               td->vertexcount,td->edgecount/2);

	mov	eax, DWORD PTR [edi+9792]
	mov	ecx, DWORD PTR _msg
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	mov	eax, DWORD PTR [edi+9804]
	push	eax
	push	OFFSET ??_C@_0DF@EHNHCPAK@After?5indexing?3?5?$CFd?5unique?5vertic@
	push	ecx
	call	_sprintf

; 3429 :           outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 20					; 00000014H
$LN46@draw_scree:

; 3430 :         }
; 3431 :         if ( td->strips_flag ) make_strips();

	cmp	DWORD PTR [edi+9836], ebx
	je	SHORT $LN45@draw_scree
	call	_make_strips
$LN45@draw_scree:

; 3432 :       }
; 3433 : 
; 3434 :       /* Workaround really bizarre line-drawing bug */
; 3435 :       if ( td->linewidth == 1.0 ) 

	fld	QWORD PTR [edi+1712]
	fld1
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN44@draw_scree

; 3436 :       { td->linewidth = (float)1.1; 

	fld	QWORD PTR __real@3ff19999a0000000

; 3437 :         glLineWidth(td->linewidth); 

	push	ecx
	fstp	QWORD PTR [edi+1712]
	fld	DWORD PTR __real@3f8ccccd
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glLineWidth@4
$LN44@draw_scree:

; 3438 :       }
; 3439 :       GL_ERROR_CHECK
; 3440 :   
; 3441 :       if ( !td->interleaved_flag )

	cmp	DWORD PTR [edi+9824], ebx
	jne	$LN43@draw_scree

; 3442 :       { /* kludge for broken nVidia Detonater 2.08 driver */
; 3443 :         if ( td->colorarray ) free((char*)td->colorarray);

	cmp	DWORD PTR [edi+9784], ebx
	je	SHORT $LN42@draw_scree
	mov	eax, DWORD PTR [edi+9784]
	push	eax
	call	_free
	add	esp, 4
$LN42@draw_scree:

; 3444 :         td->colorarray = (float*)calloc(td->edgecount+td->facetcount+5,4*sizeof(float));

	mov	ecx, DWORD PTR [edi+9800]
	mov	edx, DWORD PTR [edi+9792]
	lea	eax, DWORD PTR [ecx+edx+5]
	push	16					; 00000010H
	push	eax
	call	_calloc
	add	esp, 8
	mov	DWORD PTR [edi+9784], eax

; 3445 :         if ( td->colorarray == NULL )

	cmp	eax, ebx
	jne	SHORT $LN41@draw_scree

; 3446 :         { kb_error(5696,"Graphics too complicated for arrays.  Switching to non-array graphics.\n",
; 3447 :             WARNING);

	push	2
	push	OFFSET ??_C@_0EI@EHMFEGOO@Graphics?5too?5complicated?5for?5arr@
	push	5696					; 00001640H
	call	_kb_error

; 3448 :           td->arraysflag = 0;

	mov	DWORD PTR [edi+9772], ebx
	add	esp, 12					; 0000000cH

; 3449 :           td->doing_lazy = 0;

	mov	DWORD PTR [edi+9864], ebx

; 3450 :           glutPostRedisplay();

	call	_glutPostRedisplay@0

; 3707 :   //end psu
; 3708 : #endif
; 3709 : } /* end draw_screen() */

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@draw_scree:

; 3451 :           return;
; 3452 :         }
; 3453 : 
; 3454 :         for ( i = 0 ; i < td->edgecount+td->facetcount ; i++ )

	mov	ecx, DWORD PTR [edi+9800]
	add	ecx, DWORD PTR [edi+9792]
	mov	DWORD PTR _i$[ebp], ebx
	test	ecx, ecx
	jle	SHORT $LN38@draw_scree
	mov	ecx, DWORD PTR [edi+9776]
	xor	edx, edx
	add	ecx, 8
$LN40@draw_scree:

; 3455 :           for ( j = 0 ; j < 4 ; j++ )
; 3456 :             td->colorarray[4*i+j] = td->fullarray[i].c[j];

	fld	DWORD PTR [ecx-8]
	inc	DWORD PTR _i$[ebp]
	fstp	DWORD PTR [edx+eax]
	add	ecx, 44					; 0000002cH
	fld	DWORD PTR [ecx-48]
	add	edx, 16					; 00000010H
	fstp	DWORD PTR [edx+eax-12]
	fld	DWORD PTR [ecx-44]
	fstp	DWORD PTR [edx+eax-8]
	fld	DWORD PTR [ecx-40]
	fstp	DWORD PTR [edx+eax-4]
	mov	esi, DWORD PTR [edi+9800]
	add	esi, DWORD PTR [edi+9792]
	cmp	DWORD PTR _i$[ebp], esi
	jl	SHORT $LN40@draw_scree
$LN38@draw_scree:

; 3457 :         declare_arrays();

	call	_declare_arrays
	xor	ebx, ebx
$LN43@draw_scree:

; 3458 :       }
; 3459 :   
; 3460 :     GL_ERROR_CHECK
; 3461 :   
; 3462 :   
; 3463 :       td->newarraysflag = 0;

	mov	DWORD PTR [edi+128], ebx

; 3464 : 
; 3465 :       if ( td->dlistflag )

	cmp	DWORD PTR [edi+1748], ebx
	je	$LN34@draw_scree

; 3466 :       {
; 3467 :         declare_arrays();

	call	_declare_arrays

; 3468 :         glNewList(dindex,GL_COMPILE);

	mov	edx, DWORD PTR _dindex
	push	4864					; 00001300H
	push	edx
	call	DWORD PTR __imp__glNewList@8

; 3469 :         if ( td->indexing_flag )
; 3470 :         {
; 3471 :           glDrawElements(GL_TRIANGLES,td->facetcount,GL_UNSIGNED_INT,td->indexarray+td->facetstart);

	mov	eax, DWORD PTR [edi+9796]
	cmp	DWORD PTR [edi+9828], ebx
	je	SHORT $LN33@draw_scree
	mov	ecx, DWORD PTR [edi+9832]
	mov	esi, DWORD PTR __imp__glDrawElements@16
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edi+9800]
	push	edx
	push	5125					; 00001405H
	push	eax
	push	4
	call	esi

; 3472 :           glMatrixMode(GL_PROJECTION);

	push	5889					; 00001701H
	call	DWORD PTR __imp__glMatrixMode@4

; 3473 :           glTranslated(td->edge_bias*imagescale,0.0,0.0);   /* edges in front */

	fldz
	mov	ebx, DWORD PTR __imp__glTranslated@24
	sub	esp, 24					; 00000018H
	fst	QWORD PTR [esp+16]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [edi+1720]
	fmul	QWORD PTR _imagescale
	fstp	QWORD PTR [esp]
	call	ebx

; 3474 :           glDrawElements(GL_LINES,td->edgecount,GL_UNSIGNED_INT,td->indexarray+td->edgestart);

	mov	ecx, DWORD PTR [edi+9788]
	mov	edx, DWORD PTR [edi+9832]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [edi+9792]
	push	eax
	push	5125					; 00001405H
	push	ecx
	push	1
	call	esi

; 3475 :           glTranslated(-td->edge_bias*imagescale,0.0,0.0);
; 3476 :           glMatrixMode(GL_MODELVIEW);
; 3477 :         }
; 3478 :         else

	jmp	SHORT $LN155@draw_scree
$LN33@draw_scree:

; 3479 :         {
; 3480 :           glDrawArrays(GL_TRIANGLES,td->facetstart,td->facetcount); 

	mov	edx, DWORD PTR [edi+9800]
	mov	esi, DWORD PTR __imp__glDrawArrays@12
	push	edx
	push	eax
	push	4
	call	esi

; 3481 :           glMatrixMode(GL_PROJECTION);

	push	5889					; 00001701H
	call	DWORD PTR __imp__glMatrixMode@4

; 3482 :           glTranslated(td->edge_bias*imagescale,0.0,0.0);    /* edges in front */

	fldz
	mov	ebx, DWORD PTR __imp__glTranslated@24
	sub	esp, 24					; 00000018H
	fst	QWORD PTR [esp+16]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [edi+1720]
	fmul	QWORD PTR _imagescale
	fstp	QWORD PTR [esp]
	call	ebx

; 3483 :           glDrawArrays(GL_LINES,td->edgestart,td->edgecount);

	mov	ecx, DWORD PTR [edi+9792]
	mov	edx, DWORD PTR [edi+9788]
	push	ecx
	push	edx
	push	1
	call	esi
$LN155@draw_scree:

; 3484 :           glTranslated(-td->edge_bias*imagescale,0.0,0.0);

	fldz
	sub	esp, 24					; 00000018H
	fst	QWORD PTR [esp+16]
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR [edi+1720]
	fmul	QWORD PTR _imagescale
	fchs
	fstp	QWORD PTR [esp]
	call	ebx

; 3485 :           glMatrixMode(GL_MODELVIEW);

	push	5888					; 00001700H
	call	DWORD PTR __imp__glMatrixMode@4

; 3486 :        }
; 3487 :         glEndList();           

	call	DWORD PTR __imp__glEndList@0

; 3488 :         td->dlistflag = NORMALLIST;

	mov	DWORD PTR [edi+1748], 1
	xor	ebx, ebx
$LN34@draw_scree:

; 3489 :       }
; 3490 :       if ( td->q_flag ) outstring(current_prompt);  

	cmp	DWORD PTR [edi+9868], ebx
	je	$LN24@draw_scree
	mov	eax, DWORD PTR _current_prompt
	push	eax
	call	_outstring
	add	esp, 4

; 3491 :      }
; 3492 :      else 
; 3493 :        glutPostRedisplay();
; 3494 :   }
; 3495 :   else

	jmp	$LN24@draw_scree
$LN60@draw_scree:

; 3496 :   if ( ((td->dlistflag != NORMALLIST) || 
; 3497 :         ((graph_timestamp != prev_timestamp) && go_display_flag ))
; 3498 :      )

	mov	esi, 1
	cmp	DWORD PTR [edi+1748], esi
	jne	SHORT $LN27@draw_scree
	cmp	ecx, DWORD PTR _prev_timestamp
	je	$LN24@draw_scree
	cmp	eax, ebx
	je	$LN24@draw_scree
$LN27@draw_scree:

; 3499 :   { 
; 3500 :     /* if long time since last build, block and wait */
; 3501 :     static REAL last_mutex_time;
; 3502 :     REAL now = get_internal_variable(V_CLOCK);

	push	1880					; 00000758H
	call	_get_internal_variable
	fst	QWORD PTR _now$95974[ebp]

; 3503 :     int timeout = (now-last_mutex_time > .5) ? LONG_TIMEOUT : IMMEDIATE_TIMEOUT;

	fsub	QWORD PTR ?last_mutex_time@?BC@??draw_screen@@9@9
	add	esp, 4
	fcomp	QWORD PTR __real@3fe0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN87@draw_scree
	mov	eax, 100000				; 000186a0H
	jmp	SHORT $LN88@draw_scree
$LN87@draw_scree:
	xor	eax, eax
$LN88@draw_scree:

; 3504 :     if ( TRY_GRAPH_MUTEX(timeout) )

	push	ebx
	push	eax
	push	ebx
	push	OFFSET _graphmutex
	push	esi
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	cmp	eax, 258				; 00000102H
	je	$LN26@draw_scree
	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	DWORD PTR _locking_thread, eax
	cmp	eax, ebx
	je	$LN26@draw_scree

; 3505 :     { /* regenerate display list */
; 3506 :       graph_start = Oglz_start;
; 3507 :       graph_facet = Oglz_facet;
; 3508 :       graph_edge  = Oglz_edge;
; 3509 :       graph_end = Oglz_end;
; 3510 :     
; 3511 :       init_graphics = Ogl_init;
; 3512 :       finish_graphics = Ogl_finish;
; 3513 :       close_graphics = Ogl_close_show;
; 3514 :       last_mutex_time = now;

	fld	QWORD PTR _now$95974[ebp]
	mov	DWORD PTR _graph_start, OFFSET _Oglz_start
	mov	DWORD PTR _graph_facet, OFFSET _Oglz_facet
	fstp	QWORD PTR ?last_mutex_time@?BC@??draw_screen@@9@9
	mov	DWORD PTR _graph_edge, OFFSET _Oglz_edge
	mov	DWORD PTR _graph_end, OFFSET _Oglz_end
	mov	DWORD PTR _init_graphics, OFFSET _Ogl_init
	mov	DWORD PTR _finish_graphics, OFFSET _Ogl_finish
	mov	DWORD PTR _close_graphics, OFFSET _Ogl_close_show

; 3515 :  
; 3516 :       if ( td->dlistflag != NOLIST )

	cmp	DWORD PTR [edi+1748], ebx
	je	SHORT $LN25@draw_scree

; 3517 :       { glNewList(dindex,GL_COMPILE);

	mov	ecx, DWORD PTR _dindex
	push	4864					; 00001300H
	push	ecx
	call	DWORD PTR __imp__glNewList@8

; 3518 :         td->facetcount = td->edgecount = 0;

	mov	DWORD PTR [edi+9792], ebx
	mov	DWORD PTR [edi+9800], ebx

; 3519 :         normflag = td->normflag;

	mov	edx, DWORD PTR [edi+1708]
	mov	DWORD PTR _normflag, edx

; 3520 :         graphgen();

	call	_graphgen

; 3521 :         glEndList();

	call	DWORD PTR __imp__glEndList@0

; 3522 :         td->dlistflag = NORMALLIST;

	mov	DWORD PTR [edi+1748], esi
$LN25@draw_scree:

; 3523 :       }
; 3524 :       END_TRY_GRAPH_MUTEX

	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, ebx
	call	DWORD PTR __imp__ReleaseMutex@4

; 3525 :     }
; 3526 :    else 

	jmp	SHORT $LN24@draw_scree
$LN26@draw_scree:

; 3527 :      glutPostRedisplay();

	call	_glutPostRedisplay@0
$LN24@draw_scree:

; 3528 :   }
; 3529 : 
; 3530 :   if ( SDIM != td->olddim )

	mov	ecx, DWORD PTR _web+616
	cmp	ecx, DWORD PTR [edi+148]
	je	SHORT $LN23@draw_scree

; 3531 :   { reshape_func(td->xsize,td->ysize);  /* in case dimension changes */

	mov	edx, DWORD PTR [edi+252]
	mov	eax, DWORD PTR [edi+248]
	push	edx
	push	eax
	call	_reshape_func

; 3532 :     td->olddim = SDIM;

	mov	ecx, DWORD PTR _web+616
	add	esp, 8
	mov	DWORD PTR [edi+148], ecx
$LN23@draw_scree:

; 3533 :   }
; 3534 : 
; 3535 :   if ( web.sdim > 2 )

	cmp	DWORD PTR _web+616, 2
	jle	SHORT $LN22@draw_scree

; 3536 :   {  glEnable(GL_LIGHT0);

	mov	esi, DWORD PTR __imp__glEnable@4
	push	16384					; 00004000H
	call	esi

; 3537 :      glEnable(GL_LIGHTING);

	push	2896					; 00000b50H
	call	esi

; 3538 :   }
; 3539 :   else 

	jmp	SHORT $LN21@draw_scree
$LN22@draw_scree:

; 3540 :      glDisable(GL_LIGHTING);

	push	2896					; 00000b50H
	call	DWORD PTR __imp__glDisable@4
	mov	esi, DWORD PTR __imp__glEnable@4
$LN21@draw_scree:

; 3541 : 
; 3542 :   /*glEnable(GL_LIGHT1); */
; 3543 : 
; 3544 :   GL_ERROR_CHECK
; 3545 : 
; 3546 :   /* clear screen and zbuffer */
; 3547 :   glClearColor(rgba[background_color][0], 
; 3548 :           rgba[background_color][1],
; 3549 :           rgba[background_color][2],    
; 3550 :           rgba[background_color][3]
; 3551 :           );

	mov	eax, DWORD PTR _background_color
	shl	eax, 4
	fld	DWORD PTR _rgba[eax+12]
	sub	esp, 16					; 00000010H
	fstp	DWORD PTR [esp+12]
	fld	DWORD PTR _rgba[eax+8]
	fstp	DWORD PTR [esp+8]
	fld	DWORD PTR _rgba[eax+4]
	fstp	DWORD PTR [esp+4]
	fld	DWORD PTR _rgba[eax]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glClearColor@16

; 3552 :          
; 3553 :   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

	push	16640					; 00004100H
	call	DWORD PTR __imp__glClear@4

; 3554 : 
; 3555 :   if ( backcull_flag ) { glEnable(GL_CULL_FACE); }

	push	2884					; 00000b44H
	cmp	DWORD PTR _backcull_flag, ebx
	je	SHORT $LN20@draw_scree
	call	esi
	jmp	SHORT $LN19@draw_scree
$LN20@draw_scree:

; 3556 :   else { glDisable(GL_CULL_FACE); }

	call	DWORD PTR __imp__glDisable@4
$LN19@draw_scree:

; 3557 : 
; 3558 :   glDepthFunc(GL_LEQUAL); /* so later things get drawn */

	push	515					; 00000203H
	call	DWORD PTR __imp__glDepthFunc@4

; 3559 : 
; 3560 : #ifdef GGG
; 3561 : original loading of view matrix
; 3562 :   /* make sure global view matrix is same as first window */
; 3563 :   if ( td->win_id == 1 )
; 3564 :   { 
; 3565 :     for ( i = 0 ; i < HOMDIM ; i++ )
; 3566 :       for ( j = 0 ; j < HOMDIM ; j++ )
; 3567 :         view[i][j] = td->view[i][j];
; 3568 :   }
; 3569 : 
; 3570 :   glMatrixMode(GL_MODELVIEW);
; 3571 :   for ( i = 0 ; i < 4 ; i++ )
; 3572 :     for ( j = 0 ; j < 4 ; j++ )
; 3573 :       viewf[i][j] = td->view[(j<3)?j:(SDIM)][(i<3)?i:(SDIM)];
; 3574 :   if ( SDIM == 2 ) 
; 3575 :   { for ( i = 0 ; i < 3 ; i++ ) viewf[i][2] = viewf[2][i] = 0.0;
; 3576 :     viewf[2][2] = 1.0;
; 3577 :   }
; 3578 :   /* transpose, picking first 3 coordinates */
; 3579 :   if ( (td->projmode == P_PERSP) || td->stereomode ) 
; 3580 :   {   if ( SDIM == 2 ) viewf[3][2] -= 16;
; 3581 :       else viewf[3][0] -= 16.0;
; 3582 :   } 
; 3583 :   GL_ERROR_CHECK
; 3584 : 
; 3585 : 
; 3586 :   glLoadMatrixd(viewf[0]); 
; 3587 :   #endif
; 3588 :   
; 3589 :   /* for picking */
; 3590 :   if ( !td->arraysflag ) { glInitNames();  glPushName(0);

	cmp	DWORD PTR [edi+9772], ebx
	jne	SHORT $LN158@draw_scree
	call	DWORD PTR __imp__glInitNames@0
	push	ebx
	call	DWORD PTR __imp__glPushName@4

; 3591 :    
; 3592 :   /*{int depth;
; 3593 :     glGetIntegerv(GL_NAME_STACK_DEPTH,&depth);
; 3594 :     printf("OpenGL name stack depth: %d\n",depth);
; 3595 : 
; 3596 :   }
; 3597 :   */
; 3598 : 
; 3599 :   }
; 3600 : 
; 3601 :   if ( td->arraysflag && !td->multi_dlist_flag )

	cmp	DWORD PTR [edi+9772], ebx
	je	SHORT $LN16@draw_scree
$LN158@draw_scree:
	cmp	DWORD PTR [edi+1752], ebx
	jne	SHORT $LN16@draw_scree

; 3602 :     if ( td->declared_timestamp < td->arrays_timestamp )

	mov	edx, DWORD PTR [edi+136]
	cmp	edx, DWORD PTR [edi+132]
	jge	SHORT $LN16@draw_scree

; 3603 :       declare_arrays();

	call	_declare_arrays
$LN16@draw_scree:

; 3604 : 
; 3605 :   /* Now the actual drawing */
; 3606 :   if ( td->stereomode )

	cmp	DWORD PTR [edi+1700], ebx
	je	SHORT $LN15@draw_scree

; 3607 :   { int w = (SDIM==2) ? 0 : 1;

	xor	eax, eax
	cmp	DWORD PTR _web+616, 2

; 3608 :     /* Stereo mode always perspective */
; 3609 :     glMatrixMode(GL_MODELVIEW);

	push	5888					; 00001700H
	setne	al

; 3610 :     viewf[3][w] -= 1.5; glLoadMatrixd(viewf[0]); draw_one_image();

	lea	esi, DWORD PTR _viewf$[ebp+eax*8+96]
	call	DWORD PTR __imp__glMatrixMode@4
	fld	QWORD PTR [esi]
	fsub	QWORD PTR __real@3ff8000000000000
	lea	ecx, DWORD PTR _viewf$[ebp]
	push	ecx
	fstp	QWORD PTR [esi]
	call	DWORD PTR __imp__glLoadMatrixd@4
	call	_draw_one_image

; 3611 :     glMatrixMode(GL_MODELVIEW);

	push	5888					; 00001700H
	call	DWORD PTR __imp__glMatrixMode@4

; 3612 :     viewf[3][w] += 3.0; glLoadMatrixd(viewf[0]); draw_one_image();

	fld	QWORD PTR [esi]
	fadd	QWORD PTR __real@4008000000000000
	lea	edx, DWORD PTR _viewf$[ebp]
	push	edx
	fstp	QWORD PTR [esi]
	call	DWORD PTR __imp__glLoadMatrixd@4
$LN15@draw_scree:

; 3613 :   }
; 3614 :   else draw_one_image();

	call	_draw_one_image

; 3615 : 
; 3616 :   if ( display_text_count )

	cmp	DWORD PTR _display_text_count, ebx
	je	SHORT $LN13@draw_scree

; 3617 :     glut_text_display();  /* draw text lines */ 

	call	_glut_text_display
$LN13@draw_scree:

; 3618 : 
; 3619 :   glFlush();

	mov	ebx, DWORD PTR __imp__glFlush@0
	call	ebx

; 3620 :   glutSwapBuffers();  

	call	_glutSwapBuffers@0

; 3621 : 
; 3622 :   temp_free_all();  /* should free just graphics thread temps */

	call	_temp_free_all

; 3623 : 
; 3624 : #ifdef __cplusplus
; 3625 :   }
; 3626 :   catch(...)
; 3627 :   {
; 3628 :   }
; 3629 : #endif
; 3630 : 
; 3631 : 
; 3632 :   glutIdleFunc(idle_func);

	push	OFFSET _idle_func
	call	_glutIdleFunc@4

; 3633 : 
; 3634 : #ifdef __L_EVOLVER__
; 3635 :   //psu inserted code, writes png image for each "Saving png" request
; 3636 : if (take_snapshot > 0)

	cmp	DWORD PTR _take_snapshot, 0
	mov	esi, DWORD PTR _bmp$[ebp]
	jle	$LN12@draw_scree

; 3637 : {
; 3638 : 			//Automatically create a filename
; 3639 : 		take_snapshot--;
; 3640 : 		if(FileCounter == 0){			//Initialize: craft TimeString.

	mov	eax, DWORD PTR ?FileCounter@?1??draw_screen@@9@9
	dec	DWORD PTR _take_snapshot
	test	eax, eax
	jne	SHORT $LN11@draw_scree

; 3641 : 			time_t t;
; 3642 : 			struct tm *date;
; 3643 : 
; 3644 : 			time(&t);

	lea	eax, DWORD PTR _t$95993[ebp]
	push	eax
	call	__time64

; 3645 : 			date = localtime(&t);

	lea	ecx, DWORD PTR _t$95993[ebp]
	push	ecx
	call	__localtime64

; 3646 : 
; 3647 : 			sprintf(TimeString, "%4u%02u%02u_%02u%02u%02u", date->tm_year + 1900, date->tm_mon + 1, date->tm_mday
; 3648 : 					, date->tm_hour, date->tm_min, date->tm_sec);

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	push	edx
	mov	edx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR [eax+12]
	push	edx
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [eax+20]
	push	ecx
	inc	edx
	push	edx
	add	eax, 1900				; 0000076cH
	push	eax
	push	OFFSET ??_C@_0BJ@CJNCHCIE@?$CF4u?$CF02u?$CF02u_?$CF02u?$CF02u?$CF02u?$AA@
	push	OFFSET ?TimeString@?1??draw_screen@@9@9
	call	_sprintf
	mov	eax, DWORD PTR ?FileCounter@?1??draw_screen@@9@9
	add	esp, 40					; 00000028H
$LN11@draw_scree:

; 3649 : 		}
; 3650 : 		/* 
; 3651 : 		if (!png_full_name[0])
; 3652 : 		{
; 3653 : 			if (!png_prefix[0])
; 3654 : 				sprintf(fname, "./%s_%06u.png", TimeString, FileCounter);
; 3655 : 			else
; 3656 : 				sprintf(fname, "./%s_%06u.png", png_prefix, FileCounter);
; 3657 : 		}
; 3658 : 		else
; 3659 : 			sprintf(fname, "./%s.png", png_full_name);
; 3660 : 		*/ 
; 3661 : 		if (png_full_name[0] == '\0')

	cmp	BYTE PTR _png_full_name, 0
	jne	SHORT $LN10@draw_scree

; 3662 : 		{
; 3663 : 			if (png_prefix[0] == '\0')

	cmp	BYTE PTR _png_prefix, 0

; 3664 : 				sprintf(fname, "%s_%06u.png", TimeString, FileCounter);

	push	eax
	jne	SHORT $LN9@draw_scree
	push	OFFSET ?TimeString@?1??draw_screen@@9@9
	lea	ecx, DWORD PTR _fname$[ebp]
	push	OFFSET ??_C@_0M@ILKLMOHH@?$CFs_?$CF06u?4png?$AA@
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 3665 : 			else

	jmp	SHORT $LN7@draw_scree
$LN9@draw_scree:

; 3666 : 				sprintf(fname, "%s_%06u.png", png_prefix, FileCounter);

	push	OFFSET _png_prefix
	lea	edx, DWORD PTR _fname$[ebp]
	push	OFFSET ??_C@_0M@ILKLMOHH@?$CFs_?$CF06u?4png?$AA@
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 3667 : 		}
; 3668 : 		else

	jmp	SHORT $LN7@draw_scree
$LN10@draw_scree:

; 3669 : 			sprintf(fname, "%s.png", png_full_name);

	push	OFFSET _png_full_name
	lea	eax, DWORD PTR _fname$[ebp]
	push	OFFSET ??_C@_06PJLGDGG@?$CFs?4png?$AA@
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN7@draw_scree:

; 3670 : 		FileCounter++;

	inc	DWORD PTR ?FileCounter@?1??draw_screen@@9@9

; 3671 : 
; 3672 : 	//Grab them pixels.
; 3673 : 	glFlush(); //Added by Ben Schaeffer 

	call	ebx

; 3674 : 	glFinish();  

	call	DWORD PTR __imp__glFinish@0

; 3675 : 	glPixelStorei(GL_PACK_ALIGNMENT, 1);

	mov	ebx, DWORD PTR __imp__glPixelStorei@8
	push	1
	push	3333					; 00000d05H
	call	ebx

; 3676 : 	glReadPixels(0, 0, td->xsize, td->ysize, GL_RGB, GL_UNSIGNED_BYTE, bmp);

	mov	ecx, DWORD PTR [edi+252]
	mov	edx, DWORD PTR [edi+248]
	push	esi
	push	5121					; 00001401H
	push	6407					; 00001907H
	push	ecx
	push	edx
	push	0
	push	0
	call	DWORD PTR __imp__glReadPixels@28

; 3677 : 	glPixelStorei(GL_PACK_ALIGNMENT, 4);

	push	4
	push	3333					; 00000d05H
	call	ebx

; 3678 : 
; 3679 : 	//Flip the image so that the origin is at top left. Blatanly copied from some forum, changed to C and some other minor adjustments.
; 3680 : 	for(y = 0; y < (td->ysize >> 1); y++){

	mov	ecx, DWORD PTR [edi+252]
	xor	ebx, ebx
	mov	DWORD PTR _y$[ebp], ebx
	test	ecx, -2					; fffffffeH
	jle	$LN4@draw_scree
	mov	eax, DWORD PTR [edi+248]
$LN6@draw_scree:

; 3681 : 		const int swapY = td->ysize - y - 1;

	sub	ecx, ebx
	dec	ecx

; 3682 : 		for(x = 0; x < td->xsize; x++){

	xor	edx, edx
	mov	DWORD PTR _swapY$96004[ebp], ecx
	test	eax, eax
	jle	$LN5@draw_scree
	npad	14
$LL142@draw_scree:

; 3683 : 			const int offset = 3*(x + y*td->xsize);

	mov	ecx, DWORD PTR [edi+248]
	mov	eax, ecx

; 3684 : 			const int swapOffset = 3*(x + swapY*td->xsize);

	imul	ecx, DWORD PTR _swapY$96004[ebp]
	imul	eax, ebx
	add	eax, edx
	lea	eax, DWORD PTR [eax+eax*2]

; 3685 : 
; 3686 : 			t = bmp[offset];

	movzx	ebx, BYTE PTR [eax+esi]
	mov	BYTE PTR _t$[ebp], bl
	add	ecx, edx
	lea	ecx, DWORD PTR [ecx+ecx*2]

; 3687 : 			bmp[offset] = bmp[swapOffset];

	movzx	ebx, BYTE PTR [ecx+esi]
	mov	BYTE PTR [eax+esi], bl

; 3688 : 			bmp[swapOffset] = t;

	movzx	ebx, BYTE PTR _t$[ebp]
	mov	BYTE PTR [ecx+esi], bl

; 3689 : 
; 3690 : 			t = bmp[offset + 1];

	movzx	ebx, BYTE PTR [esi+eax+1]
	mov	BYTE PTR _t$[ebp], bl

; 3691 : 			bmp[offset + 1] = bmp[swapOffset + 1];

	movzx	ebx, BYTE PTR [esi+ecx+1]
	mov	BYTE PTR [esi+eax+1], bl

; 3692 : 			bmp[swapOffset + 1] = t;

	movzx	ebx, BYTE PTR _t$[ebp]
	mov	BYTE PTR [esi+ecx+1], bl

; 3693 : 
; 3694 : 			t = bmp[offset + 2];

	movzx	ebx, BYTE PTR [esi+eax+2]
	mov	BYTE PTR _t$[ebp], bl

; 3695 : 			bmp[offset + 2] = bmp[swapOffset + 2];

	movzx	ebx, BYTE PTR [esi+ecx+2]
	mov	BYTE PTR [esi+eax+2], bl

; 3696 : 			bmp[swapOffset + 2] = t;

	mov	al, BYTE PTR _t$[ebp]
	mov	ebx, DWORD PTR _y$[ebp]
	mov	BYTE PTR [esi+ecx+2], al
	mov	eax, DWORD PTR [edi+248]
	inc	edx
	cmp	edx, eax
	jl	$LL142@draw_scree
$LN5@draw_scree:

; 3678 : 
; 3679 : 	//Flip the image so that the origin is at top left. Blatanly copied from some forum, changed to C and some other minor adjustments.
; 3680 : 	for(y = 0; y < (td->ysize >> 1); y++){

	mov	ecx, DWORD PTR [edi+252]
	mov	edx, ecx
	inc	ebx
	sar	edx, 1
	mov	DWORD PTR _y$[ebp], ebx
	cmp	ebx, edx
	jl	$LN6@draw_scree
$LN4@draw_scree:

; 3697 : 		}
; 3698 : 	}
; 3699 : 
; 3700 : 	remove(fname);		//Kill it if it exists.

	lea	eax, DWORD PTR _fname$[ebp]
	push	eax
	call	_remove

; 3701 : 	out_file = fopen(fname, "wb");

	lea	ecx, DWORD PTR _fname$[ebp]
	push	OFFSET ??_C@_02GMLFBBN@wb?$AA@
	push	ecx
	call	_fopen

; 3702 : 	write_png(out_file, td->xsize, td->ysize, bmp, NULL);

	mov	edx, DWORD PTR [edi+252]
	push	0
	push	esi
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+248]
	push	edx
	push	eax
	push	ebx
	call	_write_png

; 3703 : 	fclose(out_file);

	push	ebx
	call	_fclose
	add	esp, 36					; 00000024H
$LN12@draw_scree:

; 3704 : 	
; 3705 : }
; 3706 : free(bmp);

	push	esi
	call	_free
	add	esp, 4
$LN81@draw_scree:

; 3707 :   //end psu
; 3708 : #endif
; 3709 : } /* end draw_screen() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_draw_screen ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@NFCLMKEC@Picked?5facet?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0CA@KHAGLGHJ@Picked?5facet?5subdivision?5edge?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@FOBHGBGJ@Picked?5edge?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0BC@EGCKKLCI@Picked?5vertex?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0EH@HOKJDPPH@Pick?5buffer?5overflow?$DL?5selected?5e@ ; `string'
PUBLIC	__real@4010000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_pick_func
EXTRN	_NULLEDGE:DWORD
EXTRN	_global_timestamp:DWORD
EXTRN	_gluPickMatrix@36:PROC
EXTRN	__imp__glRenderMode@4:PROC
EXTRN	__imp__glSelectBuffer@8:PROC
;	COMDAT ??_C@_0BB@NFCLMKEC@Picked?5facet?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BB@NFCLMKEC@Picked?5facet?5?$CFd?6?$AA@ DB 'Picked facet %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KHAGLGHJ@Picked?5facet?5subdivision?5edge?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@KHAGLGHJ@Picked?5facet?5subdivision?5edge?4?6?$AA@ DB 'Picked f'
	DB	'acet subdivision edge.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FOBHGBGJ@Picked?5edge?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BA@FOBHGBGJ@Picked?5edge?5?$CFd?6?$AA@ DB 'Picked edge %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EGCKKLCI@Picked?5vertex?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BC@EGCKKLCI@Picked?5vertex?5?$CFd?6?$AA@ DB 'Picked vertex %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@HOKJDPPH@Pick?5buffer?5overflow?$DL?5selected?5e@
CONST	SEGMENT
??_C@_0EH@HOKJDPPH@Pick?5buffer?5overflow?$DL?5selected?5e@ DB 'Pick buff'
	DB	'er overflow; selected element may not be foreground element.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _pick_func
_TEXT	SEGMENT
_enearz$ = -44						; size = 4
_fnearz$ = -40						; size = 4
_f_id$ = -36						; size = 4
_v_id$ = -32						; size = 4
_vnearz$ = -28						; size = 4
_hits$ = -24						; size = 4
_viewport$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_pick_func PROC						; COMDAT

; 1045 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 1046 :   struct graph_thread_data *td = GET_DATA;

	call	_glutGetWindow@0
	mov	esi, eax
	imul	esi, 9896				; 000026a8H

; 1047 :   GLint hits, viewport[4];
; 1048 :   int i,n;
; 1049 :   unsigned int enearz = 0xFFFFFFFF;

	or	eax, -1

; 1050 :   unsigned int fnearz = 0xFFFFFFFF;
; 1051 :   unsigned int vnearz = 0xFFFFFFFF;
; 1052 :   facet_id f_id = NULLID;
; 1053 :   edge_id e_id = NULLID;
; 1054 :   vertex_id v_id = NULLID;
; 1055 :   int count;
; 1056 : 
; 1057 :   glSelectBuffer(PICKBUFLENGTH,pickbuf);

	push	OFFSET _pickbuf
	xor	ebx, ebx
	push	500					; 000001f4H
	add	esi, OFFSET _gthread_data
	mov	DWORD PTR _enearz$[ebp], eax
	mov	DWORD PTR _fnearz$[ebp], eax
	mov	DWORD PTR _vnearz$[ebp], eax
	mov	DWORD PTR _f_id$[ebp], ebx
	mov	DWORD PTR _v_id$[ebp], ebx
	call	DWORD PTR __imp__glSelectBuffer@8

; 1058 :   glGetIntegerv(GL_VIEWPORT,viewport);

	lea	eax, DWORD PTR _viewport$[ebp]
	push	eax
	push	2978					; 00000ba2H
	call	DWORD PTR __imp__glGetIntegerv@8

; 1059 :   glMatrixMode(GL_PROJECTION);

	push	5889					; 00001701H
	call	DWORD PTR __imp__glMatrixMode@4

; 1060 :   glPushMatrix();

	call	DWORD PTR __imp__glPushMatrix@0

; 1061 :   glRenderMode(GL_SELECT);  /* see what picked when drawn */

	mov	edi, DWORD PTR __imp__glRenderMode@4
	push	7170					; 00001c02H
	call	edi

; 1062 :   glLoadIdentity();

	call	DWORD PTR __imp__glLoadIdentity@0

; 1063 :   gluPickMatrix(x,y,4,4,viewport);

	fld	QWORD PTR __real@4010000000000000
	lea	ecx, DWORD PTR _viewport$[ebp]
	push	ecx
	sub	esp, 32					; 00000020H
	fst	QWORD PTR [esp+24]
	fstp	QWORD PTR [esp+16]
	fild	DWORD PTR _y$[ebp]
	fstp	QWORD PTR [esp+8]
	fild	DWORD PTR _x$[ebp]
	fstp	QWORD PTR [esp]
	call	_gluPickMatrix@36

; 1064 :    
; 1065 :   glMultMatrixf(td->projmat);

	lea	edx, DWORD PTR [esi+1636]
	push	edx
	call	DWORD PTR __imp__glMultMatrixf@4

; 1066 :   if ( SDIM >= 3 ) glMultMatrixd(flip[0]);    /* don't know why, but need */

	cmp	DWORD PTR _web+616, 3
	jl	SHORT $LN24@pick_func
	push	OFFSET _flip
	jmp	SHORT $LN38@pick_func
$LN24@pick_func:

; 1067 :   else glMultMatrixd(flip2D[0]);

	push	OFFSET _flip2D
$LN38@pick_func:
	call	DWORD PTR __imp__glMultMatrixd@4

; 1068 : 
; 1069 :   pick_flag = 1;

	mov	DWORD PTR _pick_flag, 1

; 1070 :   if ( td->arraysflag )       /* have to turn arrays off during picking */

	cmp	DWORD PTR [esi+9772], ebx
	je	SHORT $LN22@pick_func

; 1071 :   { td->arraysflag = 0; graph_timestamp = ++global_timestamp; 

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR [esi+9772], ebx
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _graph_timestamp, eax

; 1072 :     draw_screen();

	call	_draw_screen

; 1073 :     td->arraysflag = 1; graph_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR [esi+9772], 1
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _graph_timestamp, eax

; 1074 :   }
; 1075 :   else

	jmp	SHORT $LN21@pick_func
$LN22@pick_func:

; 1076 :     draw_screen();

	call	_draw_screen
$LN21@pick_func:

; 1077 :   pick_flag = 0;
; 1078 : 
; 1079 :   hits = glRenderMode(GL_RENDER); /* back to ordinary drawing */

	push	7168					; 00001c00H
	mov	DWORD PTR _pick_flag, ebx
	call	edi
	mov	DWORD PTR _hits$[ebp], eax

; 1080 :   if ( hits < 0 ) 

	test	eax, eax
	jns	SHORT $LN20@pick_func

; 1081 :   { hits = PICKBUFLENGTH/4;  /* buffer overflow */
; 1082 :     kb_error(2173,
; 1083 :       "Pick buffer overflow; selected element may not be foreground element.\n",
; 1084 :         WARNING);

	push	2
	push	OFFSET ??_C@_0EH@HOKJDPPH@Pick?5buffer?5overflow?$DL?5selected?5e@
	push	2173					; 0000087dH
	mov	DWORD PTR _hits$[ebp], 125		; 0000007dH
	call	_kb_error
	mov	eax, DWORD PTR _hits$[ebp]
	add	esp, 12					; 0000000cH
$LN20@pick_func:

; 1085 :   }
; 1086 :   
; 1087 :   for ( i=0, n=0 ; (i < hits) && (n < PICKBUFLENGTH-4) ; i++, n += count + 3 )

	xor	edi, edi
	xor	edx, edx
	test	eax, eax
	jle	$LN17@pick_func
	npad	8
$LL19@pick_func:
	cmp	edx, 496				; 000001f0H
	jge	$LN17@pick_func

; 1088 :   { element_id id = name_to_id(pickbuf[n+3]);

	mov	eax, DWORD PTR _pickbuf[edx*4+12]
	push	eax
	call	_name_to_id

; 1089 :     count = pickbuf[n];

	mov	esi, DWORD PTR _pickbuf[edx*4]

; 1090 :     switch ( id_type(id) )

	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	add	esp, 4
	sub	ecx, 0
	je	SHORT $LN8@pick_func
	dec	ecx
	je	SHORT $LN12@pick_func
	dec	ecx
	jne	SHORT $LN18@pick_func

; 1091 :     { case FACET: 
; 1092 :         if ( pickbuf[n+1] < fnearz ) 

	mov	ecx, DWORD PTR _pickbuf[edx*4+4]
	cmp	ecx, DWORD PTR _fnearz$[ebp]
	jae	SHORT $LN18@pick_func

; 1093 :         { f_id = id; fnearz = pickbuf[n+1]; }

	mov	DWORD PTR _f_id$[ebp], eax
	mov	DWORD PTR _fnearz$[ebp], ecx

; 1094 :         break;

	jmp	SHORT $LN18@pick_func
$LN12@pick_func:

; 1095 :       case EDGE:
; 1096 :         if ( pickbuf[n+1] < enearz )

	mov	ecx, DWORD PTR _pickbuf[edx*4+4]
	cmp	ecx, DWORD PTR _enearz$[ebp]
	jae	SHORT $LN18@pick_func

; 1097 :           if ( valid_id(id) || !valid_id(e_id) )

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN9@pick_func
	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN18@pick_func
$LN9@pick_func:

; 1098 :           { e_id = id; enearz = pickbuf[n+1]; }

	mov	ebx, eax
	mov	DWORD PTR _enearz$[ebp], ecx

; 1099 :         break;

	jmp	SHORT $LN18@pick_func
$LN8@pick_func:

; 1100 :       case VERTEX: 
; 1101 :         if ( pickbuf[n+1] < vnearz )

	mov	ecx, DWORD PTR _pickbuf[edx*4+4]
	cmp	ecx, DWORD PTR _vnearz$[ebp]
	jae	SHORT $LN18@pick_func

; 1102 :           if ( valid_id(id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN18@pick_func

; 1103 :            { v_id = id; vnearz = pickbuf[n+1]; }

	mov	DWORD PTR _v_id$[ebp], eax
	mov	DWORD PTR _vnearz$[ebp], ecx
$LN18@pick_func:

; 1085 :   }
; 1086 :   
; 1087 :   for ( i=0, n=0 ; (i < hits) && (n < PICKBUFLENGTH-4) ; i++, n += count + 3 )

	inc	edi
	lea	edx, DWORD PTR [edx+esi+3]
	cmp	edi, DWORD PTR _hits$[ebp]
	jl	$LL19@pick_func
$LN17@pick_func:

; 1104 :         break;
; 1105 :        
; 1106 :     }
; 1107 :   }
; 1108 :   erroutstring("\n");  /* to get to next line after prompt */

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_erroutstring

; 1109 :   if ( valid_id(v_id) )

	mov	eax, DWORD PTR _v_id$[ebp]
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN36@pick_func

; 1110 :     { pickvnum = ordinal(v_id) + 1;
; 1111 :       #ifdef MPI_EVOLVER
; 1112 :       sprintf(msg,"Picked vertex %d@%d\n",pickvnum,id_task(v_id));
; 1113 :       #else
; 1114 :       sprintf(msg,"Picked vertex %d\n",pickvnum);

	mov	ecx, DWORD PTR _msg
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_0BC@EGCKKLCI@Picked?5vertex?5?$CFd?6?$AA@
	push	ecx
	mov	DWORD PTR _pickvnum, eax
	call	_sprintf

; 1115 :       #endif
; 1116 :       erroutstring(msg); 

	mov	edx, DWORD PTR _msg
	push	edx
	call	_erroutstring
	add	esp, 16					; 00000010H
$LN36@pick_func:

; 1117 :     }
; 1118 : 
; 1119 :   if ( valid_id(e_id) ) 

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN4@pick_func

; 1120 :   { 
; 1121 : #ifdef OLDPICKVERTEX
; 1122 :     /* check for vertex in common to picked edges */
; 1123 :     for ( i=0, n=0 ; (i < hits) && (n < PICKBUFLENGTH-4) ; i++, n += count+3 )
; 1124 :     { element_id id,ee_id;
; 1125 :       int ii,nn,ccount;
; 1126 : 
; 1127 :       count = pickbuf[n];
; 1128 :       id = name_to_id(pickbuf[n+3]);
; 1129 :       if ( (id_type(id) == EDGE) && valid_id(id) )
; 1130 :       { vertex_id v1 = get_edge_headv(id);
; 1131 :         vertex_id v2 = get_edge_tailv(id);
; 1132 :         for ( ii = i+1, nn = n+count+3 ; (ii < hits) && (n < PICKBUFLENGTH-4) ;
; 1133 :            ii++, nn += ccount + 3 )
; 1134 :         { ccount = pickbuf[nn];
; 1135 :           ee_id = name_to_id(pickbuf[nn+3]);
; 1136 :           if ( (id_type(ee_id) == EDGE) && valid_id(ee_id)
; 1137 :                && !equal_element(id,ee_id) )
; 1138 :           { if ( v1 == get_edge_tailv(ee_id) )
; 1139 :             { v_id = v1; break; }
; 1140 :             if ( v1 == get_edge_headv(ee_id) )
; 1141 :             { v_id = v1; break; }
; 1142 :             if ( v2 == get_edge_tailv(ee_id) )
; 1143 :             { v_id = v2; break; }
; 1144 :             if ( v2 == get_edge_headv(ee_id) )
; 1145 :             { v_id = v2; break; }
; 1146 :           }
; 1147 :         }
; 1148 :       }
; 1149 :     }
; 1150 :     if ( valid_id(v_id) )
; 1151 :     { pickvnum = ordinal(v_id) + 1;
; 1152 :       #ifdef MPI_EVOLVER
; 1153 :       sprintf(msg,"Picked vertex %d@%d\n",pickvnum,id_task(v_id));
; 1154 :       #else
; 1155 :       sprintf(msg,"Picked vertex %d\n",pickvnum);
; 1156 :       #endif
; 1157 :       erroutstring(msg); 
; 1158 :     }
; 1159 : #endif
; 1160 :     pickenum = ordinal(e_id) + 1;

	and	ebx, 134217727				; 07ffffffH
	lea	eax, DWORD PTR [ebx+1]

; 1161 :     #ifdef MPI_EVOLVER
; 1162 :     sprintf(msg,"Picked edge %d@%d\n",pickenum,id_task(e_id));
; 1163 :     #else
; 1164 :     sprintf(msg,"Picked edge %d\n",pickenum);

	push	eax
	mov	DWORD PTR _pickenum, eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0BA@FOBHGBGJ@Picked?5edge?5?$CFd?6?$AA@
	push	eax
	call	_sprintf

; 1165 :     #endif
; 1166 :     erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring
	add	esp, 16					; 00000010H

; 1167 :   }
; 1168 :   else 

	jmp	SHORT $LN37@pick_func
$LN4@pick_func:

; 1169 :   if ( e_id == NULLEDGE )

	cmp	ebx, DWORD PTR _NULLEDGE
	jne	SHORT $LN37@pick_func

; 1170 :      erroutstring("Picked facet subdivision edge.\n");

	push	OFFSET ??_C@_0CA@KHAGLGHJ@Picked?5facet?5subdivision?5edge?4?6?$AA@
	call	_erroutstring
	add	esp, 4
$LN37@pick_func:

; 1171 : 
; 1172 :   if ( valid_id(f_id) ) 

	mov	eax, DWORD PTR _f_id$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@pick_func

; 1173 :   { pickfnum = ordinal(f_id) + 1;
; 1174 :     #ifdef MPI_EVOLVER
; 1175 :     sprintf(msg,"Picked facet %d@%d\n",pickfnum,id_task(f_id));
; 1176 :     #else
; 1177 :     sprintf(msg,"Picked facet %d\n",pickfnum);

	mov	edx, DWORD PTR _msg
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_0BB@NFCLMKEC@Picked?5facet?5?$CFd?6?$AA@
	push	edx
	mov	DWORD PTR _pickfnum, eax
	call	_sprintf

; 1178 :     #endif
; 1179 :     erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring
	add	esp, 16					; 00000010H
$LN1@pick_func:

; 1180 :   }
; 1181 :   erroutstring(current_prompt);

	mov	ecx, DWORD PTR _current_prompt
	push	ecx
	call	_erroutstring
	add	esp, 4

; 1182 : 
; 1183 :   glMatrixMode(GL_PROJECTION);

	push	5889					; 00001701H
	call	DWORD PTR __imp__glMatrixMode@4

; 1184 :   glPopMatrix();

	call	DWORD PTR __imp__glPopMatrix@0

; 1185 : 
; 1186 : } /* end pick_func() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_pick_func ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@MCPLIHNM@Q?5?5Toggle?5printing?5some?5statisti@ ; `string'
PUBLIC	??_C@_0DF@EAAFAKBE@u?5?5Toggle?5window?5update?5every?5gr@ ; `string'
PUBLIC	??_C@_0EE@IGEKHONA@?5?5?5?5?5?5?5Caution?3?5assumes?5display?5@ ; `string'
PUBLIC	??_C@_0DF@LENOJMBC@Y?5?5One?9time?5coloring?5of?5strips?5g@ ; `string'
PUBLIC	??_C@_0CA@HEEGFBPG@S?5?5Use?5element?5strips?0?5now?5OFF?6?$AA@ ; `string'
PUBLIC	??_C@_0EK@HJJHCJHC@S?5?5Use?5element?5strips?0?5now?5ON?5?$CIi@ ; `string'
PUBLIC	??_C@_0CH@IHOCAOJJ@i?5?5Interleaved?5vertex?5arrays?0?5no@ ; `string'
PUBLIC	??_C@_0CG@FIKHPDDO@i?5?5Interleaved?5vertex?5arrays?0?5no@ ; `string'
PUBLIC	??_C@_0CD@KAEIJMNC@I?5?5Indexed?5vertex?5arrays?0?5now?5OF@ ; `string'
PUBLIC	??_C@_0CC@PAHEBCEP@I?5?5Indexed?5vertex?5arrays?0?5now?5ON@ ; `string'
PUBLIC	??_C@_0DC@LAEMLPBH@a?5?5Toggle?5using?5vertex?5and?5color@ ; `string'
PUBLIC	??_C@_0DB@COCNINNF@a?5?5Toggle?5using?5vertex?5and?5color@ ; `string'
PUBLIC	??_C@_0CH@OHLPFLNI@D?5?5Toggle?5using?5display?5list?0?5no@ ; `string'
PUBLIC	??_C@_0CG@LFHMGHKB@D?5?5Toggle?5using?5display?5list?0?5no@ ; `string'
PUBLIC	??_C@_0DE@HNHMJFGL@?6Following?5for?5fiddling?5with?5Ope@ ; `string'
PUBLIC	??_C@_0BD@CEBDGLIN@x?5?5Close?5graphics?6?$AA@	; `string'
PUBLIC	??_C@_0BK@IGMDJEJH@H?5?5Guru?9level?5help?5items?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@NHNCJPMP@G?5?5Another?5graphics?5window?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@PJMOLLKK@arrow?5keys?5?5translate?5image?6?$AA@ ; `string'
PUBLIC	??_C@_0DA@JMJKJFLN@F?5?5Set?5rotate?1zoom?5focus?5to?5last@ ; `string'
PUBLIC	??_C@_0BN@DEHHMEEM@s?5?5Toggle?5cross?9eyed?5stereo?6?$AA@ ; `string'
PUBLIC	??_C@_0DN@JGDGMKJF@p?5?5Toggle?5orthogonal?1perspective@ ; `string'
PUBLIC	??_C@_0DO@LOPOMPDI@p?5?5Toggle?5orthogonal?1perspective@ ; `string'
PUBLIC	??_C@_0CD@FHPGLNOB@f?5?5Toggle?5showing?5facets?0?5now?5OF@ ; `string'
PUBLIC	??_C@_0CC@CMACHMNL@f?5?5Toggle?5showing?5facets?0?5now?5ON@ ; `string'
PUBLIC	??_C@_0CG@EJFEMILG@e?5?5Toggle?5showing?5all?5edges?0?5now@ ; `string'
PUBLIC	??_C@_0CF@IPIFEDEJ@e?5?5Toggle?5showing?5all?5edges?0?5now@ ; `string'
PUBLIC	??_C@_0BB@GFNELJDI@m?5?5Center?5image?6?$AA@	; `string'
PUBLIC	??_C@_0P@IDDHFCHH@R?5?5Reset?5view?6?$AA@	; `string'
PUBLIC	??_C@_0DF@IEAODFDM@g?5?5Gourard?5shading?5?$CIsmooth?5shadi@ ; `string'
PUBLIC	??_C@_0DE@CHOFKLM@g?5?5Gourard?5shading?5?$CIsmooth?5shadi@ ; `string'
PUBLIC	??_C@_0CG@NIOPGKA@b?5?5Decrease?5edge?5front?5bias?5by?50@ ; `string'
PUBLIC	??_C@_0CG@KCDOIPPP@B?5?5Increase?5edge?5front?5bias?5by?50@ ; `string'
PUBLIC	??_C@_0BB@FGLFIDDM@w?5?5Narrow?5edges?6?$AA@	; `string'
PUBLIC	??_C@_0BA@NJAKALEC@W?5?5Widen?5edges?6?$AA@	; `string'
PUBLIC	??_C@_0CE@GAIPGBG@c?5?5Clockwise?1counterclockwise?5mo@ ; `string'
PUBLIC	??_C@_0DA@MAJNEPON@c?5?5Clockwise?1counterclockwise?5mo@ ; `string'
PUBLIC	??_C@_0CE@GELNMPKP@z?5?5Zoom?5mode?5for?5left?5mouse?5butt@ ; `string'
PUBLIC	??_C@_0DA@GALHLAFO@z?5?5Zoom?5mode?5for?5left?5mouse?5butt@ ; `string'
PUBLIC	??_C@_0CJ@NAOFHFMM@t?5?5Translate?5mode?5for?5left?5mouse@ ; `string'
PUBLIC	??_C@_0DF@DNBEHPIM@t?5?5Translate?5mode?5for?5left?5mouse@ ; `string'
PUBLIC	??_C@_0CG@DDAEAOJF@r?5?5Rotate?5mode?5for?5left?5mouse?5bu@ ; `string'
PUBLIC	??_C@_0DC@JKFOBBMH@r?5?5Rotate?5mode?5for?5left?5mouse?5bu@ ; `string'
PUBLIC	??_C@_0BH@MOLLDJEK@Graphics?5window?5keys?3?6?$AA@ ; `string'
PUBLIC	??_C@_0CG@PJAOEABK@Left?5mouse?3?5move?5?5?5Right?5mouse?3?5@ ; `string'
PUBLIC	??_C@_0BI@JPLBIKBO@?6Graphics?5window?5help?3?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@ECBCNCDM@?6Printing?5drawing?5stats?5OFF?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@BCEAOIIG@?6Printing?5drawing?5stats?5ON?6?$AA@ ; `string'
PUBLIC	??_C@_0CE@CBJJCPNH@?6OpenGL?5projection?5now?5ORTHOGONA@ ; `string'
PUBLIC	??_C@_0CF@PDEPPJ@?6OpenGL?5projection?5now?5PERSPECTI@ ; `string'
PUBLIC	??_C@_0CL@OFFEDINK@?6OpenGL?5projection?5now?5CROSS?9EYE@ ; `string'
PUBLIC	??_C@_0CA@LKLNOBMP@?6OpenGL?5vertex_arrays?5now?5OFF?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@FNKMINJN@?6OpenGL?5vertex?5arrays?5now?5ON?4?6?$AA@ ; `string'
PUBLIC	__real@3f000000
PUBLIC	??_C@_0EA@BOJOBDMK@Vertex?5arrays?5require?5OpenGL?5ver@ ; `string'
PUBLIC	??_C@_03GCKCNDHP@1?41?$AA@			; `string'
PUBLIC	??_C@_0CF@CDCECBKF@?6OpenGL?5multiple?5display?5lists?5O@ ; `string'
PUBLIC	??_C@_0CE@GPALKADI@?6OpenGL?5multiple?5display?5lists?5O@ ; `string'
PUBLIC	??_C@_0BP@OCNIMDOP@?6OpenGL?5display?5list?5now?5OFF?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@HFMKKJDN@?6OpenGL?5arrays?5now?5OFF?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@PCPEEBAG@?6OpenGL?5display?5list?5now?5ON?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@LIJFFNDP@?6?6Set?5Focus?3?5pickvnum?5?$CFd?5is?5inva@ ; `string'
PUBLIC	??_C@_0BF@EMFALJHA@Element?5strips?5OFF?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@KLOEJEOO@Element?5strips?5ON?4?6?$AA@	; `string'
PUBLIC	??_C@_0BF@HMHMNFCK@Array?5indexing?5OFF?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@DCHHCHAB@Array?5indexing?5ON?4?6?$AA@	; `string'
PUBLIC	??_C@_0BD@FBIOPEFB@Interleaving?5OFF?4?6?$AA@	; `string'
PUBLIC	??_C@_0BC@MCLJNBPO@Interleaving?5ON?4?6?$AA@	; `string'
PUBLIC	__real@4023cccccccccccd
PUBLIC	__real@3fe3333333333333
PUBLIC	??_C@_0BJ@PMICCHIL@?6Edge?5front?5bias?5now?5?$CFf?6?$AA@ ; `string'
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	_draw_thread
PUBLIC	__$ArrayPad$
PUBLIC	_key_func
EXTRN	__imp__ExitProcess@4:PROC
EXTRN	_glutDetachMenu@4:PROC
EXTRN	_glutAttachMenu@4:PROC
EXTRN	_glutSetMenu@4:PROC
EXTRN	__imp__glDisableClientState@4:PROC
EXTRN	_torus_display_mode:DWORD
EXTRN	_dymem:DWORD
EXTRN	_valid_element:PROC
EXTRN	_get_ordinal_id:PROC
EXTRN	_myfree:PROC
EXTRN	_kb_calloc:PROC
EXTRN	_bbox_maxy:QWORD
EXTRN	_bbox_miny:QWORD
EXTRN	_bbox_maxx:QWORD
EXTRN	_bbox_minx:QWORD
EXTRN	_do_gfile:PROC
EXTRN	_resize:PROC
EXTRN	_floor:PROC
_BSS	SEGMENT
_mainmenu DD	01H DUP (?)
_opengl_version DB 014H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DD@MCPLIHNM@Q?5?5Toggle?5printing?5some?5statisti@
CONST	SEGMENT
??_C@_0DD@MCPLIHNM@Q?5?5Toggle?5printing?5some?5statisti@ DB 'Q  Toggle p'
	DB	'rinting some statistics during drawing', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EAAFAKBE@u?5?5Toggle?5window?5update?5every?5gr@
CONST	SEGMENT
??_C@_0DF@EAAFAKBE@u?5?5Toggle?5window?5update?5every?5gr@ DB 'u  Toggle '
	DB	'window update every graphics command, now ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@IGEKHONA@?5?5?5?5?5?5?5Caution?3?5assumes?5display?5@
CONST	SEGMENT
??_C@_0EE@IGEKHONA@?5?5?5?5?5?5?5Caution?3?5assumes?5display?5@ DB '     '
	DB	'  Caution: assumes display facets same as real, with no gaps.'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LENOJMBC@Y?5?5One?9time?5coloring?5of?5strips?5g@
CONST	SEGMENT
??_C@_0DF@LENOJMBC@Y?5?5One?9time?5coloring?5of?5strips?5g@ DB 'Y  One-ti'
	DB	'me coloring of strips generated in S mode.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HEEGFBPG@S?5?5Use?5element?5strips?0?5now?5OFF?6?$AA@
CONST	SEGMENT
??_C@_0CA@HEEGFBPG@S?5?5Use?5element?5strips?0?5now?5OFF?6?$AA@ DB 'S  Us'
	DB	'e element strips, now OFF', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@HJJHCJHC@S?5?5Use?5element?5strips?0?5now?5ON?5?$CIi@
CONST	SEGMENT
??_C@_0EK@HJJHCJHC@S?5?5Use?5element?5strips?0?5now?5ON?5?$CIi@ DB 'S  Us'
	DB	'e element strips, now ON (indexed elements automatically turn'
	DB	'ed on)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@IHOCAOJJ@i?5?5Interleaved?5vertex?5arrays?0?5no@
CONST	SEGMENT
??_C@_0CH@IHOCAOJJ@i?5?5Interleaved?5vertex?5arrays?0?5no@ DB 'i  Interle'
	DB	'aved vertex arrays, now OFF', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FIKHPDDO@i?5?5Interleaved?5vertex?5arrays?0?5no@
CONST	SEGMENT
??_C@_0CG@FIKHPDDO@i?5?5Interleaved?5vertex?5arrays?0?5no@ DB 'i  Interle'
	DB	'aved vertex arrays, now ON', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KAEIJMNC@I?5?5Indexed?5vertex?5arrays?0?5now?5OF@
CONST	SEGMENT
??_C@_0CD@KAEIJMNC@I?5?5Indexed?5vertex?5arrays?0?5now?5OF@ DB 'I  Indexe'
	DB	'd vertex arrays, now OFF', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PAHEBCEP@I?5?5Indexed?5vertex?5arrays?0?5now?5ON@
CONST	SEGMENT
??_C@_0CC@PAHEBCEP@I?5?5Indexed?5vertex?5arrays?0?5now?5ON@ DB 'I  Indexe'
	DB	'd vertex arrays, now ON', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LAEMLPBH@a?5?5Toggle?5using?5vertex?5and?5color@
CONST	SEGMENT
??_C@_0DC@LAEMLPBH@a?5?5Toggle?5using?5vertex?5and?5color@ DB 'a  Toggle '
	DB	'using vertex and color arrays, now OFF', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@COCNINNF@a?5?5Toggle?5using?5vertex?5and?5color@
CONST	SEGMENT
??_C@_0DB@COCNINNF@a?5?5Toggle?5using?5vertex?5and?5color@ DB 'a  Toggle '
	DB	'using vertex and color arrays, now ON', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OHLPFLNI@D?5?5Toggle?5using?5display?5list?0?5no@
CONST	SEGMENT
??_C@_0CH@OHLPFLNI@D?5?5Toggle?5using?5display?5list?0?5no@ DB 'D  Toggle'
	DB	' using display list, now OFF', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LFHMGHKB@D?5?5Toggle?5using?5display?5list?0?5no@
CONST	SEGMENT
??_C@_0CG@LFHMGHKB@D?5?5Toggle?5using?5display?5list?0?5no@ DB 'D  Toggle'
	DB	' using display list, now ON', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@HNHMJFGL@?6Following?5for?5fiddling?5with?5Ope@
CONST	SEGMENT
??_C@_0DE@HNHMJFGL@?6Following?5for?5fiddling?5with?5Ope@ DB 0aH, 'Follow'
	DB	'ing for fiddling with OpenGL drawing modes:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CEBDGLIN@x?5?5Close?5graphics?6?$AA@
CONST	SEGMENT
??_C@_0BD@CEBDGLIN@x?5?5Close?5graphics?6?$AA@ DB 'x  Close graphics', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IGMDJEJH@H?5?5Guru?9level?5help?5items?6?$AA@
CONST	SEGMENT
??_C@_0BK@IGMDJEJH@H?5?5Guru?9level?5help?5items?6?$AA@ DB 'H  Guru-level'
	DB	' help items', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NHNCJPMP@G?5?5Another?5graphics?5window?6?$AA@
CONST	SEGMENT
??_C@_0BM@NHNCJPMP@G?5?5Another?5graphics?5window?6?$AA@ DB 'G  Another g'
	DB	'raphics window', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PJMOLLKK@arrow?5keys?5?5translate?5image?6?$AA@
CONST	SEGMENT
??_C@_0BN@PJMOLLKK@arrow?5keys?5?5translate?5image?6?$AA@ DB 'arrow keys '
	DB	' translate image', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JMJKJFLN@F?5?5Set?5rotate?1zoom?5focus?5to?5last@
CONST	SEGMENT
??_C@_0DA@JMJKJFLN@F?5?5Set?5rotate?1zoom?5focus?5to?5last@ DB 'F  Set ro'
	DB	'tate/zoom focus to last picked vertex', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DEHHMEEM@s?5?5Toggle?5cross?9eyed?5stereo?6?$AA@
CONST	SEGMENT
??_C@_0BN@DEHHMEEM@s?5?5Toggle?5cross?9eyed?5stereo?6?$AA@ DB 's  Toggle '
	DB	'cross-eyed stereo', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@JGDGMKJF@p?5?5Toggle?5orthogonal?1perspective@
CONST	SEGMENT
??_C@_0DN@JGDGMKJF@p?5?5Toggle?5orthogonal?1perspective@ DB 'p  Toggle or'
	DB	'thogonal/perspective projection, now orthogonal', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@LOPOMPDI@p?5?5Toggle?5orthogonal?1perspective@
CONST	SEGMENT
??_C@_0DO@LOPOMPDI@p?5?5Toggle?5orthogonal?1perspective@ DB 'p  Toggle or'
	DB	'thogonal/perspective projection, now perspective', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FHPGLNOB@f?5?5Toggle?5showing?5facets?0?5now?5OF@
CONST	SEGMENT
??_C@_0CD@FHPGLNOB@f?5?5Toggle?5showing?5facets?0?5now?5OF@ DB 'f  Toggle'
	DB	' showing facets, now OFF', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CMACHMNL@f?5?5Toggle?5showing?5facets?0?5now?5ON@
CONST	SEGMENT
??_C@_0CC@CMACHMNL@f?5?5Toggle?5showing?5facets?0?5now?5ON@ DB 'f  Toggle'
	DB	' showing facets, now ON', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EJFEMILG@e?5?5Toggle?5showing?5all?5edges?0?5now@
CONST	SEGMENT
??_C@_0CG@EJFEMILG@e?5?5Toggle?5showing?5all?5edges?0?5now@ DB 'e  Toggle'
	DB	' showing all edges, now OFF', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IPIFEDEJ@e?5?5Toggle?5showing?5all?5edges?0?5now@
CONST	SEGMENT
??_C@_0CF@IPIFEDEJ@e?5?5Toggle?5showing?5all?5edges?0?5now@ DB 'e  Toggle'
	DB	' showing all edges, now ON', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GFNELJDI@m?5?5Center?5image?6?$AA@
CONST	SEGMENT
??_C@_0BB@GFNELJDI@m?5?5Center?5image?6?$AA@ DB 'm  Center image', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IDDHFCHH@R?5?5Reset?5view?6?$AA@
CONST	SEGMENT
??_C@_0P@IDDHFCHH@R?5?5Reset?5view?6?$AA@ DB 'R  Reset view', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@IEAODFDM@g?5?5Gourard?5shading?5?$CIsmooth?5shadi@
CONST	SEGMENT
??_C@_0DF@IEAODFDM@g?5?5Gourard?5shading?5?$CIsmooth?5shadi@ DB 'g  Goura'
	DB	'rd shading (smooth shading) toggle, now OFF', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@CHOFKLM@g?5?5Gourard?5shading?5?$CIsmooth?5shadi@
CONST	SEGMENT
??_C@_0DE@CHOFKLM@g?5?5Gourard?5shading?5?$CIsmooth?5shadi@ DB 'g  Gourar'
	DB	'd shading (smooth shading) toggle, now ON', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NIOPGKA@b?5?5Decrease?5edge?5front?5bias?5by?50@
CONST	SEGMENT
??_C@_0CG@NIOPGKA@b?5?5Decrease?5edge?5front?5bias?5by?50@ DB 'b  Decreas'
	DB	'e edge front bias by 0.001', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KCDOIPPP@B?5?5Increase?5edge?5front?5bias?5by?50@
CONST	SEGMENT
??_C@_0CG@KCDOIPPP@B?5?5Increase?5edge?5front?5bias?5by?50@ DB 'B  Increa'
	DB	'se edge front bias by 0.001', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FGLFIDDM@w?5?5Narrow?5edges?6?$AA@
CONST	SEGMENT
??_C@_0BB@FGLFIDDM@w?5?5Narrow?5edges?6?$AA@ DB 'w  Narrow edges', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NJAKALEC@W?5?5Widen?5edges?6?$AA@
CONST	SEGMENT
??_C@_0BA@NJAKALEC@W?5?5Widen?5edges?6?$AA@ DB 'W  Widen edges', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GAIPGBG@c?5?5Clockwise?1counterclockwise?5mo@
CONST	SEGMENT
??_C@_0CE@GAIPGBG@c?5?5Clockwise?1counterclockwise?5mo@ DB 'c  Clockwise/'
	DB	'counterclockwise mode', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@MAJNEPON@c?5?5Clockwise?1counterclockwise?5mo@
CONST	SEGMENT
??_C@_0DA@MAJNEPON@c?5?5Clockwise?1counterclockwise?5mo@ DB 'c  Clockwise'
	DB	'/counterclockwise mode, now ACTIVE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GELNMPKP@z?5?5Zoom?5mode?5for?5left?5mouse?5butt@
CONST	SEGMENT
??_C@_0CE@GELNMPKP@z?5?5Zoom?5mode?5for?5left?5mouse?5butt@ DB 'z  Zoom m'
	DB	'ode for left mouse button', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@GALHLAFO@z?5?5Zoom?5mode?5for?5left?5mouse?5butt@
CONST	SEGMENT
??_C@_0DA@GALHLAFO@z?5?5Zoom?5mode?5for?5left?5mouse?5butt@ DB 'z  Zoom m'
	DB	'ode for left mouse button, now ACTIVE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NAOFHFMM@t?5?5Translate?5mode?5for?5left?5mouse@
CONST	SEGMENT
??_C@_0CJ@NAOFHFMM@t?5?5Translate?5mode?5for?5left?5mouse@ DB 't  Transla'
	DB	'te mode for left mouse button', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@DNBEHPIM@t?5?5Translate?5mode?5for?5left?5mouse@
CONST	SEGMENT
??_C@_0DF@DNBEHPIM@t?5?5Translate?5mode?5for?5left?5mouse@ DB 't  Transla'
	DB	'te mode for left mouse button, now ACTIVE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DDAEAOJF@r?5?5Rotate?5mode?5for?5left?5mouse?5bu@
CONST	SEGMENT
??_C@_0CG@DDAEAOJF@r?5?5Rotate?5mode?5for?5left?5mouse?5bu@ DB 'r  Rotate'
	DB	' mode for left mouse button', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@JKFOBBMH@r?5?5Rotate?5mode?5for?5left?5mouse?5bu@
CONST	SEGMENT
??_C@_0DC@JKFOBBMH@r?5?5Rotate?5mode?5for?5left?5mouse?5bu@ DB 'r  Rotate'
	DB	' mode for left mouse button, now ACTIVE', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MOLLDJEK@Graphics?5window?5keys?3?6?$AA@
CONST	SEGMENT
??_C@_0BH@MOLLDJEK@Graphics?5window?5keys?3?6?$AA@ DB 'Graphics window ke'
	DB	'ys:', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PJAOEABK@Left?5mouse?3?5move?5?5?5Right?5mouse?3?5@
CONST	SEGMENT
??_C@_0CG@PJAOEABK@Left?5mouse?3?5move?5?5?5Right?5mouse?3?5@ DB 'Left mo'
	DB	'use: move   Right mouse: pick', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JPLBIKBO@?6Graphics?5window?5help?3?6?$AA@
CONST	SEGMENT
??_C@_0BI@JPLBIKBO@?6Graphics?5window?5help?3?6?$AA@ DB 0aH, 'Graphics wi'
	DB	'ndow help:', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ECBCNCDM@?6Printing?5drawing?5stats?5OFF?6?$AA@
CONST	SEGMENT
??_C@_0BN@ECBCNCDM@?6Printing?5drawing?5stats?5OFF?6?$AA@ DB 0aH, 'Printi'
	DB	'ng drawing stats OFF', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BCEAOIIG@?6Printing?5drawing?5stats?5ON?6?$AA@
CONST	SEGMENT
??_C@_0BM@BCEAOIIG@?6Printing?5drawing?5stats?5ON?6?$AA@ DB 0aH, 'Printin'
	DB	'g drawing stats ON', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@CBJJCPNH@?6OpenGL?5projection?5now?5ORTHOGONA@
CONST	SEGMENT
??_C@_0CE@CBJJCPNH@?6OpenGL?5projection?5now?5ORTHOGONA@ DB 0aH, 'OpenGL '
	DB	'projection now ORTHOGONAL.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PDEPPJ@?6OpenGL?5projection?5now?5PERSPECTI@
CONST	SEGMENT
??_C@_0CF@PDEPPJ@?6OpenGL?5projection?5now?5PERSPECTI@ DB 0aH, 'OpenGL pr'
	DB	'ojection now PERSPECTIVE.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@OFFEDINK@?6OpenGL?5projection?5now?5CROSS?9EYE@
CONST	SEGMENT
??_C@_0CL@OFFEDINK@?6OpenGL?5projection?5now?5CROSS?9EYE@ DB 0aH, 'OpenGL'
	DB	' projection now CROSS-EYED STEREO.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LKLNOBMP@?6OpenGL?5vertex_arrays?5now?5OFF?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@LKLNOBMP@?6OpenGL?5vertex_arrays?5now?5OFF?4?6?$AA@ DB 0aH, 'Op'
	DB	'enGL vertex_arrays now OFF.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FNKMINJN@?6OpenGL?5vertex?5arrays?5now?5ON?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@FNKMINJN@?6OpenGL?5vertex?5arrays?5now?5ON?4?6?$AA@ DB 0aH, 'Op'
	DB	'enGL vertex arrays now ON.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ??_C@_0EA@BOJOBDMK@Vertex?5arrays?5require?5OpenGL?5ver@
CONST	SEGMENT
??_C@_0EA@BOJOBDMK@Vertex?5arrays?5require?5OpenGL?5ver@ DB 'Vertex array'
	DB	's require OpenGL version at least 1.1. This is %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GCKCNDHP@1?41?$AA@
CONST	SEGMENT
??_C@_03GCKCNDHP@1?41?$AA@ DB '1.1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@CDCECBKF@?6OpenGL?5multiple?5display?5lists?5O@
CONST	SEGMENT
??_C@_0CF@CDCECBKF@?6OpenGL?5multiple?5display?5lists?5O@ DB 0aH, 'OpenGL'
	DB	' multiple display lists OFF.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GPALKADI@?6OpenGL?5multiple?5display?5lists?5O@
CONST	SEGMENT
??_C@_0CE@GPALKADI@?6OpenGL?5multiple?5display?5lists?5O@ DB 0aH, 'OpenGL'
	DB	' multiple display lists ON.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OCNIMDOP@?6OpenGL?5display?5list?5now?5OFF?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@OCNIMDOP@?6OpenGL?5display?5list?5now?5OFF?4?6?$AA@ DB 0aH, 'Op'
	DB	'enGL display list now OFF.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HFMKKJDN@?6OpenGL?5arrays?5now?5OFF?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@HFMKKJDN@?6OpenGL?5arrays?5now?5OFF?4?6?$AA@ DB 0aH, 'OpenGL ar'
	DB	'rays now OFF.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PCPEEBAG@?6OpenGL?5display?5list?5now?5ON?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@PCPEEBAG@?6OpenGL?5display?5list?5now?5ON?4?6?$AA@ DB 0aH, 'Ope'
	DB	'nGL display list now ON.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@LIJFFNDP@?6?6Set?5Focus?3?5pickvnum?5?$CFd?5is?5inva@
CONST	SEGMENT
??_C@_0CH@LIJFFNDP@?6?6Set?5Focus?3?5pickvnum?5?$CFd?5is?5inva@ DB 0aH, 0aH
	DB	'Set Focus: pickvnum %d is invalid.', 0aH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EMFALJHA@Element?5strips?5OFF?4?6?$AA@
CONST	SEGMENT
??_C@_0BF@EMFALJHA@Element?5strips?5OFF?4?6?$AA@ DB 'Element strips OFF.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KLOEJEOO@Element?5strips?5ON?4?6?$AA@
CONST	SEGMENT
??_C@_0BE@KLOEJEOO@Element?5strips?5ON?4?6?$AA@ DB 'Element strips ON.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HMHMNFCK@Array?5indexing?5OFF?4?6?$AA@
CONST	SEGMENT
??_C@_0BF@HMHMNFCK@Array?5indexing?5OFF?4?6?$AA@ DB 'Array indexing OFF.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DCHHCHAB@Array?5indexing?5ON?4?6?$AA@
CONST	SEGMENT
??_C@_0BE@DCHHCHAB@Array?5indexing?5ON?4?6?$AA@ DB 'Array indexing ON.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FBIOPEFB@Interleaving?5OFF?4?6?$AA@
CONST	SEGMENT
??_C@_0BD@FBIOPEFB@Interleaving?5OFF?4?6?$AA@ DB 'Interleaving OFF.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MCLJNBPO@Interleaving?5ON?4?6?$AA@
CONST	SEGMENT
??_C@_0BC@MCLJNBPO@Interleaving?5ON?4?6?$AA@ DB 'Interleaving ON.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@4023cccccccccccd
CONST	SEGMENT
__real@4023cccccccccccd DQ 04023cccccccccccdr	; 9.9
CONST	ENDS
;	COMDAT __real@3fe3333333333333
CONST	SEGMENT
__real@3fe3333333333333 DQ 03fe3333333333333r	; 0.6
CONST	ENDS
;	COMDAT ??_C@_0BJ@PMICCHIL@?6Edge?5front?5bias?5now?5?$CFf?6?$AA@
CONST	SEGMENT
??_C@_0BJ@PMICCHIL@?6Edge?5front?5bias?5now?5?$CFf?6?$AA@ DB 0aH, 'Edge f'
	DB	'ront bias now %f', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _key_func
_TEXT	SEGMENT
_x$95282 = -64						; size = 4
tv2912 = -60						; size = 4
tv2901 = -60						; size = 4
_wrap$95298 = -60					; size = 4
tv1976 = -56						; size = 4
_m$95281 = -56						; size = 4
_fcolors$95245 = -56					; size = 4
_focus$95283 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_key$ = 8						; size = 1
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_key_func PROC						; COMDAT

; 1752 : { struct graph_thread_data *td = GET_DATA;

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	call	_glutGetWindow@0
	mov	esi, eax

; 1753 :   int i,j;
; 1754 : 
; 1755 :   switch ( key )

	movzx	eax, BYTE PTR _key$[ebp]
	imul	esi, 9896				; 000026a8H
	add	eax, -43				; ffffffd5H
	add	esi, OFFSET _gthread_data
	cmp	eax, 79					; 0000004fH
	ja	$LN91@key_func
	movzx	eax, BYTE PTR $LN159@key_func[eax]
	jmp	DWORD PTR $LN182@key_func[eax*4]
$LN90@key_func:

; 1756 :   { 
; 1757 :     case 'G': /* new graphics window */
; 1758 :         dup_window = glutGetWindow();

	call	_glutGetWindow@0

; 1759 :         draw_thread(NULL);  /* actually, just a new window */

	push	0
	mov	DWORD PTR _dup_window, eax
	call	_draw_thread
	add	esp, 4

; 1760 :       break;

	jmp	$LN91@key_func
$LN89@key_func:

; 1761 : 
; 1762 :     case 'r':  td->mouse_mode = MM_ROTATE; break;

	mov	DWORD PTR [esi+1728], 1
	jmp	$LN91@key_func
$LN88@key_func:

; 1763 :     case 't':  td->mouse_mode = MM_TRANSLATE; break;

	mov	DWORD PTR [esi+1728], 2
	jmp	$LN91@key_func
$LN87@key_func:

; 1764 :     case 'z':  td->mouse_mode = MM_SCALE; break;

	mov	DWORD PTR [esi+1728], 3
	jmp	$LN91@key_func
$LN86@key_func:

; 1765 :     case 'c':  td->mouse_mode = MM_SPIN; break;

	mov	DWORD PTR [esi+1728], 4
	jmp	$LN91@key_func
$LN85@key_func:

; 1766 :     case 'k':  if ( !slice_view_flag && !clip_view_flag )

	cmp	DWORD PTR _slice_view_flag, 0
	jne	SHORT $LN83@key_func
	cmp	DWORD PTR _clip_view_flag, 0
	mov	eax, 1
	jne	SHORT $LN157@key_func

; 1767 :                  td->newarraysflag = 1;

	mov	DWORD PTR [esi+128], eax
$LN157@key_func:

; 1768 :                if ( !slice_view_flag )
; 1769 :                  clip_view_flag = 1;  /* turn clip_view on */ 

	mov	DWORD PTR _clip_view_flag, eax
$LN83@key_func:

; 1770 :                td->mouse_mode = MM_SLICE_SPIN;

	mov	DWORD PTR [esi+1728], 6

; 1771 :                break;

	jmp	$LN91@key_func
$LN82@key_func:

; 1772 :     case 'l':  if ( !slice_view_flag && !clip_view_flag )

	cmp	DWORD PTR _slice_view_flag, 0
	jne	SHORT $LN80@key_func
	cmp	DWORD PTR _clip_view_flag, 0
	mov	eax, 1
	jne	SHORT $LN158@key_func

; 1773 :                  td->newarraysflag = 1;

	mov	DWORD PTR [esi+128], eax
$LN158@key_func:

; 1774 :                if ( !slice_view_flag )
; 1775 :                  clip_view_flag = 1;  /* turn clip_view on */ 

	mov	DWORD PTR _clip_view_flag, eax
$LN80@key_func:

; 1776 :                td->mouse_mode = MM_SLICE;

	mov	DWORD PTR [esi+1728], 5

; 1777 :                break;

	jmp	$LN91@key_func
$LN79@key_func:

; 1778 :     case 'L': slice_view_flag = clip_view_flag = 0;

	xor	eax, eax
	mov	DWORD PTR _clip_view_flag, eax
	mov	DWORD PTR _slice_view_flag, eax

; 1779 :               td->newarraysflag = 1;

	mov	eax, 1
	mov	DWORD PTR [esi+128], eax

; 1780 :               td->mouse_mode = MM_ROTATE;

	mov	DWORD PTR [esi+1728], eax

; 1781 :               break;

	jmp	$LN91@key_func
$LN78@key_func:

; 1782 : 
; 1783 :     case 'o': box_flag = !box_flag;

	xor	ecx, ecx
	cmp	DWORD PTR _box_flag, ecx
	sete	cl
	mov	DWORD PTR _box_flag, ecx
$LN178@key_func:

; 1784 :               graph_timestamp = ++global_timestamp; 

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _graph_timestamp, eax

; 1785 :               break;

	jmp	$LN91@key_func
$LN77@key_func:

; 1786 : 
; 1787 :     case 'O': td->opacity_flag = !td->opacity_flag;

	xor	edx, edx
	cmp	DWORD PTR [esi+9872], edx
	sete	dl
	mov	DWORD PTR [esi+9872], edx

; 1788 :               graph_timestamp = ++global_timestamp;
; 1789 :               break;

	jmp	SHORT $LN178@key_func
$LN76@key_func:

; 1790 : 
; 1791 :     case 'b':
; 1792 :         td->edge_bias -= 0.001; 

	fld	QWORD PTR [esi+1720]
	fsub	QWORD PTR __real@3f50624dd2f1a9fc
$LN177@key_func:

; 1793 :         sprintf(msg,"\nEdge front bias now %f\n", (DOUBLE)(td->edge_bias)); 

	mov	eax, DWORD PTR _msg
	fst	QWORD PTR [esi+1720]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BJ@PMICCHIL@?6Edge?5front?5bias?5now?5?$CFf?6?$AA@
	push	eax
	call	_sprintf

; 1794 :         erroutstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_erroutstring

; 1795 :         erroutstring(current_prompt);

	mov	edx, DWORD PTR _current_prompt
	push	edx

; 1796 :         break;

	jmp	$LN174@key_func
$LN75@key_func:

; 1797 : 
; 1798 :     case 'B':
; 1799 :         td->edge_bias += 0.001; 

	fld	QWORD PTR [esi+1720]
	fadd	QWORD PTR __real@3f50624dd2f1a9fc

; 1800 :         sprintf(msg,"\nEdge front bias now %f\n",(DOUBLE)(td->edge_bias)); 
; 1801 :         erroutstring(msg);
; 1802 :         erroutstring(current_prompt);
; 1803 :         break;

	jmp	SHORT $LN177@key_func
$LN74@key_func:

; 1804 : 
; 1805 :     case 'R':
; 1806 :        
; 1807 :         //  reset clipping and slicing
; 1808 :         memset(slice_coeff,0,sizeof(slice_coeff));

	push	64					; 00000040H
	xor	ebx, ebx
	push	ebx
	push	OFFSET _slice_coeff
	call	_memset

; 1809 :         memset(clip_coeff,0,sizeof(clip_coeff));

	push	640					; 00000280H
	push	ebx
	push	OFFSET _clip_coeff
	call	_memset

; 1810 :         clip_coeff[0][0] = 1.0;

	fld1
	add	esp, 24					; 00000018H
	fstp	QWORD PTR _clip_coeff

; 1811 :         slice_view_flag = 0;

	mov	DWORD PTR _slice_view_flag, ebx

; 1812 :         clip_view_flag = 0;

	mov	DWORD PTR _clip_view_flag, ebx

; 1813 :         slice_coeff_set_flag = 0;

	mov	DWORD PTR _slice_coeff_set_flag, ebx

; 1814 :         clip_coeff_set_flag = 0;

	mov	DWORD PTR _clip_coeff_set_flag, ebx

; 1815 :           
; 1816 :         resize();  // also sets up clip coeff

	call	_resize

; 1817 : 
; 1818 :         for ( i = 0 ; i < HOMDIM ; i++ )

	mov	edx, DWORD PTR _HOMDIM
	cmp	edx, ebx
	jle	SHORT $LN71@key_func

; 1804 : 
; 1805 :     case 'R':
; 1806 :        
; 1807 :         //  reset clipping and slicing
; 1808 :         memset(slice_coeff,0,sizeof(slice_coeff));

	lea	eax, DWORD PTR [esi+280]
	mov	DWORD PTR tv1976[ebp], eax
	npad	2
$LL73@key_func:

; 1819 :           for ( j = 0 ; j < HOMDIM ; j++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN72@key_func
	mov	edx, DWORD PTR tv1976[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _view
	mov	edi, DWORD PTR [edx+ebx*4]
	sub	edi, eax
$LL70@key_func:

; 1820 :             td->view[i][j] = view[i][j];

	fld	QWORD PTR [edi+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	mov	edx, DWORD PTR _HOMDIM
	add	eax, 8
	cmp	ecx, edx
	jl	SHORT $LL70@key_func
$LN72@key_func:

; 1817 : 
; 1818 :         for ( i = 0 ; i < HOMDIM ; i++ )

	add	DWORD PTR tv1976[ebp], 4
	inc	ebx
	cmp	ebx, edx
	jl	SHORT $LL73@key_func
$LN71@key_func:

; 1821 :         matcopy(td->to_focus,identmat,HOMDIM,HOMDIM);

	mov	eax, DWORD PTR _identmat
	push	edx
	push	edx
	push	eax
	lea	ecx, DWORD PTR [esi+768]
	push	ecx
	call	_matcopy

; 1822 :         matcopy(td->from_focus,identmat,HOMDIM,HOMDIM);

	mov	eax, DWORD PTR _HOMDIM
	mov	edx, DWORD PTR _identmat
	push	eax
	push	eax
	push	edx
	lea	eax, DWORD PTR [esi+1192]
	push	eax
	call	_matcopy
	add	esp, 32					; 00000020H

; 1823 :         td->newarraysflag = 1; // force recalc of all facets

	mov	DWORD PTR [esi+128], 1

; 1824 :     break;

	jmp	$LN91@key_func
$LN67@key_func:

; 1825 :  
; 1826 :     case '-':
; 1827 :         if ( td->linewidth > 0.6 )

	fld	QWORD PTR __real@3fe3333333333333
	fcomp	QWORD PTR [esi+1712]
	fnstsw	ax
	test	ah, 5
	jp	$LN91@key_func

; 1828 :         { td->linewidth -= 0.5;  

	fld	QWORD PTR [esi+1712]

; 1829 :           glLineWidth(td->linewidth);

	push	ecx
	fsub	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR [esi+1712]
	fstp	DWORD PTR tv2912[ebp]
	fld	DWORD PTR tv2912[ebp]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glLineWidth@4

; 1830 :         } 
; 1831 :         break;

	jmp	$LN91@key_func
$LN65@key_func:

; 1832 :   
; 1833 :     case '+':
; 1834 :         if ( td->linewidth < 9.9 ) 

	fld	QWORD PTR __real@4023cccccccccccd
	fcomp	QWORD PTR [esi+1712]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN91@key_func

; 1835 :         { td->linewidth += 0.5; 

	fld	QWORD PTR [esi+1712]

; 1836 :           glLineWidth(td->linewidth);

	push	ecx
	fadd	QWORD PTR __real@3fe0000000000000
	fst	QWORD PTR [esi+1712]
	fstp	DWORD PTR tv2901[ebp]
	fld	DWORD PTR tv2901[ebp]
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glLineWidth@4

; 1837 :         }
; 1838 :         break;

	jmp	$LN91@key_func
$LN63@key_func:

; 1839 : 
; 1840 :     case 'e':
; 1841 :         edgeshow_flag = !edgeshow_flag; 

	xor	ecx, ecx
	cmp	DWORD PTR _edgeshow_flag, ecx
	sete	cl
	mov	DWORD PTR _edgeshow_flag, ecx
$LN179@key_func:

; 1842 :         graph_timestamp = ++global_timestamp; 

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _graph_timestamp, eax

; 1843 :         td->newarraysflag = 1;

	mov	DWORD PTR [esi+128], 1

; 1844 :         break;

	jmp	$LN91@key_func
$LN62@key_func:

; 1845 : 
; 1846 :     case 'f':
; 1847 :         td->facetshow_flag = !td->facetshow_flag; 

	xor	edx, edx
	cmp	DWORD PTR [esi+1704], edx
	sete	dl
	mov	DWORD PTR [esi+1704], edx

; 1848 :         graph_timestamp = ++global_timestamp; 
; 1849 :         td->newarraysflag = 1;
; 1850 :         break;

	jmp	SHORT $LN179@key_func
$LN61@key_func:

; 1851 : 
; 1852 :     case 'g':  /* Gourard toggle */
; 1853 :         td->normflag = !td->normflag; graph_timestamp = ++global_timestamp; 

	xor	eax, eax
	cmp	DWORD PTR [esi+1708], eax
	sete	al
	mov	DWORD PTR [esi+1708], eax

; 1854 :         td->newarraysflag = 1;
; 1855 :         break;

	jmp	SHORT $LN179@key_func
$LN60@key_func:

; 1856 : 
; 1857 :     case 'm': /* move to middle */
; 1858 :          { do_gfile(0,NULL); /* get bounding box */

	push	0
	push	0
	call	_do_gfile

; 1859 :            if ( SDIM == 2 )
; 1860 :             { td->view[0][HOMDIM-1] -= (bbox_maxx+bbox_minx)/2;

	fld	QWORD PTR _bbox_minx
	fadd	QWORD PTR _bbox_maxx
	add	esp, 8
	cmp	DWORD PTR _web+616, 2
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	jne	SHORT $LN59@key_func
	mov	ecx, DWORD PTR [esi+280]
	mov	edx, DWORD PTR _HOMDIM
	fld	QWORD PTR [ecx+edx*8-8]
	lea	eax, DWORD PTR [ecx+edx*8-8]
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [eax]

; 1861 :               td->view[1][HOMDIM-1] -= (bbox_maxy+bbox_miny)/2;

	mov	eax, DWORD PTR [esi+284]
	mov	ecx, DWORD PTR _HOMDIM
	lea	eax, DWORD PTR [eax+ecx*8-8]

; 1862 :             } else

	jmp	SHORT $LN181@key_func
$LN59@key_func:

; 1863 :             { td->view[1][HOMDIM-1] -= (bbox_maxx+bbox_minx)/2;

	mov	edx, DWORD PTR [esi+284]
	mov	eax, DWORD PTR _HOMDIM
	fld	QWORD PTR [edx+eax*8-8]
	lea	eax, DWORD PTR [edx+eax*8-8]
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [eax]

; 1864 :               td->view[2][HOMDIM-1] -= (bbox_maxy+bbox_miny)/2;

	mov	ecx, DWORD PTR [esi+288]
	mov	edx, DWORD PTR _HOMDIM
	lea	eax, DWORD PTR [ecx+edx*8-8]
$LN181@key_func:
	fld	QWORD PTR _bbox_miny
	fadd	QWORD PTR _bbox_maxy
	fmulp	ST(1), ST(0)
	fsubr	QWORD PTR [eax]
	fstp	QWORD PTR [eax]

; 1865 :             }
; 1866 :             break;

	jmp	$LN91@key_func
$LN57@key_func:

; 1867 :          }
; 1868 : 
; 1869 :     case 'i': /* toggle interleaved elements in opengl arrays */ 
; 1870 :         td->interleaved_flag = !td->interleaved_flag;

	xor	eax, eax
	cmp	DWORD PTR [esi+9824], eax
	sete	al
	mov	DWORD PTR [esi+9824], eax

; 1871 :         erroutstring(td->interleaved_flag?"Interleaving ON.\n":"Interleaving OFF.\n"); 

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BC@MCLJNBPO@Interleaving?5ON?4?6?$AA@
	jne	SHORT $LN96@key_func
	mov	eax, OFFSET ??_C@_0BD@FBIOPEFB@Interleaving?5OFF?4?6?$AA@
$LN96@key_func:
	push	eax
	call	_erroutstring

; 1872 :         erroutstring(current_prompt);

	mov	eax, DWORD PTR _current_prompt
	push	eax
	call	_erroutstring
	add	esp, 8
	mov	DWORD PTR [esi+128], 1
	jmp	$LN91@key_func
$LN56@key_func:

; 1873 :         td->newarraysflag = 1;
; 1874 :         break;
; 1875 : 
; 1876 :     case 'I': /* indexed arrays */
; 1877 :         td->indexing_flag = !td->indexing_flag;

	xor	eax, eax
	cmp	DWORD PTR [esi+9828], eax
	sete	al
	mov	DWORD PTR [esi+9828], eax

; 1878 :         erroutstring(td->indexing_flag?"Array indexing ON.\n":"Array indexing OFF.\n"); 

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BE@DCHHCHAB@Array?5indexing?5ON?4?6?$AA@
	jne	SHORT $LN98@key_func
	mov	eax, OFFSET ??_C@_0BF@HMHMNFCK@Array?5indexing?5OFF?4?6?$AA@
$LN98@key_func:
	push	eax
	call	_erroutstring

; 1879 :         erroutstring(current_prompt);

	mov	ecx, DWORD PTR _current_prompt
	push	ecx
	call	_erroutstring
	add	esp, 8
	mov	DWORD PTR [esi+128], 1
	jmp	$LN91@key_func
$LN55@key_func:

; 1880 :         td->newarraysflag = 1;
; 1881 :         break;
; 1882 :    
; 1883 :     case 'S': /* toggle sending strips in arrays */
; 1884 :         td->strips_flag = !td->strips_flag;

	xor	eax, eax
	cmp	DWORD PTR [esi+9836], eax
	sete	al
	mov	DWORD PTR [esi+9836], eax

; 1885 :         erroutstring(td->strips_flag?"Element strips ON.\n":"Element strips OFF.\n"); 

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BE@KLOEJEOO@Element?5strips?5ON?4?6?$AA@
	jne	SHORT $LN100@key_func
	mov	eax, OFFSET ??_C@_0BF@EMFALJHA@Element?5strips?5OFF?4?6?$AA@
$LN100@key_func:
	push	eax
	call	_erroutstring

; 1886 :         erroutstring(current_prompt);

	mov	edx, DWORD PTR _current_prompt
	push	edx
	call	_erroutstring

; 1887 :  //       td->normflag = 1; /* gourard shading */
; 1888 :         td->indexing_flag = 1;

	mov	eax, 1
	add	esp, 8
	mov	DWORD PTR [esi+9828], eax

; 1889 :         td->newarraysflag = 1;

	mov	DWORD PTR [esi+128], eax

; 1890 :         break;

	jmp	$LN91@key_func
$LN54@key_func:

; 1891 :  
; 1892 :     case 'Y': /* colored strips */
; 1893 :       { int *fcolors;  // to save old colors of facets
; 1894 :         facet_id f_id;
; 1895 : 
; 1896 :         fcolors = (int*)mycalloc(web.skel[FACET].maxcount,sizeof(int));  // drawscreen frees temps

	mov	eax, DWORD PTR _web+244
	push	1896					; 00000768H
	push	OFFSET ??_C@_0M@CGDDLMBP@glutgraph?4c?$AA@
	push	4
	push	eax
	call	_kb_calloc

; 1897 :         FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	add	esp, 16					; 00000010H
	and	ecx, 1
	mov	DWORD PTR _fcolors$95245[ebp], eax
	je	SHORT $LN51@key_func
	npad	11
$LL167@key_func:
	mov	eax, DWORD PTR _web+236
	and	edx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN52@key_func

; 1898 :           fcolors[loc_ordinal(f_id)] = get_facet_color(f_id);

	test	ecx, ecx
	je	SHORT $LN101@key_func
	mov	eax, edx
	jmp	SHORT $LN102@key_func
$LN101@key_func:
	or	eax, -1
$LN102@key_func:
	movsx	ecx, WORD PTR [edi+48]
	mov	edi, DWORD PTR _fcolors$95245[ebp]
	mov	DWORD PTR [edi+eax*4], ecx
$LN52@key_func:

; 1897 :         FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	SHORT $LL167@key_func
$LN51@key_func:

; 1899 :         if ( !td->strips_flag ) 

	cmp	DWORD PTR [esi+9836], 0
	jne	SHORT $LN48@key_func

; 1900 :            key_func('S',0,0);  /* make sure strips on */

	push	0
	push	0
	push	83					; 00000053H
	call	_key_func
	add	esp, 12					; 0000000cH
$LN48@key_func:

; 1901 :         td->strip_color_flag = 1;

	mov	edi, 1
	mov	DWORD PTR [esi+9840], edi

; 1902 :         td->newarraysflag = 1;

	mov	DWORD PTR [esi+128], edi

; 1903 :         draw_screen();  /* get facets colored */

	call	_draw_screen

; 1904 :         td->newarraysflag = 1;

	mov	DWORD PTR [esi+128], edi

; 1905 :         draw_screen();  /* draw colored facets */

	call	_draw_screen

; 1906 :         td->strip_color_flag = 0;
; 1907 :         FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR _web+272
	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	and	edx, edi
	mov	DWORD PTR [esi+9840], 0
	je	SHORT $LN45@key_func
	mov	ebx, DWORD PTR _web+236
	npad	6
$LL47@key_func:
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+ecx*4]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN46@key_func

; 1908 :           set_facet_color(f_id,fcolors[loc_ordinal(f_id)]);

	test	edx, edx
	je	SHORT $LN103@key_func
	mov	eax, ecx
	jmp	SHORT $LN104@key_func
$LN103@key_func:
	or	eax, -1
$LN104@key_func:
	mov	edx, DWORD PTR _fcolors$95245[ebp]
	mov	ax, WORD PTR [edx+eax*4]
	mov	WORD PTR [esi+50], ax
	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	dx, WORD PTR [eax+50]
	mov	WORD PTR [eax+48], dx
	mov	ebx, DWORD PTR _web+236
$LN46@key_func:

; 1906 :         td->strip_color_flag = 0;
; 1907 :         FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	jne	SHORT $LL47@key_func
$LN45@key_func:

; 1909 :         myfree((char*)fcolors);

	mov	ecx, DWORD PTR _fcolors$95245[ebp]
	push	ecx
	call	_myfree
	add	esp, 4

; 1910 :       }
; 1911 :       break;

	jmp	$LN91@key_func
$LN42@key_func:

; 1912 : 
; 1913 :     case 'F': /* use last pick to set rotation center */
; 1914 :         if ( pickvnum > 0 )

	mov	eax, DWORD PTR _pickvnum
	test	eax, eax
	jle	$LN91@key_func

; 1915 :         { int i,m;
; 1916 :           REAL *x;
; 1917 :           REAL focus[MAXCOORD];
; 1918 :           vertex_id v_id;
; 1919 : 
; 1920 :           v_id = get_ordinal_id(VERTEX,pickvnum-1);

	dec	eax
	push	eax
	push	0
	call	_get_ordinal_id
	mov	edi, eax

; 1921 :           if ( !valid_element(v_id) )

	push	edi
	call	_valid_element
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN40@key_func

; 1922 :           { sprintf(errmsg,"\n\nSet Focus: pickvnum %d is invalid.\n\n",pickvnum);

	mov	edx, DWORD PTR _pickvnum
	push	edx
	push	OFFSET ??_C@_0CH@LIJFFNDP@?6?6Set?5Focus?3?5pickvnum?5?$CFd?5is?5inva@
	push	OFFSET _errmsg
	call	_sprintf

; 1923 :             erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 1924 :             erroutstring(current_prompt);

	mov	eax, DWORD PTR _current_prompt
	push	eax
	call	_erroutstring
	add	esp, 20					; 00000014H

; 1925 :             break;

	jmp	$LN91@key_func
$LN40@key_func:

; 1928 :           x = get_coord(td->focus_vertex_id);  

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	DWORD PTR [esi+708], edi
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edi*4]
	add	ecx, DWORD PTR [edx+eax+64]

; 1929 :           for ( m = 0 ; m < SDIM ; m++ ) td->focus_coord[m] = x[m];

	mov	edi, DWORD PTR _web+616
	xor	edx, edx
	mov	DWORD PTR _x$95282[ebp], ecx
	cmp	edi, 4
	jl	SHORT $LC152@key_func

; 1926 :           }
; 1927 :           td->focus_vertex_id = v_id;

	lea	ebx, DWORD PTR [edi-4]
	shr	ebx, 2
	add	ecx, 16					; 00000010H
	inc	ebx
	lea	eax, DWORD PTR [esi+720]
	lea	edx, DWORD PTR [ebx*4]
$LL166@key_func:

; 1929 :           for ( m = 0 ; m < SDIM ; m++ ) td->focus_coord[m] = x[m];

	fld	QWORD PTR [ecx-16]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	add	ecx, 32					; 00000020H
	dec	ebx
	fld	QWORD PTR [ecx-40]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [ecx-32]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [ecx-24]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LL166@key_func

; 1926 :           }
; 1927 :           td->focus_vertex_id = v_id;

	mov	ecx, DWORD PTR _x$95282[ebp]
$LC152@key_func:

; 1929 :           for ( m = 0 ; m < SDIM ; m++ ) td->focus_coord[m] = x[m];

	cmp	edx, edi
	jge	SHORT $LN151@key_func
	lea	eax, DWORD PTR [esi+edx*8+712]
$LC39@key_func:
	fld	QWORD PTR [ecx+edx*8]
	inc	edx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	edx, edi
	jl	SHORT $LC39@key_func
$LN151@key_func:

; 1930 :           if ( web.torus_flag && (torus_display_mode == TORUS_CLIPPED_MODE) )

	cmp	DWORD PTR _web+860, 0
	je	$LN33@key_func
	cmp	DWORD PTR _torus_display_mode, 3
	jne	$LN33@key_func

; 1931 :           { 
; 1932 :             for ( m = 0 ; m < SDIM ; m++ )

	mov	DWORD PTR _m$95281[ebp], 0
	test	edi, edi
	jle	$LN33@key_func
	npad	6
$LL35@key_func:

; 1933 :             { int wrap = (int)floor(SDIM_dot(web.inverse_periods[m],x));

	mov	ecx, DWORD PTR _x$95282[ebp]
	mov	edx, DWORD PTR _web+1612
	mov	eax, DWORD PTR _m$95281[ebp]
	push	edi
	push	ecx
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_dot
	fstp	QWORD PTR [esp+4]
	add	esp, 4
	call	_floor
	add	esp, 8
	call	__ftol2_sse

; 1934 :               for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR _web+616
	xor	ebx, ebx
	mov	DWORD PTR _wrap$95298[ebp], eax
	cmp	edi, 4
	jl	SHORT $LN164@key_func

; 1935 :                 td->focus_coord[i] -= wrap*web.torus_period[m][i];

	mov	edx, DWORD PTR _m$95281[ebp]
	fild	DWORD PTR _wrap$95298[ebp]
	mov	eax, DWORD PTR _web+1608
	mov	ecx, DWORD PTR [eax+edx*4]
	lea	edx, DWORD PTR [edi-4]
	shr	edx, 2
	add	ecx, 16					; 00000010H
	inc	edx
	lea	eax, DWORD PTR [esi+720]
	lea	ebx, DWORD PTR [edx*4]
$LN156@key_func:
	fld	QWORD PTR [ecx-16]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(1)
	add	ecx, 32					; 00000020H
	dec	edx
	fsubr	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [ecx-40]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [ecx-32]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [ecx-24]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN156@key_func

; 1933 :             { int wrap = (int)floor(SDIM_dot(web.inverse_periods[m],x));

	fstp	ST(0)
$LN164@key_func:

; 1934 :               for ( i = 0 ; i < SDIM ; i++ )

	cmp	ebx, edi
	jge	SHORT $LN34@key_func
	mov	ecx, DWORD PTR _m$95281[ebp]
	fild	DWORD PTR _wrap$95298[ebp]
	mov	edx, DWORD PTR _web+1608
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, edi
	lea	edx, DWORD PTR [eax+ebx*8]
	lea	eax, DWORD PTR [esi+ebx*8+712]
	sub	ecx, ebx
$LC32@key_func:

; 1935 :                 td->focus_coord[i] -= wrap*web.torus_period[m][i];

	fld	ST(0)
	add	edx, 8
	fmul	QWORD PTR [edx-8]
	add	eax, 8
	dec	ecx
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC32@key_func

; 1934 :               for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN34@key_func:

; 1931 :           { 
; 1932 :             for ( m = 0 ; m < SDIM ; m++ )

	mov	eax, DWORD PTR _m$95281[ebp]
	inc	eax
	mov	DWORD PTR _m$95281[ebp], eax
	cmp	eax, edi
	jl	$LL35@key_func
$LN33@key_func:

; 1936 :             }
; 1937 :           }
; 1938 : 
; 1939 :           matvec_mul(td->view,td->focus_coord,focus,HOMDIM-1,HOMDIM-1);

	mov	eax, DWORD PTR _HOMDIM
	dec	eax
	push	eax
	push	eax
	lea	ecx, DWORD PTR _focus$95283[ebp]
	lea	edi, DWORD PTR [esi+280]
	push	ecx
	add	esi, 712				; 000002c8H
	push	esi
	push	edi
	call	_matvec_mul

; 1940 :           for ( i = 0 ; i < SDIM ; i++ ) 

	xor	ecx, ecx
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _web+616, ecx
	jle	$LN91@key_func

; 1936 :             }
; 1937 :           }
; 1938 : 
; 1939 :           matvec_mul(td->view,td->focus_coord,focus,HOMDIM-1,HOMDIM-1);

	mov	eax, edi
	npad	1
$LL29@key_func:

; 1941 :           { td->to_focus[i][HOMDIM-1] = -focus[i] - td->view[i][HOMDIM-1];

	fld	QWORD PTR _focus$95283[ebp+ecx*8]
	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR _HOMDIM
	fchs
	fsub	QWORD PTR [edx+esi*8-8]
	mov	edi, DWORD PTR [eax+488]
	inc	ecx
	add	eax, 4
	fstp	QWORD PTR [edi+esi*8-8]

; 1942 :             td->from_focus[i][HOMDIM-1] = focus[i] + td->view[i][HOMDIM-1];

	mov	esi, DWORD PTR _HOMDIM
	fld	QWORD PTR [edx+esi*8-8]
	mov	edx, DWORD PTR [eax+908]
	fadd	QWORD PTR _focus$95283[ebp+ecx*8-8]
	fstp	QWORD PTR [edx+esi*8-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL29@key_func

; 1943 :           }
; 1944 :         }
; 1945 :         break;

	jmp	$LN91@key_func
$LN26@key_func:

; 1946 : 
; 1947 :     case 'D': /* toggle display list */
; 1948 :         td->dlistflag = td->dlistflag ? NOLIST:RESETLIST; 

	mov	eax, DWORD PTR [esi+1748]
	neg	eax
	sbb	eax, eax
	and	eax, -2					; fffffffeH
	add	eax, 2
	mov	DWORD PTR [esi+1748], eax

; 1949 :         if ( td->dlistflag )

	je	SHORT $LN25@key_func

; 1950 :         { erroutstring("\nOpenGL display list now ON.\n");

	push	OFFSET ??_C@_0BO@PCPEEBAG@?6OpenGL?5display?5list?5now?5ON?4?6?$AA@
	call	_erroutstring
	add	esp, 4

; 1951 :           if ( td->arraysflag )

	cmp	DWORD PTR [esi+9772], 0
	je	SHORT $LN24@key_func

; 1952 :           { glDisableClientState(GL_COLOR_ARRAY);

	mov	edi, DWORD PTR __imp__glDisableClientState@4
	push	32886					; 00008076H
	call	edi

; 1953 :             glDisableClientState(GL_NORMAL_ARRAY);

	push	32885					; 00008075H
	call	edi

; 1954 :             glDisableClientState(GL_VERTEX_ARRAY);

	push	32884					; 00008074H
	call	edi

; 1955 :             erroutstring("\nOpenGL arrays now OFF.\n");

	push	OFFSET ??_C@_0BJ@HFMKKJDN@?6OpenGL?5arrays?5now?5OFF?4?6?$AA@
	call	_erroutstring
	add	esp, 4
$LN24@key_func:

; 1960 :         erroutstring(current_prompt);

	mov	eax, DWORD PTR _current_prompt
	push	eax
	mov	DWORD PTR [esi+9772], 0
	call	_erroutstring
	add	esp, 4

; 1961 :         graph_timestamp = ++global_timestamp; /* force recalculate arrays */
; 1962 :         break;

	jmp	$LN178@key_func
$LN25@key_func:

; 1956 :           }
; 1957 :           td->arraysflag = 0;
; 1958 :         }
; 1959 :         else erroutstring("\nOpenGL display list now OFF.\n");

	push	OFFSET ??_C@_0BP@OCNIMDOP@?6OpenGL?5display?5list?5now?5OFF?4?6?$AA@
	call	_erroutstring

; 1960 :         erroutstring(current_prompt);

	mov	eax, DWORD PTR _current_prompt
	add	esp, 4
	push	eax
	call	_erroutstring
	add	esp, 4

; 1961 :         graph_timestamp = ++global_timestamp; /* force recalculate arrays */
; 1962 :         break;

	jmp	$LN178@key_func
$LN22@key_func:

; 1963 : 
; 1964 :     case 'Z': /* toggle multi-display-lists */
; 1965 :         td->multi_dlist_flag = !td->multi_dlist_flag;

	xor	eax, eax
	xor	ecx, ecx
	cmp	DWORD PTR [esi+1752], ecx

; 1966 :         if ( td->multi_dlist_flag )

	lea	edi, DWORD PTR [ecx+1]
	sete	al
	mov	DWORD PTR [esi+1752], eax
	cmp	eax, ecx
	je	SHORT $LN21@key_func

; 1967 :         { td->indexing_flag = 0;

	mov	DWORD PTR [esi+9828], ecx

; 1968 :           td->interleaved_flag = 1;

	mov	DWORD PTR [esi+9824], edi

; 1969 :           td->dlistflag = 0;

	mov	DWORD PTR [esi+1748], ecx

; 1970 :           erroutstring("\nOpenGL multiple display lists ON.\n");

	push	OFFSET ??_C@_0CE@GPALKADI@?6OpenGL?5multiple?5display?5lists?5O@
	jmp	SHORT $LN175@key_func
$LN21@key_func:

; 1971 :         }
; 1972 :         else erroutstring("\nOpenGL multiple display lists OFF.\n");

	push	OFFSET ??_C@_0CF@CDCECBKF@?6OpenGL?5multiple?5display?5lists?5O@
$LN175@key_func:
	call	_erroutstring

; 1973 :         erroutstring(current_prompt);

	mov	ecx, DWORD PTR _current_prompt
	add	esp, 4
	push	ecx
	call	_erroutstring
	add	esp, 4

; 1974 :         td->newarraysflag = 1;

	mov	DWORD PTR [esi+128], edi

; 1975 :         break;

	jmp	$LN91@key_func
$LN19@key_func:

; 1976 :   
; 1977 :     case 'a': /* toggle vertex arrays */
; 1978 :         if ( strcmp(opengl_version,"1.1") < 0 )

	mov	ecx, OFFSET ??_C@_03GCKCNDHP@1?41?$AA@
	mov	eax, OFFSET _opengl_version
	npad	4
$LL160@key_func:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN161@key_func
	test	dl, dl
	je	SHORT $LN162@key_func
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN161@key_func
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL160@key_func
$LN162@key_func:
	xor	eax, eax
	jmp	SHORT $LN163@key_func
$LN161@key_func:
	sbb	eax, eax
	sbb	eax, -1
$LN163@key_func:
	test	eax, eax
	jns	SHORT $LN18@key_func

; 1979 :         { sprintf(errmsg,
; 1980 :            "Vertex arrays require OpenGL version at least 1.1. This is %s.\n",
; 1981 :                    opengl_version);

	push	OFFSET _opengl_version
	push	OFFSET ??_C@_0EA@BOJOBDMK@Vertex?5arrays?5require?5OpenGL?5ver@
	push	OFFSET _errmsg
	call	_sprintf

; 1982 :           kb_error(2174,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2174					; 0000087eH
	call	_kb_error
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx

; 2142 : } /* end of key_func() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@key_func:

; 1983 :          return;
; 1984 :         }
; 1985 :         td->arraysflag = !td->arraysflag; 

	xor	eax, eax
	cmp	DWORD PTR [esi+9772], eax
	sete	al
	mov	DWORD PTR [esi+9772], eax

; 1986 :         if ( td->arraysflag )

	test	eax, eax
	je	$LN17@key_func

; 1987 :         { /* Workaround really bizarre line-drawing bug */
; 1988 :           if ( td->linewidth == 1.0 ) { td->linewidth = 0.5; glLineWidth(0.5);}

	fld	QWORD PTR [esi+1712]
	fld1
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN16@key_func
	fld	QWORD PTR __real@3fe0000000000000
	push	ecx
	fstp	QWORD PTR [esi+1712]
	fld	DWORD PTR __real@3f000000
	fstp	DWORD PTR [esp]
	call	DWORD PTR __imp__glLineWidth@4
$LN16@key_func:

; 1989 :           erroutstring("\nOpenGL vertex arrays now ON.\n");

	push	OFFSET ??_C@_0BP@FNKMINJN@?6OpenGL?5vertex?5arrays?5now?5ON?4?6?$AA@
	call	_erroutstring

; 1990 :           glEnableClientState(GL_COLOR_ARRAY);

	mov	edi, DWORD PTR __imp__glEnableClientState@4
	add	esp, 4
	push	32886					; 00008076H
	call	edi

; 1991 :           glEnableClientState(GL_NORMAL_ARRAY);

	push	32885					; 00008075H
	call	edi

; 1992 :           glEnableClientState(GL_VERTEX_ARRAY);

	push	32884					; 00008074H
	call	edi

; 1993 :           //glInterleavedArrays(GL_C4F_N3F_V3F,0,(void*)td->fullarray);
; 1994 :           glColorPointer(4,GL_FLOAT,sizeof(struct vercol),td->fullarray);      

	mov	edx, DWORD PTR [esi+9776]
	push	edx
	push	44					; 0000002cH
	push	5126					; 00001406H
	push	4
	call	DWORD PTR __imp__glColorPointer@16

; 1995 :           glNormalPointer(GL_FLOAT,sizeof(struct vercol),td->fullarray->n);

	mov	eax, DWORD PTR [esi+9776]
	add	eax, 16					; 00000010H
	push	eax
	push	44					; 0000002cH
	push	5126					; 00001406H
	call	DWORD PTR __imp__glNormalPointer@12

; 1996 :           glVertexPointer(3,GL_FLOAT,sizeof(struct vercol),td->fullarray->x);

	mov	ecx, DWORD PTR [esi+9776]
	add	ecx, 28					; 0000001cH
	push	ecx
	push	44					; 0000002cH
	push	5126					; 00001406H
	push	3
	call	DWORD PTR __imp__glVertexPointer@16

; 2007 :         }
; 2008 :         erroutstring(current_prompt);

	mov	edx, DWORD PTR _current_prompt
	push	edx
	mov	DWORD PTR [esi+128], 1
	mov	DWORD PTR [esi+1748], 0
	call	_erroutstring
	add	esp, 4

; 2009 :         break;

	jmp	$LN91@key_func
$LN17@key_func:

; 1997 : 
; 1998 :           td->newarraysflag = 1;
; 1999 :           td->dlistflag = 0;
; 2000 :         }
; 2001 :         else
; 2002 :         {
; 2003 :           glDisableClientState(GL_COLOR_ARRAY);

	mov	esi, DWORD PTR __imp__glDisableClientState@4
	push	32886					; 00008076H
	call	esi

; 2004 :           glDisableClientState(GL_NORMAL_ARRAY);

	push	32885					; 00008075H
	call	esi

; 2005 :           glDisableClientState(GL_VERTEX_ARRAY);

	push	32884					; 00008074H
	call	esi

; 2006 :           erroutstring("\nOpenGL vertex_arrays now OFF.\n");

	push	OFFSET ??_C@_0CA@LKLNOBMP@?6OpenGL?5vertex_arrays?5now?5OFF?4?6?$AA@
	call	_erroutstring

; 2007 :         }
; 2008 :         erroutstring(current_prompt);

	mov	edx, DWORD PTR _current_prompt
	add	esp, 4
	push	edx
	call	_erroutstring
	add	esp, 4

; 2009 :         break;

	jmp	$LN91@key_func
$LN14@key_func:

; 2010 : 
; 2011 :    case 's': /* toggle stereo */
; 2012 :       td->stereomode = (td->stereomode==NO_STEREO) ? CROSS_STEREO:NO_STEREO; 
; 2013 :       reshape_func(td->xsize,td->ysize);

	mov	ecx, DWORD PTR [esi+252]
	mov	edx, DWORD PTR [esi+248]
	xor	eax, eax
	cmp	DWORD PTR [esi+1700], eax
	push	ecx
	sete	al
	push	edx
	mov	DWORD PTR [esi+1700], eax
	call	_reshape_func
	add	esp, 8

; 2014 :       break;

	jmp	$LN91@key_func
$LN13@key_func:

; 2015 :  
; 2016 :    case 'p': /* perspective mode */
; 2017 :       if ( td->stereomode ) 

	cmp	DWORD PTR [esi+1700], 0
	je	SHORT $LN12@key_func

; 2018 :          erroutstring("\nOpenGL projection now CROSS-EYED STEREO.\n"); 

	push	OFFSET ??_C@_0CL@OFFEDINK@?6OpenGL?5projection?5now?5CROSS?9EYE@
	jmp	SHORT $LN176@key_func
$LN12@key_func:

; 2019 :       else if ( td->projmode==P_ORTHO ) 

	cmp	DWORD PTR [esi+1632], 0
	jne	SHORT $LN10@key_func

; 2020 :       { td->projmode=P_PERSP; 

	mov	DWORD PTR [esi+1632], 1

; 2021 :         erroutstring("\nOpenGL projection now PERSPECTIVE.\n");

	push	OFFSET ??_C@_0CF@PDEPPJ@?6OpenGL?5projection?5now?5PERSPECTI@

; 2022 :       }
; 2023 :       else 

	jmp	SHORT $LN176@key_func
$LN10@key_func:

; 2024 :       { td->projmode=P_ORTHO; 

	mov	DWORD PTR [esi+1632], 0

; 2025 :         erroutstring("\nOpenGL projection now ORTHOGONAL.\n");

	push	OFFSET ??_C@_0CE@CBJJCPNH@?6OpenGL?5projection?5now?5ORTHOGONA@
$LN176@key_func:
	call	_erroutstring

; 2026 :       }
; 2027 :       erroutstring(current_prompt);

	mov	eax, DWORD PTR _current_prompt
	add	esp, 4
	push	eax
	call	_erroutstring

; 2028 :       reshape_func(td->xsize,td->ysize);

	mov	ecx, DWORD PTR [esi+252]
	mov	edx, DWORD PTR [esi+248]
	push	ecx
	push	edx
	call	_reshape_func
	add	esp, 12					; 0000000cH

; 2029 :       break;

	jmp	$LN91@key_func
$LN8@key_func:

; 2030 :  
; 2031 :    case 'M': /* menu mode on right mouse button */
; 2032 :       glutSetMenu(mainmenu);

	mov	eax, DWORD PTR _mainmenu
	push	eax
	call	_glutSetMenu@4

; 2033 :       glutAttachMenu(GLUT_RIGHT_BUTTON);

	push	2
	call	_glutAttachMenu@4

; 2034 :       break;

	jmp	$LN91@key_func
$LN7@key_func:

; 2035 : 
; 2036 : 
; 2037 :    case 'P': /* pick mode on right mouse button */
; 2038 :       glutSetMenu(mainmenu);

	mov	ecx, DWORD PTR _mainmenu
	push	ecx
	call	_glutSetMenu@4

; 2039 :       glutDetachMenu(GLUT_RIGHT_BUTTON);

	push	2
	call	_glutDetachMenu@4

; 2040 :       break;

	jmp	$LN91@key_func
$LN6@key_func:

; 2041 : 
; 2042 :    case 'Q': /* toggle drawing stats printing */
; 2043 :       td->q_flag = !td->q_flag;

	xor	eax, eax
	cmp	DWORD PTR [esi+9868], eax
	sete	al
	mov	DWORD PTR [esi+9868], eax

; 2044 :       erroutstring(td->q_flag ?
; 2045 :        "\nPrinting drawing stats ON\n":"\nPrinting drawing stats OFF\n");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BM@BCEAOIIG@?6Printing?5drawing?5stats?5ON?6?$AA@
	jne	SHORT $LN106@key_func
	mov	eax, OFFSET ??_C@_0BN@ECBCNCDM@?6Printing?5drawing?5stats?5OFF?6?$AA@
$LN106@key_func:
	push	eax
	call	_erroutstring

; 2046 :       erroutstring(current_prompt);

	mov	edx, DWORD PTR _current_prompt
	push	edx
	call	_erroutstring
	add	esp, 8

; 2047 :       break;

	jmp	$LN91@key_func
$LN5@key_func:

; 2048 : 
; 2049 :    case 'q': gpu_memory_report();

	call	_gpu_memory_report

; 2050 :       break;

	jmp	$LN91@key_func
$LN4@key_func:

; 2051 : 
; 2052 : 
; 2053 :    #ifdef MPI_EVOLVER
; 2054 :    case 'y': /* MPI version only */
; 2055 :       mpi_show_corona_flag = ! mpi_show_corona_flag;
; 2056 :       td->newarraysflag = 1;
; 2057 :       erroutstring(mpi_show_corona_flag ?
; 2058 :        "\nShowing MPI corona ON\n":"\nShowing MPI corona OFF\n");
; 2059 :       erroutstring(current_prompt);
; 2060 :       break;
; 2061 :    #endif
; 2062 : 
; 2063 :    case 'x': 
; 2064 :       Ogl_close();

	call	_Ogl_close
	pop	edi
	pop	esi
	pop	ebx

; 2142 : } /* end of key_func() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@key_func:

; 2065 :       return;
; 2066 :    case 'X': 
; 2067 : #ifdef WIN32
; 2068 :      ExitProcess(0);

	push	0
	call	DWORD PTR __imp__ExitProcess@4
$LN183@key_func:
$LN2@key_func:

; 2069 : #else
; 2070 :      my_exit(0);
; 2071 : #endif
; 2072 :      return;
; 2073 : 
; 2074 :    case 'h': case '?':
; 2075 :       erroutstring("\nGraphics window help:\n");

	push	OFFSET ??_C@_0BI@JPLBIKBO@?6Graphics?5window?5help?3?6?$AA@
	call	_erroutstring

; 2076 :       erroutstring("Left mouse: move   Right mouse: pick\n");

	push	OFFSET ??_C@_0CG@PJAOEABK@Left?5mouse?3?5move?5?5?5Right?5mouse?3?5@
	call	_erroutstring

; 2077 :       erroutstring("Graphics window keys:\n");

	push	OFFSET ??_C@_0BH@MOLLDJEK@Graphics?5window?5keys?3?6?$AA@
	call	_erroutstring

; 2078 :       erroutstring(td->mouse_mode==MM_ROTATE?
; 2079 :         "r  Rotate mode for left mouse button, now ACTIVE\n":
; 2080 :         "r  Rotate mode for left mouse button\n");

	mov	edi, 1
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET ??_C@_0DC@JKFOBBMH@r?5?5Rotate?5mode?5for?5left?5mouse?5bu@
	cmp	DWORD PTR [esi+1728], edi
	je	SHORT $LN108@key_func
	mov	eax, OFFSET ??_C@_0CG@DDAEAOJF@r?5?5Rotate?5mode?5for?5left?5mouse?5bu@
$LN108@key_func:
	push	eax
	call	_erroutstring
	add	esp, 4

; 2081 :       erroutstring(td->mouse_mode==MM_TRANSLATE?
; 2082 :         "t  Translate mode for left mouse button, now ACTIVE\n":
; 2083 :         "t  Translate mode for left mouse button\n");

	cmp	DWORD PTR [esi+1728], 2
	mov	eax, OFFSET ??_C@_0DF@DNBEHPIM@t?5?5Translate?5mode?5for?5left?5mouse@
	je	SHORT $LN110@key_func
	mov	eax, OFFSET ??_C@_0CJ@NAOFHFMM@t?5?5Translate?5mode?5for?5left?5mouse@
$LN110@key_func:
	push	eax
	call	_erroutstring
	add	esp, 4

; 2084 :       erroutstring(td->mouse_mode==MM_SCALE?
; 2085 :         "z  Zoom mode for left mouse button, now ACTIVE\n":
; 2086 :         "z  Zoom mode for left mouse button\n");

	cmp	DWORD PTR [esi+1728], 3
	mov	eax, OFFSET ??_C@_0DA@GALHLAFO@z?5?5Zoom?5mode?5for?5left?5mouse?5butt@
	je	SHORT $LN112@key_func
	mov	eax, OFFSET ??_C@_0CE@GELNMPKP@z?5?5Zoom?5mode?5for?5left?5mouse?5butt@
$LN112@key_func:
	push	eax
	call	_erroutstring
	add	esp, 4

; 2087 :       erroutstring(td->mouse_mode==MM_SPIN?
; 2088 :         "c  Clockwise/counterclockwise mode, now ACTIVE\n":
; 2089 :         "c  Clockwise/counterclockwise mode\n");

	cmp	DWORD PTR [esi+1728], 4
	mov	eax, OFFSET ??_C@_0DA@MAJNEPON@c?5?5Clockwise?1counterclockwise?5mo@
	je	SHORT $LN114@key_func
	mov	eax, OFFSET ??_C@_0CE@GAIPGBG@c?5?5Clockwise?1counterclockwise?5mo@
$LN114@key_func:
	push	eax
	call	_erroutstring

; 2090 :       erroutstring("W  Widen edges\n");

	push	OFFSET ??_C@_0BA@NJAKALEC@W?5?5Widen?5edges?6?$AA@
	call	_erroutstring

; 2091 :       erroutstring("w  Narrow edges\n");

	push	OFFSET ??_C@_0BB@FGLFIDDM@w?5?5Narrow?5edges?6?$AA@
	call	_erroutstring

; 2092 :       erroutstring("B  Increase edge front bias by 0.001\n");

	push	OFFSET ??_C@_0CG@KCDOIPPP@B?5?5Increase?5edge?5front?5bias?5by?50@
	call	_erroutstring

; 2093 :       erroutstring("b  Decrease edge front bias by 0.001\n");

	push	OFFSET ??_C@_0CG@NIOPGKA@b?5?5Decrease?5edge?5front?5bias?5by?50@
	call	_erroutstring
	add	esp, 20					; 00000014H

; 2094 :       erroutstring(normflag? 
; 2095 :         "g  Gourard shading (smooth shading) toggle, now ON\n":
; 2096 :         "g  Gourard shading (smooth shading) toggle, now OFF\n" );

	cmp	DWORD PTR _normflag, 0
	mov	eax, OFFSET ??_C@_0DE@CHOFKLM@g?5?5Gourard?5shading?5?$CIsmooth?5shadi@
	jne	SHORT $LN116@key_func
	mov	eax, OFFSET ??_C@_0DF@IEAODFDM@g?5?5Gourard?5shading?5?$CIsmooth?5shadi@
$LN116@key_func:
	push	eax
	call	_erroutstring

; 2097 :       erroutstring("R  Reset view\n");

	push	OFFSET ??_C@_0P@IDDHFCHH@R?5?5Reset?5view?6?$AA@
	call	_erroutstring

; 2098 :       erroutstring("m  Center image\n");

	push	OFFSET ??_C@_0BB@GFNELJDI@m?5?5Center?5image?6?$AA@
	call	_erroutstring
	add	esp, 12					; 0000000cH

; 2099 :       erroutstring(edgeshow_flag?"e  Toggle showing all edges, now ON\n":
; 2100 :         "e  Toggle showing all edges, now OFF\n");

	cmp	DWORD PTR _edgeshow_flag, 0
	mov	eax, OFFSET ??_C@_0CF@IPIFEDEJ@e?5?5Toggle?5showing?5all?5edges?0?5now@
	jne	SHORT $LN118@key_func
	mov	eax, OFFSET ??_C@_0CG@EJFEMILG@e?5?5Toggle?5showing?5all?5edges?0?5now@
$LN118@key_func:
	push	eax
	call	_erroutstring
	add	esp, 4

; 2101 :       erroutstring(td->facetshow_flag?"f  Toggle showing facets, now ON\n":
; 2102 :         "f  Toggle showing facets, now OFF\n");

	cmp	DWORD PTR [esi+1704], 0
	mov	eax, OFFSET ??_C@_0CC@CMACHMNL@f?5?5Toggle?5showing?5facets?0?5now?5ON@
	jne	SHORT $LN120@key_func
	mov	eax, OFFSET ??_C@_0CD@FHPGLNOB@f?5?5Toggle?5showing?5facets?0?5now?5OF@
$LN120@key_func:
	push	eax
	call	_erroutstring
	add	esp, 4

; 2103 :       erroutstring(td->projmode==P_PERSP?
; 2104 :         "p  Toggle orthogonal/perspective projection, now perspective\n":
; 2105 :         "p  Toggle orthogonal/perspective projection, now orthogonal\n");

	mov	eax, OFFSET ??_C@_0DO@LOPOMPDI@p?5?5Toggle?5orthogonal?1perspective@
	cmp	DWORD PTR [esi+1632], edi
	je	SHORT $LN122@key_func
	mov	eax, OFFSET ??_C@_0DN@JGDGMKJF@p?5?5Toggle?5orthogonal?1perspective@
$LN122@key_func:
	push	eax
	call	_erroutstring

; 2106 :       erroutstring("s  Toggle cross-eyed stereo\n");

	push	OFFSET ??_C@_0BN@DEHHMEEM@s?5?5Toggle?5cross?9eyed?5stereo?6?$AA@
	call	_erroutstring
	add	esp, 8

; 2107 :       erroutstring(normflag? "g  Gourard shading (smooth shading) toggle, now ON\n":
; 2108 :              "g  Gourard shading (smooth shading) toggle, now OFF\n" );

	cmp	DWORD PTR _normflag, 0
	mov	eax, OFFSET ??_C@_0DE@CHOFKLM@g?5?5Gourard?5shading?5?$CIsmooth?5shadi@
	jne	SHORT $LN124@key_func
	mov	eax, OFFSET ??_C@_0DF@IEAODFDM@g?5?5Gourard?5shading?5?$CIsmooth?5shadi@
$LN124@key_func:
	push	eax
	call	_erroutstring

; 2109 :       erroutstring("F  Set rotate/zoom focus to last picked vertex\n");

	push	OFFSET ??_C@_0DA@JMJKJFLN@F?5?5Set?5rotate?1zoom?5focus?5to?5last@
	call	_erroutstring

; 2110 :       erroutstring("arrow keys  translate image\n");

	push	OFFSET ??_C@_0BN@PJMOLLKK@arrow?5keys?5?5translate?5image?6?$AA@
	call	_erroutstring

; 2111 :       erroutstring("G  Another graphics window\n");

	push	OFFSET ??_C@_0BM@NHNCJPMP@G?5?5Another?5graphics?5window?6?$AA@
	call	_erroutstring

; 2112 :       erroutstring("H  Guru-level help items\n");

	push	OFFSET ??_C@_0BK@IGMDJEJH@H?5?5Guru?9level?5help?5items?6?$AA@
	call	_erroutstring

; 2113 :       erroutstring("x  Close graphics\n");

	push	OFFSET ??_C@_0BD@CEBDGLIN@x?5?5Close?5graphics?6?$AA@
	call	_erroutstring

; 2114 :       erroutstring(current_prompt);

	mov	eax, DWORD PTR _current_prompt
	push	eax
	call	_erroutstring
	add	esp, 28					; 0000001cH

; 2115 :       break;

	jmp	$LN91@key_func
$LN1@key_func:

; 2116 : 
; 2117 :    case 'H': /* guru level help */
; 2118 :      erroutstring("\nFollowing for fiddling with OpenGL drawing modes:\n");

	push	OFFSET ??_C@_0DE@HNHMJFGL@?6Following?5for?5fiddling?5with?5Ope@
	call	_erroutstring
	add	esp, 4

; 2119 :      erroutstring(td->dlistflag?"D  Toggle using display list, now ON\n":
; 2120 :        "D  Toggle using display list, now OFF\n");

	cmp	DWORD PTR [esi+1748], 0
	mov	eax, OFFSET ??_C@_0CG@LFHMGHKB@D?5?5Toggle?5using?5display?5list?0?5no@
	jne	SHORT $LN126@key_func
	mov	eax, OFFSET ??_C@_0CH@OHLPFLNI@D?5?5Toggle?5using?5display?5list?0?5no@
$LN126@key_func:
	push	eax
	call	_erroutstring
	add	esp, 4

; 2121 :      erroutstring(td->arraysflag?"a  Toggle using vertex and color arrays, now ON\n"
; 2122 :         :"a  Toggle using vertex and color arrays, now OFF\n");

	cmp	DWORD PTR [esi+9772], 0
	mov	eax, OFFSET ??_C@_0DB@COCNINNF@a?5?5Toggle?5using?5vertex?5and?5color@
	jne	SHORT $LN128@key_func
	mov	eax, OFFSET ??_C@_0DC@LAEMLPBH@a?5?5Toggle?5using?5vertex?5and?5color@
$LN128@key_func:
	push	eax
	call	_erroutstring
	add	esp, 4

; 2123 :      erroutstring(td->indexing_flag ? "I  Indexed vertex arrays, now ON\n"
; 2124 :                            : "I  Indexed vertex arrays, now OFF\n");

	cmp	DWORD PTR [esi+9828], 0
	mov	eax, OFFSET ??_C@_0CC@PAHEBCEP@I?5?5Indexed?5vertex?5arrays?0?5now?5ON@
	jne	SHORT $LN130@key_func
	mov	eax, OFFSET ??_C@_0CD@KAEIJMNC@I?5?5Indexed?5vertex?5arrays?0?5now?5OF@
$LN130@key_func:
	push	eax
	call	_erroutstring
	add	esp, 4

; 2125 :      erroutstring(td->interleaved_flag ? "i  Interleaved vertex arrays, now ON\n"
; 2126 :                            : "i  Interleaved vertex arrays, now OFF\n");

	cmp	DWORD PTR [esi+9824], 0
	mov	eax, OFFSET ??_C@_0CG@FIKHPDDO@i?5?5Interleaved?5vertex?5arrays?0?5no@
	jne	SHORT $LN132@key_func
	mov	eax, OFFSET ??_C@_0CH@IHOCAOJJ@i?5?5Interleaved?5vertex?5arrays?0?5no@
$LN132@key_func:
	push	eax
	call	_erroutstring
	add	esp, 4

; 2127 :      erroutstring(td->strips_flag?
; 2128 :     "S  Use element strips, now ON (indexed elements automatically turned on)\n"
; 2129 :     :"S  Use element strips, now OFF\n");

	cmp	DWORD PTR [esi+9836], 0
	mov	eax, OFFSET ??_C@_0EK@HJJHCJHC@S?5?5Use?5element?5strips?0?5now?5ON?5?$CIi@
	jne	SHORT $LN134@key_func
	mov	eax, OFFSET ??_C@_0CA@HEEGFBPG@S?5?5Use?5element?5strips?0?5now?5OFF?6?$AA@
$LN134@key_func:
	push	eax
	call	_erroutstring

; 2130 :      erroutstring("Y  One-time coloring of strips generated in S mode.\n");

	push	OFFSET ??_C@_0DF@LENOJMBC@Y?5?5One?9time?5coloring?5of?5strips?5g@
	call	_erroutstring

; 2131 :      erroutstring("       Caution: assumes display facets same as real, with no gaps.\n");

	push	OFFSET ??_C@_0EE@IGEKHONA@?5?5?5?5?5?5?5Caution?3?5assumes?5display?5@
	call	_erroutstring

; 2132 :      erroutstring("u  Toggle window update every graphics command, now ");

	push	OFFSET ??_C@_0DF@EAAFAKBE@u?5?5Toggle?5window?5update?5every?5gr@
	call	_erroutstring

; 2133 :      erroutstring("Q  Toggle printing some statistics during drawing\n");

	push	OFFSET ??_C@_0DD@MCPLIHNM@Q?5?5Toggle?5printing?5some?5statisti@
	call	_erroutstring

; 2134 :      #ifdef MPI_EVOLVER
; 2135 :      erroutstring("y  Toggle corona display\n");
; 2136 :      #endif
; 2137 :  
; 2138 :      erroutstring(current_prompt);

	mov	ecx, DWORD PTR _current_prompt
	push	ecx
$LN174@key_func:
	call	_erroutstring
	add	esp, 24					; 00000018H
$LN91@key_func:

; 2139 :      break;
; 2140 :   }
; 2141 :   glutPostRedisplay();  /* generate redraw message */

	call	_glutPostRedisplay@0

; 2142 : } /* end of key_func() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN173@key_func:
$LN182@key_func:
	DD	$LN65@key_func
	DD	$LN67@key_func
	DD	$LN2@key_func
	DD	$LN75@key_func
	DD	$LN26@key_func
	DD	$LN42@key_func
	DD	$LN90@key_func
	DD	$LN1@key_func
	DD	$LN56@key_func
	DD	$LN79@key_func
	DD	$LN8@key_func
	DD	$LN77@key_func
	DD	$LN7@key_func
	DD	$LN6@key_func
	DD	$LN74@key_func
	DD	$LN55@key_func
	DD	$LN3@key_func
	DD	$LN54@key_func
	DD	$LN22@key_func
	DD	$LN19@key_func
	DD	$LN76@key_func
	DD	$LN86@key_func
	DD	$LN63@key_func
	DD	$LN62@key_func
	DD	$LN61@key_func
	DD	$LN57@key_func
	DD	$LN85@key_func
	DD	$LN82@key_func
	DD	$LN60@key_func
	DD	$LN78@key_func
	DD	$LN13@key_func
	DD	$LN5@key_func
	DD	$LN89@key_func
	DD	$LN14@key_func
	DD	$LN88@key_func
	DD	$LN4@key_func
	DD	$LN87@key_func
	DD	$LN91@key_func
$LN159@key_func:
	DB	0
	DB	37					; 00000025H
	DB	1
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	2
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	3
	DB	37					; 00000025H
	DB	4
	DB	37					; 00000025H
	DB	5
	DB	6
	DB	7
	DB	8
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	9
	DB	10					; 0000000aH
	DB	37					; 00000025H
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	37					; 00000025H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	2
	DB	25					; 00000019H
	DB	37					; 00000025H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	37					; 00000025H
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	35					; 00000023H
	DB	37					; 00000025H
	DB	36					; 00000024H
_key_func ENDP
_TEXT	ENDS
PUBLIC	_mainmenu_func
; Function compile flags: /Ogtp
;	COMDAT _mainmenu_func
_TEXT	SEGMENT
_choice$ = 8						; size = 4
_mainmenu_func PROC					; COMDAT

; 2150 :  { 

	push	ebp
	mov	ebp, esp

; 2151 :    key_func(choice,0,0); 

	mov	eax, DWORD PTR _choice$[ebp]
	push	0
	push	0
	push	eax
	call	_key_func
	add	esp, 12					; 0000000cH

; 2152 :  }

	pop	ebp
	ret	0
_mainmenu_func ENDP
_TEXT	ENDS
PUBLIC	_submenu_func
; Function compile flags: /Ogtp
;	COMDAT _submenu_func
_TEXT	SEGMENT
_choice$ = 8						; size = 4
_submenu_func PROC					; COMDAT

; 2155 :  { 

	push	ebp
	mov	ebp, esp

; 2156 :    key_func(choice,0,0);

	mov	eax, DWORD PTR _choice$[ebp]
	push	0
	push	0
	push	eax
	call	_key_func
	add	esp, 12					; 0000000cH

; 2157 :  }

	pop	ebp
	ret	0
_submenu_func ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@BEGFOEPP@Exit?5Evolver?5?$CIX?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BD@LGHJLNCL@Close?5graphics?5?$CIx?$CJ?$AA@ ; `string'
PUBLIC	??_C@_08IILCFNBD@Advanced?$AA@			; `string'
PUBLIC	??_C@_0BI@PLHMHBGO@Print?5drawing?5stats?5?$CIQ?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BJ@EKCJNNAC@Toggle?5display?5lists?5?$CID?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BK@HPPMCLPE@Toggle?5strip?5coloring?5?$CIY?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BC@GEPBHFON@Toggle?5strips?5?$CIS?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BK@ODOEAJDF@Toggle?5indexed?5arrays?5?$CII?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BO@FCLPDINO@Toggle?5interleaved?5arrays?5?$CIi?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BC@POOHBHDI@Toggle?5arrays?5?$CIa?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CH@DOJDBKEM@Toggle?5orthogonal?1perspective?5vi@ ; `string'
PUBLIC	??_C@_0BH@NEHDLBKD@Toggle?5stereo?5view?5?$CIs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BL@FPIIJGDL@Toggle?5Gourard?5shading?5?$CIg?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BM@CCHNFNLO@Another?5graphics?5window?5?$CIG?$CJ?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BD@HFGGDPFD@Reset?5graphics?5?$CIR?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BB@BJEOMGMC@Bounding?5box?5?$CIo?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BL@HPNHDFIB@Focus?5on?5picked?5vertex?5?$CIF?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BD@DHCDAFKO@Toggle?5opacity?5?$CIO?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BB@BLEJHNMK@Toggle?5faces?5?$CIf?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BB@DMOFDDCF@Toggle?5edges?5?$CIe?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BC@NNDLHEBG@Center?5object?5?$CIm?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BC@KIJGCFPD@Edges?5thinner?5?$CI?9?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BC@BFLELAHC@Edges?5thicker?5?$CI?$CL?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0P@LCCGEBHG@Edges?5back?5?$CIb?$CJ?$AA@	; `string'
PUBLIC	??_C@_0BA@HDOHBEDN@Edges?5front?5?$CIB?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@NBPECBPO@Menu?5mode?5?$CIM?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@OMNHAKDC@Pick?5mode?5?$CIP?$CJ?$AA@	; `string'
PUBLIC	??_C@_0BE@KEOEDDJK@Right?5button?5modes?3?$AA@	; `string'
PUBLIC	??_C@_0P@ILHPBMDC@Slice?5mode?5?$CIl?$CJ?$AA@	; `string'
PUBLIC	??_C@_0P@ONNHDLBK@Scale?5mode?5?$CIz?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@BOGJJMDB@Spin?5mode?5?$CIc?$CJ?$AA@	; `string'
PUBLIC	??_C@_0BD@KIMJAPJI@Translate?5mode?5?$CIt?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BA@BHGMMKIM@Rotate?5mode?5?$CIr?$CJ?$AA@	; `string'
PUBLIC	??_C@_0BD@DCDHHEHM@Left?5button?5modes?3?$AA@	; `string'
PUBLIC	_myMenuInit
EXTRN	_glutAddSubMenu@8:PROC
EXTRN	_glutAddMenuEntry@8:PROC
_BSS	SEGMENT
_submenu DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BB@BEGFOEPP@Exit?5Evolver?5?$CIX?$CJ?$AA@
CONST	SEGMENT
??_C@_0BB@BEGFOEPP@Exit?5Evolver?5?$CIX?$CJ?$AA@ DB 'Exit Evolver (X)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LGHJLNCL@Close?5graphics?5?$CIx?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@LGHJLNCL@Close?5graphics?5?$CIx?$CJ?$AA@ DB 'Close graphics (x)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08IILCFNBD@Advanced?$AA@
CONST	SEGMENT
??_C@_08IILCFNBD@Advanced?$AA@ DB 'Advanced', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PLHMHBGO@Print?5drawing?5stats?5?$CIQ?$CJ?$AA@
CONST	SEGMENT
??_C@_0BI@PLHMHBGO@Print?5drawing?5stats?5?$CIQ?$CJ?$AA@ DB 'Print drawin'
	DB	'g stats (Q)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EKCJNNAC@Toggle?5display?5lists?5?$CID?$CJ?$AA@
CONST	SEGMENT
??_C@_0BJ@EKCJNNAC@Toggle?5display?5lists?5?$CID?$CJ?$AA@ DB 'Toggle disp'
	DB	'lay lists (D)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@HPPMCLPE@Toggle?5strip?5coloring?5?$CIY?$CJ?$AA@
CONST	SEGMENT
??_C@_0BK@HPPMCLPE@Toggle?5strip?5coloring?5?$CIY?$CJ?$AA@ DB 'Toggle str'
	DB	'ip coloring (Y)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GEPBHFON@Toggle?5strips?5?$CIS?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@GEPBHFON@Toggle?5strips?5?$CIS?$CJ?$AA@ DB 'Toggle strips (S)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ODOEAJDF@Toggle?5indexed?5arrays?5?$CII?$CJ?$AA@
CONST	SEGMENT
??_C@_0BK@ODOEAJDF@Toggle?5indexed?5arrays?5?$CII?$CJ?$AA@ DB 'Toggle ind'
	DB	'exed arrays (I)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FCLPDINO@Toggle?5interleaved?5arrays?5?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0BO@FCLPDINO@Toggle?5interleaved?5arrays?5?$CIi?$CJ?$AA@ DB 'Toggle'
	DB	' interleaved arrays (i)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@POOHBHDI@Toggle?5arrays?5?$CIa?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@POOHBHDI@Toggle?5arrays?5?$CIa?$CJ?$AA@ DB 'Toggle arrays (a)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DOJDBKEM@Toggle?5orthogonal?1perspective?5vi@
CONST	SEGMENT
??_C@_0CH@DOJDBKEM@Toggle?5orthogonal?1perspective?5vi@ DB 'Toggle orthog'
	DB	'onal/perspective view (p)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NEHDLBKD@Toggle?5stereo?5view?5?$CIs?$CJ?$AA@
CONST	SEGMENT
??_C@_0BH@NEHDLBKD@Toggle?5stereo?5view?5?$CIs?$CJ?$AA@ DB 'Toggle stereo'
	DB	' view (s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FPIIJGDL@Toggle?5Gourard?5shading?5?$CIg?$CJ?$AA@
CONST	SEGMENT
??_C@_0BL@FPIIJGDL@Toggle?5Gourard?5shading?5?$CIg?$CJ?$AA@ DB 'Toggle Go'
	DB	'urard shading (g)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CCHNFNLO@Another?5graphics?5window?5?$CIG?$CJ?$AA@
CONST	SEGMENT
??_C@_0BM@CCHNFNLO@Another?5graphics?5window?5?$CIG?$CJ?$AA@ DB 'Another '
	DB	'graphics window (G)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HFGGDPFD@Reset?5graphics?5?$CIR?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@HFGGDPFD@Reset?5graphics?5?$CIR?$CJ?$AA@ DB 'Reset graphics (R)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BJEOMGMC@Bounding?5box?5?$CIo?$CJ?$AA@
CONST	SEGMENT
??_C@_0BB@BJEOMGMC@Bounding?5box?5?$CIo?$CJ?$AA@ DB 'Bounding box (o)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HPNHDFIB@Focus?5on?5picked?5vertex?5?$CIF?$CJ?$AA@
CONST	SEGMENT
??_C@_0BL@HPNHDFIB@Focus?5on?5picked?5vertex?5?$CIF?$CJ?$AA@ DB 'Focus on'
	DB	' picked vertex (F)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DHCDAFKO@Toggle?5opacity?5?$CIO?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@DHCDAFKO@Toggle?5opacity?5?$CIO?$CJ?$AA@ DB 'Toggle opacity (O)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BLEJHNMK@Toggle?5faces?5?$CIf?$CJ?$AA@
CONST	SEGMENT
??_C@_0BB@BLEJHNMK@Toggle?5faces?5?$CIf?$CJ?$AA@ DB 'Toggle faces (f)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DMOFDDCF@Toggle?5edges?5?$CIe?$CJ?$AA@
CONST	SEGMENT
??_C@_0BB@DMOFDDCF@Toggle?5edges?5?$CIe?$CJ?$AA@ DB 'Toggle edges (e)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NNDLHEBG@Center?5object?5?$CIm?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@NNDLHEBG@Center?5object?5?$CIm?$CJ?$AA@ DB 'Center object (m)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KIJGCFPD@Edges?5thinner?5?$CI?9?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@KIJGCFPD@Edges?5thinner?5?$CI?9?$CJ?$AA@ DB 'Edges thinner (-)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BFLELAHC@Edges?5thicker?5?$CI?$CL?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@BFLELAHC@Edges?5thicker?5?$CI?$CL?$CJ?$AA@ DB 'Edges thicker (+'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LCCGEBHG@Edges?5back?5?$CIb?$CJ?$AA@
CONST	SEGMENT
??_C@_0P@LCCGEBHG@Edges?5back?5?$CIb?$CJ?$AA@ DB 'Edges back (b)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HDOHBEDN@Edges?5front?5?$CIB?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@HDOHBEDN@Edges?5front?5?$CIB?$CJ?$AA@ DB 'Edges front (B)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NBPECBPO@Menu?5mode?5?$CIM?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@NBPECBPO@Menu?5mode?5?$CIM?$CJ?$AA@ DB 'Menu mode (M)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OMNHAKDC@Pick?5mode?5?$CIP?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@OMNHAKDC@Pick?5mode?5?$CIP?$CJ?$AA@ DB 'Pick mode (P)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KEOEDDJK@Right?5button?5modes?3?$AA@
CONST	SEGMENT
??_C@_0BE@KEOEDDJK@Right?5button?5modes?3?$AA@ DB 'Right button modes:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ILHPBMDC@Slice?5mode?5?$CIl?$CJ?$AA@
CONST	SEGMENT
??_C@_0P@ILHPBMDC@Slice?5mode?5?$CIl?$CJ?$AA@ DB 'Slice mode (l)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ONNHDLBK@Scale?5mode?5?$CIz?$CJ?$AA@
CONST	SEGMENT
??_C@_0P@ONNHDLBK@Scale?5mode?5?$CIz?$CJ?$AA@ DB 'Scale mode (z)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BOGJJMDB@Spin?5mode?5?$CIc?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@BOGJJMDB@Spin?5mode?5?$CIc?$CJ?$AA@ DB 'Spin mode (c)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KIMJAPJI@Translate?5mode?5?$CIt?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@KIMJAPJI@Translate?5mode?5?$CIt?$CJ?$AA@ DB 'Translate mode (t)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BHGMMKIM@Rotate?5mode?5?$CIr?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@BHGMMKIM@Rotate?5mode?5?$CIr?$CJ?$AA@ DB 'Rotate mode (r)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DCDHHEHM@Left?5button?5modes?3?$AA@
CONST	SEGMENT
??_C@_0BD@DCDHHEHM@Left?5button?5modes?3?$AA@ DB 'Left button modes:', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _myMenuInit
_TEXT	SEGMENT
_myMenuInit PROC					; COMDAT

; 2173 :  { mainmenu = glutCreateMenu(mainmenu_func);

	mov	eax, OFFSET _mainmenu_func
	call	_glutCreateMenu_ATEXIT_HACK@4

; 2174 :    glutSetMenu(mainmenu);

	push	eax
	mov	DWORD PTR _mainmenu, eax
	call	_glutSetMenu@4

; 2175 :    glutAddMenuEntry("Left button modes:",' ');

	push	32					; 00000020H
	push	OFFSET ??_C@_0BD@DCDHHEHM@Left?5button?5modes?3?$AA@
	call	_glutAddMenuEntry@8

; 2176 :    glutAddMenuEntry("Rotate mode (r)",'r');

	push	114					; 00000072H
	push	OFFSET ??_C@_0BA@BHGMMKIM@Rotate?5mode?5?$CIr?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2177 :    glutAddMenuEntry("Translate mode (t)",'t');

	push	116					; 00000074H
	push	OFFSET ??_C@_0BD@KIMJAPJI@Translate?5mode?5?$CIt?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2178 :    glutAddMenuEntry("Spin mode (c)",'c');

	push	99					; 00000063H
	push	OFFSET ??_C@_0O@BOGJJMDB@Spin?5mode?5?$CIc?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2179 :    glutAddMenuEntry("Scale mode (z)",'z');

	push	122					; 0000007aH
	push	OFFSET ??_C@_0P@ONNHDLBK@Scale?5mode?5?$CIz?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2180 :    glutAddMenuEntry("Slice mode (l)",'l');

	push	108					; 0000006cH
	push	OFFSET ??_C@_0P@ILHPBMDC@Slice?5mode?5?$CIl?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2181 :    glutAddMenuEntry("Right button modes:",' ');

	push	32					; 00000020H
	push	OFFSET ??_C@_0BE@KEOEDDJK@Right?5button?5modes?3?$AA@
	call	_glutAddMenuEntry@8

; 2182 :    glutAddMenuEntry("Pick mode (P)",'P');

	push	80					; 00000050H
	push	OFFSET ??_C@_0O@OMNHAKDC@Pick?5mode?5?$CIP?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2183 :    glutAddMenuEntry("Menu mode (M)",'M');

	push	77					; 0000004dH
	push	OFFSET ??_C@_0O@NBPECBPO@Menu?5mode?5?$CIM?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2184 :    glutAddMenuEntry("Edges front (B)",'B');

	push	66					; 00000042H
	push	OFFSET ??_C@_0BA@HDOHBEDN@Edges?5front?5?$CIB?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2185 :    glutAddMenuEntry("Edges back (b)",'b');

	push	98					; 00000062H
	push	OFFSET ??_C@_0P@LCCGEBHG@Edges?5back?5?$CIb?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2186 :    glutAddMenuEntry("Edges thicker (+)",'+');

	push	43					; 0000002bH
	push	OFFSET ??_C@_0BC@BFLELAHC@Edges?5thicker?5?$CI?$CL?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2187 :    glutAddMenuEntry("Edges thinner (-)",'-');

	push	45					; 0000002dH
	push	OFFSET ??_C@_0BC@KIJGCFPD@Edges?5thinner?5?$CI?9?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2188 :    glutAddMenuEntry("Center object (m)",'m');

	push	109					; 0000006dH
	push	OFFSET ??_C@_0BC@NNDLHEBG@Center?5object?5?$CIm?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2189 :    glutAddMenuEntry("Toggle edges (e)",'e');

	push	101					; 00000065H
	push	OFFSET ??_C@_0BB@DMOFDDCF@Toggle?5edges?5?$CIe?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2190 :    glutAddMenuEntry("Toggle faces (f)",'f');

	push	102					; 00000066H
	push	OFFSET ??_C@_0BB@BLEJHNMK@Toggle?5faces?5?$CIf?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2191 :    glutAddMenuEntry("Toggle opacity (O)",'O');

	push	79					; 0000004fH
	push	OFFSET ??_C@_0BD@DHCDAFKO@Toggle?5opacity?5?$CIO?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2192 :    glutAddMenuEntry("Focus on picked vertex (F)",'F');

	push	70					; 00000046H
	push	OFFSET ??_C@_0BL@HPNHDFIB@Focus?5on?5picked?5vertex?5?$CIF?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2193 :    glutAddMenuEntry("Bounding box (o)",'o');

	push	111					; 0000006fH
	push	OFFSET ??_C@_0BB@BJEOMGMC@Bounding?5box?5?$CIo?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2194 :    glutAddMenuEntry("Reset graphics (R)",'R');

	push	82					; 00000052H
	push	OFFSET ??_C@_0BD@HFGGDPFD@Reset?5graphics?5?$CIR?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2195 :    glutAddMenuEntry("",' ');  /* skip funny entry before submenu */

	push	32					; 00000020H
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	call	_glutAddMenuEntry@8

; 2196 : 
; 2197 :    submenu = glutCreateMenu(submenu_func);

	mov	eax, OFFSET _submenu_func
	call	_glutCreateMenu_ATEXIT_HACK@4

; 2198 :    glutSetMenu(submenu);

	push	eax
	mov	DWORD PTR _submenu, eax
	call	_glutSetMenu@4

; 2199 :    glutAddMenuEntry("Another graphics window (G)",'G');

	push	71					; 00000047H
	push	OFFSET ??_C@_0BM@CCHNFNLO@Another?5graphics?5window?5?$CIG?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2200 :    glutAddMenuEntry("Toggle Gourard shading (g)",'g');

	push	103					; 00000067H
	push	OFFSET ??_C@_0BL@FPIIJGDL@Toggle?5Gourard?5shading?5?$CIg?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2201 :    glutAddMenuEntry("Toggle stereo view (s)",'s');

	push	115					; 00000073H
	push	OFFSET ??_C@_0BH@NEHDLBKD@Toggle?5stereo?5view?5?$CIs?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2202 :    glutAddMenuEntry("Toggle orthogonal/perspective view (p)",'p');

	push	112					; 00000070H
	push	OFFSET ??_C@_0CH@DOJDBKEM@Toggle?5orthogonal?1perspective?5vi@
	call	_glutAddMenuEntry@8

; 2203 :    glutAddMenuEntry("Toggle arrays (a)",'a');

	push	97					; 00000061H
	push	OFFSET ??_C@_0BC@POOHBHDI@Toggle?5arrays?5?$CIa?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2204 :    glutAddMenuEntry("Toggle interleaved arrays (i)",'i');

	push	105					; 00000069H
	push	OFFSET ??_C@_0BO@FCLPDINO@Toggle?5interleaved?5arrays?5?$CIi?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2205 :    glutAddMenuEntry("Toggle indexed arrays (I)",'I');

	push	73					; 00000049H
	push	OFFSET ??_C@_0BK@ODOEAJDF@Toggle?5indexed?5arrays?5?$CII?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2206 :    glutAddMenuEntry("Toggle strips (S)",'S');

	push	83					; 00000053H
	push	OFFSET ??_C@_0BC@GEPBHFON@Toggle?5strips?5?$CIS?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2207 :    glutAddMenuEntry("Toggle strip coloring (Y)",'Y');

	push	89					; 00000059H
	push	OFFSET ??_C@_0BK@HPPMCLPE@Toggle?5strip?5coloring?5?$CIY?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2208 :    glutAddMenuEntry("Toggle display lists (D)",'D');

	push	68					; 00000044H
	push	OFFSET ??_C@_0BJ@EKCJNNAC@Toggle?5display?5lists?5?$CID?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2209 :    glutAddMenuEntry("Print drawing stats (Q)",'Q');

	push	81					; 00000051H
	push	OFFSET ??_C@_0BI@PLHMHBGO@Print?5drawing?5stats?5?$CIQ?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2210 :    #ifdef MPI_EVOLVER
; 2211 :    glutAddMenuEntry("Toggle corona display (y)",'y');
; 2212 :    #endif
; 2213 :    glutSetMenu(mainmenu);

	mov	eax, DWORD PTR _mainmenu
	push	eax
	call	_glutSetMenu@4

; 2214 :    glutAddSubMenu("Advanced",submenu);

	mov	ecx, DWORD PTR _submenu
	push	ecx
	push	OFFSET ??_C@_08IILCFNBD@Advanced?$AA@
	call	_glutAddSubMenu@8

; 2215 : 
; 2216 :    #ifdef MPI_EVOLVER
; 2217 :    { int task;
; 2218 :      mpi_taskmenu = glutCreateMenu(mpi_taskmenu_func);
; 2219 :      glutSetMenu(mpi_taskmenu);
; 2220 :      for ( task = 1 ; task < mpi_nprocs ; task++ )
; 2221 :      { char number[10];
; 2222 :        sprintf(number," %4d ",task);
; 2223 :        glutAddMenuEntry(number,task);
; 2224 :      }
; 2225 :      glutSetMenu(mainmenu);
; 2226 :      glutAddSubMenu("Pick MPI task",mpi_taskmenu);
; 2227 :    }
; 2228 :    #endif
; 2229 : 
; 2230 :    glutAddMenuEntry("Close graphics (x)",'x');

	push	120					; 00000078H
	push	OFFSET ??_C@_0BD@LGHJLNCL@Close?5graphics?5?$CIx?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2231 :    glutAddMenuEntry("Exit Evolver (X)",'X');

	push	88					; 00000058H
	push	OFFSET ??_C@_0BB@BEGFOEPP@Exit?5Evolver?5?$CIX?$CJ?$AA@
	call	_glutAddMenuEntry@8

; 2232 :    glutAttachMenu(GLUT_MIDDLE_BUTTON);

	push	1
	call	_glutAttachMenu@4

; 2233 :  } // end myMenuInit()

	ret	0
_myMenuInit ENDP
_TEXT	ENDS
PUBLIC	__real@3ff6666666666666
PUBLIC	__real@bff6666666666666
PUBLIC	__real@3f747ae147ae147b
PUBLIC	??_C@_0BK@CONOEALI@glut?5window?5id?5too?5high?4?6?$AA@ ; `string'
PUBLIC	??_C@_0P@FHGLGEEJ@GL_ATI_meminfo?$AA@		; `string'
PUBLIC	??_C@_0BH@PLDKIMGD@GL_NVX_gpu_memory_info?$AA@	; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_0CF@GANIANEG@No?5more?5graphics?5windows?5availab@ ; `string'
PUBLIC	??_C@_07MMDJMDDC@Evolver?$AA@			; `string'
PUBLIC	__$ArrayPad$
EXTRN	_glutMainLoop@0:PROC
EXTRN	_glutDisplayFunc@4:PROC
EXTRN	__imp__glLightModeli@8:PROC
EXTRN	__imp__glMaterialfv@12:PROC
EXTRN	__imp__glColorMaterial@8:PROC
EXTRN	__imp__SetForegroundWindow@4:PROC
EXTRN	__imp__EnumThreadWindows@12:PROC
EXTRN	_glutShowWindow@0:PROC
EXTRN	_glutReshapeFunc@4:PROC
EXTRN	_glutSpecialFunc@4:PROC
EXTRN	_glutKeyboardFunc@4:PROC
EXTRN	_glutMotionFunc@4:PROC
EXTRN	_glutMouseFunc@4:PROC
EXTRN	_strncmp:PROC
EXTRN	_strcspn:PROC
EXTRN	__imp__glGetString@4:PROC
EXTRN	_glutInitWindowSize@8:PROC
EXTRN	_glutInitWindowPosition@8:PROC
EXTRN	_y_pixel_height_cmd_line:DWORD
EXTRN	_x_pixel_width_cmd_line:DWORD
EXTRN	_y_pixel_down_cmd_line:DWORD
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	_glutInitDisplayMode@4:PROC
EXTRN	_rgb_colors:BYTE
EXTRN	__imp__SetThreadAffinityMask@8:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	_graphics_affinity_mask:DWORD
EXTRN	__imp__TlsSetValue@8:PROC
EXTRN	_glutgraph_thread_data:BYTE
EXTRN	_thread_data_key:DWORD
EXTRN	_draw_thread_id:DWORD
EXTRN	__imp__GetForegroundWindow@0:PROC
_BSS	SEGMENT
_handle_count DD 01H DUP (?)
?win_id@?1??draw_thread@@9@9 DD 01H DUP (?)		; `draw_thread'::`2'::win_id
_glutInit_called DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@3ff6666666666666
CONST	SEGMENT
__real@3ff6666666666666 DQ 03ff6666666666666r	; 1.4
CONST	ENDS
;	COMDAT __real@bff6666666666666
CONST	SEGMENT
__real@bff6666666666666 DQ 0bff6666666666666r	; -1.4
CONST	ENDS
;	COMDAT __real@3f747ae147ae147b
CONST	SEGMENT
__real@3f747ae147ae147b DQ 03f747ae147ae147br	; 0.005
CONST	ENDS
;	COMDAT ??_C@_0BK@CONOEALI@glut?5window?5id?5too?5high?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@CONOEALI@glut?5window?5id?5too?5high?4?6?$AA@ DB 'glut window i'
	DB	'd too high.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FHGLGEEJ@GL_ATI_meminfo?$AA@
CONST	SEGMENT
??_C@_0P@FHGLGEEJ@GL_ATI_meminfo?$AA@ DB 'GL_ATI_meminfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PLDKIMGD@GL_NVX_gpu_memory_info?$AA@
CONST	SEGMENT
??_C@_0BH@PLDKIMGD@GL_NVX_gpu_memory_info?$AA@ DB 'GL_NVX_gpu_memory_info'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GANIANEG@No?5more?5graphics?5windows?5availab@
CONST	SEGMENT
??_C@_0CF@GANIANEG@No?5more?5graphics?5windows?5availab@ DB 'No more grap'
	DB	'hics windows available.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MMDJMDDC@Evolver?$AA@
CONST	SEGMENT
??_C@_07MMDJMDDC@Evolver?$AA@ DB 'Evolver', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _draw_thread
_TEXT	SEGMENT
_argv$ = -152						; size = 4
_argc$ = -148						; size = 4
tv3189 = -144						; size = 4
_did_graphlock_here$95520 = -140			; size = 4
_foregroundhwnd$ = -140					; size = 4
tv3402 = -136						; size = 4
tv598 = -136						; size = 4
tv3007 = -132						; size = 4
_ypixels$ = -132					; size = 4
tv2995 = -128						; size = 4
_xpixels$ = -128					; size = 4
_wintitle$ = -124					; size = 120
__$ArrayPad$ = -4					; size = 4
_arglist$ = 8						; size = 4
_draw_thread PROC					; COMDAT

; 2302 : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi

; 2303 :   int argc = 1; /* to keep glutInit happy */

	mov	ebx, 1
	push	edi
	mov	DWORD PTR _argc$[ebp], ebx

; 2304 :   char *argv = "Evolver";

	mov	DWORD PTR _argv$[ebp], OFFSET ??_C@_07MMDJMDDC@Evolver?$AA@

; 2305 :   struct graph_thread_data *td;
; 2306 :   char wintitle[WINTITLESIZE];
; 2307 :   static int win_id;
; 2308 :   int glut_id;
; 2309 :   int xpixels,ypixels;
; 2310 : #ifdef __L_EVOLVER__
; 2311 :   int dwWidth;		/* added by Y Chen, 10/13/2010 */
; 2312 :   int dwHeight;
; 2313 : #endif
; 2314 : #ifdef WIN32
; 2315 :   HWND foregroundhwnd = GetForegroundWindow();

	call	DWORD PTR __imp__GetForegroundWindow@0
	mov	DWORD PTR _foregroundhwnd$[ebp], eax

; 2316 :   draw_thread_id = GetCurrentThreadId();

	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	DWORD PTR _draw_thread_id, eax

; 2317 :   /* set per-thread data */
; 2318 :   TlsSetValue(thread_data_key,(void*)&glutgraph_thread_data);

	mov	eax, DWORD PTR _thread_data_key
	push	OFFSET _glutgraph_thread_data
	push	eax
	call	DWORD PTR __imp__TlsSetValue@8

; 2319 :   if ( graphics_affinity_mask )

	mov	eax, DWORD PTR _graphics_affinity_mask
	test	eax, eax
	je	SHORT $LN44@draw_threa

; 2320 : 	  SetThreadAffinityMask(GetCurrentThread(),graphics_affinity_mask);

	push	eax
	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	call	DWORD PTR __imp__SetThreadAffinityMask@8
$LN44@draw_threa:

; 2321 :   
; 2322 : #else
; 2323 :   draw_thread_id = pthread_self();  /* get thread id */
; 2324 :   draw_pid = getpid();
; 2325 :   /* set per-thread data */
; 2326 :   pthread_setspecific(thread_data_key,(void*)&glutgraph_thread_data);
; 2327 : #endif
; 2328 : 
; 2329 :   for ( i = 0 ; i < 16 ; i++ )

	mov	ecx, OFFSET _rgba+4
	mov	eax, OFFSET _rgb_colors+8
$LL43@draw_threa:

; 2330 :     for ( j = 0 ; j < 4 ; j++ )
; 2331 :       rgba[i][j] = (float)rgb_colors[i][j];

	fld	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	fstp	DWORD PTR [ecx-4]
	add	ecx, 16					; 00000010H
	fld	QWORD PTR [eax-32]
	fstp	DWORD PTR [ecx-16]
	fld	QWORD PTR [eax-24]
	fstp	DWORD PTR [ecx-12]
	fld	QWORD PTR [eax-16]
	fstp	DWORD PTR [ecx-8]
	cmp	eax, OFFSET _rgb_colors+520
	jl	SHORT $LL43@draw_threa

; 2332 : 
; 2333 :   if ( !glutInit_called )

	cmp	DWORD PTR _glutInit_called, 0
	jne	SHORT $LN37@draw_threa

; 2334 :     glutInit(&argc,&argv);

	lea	eax, DWORD PTR _argv$[ebp]
	lea	ecx, DWORD PTR _argc$[ebp]
	call	_glutInit_ATEXIT_HACK@8
$LN37@draw_threa:

; 2335 :   glutInit_called = 1;
; 2336 :   if ( !graph_thread_running ) win_id = 0;

	cmp	DWORD PTR _graph_thread_running, 0
	mov	DWORD PTR _glutInit_called, ebx
	jne	SHORT $LN88@draw_threa
	xor	eax, eax
	jmp	SHORT $LN36@draw_threa
$LN88@draw_threa:
	mov	eax, DWORD PTR ?win_id@?1??draw_thread@@9@9
$LN36@draw_threa:

; 2337 :   win_id++;

	add	eax, ebx
	mov	DWORD PTR ?win_id@?1??draw_thread@@9@9, eax

; 2338 :   if ( win_id >= MAXGRAPHWINDOWS )

	cmp	eax, 10					; 0000000aH
	jl	SHORT $LN90@draw_threa

; 2339 :   { kb_error(2556,"No more graphics windows available.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CF@GANIANEG@No?5more?5graphics?5windows?5availab@
	push	2556					; 000009fcH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN90@draw_threa:

; 2340 :   }
; 2341 :   glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH );

	push	18					; 00000012H
	call	_glutInitDisplayMode@4

; 2342 : #ifdef __L_EVOLVER__
; 2343 :   /* original: glutInitWindowPosition((20*win_id)%400,(20*win_id)%400);*/
; 2344 : 
; 2345 :   /* Beginning, added by Y Chen, get the screen size, 10/13/2010 */
; 2346 :   //glGetIntegerv(GL_VIEWPORT, m_viewport);  
; 2347 :   //printf ("%d\n",m_viewport[1]);
; 2348 :   //printf ("%d\n",m_viewport[2]);
; 2349 :   //printf ("%d\n",m_viewport[3]);
; 2350 :   //printf ("%d\n",m_viewport[4]);
; 2351 : 
; 2352 :   dwWidth = GetSystemMetrics(SM_CXSCREEN);

	mov	esi, DWORD PTR __imp__GetSystemMetrics@4
	push	0
	call	esi

; 2353 :   dwHeight = GetSystemMetrics(SM_CYSCREEN);

	push	ebx
	mov	edi, eax
	call	esi

; 2354 :   //printf ("%d\n",dwWidth);
; 2355 :   //printf ("%d\n",dwHeight);
; 2356 :   /* xpixels is the width of the OGL display area, 730 the whole width of the window, 8 is the total thickness of the window frame */
; 2357 :  
; 2358 :   /* ypixels is the hieght of the OGL display area, 871 the whole height of the window, (30 + 4) the upper + lower thickness of the window frame */
; 2359 :   /* ypixels will be passed in command line argument */
; 2360 :   /* modified by Y. Chen, when ScreenSizeIndex == 4, it is for the viewer, otherwise, for SE-FIT, 12/05/2011 */
; 2361 :   if (y_pixel_down_cmd_line != -1) //Check if -S values were passed in and use if they were present

	mov	ecx, DWORD PTR _y_pixel_down_cmd_line
	cmp	ecx, -1
	je	SHORT $LN34@draw_threa

; 2362 :     {
; 2363 :     xpixels =  x_pixel_width_cmd_line;

	mov	edx, DWORD PTR _x_pixel_width_cmd_line

; 2364 : 	ypixels = y_pixel_height_cmd_line;

	mov	eax, DWORD PTR _y_pixel_height_cmd_line

; 2365 : 	glutInitWindowPosition(0, y_pixel_down_cmd_line);

	push	ecx
	mov	DWORD PTR _xpixels$[ebp], edx
	mov	DWORD PTR _ypixels$[ebp], eax
	push	0

; 2366 :     }
; 2367 :   else

	jmp	SHORT $LN95@draw_threa
$LN34@draw_threa:

; 2368 :     {
; 2369 :     xpixels = 800-8-8 ; //(int)(dwWidth*0.57) - 8; //730 - 8; 
; 2370 : 	ypixels = (dwHeight - 105 - 33) - 34-10; //(dwHeight - 120 - 33) - 34; // 871 - 34; 

	add	eax, -182				; ffffff4aH
	mov	DWORD PTR _ypixels$[ebp], eax

; 2371 : 	  /* 120 is the height of the FIT main window, 29 the upper portion height of the OGL window */
; 2372 : 	  /* 120+29 to be passed in command line argument */
; 2373 : 	glutInitWindowPosition((int)((dwWidth-800)/2)+8,0); //(0, 120 + 29); 

	lea	eax, DWORD PTR [edi-800]
	cdq
	sub	eax, edx
	sar	eax, 1
	push	0
	add	eax, 8
	mov	DWORD PTR _xpixels$[ebp], 784		; 00000310H
	push	eax
$LN95@draw_threa:
	call	_glutInitWindowPosition@8

; 2374 : 	  /* End, added by Y Chen, get the screen size, 10/13/2010 */
; 2375 :     }
; 2376 : //
; 2377 :  // if ( ScreenSizeIndex==0 )
; 2378 :  // {  
; 2379 : 	//glutInitWindowPosition(0, 120 + 29); 
; 2380 : 	//if ( window_aspect_ratio )
; 2381 : 	//  { xpixels = (int)(670/sqrt(fabs(window_aspect_ratio)));
; 2382 : 	//	ypixels = (int)(669*sqrt(fabs(window_aspect_ratio)));
; 2383 : 	//	/*{ xpixels = (int)(400/sqrt(fabs(window_aspect_ratio)));
; 2384 : 	//	ypixels = (int)(400*sqrt(fabs(window_aspect_ratio)));*/
; 2385 : 	//  }
; 2386 : 
; 2387 : 	// else 
; 2388 : 	//  { 
; 2389 : 	//	xpixels = 730 - 8; 
; 2390 : 	//	
; 2391 : 	//    ypixels = 871 - 34; 
; 2392 : 	//  }
; 2393 :  // }
; 2394 :  // else /* Screen Size Index Presets */
; 2395 :  // {
; 2396 : 	//switch (ScreenSizeIndex)
; 2397 : 	//{
; 2398 : 	//case 1:
; 2399 : 	//	glutInitWindowPosition(0, 150); // FIT1054 (103-28,79+32+9);
; 2400 : 	//    xpixels = 450 - 8;          //350-6+28;
; 2401 : 	//    ypixels = 399 - 42;         //350-33-9;
; 2402 : 	//	break;
; 2403 : 	//case 2:
; 2404 : 	//	glutInitWindowPosition(0, 150);
; 2405 : 	//    xpixels = 520 - 8;          //420-6+28;
; 2406 : 	//	ypixels = 519 - 42;         //420-33-9;
; 2407 : 	//	break;
; 2408 : 	//case 3:
; 2409 : 	//	glutInitWindowPosition(0, 150);
; 2410 : 	//    xpixels = 620 - 8;          //520-6+28; 
; 2411 : 	//	ypixels = 663 - 42;         //520-33-9; 
; 2412 : 	//  	break;
; 2413 : 	//case 4:
; 2414 : 	//	glutInitWindowPosition(0, 150); //(103-28,79+32+9);
; 2415 : 	//	xpixels = 770 - 8 ;         //670-6+28;
; 2416 : 	//	ypixels = 823 - 42;         //670-33-9; 
; 2417 : 	//	break;
; 2418 : 	//case 5:
; 2419 : 	//	glutInitWindowPosition(0, 150);
; 2420 : 	//	xpixels = 1170 - 8;         //1070-6+28;
; 2421 : 	//	ypixels = 849 - 42;         //720-33-9; 
; 2422 : 	//	break;
; 2423 : 	//}
; 2424 :   //}
; 2425 : 
; 2426 : #else 
; 2427 : glutInitWindowPosition((20*win_id)%400,(20*win_id)%400);
; 2428 :   if ( window_aspect_ratio )
; 2429 :   { xpixels = (int)(400/sqrt(fabs(window_aspect_ratio)));
; 2430 :     ypixels = (int)(400*sqrt(fabs(window_aspect_ratio)));
; 2431 :   }
; 2432 :   else 
; 2433 :   { xpixels = 400;
; 2434 :     ypixels = 400;
; 2435 :   }
; 2436 : #endif
; 2437 :   glutInitWindowSize(xpixels,ypixels); 

	mov	ecx, DWORD PTR _ypixels$[ebp]
	mov	edx, DWORD PTR _xpixels$[ebp]
	push	ecx
	push	edx
	call	_glutInitWindowSize@8

; 2438 : #ifdef MAC_OS_X
; 2439 :   { char title[1000];
; 2440 :     sprintf(title,"   %s (CTRL-click for right mouse button)",datafilename);
; 2441 :     glutCreateWindow(title);
; 2442 :   }
; 2443 : #else
; 2444 :   glutCreateWindow(datafilename);

	mov	eax, OFFSET _datafilename
	call	_glutCreateWindow_ATEXIT_HACK@4

; 2445 : #endif
; 2446 : 
; 2447 : 
; 2448 : 
; 2449 :   // Test for some OpenGL extensions
; 2450 :   { const GLubyte *s = glGetString(GL_VERSION);

	push	7938					; 00001f02H
	call	DWORD PTR __imp__glGetString@4
	mov	esi, eax

; 2451 :     //s = glGetString(GL_EXTENSIONS);
; 2452 :     const GLubyte *end = s + strlen((char*)s);

	lea	edx, DWORD PTR [eax+1]
$LL82@draw_threa:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL82@draw_threa
	sub	eax, edx
	lea	ebx, DWORD PTR [eax+esi]

; 2453 :     size_t nvlen = strlen("GL_NVX_gpu_memory_info");
; 2454 :     size_t atilen = strlen("GL_ATI_meminfo");
; 2455 :     while ( s < end )

	cmp	esi, ebx
	jae	SHORT $LN31@draw_threa
	npad	9
$LL32@draw_threa:

; 2456 :     { size_t n = strcspn((char*)s," ");

	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	esi
	call	_strcspn

; 2457 :       if ( strncmp((char*)s,"GL_NVX_gpu_memory_info",nvlen) == 0 )

	push	22					; 00000016H
	push	OFFSET ??_C@_0BH@PLDKIMGD@GL_NVX_gpu_memory_info?$AA@
	push	esi
	mov	edi, eax
	call	_strncmp
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN30@draw_threa

; 2458 :       { nvidia_gpu_flag = 1;

	mov	DWORD PTR _nvidia_gpu_flag, 1
$LN30@draw_threa:

; 2459 :       }
; 2460 :       if ( strncmp((char*)s,"GL_ATI_meminfo",atilen) == 0 )

	push	14					; 0000000eH
	push	OFFSET ??_C@_0P@FHGLGEEJ@GL_ATI_meminfo?$AA@
	push	esi
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN29@draw_threa

; 2461 :       { ati_gpu_flag = 1;

	mov	DWORD PTR _ati_gpu_flag, 1
$LN29@draw_threa:

; 2462 :       }
; 2463 :       s += n + 1;

	lea	esi, DWORD PTR [esi+edi+1]
	cmp	esi, ebx
	jb	SHORT $LL32@draw_threa
$LN31@draw_threa:

; 2464 :     }
; 2465 :   }       
; 2466 : 
; 2467 :   glutMouseFunc(mouse_func); 

	push	OFFSET _mouse_func
	call	_glutMouseFunc@4

; 2468 :   glutMotionFunc(mouse_loc_func); 

	push	OFFSET _mouse_loc_func
	call	_glutMotionFunc@4

; 2469 :   glutKeyboardFunc(key_func);

	push	OFFSET _key_func
	call	_glutKeyboardFunc@4

; 2470 :   glutSpecialFunc(specialkey_func);

	push	OFFSET _specialkey_func
	call	_glutSpecialFunc@4

; 2471 :   glutReshapeFunc(reshape_func);

	push	OFFSET _reshape_func
	call	_glutReshapeFunc@4

; 2472 :   glutIdleFunc(idle_func); 

	push	OFFSET _idle_func
	call	_glutIdleFunc@4

; 2473 :   myMenuInit();

	call	_myMenuInit

; 2474 :   glutShowWindow();  /* start on top */

	call	_glutShowWindow@0

; 2475 : 
; 2476 :   glut_id = glutGetWindow(); /* window identifier */

	call	_glutGetWindow@0
	mov	edi, eax

; 2477 :   if ( glut_id >= 10 )

	cmp	edi, 10					; 0000000aH
	jl	SHORT $LN28@draw_threa

; 2478 :   { kb_error(2596,"glut window id too high.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BK@CONOEALI@glut?5window?5id?5too?5high?4?6?$AA@
	push	2596					; 00000a24H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2602 :   } 
; 2603 : #ifdef PTHREADS
; 2604 :   return NULL;
; 2605 : #endif
; 2606 : } // end draw_thread()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@draw_threa:

; 2479 : #ifdef PTHREADS
; 2480 :     return NULL;
; 2481 : #else 
; 2482 :     return;
; 2483 : #endif
; 2484 :   }
; 2485 :   else td = gthread_data + glut_id;
; 2486 : 
; 2487 : #ifdef WIN32
; 2488 :   /* get window handle, do this before setting win_id to prevent
; 2489 :      race with main thread display() */
; 2490 :   handle_count = 1;
; 2491 :   EnumThreadWindows(draw_thread_id,handle_func,0);

	mov	eax, DWORD PTR _draw_thread_id
	push	0
	push	OFFSET _handle_func@8
	mov	ebx, 1
	push	eax
	mov	DWORD PTR _handle_count, ebx
	call	DWORD PTR __imp__EnumThreadWindows@12

; 2492 : 
; 2493 :   /* try to get on top */
; 2494 :  
; 2495 :   SetForegroundWindow(gthread_data[glut_id].draw_hwnd);

	mov	esi, DWORD PTR __imp__SetForegroundWindow@4
	mov	ecx, edi
	imul	ecx, 9896				; 000026a8H
	mov	edx, DWORD PTR _gthread_data[ecx+144]
	push	edx
	call	esi

; 2496 :   SetForegroundWindow(foregroundhwnd);  /* get console back on top */

	mov	eax, DWORD PTR _foregroundhwnd$[ebp]
	push	eax
	call	esi

; 2497 : 
; 2498 : #endif
; 2499 :   td = GET_DATA;

	call	_glutGetWindow@0

; 2500 :   td->in_use = 1;
; 2501 :   td->win_id = glut_id;
; 2502 :   td->aspect = 1;

	fld1
	mov	esi, eax
	imul	esi, 9896				; 000026a8H
	add	esi, OFFSET _gthread_data

; 2503 :   td->xscale=2.8/xpixels;
; 2504 :   td->yscale=2.8/ypixels;
; 2505 :   if ( background_color == -1 )

	cmp	DWORD PTR _background_color, -1
	mov	DWORD PTR [esi], ebx
	fst	QWORD PTR [esi+216]
	mov	DWORD PTR [esi+140], edi
	fild	DWORD PTR _xpixels$[ebp]
	fld	QWORD PTR __real@4006666666666666
	fld	ST(0)
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [esi+232]
	fidiv	DWORD PTR _ypixels$[ebp]
	fstp	QWORD PTR [esi+240]
	jne	SHORT $LN26@draw_threa

; 2506 :      background_color = LIGHTBLUE;

	mov	DWORD PTR _background_color, 9
$LN26@draw_threa:

; 2507 :   td->xsize = xpixels; 

	mov	ecx, DWORD PTR _xpixels$[ebp]

; 2508 :   td->ysize = ypixels;
; 2509 :   td->projmode = P_ORTHO;    /* kind of projection to do */
; 2510 :   td->stereomode = NO_STEREO;
; 2511 :   td->facetshow_flag = 1; /* whether to show facets */
; 2512 :   td->linewidth = 1.0;

	fstp	QWORD PTR [esi+1712]
	mov	edx, DWORD PTR _ypixels$[ebp]

; 2513 :   td->edge_bias = 0.005; /* amount edges drawn in front */

	fld	QWORD PTR __real@3f747ae147ae147b
	xor	eax, eax
	fstp	QWORD PTR [esi+1720]
	mov	DWORD PTR [esi+248], ecx
	mov	DWORD PTR [esi+252], edx
	mov	DWORD PTR [esi+1632], eax
	mov	DWORD PTR [esi+1700], eax
	mov	DWORD PTR [esi+1704], ebx

; 2514 :   td->mouse_left_state = GLUT_UP; /* state of left mouse button */

	mov	DWORD PTR [esi+1732], ebx

; 2515 :   td->mouse_mode = MM_ROTATE;

	mov	DWORD PTR [esi+1728], ebx

; 2516 :   if (glut_id > 1 ) 

	cmp	edi, ebx
	jle	SHORT $LN25@draw_threa

; 2517 :   { if ( strlen(datafilename) > 60 )

	mov	eax, OFFSET _datafilename
	lea	edx, DWORD PTR [eax+1]
$LL83@draw_threa:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL83@draw_threa
	sub	eax, edx

; 2518 :       sprintf(wintitle,"  %1.*s - Camera %d",WINTITLESIZE-30,
; 2519 :          datafilename+strlen(datafilename)-60, glut_id);

	push	edi
	cmp	eax, 60					; 0000003cH
	jbe	SHORT $LN24@draw_threa
	lea	eax, DWORD PTR _datafilename[eax-60]
	push	eax
	push	90					; 0000005aH
	push	OFFSET ??_C@_0BE@OHNHDFEH@?5?5?$CF1?4?$CKs?5?9?5Camera?5?$CFd?$AA@
	lea	ecx, DWORD PTR _wintitle$[ebp]
	push	ecx

; 2520 :     else  sprintf(wintitle,"  %1.*s - Camera %d",WINTITLESIZE-30,

	jmp	SHORT $LN96@draw_threa
$LN24@draw_threa:

; 2521 :          datafilename,glut_id);

	push	OFFSET _datafilename
	push	90					; 0000005aH
	push	OFFSET ??_C@_0BE@OHNHDFEH@?5?5?$CF1?4?$CKs?5?9?5Camera?5?$CFd?$AA@
	lea	edx, DWORD PTR _wintitle$[ebp]
	push	edx
$LN96@draw_threa:
	call	_sprintf
	add	esp, 20					; 00000014H

; 2522 : #ifdef MPI_EVOLVER
; 2523 :     sprintf(wintitle+strlen(wintitle)," (task %d)",this_task);
; 2524 : #endif
; 2525 :     glutSetWindowTitle(wintitle);

	lea	eax, DWORD PTR _wintitle$[ebp]
	push	eax
	call	_glutSetWindowTitle@4
$LN25@draw_threa:

; 2526 :   }
; 2527 : 
; 2528 :   ENTER_GRAPH_MUTEX; /* due to view[][] */

	mov	edi, DWORD PTR __imp__GetCurrentThreadId@0
	call	edi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN22@draw_threa
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	ebx
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	edi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$95520[ebp], ebx
	jmp	SHORT $LN21@draw_threa
$LN22@draw_threa:
	mov	DWORD PTR _did_graphlock_here$95520[ebp], 0
$LN21@draw_threa:

; 2529 :   if ( dup_window )

	mov	eax, DWORD PTR _dup_window
	test	eax, eax
	je	$LN20@draw_threa

; 2530 :   { struct graph_thread_data *tdd = gthread_data+dup_window;

	imul	eax, 9896				; 000026a8H
	add	eax, OFFSET _gthread_data
	mov	edx, eax
	lea	edi, DWORD PTR [edx+1192]
	lea	ecx, DWORD PTR [esi+800]

; 2531 :     for ( i = 0 ; i < MAXCOORD ; i++ )

	sub	edx, esi
	mov	DWORD PTR tv2995[ebp], edi
	lea	eax, DWORD PTR [esi+280]
	mov	DWORD PTR tv3007[ebp], ecx
	mov	DWORD PTR tv3189[ebp], edx
	mov	DWORD PTR tv598[ebp], 6
	jmp	SHORT $LN19@draw_threa
	npad	5
$LL89@draw_threa:

; 2530 :   { struct graph_thread_data *tdd = gthread_data+dup_window;

	mov	edx, DWORD PTR tv3189[ebp]
$LN19@draw_threa:

; 2532 :     { td->view[i] = td->viewspace[i];
; 2533 :       td->to_focus[i] = td->to_focus_space[i];

	mov	DWORD PTR [eax+488], ecx
	lea	ebx, DWORD PTR [ecx-488]
	mov	DWORD PTR [eax], ebx

; 2534 :       td->from_focus[i] = td->from_focus_space[i];

	add	ecx, 424				; 000001a8H
	mov	DWORD PTR [eax+912], ecx

; 2535 :       for ( j = 0 ; j < MAXCOORD ; j++ )
; 2536 :       { td->view[i][j] = tdd->view[i][j]; 

	mov	ecx, DWORD PTR [eax+edx]
	fld	QWORD PTR [ecx]

; 2537 :         td->to_focus[i][j] = tdd->to_focus[i][j];

	mov	edi, DWORD PTR [edi-424]
	mov	edx, ebx
	fstp	QWORD PTR [edx]
	mov	ebx, DWORD PTR [eax+488]
	fld	QWORD PTR [edi]
	add	eax, 4
	fstp	QWORD PTR [ebx]

; 2538 :         td->from_focus[i][j] = tdd->from_focus[i][j];

	mov	ebx, DWORD PTR tv2995[ebp]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [eax+908]
	fstp	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [eax+484]
	fld	QWORD PTR [ecx+8]
	fstp	QWORD PTR [edx+8]
	fld	QWORD PTR [edi+8]
	fstp	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR tv2995[ebp]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [eax+908]
	fstp	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [eax+484]
	fld	QWORD PTR [ecx+16]
	fstp	QWORD PTR [edx+16]
	fld	QWORD PTR [edi+16]
	fstp	QWORD PTR [ebx+16]
	mov	ebx, DWORD PTR tv2995[ebp]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+16]
	mov	ebx, DWORD PTR [eax+908]
	fstp	QWORD PTR [ebx+16]
	mov	ebx, DWORD PTR [eax+484]
	fld	QWORD PTR [ecx+24]
	fstp	QWORD PTR [edx+24]
	fld	QWORD PTR [edi+24]
	fstp	QWORD PTR [ebx+24]
	mov	ebx, DWORD PTR tv2995[ebp]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+24]
	mov	ebx, DWORD PTR [eax+908]
	fstp	QWORD PTR [ebx+24]
	mov	ebx, DWORD PTR [eax+484]
	fld	QWORD PTR [ecx+32]
	fstp	QWORD PTR [edx+32]
	fld	QWORD PTR [edi+32]
	fstp	QWORD PTR [ebx+32]
	mov	ebx, DWORD PTR tv2995[ebp]
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [ebx+32]
	mov	ebx, DWORD PTR [eax+908]
	fstp	QWORD PTR [ebx+32]
	fld	QWORD PTR [ecx+40]
	mov	ecx, DWORD PTR [eax+484]
	fstp	QWORD PTR [edx+40]
	fld	QWORD PTR [edi+40]
	mov	edi, DWORD PTR tv2995[ebp]
	fstp	QWORD PTR [ecx+40]
	mov	ecx, DWORD PTR [edi]
	fld	QWORD PTR [ecx+40]
	mov	ecx, DWORD PTR tv3007[ebp]
	fstp	QWORD PTR [ebx+40]
	add	edi, 4
	add	ecx, 56					; 00000038H
	mov	ebx, 1
	sub	DWORD PTR tv598[ebp], ebx
	mov	DWORD PTR tv2995[ebp], edi
	mov	DWORD PTR tv3007[ebp], ecx
	jne	$LL89@draw_threa

; 2539 :       }
; 2540 :     }
; 2541 :     dup_window = 0; 

	mov	DWORD PTR _dup_window, 0

; 2542 :   } 
; 2543 :   else

	jmp	$LN13@draw_threa
$LN20@draw_threa:

; 2544 :   { for ( i = 0 ; i < MAXCOORD ; i++ )
; 2545 :     { td->view[i] = td->viewspace[i];

	lea	ecx, DWORD PTR [esi+312]
	mov	DWORD PTR [esi+280], ecx
	lea	eax, DWORD PTR [esi+280]

; 2546 :       td->to_focus[i] = td->to_focus_space[i];
; 2547 :       td->from_focus[i] = td->from_focus_space[i];

	lea	ecx, DWORD PTR [esi+1224]
	mov	DWORD PTR [esi+1192], ecx
	lea	edx, DWORD PTR [esi+800]
	mov	DWORD PTR [esi+768], edx
	lea	ecx, DWORD PTR [esi+856]
	mov	DWORD PTR [esi+772], ecx
	lea	edx, DWORD PTR [esi+368]
	mov	DWORD PTR [esi+284], edx
	lea	ecx, DWORD PTR [esi+424]
	mov	DWORD PTR [esi+288], ecx
	lea	edx, DWORD PTR [esi+1280]
	mov	DWORD PTR [esi+1196], edx
	lea	ecx, DWORD PTR [esi+1336]
	mov	DWORD PTR [esi+1200], ecx
	lea	edx, DWORD PTR [esi+912]
	mov	DWORD PTR [esi+776], edx
	lea	ecx, DWORD PTR [esi+968]
	mov	DWORD PTR [esi+780], ecx
	lea	edx, DWORD PTR [esi+480]
	mov	DWORD PTR [esi+292], edx
	lea	ecx, DWORD PTR [esi+536]
	lea	edx, DWORD PTR [esi+1392]
	mov	DWORD PTR [esi+296], ecx
	mov	DWORD PTR [esi+1204], edx
	lea	ecx, DWORD PTR [esi+1448]
	lea	edx, DWORD PTR [esi+1024]
	mov	DWORD PTR [esi+1208], ecx
	mov	DWORD PTR [esi+784], edx
	lea	ecx, DWORD PTR [esi+1080]
	lea	edx, DWORD PTR [esi+592]
	mov	DWORD PTR [esi+788], ecx

; 2548 :     }
; 2549 :     for ( i = 0 ; i < HOMDIM ; i++ )

	mov	ecx, DWORD PTR _HOMDIM
	mov	DWORD PTR [esi+300], edx
	lea	edx, DWORD PTR [esi+1504]
	xor	ebx, ebx
	mov	DWORD PTR [esi+1212], edx
	test	ecx, ecx
	jle	SHORT $LN7@draw_threa

; 2544 :   { for ( i = 0 ; i < MAXCOORD ; i++ )
; 2545 :     { td->view[i] = td->viewspace[i];

	mov	DWORD PTR tv3402[ebp], eax
	npad	7
$LL91@draw_threa:

; 2550 :       for ( j = 0 ; j < HOMDIM ; j++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN8@draw_threa
	mov	ecx, DWORD PTR _view
	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR [ecx+ebx*4]
	sub	edi, eax
$LL6@draw_threa:

; 2551 :         td->view[i][j] = view[i][j];  /* initialize to global view */

	fld	QWORD PTR [edi+eax]
	inc	edx
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR _HOMDIM
	add	eax, 8
	cmp	edx, ecx
	jl	SHORT $LL6@draw_threa
$LN8@draw_threa:

; 2548 :     }
; 2549 :     for ( i = 0 ; i < HOMDIM ; i++ )

	mov	eax, DWORD PTR tv3402[ebp]
	inc	ebx
	add	eax, 4
	mov	DWORD PTR tv3402[ebp], eax
	cmp	ebx, ecx
	jl	SHORT $LL91@draw_threa
$LN7@draw_threa:

; 2552 :     
; 2553 :     matcopy(td->to_focus,identmat,HOMDIM,HOMDIM);

	mov	edx, DWORD PTR _identmat
	push	ecx
	push	ecx
	push	edx
	lea	eax, DWORD PTR [esi+768]
	push	eax
	call	_matcopy

; 2554 :     matcopy(td->from_focus,identmat,HOMDIM,HOMDIM);

	mov	eax, DWORD PTR _HOMDIM
	push	eax
	push	eax
	mov	eax, DWORD PTR _identmat
	push	eax
	lea	eax, DWORD PTR [esi+1192]
	push	eax
	call	_matcopy
	add	esp, 32					; 00000020H
	mov	ebx, 1
$LN13@draw_threa:

; 2555 :   }
; 2556 :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$95520[ebp], 0
	je	SHORT $LN3@draw_threa
	mov	ecx, DWORD PTR _graphmutex
	push	ecx
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN3@draw_threa:

; 2557 : 
; 2558 :   glDepthFunc(GL_LEQUAL);   

	push	515					; 00000203H
	call	DWORD PTR __imp__glDepthFunc@4

; 2559 :   glEnable(GL_DEPTH_TEST);

	mov	edi, DWORD PTR __imp__glEnable@4
	push	2929					; 00000b71H
	call	edi

; 2560 :   glEnable(GL_NORMALIZE); 

	push	2977					; 00000ba1H
	call	edi

; 2561 :   glEnable(GL_COLOR_MATERIAL);

	push	2903					; 00000b57H
	call	edi

; 2562 :   glColorMaterial(GL_FRONT_AND_BACK,GL_AMBIENT_AND_DIFFUSE);

	push	5634					; 00001602H
	push	1032					; 00000408H
	call	DWORD PTR __imp__glColorMaterial@8

; 2563 :   /*glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat_specular); */
; 2564 :   /*glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess); */
; 2565 :   glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, mat_white);

	push	OFFSET _mat_white
	push	5634					; 00001602H
	push	1032					; 00000408H
	call	DWORD PTR __imp__glMaterialfv@12

; 2566 :   /*glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, mat_emission);  */
; 2567 :   glEnable(GL_LIGHTING);

	push	2896					; 00000b50H
	call	edi

; 2568 :   glLightfv(GL_LIGHT0, GL_POSITION, light0_position);  

	mov	edi, DWORD PTR __imp__glLightfv@12
	push	OFFSET _light0_position
	push	4611					; 00001203H
	push	16384					; 00004000H
	call	edi

; 2569 :   glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);  

	push	OFFSET _light0_diffuse
	push	4609					; 00001201H
	push	16384					; 00004000H
	call	edi

; 2570 :   glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);  

	push	OFFSET _light0_ambient
	push	4608					; 00001200H
	push	16384					; 00004000H
	call	edi

; 2571 :   glLightfv(GL_LIGHT1, GL_POSITION, light1_position);

	push	OFFSET _light1_position
	push	4611					; 00001203H
	push	16385					; 00004001H
	call	edi

; 2572 :   glLightfv(GL_LIGHT1, GL_DIFFUSE, light1_diffuse);

	push	OFFSET _light1_diffuse
	push	4609					; 00001201H
	push	16385					; 00004001H
	call	edi

; 2573 :   glLightfv(GL_LIGHT0, GL_SPECULAR, light_none); 

	push	OFFSET _light_none
	push	4610					; 00001202H
	push	16384					; 00004000H
	call	edi

; 2574 :   glLightModeli(GL_LIGHT_MODEL_TWO_SIDE,GL_TRUE);

	push	ebx
	push	2898					; 00000b52H
	call	DWORD PTR __imp__glLightModeli@8

; 2575 :   
; 2576 :   /* screen corners */
; 2577 :   td->scrx[0] = td->scrx[1] = -1.4;

	fld	QWORD PTR __real@bff6666666666666
	fst	QWORD PTR [esi+160]

; 2578 :   td->scrx[2] = td->scrx[3] =  1.4;
; 2579 :   td->scry[0] = td->scry[3] =  1.4;
; 2580 :   td->scry[1] = td->scry[2] = -1.4;
; 2581 :   
; 2582 :   go_display_flag = 1; /* default, since fast graphics */
; 2583 : 
; 2584 :   /* version check */
; 2585 :   strncpy(opengl_version,(char*)glGetString(GL_VERSION),sizeof(opengl_version));

	push	20					; 00000014H
	fst	QWORD PTR [esi+152]
	push	7938					; 00001f02H
	fld	QWORD PTR __real@3ff6666666666666
	mov	DWORD PTR _go_display_flag, ebx
	fst	QWORD PTR [esi+176]
	fst	QWORD PTR [esi+168]
	fst	QWORD PTR [esi+208]
	fstp	QWORD PTR [esi+184]
	fst	QWORD PTR [esi+200]
	fstp	QWORD PTR [esi+192]
	call	DWORD PTR __imp__glGetString@4
	push	eax
	push	OFFSET _opengl_version
	call	_strncpy
	add	esp, 12					; 0000000cH

; 2586 :   if ( strcmp(opengl_version,"1.1") >= 0 ) 

	mov	ecx, OFFSET ??_C@_03GCKCNDHP@1?41?$AA@
	mov	eax, OFFSET _opengl_version
$LL84@draw_threa:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN85@draw_threa
	test	dl, dl
	je	SHORT $LN86@draw_threa
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN85@draw_threa
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL84@draw_threa
$LN86@draw_threa:
	xor	eax, eax
	jmp	SHORT $LN87@draw_threa
$LN85@draw_threa:
	sbb	eax, eax
	sbb	eax, -1
$LN87@draw_threa:
	test	eax, eax
	js	SHORT $LN2@draw_threa

; 2587 :      td->arraysflag = 1;

	mov	DWORD PTR [esi+9772], ebx
$LN2@draw_threa:

; 2588 : 
; 2589 :   glutDisplayFunc(draw_screen);

	push	OFFSET _draw_screen
	call	_glutDisplayFunc@4

; 2590 : 
; 2591 : 
; 2592 :   GL_ERROR_CHECK
; 2593 :   if ( !graph_thread_running ) 

	cmp	DWORD PTR _graph_thread_running, 0
	jne	SHORT $LN1@draw_threa

; 2594 :   {
; 2595 :   
; 2596 : #ifndef WIN32
; 2597 :    signal(SIGKICK,glut_catcher);
; 2598 : #endif
; 2599 : 
; 2600 :     graph_thread_running = 1;

	mov	DWORD PTR _graph_thread_running, ebx

; 2601 :     glutMainLoop();

	call	_glutMainLoop@0
$LN1@draw_threa:

; 2602 :   } 
; 2603 : #ifdef PTHREADS
; 2604 :   return NULL;
; 2605 : #endif
; 2606 : } // end draw_thread()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_draw_thread ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FA@CMNKCNBD@Cannot?5set?5affinity?5of?5graphics?5@ ; `string'
PUBLIC	??_C@_0CM@NADNGEAP@Set?5affinity?5of?5graphics?5thread?5@ ; `string'
PUBLIC	_init_Oglz
EXTRN	__imp__GetProcessAffinityMask@12:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	_nprocs:DWORD
EXTRN	_threadflag:DWORD
EXTRN	_cpu_affinity_flag:DWORD
EXTRN	__beginthread:PROC
;	COMDAT ??_C@_0FA@CMNKCNBD@Cannot?5set?5affinity?5of?5graphics?5@
CONST	SEGMENT
??_C@_0FA@CMNKCNBD@Cannot?5set?5affinity?5of?5graphics?5@ DB 'Cannot set '
	DB	'affinity of graphics thread to cpu %d; process affinity mask '
	DB	'is %X.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NADNGEAP@Set?5affinity?5of?5graphics?5thread?5@
CONST	SEGMENT
??_C@_0CM@NADNGEAP@Set?5affinity?5of?5graphics?5thread?5@ DB 'Set affinit'
	DB	'y of graphics thread to cpu %d.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _init_Oglz
_TEXT	SEGMENT
_system_affinity_mask$95551 = -8			; size = 4
_proc_affinity_mask$95550 = -4				; size = 4
_init_Oglz PROC						; COMDAT

; 2616 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2617 :   if ( !initz_flag )

	cmp	DWORD PTR _initz_flag, 0
	jne	$LN1@init_Oglz

; 2618 :   { initz_flag = 1;
; 2619 : 
; 2620 :     if ( !no_graphthread_flag )

	cmp	DWORD PTR _no_graphthread_flag, 0
	push	esi
	mov	esi, 1
	mov	DWORD PTR _initz_flag, esi
	jne	$LN11@init_Oglz

; 2621 :     {
; 2622 : #ifdef WIN32
; 2623 :      _beginthread(draw_thread,0,0);

	push	0
	push	0
	push	OFFSET _draw_thread
	call	__beginthread
	add	esp, 12					; 0000000cH

; 2624 :      if ( cpu_affinity_flag )

	cmp	DWORD PTR _cpu_affinity_flag, 0
	je	$LN11@init_Oglz

; 2625 :        SetThreadAffinityMask(GetCurrentThread(),1);

	push	ebx
	push	edi
	mov	edi, DWORD PTR __imp__GetCurrentThread@0
	push	esi
	call	edi
	mov	ebx, DWORD PTR __imp__SetThreadAffinityMask@8
	push	eax
	call	ebx

; 2626 :      if ( cpu_affinity_flag )

	cmp	DWORD PTR _cpu_affinity_flag, 0
	je	$LN12@init_Oglz

; 2627 :      {  DWORD_PTR  proc_affinity_mask,system_affinity_mask;
; 2628 :         int want_cpu = threadflag ? (nprocs+1) : 1;  // 0-based cpu numbering

	cmp	DWORD PTR _threadflag, 0
	je	SHORT $LN9@init_Oglz
	mov	esi, DWORD PTR _nprocs
	inc	esi
$LN9@init_Oglz:

; 2629 :         GetProcessAffinityMask(GetCurrentProcess(),&proc_affinity_mask,
; 2630 :             &system_affinity_mask);

	lea	eax, DWORD PTR _system_affinity_mask$95551[ebp]
	push	eax
	lea	ecx, DWORD PTR _proc_affinity_mask$95550[ebp]
	push	ecx
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	DWORD PTR __imp__GetProcessAffinityMask@12

; 2631 :         if ( proc_affinity_mask & (((size_t)1)<<want_cpu) )

	mov	ecx, esi
	mov	eax, 1
	shl	eax, cl
	mov	ecx, DWORD PTR _proc_affinity_mask$95550[ebp]
	test	eax, ecx
	je	SHORT $LN2@init_Oglz

; 2632 :         { SetThreadAffinityMask(GetCurrentThread(),((size_t)1)<<want_cpu);

	push	eax
	call	edi
	push	eax
	call	ebx

; 2633 :           sprintf(msg,"Set affinity of graphics thread to cpu %d.\n",want_cpu);

	mov	edx, DWORD PTR _msg
	push	esi
	push	OFFSET ??_C@_0CM@NADNGEAP@Set?5affinity?5of?5graphics?5thread?5@
	push	edx
	call	_sprintf

; 2634 :           outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebx
	pop	esi

; 2640 :         }
; 2641 :      }
; 2642 : 
; 2643 : #elif defined(PTHREADS)
; 2644 :    { pthread_t th;
; 2645 :     /*
; 2646 :     {
; 2647 :       sigemptyset(&newset);
; 2648 :       sigaddset(&newset,SIGKICK);
; 2649 :       pthread_sigmask(SIG_BLOCK,&newset,NULL);
; 2650 :     }
; 2651 :     */
; 2652 :     main_pid = getpid();
; 2653 : #ifdef MAC_OS_X
; 2654 :     /* GLUT doesn't work as secondary thread on 10.0.2, so main draws */
; 2655 :     curdir = getcwd(NULL,0);  /* so command thread gets proper directory */
; 2656 :     pthread_create(&th,NULL,(void*(*)(void*))mac_exec_commands,NULL);
; 2657 :     draw_thread(NULL);
; 2658 : #else
; 2659 :     pthread_create(&th,NULL,draw_thread,NULL);
; 2660 : #endif
; 2661 :    }
; 2662 : #else
; 2663 :     kb_error(2447,"Internal error: Evolver compiled with GLUT graphics without threading.\n",RECOVERABLE);
; 2664 : #endif
; 2665 :     }
; 2666 :   }
; 2667 : } // end init_Oglz()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@init_Oglz:

; 2635 :         }
; 2636 :         else
; 2637 :         { sprintf(errmsg,"Cannot set affinity of graphics thread to cpu %d; process affinity mask is %X.\n",
; 2638 :                   want_cpu,proc_affinity_mask);

	push	ecx
	push	esi
	push	OFFSET ??_C@_0FA@CMNKCNBD@Cannot?5set?5affinity?5of?5graphics?5@
	push	OFFSET _errmsg
	call	_sprintf

; 2639 :           kb_error(1930,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1930					; 0000078aH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN12@init_Oglz:
	pop	edi
	pop	ebx
$LN11@init_Oglz:
	pop	esi
$LN1@init_Oglz:

; 2640 :         }
; 2641 :      }
; 2642 : 
; 2643 : #elif defined(PTHREADS)
; 2644 :    { pthread_t th;
; 2645 :     /*
; 2646 :     {
; 2647 :       sigemptyset(&newset);
; 2648 :       sigaddset(&newset,SIGKICK);
; 2649 :       pthread_sigmask(SIG_BLOCK,&newset,NULL);
; 2650 :     }
; 2651 :     */
; 2652 :     main_pid = getpid();
; 2653 : #ifdef MAC_OS_X
; 2654 :     /* GLUT doesn't work as secondary thread on 10.0.2, so main draws */
; 2655 :     curdir = getcwd(NULL,0);  /* so command thread gets proper directory */
; 2656 :     pthread_create(&th,NULL,(void*(*)(void*))mac_exec_commands,NULL);
; 2657 :     draw_thread(NULL);
; 2658 : #else
; 2659 :     pthread_create(&th,NULL,draw_thread,NULL);
; 2660 : #endif
; 2661 :    }
; 2662 : #else
; 2663 :     kb_error(2447,"Internal error: Evolver compiled with GLUT graphics without threading.\n",RECOVERABLE);
; 2664 : #endif
; 2665 :     }
; 2666 :   }
; 2667 : } // end init_Oglz()

	mov	esp, ebp
	pop	ebp
	ret	0
_init_Oglz ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _Oglz_start
_TEXT	SEGMENT
_Oglz_start PROC					; COMDAT

; 2678 :   if ( initz_flag == 0 ) init_Oglz();

	cmp	DWORD PTR _initz_flag, 0
	jne	SHORT $LN1@Oglz_start
	jmp	_init_Oglz
$LN1@Oglz_start:

; 2679 : 
; 2680 : }  // end Oglz_start() 

	ret	0
_Oglz_start ENDP
_TEXT	ENDS
PUBLIC	_display
EXTRN	_glutPostWindowRedisplay@4:PROC
EXTRN	__imp__InvalidateRect@12:PROC
EXTRN	_ask_wrap_display:PROC
; Function compile flags: /Ogtp
;	COMDAT _display
_TEXT	SEGMENT
tv270 = -4						; size = 4
_display PROC						; COMDAT

; 3771 : { struct graph_thread_data *td;

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 3772 :   int i,j;
; 3773 : 
; 3774 :   if ( torus_display_mode == TORUS_DEFAULT_MODE ) 

	xor	ebx, ebx
	push	esi
	push	edi
	cmp	DWORD PTR _torus_display_mode, ebx
	jne	SHORT $LN12@display

; 3775 :     ask_wrap_display();

	call	_ask_wrap_display
$LN12@display:

; 3776 : 
; 3777 :   close_flag = 0;

	mov	DWORD PTR _close_flag, ebx

; 3778 :   Oglz_start();

	call	_Oglz_start

; 3779 :   
; 3780 :   /* set first screen view to anything modified by main thread */
; 3781 :   for ( i = 0 ; i < HOMDIM ; i++ )

	mov	edx, DWORD PTR _HOMDIM
	cmp	edx, ebx
	jle	SHORT $LN9@display
	mov	esi, DWORD PTR _view
	mov	ecx, OFFSET _gthread_data+10176
	sub	esi, ecx
	mov	edi, OFFSET _gthread_data+10208
	mov	DWORD PTR tv270[ebp], esi
$LL11@display:

; 3782 :   { gthread_data[1].view[i] = gthread_data[1].viewspace[i];
; 3783 :     for ( j = 0 ; j < HOMDIM ; j++ )

	xor	eax, eax
	mov	DWORD PTR [ecx], edi
	test	edx, edx
	jle	SHORT $LN10@display
	mov	esi, DWORD PTR [esi+ecx]
	npad	5
$LL8@display:

; 3784 :       gthread_data[1].view[i][j] = view[i][j];

	mov	edx, DWORD PTR [ecx]
	fld	QWORD PTR [esi+eax*8]
	fstp	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _HOMDIM
	inc	eax
	cmp	eax, edx
	jl	SHORT $LL8@display

; 3782 :   { gthread_data[1].view[i] = gthread_data[1].viewspace[i];
; 3783 :     for ( j = 0 ; j < HOMDIM ; j++ )

	mov	esi, DWORD PTR tv270[ebp]
$LN10@display:

; 3779 :   
; 3780 :   /* set first screen view to anything modified by main thread */
; 3781 :   for ( i = 0 ; i < HOMDIM ; i++ )

	inc	ebx
	add	edi, 56					; 00000038H
	add	ecx, 4
	cmp	ebx, edx
	jl	SHORT $LL11@display
$LN9@display:

; 3785 :   }
; 3786 : 
; 3787 :   for ( i = 0, td = gthread_data ; i < MAXGRAPHWINDOWS ; i++, td++ )

	mov	ebx, DWORD PTR __imp__InvalidateRect@12
	mov	esi, OFFSET _gthread_data+140
	mov	edi, 10					; 0000000aH
$LL5@display:

; 3788 :     if ( td->win_id )

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@display

; 3789 :     { if ( window_aspect_ratio != td->window_aspect )

	fld	QWORD PTR _window_aspect_ratio
	fld	QWORD PTR [esi+84]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN21@display

; 3790 :         td->aspect_flag = 1;

	mov	DWORD PTR [esi+1604], 1
$LN21@display:

; 3791 :  
; 3792 : #ifdef MAC_OS_X
; 3793 :       /* glutPostRedisplay() generates ugly NSEvent leak messages */
; 3794 :   /*      glutSetWindow(td->win_id); */
; 3795 :      /*   draw_screen();  Conflict with graphics thread! */
; 3796 :          
; 3797 :       glutPostWindowRedisplay(td->win_id);  /* generate redraw message */    
; 3798 : #else
; 3799 : /*   WARNING: glutSetWindow() in non-drawing thread causes problems. */
; 3800 : /*      glutSetWindow(td->win_id); */
; 3801 :  /*     glutPostRedisplay(); */  /* generate redraw message */ 
; 3802 :       glutPostWindowRedisplay(td->win_id);  /* generate redraw message */

	push	ecx
	call	_glutPostWindowRedisplay@4

; 3803 : #ifdef WIN32
; 3804 :       InvalidateRect(td->draw_hwnd,NULL,FALSE);  /* give draw thread a kick */

	mov	eax, DWORD PTR [esi+4]
	push	0
	push	0
	push	eax
	call	ebx
$LN4@display:

; 3785 :   }
; 3786 : 
; 3787 :   for ( i = 0, td = gthread_data ; i < MAXGRAPHWINDOWS ; i++, td++ )

	add	esi, 9896				; 000026a8H
	dec	edi
	jne	SHORT $LL5@display
	pop	edi
	pop	esi
	pop	ebx

; 3805 : #else
; 3806 :      if ( draw_pid != main_pid )
; 3807 :      { 
; 3808 :        kill(draw_pid,SIGKICK);  /* unix version of kick */
; 3809 :      } 
; 3810 : #endif
; 3811 : #endif
; 3812 :     }
; 3813 : 
; 3814 : }  // end display()

	mov	esp, ebp
	pop	ebp
	ret	0
_display ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@INKBOBGG@?6?$CFd?5edges?0?5?$CFd?5facets?6?$AA@ ; `string'
PUBLIC	??_C@_0LM@CDAHHJGI@Graphics?5too?5complicated?5for?5arr@ ; `string'
EXTRN	_some_no_transforms_flag:DWORD
EXTRN	_transform_colors_flag:DWORD
EXTRN	_markedgedrawflag:DWORD
_BSS	SEGMENT
?last_mutex_time@?1??build_arrays@@9@9 DQ 01H DUP (?)	; `build_arrays'::`2'::last_mutex_time
_BSS	ENDS
;	COMDAT ??_C@_0BG@INKBOBGG@?6?$CFd?5edges?0?5?$CFd?5facets?6?$AA@
CONST	SEGMENT
??_C@_0BG@INKBOBGG@?6?$CFd?5edges?0?5?$CFd?5facets?6?$AA@ DB 0aH, '%d edg'
	DB	'es, %d facets', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0LM@CDAHHJGI@Graphics?5too?5complicated?5for?5arr@
CONST	SEGMENT
??_C@_0LM@CDAHHJGI@Graphics?5too?5complicated?5for?5arr@ DB 'Graphics too'
	DB	' complicated for arrays (try turning off auto edge display wi'
	DB	'th ''e'' in graphics window or  show_trans "e" at main prompt'
	DB	' before displaying).  Switching to non-array graphics.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _build_arrays
_TEXT	SEGMENT
_now$ = -8						; size = 8
_build_arrays PROC					; COMDAT

; 4247 : {  static REAL last_mutex_time;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi

; 4248 :    struct graph_thread_data *td = GET_DATA;

	call	_glutGetWindow@0
	mov	esi, eax
	imul	esi, 9896				; 000026a8H

; 4249 :    REAL now = get_internal_variable(V_CLOCK);

	push	1880					; 00000758H
	add	esi, OFFSET _gthread_data
	call	_get_internal_variable
	add	esp, 4
	fst	QWORD PTR _now$[ebp]

; 4250 :    int timeout = (now-last_mutex_time > .5) ? LONG_TIMEOUT : IMMEDIATE_TIMEOUT;

	xor	edi, edi
	fsub	QWORD PTR ?last_mutex_time@?1??build_arrays@@9@9
	fcomp	QWORD PTR __real@3fe0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN17@build_arra
	mov	eax, 100000				; 000186a0H
	jmp	SHORT $LN18@build_arra
$LN17@build_arra:
	xor	eax, eax
$LN18@build_arra:

; 4251 : 
; 4252 : #ifdef MPI_EVOLVER
; 4253 :   if ( this_task == MASTER_TASK )
; 4254 :   { mpi_get_task_graphics(td->mpi_graph_task);
; 4255 :     return 1;
; 4256 :   }
; 4257 :   else
; 4258 : #endif
; 4259 :     if ( TRY_GRAPH_MUTEX(timeout) )

	push	edi
	push	eax
	push	edi
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	cmp	eax, 258				; 00000102H
	je	$LN14@build_arra
	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	DWORD PTR _locking_thread, eax
	cmp	eax, edi
	je	$LN14@build_arra

; 4260 :     { int oldflag;
; 4261 :    
; 4262 :       
; 4263 :       /* see if already have current arrays in some other thread */
; 4264 :   /*      int i;
; 4265 :   for ( i = 0 ; i < MAXGRAPHWINDOWS ; i++ )
; 4266 :         if ( td != gthread_data + i 
; 4267 :         #ifdef MPI_EVOLVER
; 4268 :                  && td->mpi_graph_task == gthread_data[i].mpi_graph_task 
; 4269 :         #endif
; 4270 :                && td->arrays_timestamp < gthread_data[i].arrays_timestamp )
; 4271 :          { td->fullarray = gthread_data[i].fullarray;  
; 4272 :            td->edgestart = gthread_data[i].edgestart; 
; 4273 :            td->edgecount = gthread_data[i].edgecount;   
; 4274 :            td->facetstart = gthread_data[i].facetstart;   
; 4275 :            td->facetcount = gthread_data[i].facetcount; 
; 4276 :            td->arrays_timestamp = gthread_data[i].arrays_timestamp;   
; 4277 :            td->fullarray_original = 0; 
; 4278 :            return 1; 
; 4279 :          }    
; 4280 : 		 */
; 4281 :   
; 4282 :       last_mutex_time = now;
; 4283 :       if ( td->fullarray && td->fullarray_original )

	mov	eax, DWORD PTR [esi+9776]
	fld	QWORD PTR _now$[ebp]
	fstp	QWORD PTR ?last_mutex_time@?1??build_arrays@@9@9
	cmp	eax, edi
	je	SHORT $LN13@build_arra
	cmp	DWORD PTR [esi+9780], edi
	je	SHORT $LN13@build_arra

; 4284 :       { free((char*)td->fullarray);     

	push	eax
	call	_free
	add	esp, 4

; 4285 :         td->fullarray = NULL;

	mov	DWORD PTR [esi+9776], edi
$LN13@build_arra:

; 4286 :       }
; 4287 :       td->edgecount = 0; 
; 4288 :       td->edgemax = (web.representation==SIMPLEX) ? SDIM*web.skel[FACET].count + 100 :
; 4289 :            4*web.skel[EDGE].count+10;   /* 2 vertices per edge, each edge twice */

	cmp	DWORD PTR _web+624, 3
	mov	DWORD PTR [esi+9792], edi
	jne	SHORT $LN19@build_arra
	mov	eax, DWORD PTR _web+288
	imul	eax, DWORD PTR _web+616
	add	eax, 100				; 00000064H
	jmp	SHORT $LN20@build_arra
$LN19@build_arra:
	mov	eax, DWORD PTR _web+176
	lea	eax, DWORD PTR [eax*4+10]
$LN20@build_arra:
	mov	DWORD PTR [esi+9816], eax

; 4290 :       if ( (td->multi_dlist_flag || !edgeshow_flag) && td->edgemax > 1000000 )

	cmp	DWORD PTR [esi+1752], edi
	jne	SHORT $LN11@build_arra
	cmp	DWORD PTR _edgeshow_flag, edi
	jne	SHORT $LN12@build_arra
$LN11@build_arra:
	cmp	eax, 1000000				; 000f4240H
	jle	SHORT $LN12@build_arra

; 4291 :           td->edgemax = 1000000;

	mov	DWORD PTR [esi+9816], 1000000		; 000f4240H
$LN12@build_arra:
	push	ebx

; 4292 :       td->edgearray = (struct vercol *)calloc(td->edgemax,sizeof(struct vercol));

	mov	ebx, DWORD PTR [esi+9816]
	push	44					; 0000002cH
	push	ebx
	call	_calloc
	add	esp, 8
	mov	DWORD PTR [esi+9808], eax

; 4293 :       if ( td->edgearray == NULL )

	cmp	eax, edi
	jne	SHORT $LN10@build_arra

; 4294 :       { kb_error(5701,"Graphics too complicated for arrays (try turning off auto edge display with 'e' in graphics window or  show_trans \"e\" at main prompt before displaying).  Switching to non-array graphics.\n",
; 4295 :           WARNING);

	push	2
	push	OFFSET ??_C@_0LM@CDAHHJGI@Graphics?5too?5complicated?5for?5arr@
	push	5701					; 00001645H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 4296 :         td->arraysflag = 0;

	mov	DWORD PTR [esi+9772], edi

; 4297 :         td->doing_lazy = 0;

	mov	DWORD PTR [esi+9864], edi

; 4314 :         td->doing_lazy = 0;
; 4315 :         glutPostRedisplay();

	call	_glutPostRedisplay@0
$LN23@build_arra:

; 4316 :         return 0;

	pop	ebx
	pop	edi
	xor	eax, eax
	pop	esi

; 4386 : 
; 4387 : }  /* end build_arrays() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@build_arra:

; 4298 :         glutPostRedisplay();
; 4299 :         return 0;
; 4300 :       }
; 4301 : 
; 4302 :       td->facetcount = 0; 
; 4303 :       td->facetmax = 3*web.skel[FACET].count+10; /* 3 vertices per facet */

	mov	eax, DWORD PTR _web+288
	lea	eax, DWORD PTR [eax+eax*2+10]
	mov	DWORD PTR [esi+9800], edi
	mov	DWORD PTR [esi+9820], eax

; 4304 :       if ( td->multi_dlist_flag && (td->edgemax > 1000000) )

	cmp	DWORD PTR [esi+1752], edi
	je	SHORT $LN9@build_arra
	cmp	ebx, 1000000				; 000f4240H
	jle	SHORT $LN9@build_arra

; 4305 :           td->facetmax = 1000000;

	mov	DWORD PTR [esi+9820], 1000000		; 000f4240H
$LN9@build_arra:

; 4306 : 
; 4307 :       td->facetarray = (struct vercol *)calloc(td->facetmax,sizeof(struct vercol));

	mov	ecx, DWORD PTR [esi+9820]
	push	44					; 0000002cH
	push	ecx
	call	_calloc
	add	esp, 8
	mov	DWORD PTR [esi+9812], eax

; 4308 :       if ( td->facetarray == NULL )

	cmp	eax, edi
	jne	SHORT $LN8@build_arra

; 4309 :       { kb_error(5702,"Graphics too complicated for arrays (try turning off auto edge display with 'e' in graphics window or  show_trans \"e\" at main prompt before displaying).  Switching to non-array graphics.\n",
; 4310 :           WARNING);

	push	2
	push	OFFSET ??_C@_0LM@CDAHHJGI@Graphics?5too?5complicated?5for?5arr@
	push	5702					; 00001646H
	call	_kb_error

; 4311 :         td->arraysflag = 0;
; 4312 :         free(td->edgearray);

	mov	edx, DWORD PTR [esi+9808]
	push	edx
	mov	DWORD PTR [esi+9772], edi
	call	_free
	add	esp, 16					; 00000010H

; 4313 :         td->edgearray = NULL;

	mov	DWORD PTR [esi+9808], edi
	mov	DWORD PTR [esi+9864], edi

; 4314 :         td->doing_lazy = 0;
; 4315 :         glutPostRedisplay();

	call	_glutPostRedisplay@0
	pop	ebx
	pop	edi

; 4316 :         return 0;

	xor	eax, eax
	pop	esi

; 4386 : 
; 4387 : }  /* end build_arrays() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@build_arra:

; 4317 :       }
; 4318 : 
; 4319 :       graph_start = Oglz_start;
; 4320 :       graph_facet = Oglz_facet;
; 4321 :       graph_edge  = Oglz_edge;
; 4322 :       graph_end = Oglz_end;
; 4323 :       init_graphics = Ogl_init;
; 4324 :       finish_graphics = Ogl_finish;
; 4325 :       close_graphics = Ogl_close_show;
; 4326 :   
; 4327 :       /*glDisableClientState(GL_COLOR_ARRAY); */
; 4328 :       /*glDisableClientState(GL_NORMAL_ARRAY); */
; 4329 :       /*glDisableClientState(GL_VERTEX_ARRAY); */
; 4330 :       
; 4331 :       oldflag = markedgedrawflag;
; 4332 :       markedgedrawflag = 1;
; 4333 :       if ( (td->mouse_mode != MM_SLICE) && !transform_colors_flag && (SDIM <= 3)
; 4334 :              && !clip_view_flag && !slice_view_flag && !some_no_transforms_flag ) 

	cmp	DWORD PTR [esi+1728], 5
	mov	ebx, DWORD PTR _markedgedrawflag
	mov	ecx, 1
	mov	DWORD PTR _graph_start, OFFSET _Oglz_start
	mov	DWORD PTR _graph_facet, OFFSET _Oglz_facet
	mov	DWORD PTR _graph_edge, OFFSET _Oglz_edge
	mov	DWORD PTR _graph_end, OFFSET _Oglz_end
	mov	DWORD PTR _init_graphics, OFFSET _Ogl_init
	mov	DWORD PTR _finish_graphics, OFFSET _Ogl_finish
	mov	DWORD PTR _close_graphics, OFFSET _Ogl_close_show
	mov	DWORD PTR _markedgedrawflag, ecx
	je	SHORT $LN21@build_arra
	cmp	DWORD PTR _transform_colors_flag, edi
	jne	SHORT $LN21@build_arra
	cmp	DWORD PTR _web+616, 3
	jg	SHORT $LN21@build_arra
	cmp	DWORD PTR _clip_view_flag, edi
	jne	SHORT $LN21@build_arra
	cmp	DWORD PTR _slice_view_flag, edi
	jne	SHORT $LN21@build_arra
	cmp	DWORD PTR _some_no_transforms_flag, edi
	jne	SHORT $LN21@build_arra

; 4335 :          lazy_transforms_flag = 1;   /* for graphgen use */

	mov	DWORD PTR _lazy_transforms_flag, ecx
$LN21@build_arra:

; 4336 :       td->doing_lazy = lazy_transforms_flag;  /* for glutgraph use */

	mov	eax, DWORD PTR _lazy_transforms_flag
	mov	DWORD PTR [esi+9864], eax

; 4337 :       td->arrays_timestamp = graph_timestamp = ++global_timestamp; /* prevent stale data */ 

	mov	eax, DWORD PTR _global_timestamp
	add	eax, ecx

; 4338 :       normflag = td->normflag;

	mov	ecx, DWORD PTR [esi+1708]
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _graph_timestamp, eax
	mov	DWORD PTR [esi+132], eax
	mov	DWORD PTR _normflag, ecx

; 4339 :       graphgen();   /* fill in arrays */

	call	_graphgen

; 4340 :       END_TRY_GRAPH_MUTEX

	mov	edx, DWORD PTR _graphmutex
	push	edx
	mov	DWORD PTR _locking_thread, edi
	call	DWORD PTR __imp__ReleaseMutex@4

; 4341 :       if ( td->arraysflag == 0 ) // things got too big

	cmp	DWORD PTR [esi+9772], edi

; 4342 :         return 0;

	je	$LN23@build_arra

; 4343 :       td->doing_lazy = lazy_transforms_flag;  /* for glutgraph use, in case graphgen() changed */

	mov	eax, DWORD PTR _lazy_transforms_flag
	mov	DWORD PTR [esi+9864], eax

; 4344 :     
; 4345 :       lazy_transforms_flag = 0;

	mov	DWORD PTR _lazy_transforms_flag, edi

; 4346 :       markedgedrawflag = oldflag;

	mov	DWORD PTR _markedgedrawflag, ebx

; 4347 :       if ( td->q_flag )

	cmp	DWORD PTR [esi+9868], edi
	je	SHORT $LN5@build_arra

; 4348 :       { sprintf(msg,"\n%d edges, %d facets\n",td->edgecount/2,td->facetcount/3);

	mov	eax, 1431655766				; 55555556H
	imul	DWORD PTR [esi+9800]
	mov	eax, DWORD PTR [esi+9792]
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _msg
	push	ecx
	sar	eax, 1
	push	eax
	push	OFFSET ??_C@_0BG@INKBOBGG@?6?$CFd?5edges?0?5?$CFd?5facets?6?$AA@
	push	edx
	call	_sprintf

; 4349 :         outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H
$LN5@build_arra:

; 4350 :       }
; 4351 :  
; 4352 :       if ( td->multi_dlist_flag )

	cmp	DWORD PTR [esi+1752], edi
	je	SHORT $LN4@build_arra

; 4353 :       { // get last edges and facets into display lists
; 4354 :         enlarge_edge_array(td);

	push	esi
	call	_enlarge_edge_array

; 4355 :         enlarge_facet_array(td);

	push	esi
	call	_enlarge_facet_array

; 4356 :         free((char*)td->edgearray);  td->edgearray = NULL;

	mov	ecx, DWORD PTR [esi+9808]
	push	ecx
	call	_free

; 4357 :         free((char*)td->facetarray);  td->facetarray = NULL;

	mov	edx, DWORD PTR [esi+9812]
	push	edx
	mov	DWORD PTR [esi+9808], edi
	call	_free
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+9812], edi

; 4358 :         glFlush();

	call	DWORD PTR __imp__glFlush@0
	pop	ebx
	pop	edi

; 4381 :       }
; 4382 :      
; 4383 :       return 1; /* success */

	mov	eax, 1
	pop	esi

; 4386 : 
; 4387 : }  /* end build_arrays() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@build_arra:

; 4359 :       }
; 4360 :       else
; 4361 :       {
; 4362 :         /* unify lists */  
; 4363 :         td->fullarray = (struct vercol *)realloc((char*)td->edgearray,
; 4364 :                  (td->edgecount+td->facetcount+5)*sizeof(struct vercol));       

	mov	eax, DWORD PTR [esi+9800]
	mov	ecx, DWORD PTR [esi+9792]
	lea	edx, DWORD PTR [eax+ecx+5]
	mov	eax, DWORD PTR [esi+9808]
	imul	edx, 44					; 0000002cH
	push	edx
	push	eax
	call	_realloc
	add	esp, 8
	mov	DWORD PTR [esi+9776], eax

; 4365 :         td->fullarray_original = 1;

	mov	DWORD PTR [esi+9780], 1

; 4366 :         if ( td->fullarray == NULL )

	cmp	eax, edi
	jne	SHORT $LN2@build_arra

; 4367 :         { kb_error(5703,"Graphics too complicated for arrays.  Switching to non-array graphics.\n",
; 4368 :             WARNING);

	push	2
	push	OFFSET ??_C@_0EI@EHMFEGOO@Graphics?5too?5complicated?5for?5arr@
	push	5703					; 00001647H
	call	_kb_error

; 4369 :           td->arraysflag = 0;
; 4370 :           td->doing_lazy = 0;
; 4371 :           free((char*)td->facetarray);  td->facetarray = NULL; 

	mov	ecx, DWORD PTR [esi+9812]
	push	ecx
	mov	DWORD PTR [esi+9772], edi
	mov	DWORD PTR [esi+9864], edi
	call	_free

; 4372 :           free((char*)td->edgearray); td->edgearray = NULL;

	mov	edx, DWORD PTR [esi+9808]
	push	edx
	mov	DWORD PTR [esi+9812], edi
	call	_free
	add	esp, 20					; 00000014H
	mov	DWORD PTR [esi+9808], edi
	call	_glutPostRedisplay@0
	pop	ebx
	pop	edi
	xor	eax, eax
	pop	esi

; 4386 : 
; 4387 : }  /* end build_arrays() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@build_arra:

; 4373 :           glutPostRedisplay();
; 4374 :           return 0;
; 4375 :         }
; 4376 : 
; 4377 :         memcpy((char*)(td->fullarray+td->edgecount),(char*)td->facetarray,
; 4378 :            td->facetcount*sizeof(struct vercol));

	mov	ecx, DWORD PTR [esi+9800]
	mov	edx, DWORD PTR [esi+9812]
	imul	ecx, 44					; 0000002cH
	push	ecx
	mov	ecx, DWORD PTR [esi+9792]
	imul	ecx, 44					; 0000002cH
	push	edx
	add	ecx, eax
	push	ecx
	call	_memcpy

; 4379 :         free((char*)td->facetarray);  td->facetarray = NULL; td->edgearray = NULL;

	mov	edx, DWORD PTR [esi+9812]
	push	edx
	call	_free

; 4380 :         td->edgestart = 0; td->facetstart = td->edgecount;    

	mov	eax, DWORD PTR [esi+9792]
	add	esp, 16					; 00000010H
	pop	ebx
	mov	DWORD PTR [esi+9812], edi
	mov	DWORD PTR [esi+9808], edi
	mov	DWORD PTR [esi+9788], edi
	mov	DWORD PTR [esi+9796], eax
	pop	edi

; 4381 :       }
; 4382 :      
; 4383 :       return 1; /* success */

	mov	eax, 1
	pop	esi

; 4386 : 
; 4387 : }  /* end build_arrays() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@build_arra:
	pop	edi

; 4384 :    }
; 4385 :    else return 0;

	xor	eax, eax
	pop	esi

; 4386 : 
; 4387 : }  /* end build_arrays() */

	mov	esp, ebp
	pop	ebp
	ret	0
_build_arrays ENDP
_TEXT	ENDS
END
