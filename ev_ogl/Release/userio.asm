; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\userio.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_l_check_for_break
EXTRN	_fgetc:PROC
EXTRN	_l_brfd:DWORD
EXTRN	__imp__Sleep@4:PROC
EXTRN	_l_evolver_mode:DWORD
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\userio.c
;	COMDAT _l_check_for_break
_TEXT	SEGMENT
_l_check_for_break PROC					; COMDAT

; 23   :     if  (l_evolver_mode)

	cmp	DWORD PTR _l_evolver_mode, 0
	je	SHORT $LN1@l_check_fo

; 24   :         {
; 25   : #ifdef WIN32
; 26   : 		Sleep(10);

	push	10					; 0000000aH
	call	DWORD PTR __imp__Sleep@4

; 27   : #endif
; 28   : 		if (fgetc(l_brfd)!=EOF)

	mov	eax, DWORD PTR _l_brfd
	push	eax
	call	_fgetc
	pop	ecx
$LN1@l_check_fo:

; 29   :           /*Handle control-c, still need to determine best procedure here*/
; 30   :           {
; 31   :           ;//?!
; 32   :           }
; 33   :         }
; 34   :     }

	ret	0
_l_check_for_break ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	_kb_error
PUBLIC	??_C@_0O@NJJEIDNN@Broken?5pipe?4?6?$AA@		; `string'
PUBLIC	_outstring
EXTRN	_fprintf:PROC
EXTRN	_logfilefd:DWORD
EXTRN	_logfile_flag:DWORD
EXTRN	___iob_func:PROC
EXTRN	_outfd:DWORD
EXTRN	_broken_pipe_flag:DWORD
EXTRN	_fflush:PROC
EXTRN	_fputs:PROC
EXTRN	_l_outfd:DWORD
EXTRN	_quiet_flag:DWORD
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NJJEIDNN@Broken?5pipe?4?6?$AA@
CONST	SEGMENT
??_C@_0O@NJJEIDNN@Broken?5pipe?4?6?$AA@ DB 'Broken pipe.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _outstring
_TEXT	SEGMENT
_outmsg$ = 8						; size = 4
_outstring PROC						; COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp

; 47   :   if ( quiet_flag || !outmsg ) return;

	cmp	DWORD PTR _quiet_flag, 0
	jne	$LN5@outstring
	push	esi
	mov	esi, DWORD PTR _outmsg$[ebp]
	test	esi, esi
	je	$LN9@outstring

; 48   : #ifdef __L_EVOLVER__
; 49   :   if ( l_evolver_mode )

	cmp	DWORD PTR _l_evolver_mode, 0
	je	SHORT $LN4@outstring

; 50   :     {
; 51   :     fputs(outmsg,l_outfd);

	mov	eax, DWORD PTR _l_outfd
	push	eax
	push	esi
	call	_fputs

; 52   :     fflush(l_outfd);

	mov	ecx, DWORD PTR _l_outfd

; 72   :   fflush(outfd);

	push	ecx
	call	_fflush
	add	esp, 12					; 0000000cH
	pop	esi

; 73   : #endif
; 74   : }  // end outstring()

	pop	ebp
	ret	0
$LN4@outstring:

; 53   : 
; 54   :     return;
; 55   :     }
; 56   : #endif
; 57   :   if ( broken_pipe_flag )

	cmp	DWORD PTR _broken_pipe_flag, 0
	je	SHORT $LN3@outstring

; 58   :   { broken_pipe_flag = 0; kb_error(1349,"Broken pipe.\n",RECOVERABLE); }

	push	1
	push	OFFSET ??_C@_0O@NJJEIDNN@Broken?5pipe?4?6?$AA@
	push	1349					; 00000545H
	mov	DWORD PTR _broken_pipe_flag, 0
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN3@outstring:

; 59   : 
; 60   :   if ( outfd == NULL ) outfd = stdout;    /* maybe after error */

	mov	eax, DWORD PTR _outfd
	test	eax, eax
	jne	SHORT $LN2@outstring
	call	___iob_func
	add	eax, 32					; 00000020H
	mov	DWORD PTR _outfd, eax
$LN2@outstring:

; 61   : 
; 62   :   if ( logfile_flag && (outfd==stdout) )

	cmp	DWORD PTR _logfile_flag, 0
	je	SHORT $LN1@outstring
	call	___iob_func
	lea	edx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR _outfd
	cmp	eax, edx
	jne	SHORT $LN1@outstring

; 63   :       fprintf(logfilefd,"%s",outmsg);

	mov	eax, DWORD PTR _logfilefd
	push	esi
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	push	eax
	call	_fprintf
	mov	eax, DWORD PTR _outfd
	add	esp, 12					; 0000000cH
$LN1@outstring:

; 64   : 
; 65   : #if defined(MAC_APP) || defined(WIN32S) || defined(MAC_CW)
; 66   :   if ( outfd == stdout )
; 67   :      write_to_console(outmsg);
; 68   :   else
; 69   :      fputs(outmsg,outfd);
; 70   : #else
; 71   :   fputs(outmsg,outfd);

	push	eax
	push	esi
	call	_fputs

; 72   :   fflush(outfd);

	mov	ecx, DWORD PTR _outfd
	push	ecx
	call	_fflush
	add	esp, 12					; 0000000cH
$LN9@outstring:
	pop	esi
$LN5@outstring:

; 73   : #endif
; 74   : }  // end outstring()

	pop	ebp
	ret	0
_outstring ENDP
_TEXT	ENDS
PUBLIC	_erroutstring
EXTRN	_erroutfd:DWORD
EXTRN	_suppress_erroutstring:DWORD
; Function compile flags: /Ogtp
;	COMDAT _erroutstring
_TEXT	SEGMENT
_outmsg$ = 8						; size = 4
_erroutstring PROC					; COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 86   :   if ( !outmsg || suppress_erroutstring ) 

	mov	esi, DWORD PTR _outmsg$[ebp]
	test	esi, esi
	je	SHORT $LN3@erroutstri
	cmp	DWORD PTR _suppress_erroutstring, 0
	jne	SHORT $LN3@erroutstri

; 87   : 	  return;
; 88   : #ifdef __L_EVOLVER__
; 89   :   if ( l_evolver_mode )

	cmp	DWORD PTR _l_evolver_mode, 0
	je	SHORT $LN2@erroutstri

; 90   :     {
; 91   :     outstring(outmsg);

	push	esi
	call	_outstring
	add	esp, 4
	pop	esi

; 107  : 
; 108  : } // end erroutstring()

	pop	ebp
	ret	0
$LN2@erroutstri:

; 92   :     return;
; 93   :     }
; 94   :   
; 95   : #endif
; 96   : #if defined(MAC_APP) || defined(WIN32S) || defined(MAC_CW)
; 97   :   write_to_console(outmsg);
; 98   : #else
; 99   : #ifdef MPI_EVOLVER
; 100  :   fprintf(stderr,"Task %d: ",this_task);
; 101  : #endif
; 102  :   fputs(outmsg,erroutfd);

	mov	eax, DWORD PTR _erroutfd
	push	eax
	push	esi
	call	_fputs

; 103  :   fflush(erroutfd);

	mov	ecx, DWORD PTR _erroutfd
	push	ecx
	call	_fflush
	add	esp, 12					; 0000000cH

; 104  : #endif
; 105  :   if ( logfile_flag )

	cmp	DWORD PTR _logfile_flag, 0
	je	SHORT $LN3@erroutstri

; 106  :       fprintf(logfilefd,"%s",outmsg);

	mov	edx, DWORD PTR _logfilefd
	push	esi
	push	OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN3@erroutstri:
	pop	esi

; 107  : 
; 108  : } // end erroutstring()

	pop	ebp
	ret	0
_erroutstring ENDP
_TEXT	ENDS
PUBLIC	_my_fgets
EXTRN	_ungetc:PROC
; Function compile flags: /Ogtp
;	COMDAT _my_fgets
_TEXT	SEGMENT
_s$ = 8							; size = 4
_n$ = 12						; size = 4
_stream$ = 16						; size = 4
_my_fgets PROC						; COMDAT

; 124  : { char *p;

	push	ebp
	mov	ebp, esp
	push	ebx

; 125  :   int k;
; 126  :   for ( k = 0, p = s ; k < n-1 ; k++,p++ )

	mov	ebx, DWORD PTR _n$[ebp]
	push	esi
	mov	esi, DWORD PTR _s$[ebp]
	push	edi
	dec	ebx
	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN20@my_fgets
$LL8@my_fgets:

; 127  :   { int c;
; 128  :     c = fgetc(stream);

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4

; 129  :     if ( (c == EOF) && ( k == 0 ) ) return NULL;

	cmp	eax, -1
	je	SHORT $LN18@my_fgets

; 131  :     *p = (char)c;

	mov	BYTE PTR [esi], al

; 132  : 	#ifdef __L_EVOLVER__
; 133  : 	//if (l_evolver_mode)
; 134  : 	//	fputc(c, l_outfd);
; 135  : 	#endif
; 136  :     if ( c == '\n' ) { *(++p) = 0; return s; }

	cmp	eax, 10					; 0000000aH
	je	SHORT $LN14@my_fgets

; 137  :     if ( c == '\r' )

	cmp	eax, 13					; 0000000dH
	je	SHORT $LN15@my_fgets

; 125  :   int k;
; 126  :   for ( k = 0, p = s ; k < n-1 ; k++,p++ )

	inc	edi
	inc	esi
	cmp	edi, ebx
	jl	SHORT $LL8@my_fgets
$LN20@my_fgets:

; 141  :         return s; 
; 142  :      }
; 143  :   }
; 144  :   *p = 0;  /* null terminator */

	mov	BYTE PTR [esi], 0
$LN22@my_fgets:

; 145  :   return s;

	mov	eax, DWORD PTR _s$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 146  : } // end my_fgets()

	pop	ebp
	ret	0
$LN18@my_fgets:

; 129  :     if ( (c == EOF) && ( k == 0 ) ) return NULL;

	test	edi, edi

; 130  :     if ( c == EOF ) { *p = 0; return s; }

	jne	SHORT $LN20@my_fgets

; 129  :     if ( (c == EOF) && ( k == 0 ) ) return NULL;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 146  : } // end my_fgets()

	pop	ebp
	ret	0
$LN14@my_fgets:

; 145  :   return s;

	mov	eax, DWORD PTR _s$[ebp]
	pop	edi
	mov	BYTE PTR [esi+1], 0
	pop	esi
	pop	ebx

; 146  : } // end my_fgets()

	pop	ebp
	ret	0
$LN15@my_fgets:

; 138  :      { *p = '\n'; *(++p) = 0;

	mov	WORD PTR [esi], 10			; 0000000aH

; 139  :         c = fgetc(stream);

	mov	esi, DWORD PTR _stream$[ebp]
	push	esi
	call	_fgetc
	add	esp, 4

; 140  :         if ( (c != '\n') && (c != EOF) ) ungetc(c, stream); 

	cmp	eax, 10					; 0000000aH
	je	SHORT $LN22@my_fgets
	cmp	eax, -1
	je	SHORT $LN22@my_fgets
	push	esi
	push	eax
	call	_ungetc

; 145  :   return s;

	mov	eax, DWORD PTR _s$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 146  : } // end my_fgets()

	pop	ebp
	ret	0
_my_fgets ENDP
_TEXT	ENDS
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0BA@LDMPFPFF@Enter?5command?3?5?$AA@	; `string'
PUBLIC	_prompt
EXTRN	_keylogfilefd:DWORD
EXTRN	_keylogfile_flag:DWORD
EXTRN	_catcher:PROC
EXTRN	_echo_flag:DWORD
EXTRN	_signal:PROC
EXTRN	_breakflag:DWORD
EXTRN	_l_infd:DWORD
EXTRN	_current_prompt:DWORD
EXTRN	_strchr:PROC
EXTRN	_quiet_load_flag:DWORD
EXTRN	_commandfd:DWORD
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LDMPFPFF@Enter?5command?3?5?$AA@
CONST	SEGMENT
??_C@_0BA@LDMPFPFF@Enter?5command?3?5?$AA@ DB 'Enter command: ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _prompt
_TEXT	SEGMENT
_oldquiet$ = -4						; size = 4
_promptmsg$ = 8						; size = 4
_c$ = 12						; size = 4
_inmsg$ = 12						; size = 4
_max$ = 16						; size = 4
_prompt	PROC						; COMDAT

; 414  : { char *c,*ptr;

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi

; 415  :   int oldquiet;
; 416  :   
; 417  :   inmsg[0] = 0;  /* in case no message */

	mov	esi, DWORD PTR _inmsg$[ebp]

; 418  : 
; 419  : #ifdef PTHREAD_LOG
; 420  : /* print thread event log */
; 421  : if ( threadflag )
; 422  : { int i;
; 423  :   int k[MAXPROCS], kmain = 0;
; 424  :   for ( i = 0 ; i < nprocs ; i++ ) k[i] = 0;
; 425  :   /* print in time order */
; 426  :   for(;;)
; 427  :   { unsigned int lowtime = 0,hightime = 0xFFFFFFFF;
; 428  :     int type, lowwhich = -1;
; 429  :     struct thread_event *em;
; 430  :     for ( i = 0 ; i < nprocs ; i++ ) 
; 431  :     { struct thread_event *e = thread_data_ptrs[i]->events + k[i];
; 432  :       if ( k[i] >=  thread_data_ptrs[i]->eventcount ) continue;
; 433  :       if ( (e->time_high < hightime)
; 434  :         || ((e->time_high == hightime) && ( e->time_low < lowtime ))  )
; 435  :       {  lowwhich = i; hightime = e->time_high; lowtime = e->time_low;
; 436  :          type = e->type;
; 437  :       }
; 438  :     }
; 439  :     em = main_events + kmain;
; 440  :     if ( (kmain < main_eventcount) && ((em->time_high < hightime)
; 441  :         || ((em->time_high == hightime) && ( em->time_low < lowtime )))  )
; 442  :     { printf("m %08X%08X %d\n",em->time_high,em->time_low,em->type);
; 443  :       kmain++;
; 444  :     }
; 445  :     else if ( lowwhich >= 0 )
; 446  :     { printf("%d %08X%08X %d\n",lowwhich,hightime,lowtime,type);
; 447  :       k[lowwhich]++;
; 448  :     }
; 449  :     else break;
; 450  :   }
; 451  :   for ( i = 0 ; i < nprocs ; i++ ) thread_data_ptrs[i]->eventcount = 0;
; 452  :   main_eventcount = 0;
; 453  :   
; 454  : } 
; 455  : #endif
; 456  : 
; 457  :   if ( commandfd && (commandfd != stdin) )

	xor	ebx, ebx
	mov	BYTE PTR [esi], 0
	push	edi
	cmp	DWORD PTR _commandfd, ebx
	je	$LN30@prompt
	call	___iob_func
	mov	ecx, DWORD PTR _commandfd
	cmp	ecx, eax
	je	$LN30@prompt

; 458  :   { /* from command input file */
; 459  :     if (my_fgets(inmsg,max,commandfd) == NULL) 

	mov	ebx, DWORD PTR _max$[ebp]
	push	ecx
	push	ebx
	push	esi
	call	_my_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN29@prompt
$LN49@prompt:
	pop	edi
	pop	esi

; 460  :     { return EOF; }

	or	eax, -1
	pop	ebx

; 567  : } // end prompt()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@prompt:

; 461  :     else 
; 462  :     { 
; 463  :       oldquiet = quiet_flag; /* quiet_flag = 0; */
; 464  : #ifdef USE_READLINE //CSL
; 465  :      if(promptmsg == MOREPROMPT || promptmsg == CONTPROMPT)
; 466  :      { promptmsg="more> "; } 
; 467  : #endif  
; 468  :       if ( !quiet_load_flag )

	cmp	DWORD PTR _quiet_load_flag, 0
	mov	eax, DWORD PTR _quiet_flag
	mov	edi, DWORD PTR _promptmsg$[ebp]
	mov	DWORD PTR _oldquiet$[ebp], eax
	jne	SHORT $LN27@prompt

; 469  :       { outstring(promptmsg);  /* so appears on screen also */

	push	edi
	call	_outstring

; 470  :         outstring(inmsg); /* echo */

	push	esi
	call	_outstring
	add	esp, 8
$LN27@prompt:

; 471  :       }
; 472  :       if ( (c = strchr(inmsg,'\n')) != NULL ) 

	push	10					; 0000000aH
	push	esi
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _c$[ebp], eax
	test	eax, eax
	je	SHORT $LN26@prompt

; 473  :       { if ( strcmp(promptmsg,"Enter command: ") != 0 )

	mov	edx, OFFSET ??_C@_0BA@LDMPFPFF@Enter?5command?3?5?$AA@
	mov	ecx, edi
$LL42@prompt:
	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [edx]
	jne	SHORT $LN43@prompt
	test	al, al
	je	SHORT $LN44@prompt
	mov	al, BYTE PTR [ecx+1]
	cmp	al, BYTE PTR [edx+1]
	jne	SHORT $LN43@prompt
	add	ecx, 2
	add	edx, 2
	test	al, al
	jne	SHORT $LL42@prompt
$LN44@prompt:
	xor	eax, eax
	jmp	SHORT $LN45@prompt
$LN43@prompt:
	sbb	eax, eax
	sbb	eax, -1
$LN45@prompt:
	test	eax, eax
	je	SHORT $LN23@prompt

; 474  :           *c = 0;

	mov	ecx, DWORD PTR _c$[ebp]

; 478  :       quiet_flag = oldquiet;

	mov	eax, DWORD PTR _oldquiet$[ebp]
	pop	edi
	mov	BYTE PTR [ecx], 0
	pop	esi
	mov	DWORD PTR _quiet_flag, eax

; 565  : 
; 566  :   return 1; /* not EOF */

	mov	eax, 1
	pop	ebx

; 567  : } // end prompt()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@prompt:

; 475  :       }
; 476  :       else if ( (int)strlen(inmsg) == max-1 ) 

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL46@prompt:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL46@prompt
	sub	eax, edx
	lea	edx, DWORD PTR [ebx-1]
	cmp	eax, edx
	jne	SHORT $LN23@prompt

; 477  :         inmsg[max-1] = MOREIN; 

	mov	BYTE PTR [esi+ebx-1], 1
$LN23@prompt:

; 478  :       quiet_flag = oldquiet;

	mov	eax, DWORD PTR _oldquiet$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR _quiet_flag, eax

; 565  : 
; 566  :   return 1; /* not EOF */

	mov	eax, 1
	pop	ebx

; 567  : } // end prompt()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@prompt:

; 479  :       return 1; /* not EOF */         
; 480  :     }
; 481  :   }
; 482  : #ifdef __L_EVOLVER__
; 483  :   else if ( l_evolver_mode )
; 484  :     {
; 485  :     current_prompt = promptmsg; /* for those who want to redisplay prompt */

	mov	eax, DWORD PTR _promptmsg$[ebp]
	mov	DWORD PTR _current_prompt, eax

; 486  :     outstring(promptmsg);

	push	eax
	cmp	DWORD PTR _l_evolver_mode, ebx
	je	$LN21@prompt
	call	_outstring

; 487  : 	current_prompt = NULL;
; 488  :     while ( my_fgets(inmsg,max,l_infd) == NULL )

	mov	ecx, DWORD PTR _l_infd
	mov	edi, DWORD PTR _max$[ebp]
	push	ecx
	push	edi
	push	esi
	mov	DWORD PTR _current_prompt, ebx
	call	_my_fgets
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN19@prompt
$LL20@prompt:

; 489  :       l_check_for_break();

	call	_l_check_for_break
	mov	edx, DWORD PTR _l_infd
	push	edx
	push	edi
	push	esi
	call	_my_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LL20@prompt
$LN19@prompt:

; 490  : 	/* strip whitespace from start of inmsg */
; 491  : 	ptr = inmsg;

	mov	edx, esi
	npad	3
$LL18@prompt:

; 492  : 	while ( (*ptr==' ') || (*ptr=='\t') ) ptr++;

	mov	al, BYTE PTR [edx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN16@prompt
	cmp	al, 9
	jne	SHORT $LN17@prompt
$LN16@prompt:
	inc	edx
	jmp	SHORT $LL18@prompt
$LN17@prompt:

; 493  : 	if ( ptr != inmsg )

	cmp	edx, esi
	je	SHORT $LN15@prompt

; 494  : 	{ for ( c = inmsg ; *ptr ; ) *(c++) = *(ptr++);

	mov	al, BYTE PTR [edx]
	mov	ecx, esi
	test	al, al
	je	SHORT $LN13@prompt
	sub	edx, esi
	npad	5
$LL14@prompt:
	mov	BYTE PTR [ecx], al
	mov	al, BYTE PTR [edx+ecx+1]
	inc	ecx
	test	al, al
	jne	SHORT $LL14@prompt
$LN13@prompt:

; 495  : 	 *c = 0;

	mov	BYTE PTR [ecx], bl
$LN15@prompt:

; 496  : 	}
; 497  : 	/* strip nl from end */
; 498  : 	c = inmsg + strlen(inmsg) - 1;

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
$LL47@prompt:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL47@prompt
	sub	eax, edx

; 499  : 	if ( *c == '\n' ) *c = 0;

	cmp	BYTE PTR [eax+esi-1], 10		; 0000000aH
	jne	SHORT $LN12@prompt
	mov	BYTE PTR [eax+esi-1], bl
$LN12@prompt:

; 500  :     outstring(inmsg);

	push	esi
	call	_outstring

; 501  :     outstring("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_outstring
	add	esp, 8
	pop	edi
	pop	esi

; 565  : 
; 566  :   return 1; /* not EOF */

	mov	eax, 1
	pop	ebx

; 567  : } // end prompt()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@prompt:

; 502  : 
; 503  : 	return 1;
; 504  : /* WARNING: the prior statement could essentially be an infinite loop*/
; 505  :     }
; 506  :   //else /* Otherwise continue with normal standard input from console...*/
; 507  : 
; 508  : #endif
; 509  : 
; 510  :   breakflag = 0;  /* back to user input */
; 511  : #ifdef USE_READLINE //CSL
; 512  :    current_prompt = promptmsg==MOREPROMPT || promptmsg==CONTPROMPT ? "more> " : promptmsg;
; 513  : #else
; 514  :   current_prompt = promptmsg; /* for those who want to redisplay prompt */
; 515  : #endif
; 516  : 
; 517  : #if defined(MAC_APP) || defined(WIN32S) || defined(MAC_CW)
; 518  :   write_to_console(promptmsg);
; 519  :   read_line_from_console(inmsg);
; 520  : #else
; 521  : #if defined(_READLINE_H_)
; 522  :   if(use_readline(promptmsg,inmsg,max) == EOF )
; 523  :       return EOF;
; 524  :   else
; 525  : #else
; 526  :   {
; 527  :   /* from stdin */
; 528  :   oldquiet = quiet_flag; quiet_flag = 0;

	mov	edi, DWORD PTR _quiet_flag
	mov	DWORD PTR _breakflag, ebx
	mov	DWORD PTR _quiet_flag, ebx

; 529  :   outstring(promptmsg);

	call	_outstring

; 530  :   quiet_flag = oldquiet;
; 531  : /* __L_EVOLVER__:  This next function call may be better placed elsewhere*/
; 532  : 
; 533  : #ifdef WIN32
; 534  :   signal(SIGINT,SIG_IGN); /* no interrupt during input (esp. WIN32) */

	push	1
	push	2
	mov	DWORD PTR _quiet_flag, edi
	call	_signal

; 535  : #endif
; 536  : 
; 537  : #ifdef OOGL
; 538  :   /* check for geomview pick */
; 539  :   if ( geomview_flag && !geompipe_flag )
; 540  :     while ( check_pick() == 1 ) 
; 541  :         outstring(promptmsg);
; 542  : #endif
; 543  : 
; 544  :   if ( my_fgets(inmsg,max,stdin) == NULL )

	call	___iob_func
	push	eax
	mov	eax, DWORD PTR _max$[ebp]
	push	eax
	push	esi
	call	_my_fgets
	add	esp, 24					; 00000018H
	test	eax, eax

; 545  :      return EOF;

	je	$LN49@prompt

; 546  :   if ( echo_flag ) { outstring(inmsg); outstring("\n"); }

	cmp	DWORD PTR _echo_flag, ebx
	je	SHORT $LN10@prompt
	push	esi
	call	_outstring
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_outstring
	add	esp, 8
$LN10@prompt:

; 547  :   signal(SIGINT,catcher);

	push	OFFSET _catcher
	push	2
	call	_signal
	add	esp, 8

; 548  :   }
; 549  : #endif
; 550  : #endif
; 551  : 
; 552  :   current_prompt = NULL;

	mov	DWORD PTR _current_prompt, ebx

; 553  :   /* strip whitespace from start of inmsg */
; 554  :   ptr = inmsg;

	mov	ecx, esi
$LL9@prompt:

; 555  :   while ( (*ptr==' ') || (*ptr=='\t') ) ptr++;

	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $LN7@prompt
	cmp	al, 9
	jne	SHORT $LN8@prompt
$LN7@prompt:
	inc	ecx
	jmp	SHORT $LL9@prompt
$LN8@prompt:

; 556  :   if ( ptr != inmsg )

	cmp	ecx, esi
	je	SHORT $LN6@prompt

; 557  :   { for ( c = inmsg ; *ptr ; ) *(c++) = *(ptr++);

	mov	al, BYTE PTR [ecx]
	mov	edx, esi
	test	al, al
	je	SHORT $LN4@prompt
$LL5@prompt:
	inc	ecx
	mov	BYTE PTR [edx], al
	mov	al, BYTE PTR [ecx]
	inc	edx
	test	al, al
	jne	SHORT $LL5@prompt
$LN4@prompt:

; 558  :      *c = 0;

	mov	BYTE PTR [edx], bl
$LN6@prompt:

; 559  :   }
; 560  :   /* strip nl from end */
; 561  :   c = inmsg + strlen(inmsg) - 1;

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
$LL48@prompt:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL48@prompt
	sub	eax, edx

; 562  :   if ( *c == '\n' ) *c = 0;

	cmp	BYTE PTR [eax+esi-1], 10		; 0000000aH
	jne	SHORT $LN3@prompt
	mov	BYTE PTR [eax+esi-1], bl
$LN3@prompt:

; 563  :   if ( logfile_flag ) fprintf(logfilefd,"%s\n",inmsg);

	cmp	DWORD PTR _logfile_flag, ebx
	je	SHORT $LN2@prompt
	mov	ecx, DWORD PTR _logfilefd
	push	esi
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN2@prompt:

; 564  :   if ( keylogfile_flag ) fprintf(keylogfilefd,"%s\n",inmsg);

	cmp	DWORD PTR _keylogfile_flag, ebx
	je	SHORT $LN1@prompt
	mov	edx, DWORD PTR _keylogfilefd
	push	esi
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	push	edx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN1@prompt:

; 565  : 
; 566  :   return 1; /* not EOF */

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 567  : } // end prompt()

	mov	esp, ebp
	pop	ebp
	ret	0
_prompt	ENDP
_TEXT	ENDS
PUBLIC	_add_path_to_name
EXTRN	_strrchr:PROC
EXTRN	_strncpy:PROC
; Function compile flags: /Ogtp
;	COMDAT _add_path_to_name
_TEXT	SEGMENT
_path$ = 8						; size = 4
_name$ = 12						; size = 4
_result$ = 16						; size = 4
_add_path_to_name PROC					; COMDAT

; 582  : { char *slash;

	push	ebp
	mov	ebp, esp

; 583  :   strncpy(result,path,PATHSIZE-1); result[PATHSIZE-1]=0;

	mov	eax, DWORD PTR _path$[ebp]
	push	esi
	mov	esi, DWORD PTR _result$[ebp]
	push	999					; 000003e7H
	push	eax
	push	esi
	call	_strncpy

; 584  :   slash=strrchr(result,'/');

	push	47					; 0000002fH
	push	esi
	mov	BYTE PTR [esi+999], 0
	call	_strrchr
	add	esp, 20					; 00000014H

; 585  :   if(!slash) slash = strrchr(result,'\\');

	test	eax, eax
	jne	SHORT $LN6@add_path_t
	push	92					; 0000005cH
	push	esi
	call	_strrchr
	add	esp, 8

; 586  :   if(slash) slash++;

	test	eax, eax
	je	SHORT $LN2@add_path_t
$LN6@add_path_t:
	inc	eax
	jmp	SHORT $LN1@add_path_t
$LN2@add_path_t:

; 587  :   else slash=result;

	mov	eax, esi
$LN1@add_path_t:

; 588  :   strncpy(slash,name,PATHSIZE-1-(slash-result));

	mov	ecx, DWORD PTR _name$[ebp]
	sub	esi, eax
	add	esi, 999				; 000003e7H
	push	esi
	push	ecx
	push	eax
	call	_strncpy
	add	esp, 12					; 0000000cH
	pop	esi

; 589  : } // end add_path_to_name()

	pop	ebp
	ret	0
_add_path_to_name ENDP
_TEXT	ENDS
PUBLIC	_pop_datafd
EXTRN	_line_no:DWORD
EXTRN	_datafile_stack:BYTE
EXTRN	_fclose:PROC
EXTRN	_data_fd:DWORD
EXTRN	_include_depth:DWORD
; Function compile flags: /Ogtp
;	COMDAT _pop_datafd
_TEXT	SEGMENT
_pop_datafd PROC					; COMDAT

; 641  :   if ( include_depth <= 1 )

	cmp	DWORD PTR _include_depth, 1
	jg	SHORT $LN4@pop_datafd

; 642  :      { include_depth = 0; data_fd = NULL;}

	mov	DWORD PTR _include_depth, 0
$LN2@pop_datafd:

; 647  :     } 
; 648  :   else data_fd = NULL;

	mov	DWORD PTR _data_fd, 0

; 649  : } // end pop_datafd()

	ret	0
$LN4@pop_datafd:

; 643  :   else fclose(data_fd);

	mov	eax, DWORD PTR _data_fd
	push	eax
	call	_fclose

; 644  :   if ( include_depth > 0 ) 

	mov	eax, DWORD PTR _include_depth
	add	esp, 4
	test	eax, eax
	jle	SHORT $LN2@pop_datafd

; 645  :     { data_fd = datafile_stack[--include_depth-1].fd;

	dec	eax
	mov	DWORD PTR _include_depth, eax
	imul	eax, 1016				; 000003f8H
	mov	ecx, DWORD PTR _datafile_stack[eax-1016]

; 646  :       line_no = datafile_stack[include_depth-1].line;

	mov	edx, DWORD PTR _datafile_stack[eax-12]
	mov	DWORD PTR _data_fd, ecx
	mov	DWORD PTR _line_no, edx

; 649  : } // end pop_datafd()

	ret	0
_pop_datafd ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EM@FFGDAKFK@?6NOTE?3?5There?5were?5warning?5messag@ ; `string'
PUBLIC	??_C@_0BI@GMJOBNFL@End?5of?5file?5in?5comment?6?$AA@ ; `string'
PUBLIC	_pop_commandfd
EXTRN	_warning_messages_new:DWORD
EXTRN	_cmdfilename:DWORD
EXTRN	_command:PROC
EXTRN	_cmdstring:BYTE
EXTRN	_cmdstring_flag:DWORD
EXTRN	_file_no:DWORD
EXTRN	_datafile_flag:DWORD
EXTRN	_cmdfile_stack:BYTE
EXTRN	_datafile_input_flag:DWORD
EXTRN	_read_depth:DWORD
EXTRN	_my_exit:PROC
EXTRN	__isatty:PROC
EXTRN	__fileno:PROC
EXTRN	_in_comment:DWORD
;	COMDAT ??_C@_0EM@FFGDAKFK@?6NOTE?3?5There?5were?5warning?5messag@
CONST	SEGMENT
??_C@_0EM@FFGDAKFK@?6NOTE?3?5There?5were?5warning?5messag@ DB 0aH, 'NOTE:'
	DB	' There were warning messages. To review, do "print warning_me'
	DB	'ssages"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GMJOBNFL@End?5of?5file?5in?5comment?6?$AA@
CONST	SEGMENT
??_C@_0BI@GMJOBNFL@End?5of?5file?5in?5comment?6?$AA@ DB 'End of file in c'
	DB	'omment', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _pop_commandfd
_TEXT	SEGMENT
_pop_commandfd PROC					; COMDAT

; 733  : {

	push	ebx

; 734  :   if ( in_comment )

	xor	ebx, ebx
	cmp	DWORD PTR _in_comment, ebx
	je	SHORT $LN11@pop_comman

; 735  :           { kb_error(2205,"End of file in comment\n",WARNING );  }

	push	2
	push	OFFSET ??_C@_0BI@GMJOBNFL@End?5of?5file?5in?5comment?6?$AA@
	push	2205					; 0000089dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN11@pop_comman:

; 736  : #ifdef WIN32
; 737  :   if ( commandfd == stdin )

	call	___iob_func
	cmp	DWORD PTR _commandfd, eax
	jne	SHORT $LN8@pop_comman

; 738  :   { int tty = _isatty(_fileno(stdin));

	call	___iob_func
	push	eax
	call	__fileno
	push	eax
	call	__isatty
	add	esp, 8

; 739  :     if ( !tty ) 

	test	eax, eax
	jne	$LN2@pop_comman

; 740  :        my_exit(0); /* exit in case of redirected input */

	push	ebx
	call	_my_exit
	add	esp, 4
$LN8@pop_comman:

; 741  :     else return; /* Ctrl-C gives spurious EOF */
; 742  :     /* Note:   SIGINT is not supported for any Win32 application, 
; 743  :        including Windows 98/Me and Windows NT/2000/XP. When a CTRL+C 
; 744  :        interrupt occurs, Win32 operating systems generate a new thread 
; 745  :        to specifically handle that interrupt. This can cause a 
; 746  :        single-thread application such as UNIX, to become multithreaded, 
; 747  :        resulting in unexpected behavior. (MSDN Library on SIGINT )
; 748  :        */
; 749  :  }
; 750  : #endif
; 751  :   if ( datafile_input_flag && !cmdfile_stack[read_depth-1].datafile_flag 
; 752  :           /*&& !addload_flag */)

	mov	eax, DWORD PTR _read_depth
	cmp	DWORD PTR _datafile_input_flag, ebx
	je	SHORT $LN7@pop_comman
	mov	ecx, eax
	imul	ecx, 1016				; 000003f8H
	cmp	DWORD PTR _cmdfile_stack[ecx-8], ebx
	jne	SHORT $LN7@pop_comman

; 753  :   { datafile_input_flag = 0;

	mov	DWORD PTR _datafile_input_flag, ebx

; 754  :     datafile_flag = 0; /* safe since doing one-char read-ahead */

	mov	DWORD PTR _datafile_flag, ebx
	pop	ebx

; 776  :   }
; 777  : } // end pop_commandfd()

	ret	0
$LN7@pop_comman:

; 755  :     return;  /* lex needs to keep reading EOF for datafile */
; 756  :   }
; 757  :   
; 758  :   if ( read_depth <= 1 )

	cmp	eax, 1
	jg	SHORT $LN6@pop_comman

; 759  :   { read_depth = 0; commandfd = NULL; file_no = 0;}

	mov	DWORD PTR _read_depth, ebx
	mov	DWORD PTR _commandfd, ebx
	mov	DWORD PTR _file_no, ebx
	jmp	SHORT $LN14@pop_comman
$LN6@pop_comman:

; 760  :   else fclose(commandfd);

	mov	edx, DWORD PTR _commandfd
	push	edx
	call	_fclose

; 761  :   if ( read_depth > 0 ) 

	mov	ecx, DWORD PTR _read_depth
	add	esp, 4
	cmp	ecx, ebx
	jle	SHORT $LN4@pop_comman

; 762  :   { commandfd = cmdfile_stack[--read_depth-1].fd;

	dec	ecx
	mov	eax, ecx
	imul	eax, 1016				; 000003f8H
	mov	edx, DWORD PTR _cmdfile_stack[eax-1016]
	mov	DWORD PTR _commandfd, edx

; 763  :     line_no = cmdfile_stack[read_depth-1].line;

	mov	edx, DWORD PTR _cmdfile_stack[eax-12]

; 764  :     file_no = cmdfile_stack[read_depth-1].file_no;

	mov	eax, DWORD PTR _cmdfile_stack[eax-4]
	mov	DWORD PTR _read_depth, ecx
	mov	DWORD PTR _line_no, edx
	mov	DWORD PTR _file_no, eax
$LN4@pop_comman:

; 765  :   }
; 766  :   if ( (read_depth == 1) && cmdstring_flag )

	cmp	ecx, 1
	jne	SHORT $LN15@pop_comman
	cmp	DWORD PTR _cmdstring_flag, ebx
	je	SHORT $LN14@pop_comman

; 767  :   { cmdstring_flag = 0; // so replace_load doesn't try to recur
; 768  :     command(cmdstring,ADD_TO_HISTORY);

	push	ecx
	push	OFFSET _cmdstring
	mov	DWORD PTR _cmdstring_flag, ebx
	call	_command

; 769  :     cmdstring[0] = 0;

	mov	ecx, DWORD PTR _read_depth
	add	esp, 8
	mov	BYTE PTR _cmdstring, bl

; 770  :   }
; 771  :   if ( read_depth <= 1 )

	cmp	ecx, 1
$LN15@pop_comman:
	jg	SHORT $LN2@pop_comman
$LN14@pop_comman:

; 772  :   { cmdfilename = NULL;

	mov	DWORD PTR _cmdfilename, ebx

; 773  :     if ( warning_messages_new )

	cmp	DWORD PTR _warning_messages_new, ebx
	je	SHORT $LN1@pop_comman

; 774  :       outstring("\nNOTE: There were warning messages. To review, do \"print warning_messages\"\n");

	push	OFFSET ??_C@_0EM@FFGDAKFK@?6NOTE?3?5There?5were?5warning?5messag@
	call	_outstring
	add	esp, 4
$LN1@pop_comman:

; 775  :     warning_messages_new = 0;

	mov	DWORD PTR _warning_messages_new, ebx
$LN2@pop_comman:
	pop	ebx

; 776  :   }
; 777  : } // end pop_commandfd()

	ret	0
_pop_commandfd ENDP
_TEXT	ENDS
PUBLIC	??_C@_08JFBNJFNH@userio?4c?$AA@			; `string'
PUBLIC	_add_warning_message
EXTRN	_KB_realloc:PROC
EXTRN	_warning_messages_max:DWORD
EXTRN	_warning_messages:DWORD
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_08JFBNJFNH@userio?4c?$AA@
CONST	SEGMENT
??_C@_08JFBNJFNH@userio?4c?$AA@ DB 'userio.c', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _add_warning_message
_TEXT	SEGMENT
_message$ = 8						; size = 4
_add_warning_message PROC				; COMDAT

; 789  : { size_t needed = (warning_messages ? strlen(warning_messages):0) + strlen(message) + 10;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _warning_messages
	push	esi
	push	edi
	test	eax, eax
	je	SHORT $LN9@add_warnin
	mov	ecx, eax
	lea	esi, DWORD PTR [ecx+1]
$LL13@add_warnin:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL13@add_warnin
	sub	ecx, esi
	mov	esi, ecx
	jmp	SHORT $LN10@add_warnin
$LN9@add_warnin:
	xor	esi, esi
$LN10@add_warnin:
	push	ebx
	mov	ebx, DWORD PTR _message$[ebp]
	mov	ecx, ebx
	lea	edi, DWORD PTR [ecx+1]
	npad	5
$LL14@add_warnin:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL14@add_warnin

; 790  :   if ( warning_messages_max < needed )

	mov	edx, DWORD PTR _warning_messages_max
	sub	ecx, edi
	lea	ecx, DWORD PTR [ecx+esi+10]
	cmp	edx, ecx
	jae	SHORT $LN4@add_warnin

; 791  :   { if ( warning_messages_max < WARNING_MESSAGES_MAX )

	cmp	edx, 100000				; 000186a0H
	jae	SHORT $LN5@add_warnin

; 792  :     { warning_messages = (char*)kb_realloc(warning_messages,needed+1000);

	push	792					; 00000318H
	lea	esi, DWORD PTR [ecx+1000]
	push	OFFSET ??_C@_08JFBNJFNH@userio?4c?$AA@
	push	esi
	push	eax
	call	_KB_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _warning_messages, eax

; 793  :       warning_messages_max = needed+1000;

	mov	DWORD PTR _warning_messages_max, esi

; 794  :     }
; 795  :     else

	jmp	SHORT $LN4@add_warnin
$LN5@add_warnin:

; 796  :     { /* delete early messages */
; 797  :       char *c;
; 798  :       for ( c = warning_messages + 1000 ; *c != '\n' ; c++ ) ;

	cmp	BYTE PTR [eax+1000], 10			; 0000000aH
	lea	ecx, DWORD PTR [eax+1000]
	je	SHORT $LN1@add_warnin
$LL3@add_warnin:
	inc	ecx
	cmp	BYTE PTR [ecx], 10			; 0000000aH
	jne	SHORT $LL3@add_warnin
$LN1@add_warnin:

; 799  :       memcpy(warning_messages,c,warning_messages_max-(c-warning_messages));

	sub	edx, ecx
	add	edx, eax
	push	edx
	push	ecx
	push	eax
	call	_memcpy
	mov	eax, DWORD PTR _warning_messages
	add	esp, 12					; 0000000cH
$LN4@add_warnin:

; 800  :     }
; 801  :   }
; 802  :   strcat(warning_messages,message);

	mov	ecx, ebx
	mov	esi, ebx
	pop	ebx
$LL15@add_warnin:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL15@add_warnin
	sub	ecx, esi
	mov	edx, ecx
	lea	edi, DWORD PTR [eax-1]
$LL16@add_warnin:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL16@add_warnin
	mov	ecx, edx
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb

; 803  :   warning_messages_new++;

	inc	DWORD PTR _warning_messages_new
	pop	edi
	pop	esi

; 804  : } // end add_warning_message()

	pop	ebp
	ret	0
_add_warning_message ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GLJKPGNM@Source?5file?5?$CFs?0?5line?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0P@IIFAANFO@Called?5from?3?5?6?$AA@	; `string'
PUBLIC	_print_eval_stack_trace
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
EXTRN	_file_names:DWORD
EXTRN	_eval_stack_trace:BYTE
EXTRN	_eval_stack_trace_spot:DWORD
;	COMDAT ??_C@_0BJ@GLJKPGNM@Source?5file?5?$CFs?0?5line?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BJ@GLJKPGNM@Source?5file?5?$CFs?0?5line?5?$CFd?6?$AA@ DB 'Source f'
	DB	'ile %s, line %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IIFAANFO@Called?5from?3?5?6?$AA@
CONST	SEGMENT
??_C@_0P@IIFAANFO@Called?5from?3?5?6?$AA@ DB 'Called from: ', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _print_eval_stack_trace
_TEXT	SEGMENT
_print_eval_stack_trace PROC				; COMDAT

; 833  :   int i;
; 834  :   if ( eval_stack_trace_spot > 0 )

	cmp	DWORD PTR _eval_stack_trace_spot, 0
	jle	SHORT $LN4@print_eval

; 835  :   { erroutstring("Called from: \n");

	push	esi
	push	OFFSET ??_C@_0P@IIFAANFO@Called?5from?3?5?6?$AA@
	call	_erroutstring

; 836  :     for ( i = eval_stack_trace_spot-1 ; i >= 0 ; i-- )

	mov	esi, DWORD PTR _eval_stack_trace_spot
	add	esp, 4
	dec	esi
	js	SHORT $LN1@print_eval
$LL3@print_eval:

; 837  :     { struct treenode *node = eval_stack_trace[i];

	mov	eax, DWORD PTR _eval_stack_trace[esi*4]

; 838  :       sprintf(errmsg,"Source file %s, line %d\n",
; 839  :              file_names[node->file_no],node->line_no);

	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _file_names
	push	ecx
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	push	OFFSET ??_C@_0BJ@GLJKPGNM@Source?5file?5?$CFs?0?5line?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 840  :       erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 20					; 00000014H
	dec	esi
	jns	SHORT $LL3@print_eval
$LN1@print_eval:

; 841  :     }
; 842  :     erroutstring("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_erroutstring
	add	esp, 4
	pop	esi
$LN4@print_eval:

; 843  :   }
; 844  : 
; 845  : } // end print_eval_stack_trace()

	ret	0
_print_eval_stack_trace ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@ECBGFJBB@DATAFILE?5ERROR?5?$CFd?3?5?$AA@ ; `string'
PUBLIC	??_C@_0CI@LEIHKEOJ@Too?5many?5errors?5in?5datafile?4?5Abo@ ; `string'
PUBLIC	??_C@_0CA@KHNBAANB@called?5from?5file?5?$CFs?5at?5line?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@CPCAMBLO@Too?5many?5errors?4?5Aborting?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@FEOGDCJK@SYNTAX?5ERROR?5?$CFd?3?5?$AA@ ; `string'
PUBLIC	??_C@_0N@EGCOIPLL@WARNING?5?$CFd?3?5?$AA@	; `string'
PUBLIC	??_C@_0BE@LMLILLEJ@file?5?$CFs?5at?5line?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0L@JAGEGNBG@ERROR?5?$CFd?3?5?$AA@		; `string'
PUBLIC	??_C@_0O@IGBJDEFG@?6?$CFs?5Line?5?$CFd?3?6?$AA@	; `string'
PUBLIC	??_C@_0M@GKABPCPE@?6ERROR?5?$CFd?3?5?$AA@	; `string'
PUBLIC	??_C@_0BC@BDEMAHNB@?6FATAL?5ERROR?5?$CFd?3?5?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	__$ArrayPad$
EXTRN	_jumpbuf:BYTE
EXTRN	_win_get_thread_data:PROC
EXTRN	_thread_data_key:DWORD
EXTRN	_graphjumpbuf:BYTE
EXTRN	_draw_thread_id:DWORD
EXTRN	_gocount:DWORD
EXTRN	_myfree:PROC
EXTRN	_permlist:DWORD
EXTRN	_list:DWORD
EXTRN	_Met:BYTE
EXTRN	_vgrad_end:PROC
EXTRN	_clear_symtable:PROC
EXTRN	_recalc:PROC
EXTRN	_unsave_coords:PROC
EXTRN	_restore_coords:PROC
EXTRN	_saved:BYTE
EXTRN	_hessian_subshell_flag:DWORD
EXTRN	_iterate_flag:DWORD
EXTRN	_update_display:PROC
EXTRN	_longjmp:PROC
EXTRN	_cmdbuf:BYTE
EXTRN	__fpreset:PROC
EXTRN	_temp_free_all:PROC
EXTRN	_subshell_depth:DWORD
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	_graphmutex:DWORD
EXTRN	_locking_thread:DWORD
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	_const_expr_flag:DWORD
EXTRN	_local_nest_depth:DWORD
EXTRN	_function_kludge_flag:DWORD
EXTRN	_perm_rewind_globals:PROC
EXTRN	_old_perm_global_count:DWORD
EXTRN	_rewind_globals:PROC
EXTRN	_old_global_count:DWORD
EXTRN	_parse_errors:DWORD
EXTRN	_break_on_warning:DWORD
EXTRN	_break_after_warning:DWORD
EXTRN	_exit_after_warning:DWORD
EXTRN	_warnings_suppressed:BYTE
EXTRN	_warnings_suppressed_count:DWORD
EXTRN	_exit_after_error:DWORD
EXTRN	_recovery_flag:DWORD
EXTRN	_parse_error_flag:DWORD
EXTRN	_dump_buff:PROC
EXTRN	_strncat:PROC
EXTRN	_reading_comp_quant_flag:DWORD
EXTRN	_last_error:DWORD
EXTRN	_msgmax:DWORD
EXTRN	_msg:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BE@ECBGFJBB@DATAFILE?5ERROR?5?$CFd?3?5?$AA@
CONST	SEGMENT
??_C@_0BE@ECBGFJBB@DATAFILE?5ERROR?5?$CFd?3?5?$AA@ DB 'DATAFILE ERROR %d:'
	DB	' ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LEIHKEOJ@Too?5many?5errors?5in?5datafile?4?5Abo@
CONST	SEGMENT
??_C@_0CI@LEIHKEOJ@Too?5many?5errors?5in?5datafile?4?5Abo@ DB 'Too many e'
	DB	'rrors in datafile. Aborting.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KHNBAANB@called?5from?5file?5?$CFs?5at?5line?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0CA@KHNBAANB@called?5from?5file?5?$CFs?5at?5line?5?$CFd?6?$AA@ DB 'c'
	DB	'alled from file %s at line %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CPCAMBLO@Too?5many?5errors?4?5Aborting?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@CPCAMBLO@Too?5many?5errors?4?5Aborting?4?6?$AA@ DB 'Too many er'
	DB	'rors. Aborting.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FEOGDCJK@SYNTAX?5ERROR?5?$CFd?3?5?$AA@
CONST	SEGMENT
??_C@_0BC@FEOGDCJK@SYNTAX?5ERROR?5?$CFd?3?5?$AA@ DB 'SYNTAX ERROR %d: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EGCOIPLL@WARNING?5?$CFd?3?5?$AA@
CONST	SEGMENT
??_C@_0N@EGCOIPLL@WARNING?5?$CFd?3?5?$AA@ DB 'WARNING %d: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LMLILLEJ@file?5?$CFs?5at?5line?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BE@LMLILLEJ@file?5?$CFs?5at?5line?5?$CFd?6?$AA@ DB 'file %s at lin'
	DB	'e %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JAGEGNBG@ERROR?5?$CFd?3?5?$AA@
CONST	SEGMENT
??_C@_0L@JAGEGNBG@ERROR?5?$CFd?3?5?$AA@ DB 'ERROR %d: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IGBJDEFG@?6?$CFs?5Line?5?$CFd?3?6?$AA@
CONST	SEGMENT
??_C@_0O@IGBJDEFG@?6?$CFs?5Line?5?$CFd?3?6?$AA@ DB 0aH, '%s Line %d:', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GKABPCPE@?6ERROR?5?$CFd?3?5?$AA@
CONST	SEGMENT
??_C@_0M@GKABPCPE@?6ERROR?5?$CFd?3?5?$AA@ DB 0aH, 'ERROR %d: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BDEMAHNB@?6FATAL?5ERROR?5?$CFd?3?5?$AA@
CONST	SEGMENT
??_C@_0BC@BDEMAHNB@?6FATAL?5ERROR?5?$CFd?3?5?$AA@ DB 0aH, 'FATAL ERROR %d'
	DB	': ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _kb_error
_TEXT	SEGMENT
tv799 = -108						; size = 4
_size$ = -108						; size = 4
_c$89334 = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_errnum$ = 8						; size = 4
_emsg$ = 12						; size = 4
_mode$ = 16						; size = 4
_kb_error PROC						; COMDAT

; 860  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _mode$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _emsg$[ebp]
	push	edi
	npad	7
$LL91@kb_error:

; 861  :   extern int line_no;
; 862  :   char *fullmsg;
; 863  :   int size;
; 864  :   int prev_read_depth;
; 865  :   int i;
; 866  : 
; 867  :   if ( emsg == NULL ) emsg = "";  /* just in case */

	test	esi, esi
	jne	SHORT $LN88@kb_error
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN88@kb_error:

; 868  :   if ( emsg == errmsg ) { fullmsg = msg; size = msgmax; }

	cmp	esi, OFFSET _errmsg
	jne	SHORT $LN87@kb_error
	mov	ebx, DWORD PTR _msg
	mov	edi, DWORD PTR _msgmax
	jmp	SHORT $LN147@kb_error
$LN87@kb_error:

; 869  :   else { fullmsg = errmsg; size = sizeof(errmsg); }

	mov	ebx, OFFSET _errmsg
	mov	edi, 2000				; 000007d0H
$LN147@kb_error:

; 870  : 
; 871  :   last_error = errnum;

	mov	ecx, DWORD PTR _errnum$[ebp]
	mov	DWORD PTR _last_error, ecx

; 872  : 
; 873  : /*  if ( read_depth > 1 ) 
; 874  :   { sprintf(fullmsg,"\n%s Line %d:\n",
; 875  :       cmdfile_stack[read_depth-1].filename,line_no); 
; 876  :   }
; 877  :   else
; 878  :   */
; 879  :     fullmsg[0] = 0;

	mov	BYTE PTR [ebx], 0
	mov	DWORD PTR _size$[ebp], edi

; 880  : 
; 881  :   reading_comp_quant_flag = 0;  /* just in case */

	mov	DWORD PTR _reading_comp_quant_flag, 0

; 882  : 
; 883  :   switch ( mode )

	cmp	eax, 10					; 0000000aH
	ja	$LN84@kb_error
	mov	edx, DWORD PTR _mode$[ebp]
	jmp	DWORD PTR $LN150@kb_error[edx*4]
$LN42@kb_error:

; 1024 : 
; 1025 :      case COMMAND_ERROR:
; 1026 :         if ( datafile_flag )

	cmp	DWORD PTR _datafile_flag, 0
	je	$LN41@kb_error

; 1027 :         { /* kludge since cmdjmpbuf empty in datafile */
; 1028 :           kb_error(errnum,emsg,DATAFILE_ERROR);

	mov	eax, 6
	mov	DWORD PTR _mode$[ebp], eax
	jmp	SHORT $LL91@kb_error
$LN83@kb_error:

; 884  :   {
; 885  :      case UNRECOVERABLE:
; 886  :         sprintf(fullmsg+strlen(fullmsg),"\nFATAL ERROR %d: ",errnum);

	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
$LL112@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL112@kb_error
	mov	ecx, DWORD PTR _errnum$[ebp]
	push	ecx
	sub	eax, edx
	add	eax, ebx
	push	OFFSET ??_C@_0BC@BDEMAHNB@?6FATAL?5ERROR?5?$CFd?3?5?$AA@
	push	eax
	call	_sprintf

; 887  :         strncat(fullmsg,emsg,size);

	push	edi
	push	esi
	push	ebx
	call	_strncat
	add	esp, 24					; 00000018H

; 888  :         if ( datafile_flag )

	cmp	DWORD PTR _datafile_flag, 0
	je	SHORT $LN82@kb_error

; 889  :           dump_buff(fullmsg+strlen(fullmsg),size-strlen(fullmsg));

	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
$LL113@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL113@kb_error
	sub	eax, edx
	mov	edx, eax
	mov	eax, ebx
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR tv799[ebp], ecx
$LL114@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL114@kb_error
	sub	eax, DWORD PTR tv799[ebp]
	mov	ecx, edi
	sub	ecx, edx
	push	ecx
	add	eax, ebx
	push	eax
	call	_dump_buff
	add	esp, 8
$LN82@kb_error:

; 890  :         erroutstring(fullmsg);

	push	ebx
	call	_erroutstring

; 891  :         print_eval_stack_trace();

	call	_print_eval_stack_trace

; 892  :         my_exit(errnum);  

	mov	edx, DWORD PTR _errnum$[ebp]
	push	edx
	call	_my_exit
	add	esp, 8
$LN81@kb_error:

; 893  : 
; 894  :      case RECOVERABLE_ABORT:
; 895  :      case RECOVERABLE:
; 896  :         sprintf(fullmsg+strlen(fullmsg),"\nERROR %d: ",errnum);

	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL115@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL115@kb_error
	mov	ecx, DWORD PTR _errnum$[ebp]
	push	ecx
	sub	eax, edx
	add	eax, ebx
	push	OFFSET ??_C@_0M@GKABPCPE@?6ERROR?5?$CFd?3?5?$AA@
	push	eax
	call	_sprintf

; 897  :         strncat(fullmsg,emsg,size);

	push	edi
	push	esi
	push	ebx
	call	_strncat

; 898  :         /* pop stack of command files */
; 899  :         if ( read_depth > 0 ) cmdfile_stack[read_depth-1].line = line_no;

	mov	eax, DWORD PTR _read_depth
	add	esp, 24					; 00000018H
	test	eax, eax
	jle	SHORT $LN93@kb_error
	mov	edx, DWORD PTR _line_no
	imul	eax, 1016				; 000003f8H
	mov	DWORD PTR _cmdfile_stack[eax-12], edx
$LN93@kb_error:

; 900  :         while ( commandfd && (commandfd  != stdin) )

	cmp	DWORD PTR _commandfd, 0
	je	SHORT $LN78@kb_error
	npad	7
$LL79@kb_error:
	call	___iob_func
	cmp	DWORD PTR _commandfd, eax
	je	SHORT $LN78@kb_error

; 901  :           {
; 902  :              pop_commandfd();

	call	_pop_commandfd
	cmp	DWORD PTR _commandfd, 0
	jne	SHORT $LL79@kb_error
$LN78@kb_error:

; 903  :           }
; 904  :         strcat(fullmsg,"\n");

	lea	edi, DWORD PTR [ebx-1]
	npad	2
$LL116@kb_error:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL116@kb_error
	mov	ax, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@

; 905  :         erroutstring(fullmsg);

	push	ebx
	mov	WORD PTR [edi], ax
	call	_erroutstring
	add	esp, 4

; 906  :         print_eval_stack_trace();

	call	_print_eval_stack_trace

; 907  :         goto bailout;

	jmp	$bailout$89289
$LN94@kb_error:

; 908  : 
; 909  :      case RECOVERABLE_QUIET:
; 910  :         /* pop stack of command files */
; 911  :         while ( commandfd && (commandfd  != stdin) )

	cmp	DWORD PTR _commandfd, 0
	je	$bailout$89289
$LL76@kb_error:
	call	___iob_func
	cmp	DWORD PTR _commandfd, eax
	je	$bailout$89289

; 912  :              pop_commandfd();

	call	_pop_commandfd
	cmp	DWORD PTR _commandfd, 0
	jne	SHORT $LL76@kb_error

; 913  :         goto bailout;

	jmp	$bailout$89289
$LN74@kb_error:

; 914  : 
; 915  :      case Q_ERROR:
; 916  :         if ( read_depth > 1 ) 

	mov	eax, DWORD PTR _read_depth
	cmp	eax, 1
	jle	SHORT $LN73@kb_error

; 917  :         { sprintf(fullmsg,"\n%s Line %d:\n",
; 918  :           cmdfile_stack[read_depth-1].filename,line_no); 

	mov	ecx, DWORD PTR _line_no
	imul	eax, 1016				; 000003f8H
	push	ecx
	lea	edx, DWORD PTR _cmdfile_stack[eax-1012]
	push	edx
	push	OFFSET ??_C@_0O@IGBJDEFG@?6?$CFs?5Line?5?$CFd?3?6?$AA@
	push	ebx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN73@kb_error:

; 919  :         }
; 920  :         sprintf(fullmsg+strlen(fullmsg),"ERROR %d: ",errnum);

	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
$LL117@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL117@kb_error
	mov	ecx, DWORD PTR _errnum$[ebp]
	push	ecx
	sub	eax, edx
	add	eax, ebx
	push	OFFSET ??_C@_0L@JAGEGNBG@ERROR?5?$CFd?3?5?$AA@
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 921  :         strcat(fullmsg,emsg); 

	mov	eax, esi
$LL118@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL118@kb_error
	sub	eax, esi
	lea	edi, DWORD PTR [ebx-1]
$LL119@kb_error:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL119@kb_error
	mov	ecx, eax
	shr	ecx, 2
	rep movsd
	mov	ecx, eax
	and	ecx, 3

; 922  :         dump_buff(fullmsg+strlen(fullmsg),size-strlen(fullmsg));

	mov	eax, ebx
	rep movsb
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL120@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL120@kb_error
	sub	eax, edx
	mov	edx, eax
	mov	eax, ebx
	lea	esi, DWORD PTR [eax+1]
$LL121@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL121@kb_error
	mov	ecx, DWORD PTR _size$[ebp]
	sub	eax, esi
	sub	ecx, edx
	push	ecx
	add	eax, ebx
	push	eax
	call	_dump_buff

; 923  :         /* pop stack of command files */
; 924  :         if ( read_depth > 0 ) cmdfile_stack[read_depth-1].line = line_no;

	mov	eax, DWORD PTR _read_depth
	add	esp, 8
	test	eax, eax
	jle	SHORT $LN72@kb_error
	mov	ecx, DWORD PTR _line_no
	mov	edx, eax
	imul	edx, 1016				; 000003f8H
	mov	DWORD PTR _cmdfile_stack[edx-12], ecx
$LN72@kb_error:

; 925  :         prev_read_depth = read_depth+1;
; 926  :         while ( commandfd && (commandfd  != stdin) )

	cmp	DWORD PTR _commandfd, 0
	lea	esi, DWORD PTR [eax+1]
	je	SHORT $LN70@kb_error
$LL71@kb_error:
	call	___iob_func
	cmp	DWORD PTR _commandfd, eax
	je	SHORT $LN70@kb_error

; 927  :           { if ( read_depth < prev_read_depth )

	mov	ecx, DWORD PTR _read_depth
	cmp	ecx, esi
	jge	SHORT $LN69@kb_error

; 928  :                sprintf(fullmsg+strlen(fullmsg),"file %s at line %d\n",
; 929  :                   cmdfile_stack[read_depth-1].filename,
; 930  :                   cmdfile_stack[read_depth-1].line); 

	mov	eax, ebx
	lea	esi, DWORD PTR [eax+1]
	npad	1
$LL122@kb_error:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL122@kb_error
	imul	ecx, 1016				; 000003f8H
	mov	edx, DWORD PTR _cmdfile_stack[ecx-12]
	push	edx
	lea	ecx, DWORD PTR _cmdfile_stack[ecx-1012]
	push	ecx
	sub	eax, esi
	add	eax, ebx
	push	OFFSET ??_C@_0BE@LMLILLEJ@file?5?$CFs?5at?5line?5?$CFd?6?$AA@
	push	eax
	call	_sprintf
	mov	ecx, DWORD PTR _read_depth
	add	esp, 16					; 00000010H
$LN69@kb_error:

; 931  :             prev_read_depth = read_depth; /* pop_commandfd() doesn't always pop */            
; 932  :              if ( datafile_flag )

	cmp	DWORD PTR _datafile_flag, 0
	mov	esi, ecx
	jne	SHORT $LN102@kb_error

; 937  :                return;
; 938  :              }
; 939  :              else 
; 940  :              pop_commandfd();

	call	_pop_commandfd
	cmp	DWORD PTR _commandfd, 0
	jne	SHORT $LL71@kb_error
$LN70@kb_error:

; 941  :           }
; 942  :         erroutstring(fullmsg);

	push	ebx
	call	_erroutstring

; 943  :         erroutstring("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_erroutstring
	add	esp, 8

; 944  :         print_eval_stack_trace();

	call	_print_eval_stack_trace

; 945  :         goto bailout;

	jmp	$bailout$89289
$LN102@kb_error:

; 933  :              { parse_error_flag = 1;

	mov	eax, 1

; 934  :                recovery_flag = 1; 
; 935  :                erroutstring(fullmsg);

	push	ebx
	mov	DWORD PTR _parse_error_flag, eax
	mov	DWORD PTR _recovery_flag, eax
	call	_erroutstring
	add	esp, 4

; 936  :                if ( exit_after_error ) my_exit(errnum);

	cmp	DWORD PTR _exit_after_error, 0
	je	$LN89@kb_error
	mov	edx, DWORD PTR _errnum$[ebp]
	push	edx
	call	_my_exit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 1215 : #endif
; 1216 :   
; 1217 : } // end kb_error()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@kb_error:

; 946  : 
; 947  :      case WARNING:
; 948  :         for ( i = 0 ; i < warnings_suppressed_count ; i++ )

	mov	ecx, DWORD PTR _warnings_suppressed_count
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN142@kb_error
	mov	edx, DWORD PTR _errnum$[ebp]
	npad	6
$LL64@kb_error:

; 949  :           if ( errnum == warnings_suppressed[i] )

	cmp	edx, DWORD PTR _warnings_suppressed[eax*4]
	je	$LN89@kb_error

; 946  : 
; 947  :      case WARNING:
; 948  :         for ( i = 0 ; i < warnings_suppressed_count ; i++ )

	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL64@kb_error
$LN142@kb_error:

; 950  :             return;
; 951  : 		if ( read_depth > 1 ) 

	mov	eax, DWORD PTR _read_depth
	cmp	eax, 1
	jle	SHORT $LN60@kb_error

; 952  :         { sprintf(fullmsg,"\n%s Line %d:\n",
; 953  :           cmdfile_stack[read_depth-1].filename,line_no); 

	mov	ecx, DWORD PTR _line_no
	imul	eax, 1016				; 000003f8H
	push	ecx
	lea	edx, DWORD PTR _cmdfile_stack[eax-1012]
	push	edx
	push	OFFSET ??_C@_0O@IGBJDEFG@?6?$CFs?5Line?5?$CFd?3?6?$AA@
	push	ebx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN60@kb_error:

; 954  :         }
; 955  :         sprintf(fullmsg+strlen(fullmsg),"WARNING %d: ",errnum);

	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
$LL123@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL123@kb_error
	mov	ecx, DWORD PTR _errnum$[ebp]
	push	ecx
	sub	eax, edx
	add	eax, ebx
	push	OFFSET ??_C@_0N@EGCOIPLL@WARNING?5?$CFd?3?5?$AA@
	push	eax
	call	_sprintf

; 956  :         strncat(fullmsg,emsg,size);

	push	edi
	push	esi
	push	ebx
	call	_strncat
	add	esp, 24					; 00000018H

; 957  :         strcat(fullmsg,"\n");

	lea	edi, DWORD PTR [ebx-1]
	npad	5
$LL124@kb_error:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL124@kb_error
	mov	dx, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@

; 958  :         erroutstring(fullmsg);

	push	ebx
	mov	WORD PTR [edi], dx
	call	_erroutstring

; 959  :         print_eval_stack_trace();

	call	_print_eval_stack_trace

; 960  :         add_warning_message(fullmsg);

	push	ebx
	call	_add_warning_message
	add	esp, 8

; 961  :         if ( exit_after_warning ) my_exit(errnum);

	cmp	DWORD PTR _exit_after_warning, 0
	je	SHORT $LN59@kb_error
	mov	eax, DWORD PTR _errnum$[ebp]
	push	eax
	call	_my_exit
	add	esp, 4
$LN59@kb_error:

; 962  :         if ( break_after_warning ) breakflag = BREAKAFTERWARNING;

	cmp	DWORD PTR _break_after_warning, 0
	je	SHORT $LN58@kb_error
	mov	DWORD PTR _breakflag, 4
$LN58@kb_error:

; 963  :         if ( break_on_warning )  

	cmp	DWORD PTR _break_on_warning, 0
	jne	$bailout$89289
	pop	edi
	pop	esi
	pop	ebx

; 1215 : #endif
; 1216 :   
; 1217 : } // end kb_error()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@kb_error:

; 964  :           goto bailout;
; 965  :         
; 966  :         return;
; 967  : 
; 968  :     case EXPRESSION_ERROR:
; 969  :        if ( read_depth > 1 ) 

	mov	eax, DWORD PTR _read_depth
	cmp	eax, 1
	jle	SHORT $LN55@kb_error

; 970  :        { sprintf(fullmsg,"\n%s Line %d:\n",
; 971  :          cmdfile_stack[read_depth-1].filename,line_no); 

	mov	ecx, DWORD PTR _line_no
	imul	eax, 1016				; 000003f8H
	push	ecx
	lea	edx, DWORD PTR _cmdfile_stack[eax-1012]
	push	edx
	push	OFFSET ??_C@_0O@IGBJDEFG@?6?$CFs?5Line?5?$CFd?3?6?$AA@
	push	ebx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN55@kb_error:

; 972  :        }
; 973  :         sprintf(fullmsg+strlen(fullmsg),"SYNTAX ERROR %d: ",errnum);

	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL125@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL125@kb_error
	mov	ecx, DWORD PTR _errnum$[ebp]
	push	ecx
	sub	eax, edx
	add	eax, ebx
	push	OFFSET ??_C@_0BC@FEOGDCJK@SYNTAX?5ERROR?5?$CFd?3?5?$AA@
	push	eax
	call	_sprintf

; 974  :         strncat(fullmsg,emsg,size);

	push	edi
	push	esi
	push	ebx
	call	_strncat

; 975  :         dump_buff(fullmsg+strlen(fullmsg),size-strlen(fullmsg));

	mov	eax, ebx
	add	esp, 24					; 00000018H
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL126@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL126@kb_error
	sub	eax, edx
	mov	edx, eax
	mov	eax, ebx
	lea	esi, DWORD PTR [eax+1]
$LL127@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL127@kb_error
	sub	eax, esi
	sub	edi, edx
	add	eax, ebx
	push	edi
	push	eax
	call	_dump_buff

; 976  :         erroutstring(fullmsg);

	push	ebx
	call	_erroutstring

; 977  :         print_eval_stack_trace();

	call	_print_eval_stack_trace

; 978  :         add_warning_message(fullmsg);

	push	ebx
	call	_add_warning_message

; 979  :         if ( ++parse_errors >= 5 ) 

	mov	eax, DWORD PTR _parse_errors
	mov	ecx, 1
	add	eax, ecx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _parse_errors, eax
	cmp	eax, 5
	jl	SHORT $LN54@kb_error

; 980  :           {
; 981  :              erroutstring("Too many errors. Aborting.\n");

	push	OFFSET ??_C@_0BM@CPCAMBLO@Too?5many?5errors?4?5Aborting?4?6?$AA@
	call	_erroutstring
	add	esp, 4

; 982  :              /* pop stack of command files */
; 983  :              while ( commandfd && (commandfd  != stdin) ) pop_commandfd();

	cmp	DWORD PTR _commandfd, 0
	je	$bailout$89289
$LL53@kb_error:
	call	___iob_func
	cmp	DWORD PTR _commandfd, eax
	je	$bailout$89289
	call	_pop_commandfd
	cmp	DWORD PTR _commandfd, 0
	jne	SHORT $LL53@kb_error

; 984  :              goto bailout;

	jmp	$bailout$89289
$LN54@kb_error:

; 985  :           }
; 986  :         parse_error_flag = 1;

	mov	DWORD PTR _parse_error_flag, ecx

; 987  :         recovery_flag = 1;

	mov	DWORD PTR _recovery_flag, ecx
$LN148@kb_error:

; 988  :         if ( exit_after_error ) my_exit(errnum);

	cmp	DWORD PTR _exit_after_error, 0
	je	SHORT $LN84@kb_error
	mov	edx, DWORD PTR _errnum$[ebp]
	push	edx
$LN149@kb_error:
	call	_my_exit
	add	esp, 4
$LN84@kb_error:

; 1124 :         local_nest_depth = 0;
; 1125 :         return;
; 1126 :      }
; 1127 : 
; 1128 :   quiet_flag = 0;

	mov	DWORD PTR _quiet_flag, 0
$LN89@kb_error:
	pop	edi
	pop	esi
	pop	ebx

; 1215 : #endif
; 1216 :   
; 1217 : } // end kb_error()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@kb_error:

; 989  :         break;
; 990  : 
; 991  :      case SYNTAX_ERROR:
; 992  :         if ( read_depth > 1 ) 

	mov	eax, DWORD PTR _read_depth
	cmp	eax, 1
	jle	SHORT $LN49@kb_error

; 993  :         { sprintf(fullmsg,"\n%s Line %d:\n",
; 994  :           cmdfile_stack[read_depth-1].filename,line_no); 

	mov	ecx, DWORD PTR _line_no
	imul	eax, 1016				; 000003f8H
	push	ecx
	lea	edx, DWORD PTR _cmdfile_stack[eax-1012]
	push	edx
	push	OFFSET ??_C@_0O@IGBJDEFG@?6?$CFs?5Line?5?$CFd?3?6?$AA@
	push	ebx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN49@kb_error:

; 995  :         }
; 996  :         strncat(fullmsg,emsg,size); 

	push	edi
	push	esi
	push	ebx
	call	_strncat

; 997  :         /*
; 998  :         dump_buff(fullmsg+strlen(fullmsg),size-strlen(fullmsg));
; 999  :         */
; 1000 :         rewind_globals(old_global_count);

	mov	eax, DWORD PTR _old_global_count
	push	eax
	call	_rewind_globals

; 1001 :         perm_rewind_globals(old_perm_global_count);

	mov	ecx, DWORD PTR _old_perm_global_count
	push	ecx
	call	_perm_rewind_globals
	add	esp, 20					; 00000014H

; 1002 :         local_nest_depth = 0;
; 1003 :         /* pop stack of command files */
; 1004 :         if ( !function_kludge_flag )

	cmp	DWORD PTR _function_kludge_flag, 0
	mov	DWORD PTR _local_nest_depth, 0
	jne	$LN143@kb_error

; 1005 :         { FILE *oldcommandfd = commandfd;

	mov	eax, DWORD PTR _commandfd
	mov	esi, eax

; 1006 :           if ( commandfd && (commandfd  != stdin) ) pop_commandfd();

	test	eax, eax
	je	$LN143@kb_error
	call	___iob_func
	cmp	DWORD PTR _commandfd, eax
	je	SHORT $LN98@kb_error
	call	_pop_commandfd
$LN98@kb_error:

; 1007 :           while ( commandfd && (commandfd  != stdin) )

	cmp	DWORD PTR _commandfd, 0
	je	$LN143@kb_error
	npad	5
$LL46@kb_error:
	call	___iob_func
	mov	ecx, DWORD PTR _commandfd
	cmp	ecx, eax
	je	SHORT $LN143@kb_error

; 1008 :           { char c[100];
; 1009 :             if ( commandfd != oldcommandfd )

	cmp	ecx, esi
	je	SHORT $LN44@kb_error

; 1010 :             {
; 1011 :               sprintf(c,"called from file %s at line %d\n",
; 1012 :                   cmdfile_stack[read_depth-1].filename,
; 1013 :                   cmdfile_stack[read_depth-1].line);

	mov	eax, DWORD PTR _read_depth
	imul	eax, 1016				; 000003f8H
	mov	edx, DWORD PTR _cmdfile_stack[eax-12]
	push	edx
	lea	eax, DWORD PTR _cmdfile_stack[eax-1012]
	push	eax
	lea	ecx, DWORD PTR _c$89334[ebp]
	push	OFFSET ??_C@_0CA@KHNBAANB@called?5from?5file?5?$CFs?5at?5line?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf

; 1014 :               strncat(fullmsg,c,size-strlen(fullmsg));

	mov	eax, ebx
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL128@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL128@kb_error
	sub	eax, edx
	mov	edx, edi
	sub	edx, eax
	push	edx
	lea	eax, DWORD PTR _c$89334[ebp]
	push	eax
	push	ebx
	call	_strncat
	add	esp, 12					; 0000000cH
$LN44@kb_error:

; 1015 :             }
; 1016 :             pop_commandfd();

	call	_pop_commandfd
	cmp	DWORD PTR _commandfd, 0
	jne	SHORT $LL46@kb_error
$LN143@kb_error:

; 1017 :           }
; 1018 :         }
; 1019 :         strcat(fullmsg,"\n");

	lea	edi, DWORD PTR [ebx-1]
	npad	2
$LL129@kb_error:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL129@kb_error
	mov	cx, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@

; 1020 :         erroutstring(fullmsg); 

	push	ebx
	mov	WORD PTR [edi], cx
	call	_erroutstring
	add	esp, 4

; 1021 :         const_expr_flag = 0;

	mov	DWORD PTR _const_expr_flag, 0

; 1022 :         if ( exit_after_error ) my_exit(errnum);
; 1023 :         break; /* return to parser for its message */

	jmp	$LN148@kb_error
$LN41@kb_error:

; 1029 :           return;
; 1030 :         }
; 1031 :         if ( read_depth > 1 ) 

	mov	eax, DWORD PTR _read_depth
	cmp	eax, 1
	jle	SHORT $LN40@kb_error

; 1032 :         { sprintf(fullmsg,"\n%s Line %d:\n",
; 1033 :           cmdfile_stack[read_depth-1].filename,line_no); 

	mov	ecx, DWORD PTR _line_no
	imul	eax, 1016				; 000003f8H
	push	ecx
	lea	edx, DWORD PTR _cmdfile_stack[eax-1012]
	push	edx
	push	OFFSET ??_C@_0O@IGBJDEFG@?6?$CFs?5Line?5?$CFd?3?6?$AA@
	push	ebx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN40@kb_error:

; 1034 :         }
; 1035 :         sprintf(fullmsg+strlen(fullmsg),"ERROR %d: ",errnum);

	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL130@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL130@kb_error
	mov	ecx, DWORD PTR _errnum$[ebp]
	push	ecx
	sub	eax, edx
	add	eax, ebx
	push	OFFSET ??_C@_0L@JAGEGNBG@ERROR?5?$CFd?3?5?$AA@
	push	eax
	call	_sprintf

; 1036 :         strncat(fullmsg,emsg,size);

	push	edi
	push	esi
	push	ebx
	call	_strncat

; 1037 :         dump_buff(fullmsg+strlen(fullmsg),size-strlen(fullmsg));

	mov	eax, ebx
	add	esp, 24					; 00000018H
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL131@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL131@kb_error
	sub	eax, edx
	mov	edx, eax
	mov	eax, ebx
	lea	esi, DWORD PTR [eax+1]
$LL132@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL132@kb_error
	sub	eax, esi
	sub	edi, edx
	add	eax, ebx
	push	edi
	push	eax
	call	_dump_buff

; 1038 :         parse_error_flag = 1;
; 1039 :         rewind_globals(old_global_count);

	mov	edx, DWORD PTR _old_global_count
	push	edx
	mov	DWORD PTR _parse_error_flag, 1
	call	_rewind_globals

; 1040 :         perm_rewind_globals(old_perm_global_count);

	mov	eax, DWORD PTR _old_perm_global_count
	push	eax
	call	_perm_rewind_globals

; 1041 :         /* pop stack of command files */
; 1042 :         if ( read_depth > 0 ) cmdfile_stack[read_depth-1].line = line_no;

	mov	eax, DWORD PTR _read_depth
	xor	esi, esi
	add	esp, 16					; 00000010H
	cmp	eax, esi
	jle	SHORT $LN99@kb_error
	mov	ecx, DWORD PTR _line_no
	imul	eax, 1016				; 000003f8H
	mov	DWORD PTR _cmdfile_stack[eax-12], ecx
$LN99@kb_error:

; 1043 :         while ( commandfd && (commandfd  != stdin) )

	cmp	DWORD PTR _commandfd, esi
	je	SHORT $LN37@kb_error
	npad	3
$LL38@kb_error:
	call	___iob_func
	cmp	DWORD PTR _commandfd, eax
	je	SHORT $LN37@kb_error

; 1044 :           {
; 1045 : /*
; 1046 :              char stuff[200];
; 1047 :              sprintf(stuff,"file %s at line %d\n",
; 1048 :                   cmdfile_stack[read_depth-1].filename,
; 1049 :                   cmdfile_stack[read_depth-1].line);
; 1050 :                  strncat(fullmsg,stuff,size); 
; 1051 : */
; 1052 :              pop_commandfd();

	call	_pop_commandfd
	cmp	DWORD PTR _commandfd, esi
	jne	SHORT $LL38@kb_error
$LN37@kb_error:

; 1053 :           }
; 1054 :         strcat(fullmsg,"\n");

	lea	edi, DWORD PTR [ebx-1]
	npad	3
$LL133@kb_error:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL133@kb_error
	mov	dx, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@

; 1055 :         erroutstring(fullmsg);

	push	ebx
	mov	WORD PTR [edi], dx
	call	_erroutstring

; 1056 :         #ifdef PTHREADS
; 1057 :         if ( pthread_equal(locking_thread,pthread_self()) )
; 1058 :         {  ABORT_GRAPH_MUTEX
; 1059 :         }
; 1060 :         #endif
; 1061 :         #ifdef WINTHREADS
; 1062 :         if ( GetCurrentThreadId() == locking_thread )

	mov	edi, DWORD PTR __imp__GetCurrentThreadId@0
	add	esp, 4
	call	edi
	cmp	eax, DWORD PTR _locking_thread
	jne	SHORT $LN35@kb_error

; 1063 :         {  ABORT_GRAPH_MUTEX

	call	edi
	cmp	eax, DWORD PTR _locking_thread
	jne	SHORT $LN35@kb_error
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, esi
	call	DWORD PTR __imp__ReleaseMutex@4
$LN35@kb_error:

; 1064 :         }
; 1065 :         #endif
; 1066 :         if ( subshell_depth == 0 )

	cmp	DWORD PTR _subshell_depth, esi
	jne	SHORT $LN33@kb_error

; 1067 :           temp_free_all();

	call	_temp_free_all
$LN33@kb_error:

; 1068 :         if ( exit_after_error ) my_exit(errnum);

	cmp	DWORD PTR _exit_after_error, esi
	je	SHORT $LN32@kb_error
	mov	ecx, DWORD PTR _errnum$[ebp]
	push	ecx
	call	_my_exit
	add	esp, 4
$LN32@kb_error:

; 1069 :         FPRESET;

	call	__fpreset

; 1070 :         quiet_flag = 0;
; 1071 : #ifdef __cplusplus
; 1072 :         do_cmd_throw();
; 1073 : #else
; 1074 :         longjmp(cmdbuf,1);

	push	1
	push	OFFSET _cmdbuf
	mov	DWORD PTR _quiet_flag, esi
	call	_longjmp
$LN151@kb_error:
$LN31@kb_error:

; 1075 : #endif
; 1076 :         break;
; 1077 : 
; 1078 :      case PARSE_ERROR:
; 1079 :         if ( read_depth > 1 ) 

	mov	eax, DWORD PTR _read_depth
	cmp	eax, 1
	jle	SHORT $LN30@kb_error

; 1080 :         { sprintf(fullmsg,"\n%s Line %d:\n",
; 1081 :           cmdfile_stack[read_depth-1].filename,line_no); 

	mov	edx, DWORD PTR _line_no
	imul	eax, 1016				; 000003f8H
	push	edx
	lea	eax, DWORD PTR _cmdfile_stack[eax-1012]
	push	eax
	push	OFFSET ??_C@_0O@IGBJDEFG@?6?$CFs?5Line?5?$CFd?3?6?$AA@
	push	ebx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN30@kb_error:

; 1082 :         }
; 1083 :         sprintf(fullmsg+strlen(fullmsg),"SYNTAX ERROR %d: ",errnum);

	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
$LL134@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL134@kb_error
	mov	ecx, DWORD PTR _errnum$[ebp]
	push	ecx
	sub	eax, edx
	add	eax, ebx
	push	OFFSET ??_C@_0BC@FEOGDCJK@SYNTAX?5ERROR?5?$CFd?3?5?$AA@
	push	eax
	call	_sprintf

; 1084 :         strncat(fullmsg,emsg,size);

	push	edi
	push	esi
	push	ebx
	call	_strncat

; 1085 :         dump_buff(fullmsg+strlen(fullmsg),size-strlen(fullmsg));

	mov	eax, ebx
	add	esp, 24					; 00000018H
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL135@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL135@kb_error
	mov	ecx, ebx
	sub	eax, edx
	lea	esi, DWORD PTR [ecx+1]
	npad	2
$LL136@kb_error:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL136@kb_error
	sub	ecx, esi
	sub	edi, eax
	add	ecx, ebx
	push	edi
	push	ecx
	call	_dump_buff
	add	esp, 8

; 1086 :         strcat(fullmsg,"\n");

	lea	edi, DWORD PTR [ebx-1]
	npad	6
$LL137@kb_error:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL137@kb_error
	mov	dx, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@

; 1087 :         erroutstring(fullmsg);

	push	ebx
	mov	WORD PTR [edi], dx
	call	_erroutstring

; 1088 :         add_warning_message(fullmsg);

	push	ebx
	call	_add_warning_message

; 1089 :         if ( ++parse_errors >= 5 ) 

	mov	eax, DWORD PTR _parse_errors
	mov	ecx, 1
	add	eax, ecx
	add	esp, 8
	mov	DWORD PTR _parse_errors, eax
	cmp	eax, 5
	jl	SHORT $LN29@kb_error

; 1090 :           {
; 1091 :              erroutstring("Too many errors in datafile. Aborting.\n");

	push	OFFSET ??_C@_0CI@LEIHKEOJ@Too?5many?5errors?5in?5datafile?4?5Abo@
	call	_erroutstring
	add	esp, 4

; 1092 :              /* pop stack of command files */
; 1093 :              while ( commandfd && (commandfd  != stdin) ) pop_commandfd();

	cmp	DWORD PTR _commandfd, 0
	je	$bailout$89289
$LL28@kb_error:
	call	___iob_func
	cmp	DWORD PTR _commandfd, eax
	je	$bailout$89289
	call	_pop_commandfd
	cmp	DWORD PTR _commandfd, 0
	jne	SHORT $LL28@kb_error

; 1094 :              goto bailout;

	jmp	$bailout$89289
$LN29@kb_error:

; 1095 :           }
; 1096 :         parse_error_flag = 1;
; 1097 :         const_expr_flag = 0;
; 1098 :         recovery_flag = 1;
; 1099 :         if ( exit_after_error ) my_exit(errnum);

	cmp	DWORD PTR _exit_after_error, 0
	mov	DWORD PTR _parse_error_flag, ecx
	mov	DWORD PTR _const_expr_flag, 0
	mov	DWORD PTR _recovery_flag, ecx
	je	$LN84@kb_error
	mov	eax, DWORD PTR _errnum$[ebp]
	push	eax

; 1100 :         break;

	jmp	$LN149@kb_error
$LN25@kb_error:

; 1101 :         
; 1102 :      case DATAFILE_ERROR:
; 1103 :         if ( read_depth > 1 ) 

	mov	eax, DWORD PTR _read_depth
	cmp	eax, 1
	jle	SHORT $LN24@kb_error

; 1104 :         { sprintf(fullmsg,"\n%s Line %d:\n",
; 1105 :           cmdfile_stack[read_depth-1].filename,line_no); 

	mov	ecx, DWORD PTR _line_no
	imul	eax, 1016				; 000003f8H
	push	ecx
	lea	edx, DWORD PTR _cmdfile_stack[eax-1012]
	push	edx
	push	OFFSET ??_C@_0O@IGBJDEFG@?6?$CFs?5Line?5?$CFd?3?6?$AA@
	push	ebx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN24@kb_error:

; 1106 :         }
; 1107 :         sprintf(fullmsg+strlen(fullmsg),"DATAFILE ERROR %d: ",errnum);

	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
$LL138@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL138@kb_error
	mov	ecx, DWORD PTR _errnum$[ebp]
	push	ecx
	sub	eax, edx
	add	eax, ebx
	push	OFFSET ??_C@_0BE@ECBGFJBB@DATAFILE?5ERROR?5?$CFd?3?5?$AA@
	push	eax
	call	_sprintf

; 1108 :         strncat(fullmsg,emsg,size); 

	push	edi
	push	esi
	push	ebx
	call	_strncat

; 1109 :         dump_buff(fullmsg+strlen(fullmsg),size-strlen(fullmsg));

	mov	eax, ebx
	add	esp, 24					; 00000018H
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL139@kb_error:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL139@kb_error
	mov	ecx, ebx
	sub	eax, edx
	lea	esi, DWORD PTR [ecx+1]
	npad	2
$LL140@kb_error:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	test	dl, dl
	jne	SHORT $LL140@kb_error
	sub	ecx, esi
	sub	edi, eax
	add	ecx, ebx
	push	edi
	push	ecx
	call	_dump_buff
	add	esp, 8

; 1110 :         strcat(fullmsg,"\n");

	lea	edi, DWORD PTR [ebx-1]
	npad	6
$LL141@kb_error:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL141@kb_error
	mov	dx, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@

; 1111 :         erroutstring(fullmsg);

	push	ebx
	mov	WORD PTR [edi], dx
	call	_erroutstring

; 1112 :         add_warning_message(fullmsg);

	push	ebx
	call	_add_warning_message

; 1113 :         if ( ++parse_errors >= 5 ) 

	mov	eax, DWORD PTR _parse_errors
	mov	ecx, 1
	add	eax, ecx
	add	esp, 8
	mov	DWORD PTR _parse_errors, eax
	cmp	eax, 5
	jl	$LN23@kb_error

; 1114 :           {
; 1115 :              erroutstring("Too many errors in datafile. Aborting.\n");

	push	OFFSET ??_C@_0CI@LEIHKEOJ@Too?5many?5errors?5in?5datafile?4?5Abo@
	call	_erroutstring
	add	esp, 4

; 1116 :              /* pop stack of command files */
; 1117 :              while ( commandfd && (commandfd  != stdin) ) pop_commandfd();

	cmp	DWORD PTR _commandfd, 0
	je	SHORT $LN21@kb_error
$LL22@kb_error:
	call	___iob_func
	cmp	DWORD PTR _commandfd, eax
	je	SHORT $LN21@kb_error
	call	_pop_commandfd
	cmp	DWORD PTR _commandfd, 0
	jne	SHORT $LL22@kb_error
$LN21@kb_error:

; 1118 :              update_display(); /* so can see what we have so far */

	call	_update_display
$bailout$89289:

; 1129 :   return;
; 1130 : 
; 1131 : bailout:
; 1132 : 
; 1133 :   #ifdef MPI_EVOLVER
; 1134 :   if ( (this_task != 0) && !mpi_local_error_bailout )
; 1135 :   { erroutstring("ALL SLAVE TASK ERRORS FATAL! KILLING ALL PROCESSES!\n");
; 1136 :     MPI_Abort(MPI_COMM_WORLD,1);
; 1137 :   }
; 1138 :   #endif
; 1139 : 
; 1140 :   if ( outfd != stdout )

	call	___iob_func
	lea	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR _outfd

; 1141 :   { if ( outfd != NULL )

	xor	esi, esi
	cmp	eax, ecx
	je	SHORT $LN19@kb_error
	cmp	eax, esi
	je	SHORT $LN18@kb_error

; 1142 :     {
; 1143 :        fclose(outfd);

	push	eax
	call	_fclose
	add	esp, 4
$LN18@kb_error:

; 1144 :     }
; 1145 :     outfd = stdout;    /* in case of previous piping */

	call	___iob_func
	add	eax, 32					; 00000020H
	mov	DWORD PTR _outfd, eax
$LN19@kb_error:

; 1146 :   }
; 1147 :   if ( erroutfd != stderr )

	call	___iob_func
	lea	edx, DWORD PTR [eax+64]
	mov	eax, DWORD PTR _erroutfd
	cmp	eax, edx
	je	SHORT $LN17@kb_error

; 1148 :   { if ( erroutfd != NULL )

	cmp	eax, esi
	je	SHORT $LN16@kb_error

; 1149 :     {
; 1150 :        fclose(erroutfd);

	push	eax
	call	_fclose
	add	esp, 4
$LN16@kb_error:

; 1151 :     }
; 1152 :     erroutfd = stderr;    /* in case of previous piping */

	call	___iob_func
	add	eax, 64					; 00000040H
	mov	DWORD PTR _erroutfd, eax
$LN17@kb_error:

; 1153 :   }
; 1154 :   breakflag = 0; iterate_flag = 0;
; 1155 :   
; 1156 :   if ( mode == RECOVERABLE_ABORT )

	cmp	DWORD PTR _mode$[ebp], 10		; 0000000aH
	mov	DWORD PTR _breakflag, esi
	mov	DWORD PTR _iterate_flag, esi
	jne	SHORT $LN15@kb_error

; 1157 :   {
; 1158 :     subshell_depth = 0;

	mov	DWORD PTR _subshell_depth, esi

; 1159 :     hessian_subshell_flag = 0;

	mov	DWORD PTR _hessian_subshell_flag, esi
$LN15@kb_error:

; 1160 :   }
; 1161 :   
; 1162 :   if ( saved.coord ) 

	mov	edi, DWORD PTR __imp__GetCurrentThreadId@0
	mov	ebx, DWORD PTR __imp__ReleaseMutex@4
	cmp	DWORD PTR _saved, esi
	je	SHORT $LN145@kb_error

; 1163 :   { restore_coords(&saved,SAVE_IN_ATTR); 

	push	1
	push	OFFSET _saved
	call	_restore_coords

; 1164 :     unsave_coords(&saved,SAVE_IN_ATTR); 

	push	1
	push	OFFSET _saved
	call	_unsave_coords
	add	esp, 16					; 00000010H

; 1165 :     ABORT_GRAPH_MUTEX;

	call	edi
	cmp	eax, DWORD PTR _locking_thread
	jne	SHORT $LN13@kb_error
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, esi
	call	ebx
$LN13@kb_error:

; 1166 :     recalc();

	call	_recalc
$LN145@kb_error:

; 1167 :   }
; 1168 :   clear_symtable();     /* clear symbol table */

	call	_clear_symtable

; 1169 :   vgrad_end();          /* clear up volume gradients */

	call	_vgrad_end

; 1170 :   memset((char*)(&Met),0,sizeof(Met));

	push	232					; 000000e8H
	push	esi
	push	OFFSET _Met
	call	_memset
	add	esp, 12					; 0000000cH

; 1171 :   #ifdef PTHREADS
; 1172 :   if ( pthread_equal(locking_thread,pthread_self()) )
; 1173 :   {  ABORT_GRAPH_MUTEX
; 1174 :   }
; 1175 :   #endif
; 1176 :   #ifdef WINTHREADS
; 1177 :   if ( GetCurrentThreadId() == locking_thread )

	call	edi
	cmp	eax, DWORD PTR _locking_thread
	jne	SHORT $LN10@kb_error

; 1178 :   {  ABORT_GRAPH_MUTEX

	call	edi
	cmp	eax, DWORD PTR _locking_thread
	jne	SHORT $LN10@kb_error
	mov	ecx, DWORD PTR _graphmutex
	push	ecx
	mov	DWORD PTR _locking_thread, esi
	call	ebx
$LN10@kb_error:

; 1179 :   }
; 1180 :   #endif
; 1181 :   if ( subshell_depth == 0 )

	cmp	DWORD PTR _subshell_depth, esi
	jne	SHORT $LN8@kb_error

; 1182 :      temp_free_all();      

	call	_temp_free_all
$LN8@kb_error:

; 1183 :   if ( list && (list != permlist) )

	mov	eax, DWORD PTR _list
	cmp	eax, esi
	je	SHORT $LN7@kb_error
	cmp	eax, DWORD PTR _permlist
	je	SHORT $LN7@kb_error

; 1184 :     { myfree((char*)list); list = NULL; } /* plug memory leak */

	push	eax
	call	_myfree
	add	esp, 4
	mov	DWORD PTR _list, esi
$LN7@kb_error:

; 1185 :   quiet_flag = 0;

	mov	DWORD PTR _quiet_flag, esi

; 1186 :   gocount = 1;

	mov	DWORD PTR _gocount, 1

; 1187 :   local_nest_depth = 0;

	mov	DWORD PTR _local_nest_depth, esi

; 1188 :   if ( exit_after_error ) my_exit(errnum);

	cmp	DWORD PTR _exit_after_error, esi
	je	SHORT $LN6@kb_error
	mov	edx, DWORD PTR _errnum$[ebp]
	push	edx
	call	_my_exit
	add	esp, 4
$LN6@kb_error:

; 1189 :   FPRESET;

	call	__fpreset

; 1190 :   ABORT_GRAPH_MUTEX;

	call	edi
	cmp	eax, DWORD PTR _locking_thread
	jne	SHORT $LN5@kb_error
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, esi
	call	ebx
$LN5@kb_error:

; 1191 : #ifdef WIN32
; 1192 :   if ( draw_thread_id == GetCurrentThreadId() )

	call	edi
	cmp	DWORD PTR _draw_thread_id, eax
	jne	SHORT $LN2@kb_error

; 1193 : #elif defined(PTHREADS)
; 1194 :   if ( draw_thread_id == pthread_self() ) 
; 1195 : #endif
; 1196 : 
; 1197 : #if defined(WIN32) || defined(PTHREADS)
; 1198 : #ifdef __cplusplus
; 1199 :       do_graph_throw();
; 1200 : #else
; 1201 :       if ( *(int*)&graphjumpbuf )

	cmp	DWORD PTR _graphjumpbuf, esi
	je	SHORT $LN2@kb_error

; 1202 :         longjmp(graphjumpbuf,1);

	push	1
	push	OFFSET _graphjumpbuf
	call	_longjmp
$LN152@kb_error:
$LN2@kb_error:

; 1203 : #endif
; 1204 : #endif
; 1205 :  if ( subshell_depth == 0 )

	mov	eax, DWORD PTR _subshell_depth
	cmp	eax, esi
	jne	SHORT $LN1@kb_error

; 1206 :  { struct thread_data *td = GET_THREAD_DATA;

	mov	ecx, DWORD PTR _thread_data_key
	push	ecx
	call	_win_get_thread_data

; 1207 :    td->stack_top = td->eval_stack;

	mov	edx, DWORD PTR [eax+40]
	mov	DWORD PTR [eax+48], edx

; 1208 :    td->frame_spot = 0;

	mov	DWORD PTR [eax+52], esi
	mov	eax, DWORD PTR _subshell_depth
	add	esp, 4
$LN1@kb_error:

; 1209 :  }
; 1210 :  
; 1211 : #ifdef __cplusplus
; 1212 :   do_throw(errnum);
; 1213 : #else
; 1214 :   longjmp(jumpbuf[subshell_depth],1);

	shl	eax, 6
	push	1
	add	eax, OFFSET _jumpbuf
	push	eax
	call	_longjmp
$LN153@kb_error:
$LN23@kb_error:

; 1119 :              goto bailout;
; 1120 :           }
; 1121 :         parse_error_flag = 1;
; 1122 :         recovery_flag = 1;
; 1123 :         if ( exit_after_error ) my_exit(errnum);

	cmp	DWORD PTR _exit_after_error, 0
	mov	DWORD PTR _parse_error_flag, ecx
	mov	DWORD PTR _recovery_flag, ecx
	je	SHORT $LN20@kb_error
	mov	eax, DWORD PTR _errnum$[ebp]
	push	eax
	call	_my_exit
	add	esp, 4
$LN20@kb_error:

; 1215 : #endif
; 1216 :   
; 1217 : } // end kb_error()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	mov	DWORD PTR _local_nest_depth, 0
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN146@kb_error:
	npad	1
$LN150@kb_error:
	DD	$LN83@kb_error
	DD	$LN81@kb_error
	DD	$LN65@kb_error
	DD	$LN31@kb_error
	DD	$LN56@kb_error
	DD	$LN42@kb_error
	DD	$LN25@kb_error
	DD	$LN50@kb_error
	DD	$LN74@kb_error
	DD	$LN94@kb_error
	DD	$LN81@kb_error
_kb_error ENDP
_TEXT	ENDS
PUBLIC	_stop_logfile
; Function compile flags: /Ogtp
;	COMDAT _stop_logfile
_TEXT	SEGMENT
_stop_logfile PROC					; COMDAT

; 1267 :   if ( logfilefd ) fclose(logfilefd);

	mov	eax, DWORD PTR _logfilefd
	push	esi
	xor	esi, esi
	cmp	eax, esi
	je	SHORT $LN4@stop_logfi
	push	eax
	call	_fclose
	add	esp, 4
$LN4@stop_logfi:

; 1268 :   logfilefd = NULL;
; 1269 :   logfile_flag = 0;

	mov	DWORD PTR _logfile_flag, esi
	mov	DWORD PTR _logfilefd, esi
	pop	esi

; 1270 : } // end stop_logfile()

	ret	0
_stop_logfile ENDP
_TEXT	ENDS
PUBLIC	_stop_keylogfile
; Function compile flags: /Ogtp
;	COMDAT _stop_keylogfile
_TEXT	SEGMENT
_stop_keylogfile PROC					; COMDAT

; 1320 :   if ( keylogfilefd ) fclose(keylogfilefd);

	mov	eax, DWORD PTR _keylogfilefd
	push	esi
	xor	esi, esi
	cmp	eax, esi
	je	SHORT $LN4@stop_keylo
	push	eax
	call	_fclose
	add	esp, 4
$LN4@stop_keylo:

; 1321 :   keylogfilefd = NULL;
; 1322 :   keylogfile_flag = 0;

	mov	DWORD PTR _keylogfile_flag, esi
	mov	DWORD PTR _keylogfilefd, esi
	pop	esi

; 1323 : } // end stop_keylogfile()

	ret	0
_stop_keylogfile ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@INNPBMDA@Minimum?5scroll?5buffer?5size?5is?51?4@ ; `string'
PUBLIC	_set_scroll_size
EXTRN	__imp__SetConsoleScreenBufferSize@8:PROC
EXTRN	__imp__GetStdHandle@4:PROC
;	COMDAT ??_C@_0DE@INNPBMDA@Minimum?5scroll?5buffer?5size?5is?51?4@
CONST	SEGMENT
??_C@_0DE@INNPBMDA@Minimum?5scroll?5buffer?5size?5is?51?4@ DB 'Minimum sc'
	DB	'roll buffer size is 1.  Command ignored.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _set_scroll_size
_TEXT	SEGMENT
_size$ = 8						; size = 4
_rows$ = 8						; size = 4
_set_scroll_size PROC					; COMDAT

; 1334 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 1335 : #ifdef MSC
; 1336 :   COORD size;
; 1337 :   if ( rows < 1)

	mov	esi, DWORD PTR _rows$[ebp]
	cmp	esi, 1
	jge	SHORT $LN1@set_scroll

; 1338 :     kb_error(2428,"Minimum scroll buffer size is 1.  Command ignored.\n",
; 1339 :          WARNING);

	push	2
	push	OFFSET ??_C@_0DE@INNPBMDA@Minimum?5scroll?5buffer?5size?5is?51?4@
	push	2428					; 0000097cH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@set_scroll:

; 1340 :   size.X = 80;

	mov	eax, 80					; 00000050H
	mov	WORD PTR _size$[ebp], ax

; 1341 :   size.Y = (short)rows;

	mov	WORD PTR _size$[ebp+2], si

; 1342 :   SetConsoleScreenBufferSize(GetStdHandle(STD_OUTPUT_HANDLE),size);

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	-11					; fffffff5H
	call	DWORD PTR __imp__GetStdHandle@4
	push	eax
	call	DWORD PTR __imp__SetConsoleScreenBufferSize@8
	pop	esi

; 1343 : #else
; 1344 :   kb_error(2429,"ScrollBufferSize not implemented on this system.\n",
; 1345 :      WARNING);
; 1346 : #endif
; 1347 : } // end set_scroll_size()

	pop	ebp
	ret	0
_set_scroll_size ENDP
_TEXT	ENDS
PUBLIC	_getstring
EXTRN	_topflag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _getstring
_TEXT	SEGMENT
_inmsg$ = 8						; size = 4
_max$ = 12						; size = 4
_getstring PROC						; COMDAT

; 159  : { char *c;

	push	ebp
	mov	ebp, esp
	push	esi

; 160  :   max -= 2; /* ensure room */
; 161  :   
; 162  :   while ( commandfd && (commandfd != stdin) )

	mov	esi, DWORD PTR _inmsg$[ebp]
	push	edi
	mov	edi, DWORD PTR _max$[ebp]
	sub	edi, 2
	cmp	DWORD PTR _commandfd, 0
	je	SHORT $LN13@getstring
$LL14@getstring:
	call	___iob_func
	mov	ecx, DWORD PTR _commandfd
	cmp	ecx, eax
	je	SHORT $LN13@getstring

; 163  :   { /* from command input file */
; 164  :     if (my_fgets(inmsg,max,commandfd) == NULL) 

	push	ecx
	push	edi
	push	esi
	call	_my_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@getstring

; 165  :     { pop_commandfd();

	call	_pop_commandfd
	cmp	DWORD PTR _commandfd, 0
	jne	SHORT $LL14@getstring
$LN13@getstring:

; 173  :       return;
; 174  :     }
; 175  :   }
; 176  : #ifdef __L_EVOLVER__
; 177  :   if ( l_evolver_mode )

	cmp	DWORD PTR _l_evolver_mode, 0
	je	$LN8@getstring

; 178  :     {
; 179  : /* This next section is simply a copy of the code for standard input,
; 180  :     and most likely will be problematic if input is at the end of file
; 181  : 
; 182  :     On the other hand I don't understand the normal function - it looks
; 183  :     like it demands input and does NOT wait for a typical delayed
; 184  :     response from the console
; 185  : 
; 186  :     if ( my_fgets(inmsg,max,l_infd) == NULL )
; 187  :        my_exit(0);
; 188  :     c = inmsg + strlen(inmsg) - 1;
; 189  :     if ( *c == '\n' ) *c = 0;
; 190  :     if ( echo_flag ) { outstring(inmsg);  outstring("\n"); }
; 191  : */
; 192  :     while ( my_fgets(inmsg,max,l_infd) == NULL )

	mov	edx, DWORD PTR _l_infd
	push	edx
	push	edi
	push	esi
	call	_my_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN6@getstring
$LL7@getstring:

; 193  :        l_check_for_break(); /*Sleep(100); here?*/

	call	_l_check_for_break
	mov	eax, DWORD PTR _l_infd
	push	eax
	push	edi
	push	esi
	call	_my_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LL7@getstring
$LN6@getstring:

; 194  : /* WARNING: the prior statement could essentially be an infinite loop*/
; 195  :     c = inmsg + strlen(inmsg) - 1;

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
$LL22@getstring:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL22@getstring
	sub	eax, edx

; 196  :     if ( *c == '\n' ) *c = 0;

	cmp	BYTE PTR [eax+esi-1], 10		; 0000000aH
	jne	SHORT $LN5@getstring
	mov	BYTE PTR [eax+esi-1], cl
$LN5@getstring:

; 197  :     outstring(inmsg);

	push	esi
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi

; 220  : } // end getstring()

	pop	ebp
	ret	0
$LN12@getstring:

; 166  :       continue;  /* will fall thru to stdin eventually */
; 167  :     }
; 168  :     else 
; 169  :     {
; 170  :       if ( !topflag && !quiet_load_flag ) outstring(inmsg); /* echo */

	cmp	DWORD PTR _topflag, 0
	jne	SHORT $LN10@getstring
	cmp	DWORD PTR _quiet_load_flag, 0
	jne	SHORT $LN10@getstring
	push	esi
	call	_outstring
	add	esp, 4
$LN10@getstring:

; 171  :       if ( (int)strlen(inmsg) == max-1 ) 

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
$LL21@getstring:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL21@getstring
	sub	eax, edx
	lea	ecx, DWORD PTR [edi-1]
	cmp	eax, ecx
	jne	$LN1@getstring

; 172  :       {inmsg[max-1] = MOREIN; inmsg[max] = 0; }

	mov	WORD PTR [esi+edi-1], 1
	pop	edi
	pop	esi

; 220  : } // end getstring()

	pop	ebp
	ret	0
$LN8@getstring:

; 198  :     
; 199  : 	//outstring("\n"); 
; 200  : //      if ( !topflag && !quiet_load_flag ) outstring(inmsg); /* echo */
; 201  :     return;
; 202  :     }
; 203  :   
; 204  : #endif
; 205  : 
; 206  :   /* from stdin */
; 207  :   broken_pipe_flag = 0; /* in case left over */

	mov	DWORD PTR _broken_pipe_flag, 0

; 208  : 
; 209  : #if defined(MAC_APP) || defined(WIN32S) || defined(MAC_CW)
; 210  :   read_line_from_console(inmsg);
; 211  : #else
; 212  :   if ( my_fgets(inmsg,max,stdin) == NULL )

	call	___iob_func
	push	eax
	push	edi
	push	esi
	call	_my_fgets
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN4@getstring

; 213  :      my_exit(0);

	push	eax
	call	_my_exit
	add	esp, 4
$LN4@getstring:

; 214  :   c = inmsg + strlen(inmsg) - 1;

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL23@getstring:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL23@getstring
	sub	eax, edx

; 215  :   if ( *c == '\n' ) *c = 0;

	cmp	BYTE PTR [eax+esi-1], 10		; 0000000aH
	jne	SHORT $LN3@getstring
	mov	BYTE PTR [eax+esi-1], cl
$LN3@getstring:

; 216  :   if ( echo_flag ) { outstring(inmsg);  outstring("\n"); }

	cmp	DWORD PTR _echo_flag, 0
	je	SHORT $LN2@getstring
	push	esi
	call	_outstring
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_outstring
	add	esp, 8
$LN2@getstring:

; 217  : #endif
; 218  : 
; 219  :   if ( keylogfile_flag ) fprintf(keylogfilefd,"%s\n",inmsg);

	cmp	DWORD PTR _keylogfile_flag, 0
	je	SHORT $LN1@getstring
	mov	ecx, DWORD PTR _keylogfilefd
	push	esi
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	push	ecx
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN1@getstring:
	pop	edi
	pop	esi

; 220  : } // end getstring()

	pop	ebp
	ret	0
_getstring ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@MIGDMIJG@Cannot?5open?5?$CFs?4?$AA@	; `string'
PUBLIC	??_C@_0BN@NNNFKGPD@INCLUDEs?5nested?5too?5deeply?4?6?$AA@ ; `string'
PUBLIC	_push_datafd
EXTRN	_yylex_init:PROC
EXTRN	_filename:BYTE
EXTRN	_path_open:PROC
;	COMDAT ??_C@_0BA@MIGDMIJG@Cannot?5open?5?$CFs?4?$AA@
CONST	SEGMENT
??_C@_0BA@MIGDMIJG@Cannot?5open?5?$CFs?4?$AA@ DB 'Cannot open %s.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NNNFKGPD@INCLUDEs?5nested?5too?5deeply?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@NNNFKGPD@INCLUDEs?5nested?5too?5deeply?4?6?$AA@ DB 'INCLUDEs ne'
	DB	'sted too deeply.', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _push_datafd
_TEXT	SEGMENT
_cfd$ = 8						; size = 4
_name$ = 12						; size = 4
_push_datafd PROC					; COMDAT

; 603  : {

	push	ebp
	mov	ebp, esp

; 604  :   if ( include_depth >= NESTDEPTH-1 )

	mov	eax, DWORD PTR _include_depth
	cmp	eax, 9
	jl	SHORT $LN5@push_dataf

; 605  :      kb_error(1352,"INCLUDEs nested too deeply.\n",DATAFILE_ERROR);

	push	6
	push	OFFSET ??_C@_0BN@NNNFKGPD@INCLUDEs?5nested?5too?5deeply?4?6?$AA@
	push	1352					; 00000548H
	call	_kb_error
	mov	eax, DWORD PTR _include_depth
	add	esp, 12					; 0000000cH
$LN5@push_dataf:

; 606  : 
; 607  :   if ( cfd == NULL )

	push	esi
	mov	esi, DWORD PTR _cfd$[ebp]
	push	edi
	mov	edi, DWORD PTR _name$[ebp]
	test	esi, esi
	jne	$LN2@push_dataf

; 608  :      cfd = path_open(name,NOTDATAFILENAME);

	push	0
	push	edi
	call	_path_open
	mov	esi, eax
	add	esp, 8

; 609  : 
; 610  :   /* CSL: try the directory of the previous entry */
; 611  :   if( cfd==NULL && include_depth>0 && datafile_stack[include_depth-1].fd != stdin )

	test	esi, esi
	jne	SHORT $LN9@push_dataf
	mov	esi, DWORD PTR _include_depth
	test	esi, esi
	jle	SHORT $LN8@push_dataf
	imul	esi, 1016				; 000003f8H
	call	___iob_func
	cmp	DWORD PTR _datafile_stack[esi-1016], eax
	je	SHORT $LN8@push_dataf

; 612  :   {
; 613  :     add_path_to_name(datafile_stack[include_depth-1].filename,name,filename);

	push	OFFSET _filename
	lea	eax, DWORD PTR _datafile_stack[esi-1012]
	push	edi
	push	eax
	call	_add_path_to_name

; 614  :     cfd=path_open(filename,NOTDATAFILENAME);

	push	0
	push	OFFSET _filename
	call	_path_open
	mov	esi, eax
	add	esp, 20					; 00000014H

; 615  :   }
; 616  :  
; 617  :   if ( cfd == NULL )

	test	esi, esi
	jne	SHORT $LN9@push_dataf
$LN8@push_dataf:

; 618  :   { sprintf(errmsg,"Cannot open %s.",name);

	push	edi
	push	OFFSET ??_C@_0BA@MIGDMIJG@Cannot?5open?5?$CFs?4?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 619  :      kb_error(1353,errmsg,DATAFILE_ERROR);

	push	6
	push	OFFSET _errmsg
	push	1353					; 00000549H
	call	_kb_error
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 630  : } // end push_datafd()

	pop	ebp
	ret	0
$LN9@push_dataf:

; 620  : 
; 621  :      return;

	mov	eax, DWORD PTR _include_depth
$LN2@push_dataf:

; 622  :   }
; 623  :   if ( include_depth > 0 )

	test	eax, eax
	jle	SHORT $LN1@push_dataf

; 624  :       datafile_stack[include_depth-1].line = line_no;

	mov	edx, DWORD PTR _line_no
	mov	ecx, eax
	imul	ecx, 1016				; 000003f8H
	mov	DWORD PTR _datafile_stack[ecx-12], edx
$LN1@push_dataf:

; 625  :   line_no = 1;
; 626  :   strncpy(datafile_stack[include_depth].filename,name,PATHSIZE-1);

	imul	eax, 1016				; 000003f8H
	push	999					; 000003e7H
	add	eax, OFFSET _datafile_stack+4
	push	edi
	push	eax
	mov	DWORD PTR _line_no, 1
	call	_strncpy

; 627  :   datafile_stack[include_depth].line = 0;

	mov	ecx, DWORD PTR _include_depth
	mov	eax, ecx
	imul	eax, 1016				; 000003f8H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _datafile_stack[eax+1004], 0

; 628  :   datafile_stack[include_depth++].fd = data_fd = cfd;

	inc	ecx
	pop	edi
	mov	DWORD PTR _data_fd, esi
	mov	DWORD PTR _datafile_stack[eax], esi
	mov	DWORD PTR _include_depth, ecx
	pop	esi

; 630  : } // end push_datafd()

	pop	ebp

; 629  :   yylex_init();  /* reset lex */

	jmp	_yylex_init
_push_datafd ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@FNLOEFDB@READs?5nested?5too?5deeply?4?6?$AA@ ; `string'
PUBLIC	_push_commandfd
EXTRN	_kb_calloc:PROC
EXTRN	_file_no_max:DWORD
EXTRN	_file_no_used:DWORD
;	COMDAT ??_C@_0BK@FNLOEFDB@READs?5nested?5too?5deeply?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@FNLOEFDB@READs?5nested?5too?5deeply?4?6?$AA@ DB 'READs nested t'
	DB	'oo deeply.', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _push_commandfd
_TEXT	SEGMENT
_cfd$ = 8						; size = 4
_name$ = 12						; size = 4
_push_commandfd PROC					; COMDAT

; 662  : { int n;

	push	ebp
	mov	ebp, esp
	push	ebx

; 663  : 
; 664  :   if ( (cfd==NULL) && (name==NULL) ) return;

	mov	ebx, DWORD PTR _name$[ebp]
	push	esi
	mov	esi, DWORD PTR _cfd$[ebp]
	test	esi, esi
	jne	SHORT $LN15@push_comma
	test	ebx, ebx
	je	$LN16@push_comma
$LN15@push_comma:

; 665  :   if ( read_depth >= NESTDEPTH-1 )

	cmp	DWORD PTR _read_depth, 9
	jl	SHORT $LN30@push_comma

; 666  :      kb_error(1354,"READs nested too deeply.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BK@FNLOEFDB@READs?5nested?5too?5deeply?4?6?$AA@
	push	1354					; 0000054aH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN30@push_comma:

; 667  : 
; 668  :   if ( cfd == NULL )

	push	edi
	test	esi, esi
	jne	SHORT $LN31@push_comma

; 669  :      cfd = path_open(name,NOTDATAFILENAME);

	push	esi
	push	ebx
	call	_path_open
	mov	esi, eax
	add	esp, 8

; 670  : 
; 671  :   /* CSL: try the directory of the previous entry */
; 672  :   if( cfd==NULL && read_depth>0 && cmdfile_stack[read_depth-1].fd != stdin )

	test	esi, esi
	jne	SHORT $LN31@push_comma
	mov	edi, DWORD PTR _read_depth
	test	edi, edi
	jle	SHORT $LN23@push_comma
	imul	edi, 1016				; 000003f8H
	call	___iob_func
	cmp	DWORD PTR _cmdfile_stack[edi-1016], eax
	je	SHORT $LN23@push_comma

; 673  :   {
; 674  :     add_path_to_name(cmdfile_stack[read_depth-1].filename,name,filename);

	push	OFFSET _filename
	lea	eax, DWORD PTR _cmdfile_stack[edi-1012]
	push	ebx
	push	eax
	call	_add_path_to_name

; 675  :     cfd=path_open(filename,NOTDATAFILENAME);

	push	esi
	push	OFFSET _filename
	call	_path_open
	mov	esi, eax
	add	esp, 20					; 00000014H

; 676  :   }
; 677  : 
; 678  : 
; 679  :   if ( cfd == NULL )

	test	esi, esi
	jne	SHORT $LN31@push_comma
$LN23@push_comma:

; 680  :   { sprintf(errmsg,"Cannot open %s.",name);

	push	ebx
	push	OFFSET ??_C@_0BA@MIGDMIJG@Cannot?5open?5?$CFs?4?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 681  :     kb_error(1355,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1355					; 0000054bH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN31@push_comma:

; 682  :   }
; 683  :   if ( (cfd == stdin) && (read_depth == 1) ) read_depth = 0;

	call	___iob_func
	cmp	esi, eax
	mov	eax, DWORD PTR _read_depth
	jne	SHORT $LN32@push_comma
	cmp	eax, 1
	jne	SHORT $LN32@push_comma
	xor	eax, eax
	mov	DWORD PTR _read_depth, eax
$LN32@push_comma:

; 684  : #ifdef __L_EVOLVER__
; 685  : //else if (l_evolver_mode && cfd == l_infd &&  read_depth )
; 686  : 	 //read_depth = 0;
; 687  : 
; 688  : #endif
; 689  : 
; 690  :   strncpy(cmdfile_stack[read_depth].filename,name,PATHSIZE-1);

	imul	eax, 1016				; 000003f8H
	push	999					; 000003e7H
	add	eax, OFFSET _cmdfile_stack+4
	push	ebx
	push	eax
	call	_strncpy

; 691  :   cmdfile_stack[read_depth].datafile_flag = datafile_flag;

	mov	ecx, DWORD PTR _read_depth
	mov	edx, DWORD PTR _datafile_flag
	mov	eax, ecx
	imul	eax, 1016				; 000003f8H
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cmdfile_stack[eax+1008], edx

; 692  :   if ( read_depth > 0 )

	test	ecx, ecx
	jle	SHORT $LN9@push_comma

; 693  :      cmdfile_stack[read_depth-1].line = line_no; /* save previous line number */

	mov	ecx, DWORD PTR _line_no
	mov	DWORD PTR _cmdfile_stack[eax-12], ecx
$LN9@push_comma:

; 694  :   line_no = 1;
; 695  :   cmdfile_stack[read_depth].fd = commandfd = cfd;
; 696  : 
; 697  :   // see if file name already in list, i.e. replace_load
; 698  :   for ( n = 0 ; n < file_no_used ; n++ )

	mov	edi, DWORD PTR _file_no_used
	mov	DWORD PTR _commandfd, esi
	mov	DWORD PTR _cmdfile_stack[eax], esi
	xor	esi, esi
	mov	DWORD PTR _line_no, 1
	test	edi, edi
	jle	SHORT $LN4@push_comma
$LL8@push_comma:

; 699  :     if ( strcmp(name,file_names[n]) == 0 )

	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+esi*4]
	mov	eax, ebx
	npad	5
$LL24@push_comma:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN25@push_comma
	test	dl, dl
	je	SHORT $LN26@push_comma
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN25@push_comma
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL24@push_comma
$LN26@push_comma:
	xor	eax, eax
	jmp	SHORT $LN27@push_comma
$LN25@push_comma:
	sbb	eax, eax
	sbb	eax, -1
$LN27@push_comma:
	test	eax, eax
	je	$LN21@push_comma

; 694  :   line_no = 1;
; 695  :   cmdfile_stack[read_depth].fd = commandfd = cfd;
; 696  : 
; 697  :   // see if file name already in list, i.e. replace_load
; 698  :   for ( n = 0 ; n < file_no_used ; n++ )

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL8@push_comma
$LN4@push_comma:

; 702  :   { // already exists
; 703  :      file_no = n; // set global variable
; 704  :   }
; 705  :   else
; 706  :   { // append to list
; 707  :     if ( file_no_used >= file_no_max ) 

	mov	eax, DWORD PTR _file_no_max
	cmp	edi, eax
	jl	SHORT $LN2@push_comma

; 708  :     { file_names = (char**)kb_realloc((char*)file_names,
; 709  :         (2*file_no_max+10)*sizeof(char*));

	mov	ecx, DWORD PTR _file_names
	push	709					; 000002c5H
	push	OFFSET ??_C@_08JFBNJFNH@userio?4c?$AA@
	lea	eax, DWORD PTR [eax*8+40]
	push	eax
	push	ecx
	call	_KB_realloc

; 710  :     file_no_max = 2*file_no_max+10;

	mov	edx, DWORD PTR _file_no_max
	mov	DWORD PTR _file_names, eax
	lea	eax, DWORD PTR [edx+edx+10]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _file_no_max, eax
$LN2@push_comma:

; 711  :     } 
; 712  :     file_names[file_no_used] = mycalloc(strlen(name)+4,1);

	mov	eax, ebx
	lea	edx, DWORD PTR [eax+1]
$LL28@push_comma:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL28@push_comma
	push	712					; 000002c8H
	sub	eax, edx
	push	OFFSET ??_C@_08JFBNJFNH@userio?4c?$AA@
	add	eax, 4
	push	1
	push	eax
	call	_kb_calloc
	mov	ecx, DWORD PTR _file_names
	mov	edx, DWORD PTR _file_no_used
	mov	DWORD PTR [ecx+edx*4], eax

; 713  :     strcpy(file_names[file_no_used],name);

	mov	eax, DWORD PTR _file_no_used
	mov	edx, DWORD PTR _file_names
	mov	edx, DWORD PTR [edx+eax*4]
	add	esp, 16					; 00000010H
	mov	ecx, ebx
$LL18@push_comma:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL18@push_comma

; 714  :     if ( read_depth > 0 )

	mov	ecx, DWORD PTR _read_depth
	mov	eax, DWORD PTR _file_no_used
	test	ecx, ecx
	jle	SHORT $LN1@push_comma

; 715  :     { file_no = file_no_used;
; 716  :       cmdfile_stack[read_depth].file_no = file_no;

	imul	ecx, 1016				; 000003f8H
	mov	DWORD PTR _file_no, eax
	mov	DWORD PTR _cmdfile_stack[ecx+1012], eax
$LN1@push_comma:

; 717  :     }
; 718  :     file_no_used++;

	pop	edi
	inc	eax

; 719  :   }
; 720  : 
; 721  :   read_depth++;

	inc	DWORD PTR _read_depth
	pop	esi
	mov	DWORD PTR _file_no_used, eax
	pop	ebx

; 723  : } // end push_commandfd()

	pop	ebp

; 722  :   yylex_init();  /* reset lex */ 

	jmp	_yylex_init
$LN21@push_comma:

; 700  :       break;
; 701  :   if ( n < file_no_used )

	cmp	esi, edi
	jge	$LN4@push_comma

; 719  :   }
; 720  : 
; 721  :   read_depth++;

	inc	DWORD PTR _read_depth
	pop	edi
	mov	DWORD PTR _file_no, esi
	pop	esi
	pop	ebx

; 723  : } // end push_commandfd()

	pop	ebp

; 722  :   yylex_init();  /* reset lex */ 

	jmp	_yylex_init
$LN16@push_comma:
	pop	esi
	pop	ebx

; 723  : } // end push_commandfd()

	pop	ebp
	ret	0
_push_commandfd ENDP
_TEXT	ENDS
PUBLIC	??_C@_01MCMALHOG@a?$AA@				; `string'
PUBLIC	??_C@_0BI@PKPIDCIJ@Missing?5log?5file?5name?4?6?$AA@ ; `string'
PUBLIC	_start_logfile
EXTRN	_perror:PROC
EXTRN	_l_redirect:DWORD
EXTRN	_fopen:PROC
EXTRN	_logfilename:BYTE
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT
??_C@_01MCMALHOG@a?$AA@ DB 'a', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PKPIDCIJ@Missing?5log?5file?5name?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@PKPIDCIJ@Missing?5log?5file?5name?4?6?$AA@ DB 'Missing log file'
	DB	' name.', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _start_logfile
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_start_logfile PROC					; COMDAT

; 1231 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 1232 :   char *name = filename ? filename : logfilename;

	mov	edi, DWORD PTR _filename$[ebp]
	mov	esi, edi
	test	edi, edi
	jne	SHORT $LN10@start_logf
	mov	esi, OFFSET _logfilename
$LN10@start_logf:

; 1233 : 
; 1234 :   if ( name[0] == 0 )

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN6@start_logf

; 1235 :      kb_error(2206,"Missing log file name.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BI@PKPIDCIJ@Missing?5log?5file?5name?4?6?$AA@
	push	2206					; 0000089eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN6@start_logf:

; 1236 : 
; 1237 :   stop_logfile();

	call	_stop_logfile

; 1238 : 
; 1239 :   logfilefd = fopen(name,"a");

	push	OFFSET ??_C@_01MCMALHOG@a?$AA@
	push	esi
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _logfilefd, eax

; 1240 :   if ( !logfilefd ) 

	test	eax, eax
	jne	SHORT $LN5@start_logf

; 1241 :   {
; 1242 : #ifdef __L_EVOLVER__		 
; 1243 : 		   		     if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, eax
	jne	SHORT $LN3@start_logf
	cmp	DWORD PTR _l_evolver_mode, eax
	jne	SHORT $LN3@start_logf

; 1245 : 		   		     else
; 1246 : 					   perror(name);

	push	esi
	call	_perror
	add	esp, 4
	pop	edi
	pop	esi

; 1255 : 
; 1256 : } // end start_logfile()

	pop	ebp
	ret	0
$LN3@start_logf:

; 1244 : 			   		   erroutstring(name);

	push	esi
	call	_erroutstring
	add	esp, 4
	pop	edi
	pop	esi

; 1255 : 
; 1256 : } // end start_logfile()

	pop	ebp
	ret	0
$LN5@start_logf:

; 1247 : #else
; 1248 : 					 perror(name);
; 1249 : #endif	
; 1250 : 					 return; 
; 1251 :   }
; 1252 : 
; 1253 :   logfile_flag = 1;

	mov	DWORD PTR _logfile_flag, 1

; 1254 :   if ( filename ) strncpy(logfilename,filename,sizeof(logfilename)-1);

	test	edi, edi
	je	SHORT $LN1@start_logf
	push	999					; 000003e7H
	push	edi
	push	OFFSET _logfilename
	call	_strncpy
	add	esp, 12					; 0000000cH
$LN1@start_logf:
	pop	edi
	pop	esi

; 1255 : 
; 1256 : } // end start_logfile()

	pop	ebp
	ret	0
_start_logfile ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@PONPGDPK@Missing?5key?5log?5file?5name?4?6?$AA@ ; `string'
PUBLIC	_start_keylogfile
EXTRN	_keylogfilename:BYTE
;	COMDAT ??_C@_0BM@PONPGDPK@Missing?5key?5log?5file?5name?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@PONPGDPK@Missing?5key?5log?5file?5name?4?6?$AA@ DB 'Missing key'
	DB	' log file name.', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _start_keylogfile
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_start_keylogfile PROC					; COMDAT

; 1283 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 1284 :   char *name = filename ? filename : keylogfilename;

	mov	edi, DWORD PTR _filename$[ebp]
	mov	esi, edi
	test	edi, edi
	jne	SHORT $LN10@start_keyl
	mov	esi, OFFSET _keylogfilename
$LN10@start_keyl:

; 1285 : 
; 1286 :   if ( name[0] == 0 )

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN6@start_keyl

; 1287 :      kb_error(2420,"Missing key log file name.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BM@PONPGDPK@Missing?5key?5log?5file?5name?4?6?$AA@
	push	2420					; 00000974H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN6@start_keyl:

; 1288 : 
; 1289 :   stop_keylogfile();

	call	_stop_keylogfile

; 1290 : 
; 1291 :   keylogfilefd = fopen(name,"a");

	push	OFFSET ??_C@_01MCMALHOG@a?$AA@
	push	esi
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _keylogfilefd, eax

; 1292 :   if ( !keylogfilefd )

	test	eax, eax
	jne	SHORT $LN5@start_keyl

; 1293 :   {
; 1294 : #ifdef __L_EVOLVER__		 
; 1295 : 		   		     if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, eax
	jne	SHORT $LN3@start_keyl
	cmp	DWORD PTR _l_evolver_mode, eax
	jne	SHORT $LN3@start_keyl

; 1297 : 		   		     else
; 1298 : 					   perror(name);

	push	esi
	call	_perror
	add	esp, 4
	pop	edi
	pop	esi

; 1308 : 
; 1309 : } // endstart_keylogfile()

	pop	ebp
	ret	0
$LN3@start_keyl:

; 1296 : 			   		   erroutstring(name);

	push	esi
	call	_erroutstring
	add	esp, 4
	pop	edi
	pop	esi

; 1308 : 
; 1309 : } // endstart_keylogfile()

	pop	ebp
	ret	0
$LN5@start_keyl:

; 1299 : #else
; 1300 : 					 perror(name);
; 1301 : #endif	
; 1302 : 					 return; 
; 1303 :   }
; 1304 : 
; 1305 : 
; 1306 :   keylogfile_flag = 1;

	mov	DWORD PTR _keylogfile_flag, 1

; 1307 :   if ( filename ) strncpy(keylogfilename,filename,sizeof(keylogfilename)-1);

	test	edi, edi
	je	SHORT $LN1@start_keyl
	push	999					; 000003e7H
	push	edi
	push	OFFSET _keylogfilename
	call	_strncpy
	add	esp, 12					; 0000000cH
$LN1@start_keyl:
	pop	edi
	pop	esi

; 1308 : 
; 1309 : } // endstart_keylogfile()

	pop	ebp
	ret	0
_start_keylogfile ENDP
_TEXT	ENDS
END
