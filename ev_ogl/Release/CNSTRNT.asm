; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\CNSTRNT.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_unset_attr
; Function compile flags: /Ogtp
;	COMDAT _unset_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_unset_attr PROC					; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp

; 29   :   elptr(id)->attr &= ~attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	not	ecx
	and	DWORD PTR [eax+8], ecx
	not	edx
	and	DWORD PTR [eax+12], edx

; 30   : }

	pop	ebp
	ret	0
_unset_attr ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _get_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_edge PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp

; 70   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[1]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H

; 72   : }

	pop	ebp
	ret	0
$LN2@get_prev_e:

; 71   :   else return feptr(fe_id)->nextedge[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 72   : }

	pop	ebp
	ret	0
_get_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_tail_edge PROC				; COMDAT

; 270  : { return eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4+32]
	pop	ebp
	ret	0
_get_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	??_C@_09HIPGGKDD@CNSTRNT?4C?$AA@		; `string'
PUBLIC	_constraint_init
EXTRN	_kb_calloc:PROC
;	COMDAT ??_C@_09HIPGGKDD@CNSTRNT?4C?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\cnstrnt.c
CONST	SEGMENT
??_C@_09HIPGGKDD@CNSTRNT?4C?$AA@ DB 'CNSTRNT.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _constraint_init
_TEXT	SEGMENT
_con$ = 8						; size = 4
_constraint_init PROC					; COMDAT

; 24   : { int i;

	push	ebp
	mov	ebp, esp
	push	esi

; 25   :   con->formula = (struct expnode *)mycalloc(1+2*MAXCONCOMP,
; 26   :       sizeof(struct expnode));

	mov	esi, DWORD PTR _con$[ebp]
	push	26					; 0000001aH
	push	OFFSET ??_C@_09HIPGGKDD@CNSTRNT?4C?$AA@
	push	104					; 00000068H
	push	31					; 0000001fH
	call	_kb_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+40], eax
	xor	eax, eax
	lea	ecx, DWORD PTR [esi+108]
$LL3@constraint:

; 27   : 
; 28   :   for ( i = 0 ; i < MAXCONCOMP ; i++ )
; 29   :   { con->envect[i] = con->formula + 1 + i;

	mov	edx, DWORD PTR [esi+40]
	lea	edx, DWORD PTR [eax+edx+104]
	mov	DWORD PTR [ecx-60], edx

; 30   :     con->convect[i] = con->formula + 1 + MAXCONCOMP + i;

	mov	edx, DWORD PTR [esi+40]
	lea	edx, DWORD PTR [eax+edx+1664]
	mov	DWORD PTR [ecx], edx
	add	eax, 104				; 00000068H
	add	ecx, 4
	cmp	eax, 1560				; 00000618H
	jl	SHORT $LL3@constraint
	pop	esi

; 31   :   }
; 32   : } // end constraint_init()

	pop	ebp
	ret	0
_constraint_init ENDP
_TEXT	ENDS
PUBLIC	_constraint_free
EXTRN	_myfree:PROC
EXTRN	_free_expr:PROC
; Function compile flags: /Ogtp
;	COMDAT _constraint_free
_TEXT	SEGMENT
_con$ = 8						; size = 4
_constraint_free PROC					; COMDAT

; 43   : { int j;

	push	ebp
	mov	ebp, esp
	push	ebx

; 44   : 
; 45   :   if ( con->formula )

	mov	ebx, DWORD PTR _con$[ebp]
	cmp	DWORD PTR [ebx+40], 0
	je	SHORT $LN4@constraint@2

; 46   :   { for ( j = 0 ; j < MAXCONCOMP ; j++ )

	push	esi
	push	edi
	lea	esi, DWORD PTR [ebx+108]
	mov	edi, 15					; 0000000fH
$LL3@constraint@2:

; 47   :     { free_expr(con->envect[j]);

	mov	eax, DWORD PTR [esi-60]
	push	eax
	call	_free_expr

; 48   :       free_expr(con->convect[j]);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	_free_expr
	add	esp, 8
	add	esi, 4
	dec	edi
	jne	SHORT $LL3@constraint@2

; 49   :     }
; 50   :     free_expr(con->formula);

	mov	edx, DWORD PTR [ebx+40]
	push	edx
	call	_free_expr

; 51   :     myfree((char*)con->formula);

	mov	eax, DWORD PTR [ebx+40]
	push	eax
	call	_myfree
	add	esp, 8
	pop	edi
	pop	esi
$LN4@constraint@2:
	pop	ebx

; 52   :   }
; 53   :   
; 54   : } // end constraint_free(

	pop	ebp
	ret	0
_constraint_free ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0CK@LBMCBKJ@?4?5?5Maybe?5redundant?5one?9sided?5con@ ; `string'
PUBLIC	??_C@_03EEBNCBOD@?5?$CFs?$AA@			; `string'
PUBLIC	??_C@_0BP@BMAGEEBM@?5?5?5?5Projecting?5on?5constraints?5?$AA@ ; `string'
PUBLIC	??_C@_0EH@MELMCFI@Trying?5to?5project?5vertex?5?$CFs?5on?5m@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	_combo$GSCopy$
PUBLIC	_b$GSCopy$
PUBLIC	_coord$GSCopy$
PUBLIC	_constr$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_constr_proj
EXTRN	_mat_approx_solve:PROC
EXTRN	_dot:PROC
EXTRN	_eval_all:PROC
EXTRN	_kb_error:PROC
EXTRN	_errmsg:BYTE
EXTRN	_sprintf:PROC
EXTRN	_elnames:BYTE
EXTRN	_mat2d_setup:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LBMCBKJ@?4?5?5Maybe?5redundant?5one?9sided?5con@
CONST	SEGMENT
??_C@_0CK@LBMCBKJ@?4?5?5Maybe?5redundant?5one?9sided?5con@ DB '.  Maybe r'
	DB	'edundant one-sided constraints?', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03EEBNCBOD@?5?$CFs?$AA@
CONST	SEGMENT
??_C@_03EEBNCBOD@?5?$CFs?$AA@ DB ' %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BMAGEEBM@?5?5?5?5Projecting?5on?5constraints?5?$AA@
CONST	SEGMENT
??_C@_0BP@BMAGEEBM@?5?5?5?5Projecting?5on?5constraints?5?$AA@ DB '    Pro'
	DB	'jecting on constraints ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@MELMCFI@Trying?5to?5project?5vertex?5?$CFs?5on?5m@
CONST	SEGMENT
??_C@_0EH@MELMCFI@Trying?5to?5project?5vertex?5?$CFs?5on?5m@ DB 'Trying t'
	DB	'o project vertex %s on more constraints, %d, than allowed, %d'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _constr_proj
_TEXT	SEGMENT
_aqXvS$ = -732						; size = 24
_fval$ = -708						; size = 8
_a$ = -700						; size = 4
tv738 = -696						; size = 4
_coord$GSCopy$ = -692					; size = 4
_bb$ = -692						; size = 4
tv152 = -688						; size = 4
_constr$GSCopy$ = -688					; size = 4
tv1401 = -684						; size = 4
_combo$GSCopy$ = -684					; size = 4
tv736 = -680						; size = 4
_b$GSCopy$ = -680					; size = 4
_axJ$ = -676						; size = 288
_grad$ = -388						; size = 288
_r$ = -100						; size = 48
_c$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_mode$ = 8						; size = 4
_concount$ = 12						; size = 4
_constr$ = 16						; size = 4
_coord$ = 20						; size = 4
_b$ = 24						; size = 4
_combo$ = 28						; size = 4
_conlist$ = 32						; size = 4
_detect_flag$ = 36					; size = 4
_v_id$ = 40						; size = 4
_constr_proj PROC					; COMDAT

; 86   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 732				; 000002dcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 146  : #endif
; 147  : 
; 148  :   /* form combination */
; 149  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _constr$[ebp]
	mov	ecx, DWORD PTR _coord$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _combo$[ebp]
	push	edi
	mov	edi, DWORD PTR _conlist$[ebp]
	push	6
	mov	DWORD PTR _constr$GSCopy$[ebp], eax
	push	6
	lea	eax, DWORD PTR _axJ$[ebp]
	mov	DWORD PTR _coord$GSCopy$[ebp], ecx
	push	eax
	lea	ecx, DWORD PTR _aqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _b$GSCopy$[ebp], edx
	mov	DWORD PTR _combo$GSCopy$[ebp], esi
	call	_mat2d_setup
	mov	ebx, DWORD PTR _concount$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _a$[ebp], eax
	cmp	ebx, 6
	jle	$LN63@constr_pro

; 87   : /* maximum number of hit constraints */
; 88   : #define MAXCONSTR MAXCOORD
; 89   :   int i,j;
; 90   :   REAL grad[MAXCONSTR][MAXCOORD];     /* gradients of constraints */
; 91   :   REAL c[MAXCONSTR];                  /* combination coefficients */
; 92   :   REAL r[MAXCONSTR];                  /* constructed right side B */
; 93   :   REAL fval;                          /* value of constraint      */
; 94   :   REAL *bb;                           /* pointer to right side    */
; 95   :   MAT2D(a,MAXCONSTR,MAXCONSTR);       /* matrix for projection    */
; 96   :   
; 97   :   if ( concount > MAXCONSTR ) 
; 98   :   { sprintf(errmsg,
; 99   :      "Trying to project vertex %s on more constraints, %d, than allowed, %d.",
; 100  :      ELNAME(v_id),concount,MAXCONSTR);  

	mov	eax, DWORD PTR _v_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN35@constr_pro
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN36@constr_pro
$LN35@constr_pro:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN36@constr_pro:
	push	6
	push	ebx
	push	eax
	push	OFFSET ??_C@_0EH@MELMCFI@Trying?5to?5project?5vertex?5?$CFs?5on?5m@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 20					; 00000014H

; 101  :      if ( conlist )

	test	edi, edi
	je	$LN62@constr_pro

; 102  :      { sprintf(errmsg+strlen(errmsg),"    Projecting on constraints ");

	mov	eax, OFFSET _errmsg
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL58@constr_pro:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL58@constr_pro
	sub	eax, edx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BP@BMAGEEBM@?5?5?5?5Projecting?5on?5constraints?5?$AA@
	push	edx
	call	_sprintf
	add	esp, 8

; 103  :         for ( i = 0 ; i < concount ; i++ )

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN28@constr_pro
$LL30@constr_pro:

; 104  :         sprintf(errmsg+strlen(errmsg)," %s",get_constraint(conlist[i])->name);

	mov	eax, OFFSET _errmsg
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL59@constr_pro:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL59@constr_pro
	mov	ecx, DWORD PTR [edi+esi*4]
	and	ecx, 1073741823				; 3fffffffH
	imul	ecx, 176				; 000000b0H
	add	ecx, DWORD PTR _web+652
	sub	eax, edx
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_03EEBNCBOD@?5?$CFs?$AA@
	push	edx
	call	_sprintf
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, ebx
	jl	SHORT $LL30@constr_pro
$LN28@constr_pro:

; 105  :         strcat(errmsg,".  Maybe redundant one-sided constraints?");

	mov	edi, OFFSET _errmsg
	dec	edi
	npad	2
$LL60@constr_pro:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL60@constr_pro
	mov	ecx, 10					; 0000000aH
	mov	esi, OFFSET ??_C@_0CK@LBMCBKJ@?4?5?5Maybe?5redundant?5one?9sided?5con@
	rep movsd
	movsw
$LN62@constr_pro:

; 106  :      }
; 107  :      strcat(errmsg,"\n");

	mov	edi, OFFSET _errmsg
	dec	edi
	npad	4
$LL61@constr_pro:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL61@constr_pro
	mov	ax, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@

; 108  :      kb_error(1791,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1791					; 000006ffH
	mov	WORD PTR [edi], ax
	call	_kb_error
	mov	esi, DWORD PTR _combo$GSCopy$[ebp]
	add	esp, 12					; 0000000cH
$LN63@constr_pro:

; 109  :   }
; 110  : 
; 111  :   if ( concount <= 0 ) 

	test	ebx, ebx
	jg	SHORT $LN27@constr_pro

; 112  :   { for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	$LN4@constr_pro
	fldz
$LN26@constr_pro:

; 113  :        combo[j] = 0.0;     

	fst	QWORD PTR [esi+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN26@constr_pro

; 114  :     return concount;

	jmp	$LN84@constr_pro
$LN27@constr_pro:

; 115  :   }
; 116  : 
; 117  :   /* calculate gradients */
; 118  :   for ( i = 0 ; i < concount ; i++ )     

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN21@constr_pro
	lea	esi, DWORD PTR _grad$[ebp]
	npad	4
$LL23@constr_pro:

; 119  :       eval_all(constr[i]->formula,coord,SDIM,&fval,grad[i],v_id);

	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	eax, DWORD PTR _web+616
	push	ecx
	mov	ecx, DWORD PTR _coord$GSCopy$[ebp]
	push	esi
	lea	edx, DWORD PTR _fval$[ebp]
	push	edx
	mov	edx, DWORD PTR _constr$GSCopy$[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+edi*4]
	push	ecx
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_eval_all
	inc	edi
	add	esp, 24					; 00000018H
	add	esi, 48					; 00000030H
	cmp	edi, ebx
	jl	SHORT $LL23@constr_pro
$LN21@constr_pro:

; 120  : 
; 121  :   /* maybe construct right side for vector projection */
; 122  :   if ( mode == TANGPROJ )

	cmp	DWORD PTR _mode$[ebp], 2
	jne	SHORT $LN20@constr_pro

; 123  :   { for ( i = 0 ; i < concount ; i++ )

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN17@constr_pro
	lea	esi, DWORD PTR _grad$[ebp]
	npad	8
$LL19@constr_pro:

; 124  :       r[i] = SDIM_dot(b,grad[i]);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR _b$GSCopy$[ebp]
	push	edx
	push	esi
	push	eax
	call	_dot
	fstp	QWORD PTR _r$[ebp+edi*8]
	inc	edi
	add	esp, 12					; 0000000cH
	add	esi, 48					; 00000030H
	cmp	edi, ebx
	jl	SHORT $LL19@constr_pro
$LN17@constr_pro:

; 125  :     bb = r;

	lea	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR _bb$[ebp], ecx
	jmp	SHORT $LN16@constr_pro
$LN20@constr_pro:

; 126  :   }
; 127  :   else bb = b;

	mov	edx, DWORD PTR _b$GSCopy$[ebp]
	mov	DWORD PTR _bb$[ebp], edx
$LN16@constr_pro:

; 128  : 
; 129  :   /* construct matrix A */  
; 130  :   for ( i = 0 ; i < concount ; i++ )     

	test	ebx, ebx
	jle	$LN9@constr_pro
	mov	eax, DWORD PTR _a$[ebp]
	lea	ecx, DWORD PTR _grad$[ebp]
	mov	DWORD PTR tv736[ebp], eax
	mov	DWORD PTR tv738[ebp], ecx
	mov	DWORD PTR tv152[ebp], ebx
$LL64@constr_pro:

; 131  :      for ( j = 0 ; j < concount ; j++ )

	xor	edi, edi
	lea	esi, DWORD PTR _grad$[ebp]
	npad	8
$LL65@constr_pro:

; 132  :         a[i][j] = SDIM_dot(grad[i],grad[j]);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR tv738[ebp]
	push	edx
	push	esi
	push	eax
	call	_dot
	mov	ecx, DWORD PTR tv736[ebp]
	mov	edx, DWORD PTR [ecx]
	fstp	QWORD PTR [edx+edi*8]
	inc	edi
	add	esp, 12					; 0000000cH
	add	esi, 48					; 00000030H
	cmp	edi, ebx
	jl	SHORT $LL65@constr_pro

; 128  : 
; 129  :   /* construct matrix A */  
; 130  :   for ( i = 0 ; i < concount ; i++ )     

	add	DWORD PTR tv738[ebp], 48		; 00000030H
	add	DWORD PTR tv736[ebp], 4
	dec	DWORD PTR tv152[ebp]
	jne	SHORT $LL64@constr_pro

; 133  : 
; 134  : #define BBOLDWAY
; 135  : #ifdef OLDWAY
; 136  :   /* invert */
; 137  :   mat_inv(a,concount);
; 138  : 
; 139  :   /* combination coefficients */
; 140  :   matvec_mul(a,bb,c,concount>SDIM?SDIM:concount,concount>SDIM?SDIM:concount);
; 141  : #else
; 142  : 
; 143  :    for ( i = 0 ; i < concount ; i++ )

	test	ebx, ebx
	jle	SHORT $LN9@constr_pro
	mov	esi, DWORD PTR _bb$[ebp]
	mov	ecx, ebx
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	lea	edi, DWORD PTR _c$[ebp]
	rep movsd
$LN9@constr_pro:

; 144  :      c[i] = bb[i];
; 145  :    mat_approx_solve(a,concount,c);

	mov	ecx, DWORD PTR _a$[ebp]
	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	push	ebx
	push	ecx
	call	_mat_approx_solve

; 146  : #endif
; 147  : 
; 148  :   /* form combination */
; 149  :   for ( i = 0 ; i < SDIM ; i++ )

	xor	edi, edi
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+616, edi
	jle	$LN4@constr_pro
	mov	edx, DWORD PTR _combo$GSCopy$[ebp]
	fldz
	lea	ecx, DWORD PTR _grad$[ebp+48]
	sub	ecx, edx
	mov	DWORD PTR tv1401[ebp], ecx
	jmp	SHORT $LN6@constr_pro
$LN66@constr_pro:
	mov	ecx, DWORD PTR tv1401[ebp]
$LN6@constr_pro:

; 151  :     for ( j = 0 ; j < concount ; j++ )

	xor	eax, eax
	fst	QWORD PTR [edx]
	cmp	ebx, 4
	jl	SHORT $LC56@constr_pro

; 150  :   { combo[i] = 0.0;

	fld	QWORD PTR [edx]
	lea	esi, DWORD PTR [ebx-3]
	add	ecx, edx

; 151  :     for ( j = 0 ; j < concount ; j++ )

$LN57@constr_pro:

; 152  :       combo[i] += c[j]*grad[j][i];

	fld	QWORD PTR _c$[ebp+eax*8]
	add	eax, 4
	fmul	QWORD PTR [ecx-48]
	add	ecx, 192				; 000000c0H
	faddp	ST(1), ST(0)
	fld	QWORD PTR _c$[ebp+eax*8-24]
	fmul	QWORD PTR [ecx-192]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _c$[ebp+eax*8-16]
	fmul	QWORD PTR [ecx-144]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _c$[ebp+eax*8-8]
	fmul	QWORD PTR [ecx-96]
	faddp	ST(1), ST(0)
	cmp	eax, esi
	jl	SHORT $LN57@constr_pro
	fstp	QWORD PTR [edx]
$LC56@constr_pro:

; 151  :     for ( j = 0 ; j < concount ; j++ )

	cmp	eax, ebx
	jge	SHORT $LN5@constr_pro
	fld	QWORD PTR [edx]
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [edi+ecx*2]
	lea	ecx, DWORD PTR _grad$[ebp+ecx*8]
$LC3@constr_pro:

; 152  :       combo[i] += c[j]*grad[j][i];

	fld	QWORD PTR _c$[ebp+eax*8]
	inc	eax
	fmul	QWORD PTR [ecx]
	add	ecx, 48					; 00000030H
	faddp	ST(1), ST(0)
	cmp	eax, ebx
	jl	SHORT $LC3@constr_pro
	fstp	QWORD PTR [edx]
$LN5@constr_pro:

; 146  : #endif
; 147  : 
; 148  :   /* form combination */
; 149  :   for ( i = 0 ; i < SDIM ; i++ )

	inc	edi
	add	edx, 8
	cmp	edi, DWORD PTR _web+616
	jl	SHORT $LN66@constr_pro
$LN84@constr_pro:
	fstp	ST(0)
$LN4@constr_pro:

; 153  :   }
; 154  :   
; 155  :   return concount;
; 156  : 
; 157  : } /* end constr_proj() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	mov	eax, ebx
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_constr_proj ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@bff0000000000000
PUBLIC	??_C@_0DJ@GJDHBMNF@Vertex?5?$CFs?5has?5more?5constraints?5t@ ; `string'
PUBLIC	_mat$GSCopy$
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_constr_proj_matrix
EXTRN	_tr_mat_mul:PROC
EXTRN	_gram_schmidt:PROC
EXTRN	_nullcon:QWORD
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT ??_C@_0DJ@GJDHBMNF@Vertex?5?$CFs?5has?5more?5constraints?5t@
CONST	SEGMENT
??_C@_0DJ@GJDHBMNF@Vertex?5?$CFs?5has?5more?5constraints?5t@ DB 'Vertex %'
	DB	's has more constraints than space dimension, %d.', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _constr_proj_matrix
_TEXT	SEGMENT
_gradqXvS$ = -368					; size = 24
_fval$ = -344						; size = 8
_constr$ = -336						; size = 24
_v_id$GSCopy$ = -312					; size = 4
_grad$ = -308						; size = 4
_j$ = -304						; size = 4
_mat$GSCopy$ = -300					; size = 4
_conmap$ = -296						; size = 4
_concount$ = -296					; size = 4
_gradxJ$ = -292						; size = 288
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_mat$ = 12						; size = 4
_constr_proj_matrix PROC				; COMDAT

; 178  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 223  :     }
; 224  :   }
; 225  :   /* else identity */
; 226  :   else
; 227  :   { for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _mat$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _v_id$[ebp]
	push	edi
	push	6
	push	6
	lea	ecx, DWORD PTR _gradxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _gradqXvS$[ebp]
	push	edx
	mov	DWORD PTR _v_id$GSCopy$[ebp], esi
	mov	DWORD PTR _mat$GSCopy$[ebp], eax
	call	_mat2d_setup
	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR _grad$[ebp], eax
	mov	eax, DWORD PTR _web+104
	xor	ebx, ebx
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [eax+ecx+1288], ebx
	je	SHORT $LN29@constr_pro@2

; 179  : /* maximum number of hit constraints */
; 180  : #define MAXCONSTR MAXCOORD
; 181  :   int i,j;
; 182  :   MAT2D(grad,MAXCONSTR,MAXCOORD);     /* gradients of constraints */
; 183  :   REAL fval;                          /* value of constraint */
; 184  :   int concount=0;
; 185  :   conmap_t * conmap = get_v_constraint_map(v_id);

	mov	edi, DWORD PTR _web+12
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+edx*4]
	add	edi, DWORD PTR [eax+ecx+1264]
	mov	DWORD PTR _conmap$[ebp], edi
	jmp	SHORT $LN30@constr_pro@2
$LN29@constr_pro@2:
	mov	DWORD PTR _conmap$[ebp], OFFSET _nullcon
	mov	edi, DWORD PTR _conmap$[ebp]
$LN30@constr_pro@2:

; 186  :   struct constraint *constr[MAXCONSTR];
; 187  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _web+616
	mov	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	cmp	DWORD PTR [edi], ecx
	jl	$LN17@constr_pro@2
	npad	10
$LL26@constr_pro@2:

; 188  :    if ( conmap[j] & CON_HIT_BIT )

	test	DWORD PTR [edi+ecx*4], -2147483648	; 80000000H
	je	$LN25@constr_pro@2

; 189  :    { 
; 190  :      if ( concount >= web.sdim ) 

	cmp	ebx, eax
	jl	$LN22@constr_pro@2

; 191  :      { sprintf(errmsg,
; 192  :        "Vertex %s has more constraints than space dimension, %d.",
; 193  :           ELNAME(v_id),SDIM);  

	test	esi, 268435456				; 10000000H
	je	SHORT $LN31@constr_pro@2
	and	esi, 134217727				; 07ffffffH
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	eax, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	mov	ecx, OFFSET _elnames
	jmp	SHORT $LN32@constr_pro@2
$LN31@constr_pro@2:
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN32@constr_pro@2:
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DJ@GJDHBMNF@Vertex?5?$CFs?5has?5more?5constraints?5t@
	push	OFFSET _errmsg
	call	_sprintf

; 194  :  
; 195  :        sprintf(errmsg+strlen(errmsg),"    Projecting on constraints ");

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL49@constr_pro@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL49@constr_pro@2
	sub	eax, edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BP@BMAGEEBM@?5?5?5?5Projecting?5on?5constraints?5?$AA@
	push	eax
	call	_sprintf
	add	esp, 8

; 196  :        for ( i = 0 ; i < concount ; i++ )

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN19@constr_pro@2
	lea	ecx, DWORD PTR _constr$[ebp]
	sub	edi, ecx
	npad	1
$LL21@constr_pro@2:
	lea	edx, DWORD PTR [edi+esi*4]

; 197  :         if ( conmap[i] & CON_HIT_BIT )

	test	DWORD PTR _constr$[ebp+edx], -2147483648 ; 80000000H
	je	SHORT $LN20@constr_pro@2

; 198  :           sprintf(errmsg+strlen(errmsg)," %s",constr[i]->name);

	mov	eax, OFFSET _errmsg
	lea	edx, DWORD PTR [eax+1]
$LL50@constr_pro@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL50@constr_pro@2
	mov	ecx, DWORD PTR _constr$[ebp+esi*4]
	push	ecx
	sub	eax, edx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_03EEBNCBOD@?5?$CFs?$AA@
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN20@constr_pro@2:

; 196  :        for ( i = 0 ; i < concount ; i++ )

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL21@constr_pro@2
$LN19@constr_pro@2:

; 199  :        strcat(errmsg,".  Maybe redundant one-sided constraints?");

	mov	edi, OFFSET _errmsg
	dec	edi
$LL51@constr_pro@2:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL51@constr_pro@2
	mov	ecx, 10					; 0000000aH
	mov	esi, OFFSET ??_C@_0CK@LBMCBKJ@?4?5?5Maybe?5redundant?5one?9sided?5con@
	rep movsd
	movsw

; 200  :      
; 201  :        strcat(errmsg,"\n");

	mov	edi, OFFSET _errmsg
	dec	edi
$LL52@constr_pro@2:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL52@constr_pro@2
	mov	ax, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@

; 202  :        kb_error(3515,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3515					; 00000dbbH
	mov	WORD PTR [edi], ax
	call	_kb_error
	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edi, DWORD PTR _conmap$[ebp]
	mov	esi, DWORD PTR _v_id$GSCopy$[ebp]
	add	esp, 12					; 0000000cH
$LN22@constr_pro@2:

; 203  :      }
; 204  :      constr[concount++] = get_constraint(conmap[j]);

	mov	edx, DWORD PTR [edi+ecx*4]
	and	edx, 1073741823				; 3fffffffH
	imul	edx, 176				; 000000b0H
	add	edx, DWORD PTR _web+652
	inc	ebx
	mov	DWORD PTR _constr$[ebp+ebx*4-4], edx
$LN25@constr_pro@2:

; 186  :   struct constraint *constr[MAXCONSTR];
; 187  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR [edi]
	jle	$LL26@constr_pro@2

; 203  :      }
; 204  :      constr[concount++] = get_constraint(conmap[j]);

	mov	DWORD PTR _concount$[ebp], ebx

; 205  :    }
; 206  : 
; 207  :   if ( concount > 0 )

	test	ebx, ebx
	jle	$LN17@constr_pro@2

; 208  :   { REAL *coord = get_coord(v_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR _dymem
	and	esi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _web+104
	add	edi, DWORD PTR [ecx+edx+64]

; 209  :   
; 210  :     /* calculate gradients */
; 211  :     for ( i = 0 ; i < concount ; i++ )     

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN14@constr_pro@2
	mov	ebx, DWORD PTR _grad$[ebp]
	lea	edx, DWORD PTR _constr$[ebp]
	sub	ebx, edx
	npad	3
$LL55@constr_pro@2:

; 212  :       eval_all(constr[i]->formula,coord,SDIM,&fval,grad[i],v_id);

	mov	ecx, DWORD PTR _v_id$GSCopy$[ebp]
	push	ecx
	lea	edx, DWORD PTR [ebx+esi*4]
	mov	ecx, DWORD PTR _constr$[ebp+edx]
	push	ecx
	lea	edx, DWORD PTR _fval$[ebp]
	push	edx
	push	eax
	mov	eax, DWORD PTR _constr$[ebp+esi*4]
	mov	ecx, DWORD PTR [eax+40]
	push	edi
	push	ecx
	call	_eval_all
	mov	eax, DWORD PTR _web+616
	inc	esi
	add	esp, 24					; 00000018H
	cmp	esi, DWORD PTR _concount$[ebp]
	jl	SHORT $LL55@constr_pro@2

; 209  :   
; 210  :     /* calculate gradients */
; 211  :     for ( i = 0 ; i < concount ; i++ )     

	mov	ebx, DWORD PTR _concount$[ebp]
$LN14@constr_pro@2:

; 213  :   
; 214  :     /* orthonormalize */
; 215  :     concount = gram_schmidt(grad,concount,SDIM);

	mov	edi, DWORD PTR _grad$[ebp]
	push	eax
	push	ebx
	push	edi
	call	_gram_schmidt

; 216  : 
; 217  :     /* form projection matrix */
; 218  :     tr_mat_mul(grad,grad,mat,concount,SDIM,SDIM);

	mov	ebx, DWORD PTR _mat$GSCopy$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	push	esi
	push	ebx
	push	edi
	push	edi
	call	_tr_mat_mul

; 219  :     for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 36					; 00000024H
	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN54@constr_pro@2
	fld	QWORD PTR __real@bff0000000000000
	fld1
$LN13@constr_pro@2:

; 220  :     { for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN8@constr_pro@2

; 219  :     for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR [ebx+ecx*4]
$LN10@constr_pro@2:

; 221  :         mat[i][j] *= -1;

	fld	QWORD PTR [eax]
	inc	edx
	fmul	ST(0), ST(2)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LN10@constr_pro@2
$LN8@constr_pro@2:

; 219  :     for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR [ebx+ecx*4]

; 222  :       mat[i][i] += 1.0;

	fld	QWORD PTR [edx+ecx*8]
	lea	eax, DWORD PTR [edx+ecx*8]
	fadd	ST(0), ST(1)
	inc	ecx
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR _web+616
	cmp	ecx, eax
	jl	SHORT $LN13@constr_pro@2

; 219  :     for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(1)
	fstp	ST(0)
$LN54@constr_pro@2:

; 230  :   }
; 231  : 
; 232  :   return concount;

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 233  : } /* end constr_proj_matrix */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@constr_pro@2:

; 223  :     }
; 224  :   }
; 225  :   /* else identity */
; 226  :   else
; 227  :   { for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN53@constr_pro@2
	fld1
	fldz
$LN57@constr_pro@2:

; 228  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN5@constr_pro@2

; 223  :     }
; 224  :   }
; 225  :   /* else identity */
; 226  :   else
; 227  :   { for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _mat$GSCopy$[ebp]
	mov	edx, DWORD PTR [eax+esi*4]
$LN3@constr_pro@2:

; 229  :         mat[i][j] = (i==j) ? 1.0 : 0.0;

	cmp	esi, ecx
	jne	SHORT $LN33@constr_pro@2
	fld	ST(1)
	jmp	SHORT $LN34@constr_pro@2
$LN33@constr_pro@2:
	fld	ST(0)
$LN34@constr_pro@2:
	fstp	QWORD PTR [edx]
	mov	eax, DWORD PTR _web+616
	inc	ecx
	add	edx, 8
	cmp	ecx, eax
	jl	SHORT $LN3@constr_pro@2
$LN5@constr_pro@2:

; 223  :     }
; 224  :   }
; 225  :   /* else identity */
; 226  :   else
; 227  :   { for ( i = 0 ; i < SDIM ; i++ )

	inc	esi
	cmp	esi, eax
	jl	SHORT $LN57@constr_pro@2
	fstp	ST(1)
	fstp	ST(0)
$LN53@constr_pro@2:

; 233  : } /* end constr_proj_matrix */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	mov	eax, ebx
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_constr_proj_matrix ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DP@HMNGLHAE@Vertex?5?$CFs?5has?5more?5constraints?0?5@ ; `string'
PUBLIC	_mat$GSCopy$
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_constr_proj_matrix_wall
;	COMDAT ??_C@_0DP@HMNGLHAE@Vertex?5?$CFs?5has?5more?5constraints?0?5@
CONST	SEGMENT
??_C@_0DP@HMNGLHAE@Vertex?5?$CFs?5has?5more?5constraints?0?5@ DB 'Vertex '
	DB	'%s has more constraints, %d, than space dimensions, %d.', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _constr_proj_matrix_wall
_TEXT	SEGMENT
_gradqXvS$ = -368					; size = 24
_fval$ = -344						; size = 8
_constr$ = -336						; size = 24
$T90612 = -312						; size = 4
_mat$GSCopy$ = -308					; size = 4
_v_id$GSCopy$ = -304					; size = 4
_grad$ = -300						; size = 4
_concount$ = -296					; size = 4
_gradxJ$ = -292						; size = 288
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_mat$ = 12						; size = 4
_constr_proj_matrix_wall PROC				; COMDAT

; 254  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 301  :     }
; 302  :   }
; 303  :   /* else identity */
; 304  :   else
; 305  :   { for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _mat$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _v_id$[ebp]
	push	esi
	push	edi
	push	6
	push	6
	lea	ecx, DWORD PTR _gradxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _gradqXvS$[ebp]
	push	edx
	mov	DWORD PTR _v_id$GSCopy$[ebp], ebx
	mov	DWORD PTR _mat$GSCopy$[ebp], eax
	call	_mat2d_setup
	mov	ecx, DWORD PTR _web+104
	mov	DWORD PTR _grad$[ebp], eax
	mov	eax, DWORD PTR _dymem
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [ecx+eax+1288], 0
	mov	DWORD PTR _concount$[ebp], 0
	je	SHORT $LN29@constr_pro@3

; 255  : /* maximum number of hit constraints */
; 256  : #define MAXCONSTR MAXCOORD
; 257  :   int i,j;
; 258  :   MAT2D(grad,MAXCONSTR,MAXCOORD);     /* gradients of constraints */
; 259  :   REAL fval;                                 /* value of constraint */
; 260  :   int concount=0;
; 261  :   conmap_t * conmap = get_v_constraint_map(v_id);

	mov	esi, DWORD PTR _web+12
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+edx*4]
	add	esi, DWORD PTR [ecx+eax+1264]
	jmp	SHORT $LN30@constr_pro@3
$LN29@constr_pro@3:
	mov	esi, OFFSET _nullcon
$LN30@constr_pro@3:
	mov	eax, DWORD PTR [esi]

; 262  :   struct constraint *constr[MAXCONSTR];
; 263  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	edi, 1
	mov	DWORD PTR $T90612[ebp], eax
	cmp	eax, edi
	jl	SHORT $LN24@constr_pro@3
	mov	ebx, DWORD PTR _web+652
	npad	3
$LL26@constr_pro@3:

; 264  :    if ( conmap[j] & CON_HIT_BIT )

	mov	eax, DWORD PTR [esi+edi*4]
	test	eax, eax
	jns	SHORT $LN25@constr_pro@3

; 265  :    { struct constraint *con = get_constraint(conmap[j]);

	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H

; 266  :      if ( !(con->attr & NONWALL) )

	mov	ecx, DWORD PTR [eax+ebx+32]
	add	eax, ebx
	and	ecx, 1024				; 00000400H
	xor	edx, edx
	or	ecx, edx
	jne	SHORT $LN25@constr_pro@3

; 267  :        constr[concount++] = con;

	mov	ecx, DWORD PTR _concount$[ebp]
	mov	DWORD PTR _constr$[ebp+ecx*4], eax
	inc	ecx
	mov	DWORD PTR _concount$[ebp], ecx
$LN25@constr_pro@3:

; 262  :   struct constraint *constr[MAXCONSTR];
; 263  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	inc	edi
	cmp	edi, DWORD PTR $T90612[ebp]
	jle	SHORT $LL26@constr_pro@3
	mov	ebx, DWORD PTR _v_id$GSCopy$[ebp]
$LN24@constr_pro@3:

; 268  :    }
; 269  : 
; 270  :   if ( concount > SDIM ) 

	mov	eax, DWORD PTR _web+616
	cmp	DWORD PTR _concount$[ebp], eax
	jle	$LN21@constr_pro@3

; 271  :   { sprintf(errmsg,
; 272  :      "Vertex %s has more constraints, %d, than space dimensions, %d.",
; 273  :         ELNAME(v_id),concount,SDIM);  

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN31@constr_pro@3
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	mov	eax, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	mov	ecx, OFFSET _elnames
	jmp	SHORT $LN32@constr_pro@3
$LN31@constr_pro@3:
	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN32@constr_pro@3:
	mov	edx, DWORD PTR _concount$[ebp]
	push	eax
	push	edx
	push	ecx
	push	OFFSET ??_C@_0DP@HMNGLHAE@Vertex?5?$CFs?5has?5more?5constraints?0?5@
	push	OFFSET _errmsg
	call	_sprintf

; 274  :  
; 275  :      sprintf(errmsg+strlen(errmsg),"    Projecting on constraints ");

	mov	eax, OFFSET _errmsg
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL49@constr_pro@3:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL49@constr_pro@3
	sub	eax, edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BP@BMAGEEBM@?5?5?5?5Projecting?5on?5constraints?5?$AA@
	push	eax
	call	_sprintf

; 276  :      for ( i = 0 ; i < concount ; i++ )

	mov	edi, DWORD PTR _concount$[ebp]
	add	esp, 8
	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN18@constr_pro@3
	npad	7
$LL20@constr_pro@3:

; 277  :         sprintf(errmsg+strlen(errmsg)," %s",constr[i]->name);

	mov	eax, OFFSET _errmsg
	lea	edx, DWORD PTR [eax+1]
$LL50@constr_pro@3:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL50@constr_pro@3
	mov	ecx, DWORD PTR _constr$[ebp+esi*4]
	push	ecx
	sub	eax, edx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_03EEBNCBOD@?5?$CFs?$AA@
	push	edx
	call	_sprintf
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, edi
	jl	SHORT $LL20@constr_pro@3
$LN18@constr_pro@3:

; 278  :      strcat(errmsg,".  Maybe redundant one-sided constraints?");

	mov	edi, OFFSET _errmsg
	dec	edi
$LL51@constr_pro@3:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL51@constr_pro@3
	mov	ecx, 10					; 0000000aH
	mov	esi, OFFSET ??_C@_0CK@LBMCBKJ@?4?5?5Maybe?5redundant?5one?9sided?5con@
	rep movsd
	movsw

; 279  :      
; 280  :      strcat(errmsg,"\n");

	mov	edi, OFFSET _errmsg
	dec	edi
$LL52@constr_pro@3:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL52@constr_pro@3
	mov	ax, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@

; 281  :      kb_error(3028,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3028					; 00000bd4H
	mov	WORD PTR [edi], ax
	call	_kb_error
	mov	eax, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
$LN21@constr_pro@3:

; 282  :   }
; 283  : 
; 284  :   if ( concount > 0 )

	mov	ecx, DWORD PTR _concount$[ebp]
	test	ecx, ecx
	jle	$LN17@constr_pro@3

; 285  :   { REAL *coord = get_coord(v_id);

	mov	edx, DWORD PTR _web+12
	mov	esi, DWORD PTR _dymem
	and	ebx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR _web+104
	add	edi, DWORD PTR [edx+esi+64]

; 286  :   
; 287  :     /* calculate gradients */
; 288  :     for ( i = 0 ; i < concount ; i++ )     

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN14@constr_pro@3
	mov	ebx, DWORD PTR _grad$[ebp]
	lea	ecx, DWORD PTR _constr$[ebp]
	sub	ebx, ecx
	npad	1
$LL55@constr_pro@3:

; 289  :       eval_all(constr[i]->formula,coord,SDIM,&fval,grad[i],v_id);

	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
	push	edx
	lea	ecx, DWORD PTR [ebx+esi*4]
	mov	edx, DWORD PTR _constr$[ebp+ecx]
	push	edx
	mov	edx, DWORD PTR _constr$[ebp+esi*4]
	lea	ecx, DWORD PTR _fval$[ebp]
	push	ecx
	push	eax
	mov	eax, DWORD PTR [edx+40]
	push	edi
	push	eax
	call	_eval_all
	mov	eax, DWORD PTR _web+616
	inc	esi
	add	esp, 24					; 00000018H
	cmp	esi, DWORD PTR _concount$[ebp]
	jl	SHORT $LL55@constr_pro@3
$LN14@constr_pro@3:

; 290  :   
; 291  :     /* orthonormalize */
; 292  :     concount = gram_schmidt(grad,concount,SDIM);

	mov	ecx, DWORD PTR _concount$[ebp]
	mov	edx, DWORD PTR _grad$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_gram_schmidt

; 293  : 
; 294  :     /* form projection matrix */
; 295  :     tr_mat_mul(grad,grad,mat,concount,SDIM,SDIM);

	mov	edi, DWORD PTR _mat$GSCopy$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR _web+616
	push	eax
	push	eax
	mov	eax, DWORD PTR _grad$[ebp]
	push	esi
	push	edi
	push	eax
	push	eax
	call	_tr_mat_mul

; 296  : 
; 297  :     for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 36					; 00000024H
	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN54@constr_pro@3
	fld	QWORD PTR __real@bff0000000000000
	fld1
$LN13@constr_pro@3:

; 298  :     { for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN8@constr_pro@3

; 296  : 
; 297  :     for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR [edi+ecx*4]
$LN10@constr_pro@3:

; 299  :         mat[i][j] *= -1;

	fld	QWORD PTR [eax]
	inc	edx
	fmul	ST(0), ST(2)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LN10@constr_pro@3
$LN8@constr_pro@3:

; 296  : 
; 297  :     for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR [edi+ecx*4]

; 300  :       mat[i][i] += 1.0;

	fld	QWORD PTR [eax+ecx*8]
	lea	eax, DWORD PTR [eax+ecx*8]
	fadd	ST(0), ST(1)
	inc	ecx
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR _web+616
	cmp	ecx, eax
	jl	SHORT $LN13@constr_pro@3

; 296  : 
; 297  :     for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(1)
	fstp	ST(0)
$LN54@constr_pro@3:

; 308  :   }
; 309  : 
; 310  :   return concount;

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 311  : } /* end constr_proj_matrix */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@constr_pro@3:

; 301  :     }
; 302  :   }
; 303  :   /* else identity */
; 304  :   else
; 305  :   { for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN53@constr_pro@3
	fld1
	fldz
$LN57@constr_pro@3:

; 306  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN5@constr_pro@3

; 301  :     }
; 302  :   }
; 303  :   /* else identity */
; 304  :   else
; 305  :   { for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _mat$GSCopy$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
$LN3@constr_pro@3:

; 307  :         mat[i][j] = (i==j) ? 1.0 : 0.0;

	cmp	esi, ecx
	jne	SHORT $LN33@constr_pro@3
	fld	ST(1)
	jmp	SHORT $LN34@constr_pro@3
$LN33@constr_pro@3:
	fld	ST(0)
$LN34@constr_pro@3:
	fstp	QWORD PTR [edx]
	mov	eax, DWORD PTR _web+616
	inc	ecx
	add	edx, 8
	cmp	ecx, eax
	jl	SHORT $LN3@constr_pro@3
$LN5@constr_pro@3:

; 301  :     }
; 302  :   }
; 303  :   /* else identity */
; 304  :   else
; 305  :   { for ( i = 0 ; i < SDIM ; i++ )

	inc	esi
	cmp	esi, eax
	jl	SHORT $LN57@constr_pro@3

; 308  :   }
; 309  : 
; 310  :   return concount;

	mov	eax, DWORD PTR _concount$[ebp]
	fstp	ST(1)
	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx

; 311  : } /* end constr_proj_matrix */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@constr_pro@3:

; 308  :   }
; 309  : 
; 310  :   return concount;

	mov	eax, ecx

; 311  : } /* end constr_proj_matrix */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_constr_proj_matrix_wall ENDP
_TEXT	ENDS
PUBLIC	??_C@_0GK@OFOCPBMB@Vertex?5?$CFs?5doesn?8t?5converge?5to?5co@ ; `string'
PUBLIC	??_C@_0DK@NBHPKLFK@Vertex?5?$CFs?5hits?5more?5constraints?5@ ; `string'
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_project_v_constr
EXTRN	_msg:DWORD
EXTRN	_set_v_constraint_status:PROC
EXTRN	_eval:PROC
EXTRN	_clear_v_constraint_status:PROC
;	COMDAT ??_C@_0GK@OFOCPBMB@Vertex?5?$CFs?5doesn?8t?5converge?5to?5co@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0GK@OFOCPBMB@Vertex?5?$CFs?5doesn?8t?5converge?5to?5co@ DB 'Vertex '
	DB	'%s doesn''t converge to constraint %s after %d iterations. ', 0aH
	DB	' maxdiff = %g, constraint_tolerance %g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@NBHPKLFK@Vertex?5?$CFs?5hits?5more?5constraints?5@
CONST	SEGMENT
??_C@_0DK@NBHPKLFK@Vertex?5?$CFs?5hits?5more?5constraints?5@ DB 'Vertex %'
	DB	's hits more constraints than dimension of space.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\cnstrnt.c
CONST	ENDS
;	COMDAT _project_v_constr
_TEXT	SEGMENT
_con$ = -200						; size = 28
tv450 = -172						; size = 8
_diff$ = -164						; size = 8
_maxdiff$ = -156					; size = 8
_totaldiff$ = -148					; size = 8
_dcon$ = -140						; size = 4
_itercount$ = -136					; size = 4
_walls$ = -132						; size = 4
_x$ = -128						; size = 4
_oncount$ = -124					; size = 4
_new_hits$ = -120					; size = 4
_v_id$GSCopy$ = -116					; size = 4
tv417 = -112						; size = 4
_f$ = -108						; size = 56
_delta$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_mode$ = 12						; size = 4
_one_sided_reset$ = 16					; size = 4
_project_v_constr PROC					; COMDAT

; 327  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _v_id$[ebp]

; 328  :   REAL *x;
; 329  :   conmap_t *conmap;
; 330  :   struct constraint *con[MAXCONHIT],*thiscon;
; 331  :   int oncount = 0;
; 332  :   REAL f[MAXCONHIT],delta[MAXCOORD];
; 333  :   int j,itercount = 0;

	xor	ebx, ebx

; 334  :   REAL diff,totaldiff;
; 335  :   int walls = 0;  /* total number of constraints vertex is on */
; 336  :   REAL maxdiff;
; 337  :   int dcon=0; /* which constraint has largest difference */
; 338  :   /*int hit_one_side;*/ /* if hits a one-sided constraint */
; 339  :   int new_hits = 0; /* total new hits */
; 340  : 
; 341  :   if ( one_sided_reset == RESET_ONESIDEDNESS )

	cmp	DWORD PTR _one_sided_reset$[ebp], 1
	push	edi
	mov	DWORD PTR _v_id$GSCopy$[ebp], esi
	mov	DWORD PTR _itercount$[ebp], ebx
	mov	DWORD PTR _dcon$[ebp], ebx
	jne	SHORT $LN22@project_v_

; 342  :     clear_v_constraint_status(v_id);  // moved from inside loop, so 1-sided con is sticky

	push	esi
	call	_clear_v_constraint_status
	add	esp, 4
$LN22@project_v_:

; 343  :  
; 344  :   x = get_coord(v_id);

	mov	edi, DWORD PTR _web+12
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	DWORD PTR tv417[ebp], edx
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR [eax+ecx+64]
	add	edi, edx
	mov	DWORD PTR _x$[ebp], edi

; 345  :   conmap = get_v_constraint_map(v_id);

	cmp	DWORD PTR [eax+ecx+1288], ebx
	je	SHORT $LN25@project_v_
	mov	ebx, DWORD PTR [eax+ecx+1264]
	add	ebx, edx
	jmp	SHORT $LN50@project_v_
$LN25@project_v_:
	mov	ebx, OFFSET _nullcon
$LN50@project_v_:
	fldz

; 346  :   do
; 347  :   {
; 348  :     walls = 0; 

	xor	eax, eax

; 349  :     /*hit_one_side = 0; */
; 350  :     new_hits = 0;
; 351  :     totaldiff = maxdiff = 0.0;
; 352  : 
; 353  :     for ( j = 1, oncount = 0 ; j <= (int)conmap[0] ; j++ )

	mov	edi, 1
	fst	QWORD PTR _maxdiff$[ebp]
	fstp	QWORD PTR _totaldiff$[ebp]
	mov	DWORD PTR _walls$[ebp], eax
	mov	DWORD PTR _new_hits$[ebp], eax
	mov	DWORD PTR _oncount$[ebp], eax
	cmp	DWORD PTR [ebx], edi
	jl	$LN53@project_v_
$LL56@project_v_:

; 354  :     {
; 355  :       thiscon = get_constraint(conmap[j]);

	mov	esi, DWORD PTR [ebx+edi*4]

; 356  :       diff = eval(thiscon->formula,x,v_id,NULL);

	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	and	esi, 1073741823				; 3fffffffH
	imul	esi, 176				; 000000b0H
	add	esi, DWORD PTR _web+652
	push	0
	mov	edx, DWORD PTR [esi+40]
	push	eax
	push	ecx
	push	edx
	call	_eval

; 357  :       if ( ((thiscon->attr & NONNEGATIVE) && !(conmap[j] & CON_HIT_BIT) && 
; 358  :                ( diff > web.tolerance ))
; 359  :        || ((thiscon->attr & NONPOSITIVE) && !(conmap[j] & CON_HIT_BIT) && 
; 360  :                ( diff < -web.tolerance )) )

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+32]
	fst	QWORD PTR _diff$[ebp]
	fld	QWORD PTR _web+752
	mov	DWORD PTR tv450[ebp+4], eax
	mov	eax, ecx
	and	eax, 2
	xor	edx, edx
	add	esp, 16					; 00000010H
	or	eax, edx
	je	SHORT $LN57@project_v_
	test	DWORD PTR [ebx+edi*4], -2147483648	; 80000000H
	jne	SHORT $LN57@project_v_
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	$LN67@project_v_
$LN57@project_v_:
	and	ecx, 1
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN72@project_v_
	test	DWORD PTR [ebx+edi*4], -2147483648	; 80000000H
	jne	SHORT $LN72@project_v_
	fchs
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H

; 361  :       {
; 362  :         continue;

	je	$LN74@project_v_
	jmp	SHORT $LN15@project_v_
$LN72@project_v_:

; 357  :       if ( ((thiscon->attr & NONNEGATIVE) && !(conmap[j] & CON_HIT_BIT) && 
; 358  :                ( diff > web.tolerance ))
; 359  :        || ((thiscon->attr & NONPOSITIVE) && !(conmap[j] & CON_HIT_BIT) && 
; 360  :                ( diff < -web.tolerance )) )

	fstp	ST(0)
$LN15@project_v_:

; 363  :       }
; 364  :       if ( oncount >= web.sdim )

	mov	edx, DWORD PTR _oncount$[ebp]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LN12@project_v_

; 365  :       { sprintf(errmsg,"Vertex %s hits more constraints than dimension of space.\n",
; 366  :             ELNAME(v_id));

	test	DWORD PTR _v_id$GSCopy$[ebp], 268435456	; 10000000H
	fstp	ST(0)
	je	SHORT $LN27@project_v_
	mov	ecx, DWORD PTR tv417[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN28@project_v_
$LN27@project_v_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN28@project_v_:
	push	eax
	push	OFFSET ??_C@_0DK@NBHPKLFK@Vertex?5?$CFs?5hits?5more?5constraints?5@
	push	OFFSET _errmsg
	call	_sprintf

; 367  :         kb_error(5883,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5883					; 000016fbH
	call	_kb_error
	fld	QWORD PTR _diff$[ebp]
	mov	edx, DWORD PTR _oncount$[ebp]
	add	esp, 24					; 00000018H
$LN12@project_v_:

; 368  :       }
; 369  :       if ( thiscon->attr & (NONNEGATIVE|NONPOSITIVE) )

	mov	eax, DWORD PTR [esi+32]
	and	eax, 3
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN58@project_v_

; 370  :       { /* hit_one_side = 1; */
; 371  :         if ( !(conmap[j] & CON_HIT_BIT) ) new_hits++;

	test	DWORD PTR [ebx+edi*4], -2147483648	; 80000000H
	jne	SHORT $LN10@project_v_
	inc	DWORD PTR _new_hits$[ebp]
$LN10@project_v_:

; 372  :         set_attr(v_id,HIT_ONE_SIDED);

	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR tv417[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [eax+12]
	or	DWORD PTR [eax+8], 1048576		; 00100000H
	mov	DWORD PTR [eax+12], ecx
$LN58@project_v_:

; 373  :       }
; 374  :       f[oncount] = -diff;

	fld	ST(0)

; 375  :       con[oncount++] = thiscon;

	mov	DWORD PTR _con$[ebp+edx*4], esi
	fchs
	inc	edx
	fstp	QWORD PTR _f$[ebp+edx*8-8]
	mov	DWORD PTR _oncount$[ebp], edx

; 376  :       if ( fabs(diff) > maxdiff ) 

	fabs
	fld	QWORD PTR _maxdiff$[ebp]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN9@project_v_

; 377  :       { maxdiff = fabs(diff); dcon = conmap[j]&CONMASK; }

	mov	eax, DWORD PTR [ebx+edi*4]
	fst	QWORD PTR _maxdiff$[ebp]
	and	eax, 1073741823				; 3fffffffH
	mov	DWORD PTR _dcon$[ebp], eax
$LN9@project_v_:

; 378  :       totaldiff += fabs(diff);
; 379  :       if ( one_sided_reset == RESET_ONESIDEDNESS )

	cmp	DWORD PTR _one_sided_reset$[ebp], 1
	fadd	QWORD PTR _totaldiff$[ebp]
	fstp	QWORD PTR _totaldiff$[ebp]
	jne	SHORT $LN8@project_v_

; 380  :           set_v_constraint_status(v_id,conmap[j]);

	mov	edx, DWORD PTR [ebx+edi*4]
	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	edx
	push	eax
	call	_set_v_constraint_status
	add	esp, 8
$LN8@project_v_:

; 381  :       walls++;

	inc	DWORD PTR _walls$[ebp]
	jmp	SHORT $LN17@project_v_
$LN67@project_v_:
	fstp	ST(1)
$LN74@project_v_:

; 361  :       {
; 362  :         continue;

	fstp	ST(0)
$LN17@project_v_:

; 349  :     /*hit_one_side = 0; */
; 350  :     new_hits = 0;
; 351  :     totaldiff = maxdiff = 0.0;
; 352  : 
; 353  :     for ( j = 1, oncount = 0 ; j <= (int)conmap[0] ; j++ )

	inc	edi
	cmp	edi, DWORD PTR [ebx]
	jle	$LL56@project_v_
	mov	esi, DWORD PTR _v_id$GSCopy$[ebp]
$LN53@project_v_:

; 382  :     }
; 383  :     if ( totaldiff < web.tolerance ) break;

	fld	QWORD PTR _web+752
	fcomp	QWORD PTR _totaldiff$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN19@project_v_

; 384  : 
; 385  :     constr_proj(PLAINPROJ,oncount,con,x,f,delta,NULL,NO_DETECT,v_id);

	mov	eax, DWORD PTR _x$[ebp]
	push	esi
	push	0
	push	0
	lea	ecx, DWORD PTR _delta$[ebp]
	push	ecx
	lea	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	edx, DWORD PTR _oncount$[ebp]
	push	eax
	lea	ecx, DWORD PTR _con$[ebp]
	push	ecx
	push	edx
	push	4
	call	_constr_proj

; 386  :     for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	add	esp, 36					; 00000024H
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN4@project_v_
	mov	eax, DWORD PTR _x$[ebp]
	lea	edx, DWORD PTR _delta$[ebp]
	sub	edx, eax
	npad	7
$LL6@project_v_:

; 387  :         x[j] += delta[j];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL6@project_v_
$LN4@project_v_:

; 388  :     itercount++;

	mov	eax, DWORD PTR _itercount$[ebp]
	inc	eax
	mov	DWORD PTR _itercount$[ebp], eax

; 389  :   }
; 390  :   while ( itercount < MAXCONITER );

	cmp	eax, 10					; 0000000aH
	jge	SHORT $LN54@project_v_
	jmp	$LN50@project_v_
$LN19@project_v_:

; 391  : 
; 392  :   if ( (itercount >= MAXCONITER) && (mode == ACTUAL_MOVE) )

	cmp	DWORD PTR _itercount$[ebp], 10		; 0000000aH
	jl	$LN3@project_v_
$LN54@project_v_:
	cmp	DWORD PTR _mode$[ebp], 1
	jne	$LN3@project_v_

; 393  :   { struct constraint *con = get_constraint(dcon);

	mov	edi, DWORD PTR _dcon$[ebp]
	and	edi, 1073741823				; 3fffffffH
	imul	edi, 176				; 000000b0H
	add	edi, DWORD PTR _web+652

; 394  :     sprintf(msg,
; 395  :   "Vertex %s doesn't converge to constraint %s after %d iterations. \n maxdiff = %g, constraint_tolerance %g\n",
; 396  :          ELNAME(v_id),con->name,MAXCONITER,(DOUBLE)totaldiff,
; 397  :             (DOUBLE)web.tolerance);

	test	esi, 268435456				; 10000000H
	je	SHORT $LN29@project_v_
	mov	eax, DWORD PTR tv417[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN30@project_v_
$LN29@project_v_:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN30@project_v_:
	fld	QWORD PTR _web+752
	mov	ecx, DWORD PTR _msg
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _totaldiff$[ebp]
	fstp	QWORD PTR [esp]
	push	10					; 0000000aH
	push	edi
	push	eax
	push	OFFSET ??_C@_0GK@OFOCPBMB@Vertex?5?$CFs?5doesn?8t?5converge?5to?5co@
	push	ecx
	call	_sprintf

; 398  :      kb_error(1792,msg,WARNING);

	mov	edx, DWORD PTR _msg
	push	2
	push	edx
	push	1792					; 00000700H
	call	_kb_error
	add	esp, 48					; 00000030H
$LN3@project_v_:

; 399  :   }
; 400  : 
; 401  : /*  if ( mode == ACTUAL_MOVE ) */
; 402  :   { if ( walls ) set_attr(v_id,HIT_WALL);

	mov	ecx, DWORD PTR tv417[ebp]
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	cmp	DWORD PTR _walls$[ebp], 0
	mov	eax, DWORD PTR _web[esi+12]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+12], edx
	je	SHORT $LN2@project_v_
	or	DWORD PTR [eax+8], 8192			; 00002000H

; 403  :      else unset_attr(v_id,HIT_WALL);
; 404  : /*
; 405  :      if ( hit_one_side ) set_attr(v_id,HIT_ONE_SIDED);
; 406  :      else unset_attr(v_id,HIT_ONE_SIDED);
; 407  : */
; 408  :   }
; 409  :   return new_hits;

	mov	eax, DWORD PTR _new_hits$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 410  : 
; 411  : } // end project_v_constr()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@project_v_:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	and	DWORD PTR [eax+8], -8193		; ffffdfffH
	mov	eax, DWORD PTR _new_hits$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_project_v_constr ENDP
_TEXT	ENDS
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_calc_constr_force_v
EXTRN	_int_val:DWORD
; Function compile flags: /Ogtp
;	COMDAT _calc_constr_force_v
_TEXT	SEGMENT
_fval$ = -76						; size = 8
_f$ = -68						; size = 4
_v_id$GSCopy$ = -64					; size = 4
_coord$ = -60						; size = 4
_sign$ = -56						; size = 4
_deriv$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_calc_constr_force_v PROC				; COMDAT

; 421  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _v_id$[ebp]

; 422  :   REAL *f,*coord;
; 423  :   struct constraint *constr;
; 424  :   int i,j;
; 425  :   conmap_t * conmap;
; 426  :   int sign;
; 427  :   REAL fval,deriv[MAXCOORD];
; 428  : 
; 429  :   int_val = ordinal(get_original(v_id))+1;  /* for eval  of file parameters */

	mov	ecx, eax

; 434  :   conmap = get_v_constraint_map(v_id);

	mov	DWORD PTR _v_id$GSCopy$[ebp], eax
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	eax, DWORD PTR _web[eax+12]
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx+20]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN13@calc_const

; 422  :   REAL *f,*coord;
; 423  :   struct constraint *constr;
; 424  :   int i,j;
; 425  :   conmap_t * conmap;
; 426  :   int sign;
; 427  :   REAL fval,deriv[MAXCOORD];
; 428  : 
; 429  :   int_val = ordinal(get_original(v_id))+1;  /* for eval  of file parameters */

	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN14@calc_const
$LN13@calc_const:
	or	eax, -1
$LN14@calc_const:

; 430  :   f = get_force(v_id);

	mov	edx, DWORD PTR _web+104
	push	ebx
	mov	ebx, DWORD PTR _web+12
	inc	eax
	mov	DWORD PTR _int_val, eax
	mov	eax, DWORD PTR [ecx+ebx]
	push	esi
	mov	esi, DWORD PTR _dymem
	push	edi
	mov	edi, DWORD PTR [edx+esi+784]
	add	edi, eax
	mov	DWORD PTR _f$[ebp], edi

; 431  :   coord = get_coord(v_id);

	mov	edi, DWORD PTR [edx+esi+64]
	add	edi, eax

; 432  :   if ( get_vattr(v_id) & NEGBOUNDARY ) sign = -1;

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _coord$[ebp], edi
	and	eax, 256				; 00000100H
	xor	edi, edi
	or	eax, edi
	mov	DWORD PTR _sign$[ebp], -1
	jne	SHORT $LN9@calc_const

; 433  :   else sign = 1;

	mov	DWORD PTR _sign$[ebp], 1
$LN9@calc_const:

; 434  :   conmap = get_v_constraint_map(v_id);

	cmp	DWORD PTR [edx+esi+1288], edi
	je	SHORT $LN15@calc_const
	mov	edi, DWORD PTR [edx+esi+1264]
	add	edi, DWORD PTR [ecx+ebx]
	jmp	SHORT $LN16@calc_const
$LN15@calc_const:
	mov	edi, OFFSET _nullcon
$LN16@calc_const:

; 435  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	ebx, 1
	cmp	DWORD PTR [edi], ebx
	jl	$LN6@calc_const
	mov	esi, DWORD PTR _web+616
$LL8@calc_const:

; 436  :   { constr = get_constraint(conmap[j]);

	mov	eax, DWORD PTR [edi+ebx*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 437  :     if ( !(constr->attr & CON_ENERGY) || (constr->compcount != 1) )

	xor	edx, edx
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 64					; 00000040H
	or	ecx, edx
	je	SHORT $LN7@calc_const
	cmp	DWORD PTR [eax+44], 1
	jne	SHORT $LN7@calc_const

; 438  :       continue;
; 439  :     eval_all(constr->envect[0],coord,SDIM,&fval,deriv,v_id);      

	mov	ecx, DWORD PTR _v_id$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax+48]
	push	ecx
	lea	edx, DWORD PTR _deriv$[ebp]
	push	edx
	mov	edx, DWORD PTR _coord$[ebp]
	lea	ecx, DWORD PTR _fval$[ebp]
	push	ecx
	push	esi
	push	edx
	push	eax
	call	_eval_all

; 440  :     for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _web+616
	add	esp, 24					; 00000018H
	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN7@calc_const
	mov	eax, DWORD PTR _f$[ebp]
	fild	DWORD PTR _sign$[ebp]
	lea	edx, DWORD PTR _deriv$[ebp]
	sub	edx, eax
$LN3@calc_const:

; 441  :       f[i] += -sign*deriv[i]; /* force by constraint */

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	esi, DWORD PTR _web+616
	cmp	ecx, esi
	jl	SHORT $LN3@calc_const

; 440  :     for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN7@calc_const:

; 435  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	inc	ebx
	cmp	ebx, DWORD PTR [edi]
	jle	SHORT $LL8@calc_const
$LN6@calc_const:

; 442  :   }
; 443  : 
; 444  :   return;
; 445  : 
; 446  : } // end calc_constr_force_v()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_calc_constr_force_v ENDP
_TEXT	ENDS
PUBLIC	_calc_constr_energy_v
EXTRN	_binary_tree_add:PROC
; Function compile flags: /Ogtp
;	COMDAT _calc_constr_energy_v
_TEXT	SEGMENT
_j$ = -4						; size = 4
_v_id$ = 8						; size = 4
_calc_constr_energy_v PROC				; COMDAT

; 524  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 525  :   REAL e;
; 526  :   int j;
; 527  :   conmap_t *conmap = get_v_constraint_map(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	cmp	DWORD PTR [ecx+eax+1288], 0
	push	ebx
	mov	ebx, DWORD PTR _v_id$[ebp]
	push	esi
	push	edi
	je	SHORT $LN10@calc_const@2
	mov	esi, DWORD PTR _web+12
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [esi+edx*4]
	add	edi, DWORD PTR [ecx+eax+1264]
	jmp	SHORT $LN11@calc_const@2
$LN10@calc_const@2:
	mov	edi, OFFSET _nullcon
$LN11@calc_const@2:

; 528  :   struct constraint *constr;
; 529  : 
; 530  :   int_val = ordinal(get_original(v_id))+1;  /* for eval  of file parameters */

	mov	eax, ebx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [edx+20]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN12@calc_const@2
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN13@calc_const@2
$LN12@calc_const@2:
	or	eax, -1
$LN13@calc_const@2:
	inc	eax
	mov	DWORD PTR _int_val, eax

; 531  :   for ( j = 1 ;  j <= (int)conmap[0] ; j++ )

	mov	eax, 1
	mov	DWORD PTR _j$[ebp], eax
	cmp	DWORD PTR [edi], eax
	jl	$LN5@calc_const@2
	jmp	SHORT $LN7@calc_const@2
	npad	9
$LL16@calc_const@2:
	mov	ebx, DWORD PTR _v_id$[ebp]
$LN7@calc_const@2:

; 532  :   { constr = get_constraint(conmap[j]);

	mov	eax, DWORD PTR [edi+eax*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 533  :     if ( !(constr->attr & CON_ENERGY) || (constr->compcount != 1) ) continue;

	xor	edx, edx
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 64					; 00000040H
	or	ecx, edx
	je	SHORT $LN6@calc_const@2
	cmp	DWORD PTR [eax+44], 1
	jne	SHORT $LN6@calc_const@2

; 534  :     e = eval(constr->envect[0],get_coord(v_id),v_id,NULL);  

	mov	ecx, DWORD PTR _web+12
	push	edx
	mov	edx, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR _web+104
	push	ebx
	mov	ebx, DWORD PTR _dymem
	add	edx, DWORD PTR [ecx+ebx+64]
	push	edx
	mov	edx, DWORD PTR [eax+48]
	push	edx
	call	_eval

; 535  :     if ( get_vattr(v_id) & NEGBOUNDARY )

	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [eax+8]
	add	esp, 16					; 00000010H
	and	eax, 256				; 00000100H
	xor	ecx, ecx

; 536  :       binary_tree_add(web.total_energy_addends,-e);

	sub	esp, 8
	or	eax, ecx
	je	SHORT $LN2@calc_const@2
	fchs
$LN2@calc_const@2:

; 537  :     else
; 538  :       binary_tree_add(web.total_energy_addends,e);

	fstp	QWORD PTR [esp]
	push	OFFSET _web+1248
	call	_binary_tree_add
	add	esp, 12					; 0000000cH
$LN6@calc_const@2:

; 531  :   for ( j = 1 ;  j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR [edi]
	jle	$LL16@calc_const@2
$LN5@calc_const@2:
	pop	edi
	pop	esi
	pop	ebx

; 539  :   }
; 540  : } // end calc_constr_energy_v()

	mov	esp, ebp
	pop	ebp
	ret	0
_calc_constr_energy_v ENDP
_TEXT	ENDS
PUBLIC	_calc_constr_content_v
EXTRN	_add_body_volume:PROC
; Function compile flags: /Ogtp
;	COMDAT _calc_constr_content_v
_TEXT	SEGMENT
_e$ = -52						; size = 8
_start_e$ = -44						; size = 4
_start_fe$89626 = -40					; size = 4
tv673 = -36						; size = 4
_j$ = -32						; size = 4
_next_e$ = -28						; size = 4
_constr$ = -24						; size = 4
_e_id$ = -20						; size = 4
_min_rank$ = -16					; size = 4
_max_rank$ = -12					; size = 4
tv777 = -8						; size = 4
_conmap$ = -4						; size = 4
_v_id$ = 8						; size = 4
_calc_constr_content_v PROC				; COMDAT

; 612  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 613  :   REAL e=0.0;
; 614  :   int j;
; 615  :   conmap_t * conmap;
; 616  :   struct constraint *constr;
; 617  :   body_id b_id;
; 618  :   facetedge_id fe_id;
; 619  :   facet_id f_id;
; 620  :   edge_id  e_id = get_vertex_edge(v_id);

	mov	edx, DWORD PTR _v_id$[ebp]
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _web+12
	mov	eax, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR tv673[ebp], ecx
	mov	DWORD PTR _e_id$[ebp], eax

; 621  :   edge_id  start_e = e_id;

	mov	DWORD PTR _start_e$[ebp], eax

; 622  :   edge_id  next_e;
; 623  :   int min_rank,max_rank;
; 624  : 
; 625  :   if ( !valid_id(e_id) ) return;  /* not on a cell */

	test	eax, 268435456				; 10000000H
	je	$LN20@calc_const@3

; 626  : 
; 627  :   int_val = ordinal(get_original(v_id))+1;  /* for eval  of file parameters */

	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	eax, DWORD PTR [edx+ecx]
	mov	eax, DWORD PTR [eax+20]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN32@calc_const@3
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN33@calc_const@3
$LN32@calc_const@3:
	or	eax, -1
$LN33@calc_const@3:
	inc	eax
	mov	DWORD PTR _int_val, eax

; 628  :   conmap = get_v_constraint_map(v_id); /* only hit constraints */

	mov	eax, DWORD PTR _dymem
	push	edi
	mov	edi, DWORD PTR _web+104
	cmp	DWORD PTR [edi+eax+1288], 0
	je	SHORT $LN34@calc_const@3
	mov	eax, DWORD PTR [edi+eax+1264]
	add	eax, DWORD PTR [ecx+esi]
	mov	DWORD PTR _conmap$[ebp], eax
	jmp	SHORT $LN35@calc_const@3
$LN34@calc_const@3:
	mov	DWORD PTR _conmap$[ebp], OFFSET _nullcon
$LN35@calc_const@3:

; 629  :   
; 630  :   min_rank = MAXINT; max_rank = 0;
; 631  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _conmap$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR _web+652
	mov	ecx, 1
	mov	DWORD PTR _min_rank$[ebp], 2147483647	; 7fffffffH
	mov	DWORD PTR _max_rank$[ebp], 0
	cmp	edx, ecx
	jl	SHORT $LN76@calc_const@3
	npad	3
$LL28@calc_const@3:

; 632  :   { if ( !(conmap[j] & CON_HIT_BIT) ) continue;

	mov	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	jns	SHORT $LN27@calc_const@3

; 633  :     constr = get_constraint(conmap[j]);

	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H

; 634  :     if ( constr->content_rank < min_rank ) min_rank = constr->content_rank;

	mov	eax, DWORD PTR [eax+esi+172]
	cmp	eax, DWORD PTR _min_rank$[ebp]
	jge	SHORT $LN24@calc_const@3
	mov	DWORD PTR _min_rank$[ebp], eax
$LN24@calc_const@3:

; 635  :     if ( constr->content_rank > max_rank ) max_rank = constr->content_rank;

	cmp	eax, DWORD PTR _max_rank$[ebp]
	jle	SHORT $LN27@calc_const@3
	mov	DWORD PTR _max_rank$[ebp], eax
$LN27@calc_const@3:

; 629  :   
; 630  :   min_rank = MAXINT; max_rank = 0;
; 631  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _conmap$[ebp]
	inc	ecx
	cmp	ecx, edx
	jle	SHORT $LL28@calc_const@3
$LN76@calc_const@3:

; 636  :   }
; 637  :     
; 638  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
	cmp	edx, ecx
	jl	$LN85@calc_const@3
	push	ebx
$LL22@calc_const@3:

; 639  :   { if ( !(conmap[j] & CON_HIT_BIT) ) continue;

	mov	eax, DWORD PTR [eax+ecx*4]
	test	eax, eax
	jns	$LN21@calc_const@3

; 640  :     constr = get_constraint(conmap[j]);

	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	lea	ebx, DWORD PTR [esi+eax]

; 641  :     if ( !(constr->attr & CON_CONTENT) ) continue;

	mov	eax, DWORD PTR [ebx+32]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	mov	DWORD PTR _constr$[ebp], ebx
	je	$LN21@calc_const@3

; 642  :     if ( constr->compcount != 1 ) continue;

	cmp	DWORD PTR [ebx+44], 1
	jne	$LN21@calc_const@3

; 643  :     
; 644  :     if ( get_vattr(v_id) & NEGBOUNDARY )

	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR tv673[ebp]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [ecx+8]
	xor	edx, edx
	and	eax, 256				; 00000100H
	or	eax, edx

; 645  :       e = -eval(constr->convect[0],get_coord(v_id),v_id,NULL);  

	push	edx
	je	SHORT $LN16@calc_const@3
	mov	eax, DWORD PTR _v_id$[ebp]
	mov	edx, DWORD PTR _dymem
	push	eax
	mov	eax, DWORD PTR [edi+edx+64]
	add	eax, ecx
	mov	ecx, DWORD PTR [ebx+108]
	push	eax
	push	ecx
	call	_eval
	fchs

; 646  :     else

	jmp	SHORT $LN160@calc_const@3
$LN16@calc_const@3:

; 647  :       e = eval(constr->convect[0],get_coord(v_id),v_id,NULL);  

	mov	edx, DWORD PTR _v_id$[ebp]
	mov	eax, DWORD PTR _dymem
	push	edx
	mov	edx, DWORD PTR [edi+eax+64]
	mov	eax, DWORD PTR [ebx+108]
	add	edx, ecx
	push	edx
	push	eax
	call	_eval
$LN160@calc_const@3:

; 648  :   
; 649  :     next_e = e_id;

	mov	ecx, DWORD PTR _e_id$[ebp]
	fst	QWORD PTR _e$[ebp]
	mov	ebx, DWORD PTR _web+460
	mov	edi, DWORD PTR _web+124
	add	esp, 16					; 00000010H
	jmp	SHORT $LN14@calc_const@3
$LN77@calc_const@3:
	mov	ecx, DWORD PTR _next_e$[ebp]
$LN14@calc_const@3:

; 650  :     do
; 651  :     { facetedge_id start_fe;
; 652  :       
; 653  :       e_id = next_e;
; 654  :       next_e = get_next_tail_edge(e_id);

	mov	eax, ecx
	mov	DWORD PTR _e_id$[ebp], ecx
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+eax*4]
	shr	ecx, 27					; 0000001bH
	mov	edx, ecx
	and	edx, 1
	mov	edx, DWORD PTR [esi+edx*4+32]
	mov	DWORD PTR _next_e$[ebp], edx

; 655  :       if ( get_eattr(e_id) & NONCONTENT ) continue;

	mov	edx, esi
	mov	eax, DWORD PTR [edx+8]
	and	eax, 536870912				; 20000000H
	xor	esi, esi
	or	eax, esi
	jne	$LN13@calc_const@3

; 656  :   
; 657  :       /* cell on one side of edge */
; 658  :       start_fe = fe_id = get_edge_fe(e_id);    

	test	edx, edx
	je	SHORT $LN40@calc_const@3
$LN41@calc_const@3:
	mov	eax, DWORD PTR [edx+28]
	test	cl, 1
	je	SHORT $LN40@calc_const@3
	xor	eax, 134217728				; 08000000H
$LN40@calc_const@3:
	mov	DWORD PTR _start_fe$89626[ebp], eax

; 659  :       if ( !valid_id(fe_id) ) continue;

	test	eax, 268435456				; 10000000H
	je	$LN13@calc_const@3
$LN9@calc_const@3:

; 660  :       
; 661  :       do 
; 662  :       {
; 663  :         if ( !valid_id(get_prev_edge(fe_id)) )

	mov	edi, eax
	shr	edi, 27					; 0000001bH
	and	edi, 1
	mov	DWORD PTR tv777[ebp], edi
	mov	esi, eax
	je	SHORT $LN45@calc_const@3
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+ebx]
	mov	ecx, DWORD PTR [edx+32]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN44@calc_const@3
$LN45@calc_const@3:
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+ebx]
	mov	ecx, DWORD PTR [edx+28]
$LN44@calc_const@3:
	test	ecx, 268435456				; 10000000H
	jne	$LN82@calc_const@3

; 664  :         { 
; 665  :           f_id = get_fe_facet(fe_id);

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN49@calc_const@3
	mov	edi, DWORD PTR _NULLFACET
	jmp	SHORT $LN50@calc_const@3
$LN49@calc_const@3:
	mov	edx, DWORD PTR [edx+24]
	test	edi, edi
	je	SHORT $LN48@calc_const@3
	xor	edx, 134217728				; 08000000H
$LN48@calc_const@3:
	mov	edi, edx
$LN50@calc_const@3:

; 666  :           if ( valid_id(f_id) && 
; 667  :            ( (!inverted(f_id) && constr->content_rank >= max_rank) 
; 668  :                || (inverted(f_id) && constr->content_rank <= min_rank)) )

	test	edi, 268435456				; 10000000H
	je	$LN81@calc_const@3
	mov	edx, edi
	shr	edx, 27					; 0000001bH
	and	edx, 1
	jne	SHORT $LN78@calc_const@3
	mov	eax, DWORD PTR _max_rank$[ebp]
	mov	ecx, DWORD PTR _constr$[ebp]
	cmp	DWORD PTR [ecx+172], eax
	jge	SHORT $LN4@calc_const@3
$LN78@calc_const@3:
	test	edx, edx
	je	$LN81@calc_const@3
	mov	eax, DWORD PTR _min_rank$[ebp]
	mov	ecx, DWORD PTR _constr$[ebp]
	cmp	DWORD PTR [ecx+172], eax
	jg	$LN81@calc_const@3
$LN4@calc_const@3:

; 669  :           {
; 670  :             add_facet_area(f_id,-e);

	fld	ST(0)
	fchs
	fld	ST(0)
	test	edx, edx
	je	SHORT $LN37@calc_const@3
	fchs
$LN37@calc_const@3:
	mov	ecx, DWORD PTR _web+236
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	fadd	QWORD PTR [ecx+40]
	fstp	QWORD PTR [ecx+40]

; 671  :             
; 672  :             b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	mov	ecx, DWORD PTR _web+328
	mov	ebx, DWORD PTR _web+236
	jne	SHORT $LN55@calc_const@3
	xor	eax, eax
	jmp	SHORT $LN52@calc_const@3
$LN55@calc_const@3:
	test	edx, edx
	mov	edx, DWORD PTR [eax+ebx]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [ecx+eax+784]
	je	SHORT $LN53@calc_const@3
	mov	eax, DWORD PTR [edx+eax+4]
	jmp	SHORT $LN52@calc_const@3
$LN53@calc_const@3:
	mov	eax, DWORD PTR [edx+eax]
$LN52@calc_const@3:

; 673  :             if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN124@calc_const@3

; 674  :               add_body_volume(b_id,-e);

	sub	esp, 8
	fstp	ST(1)
	fstp	QWORD PTR [esp]
	push	eax
	call	_add_body_volume
	fld	QWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _web+328
	mov	ebx, DWORD PTR _web+236
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN2@calc_const@3
$LN124@calc_const@3:
	fstp	ST(0)
$LN2@calc_const@3:

; 675  :             b_id = get_facet_body(inverse_id(f_id));

	xor	edi, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	mov	eax, edi
	jne	SHORT $LN61@calc_const@3
	xor	eax, eax
	jmp	SHORT $LN58@calc_const@3
$LN61@calc_const@3:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN60@calc_const@3
	xor	eax, eax
	jmp	SHORT $LN58@calc_const@3
$LN60@calc_const@3:
	test	eax, 134217728				; 08000000H
	je	SHORT $LN59@calc_const@3
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+eax+784]
	mov	eax, DWORD PTR [edx+ecx+4]
	jmp	SHORT $LN58@calc_const@3
$LN59@calc_const@3:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+eax+784]
	mov	eax, DWORD PTR [edx+ecx]
$LN58@calc_const@3:

; 676  :             if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN74@calc_const@3

; 677  :               add_body_volume(b_id,e);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	call	_add_body_volume
	fld	QWORD PTR _e$[ebp]
	add	esp, 12					; 0000000cH
$LN74@calc_const@3:
	mov	ebx, DWORD PTR _web+460
$LN81@calc_const@3:
	mov	edi, DWORD PTR tv777[ebp]
$LN82@calc_const@3:

; 678  :           }
; 679  :         }
; 680  :         fe_id = get_next_facet(fe_id);

	test	edi, edi
	je	SHORT $LN65@calc_const@3
	mov	edx, DWORD PTR [esi+ebx]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN8@calc_const@3
$LN65@calc_const@3:
	mov	eax, DWORD PTR [esi+ebx]
	mov	eax, DWORD PTR [eax+40]
$LN8@calc_const@3:

; 681  :       } while (!equal_id(fe_id,start_fe));

	cmp	eax, DWORD PTR _start_fe$89626[ebp]
	jne	$LN9@calc_const@3
	mov	edi, DWORD PTR _web+124
$LN13@calc_const@3:

; 682  :   
; 683  :     } while ( !equal_id(next_e,start_e) );

	mov	ecx, DWORD PTR _start_e$[ebp]
	cmp	DWORD PTR _next_e$[ebp], ecx
	jne	$LN77@calc_const@3
	mov	esi, DWORD PTR _web+652
	fstp	ST(0)
	mov	edi, DWORD PTR _web+104
$LN21@calc_const@3:

; 636  :   }
; 637  :     
; 638  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _conmap$[ebp]
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR [eax]
	jle	$LL22@calc_const@3
	pop	ebx
$LN85@calc_const@3:
	pop	edi
$LN20@calc_const@3:
	pop	esi

; 684  :   
; 685  :   }
; 686  : }  // end calc_constr_content_v()

	mov	esp, ebp
	pop	ebp
	ret	0
_calc_constr_content_v ENDP
_TEXT	ENDS
PUBLIC	__real@4028000000000000
PUBLIC	??_C@_0EJ@OPDAHNAB@Gap?5energy?5error?3?5Vertex?5?$CFs?5is?5o@ ; `string'
PUBLIC	??_C@_0CJ@JGBJEBAP@Edge?5?$CFs?5on?5too?5many?5convex?5const@ ; `string'
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_constr_spring_energy
EXTRN	_get_edge_side:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@4028000000000000
CONST	SEGMENT
__real@4028000000000000 DQ 04028000000000000r	; 12
CONST	ENDS
;	COMDAT ??_C@_0EJ@OPDAHNAB@Gap?5energy?5error?3?5Vertex?5?$CFs?5is?5o@
CONST	SEGMENT
??_C@_0EJ@OPDAHNAB@Gap?5energy?5error?3?5Vertex?5?$CFs?5is?5o@ DB 'Gap en'
	DB	'ergy error: Vertex %s is on a convex constraint at zero gradi'
	DB	'ent.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JGBJEBAP@Edge?5?$CFs?5on?5too?5many?5convex?5const@
CONST	SEGMENT
??_C@_0CJ@JGBJEBAP@Edge?5?$CFs?5on?5too?5many?5convex?5const@ DB 'Edge %s'
	DB	' on too many convex constraints.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _constr_spring_energy
_TEXT	SEGMENT
_constr$ = -188						; size = 28
_ss$ = -160						; size = 8
tv359 = -152						; size = 8
_fval$89794 = -152					; size = 8
_concount$ = -144					; size = 4
tv462 = -140						; size = 8
tv460 = -140						; size = 8
_tail$ = -132						; size = 4
_head$ = -128						; size = 4
_ff$89792 = -124					; size = 8
_sprenergy$ = -116					; size = 8
_e_id$GSCopy$ = -108					; size = 4
tv352 = -104						; size = 4
_i$ = -104						; size = 4
_s$ = -100						; size = 48
_grad$89795 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_constr_spring_energy PROC				; COMDAT

; 801  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 188				; 000000bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 802  :   REAL sprenergy = 0.0;
; 803  :   REAL s[MAXCOORD];
; 804  :   REAL ss;
; 805  :   struct constraint *constr[MAXCONHIT];
; 806  :   int concount;
; 807  :   conmap_t * conmap;
; 808  :   vertex_id tail,head;
; 809  :   int i,j; 
; 810  : 
; 811  :   if ( get_eattr(e_id) & FIXED ) return;

	mov	ecx, DWORD PTR _web+124
	fldz
	push	esi
	fstp	QWORD PTR _sprenergy$[ebp]
	push	edi
	mov	edi, DWORD PTR _e_id$[ebp]
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR tv352[ebp], eax
	mov	eax, ecx
	mov	DWORD PTR tv359[ebp+4], edx
	and	eax, 64					; 00000040H
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR _e_id$GSCopy$[ebp], edi
	jne	$LN14@constr_spr

; 812  :   if ( !(get_eattr(e_id) & CONSTRAINT) ) return;

	and	ecx, 1024				; 00000400H
	or	ecx, eax
	je	$LN14@constr_spr

; 813  : 
; 814  :   tail = get_edge_tailv(e_id);

	push	edi
	call	_get_edge_tailv

; 815  :   head = get_edge_headv(e_id);

	push	edi
	mov	DWORD PTR _tail$[ebp], eax
	call	_get_edge_headv

; 816  : 
; 817  :   /* find which constraints have CONVEX attribute */
; 818  :   conmap = get_e_constraint_map(e_id);

	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR _head$[ebp], eax
	mov	eax, DWORD PTR _web+216
	add	esp, 8
	cmp	DWORD PTR [eax+ecx+1048], 0
	je	SHORT $LN16@constr_spr
	mov	edi, DWORD PTR [eax+ecx+1024]
	add	edi, esi
	jmp	SHORT $LN17@constr_spr
$LN16@constr_spr:
	mov	edi, OFFSET _nullcon
$LN17@constr_spr:
	push	ebx

; 819  :   for ( j = 1,i = 0 ; j <= (int)conmap[0] ; j++ )

	mov	ebx, 1
	xor	esi, esi
	cmp	DWORD PTR [edi], ebx
	jl	$LN32@constr_spr
	npad	7
$LL31@constr_spr:

; 820  :   { constr[i] = get_constraint(conmap[j]);

	mov	eax, DWORD PTR [edi+ebx*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 821  :     if ( constr[i]->attr & B_CONVEX ) 

	xor	ecx, ecx
	mov	DWORD PTR _constr$[ebp+esi*4], eax
	mov	eax, DWORD PTR [eax+32]
	and	eax, 8
	or	eax, ecx
	je	SHORT $LN10@constr_spr

; 822  :     {
; 823  :       if ( i >= MAXCONHIT )

	cmp	esi, 7
	jl	SHORT $LN7@constr_spr

; 824  :       { sprintf(errmsg,"Edge %s on too many convex constraints.\n",
; 825  :             ELNAME(e_id));

	test	DWORD PTR _e_id$GSCopy$[ebp], 268435456	; 10000000H
	je	SHORT $LN18@constr_spr
	mov	edx, DWORD PTR tv352[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN19@constr_spr
$LN18@constr_spr:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN19@constr_spr:
	push	eax
	push	OFFSET ??_C@_0CJ@JGBJEBAP@Edge?5?$CFs?5on?5too?5many?5convex?5const@
	push	OFFSET _errmsg
	call	_sprintf

; 826  :         kb_error(5884,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5884					; 000016fcH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN7@constr_spr:

; 827  :       }
; 828  :       i++;    /* keep this one */

	inc	esi
$LN10@constr_spr:

; 819  :   for ( j = 1,i = 0 ; j <= (int)conmap[0] ; j++ )

	inc	ebx
	cmp	ebx, DWORD PTR [edi]
	jle	$LL31@constr_spr

; 829  :     }
; 830  :   }
; 831  :   if ( i == 0 ) return;

	test	esi, esi
	je	$LN32@constr_spr

; 832  :   concount = i;  
; 833  : 
; 834  :   /* now the calculation */
; 835  :   get_edge_side(e_id,s);

	mov	ecx, DWORD PTR _e_id$GSCopy$[ebp]
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	push	ecx
	mov	DWORD PTR _concount$[ebp], esi
	call	_get_edge_side

; 836  :   ss = SDIM_dot(s,s);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, eax
	push	ecx
	call	_dot
	fstp	QWORD PTR _ss$[ebp]
	add	esp, 20					; 00000014H

; 837  : 
; 838  : #ifndef OLDWAY
; 839  :   for ( i = 0 ; i < concount ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	esi, esi
	jle	$LN28@constr_spr
	mov	ebx, DWORD PTR _tail$[ebp]
	mov	esi, DWORD PTR _head$[ebp]
	and	ebx, 134217727				; 07ffffffH
	and	esi, 134217727				; 07ffffffH
$LL30@constr_spr:

; 840  :   { REAL *coord,ff,fs;
; 841  :     REAL fval,grad[MAXCOORD];
; 842  :     coord = get_coord(tail);
; 843  :     eval_all(constr[i]->formula,coord,SDIM,&fval,grad,e_id);

	mov	eax, DWORD PTR _e_id$GSCopy$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	edi, DWORD PTR _constr$[ebp+edx*4]
	push	eax
	mov	eax, DWORD PTR _web+616
	lea	ecx, DWORD PTR _grad$89795[ebp]
	push	ecx
	mov	ecx, DWORD PTR _web+12
	lea	edx, DWORD PTR _fval$89794[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR _dymem
	push	eax
	mov	eax, DWORD PTR _web+104
	add	edx, DWORD PTR [eax+ecx+64]
	push	edx
	mov	edx, DWORD PTR [edi+40]
	push	edx
	call	_eval_all

; 844  :     ff = SDIM_dot(grad,grad);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _grad$89795[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fst	QWORD PTR _ff$89792[ebp]

; 845  :     if ( ff <= 0.0 )

	fldz
	add	esp, 36					; 00000024H
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN29@constr_spr

; 846  :     { sprintf(errmsg,
; 847  :    "Gap energy error: Vertex %s is on a convex constraint at zero gradient.\n",
; 848  :              ELNAME(tail));

	test	DWORD PTR _tail$[ebp], 268435456	; 10000000H
	je	SHORT $LN20@constr_spr
	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN21@constr_spr
$LN20@constr_spr:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@constr_spr:
	push	eax
	push	OFFSET ??_C@_0EJ@OPDAHNAB@Gap?5energy?5error?3?5Vertex?5?$CFs?5is?5o@
	push	OFFSET _errmsg
	call	_sprintf

; 849  :        kb_error(2001,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2001					; 000007d1H
	call	_kb_error

; 850  :        ff = 1.0;

	fld1
	fstp	QWORD PTR _ff$89792[ebp]
	add	esp, 24					; 00000018H
$LN29@constr_spr:

; 851  :     }
; 852  :     fs = SDIM_dot(s,grad);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _grad$89795[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_dot

; 853  :     sprenergy += fabs(fs)*sqrt(ss/ff)/12;

	fabs
	fstp	QWORD PTR tv460[ebp]
	add	esp, 12					; 0000000cH
	fld	QWORD PTR _ss$[ebp]
	fdiv	QWORD PTR _ff$89792[ebp]
	call	__CIsqrt
	fmul	QWORD PTR tv460[ebp]

; 854  : 
; 855  :     coord = get_coord(head);
; 856  :     eval_all(constr[i]->formula,coord,SDIM,&fval,grad,e_id);

	mov	ecx, DWORD PTR _e_id$GSCopy$[ebp]
	push	ecx
	fdiv	QWORD PTR __real@4028000000000000
	mov	ecx, DWORD PTR _web+616
	lea	edx, DWORD PTR _grad$89795[ebp]
	push	edx
	mov	edx, DWORD PTR _web+12
	lea	eax, DWORD PTR _fval$89794[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _dymem
	push	ecx
	mov	ecx, DWORD PTR _web+104
	add	eax, DWORD PTR [ecx+edx+64]
	push	eax
	mov	eax, DWORD PTR [edi+40]
	push	eax
	fadd	QWORD PTR _sprenergy$[ebp]
	fstp	QWORD PTR _sprenergy$[ebp]
	call	_eval_all

; 857  :     ff = SDIM_dot(grad,grad);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _grad$89795[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	fst	QWORD PTR _ff$89792[ebp]

; 858  :     if ( ff <= 0.0 )

	fldz
	add	esp, 36					; 00000024H
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN1@constr_spr

; 859  :     { sprintf(errmsg,
; 860  :   "Gap energy error: Vertex %s is on a convex constraint at zero gradient.\n",
; 861  :              ELNAME(head));

	test	DWORD PTR _head$[ebp], 268435456	; 10000000H
	je	SHORT $LN22@constr_spr
	lea	ecx, DWORD PTR [esi+1]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN23@constr_spr
$LN22@constr_spr:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN23@constr_spr:
	push	eax
	push	OFFSET ??_C@_0EJ@OPDAHNAB@Gap?5energy?5error?3?5Vertex?5?$CFs?5is?5o@
	push	OFFSET _errmsg
	call	_sprintf

; 862  :       kb_error(2002,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2002					; 000007d2H
	call	_kb_error

; 863  :       ff = 1.0;

	fld1
	fstp	QWORD PTR _ff$89792[ebp]
	add	esp, 24					; 00000018H
$LN1@constr_spr:

; 864  :     }
; 865  :     fs = SDIM_dot(s,grad);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _grad$89795[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_dot

; 866  :     sprenergy += fabs(fs)*sqrt(ss/ff)/12;

	fabs
	fstp	QWORD PTR tv462[ebp]
	add	esp, 12					; 0000000cH
	fld	QWORD PTR _ss$[ebp]
	fdiv	QWORD PTR _ff$89792[ebp]
	call	__CIsqrt
	fmul	QWORD PTR tv462[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	fdiv	QWORD PTR __real@4028000000000000
	mov	DWORD PTR _i$[ebp], eax
	fadd	QWORD PTR _sprenergy$[ebp]
	fstp	QWORD PTR _sprenergy$[ebp]
	cmp	eax, DWORD PTR _concount$[ebp]
	jl	$LL30@constr_spr
$LN28@constr_spr:

; 867  :   }
; 868  : #endif
; 869  : 
; 870  : #ifdef OLDWAYX
; 871  : 
; 872  :   constr_proj(TANGPROJ,concount,constr,get_coord(tail),s,q,NULL,
; 873  :       NO_DETECT,tail);
; 874  :   qq = SDIM_dot(q,q);
; 875  :   sprenergy = ss*sqrt(qq/(ss - qq))/12;
; 876  : 
; 877  :   constr_proj(TANGPROJ,concount,constr,get_coord(head),s,q,NULL,
; 878  :       NO_DETECT,head);
; 879  :   qq = SDIM_dot(q,q);
; 880  :   sprenergy += ss*sqrt(qq/(ss - qq))/12;
; 881  : #endif
; 882  : 
; 883  :   sprenergy *= web.spring_constant;

	fld	QWORD PTR _web+1584

; 884  :   binary_tree_add(web.total_energy_addends,sprenergy);

	sub	esp, 8
	fmul	QWORD PTR _sprenergy$[ebp]
	fst	QWORD PTR _sprenergy$[ebp]
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1248
	call	_binary_tree_add

; 885  :   web.spring_energy += sprenergy;

	fld	QWORD PTR _web+1488
	fadd	QWORD PTR _sprenergy$[ebp]
	add	esp, 12					; 0000000cH
	fstp	QWORD PTR _web+1488
$LN32@constr_spr:
	pop	ebx
$LN14@constr_spr:

; 886  : 
; 887  : } // end constr_spring_energy()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_constr_spring_energy ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@KDOKIEGB@Vertex?5?$CFs?5on?5too?5many?5convex?5con@ ; `string'
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_constr_springs
EXTRN	_eval_second:PROC
;	COMDAT ??_C@_0CL@KDOKIEGB@Vertex?5?$CFs?5on?5too?5many?5convex?5con@
CONST	SEGMENT
??_C@_0CL@KDOKIEGB@Vertex?5?$CFs?5on?5too?5many?5convex?5con@ DB 'Vertex '
	DB	'%s on too many convex constraints.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _constr_springs
_TEXT	SEGMENT
_secondqXvS$ = -552					; size = 24
_constr$ = -528						; size = 28
tv455 = -500						; size = 8
_fval$89864 = -500					; size = 8
_ss$ = -492						; size = 8
_concount$ = -484					; size = 4
tv508 = -480						; size = 4
tv544 = -476						; size = 8
tv562 = -468						; size = 8
_tail$ = -460						; size = 4
_head$ = -456						; size = 4
tv393 = -452						; size = 8
tv251 = -452						; size = 8
tv186 = -452						; size = 8
_ft$ = -444						; size = 4
tv550 = -440						; size = 8
tv182 = -440						; size = 8
_t$89868 = -432						; size = 8
_fs$89867 = -424					; size = 8
tv1004 = -420						; size = 4
tv846 = -420						; size = 4
tv540 = -416						; size = 8
tv526 = -416						; size = 8
tv498 = -408						; size = 4
tv448 = -408						; size = 4
_ff$89866 = -404					; size = 8
_e_id$GSCopy$ = -396					; size = 4
_fh$ = -396						; size = 4
_i$ = -392						; size = 4
_j$ = -392						; size = 4
_secondxJ$ = -388					; size = 288
_s$ = -100						; size = 48
_grad$89865 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_constr_springs PROC					; COMDAT

; 908  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 552				; 00000228H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _e_id$[ebp]

; 909  :   REAL s[MAXCOORD],*fh,*ft;
; 910  :   REAL ss; /* square lengths */
; 911  :   struct constraint *constr[MAXCONHIT];
; 912  :   int concount;
; 913  :   conmap_t * conmap;
; 914  :   vertex_id head,tail;
; 915  :   int i,j; 
; 916  :   MAT2D(second,MAXCOORD,MAXCOORD); /* for second partials */

	push	6
	push	6
	lea	eax, DWORD PTR _secondxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _secondqXvS$[ebp]
	push	ecx

; 917  : 
; 918  :   if ( get_eattr(e_id) & FIXED ) return;

	mov	DWORD PTR _e_id$GSCopy$[ebp], edi
	call	_mat2d_setup
	mov	edx, DWORD PTR _web+124
	mov	ebx, eax
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR tv448[ebp], eax
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR tv455[ebp+4], eax
	mov	eax, ecx
	and	eax, 64					; 00000040H
	xor	edx, edx
	add	esp, 16					; 00000010H
	or	eax, edx
	jne	$LN11@constr_spr@2

; 919  :   if ( !(get_eattr(e_id) & CONSTRAINT) ) return;

	and	ecx, 1024				; 00000400H
	or	ecx, eax
	je	$LN11@constr_spr@2

; 920  : 
; 921  :   tail = get_edge_tailv(e_id);

	push	edi
	call	_get_edge_tailv

; 922  :   head = get_edge_headv(e_id);

	push	edi
	mov	DWORD PTR _tail$[ebp], eax
	call	_get_edge_headv

; 923  : 
; 924  :   /* find which constraints have CONVEX attribute */
; 925  :   conmap = get_e_constraint_map(e_id);

	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR _head$[ebp], eax
	mov	eax, DWORD PTR _web+216
	add	esp, 8
	cmp	DWORD PTR [eax+ecx+1048], 0
	je	SHORT $LN24@constr_spr@2
	mov	edi, DWORD PTR [eax+ecx+1024]
	add	edi, esi
	jmp	SHORT $LN25@constr_spr@2
$LN24@constr_spr@2:
	mov	edi, OFFSET _nullcon
$LN25@constr_spr@2:

; 926  :   for ( j = 1,i=0 ; j <= (int)conmap[0] ; j++ )

	mov	edx, 1
	xor	esi, esi
	mov	DWORD PTR _j$[ebp], edx
	cmp	DWORD PTR [edi], edx
	jl	$LN11@constr_spr@2
	npad	1
$LL19@constr_spr@2:

; 927  :   { constr[i] = get_constraint(conmap[j]);

	mov	ecx, DWORD PTR [edi+edx*4]
	mov	eax, DWORD PTR _web+652
	and	ecx, 1073741823				; 3fffffffH
	imul	ecx, 176				; 000000b0H
	add	eax, ecx
	mov	DWORD PTR _constr$[ebp+esi*4], eax

; 928  :     if ( constr[i]->attr & B_CONVEX )

	mov	eax, DWORD PTR [eax+32]
	and	eax, 8
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN18@constr_spr@2

; 929  :     {
; 930  :       if ( i >= MAXCONHIT )

	cmp	esi, 7
	jl	SHORT $LN39@constr_spr@2

; 931  :       { sprintf(errmsg,"Vertex %s on too many convex constraints.\n",
; 932  :             ELNAME(e_id));

	test	DWORD PTR _e_id$GSCopy$[ebp], 268435456	; 10000000H
	je	SHORT $LN26@constr_spr@2
	mov	ecx, DWORD PTR tv448[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN27@constr_spr@2
$LN26@constr_spr@2:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN27@constr_spr@2:
	push	eax
	push	OFFSET ??_C@_0CL@KDOKIEGB@Vertex?5?$CFs?5on?5too?5many?5convex?5con@
	push	OFFSET _errmsg
	call	_sprintf

; 933  :         kb_error(5885,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5885					; 000016fdH
	call	_kb_error
	mov	edx, DWORD PTR _j$[ebp]
	add	esp, 24					; 00000018H
$LN39@constr_spr@2:

; 934  :       }
; 935  :       i++;    /* keep this one */

	inc	esi
$LN18@constr_spr@2:

; 926  :   for ( j = 1,i=0 ; j <= (int)conmap[0] ; j++ )

	inc	edx
	mov	DWORD PTR _j$[ebp], edx
	cmp	edx, DWORD PTR [edi]
	jle	$LL19@constr_spr@2

; 936  :     }
; 937  :   }
; 938  :   if ( i == 0 ) return;

	test	esi, esi
	je	$LN11@constr_spr@2

; 939  :   concount = i;  
; 940  : 
; 941  :   /* now the calculation */
; 942  :   get_edge_side(e_id,s);

	mov	eax, DWORD PTR _e_id$GSCopy$[ebp]
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	push	eax
	mov	DWORD PTR _concount$[ebp], esi
	call	_get_edge_side

; 943  :   ss = SDIM_dot(s,s);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	fstp	QWORD PTR _ss$[ebp]

; 944  :   ft = get_force(tail);

	mov	edi, DWORD PTR _tail$[ebp]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+ecx+784]
	mov	ecx, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+ecx]
	add	eax, edx
	mov	DWORD PTR _ft$[ebp], eax

; 945  :   fh = get_force(head);

	mov	eax, DWORD PTR _head$[ebp]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv508[ebp], eax
	mov	eax, DWORD PTR [eax+ecx]
	add	eax, edx
	add	esp, 20					; 00000014H
	mov	DWORD PTR tv498[ebp], edi
	mov	DWORD PTR _fh$[ebp], eax

; 946  : 
; 947  : #ifndef OLDWAYX
; 948  :   for ( i = 0 ; i < concount ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	esi, esi
	jle	$LN11@constr_spr@2
	mov	eax, DWORD PTR _web+616
	jmp	SHORT $LN13@constr_spr@2
	npad	9
$LL36@constr_spr@2:
	mov	ecx, DWORD PTR _web+12
$LN13@constr_spr@2:

; 949  :   { REAL *coord;
; 950  :     REAL fval,grad[MAXCOORD];
; 951  :     REAL ff,fs,t;
; 952  : 
; 953  :     coord = get_coord(tail);
; 954  :     eval_second(constr[i]->formula,coord,SDIM,&fval,grad,second,tail);

	mov	esi, DWORD PTR _tail$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _constr$[ebp+edx*4]
	mov	edx, DWORD PTR [edx+40]
	push	esi
	push	ebx
	lea	esi, DWORD PTR _grad$89865[ebp]
	push	esi
	lea	esi, DWORD PTR _fval$89864[ebp]
	push	esi
	mov	esi, DWORD PTR _dymem
	push	eax
	mov	eax, DWORD PTR [edi+ecx]
	mov	ecx, DWORD PTR _web+104
	add	eax, DWORD PTR [ecx+esi+64]
	push	eax
	push	edx
	call	_eval_second

; 955  :     ff = SDIM_dot(grad,grad);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _grad$89865[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fst	QWORD PTR _ff$89866[ebp]

; 956  :     if ( ff <= 0.0 ) ff = 1;

	fldz
	add	esp, 40					; 00000028H
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN10@constr_spr@2
	fld1
	fstp	QWORD PTR _ff$89866[ebp]
$LN10@constr_spr@2:

; 957  :     fs = SDIM_dot(s,grad);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _grad$89865[ebp]
	push	ecx
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_dot
	fstp	QWORD PTR _fs$89867[ebp]

; 958  :     t = sqrt(ss/ff);

	fld	QWORD PTR _ss$[ebp]
	add	esp, 12					; 0000000cH
	fdiv	QWORD PTR _ff$89866[ebp]
	fst	QWORD PTR tv526[ebp]
	call	__CIsqrt
	fst	QWORD PTR _t$89868[ebp]

; 959  :     if ( fs < 0.0 ) t = -t;  /* to take care of fabs() */

	fldz
	fld	QWORD PTR _fs$89867[ebp]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN9@constr_spr@2
	fxch	ST(1)
	fchs
	fst	QWORD PTR _t$89868[ebp]
	fxch	ST(1)
$LN9@constr_spr@2:

; 960  :     for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	xor	esi, esi
	test	eax, eax
	jle	$LN46@constr_spr@2
	fld	QWORD PTR tv526[ebp]
	mov	ecx, DWORD PTR _ft$[ebp]
	fld	QWORD PTR _ff$89866[ebp]
	lea	edx, DWORD PTR _s$[ebp]
	fdiv	ST(1), ST(0)
	sub	ecx, edx
	mov	DWORD PTR tv846[ebp], ecx
	fxch	ST(1)
	fstp	QWORD PTR tv540[ebp]
	fxch	ST(1)
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR tv544[ebp]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR tv562[ebp]
	jmp	SHORT $LN8@constr_spr@2
	npad	10
$LL37@constr_spr@2:
	fld	QWORD PTR _ff$89866[ebp]
$LN8@constr_spr@2:

; 961  :     { REAL g;
; 962  :       g = -t*grad[j] + t*SDIM_dot(s,second[j]) 
; 963  :                     + fs/t*(-s[j]/ff - ss/ff/ff*SDIM_dot(grad,second[j]));

	fdivr	QWORD PTR _s$[ebp+esi*8]
	lea	edi, DWORD PTR _s$[ebp+esi*8]
	push	eax
	mov	eax, DWORD PTR [ebx+esi*4]
	push	eax
	lea	ecx, DWORD PTR _grad$89865[ebp]
	push	ecx
	fchs
	fstp	QWORD PTR tv182[ebp]
	call	_dot
	fmul	QWORD PTR tv540[ebp]
	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [ebx+esi*4]
	push	edx
	fsubr	QWORD PTR tv182[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	fmul	QWORD PTR tv544[ebp]
	fstp	QWORD PTR tv186[ebp]
	fld	QWORD PTR _grad$89865[ebp+esi*8]
	fmul	QWORD PTR _t$89868[ebp]
	fstp	QWORD PTR tv550[ebp]
	call	_dot
	fmul	QWORD PTR _t$89868[ebp]

; 964  :       ft[j] -= web.spring_constant*g/12;

	mov	eax, DWORD PTR tv846[ebp]
	fld	QWORD PTR tv550[ebp]
	inc	esi
	add	esp, 24					; 00000018H
	fsub	ST(1), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR tv186[ebp]
	fmul	QWORD PTR _web+1584
	fld	QWORD PTR __real@4028000000000000
	fdiv	ST(1), ST(0)
	fld	QWORD PTR [eax+edi]
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [eax+edi]

; 965  :       g = t*grad[j] + fs/t/ff*s[j];
; 966  :       fh[j] -= web.spring_constant*g/12;

	mov	eax, DWORD PTR _fh$[ebp]
	fld	QWORD PTR tv562[ebp]
	fmul	QWORD PTR [edi]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR _web+1584
	fdivrp	ST(1), ST(0)
	fsubr	QWORD PTR [eax+esi*8-8]
	fstp	QWORD PTR [eax+esi*8-8]
	mov	eax, DWORD PTR _web+616
	cmp	esi, eax
	jl	$LL37@constr_spr@2

; 960  :     for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR tv498[ebp]
	jmp	SHORT $LN6@constr_spr@2
$LN46@constr_spr@2:
	fstp	ST(1)
	fstp	ST(0)
$LN6@constr_spr@2:

; 967  :     }
; 968  :     coord = get_coord(head);
; 969  :     eval_second(constr[i]->formula,coord,SDIM,&fval,grad,second,head);

	mov	edx, DWORD PTR _head$[ebp]
	push	edx
	push	ebx
	lea	ecx, DWORD PTR _grad$89865[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv508[ebp]
	lea	edx, DWORD PTR _fval$89864[ebp]
	push	edx
	push	eax
	mov	eax, DWORD PTR _web+12
	mov	edx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+64]
	push	edx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _constr$[ebp+edx*4]
	mov	eax, DWORD PTR [eax+40]
	push	eax
	call	_eval_second

; 970  :     ff = SDIM_dot(grad,grad);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _grad$89865[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	fst	QWORD PTR _ff$89866[ebp]

; 971  :     if ( ff <= 0.0 ) ff = 1;

	fldz
	add	esp, 40					; 00000028H
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN5@constr_spr@2
	fld1
	fstp	QWORD PTR _ff$89866[ebp]
$LN5@constr_spr@2:

; 972  :     fs = SDIM_dot(s,grad);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _grad$89865[ebp]
	push	edx
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_dot
	fstp	QWORD PTR _fs$89867[ebp]

; 973  :     t = sqrt(ss/ff);

	fld	QWORD PTR _ss$[ebp]
	add	esp, 12					; 0000000cH
	fdiv	QWORD PTR _ff$89866[ebp]
	fst	QWORD PTR tv526[ebp]
	call	__CIsqrt
	fst	QWORD PTR _t$89868[ebp]

; 974  :     if ( fs < 0.0 ) t = -t;  /* to take care of fabs() */

	fldz
	fld	QWORD PTR _fs$89867[ebp]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN4@constr_spr@2
	fxch	ST(1)
	fchs
	fst	QWORD PTR _t$89868[ebp]
	fxch	ST(1)
$LN4@constr_spr@2:

; 975  :     for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	xor	esi, esi
	test	eax, eax
	jle	$LN54@constr_spr@2
	fld	QWORD PTR tv526[ebp]
	mov	ecx, DWORD PTR _fh$[ebp]
	fld	QWORD PTR _ff$89866[ebp]
	lea	edx, DWORD PTR _grad$89865[ebp]
	fdiv	ST(1), ST(0)
	sub	ecx, edx
	mov	DWORD PTR tv1004[ebp], ecx
	fxch	ST(1)
	fstp	QWORD PTR tv540[ebp]
	fxch	ST(1)
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR tv544[ebp]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR tv562[ebp]
	jmp	SHORT $LN3@constr_spr@2
	npad	1
$LL38@constr_spr@2:
	fld	QWORD PTR _ff$89866[ebp]
$LN3@constr_spr@2:

; 976  :     { REAL g;
; 977  :       g = t*grad[j] + t*SDIM_dot(s,second[j]) 
; 978  :                    + fs/t*(s[j]/ff - ss/ff/ff*SDIM_dot(grad,second[j]));

	fdivr	QWORD PTR _s$[ebp+esi*8]
	push	eax
	mov	eax, DWORD PTR [ebx+esi*4]
	push	eax
	lea	ecx, DWORD PTR _grad$89865[ebp]
	push	ecx
	fstp	QWORD PTR tv251[ebp]
	call	_dot
	fmul	QWORD PTR tv540[ebp]
	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [ebx+esi*4]
	lea	edi, DWORD PTR _grad$89865[ebp+esi*8]
	fsubr	QWORD PTR tv251[ebp]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	fmul	QWORD PTR tv544[ebp]
	push	ecx
	fstp	QWORD PTR tv393[ebp]
	fld	QWORD PTR [edi]
	fmul	QWORD PTR _t$89868[ebp]
	fstp	QWORD PTR tv550[ebp]
	call	_dot
	fmul	QWORD PTR _t$89868[ebp]

; 979  :       fh[j] -= web.spring_constant*g/12;

	mov	eax, DWORD PTR tv1004[ebp]
	fld	QWORD PTR tv550[ebp]
	inc	esi
	add	esp, 24					; 00000018H
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR tv393[ebp]
	fmul	QWORD PTR _web+1584
	fld	QWORD PTR __real@4028000000000000
	fdiv	ST(1), ST(0)
	fld	QWORD PTR [eax+edi]
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [eax+edi]

; 980  :       g = -t*grad[j] - fs/t/ff*s[j];
; 981  :       ft[j] -= web.spring_constant*g/12;

	mov	eax, DWORD PTR _ft$[ebp]
	fxch	ST(1)
	fchs
	fld	QWORD PTR tv562[ebp]
	fmul	QWORD PTR _s$[ebp+esi*8-8]
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR _web+1584
	fdivrp	ST(1), ST(0)
	fsubr	QWORD PTR [eax+esi*8-8]
	fstp	QWORD PTR [eax+esi*8-8]
	mov	eax, DWORD PTR _web+616
	cmp	esi, eax
	jl	$LL38@constr_spr@2

; 975  :     for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR tv498[ebp]
	jmp	SHORT $LN12@constr_spr@2
$LN54@constr_spr@2:
	fstp	ST(1)
	fstp	ST(0)
$LN12@constr_spr@2:

; 946  : 
; 947  : #ifndef OLDWAYX
; 948  :   for ( i = 0 ; i < concount ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, DWORD PTR _concount$[ebp]
	jl	$LL36@constr_spr@2
$LN11@constr_spr@2:

; 982  :     }
; 983  :   }
; 984  : #endif
; 985  : 
; 986  : #ifdef OLDWAYX
; 987  : 
; 988  :   /*tail*/
; 989  :   constr_proj(TANGPROJ,concount,constr,get_coord(tail),s,q,NULL,
; 990  :       NO_DETECT,tail);
; 991  :   for ( i = 0 ; i < SDIM ; i++ )
; 992  :      q[i] = s[i] - q[i];    /* get tangent side */
; 993  :   qq = SDIM_dot(q,q);
; 994  :   norm = (1 + (ss-qq)/3/qq)*sqrt(fabs(ss-qq)/qq)/2; /* fabs due to machine inaccuracy */
; 995  :   for ( i = 0 ; i < SDIM ; i++ )
; 996  :      ft[i] += web.spring_constant*q[i]*norm;
; 997  : 
; 998  : 
; 999  :   /* head */
; 1000 :   constr_proj(TANGPROJ,concount,constr,get_coord(head),s,q,NULL,
; 1001 :       NO_DETECT,head);
; 1002 :   for ( i = 0 ; i < SDIM ; i++ )
; 1003 :      q[i] = s[i] - q[i];    /* get tangent side */
; 1004 :   qq = SDIM_dot(q,q);
; 1005 :   norm = (1 + (ss-qq)/3/qq)*sqrt(fabs(ss-qq)/qq)/2;
; 1006 :   for ( i = 0 ; i < SDIM ; i++ )
; 1007 :      fh[i] -= web.spring_constant*q[i]*norm;
; 1008 : #endif 
; 1009 : 
; 1010 : } // end constr_springs()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_constr_springs ENDP
_TEXT	ENDS
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_constr_edge_energy_q
EXTRN	_gauss2wt:BYTE
EXTRN	_gcombo:BYTE
EXTRN	_sdip:BYTE
; Function compile flags: /Ogtp
;	COMDAT _constr_edge_energy_q
_TEXT	SEGMENT
_pt$ = -376						; size = 12
_e_id$GSCopy$ = -364					; size = 4
_energy$ = -360						; size = 8
_j$ = -352						; size = 4
_sign$ = -348						; size = 4
_conmap$ = -344						; size = 4
_side$ = -340						; size = 48
_green$ = -292						; size = 48
_x$ = -244						; size = 144
_gpt$ = -100						; size = 48
_etang$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_constr_edge_energy_q PROC				; COMDAT

; 1030 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 376				; 00000178H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1031 :   REAL x[EDGE_CTRL][MAXCOORD];
; 1032 :   REAL *pt[EDGE_CTRL];
; 1033 :   REAL etang[MAXCOORD];
; 1034 :   vertex_id v[EDGE_CTRL];
; 1035 :   int i,j,k;
; 1036 :   struct constraint *constr;
; 1037 :   REAL energy = 0.0;

	fldz
	push	ebx
	push	esi
	fstp	QWORD PTR _energy$[ebp]
	push	edi
	mov	edi, DWORD PTR _e_id$[ebp]

; 1038 :   REAL side[MAXCOORD];
; 1039 :   REAL green[MAXCOORD];
; 1040 :   conmap_t *conmap;
; 1041 :   int sign;
; 1042 :   REAL gpt[MAXCOORD];
; 1043 :           
; 1044 :   int_val = ordinal(get_original(e_id))+1;  /* for eval  of file parameters */

	mov	eax, edi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [edx+20]

; 1076 :         green[k] = eval(constr->envect[k],gpt,e_id,NULL); 

	mov	DWORD PTR _e_id$GSCopy$[ebp], edi
	test	eax, 268435456				; 10000000H
	je	SHORT $LN31@constr_edg

; 1038 :   REAL side[MAXCOORD];
; 1039 :   REAL green[MAXCOORD];
; 1040 :   conmap_t *conmap;
; 1041 :   int sign;
; 1042 :   REAL gpt[MAXCOORD];
; 1043 :           
; 1044 :   int_val = ordinal(get_original(e_id))+1;  /* for eval  of file parameters */

	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN32@constr_edg
$LN31@constr_edg:
	or	eax, -1
$LN32@constr_edg:

; 1045 :   conmap = get_e_constraint_map(e_id);

	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	inc	eax
	mov	DWORD PTR _int_val, eax
	cmp	DWORD PTR [ecx+edx+1048], 0
	je	SHORT $LN33@constr_edg
	mov	eax, DWORD PTR _web+124
	mov	eax, DWORD PTR [esi+eax]
	add	eax, DWORD PTR [ecx+edx+1024]
	mov	DWORD PTR _conmap$[ebp], eax
	jmp	SHORT $LN34@constr_edg
$LN33@constr_edg:
	mov	DWORD PTR _conmap$[ebp], OFFSET _nullcon
$LN34@constr_edg:

; 1046 :   get_edge_side(e_id,side);

	lea	ecx, DWORD PTR _side$[ebp]
	push	ecx
	push	edi
	call	_get_edge_side

; 1047 :   if ( get_eattr(e_id) & NEGBOUNDARY ) sign = -1;

	mov	edx, DWORD PTR _web+124
	mov	esi, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	add	esp, 8
	or	eax, ecx
	mov	DWORD PTR _sign$[ebp], -1
	jne	SHORT $LN27@constr_edg

; 1048 :   else sign = 1;

	mov	DWORD PTR _sign$[ebp], 1
$LN27@constr_edg:

; 1049 :                   
; 1050 :   v[0] = get_edge_tailv(e_id);

	mov	ebx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ebx+304]
	shr	edi, 27					; 0000001bH
	and	edi, 1
	je	SHORT $LN36@constr_edg
	add	eax, esi
	mov	edx, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN35@constr_edg
$LN36@constr_edg:
	mov	edx, DWORD PTR [eax+esi]
	add	eax, esi
$LN35@constr_edg:

; 1051 :   v[1] = get_edge_midv(e_id);

	mov	esi, DWORD PTR [eax+8]

; 1052 :   v[2] = get_edge_headv(e_id);

	test	edi, edi
	je	SHORT $LN40@constr_edg
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN39@constr_edg
$LN40@constr_edg:
	mov	ecx, DWORD PTR [eax+ecx*4]
$LN39@constr_edg:

; 1053 :   for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 1054 :     pt[i] = get_coord(v[i]);

	mov	edi, DWORD PTR _web+12
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ebx+64]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	add	edx, eax
	mov	DWORD PTR _pt$[ebp], edx
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+esi*4]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	add	edx, eax
	add	ecx, eax
	mov	DWORD PTR _pt$[ebp+4], edx
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR _pt$[ebp+8], ecx

; 1055 : 
; 1056 :   for ( i = 0 ; i < EDGE_CTRL ; i++ )

	xor	eax, eax
	lea	ebx, DWORD PTR _x$[ebp]
	npad	6
$LL23@constr_edg:

; 1057 :      for ( j = 0 ; j < SDIM ; j++ )

	test	edx, edx
	jle	SHORT $LN22@constr_edg
	mov	esi, DWORD PTR _pt$[ebp+eax*4]
	mov	ecx, edx
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	mov	edi, ebx
	rep movsd
$LN22@constr_edg:

; 1055 : 
; 1056 :   for ( i = 0 ; i < EDGE_CTRL ; i++ )

	inc	eax
	add	ebx, 48					; 00000030H
	cmp	eax, 3
	jl	SHORT $LL23@constr_edg

; 1058 :         x[i][j] = pt[i][j];
; 1059 :              
; 1060 :      
; 1061 :   /* calculate tangents at integration points and accumulate */
; 1062 :   for ( i = 0 ; i < EDGE_INTERP ; i++ )

	fldz
	xor	edi, edi
$LN68@constr_edg:

; 1063 :   { for ( j = 0 ; j < SDIM ; j ++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN12@constr_edg
$LN14@constr_edg:

; 1064 :     { etang[j] = 0.0;

	fst	QWORD PTR _etang$[ebp+eax*8]
	inc	eax

; 1065 :       gpt[j] = 0.0;

	fst	QWORD PTR _gpt$[ebp+eax*8-8]

; 1066 :       for ( k = 0 ; k < EDGE_CTRL ; k++ )
; 1067 :       { etang[j] += sdip[k][i]*x[k][j];

	fld	QWORD PTR _sdip[edi]
	fmul	QWORD PTR _x$[ebp+eax*8-8]
	fadd	QWORD PTR _etang$[ebp+eax*8-8]
	fld	QWORD PTR _x$[ebp+eax*8+40]
	fmul	QWORD PTR _sdip[edi+24]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _x$[ebp+eax*8+88]
	fmul	QWORD PTR _sdip[edi+48]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _etang$[ebp+eax*8-8]

; 1068 :         gpt[j] += gcombo[k][i]*x[k][j];

	fld	QWORD PTR _gcombo[edi]
	fmul	QWORD PTR _x$[ebp+eax*8-8]
	fadd	QWORD PTR _gpt$[ebp+eax*8-8]
	fld	QWORD PTR _gcombo[edi+24]
	fmul	QWORD PTR _x$[ebp+eax*8+40]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _gcombo[edi+48]
	fmul	QWORD PTR _x$[ebp+eax*8+88]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _gpt$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LN14@constr_edg
$LN12@constr_edg:

; 1069 :       }
; 1070 :     }
; 1071 :     for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _conmap$[ebp]
	mov	ebx, 1
	mov	DWORD PTR _j$[ebp], ebx
	cmp	DWORD PTR [eax], ebx
	jl	$LN16@constr_edg
$LN69@constr_edg:

; 1072 :     { constr = get_constraint(conmap[j]);

	mov	ecx, DWORD PTR _conmap$[ebp]
	mov	eax, DWORD PTR [ecx+ebx*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 1073 :       if ( !(constr->attr & CON_ENERGY) ) continue;

	xor	esi, esi
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 64					; 00000040H
	or	ecx, esi
	je	SHORT $LN7@constr_edg

; 1074 :       if ( constr->compcount != SDIM ) continue;

	cmp	DWORD PTR [eax+44], edx
	jne	SHORT $LN7@constr_edg
	fstp	ST(0)

; 1075 :       for ( k = 0 ; k < SDIM ; k++ )

	test	edx, edx
	jle	SHORT $LN1@constr_edg
	lea	ebx, DWORD PTR [eax+48]
	npad	4
$LL3@constr_edg:

; 1076 :         green[k] = eval(constr->envect[k],gpt,e_id,NULL); 

	mov	edx, DWORD PTR _e_id$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ebx]
	push	0
	push	edx
	lea	eax, DWORD PTR _gpt$[ebp]
	push	eax
	push	ecx
	call	_eval
	fstp	QWORD PTR _green$[ebp+esi*8]
	mov	edx, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	add	ebx, 4
	cmp	esi, edx
	jl	SHORT $LL3@constr_edg
$LN1@constr_edg:

; 1077 :       energy += sign*gauss2wt[i]*SDIM_dot(etang,green);

	push	edx
	lea	edx, DWORD PTR _green$[ebp]
	push	edx
	lea	eax, DWORD PTR _etang$[ebp]
	push	eax
	call	_dot
	fild	DWORD PTR _sign$[ebp]
	mov	edx, DWORD PTR _web+616
	mov	ebx, DWORD PTR _j$[ebp]
	fmul	QWORD PTR _gauss2wt[edi]
	add	esp, 12					; 0000000cH
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR _energy$[ebp]
	fstp	QWORD PTR _energy$[ebp]
	fldz
$LN7@constr_edg:

; 1069 :       }
; 1070 :     }
; 1071 :     for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	ecx, DWORD PTR _conmap$[ebp]
	inc	ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, DWORD PTR [ecx]
	jle	$LN69@constr_edg
$LN16@constr_edg:

; 1058 :         x[i][j] = pt[i][j];
; 1059 :              
; 1060 :      
; 1061 :   /* calculate tangents at integration points and accumulate */
; 1062 :   for ( i = 0 ; i < EDGE_INTERP ; i++ )

	add	edi, 8
	cmp	edi, 24					; 00000018H
	jl	$LN68@constr_edg
	fstp	ST(0)

; 1078 :     }
; 1079 :   }
; 1080 :      
; 1081 :   binary_tree_add(web.total_energy_addends,energy);

	sub	esp, 8
	fld	QWORD PTR _energy$[ebp]
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1248
	call	_binary_tree_add

; 1082 : 
; 1083 : }  // end constr_edge_energy_q()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_constr_edge_energy_q ENDP
_TEXT	ENDS
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_constr_edge_force_q
; Function compile flags: /Ogtp
;	COMDAT _constr_edge_force_q
_TEXT	SEGMENT
_pt$ = -724						; size = 12
_force$ = -712						; size = 12
_e_id$GSCopy$ = -700					; size = 4
_m$ = -696						; size = 4
_sign$ = -692						; size = 4
_conmap$ = -688						; size = 4
tv1282 = -684						; size = 4
_j$ = -684						; size = 4
tv1712 = -680						; size = 4
_k$ = -680						; size = 4
_green_deriv$ = -676					; size = 288
_side$ = -388						; size = 48
_green$ = -340						; size = 48
_x$ = -292						; size = 144
_tangdot$90028 = -148					; size = 48
_etang$ = -100						; size = 48
_gpt$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_constr_edge_force_q PROC				; COMDAT

; 1097 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 724				; 000002d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _e_id$[ebp]

; 1098 :   REAL x[EDGE_CTRL][MAXCOORD];
; 1099 :   REAL *pt[EDGE_CTRL];
; 1100 :   REAL etang[MAXCOORD];
; 1101 :   vertex_id v[EDGE_CTRL];
; 1102 :   int i,j,k,m,n;
; 1103 :   struct constraint *constr;
; 1104 :   REAL side[MAXCOORD];
; 1105 :   REAL green[MAXCOORD];
; 1106 :   REAL green_deriv[MAXCOORD][MAXCOORD];
; 1107 :   conmap_t *conmap;
; 1108 :   int sign;
; 1109 :   REAL gpt[MAXCOORD];
; 1110 :   REAL *force[EDGE_CTRL];
; 1111 :           
; 1112 :   int_val = ordinal(get_original(e_id))+1;  /* for eval  of file parameters */

	mov	eax, edi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [edx+20]

; 1153 :           force[k][n] -= sign*gauss2wt[i]*gcombo[k][i]*tangdot[n];

	mov	DWORD PTR _e_id$GSCopy$[ebp], edi
	test	eax, 268435456				; 10000000H
	je	SHORT $LN46@constr_edg@2

; 1098 :   REAL x[EDGE_CTRL][MAXCOORD];
; 1099 :   REAL *pt[EDGE_CTRL];
; 1100 :   REAL etang[MAXCOORD];
; 1101 :   vertex_id v[EDGE_CTRL];
; 1102 :   int i,j,k,m,n;
; 1103 :   struct constraint *constr;
; 1104 :   REAL side[MAXCOORD];
; 1105 :   REAL green[MAXCOORD];
; 1106 :   REAL green_deriv[MAXCOORD][MAXCOORD];
; 1107 :   conmap_t *conmap;
; 1108 :   int sign;
; 1109 :   REAL gpt[MAXCOORD];
; 1110 :   REAL *force[EDGE_CTRL];
; 1111 :           
; 1112 :   int_val = ordinal(get_original(e_id))+1;  /* for eval  of file parameters */

	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN47@constr_edg@2
$LN46@constr_edg@2:
	or	eax, -1
$LN47@constr_edg@2:

; 1113 :   conmap = get_e_constraint_map(e_id);

	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	inc	eax
	mov	DWORD PTR _int_val, eax
	cmp	DWORD PTR [ecx+edx+1048], 0
	je	SHORT $LN48@constr_edg@2
	mov	eax, DWORD PTR _web+124
	mov	eax, DWORD PTR [esi+eax]
	add	eax, DWORD PTR [ecx+edx+1024]
	mov	DWORD PTR _conmap$[ebp], eax
	jmp	SHORT $LN49@constr_edg@2
$LN48@constr_edg@2:
	mov	DWORD PTR _conmap$[ebp], OFFSET _nullcon
$LN49@constr_edg@2:

; 1114 :   get_edge_side(e_id,side);

	lea	ecx, DWORD PTR _side$[ebp]
	push	ecx
	push	edi
	call	_get_edge_side

; 1115 :   if ( get_eattr(e_id) & NEGBOUNDARY ) sign = -1;

	mov	edx, DWORD PTR _web+124
	mov	esi, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	add	esp, 8
	or	eax, ecx
	mov	DWORD PTR _sign$[ebp], -1
	jne	SHORT $LN42@constr_edg@2

; 1116 :   else sign = 1;

	mov	DWORD PTR _sign$[ebp], 1
$LN42@constr_edg@2:

; 1117 :                   
; 1118 :   v[0] = get_edge_tailv(e_id);

	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	ebx, DWORD PTR _web+636
	mov	edx, DWORD PTR [eax+ecx+304]
	shr	edi, 27					; 0000001bH
	and	edi, 1
	je	SHORT $LN51@constr_edg@2
	add	edx, esi
	mov	eax, DWORD PTR [edx+ebx*4]
	jmp	SHORT $LN50@constr_edg@2
$LN51@constr_edg@2:
	mov	eax, DWORD PTR [edx+esi]
	add	edx, esi
$LN50@constr_edg@2:

; 1119 :   v[1] = get_edge_midv(e_id);

	mov	esi, DWORD PTR [edx+8]

; 1120 :   v[2] = get_edge_headv(e_id);

	test	edi, edi
	je	SHORT $LN55@constr_edg@2
	mov	edx, DWORD PTR [edx]
	jmp	SHORT $LN54@constr_edg@2
$LN55@constr_edg@2:
	mov	edx, DWORD PTR [edx+ebx*4]
$LN54@constr_edg@2:

; 1121 :   for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 1122 :   { pt[i] = get_coord(v[i]);

	mov	edi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	DWORD PTR tv1282[ebp], ebx
	add	ebx, eax
	mov	DWORD PTR _pt$[ebp], ebx

; 1123 :     force[i] = get_force(v[i]);

	mov	ebx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ebx+ecx+784]
	mov	ebx, DWORD PTR tv1282[ebp]
	and	esi, 134217727				; 07ffffffH
	add	ebx, ecx
	lea	esi, DWORD PTR [edi+esi*4]
	mov	DWORD PTR _force$[ebp], ebx
	mov	ebx, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi]
	and	edx, 134217727				; 07ffffffH
	add	esi, ecx
	lea	edx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR _force$[ebp+4], esi
	mov	esi, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx]
	add	ebx, eax
	add	esi, eax
	mov	eax, DWORD PTR _web+616
	add	edx, ecx
	mov	DWORD PTR _pt$[ebp+4], ebx
	mov	DWORD PTR _force$[ebp+8], edx
	mov	DWORD PTR _pt$[ebp+8], esi

; 1124 :   }
; 1125 :   for ( i = 0 ; i < EDGE_CTRL ; i++ )

	xor	edx, edx
	lea	ebx, DWORD PTR _x$[ebp]
	npad	7
$LL95@constr_edg@2:

; 1126 :      for ( j = 0 ; j < SDIM ; j++ )

	test	eax, eax
	jle	SHORT $LN37@constr_edg@2
	mov	esi, DWORD PTR _pt$[ebp+edx*4]
	mov	ecx, eax
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	mov	edi, ebx
	rep movsd
$LN37@constr_edg@2:

; 1124 :   }
; 1125 :   for ( i = 0 ; i < EDGE_CTRL ; i++ )

	inc	edx
	add	ebx, 48					; 00000030H
	cmp	edx, 3
	jl	SHORT $LL95@constr_edg@2

; 1127 :         x[i][j] = pt[i][j];
; 1128 :              
; 1129 :   /* calculate tangents at integration points and accumulate */
; 1130 :   for ( i = 0 ; i < EDGE_INTERP ; i++ )

	fldz
	xor	edi, edi
$LN96@constr_edg@2:

; 1131 :   { for ( j = 0 ; j < SDIM ; j ++ )

	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN27@constr_edg@2
$LN29@constr_edg@2:

; 1132 :     { etang[j] = 0.0;

	fst	QWORD PTR _etang$[ebp+ecx*8]
	inc	ecx

; 1133 :       gpt[j] = 0.0;

	fst	QWORD PTR _gpt$[ebp+ecx*8-8]

; 1134 :       for ( k = 0 ; k < EDGE_CTRL ; k++ )
; 1135 :       { etang[j] += sdip[k][i]*x[k][j];

	fld	QWORD PTR _sdip[edi]
	fmul	QWORD PTR _x$[ebp+ecx*8-8]
	fadd	QWORD PTR _etang$[ebp+ecx*8-8]
	fld	QWORD PTR _x$[ebp+ecx*8+40]
	fmul	QWORD PTR _sdip[edi+24]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _sdip[edi+48]
	fmul	QWORD PTR _x$[ebp+ecx*8+88]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _etang$[ebp+ecx*8-8]

; 1136 :         gpt[j] += gcombo[k][i]*x[k][j];

	fld	QWORD PTR _x$[ebp+ecx*8-8]
	fmul	QWORD PTR _gcombo[edi]
	fadd	QWORD PTR _gpt$[ebp+ecx*8-8]
	fld	QWORD PTR _x$[ebp+ecx*8+40]
	fmul	QWORD PTR _gcombo[edi+24]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _x$[ebp+ecx*8+88]
	fmul	QWORD PTR _gcombo[edi+48]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _gpt$[ebp+ecx*8-8]
	cmp	ecx, eax
	jl	SHORT $LN29@constr_edg@2
$LN27@constr_edg@2:

; 1137 :       }
; 1138 :     }
; 1139 :     for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	ecx, DWORD PTR _conmap$[ebp]
	mov	ebx, 1
	mov	DWORD PTR _j$[ebp], ebx
	cmp	DWORD PTR [ecx], ebx
	jl	$LN31@constr_edg@2
$LN94@constr_edg@2:

; 1140 :     { REAL tangdot[MAXCOORD];
; 1141 :       constr = get_constraint(conmap[j]);

	mov	edx, DWORD PTR _conmap$[ebp]
	mov	ecx, DWORD PTR [edx+ebx*4]
	and	ecx, 1073741823				; 3fffffffH
	imul	ecx, 176				; 000000b0H
	add	ecx, DWORD PTR _web+652

; 1142 :       if ( !(constr->attr & CON_ENERGY) ) continue;

	xor	esi, esi
	mov	edx, DWORD PTR [ecx+32]
	and	edx, 64					; 00000040H
	or	edx, esi
	je	$LN22@constr_edg@2

; 1143 :       if ( constr->compcount != SDIM ) continue;

	cmp	DWORD PTR [ecx+44], eax
	jne	$LN22@constr_edg@2

; 1144 :       for ( m = 0 ; m < SDIM ; m++ )

	mov	DWORD PTR _m$[ebp], esi
	test	eax, eax
	jle	SHORT $LN16@constr_edg@2
	lea	edx, DWORD PTR _green$[ebp]
	fstp	ST(0)
	mov	DWORD PTR tv1712[ebp], edx
	lea	ebx, DWORD PTR _green_deriv$[ebp]
	lea	esi, DWORD PTR [ecx+48]
	npad	3
$LL92@constr_edg@2:

; 1145 :         eval_all(constr->envect[m],gpt,SDIM,&green[m],green_deriv[m],e_id);

	mov	ecx, DWORD PTR _e_id$GSCopy$[ebp]
	mov	edx, DWORD PTR tv1712[ebp]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	push	ebx
	push	edx
	push	eax
	lea	eax, DWORD PTR _gpt$[ebp]
	push	eax
	push	ecx
	call	_eval_all
	mov	ecx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR _web+616
	add	DWORD PTR tv1712[ebp], 8
	inc	ecx
	add	esp, 24					; 00000018H
	add	esi, 4
	add	ebx, 48					; 00000030H
	mov	DWORD PTR _m$[ebp], ecx
	cmp	ecx, eax
	jl	SHORT $LL92@constr_edg@2

; 1144 :       for ( m = 0 ; m < SDIM ; m++ )

	fldz
$LN16@constr_edg@2:

; 1146 :       for ( n = 0 ; n < SDIM ; n++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN13@constr_edg@2
$LN93@constr_edg@2:

; 1147 :         for ( m = 0, tangdot[n] = 0.0 ; m < SDIM ; m++ )

	fst	QWORD PTR _tangdot$90028[ebp+esi*8]
	xor	ecx, ecx
	lea	edx, DWORD PTR _green_deriv$[ebp+esi*8]
$LN12@constr_edg@2:

; 1148 :           tangdot[n] += etang[m]*green_deriv[m][n];

	fld	QWORD PTR _etang$[ebp+ecx*8]
	inc	ecx
	fmul	QWORD PTR [edx]
	add	edx, 48					; 00000030H
	fadd	QWORD PTR _tangdot$90028[ebp+esi*8]
	fstp	QWORD PTR _tangdot$90028[ebp+esi*8]
	cmp	ecx, eax
	jl	SHORT $LN12@constr_edg@2

; 1146 :       for ( n = 0 ; n < SDIM ; n++ )

	inc	esi
	cmp	esi, eax
	jl	SHORT $LN93@constr_edg@2
$LN13@constr_edg@2:

; 1149 :       for ( k = 0 ; k < EDGE_CTRL ; k++ )

	xor	ecx, ecx
	mov	DWORD PTR _k$[ebp], ecx
	mov	esi, edi
$LN97@constr_edg@2:

; 1150 :       { for ( m = 0 ; m < SDIM ; m++ )

	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN4@constr_edg@2
	mov	ecx, DWORD PTR _force$[ebp+ecx*4]
	fild	DWORD PTR _sign$[ebp]
	lea	ebx, DWORD PTR _green$[ebp]
	sub	ebx, ecx
$LN6@constr_edg@2:

; 1151 :           force[k][m] -= sign*gauss2wt[i]*sdip[k][i]*green[m];

	fld	QWORD PTR _gauss2wt[edi]
	inc	edx
	fmul	ST(0), ST(1)
	add	ecx, 8
	fmul	QWORD PTR _sdip[esi]
	fmul	QWORD PTR [ebx+ecx-8]
	fsubr	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
	mov	eax, DWORD PTR _web+616
	cmp	edx, eax
	jl	SHORT $LN6@constr_edg@2

; 1150 :       { for ( m = 0 ; m < SDIM ; m++ )

	mov	ecx, DWORD PTR _k$[ebp]
	fstp	ST(0)
$LN4@constr_edg@2:

; 1152 :         for ( n = 0 ; n < SDIM ; n++ )

	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN8@constr_edg@2
	mov	ecx, DWORD PTR _force$[ebp+ecx*4]
	fild	DWORD PTR _sign$[ebp]
	lea	ebx, DWORD PTR _tangdot$90028[ebp]
	sub	ebx, ecx
$LN3@constr_edg@2:

; 1153 :           force[k][n] -= sign*gauss2wt[i]*gcombo[k][i]*tangdot[n];

	fld	QWORD PTR _gauss2wt[edi]
	inc	edx
	fmul	ST(0), ST(1)
	add	ecx, 8
	fmul	QWORD PTR _gcombo[esi]
	fmul	QWORD PTR [ebx+ecx-8]
	fsubr	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
	mov	eax, DWORD PTR _web+616
	cmp	edx, eax
	jl	SHORT $LN3@constr_edg@2

; 1152 :         for ( n = 0 ; n < SDIM ; n++ )

	mov	ecx, DWORD PTR _k$[ebp]
	fstp	ST(0)
$LN8@constr_edg@2:

; 1149 :       for ( k = 0 ; k < EDGE_CTRL ; k++ )

	inc	ecx
	add	esi, 24					; 00000018H
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ecx, 3
	jl	$LN97@constr_edg@2
	mov	ebx, DWORD PTR _j$[ebp]
$LN22@constr_edg@2:

; 1137 :       }
; 1138 :     }
; 1139 :     for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	edx, DWORD PTR _conmap$[ebp]
	inc	ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, DWORD PTR [edx]
	jle	$LN94@constr_edg@2
$LN31@constr_edg@2:

; 1127 :         x[i][j] = pt[i][j];
; 1128 :              
; 1129 :   /* calculate tangents at integration points and accumulate */
; 1130 :   for ( i = 0 ; i < EDGE_INTERP ; i++ )

	add	edi, 8
	cmp	edi, 24					; 00000018H
	jl	$LN96@constr_edg@2

; 1154 :       }              
; 1155 :     }
; 1156 :   }
; 1157 : } // end constr_edge_force_q()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_constr_edge_force_q ENDP
_TEXT	ENDS
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_constr_edge_content_q
; Function compile flags: /Ogtp
;	COMDAT _constr_edge_content_q
_TEXT	SEGMENT
_pt$ = -384						; size = 12
tv932 = -372						; size = 4
tv902 = -368						; size = 4
_e_id$GSCopy$ = -364					; size = 4
_content$ = -360					; size = 8
_sign$ = -352						; size = 4
_j$ = -348						; size = 4
_first_fe$ = -344					; size = 4
_conmap$ = -344						; size = 4
_side$ = -340						; size = 48
_green$ = -292						; size = 48
_x$ = -244						; size = 144
_etang$ = -100						; size = 48
_gpt$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_constr_edge_content_q PROC				; COMDAT

; 1171 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 384				; 00000180H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1172 :   REAL x[EDGE_CTRL][MAXCOORD];
; 1173 :   REAL *pt[EDGE_CTRL];
; 1174 :   REAL etang[MAXCOORD];
; 1175 :   vertex_id v[EDGE_CTRL];
; 1176 :   int i,j,k;
; 1177 :   struct constraint *constr;
; 1178 :   REAL content = 0.0;

	fldz
	push	ebx
	push	esi
	fstp	QWORD PTR _content$[ebp]
	push	edi
	mov	edi, DWORD PTR _e_id$[ebp]

; 1179 :   REAL side[MAXCOORD];
; 1180 :   REAL green[MAXCOORD];
; 1181 :   conmap_t * conmap;
; 1182 :   int sign;
; 1183 :   REAL gpt[MAXCOORD];
; 1184 :   body_id b_id;
; 1185 :   facet_id f_id;
; 1186 :   facetedge_id fe_id = get_edge_fe(e_id);
; 1187 :   facetedge_id first_fe;
; 1188 :           
; 1189 :   int_val = ordinal(get_original(e_id))+1;  /* for eval  of file parameters */

	mov	eax, edi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _e_id$GSCopy$[ebp], edi
	mov	DWORD PTR tv902[ebp], esi
	test	eax, 268435456				; 10000000H
	je	SHORT $LN40@constr_edg@3
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN41@constr_edg@3
$LN40@constr_edg@3:
	or	eax, -1
$LN41@constr_edg@3:

; 1190 :   conmap = get_e_constraint_map(e_id);

	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	inc	eax
	mov	DWORD PTR _int_val, eax
	cmp	DWORD PTR [ecx+edx+1048], 0
	je	SHORT $LN42@constr_edg@3
	mov	eax, DWORD PTR _web+124
	mov	eax, DWORD PTR [esi+eax]
	add	eax, DWORD PTR [ecx+edx+1024]
	mov	DWORD PTR _conmap$[ebp], eax
	jmp	SHORT $LN43@constr_edg@3
$LN42@constr_edg@3:
	mov	DWORD PTR _conmap$[ebp], OFFSET _nullcon
$LN43@constr_edg@3:

; 1191 :   get_edge_side(e_id,side);

	lea	ecx, DWORD PTR _side$[ebp]
	push	ecx
	push	edi
	call	_get_edge_side

; 1192 :   if ( get_eattr(e_id) & NEGBOUNDARY ) sign = -1;

	mov	edx, DWORD PTR _web+124
	mov	esi, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	add	esp, 8
	or	eax, ecx
	mov	DWORD PTR _sign$[ebp], -1
	jne	SHORT $LN36@constr_edg@3

; 1193 :   else sign = 1;

	mov	DWORD PTR _sign$[ebp], 1
$LN36@constr_edg@3:

; 1194 :                   
; 1195 :   v[0] = get_edge_tailv(e_id);

	mov	ebx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ebx+304]
	shr	edi, 27					; 0000001bH
	and	edi, 1
	mov	DWORD PTR tv932[ebp], edi
	je	SHORT $LN49@constr_edg@3
	add	eax, esi
	mov	edx, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN48@constr_edg@3
$LN49@constr_edg@3:
	mov	edx, DWORD PTR [eax+esi]
	add	eax, esi
$LN48@constr_edg@3:

; 1196 :   v[1] = get_edge_midv(e_id);

	mov	esi, DWORD PTR [eax+8]

; 1197 :   v[2] = get_edge_headv(e_id);

	test	edi, edi
	je	SHORT $LN53@constr_edg@3
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $LN52@constr_edg@3
$LN53@constr_edg@3:
	mov	ecx, DWORD PTR [eax+ecx*4]
$LN52@constr_edg@3:

; 1198 :   for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 1199 :     pt[i] = get_coord(v[i]);

	mov	edi, DWORD PTR _web+12
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ebx+64]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	add	edx, eax
	mov	DWORD PTR _pt$[ebp], edx
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+esi*4]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	add	edx, eax
	add	ecx, eax
	mov	DWORD PTR _pt$[ebp+4], edx
	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR _pt$[ebp+8], ecx

; 1200 : 
; 1201 :   for ( i = 0 ; i < EDGE_CTRL ; i++ )

	xor	eax, eax
	lea	ebx, DWORD PTR _x$[ebp]
$LL32@constr_edg@3:

; 1202 :      for ( j = 0 ; j < SDIM ; j++ )

	test	edx, edx
	jle	SHORT $LN31@constr_edg@3
	mov	esi, DWORD PTR _pt$[ebp+eax*4]
	mov	ecx, edx
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	mov	edi, ebx
	rep movsd
$LN31@constr_edg@3:

; 1200 : 
; 1201 :   for ( i = 0 ; i < EDGE_CTRL ; i++ )

	inc	eax
	add	ebx, 48					; 00000030H
	cmp	eax, 3
	jl	SHORT $LL32@constr_edg@3

; 1203 :         x[i][j] = pt[i][j];
; 1204 :              
; 1205 :      
; 1206 :   /* calculate tangents at integration points and accumulate */
; 1207 :   for ( i = 0 ; i < EDGE_INTERP ; i++ )

	fldz
	xor	edi, edi
$LN111@constr_edg@3:

; 1208 :   { for ( j = 0 ; j < SDIM ; j ++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN21@constr_edg@3
$LN23@constr_edg@3:

; 1209 :     { etang[j] = 0.0;

	fst	QWORD PTR _etang$[ebp+eax*8]
	inc	eax

; 1210 :       gpt[j] = 0.0;

	fst	QWORD PTR _gpt$[ebp+eax*8-8]

; 1211 :       for ( k = 0 ; k < EDGE_CTRL ; k++ )
; 1212 :       { etang[j] += sdip[k][i]*x[k][j];

	fld	QWORD PTR _x$[ebp+eax*8-8]
	fmul	QWORD PTR _sdip[edi]
	fadd	QWORD PTR _etang$[ebp+eax*8-8]
	fld	QWORD PTR _x$[ebp+eax*8+40]
	fmul	QWORD PTR _sdip[edi+24]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _x$[ebp+eax*8+88]
	fmul	QWORD PTR _sdip[edi+48]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _etang$[ebp+eax*8-8]

; 1213 :         gpt[j] += gcombo[k][i]*x[k][j];

	fld	QWORD PTR _x$[ebp+eax*8-8]
	fmul	QWORD PTR _gcombo[edi]
	fadd	QWORD PTR _gpt$[ebp+eax*8-8]
	fld	QWORD PTR _x$[ebp+eax*8+40]
	fmul	QWORD PTR _gcombo[edi+24]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _gcombo[edi+48]
	fmul	QWORD PTR _x$[ebp+eax*8+88]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _gpt$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LN23@constr_edg@3
$LN21@constr_edg@3:

; 1214 :       }
; 1215 :     }
; 1216 :     for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _conmap$[ebp]
	mov	ebx, 1
	mov	DWORD PTR _j$[ebp], ebx
	cmp	DWORD PTR [eax], ebx
	jl	$LN25@constr_edg@3
$LN112@constr_edg@3:

; 1217 :     { constr = get_constraint(conmap[j]);

	mov	ecx, DWORD PTR _conmap$[ebp]
	mov	eax, DWORD PTR [ecx+ebx*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 1218 :       if ( !(constr->attr & CON_CONTENT) ) continue;

	xor	esi, esi
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 128				; 00000080H
	or	ecx, esi
	je	SHORT $LN16@constr_edg@3

; 1219 :       if ( constr->compcount != SDIM ) continue;

	cmp	DWORD PTR [eax+44], edx
	jne	SHORT $LN16@constr_edg@3
	fstp	ST(0)

; 1220 :         for ( k = 0 ; k < SDIM ; k++ )

	test	edx, edx
	jle	SHORT $LN10@constr_edg@3
	lea	ebx, DWORD PTR [eax+108]
$LL12@constr_edg@3:

; 1221 :           green[k] = eval(constr->convect[k],gpt,e_id,NULL);

	mov	edx, DWORD PTR _e_id$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ebx]
	push	0
	push	edx
	lea	eax, DWORD PTR _gpt$[ebp]
	push	eax
	push	ecx
	call	_eval
	fstp	QWORD PTR _green$[ebp+esi*8]
	mov	edx, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	add	ebx, 4
	cmp	esi, edx
	jl	SHORT $LL12@constr_edg@3
$LN10@constr_edg@3:

; 1222 :       content += sign*gauss2wt[i]*SDIM_dot(etang,green);

	push	edx
	lea	edx, DWORD PTR _green$[ebp]
	push	edx
	lea	eax, DWORD PTR _etang$[ebp]
	push	eax
	call	_dot
	fild	DWORD PTR _sign$[ebp]
	mov	edx, DWORD PTR _web+616
	mov	ebx, DWORD PTR _j$[ebp]
	fmul	QWORD PTR _gauss2wt[edi]
	add	esp, 12					; 0000000cH
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR _content$[ebp]
	fstp	QWORD PTR _content$[ebp]
	fldz
$LN16@constr_edg@3:

; 1214 :       }
; 1215 :     }
; 1216 :     for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	ecx, DWORD PTR _conmap$[ebp]
	inc	ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, DWORD PTR [ecx]
	jle	$LN112@constr_edg@3
$LN25@constr_edg@3:

; 1203 :         x[i][j] = pt[i][j];
; 1204 :              
; 1205 :      
; 1206 :   /* calculate tangents at integration points and accumulate */
; 1207 :   for ( i = 0 ; i < EDGE_INTERP ; i++ )

	add	edi, 8
	cmp	edi, 24					; 00000018H
	jl	$LN111@constr_edg@3

; 1223 :     }
; 1224 :   }
; 1225 :      
; 1226 :   fe_id = first_fe = get_edge_fe(e_id);

	mov	edx, DWORD PTR _web+124
	fstp	ST(0)
	mov	eax, DWORD PTR tv902[ebp]
	mov	eax, DWORD PTR [eax+edx]
	test	eax, eax
	jne	SHORT $LN57@constr_edg@3
	mov	DWORD PTR _first_fe$[ebp], eax
	jmp	SHORT $LN58@constr_edg@3
$LN57@constr_edg@3:
	cmp	DWORD PTR tv932[ebp], 0
	mov	eax, DWORD PTR [eax+28]
	je	SHORT $LN113@constr_edg@3
	xor	eax, 134217728				; 08000000H
$LN113@constr_edg@3:
	mov	DWORD PTR _first_fe$[ebp], eax
$LN58@constr_edg@3:
	mov	eax, DWORD PTR _first_fe$[ebp]
	mov	edi, eax

; 1227 :   if ( valid_id(fe_id) ) do

	shr	eax, 28					; 0000001cH
	test	al, 1
	je	$LN6@constr_edg@3
	mov	ebx, DWORD PTR _web+460
	npad	4
$LL8@constr_edg@3:

; 1228 :   { /* cell on plus side of edge */
; 1229 :     f_id = get_fe_facet(fe_id);

	test	al, 1
	jne	SHORT $LN61@constr_edg@3
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN60@constr_edg@3
$LN61@constr_edg@3:
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+ecx*4]
	mov	esi, DWORD PTR [edx+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN60@constr_edg@3
	xor	esi, 134217728				; 08000000H
$LN60@constr_edg@3:

; 1230 :     if ( valid_id(f_id) && !(get_fattr(f_id) & NONCONTENT) ) 

	test	esi, 268435456				; 10000000H
	je	$LN114@constr_edg@3
	mov	ecx, DWORD PTR _web+236
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 536870912				; 20000000H
	xor	edx, edx
	or	eax, edx
	jne	SHORT $LN114@constr_edg@3

; 1231 :     {
; 1232 :       b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, edx
	jne	SHORT $LN67@constr_edg@3
	xor	ecx, ecx
	jmp	SHORT $LN64@constr_edg@3
$LN67@constr_edg@3:
	test	esi, 134217728				; 08000000H
	je	SHORT $LN65@constr_edg@3
	mov	edx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+784]
	mov	ecx, DWORD PTR [edx+ecx+4]
	jmp	SHORT $LN64@constr_edg@3
$LN65@constr_edg@3:
	mov	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+784]
	mov	ecx, DWORD PTR [ecx+eax]
$LN64@constr_edg@3:

; 1233 :       if ( valid_id(b_id) )

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN114@constr_edg@3

; 1234 :         add_body_volume(b_id,content);

	fld	QWORD PTR _content$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	call	_add_body_volume
	mov	ebx, DWORD PTR _web+460
	add	esp, 12					; 0000000cH
$LN114@constr_edg@3:

; 1235 :     }
; 1236 : 
; 1237 :     /* cell on other side of edge */
; 1238 :     f_id = get_fe_facet(inverse_id(fe_id));

	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN71@constr_edg@3
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN70@constr_edg@3
$LN71@constr_edg@3:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+ecx*4]
	mov	esi, DWORD PTR [edx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN70@constr_edg@3
	xor	esi, 134217728				; 08000000H
$LN70@constr_edg@3:

; 1239 :     if ( valid_id(f_id) && !(get_fattr(f_id) & NONCONTENT) ) 

	test	esi, 268435456				; 10000000H
	je	$LN115@constr_edg@3
	mov	ecx, DWORD PTR _web+236
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 536870912				; 20000000H
	xor	edx, edx
	or	eax, edx
	jne	SHORT $LN115@constr_edg@3

; 1240 :     {
; 1241 :       b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, edx
	jne	SHORT $LN77@constr_edg@3
	xor	ecx, ecx
	jmp	SHORT $LN74@constr_edg@3
$LN77@constr_edg@3:
	test	esi, 134217728				; 08000000H
	je	SHORT $LN75@constr_edg@3
	mov	edx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+784]
	mov	ecx, DWORD PTR [edx+ecx+4]
	jmp	SHORT $LN74@constr_edg@3
$LN75@constr_edg@3:
	mov	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+784]
	mov	ecx, DWORD PTR [ecx+eax]
$LN74@constr_edg@3:

; 1242 :       if ( valid_id(b_id) )

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN115@constr_edg@3

; 1243 :         add_body_volume(b_id,-content);

	fld	QWORD PTR _content$[ebp]
	sub	esp, 8
	fchs
	fstp	QWORD PTR [esp]
	push	ecx
	call	_add_body_volume
	mov	ebx, DWORD PTR _web+460
	add	esp, 12					; 0000000cH
$LN115@constr_edg@3:

; 1244 :     }
; 1245 :     fe_id = get_next_facet(fe_id);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN81@constr_edg@3
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+edi*4]
	mov	edi, DWORD PTR [ecx+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN7@constr_edg@3
$LN81@constr_edg@3:
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edi*4]
	mov	edi, DWORD PTR [edx+40]
$LN7@constr_edg@3:

; 1246 :   } while ( valid_id(fe_id) && !equal_id(fe_id,first_fe) );

	mov	eax, edi
	shr	eax, 28					; 0000001cH
	test	al, 1
	je	SHORT $LN6@constr_edg@3
	cmp	edi, DWORD PTR _first_fe$[ebp]
	jne	$LL8@constr_edg@3
$LN6@constr_edg@3:

; 1247 : 
; 1248 :   return;
; 1249 : 
; 1250 : } // end constr_edge_content_q()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_constr_edge_content_q ENDP
_TEXT	ENDS
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_constr_vol_grad_q
EXTRN	_get_vertex_vgrad:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT _constr_vol_grad_q
_TEXT	SEGMENT
_pt$ = -832						; size = 12
tv966 = -820						; size = 4
tv996 = -816						; size = 4
_e_id$GSCopy$ = -812					; size = 4
_start_fe$ = -812					; size = 4
_m$ = -808						; size = 4
_sign$ = -804						; size = 4
_f_id$ = -800						; size = 4
_j$ = -800						; size = 4
tv2260 = -796						; size = 4
_bodysign$ = -796					; size = 4
_fe$ = -792						; size = 4
_conmap$ = -792						; size = 4
tv2415 = -788						; size = 4
tv1818 = -788						; size = 4
tv169 = -788						; size = 4
_green_deriv$ = -784					; size = 288
_grad$ = -496						; size = 144
_green$ = -352						; size = 48
_x$ = -304						; size = 144
_tangdot$90214 = -160					; size = 48
_etang$ = -112						; size = 48
_gpt$ = -64						; size = 48
_v$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_constr_vol_grad_q PROC					; COMDAT

; 1263 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 832				; 00000340H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _e_id$[ebp]

; 1264 :   REAL x[EDGE_CTRL][MAXCOORD];
; 1265 :   REAL *pt[EDGE_CTRL];
; 1266 :   REAL etang[MAXCOORD];
; 1267 :   vertex_id v[EDGE_CTRL];
; 1268 :   int i,j,k;
; 1269 :   REAL green[MAXCOORD];
; 1270 :   REAL green_deriv[MAXCOORD][MAXCOORD];
; 1271 :   struct constraint *constr;
; 1272 :   int m,n;
; 1273 :   REAL grad[EDGE_CTRL][MAXCOORD];
; 1274 :   conmap_t * conmap;
; 1275 :   int sign,bodysign=1;
; 1276 :   REAL gpt[MAXCOORD];
; 1277 :   struct volgrad *vgptri;
; 1278 :   facet_id f_id;
; 1279 :   facetedge_id fe,start_fe;
; 1280 : 
; 1281 :   int_val = ordinal(get_original(e_id))+1;  /* for eval  of file parameters */

	mov	ecx, edi
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [edx+eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR _e_id$GSCopy$[ebp], edi
	mov	DWORD PTR tv966[ebp], eax
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN65@constr_vol
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN66@constr_vol
$LN65@constr_vol:
	or	ecx, -1
$LN66@constr_vol:

; 1282 :   /* get basic edge data */          
; 1283 :   conmap = get_e_constraint_map(e_id);

	mov	ebx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR _web+124
	inc	ecx
	mov	DWORD PTR _int_val, ecx
	cmp	DWORD PTR [ebx+edx+1048], 0
	je	SHORT $LN67@constr_vol
	mov	ecx, DWORD PTR [eax+esi]
	add	ecx, DWORD PTR [ebx+edx+1024]
	mov	DWORD PTR _conmap$[ebp], ecx
	jmp	SHORT $LN68@constr_vol
$LN67@constr_vol:
	mov	DWORD PTR _conmap$[ebp], OFFSET _nullcon
$LN68@constr_vol:

; 1284 :   if ( get_eattr(e_id) & NEGBOUNDARY ) sign = -1;

	mov	ecx, DWORD PTR [eax+esi]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 256				; 00000100H
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR _sign$[ebp], -1
	jne	SHORT $LN61@constr_vol

; 1285 :   else sign = 1;

	mov	DWORD PTR _sign$[ebp], 1
$LN61@constr_vol:

; 1286 :                   
; 1287 :   v[0] = get_edge_tailv(e_id);

	mov	eax, DWORD PTR [ebx+edx+304]
	shr	edi, 27					; 0000001bH
	and	edi, 1
	mov	DWORD PTR tv996[ebp], edi
	je	SHORT $LN70@constr_vol
	add	eax, ecx
	mov	ecx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN69@constr_vol
$LN70@constr_vol:
	add	eax, ecx
	mov	ecx, DWORD PTR [eax]
$LN69@constr_vol:

; 1288 :   v[1] = get_edge_midv(e_id);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR _v$[ebp], ecx
	mov	DWORD PTR _v$[ebp+4], esi

; 1289 :   v[2] = get_edge_headv(e_id);

	test	edi, edi
	je	SHORT $LN74@constr_vol
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN73@constr_vol
$LN74@constr_vol:
	mov	edi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edi*4]
$LN73@constr_vol:

; 1290 :   for ( i = 0 ; i < EDGE_CTRL ; i++ )
; 1291 :      pt[i] = get_coord(v[i]);

	mov	edi, DWORD PTR _web+104
	mov	edx, DWORD PTR [edi+edx+64]
	mov	edi, DWORD PTR _web+12
	mov	ebx, DWORD PTR _web+616
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR _v$[ebp+8], eax
	add	ecx, edx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	and	esi, 134217727				; 07ffffffH
	mov	DWORD PTR _pt$[ebp], ecx
	mov	ecx, DWORD PTR [edi+esi*4]
	add	eax, edx
	add	ecx, edx
	mov	DWORD PTR _pt$[ebp+8], eax
	mov	DWORD PTR _pt$[ebp+4], ecx

; 1292 :   for ( i = 0 ; i < EDGE_CTRL ; i++ )

	xor	eax, eax
	lea	edx, DWORD PTR _x$[ebp]
	npad	2
$LL57@constr_vol:

; 1293 :      for ( j = 0 ; j < SDIM ; j++ )

	test	ebx, ebx
	jle	SHORT $LN56@constr_vol
	mov	esi, DWORD PTR _pt$[ebp+eax*4]
	mov	ecx, ebx
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	mov	edi, edx
	rep movsd
$LN56@constr_vol:

; 1292 :   for ( i = 0 ; i < EDGE_CTRL ; i++ )

	inc	eax
	add	edx, 48					; 00000030H
	cmp	eax, 3
	jl	SHORT $LL57@constr_vol

; 1294 :         x[i][j] = pt[i][j];
; 1295 :              
; 1296 :   memset((char *)grad,0,sizeof(grad));

	push	144					; 00000090H
	lea	ecx, DWORD PTR _grad$[ebp]
	push	0
	push	ecx
	call	_memset
	fldz
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv2260[ebp], 0
$LN51@constr_vol:

; 1300 :   { /* calculate coords and tangents at integration point */
; 1301 :     for ( j = 0 ; j < SDIM ; j ++ )

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN137@constr_vol
	mov	ecx, DWORD PTR tv2260[ebp]
$LN48@constr_vol:

; 1302 :     { etang[j] = 0.0;

	fst	QWORD PTR _etang$[ebp+eax*8]
	inc	eax

; 1303 :       gpt[j] = 0.0;

	fst	QWORD PTR _gpt$[ebp+eax*8-8]

; 1304 :       for ( k = 0 ; k < EDGE_CTRL ; k++ )
; 1305 :       { etang[j] += sdip[k][i]*x[k][j];

	fld	QWORD PTR _sdip[ecx]
	fmul	QWORD PTR _x$[ebp+eax*8-8]
	fadd	QWORD PTR _etang$[ebp+eax*8-8]
	fld	QWORD PTR _sdip[ecx+24]
	fmul	QWORD PTR _x$[ebp+eax*8+40]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _sdip[ecx+48]
	fmul	QWORD PTR _x$[ebp+eax*8+88]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _etang$[ebp+eax*8-8]

; 1306 :         gpt[j] += gcombo[k][i]*x[k][j];

	fld	QWORD PTR _x$[ebp+eax*8-8]
	fmul	QWORD PTR _gcombo[ecx]
	fadd	QWORD PTR _gpt$[ebp+eax*8-8]
	fld	QWORD PTR _x$[ebp+eax*8+40]
	fmul	QWORD PTR _gcombo[ecx+24]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _x$[ebp+eax*8+88]
	fmul	QWORD PTR _gcombo[ecx+48]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _gpt$[ebp+eax*8-8]
	cmp	eax, ebx
	jl	SHORT $LN48@constr_vol
$LN137@constr_vol:

; 1307 :       }
; 1308 :     }
; 1309 :  
; 1310 :     /* accumulate gradients due to this integration point */
; 1311 :     for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	edx, DWORD PTR _conmap$[ebp]
	cmp	DWORD PTR [edx], 1
	mov	DWORD PTR _j$[ebp], 1
	jl	$LN50@constr_vol
$LN42@constr_vol:

; 1312 :     { REAL tangdot[MAXCOORD];
; 1313 : 
; 1314 :       constr = get_constraint(conmap[j]);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _conmap$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 1315 :       if ( !(constr->attr & CON_CONTENT) ) continue;

	xor	edx, edx
	mov	ecx, DWORD PTR [eax+32]
	and	ecx, 128				; 00000080H
	or	ecx, edx
	je	$LN41@constr_vol

; 1316 :       if ( constr->compcount != SDIM ) continue;

	cmp	DWORD PTR [eax+44], ebx
	jne	$LN41@constr_vol

; 1317 :       for ( m = 0 ; m < SDIM ; m++ )

	mov	DWORD PTR _m$[ebp], edx
	test	ebx, ebx
	jle	SHORT $LN35@constr_vol
	lea	edx, DWORD PTR _green$[ebp]
	fstp	ST(0)
	mov	DWORD PTR tv1818[ebp], edx
	lea	edi, DWORD PTR _green_deriv$[ebp]
	lea	esi, DWORD PTR [eax+108]
	npad	7
$LL37@constr_vol:

; 1318 :         eval_all(constr->convect[m],gpt,SDIM,&green[m],green_deriv[m],e_id); 

	mov	eax, DWORD PTR _e_id$GSCopy$[ebp]
	mov	ecx, DWORD PTR tv1818[ebp]
	push	eax
	mov	eax, DWORD PTR [esi]
	push	edi
	push	ecx
	push	ebx
	lea	edx, DWORD PTR _gpt$[ebp]
	push	edx
	push	eax
	call	_eval_all
	mov	eax, DWORD PTR _m$[ebp]
	mov	ebx, DWORD PTR _web+616
	add	DWORD PTR tv1818[ebp], 8
	inc	eax
	add	esp, 24					; 00000018H
	add	esi, 4
	add	edi, 48					; 00000030H
	mov	DWORD PTR _m$[ebp], eax
	cmp	eax, ebx
	jl	SHORT $LL37@constr_vol

; 1317 :       for ( m = 0 ; m < SDIM ; m++ )

	fldz
$LN35@constr_vol:

; 1319 :       for ( n = 0 ; n < SDIM ; n++ )

	xor	edx, edx
	test	ebx, ebx
	jle	SHORT $LN138@constr_vol
$LN34@constr_vol:

; 1320 :         for ( m = 0, tangdot[n] = 0.0 ; m < SDIM ; m++ )

	fst	QWORD PTR _tangdot$90214[ebp+edx*8]
	xor	eax, eax
	lea	ecx, DWORD PTR _green_deriv$[ebp+edx*8]
$LN31@constr_vol:

; 1321 :           tangdot[n] += etang[m]*green_deriv[m][n];

	fld	QWORD PTR _etang$[ebp+eax*8]
	inc	eax
	fmul	QWORD PTR [ecx]
	add	ecx, 48					; 00000030H
	fadd	QWORD PTR _tangdot$90214[ebp+edx*8]
	fstp	QWORD PTR _tangdot$90214[ebp+edx*8]
	cmp	eax, ebx
	jl	SHORT $LN31@constr_vol

; 1319 :       for ( n = 0 ; n < SDIM ; n++ )

	inc	edx
	cmp	edx, ebx
	jl	SHORT $LN34@constr_vol
$LN138@constr_vol:

; 1322 :       for ( k = 0 ; k < EDGE_CTRL ; k++ )

	mov	edi, DWORD PTR tv2260[ebp]
	lea	esi, DWORD PTR _grad$[ebp]
	mov	edx, edi
	mov	DWORD PTR tv169[ebp], 3
$LN28@constr_vol:

; 1323 :       { for ( m = 0 ; m < SDIM ; m++ )

	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN23@constr_vol
	fild	DWORD PTR _sign$[ebp]
	mov	eax, esi
	fmul	QWORD PTR _gauss2wt[edi]
	fmul	QWORD PTR _sdip[edx]
$LN25@constr_vol:

; 1324 :           grad[k][m] += sign*gauss2wt[i]*sdip[k][i]*green[m];

	fld	QWORD PTR _green$[ebp+ecx*8]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, ebx
	jl	SHORT $LN25@constr_vol

; 1323 :       { for ( m = 0 ; m < SDIM ; m++ )

	fstp	ST(0)
$LN23@constr_vol:

; 1325 :         for ( n = 0 ; n < SDIM ; n++ )

	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN27@constr_vol
	fild	DWORD PTR _sign$[ebp]
	mov	eax, esi
	fmul	QWORD PTR _gauss2wt[edi]
	fmul	QWORD PTR _gcombo[edx]
$LN22@constr_vol:

; 1326 :           grad[k][n] += sign*gauss2wt[i]*gcombo[k][i]*tangdot[n];

	fld	QWORD PTR _tangdot$90214[ebp+ecx*8]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, ebx
	jl	SHORT $LN22@constr_vol

; 1325 :         for ( n = 0 ; n < SDIM ; n++ )

	fstp	ST(0)
$LN27@constr_vol:

; 1322 :       for ( k = 0 ; k < EDGE_CTRL ; k++ )

	add	edx, 24					; 00000018H
	add	esi, 48					; 00000030H
	dec	DWORD PTR tv169[ebp]
	jne	SHORT $LN28@constr_vol
$LN41@constr_vol:

; 1307 :       }
; 1308 :     }
; 1309 :  
; 1310 :     /* accumulate gradients due to this integration point */
; 1311 :     for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _conmap$[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR [ecx]
	jle	$LN42@constr_vol
$LN50@constr_vol:

; 1297 : 
; 1298 :   /* find content integral gradients */     
; 1299 :   for ( i = 0 ; i < EDGE_INTERP ; i++ )

	mov	eax, DWORD PTR tv2260[ebp]
	add	eax, 8
	mov	DWORD PTR tv2260[ebp], eax
	cmp	eax, 24					; 00000018H
	jl	$LN51@constr_vol

; 1327 :       }              
; 1328 :     }
; 1329 :   }
; 1330 : 
; 1331 :   /* now add gradients to proper bodies */
; 1332 :   fe = start_fe = get_edge_fe(e_id);

	mov	edx, DWORD PTR _web+124
	fstp	ST(0)
	mov	eax, DWORD PTR tv966[ebp]
	mov	eax, DWORD PTR [eax+edx]
	test	eax, eax
	je	SHORT $LN77@constr_vol
$LN78@constr_vol:
	cmp	DWORD PTR tv996[ebp], 0
	mov	eax, DWORD PTR [eax+28]
	je	SHORT $LN77@constr_vol
	xor	eax, 134217728				; 08000000H
$LN77@constr_vol:
	mov	DWORD PTR _start_fe$[ebp], eax
	mov	ebx, eax

; 1333 :   if ( valid_id(start_fe) )

	test	eax, 268435456				; 10000000H
	je	$LN16@constr_vol
	mov	edx, DWORD PTR _web+460
	npad	6
$LL18@constr_vol:

; 1334 :     do
; 1335 :     { f_id = get_fe_facet(fe);

	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN82@constr_vol
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN81@constr_vol
$LN82@constr_vol:
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax+24]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN81@constr_vol
	xor	eax, 134217728				; 08000000H
$LN81@constr_vol:
	mov	DWORD PTR _f_id$[ebp], eax

; 1336 :       fe = get_next_facet(fe);

	test	ebx, 134217728				; 08000000H
	je	SHORT $LN86@constr_vol
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	ebx, DWORD PTR [ecx+36]
	xor	ebx, 134217728				; 08000000H
	jmp	SHORT $LN176@constr_vol
$LN86@constr_vol:
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	ebx, DWORD PTR [ecx+40]
$LN176@constr_vol:

; 1337 :       if ( get_fattr(f_id) & NONCONTENT ) continue;

	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 536870912				; 20000000H
	xor	ecx, ecx
	or	eax, ecx
	mov	DWORD PTR _fe$[ebp], ebx
	jne	$LN17@constr_vol

; 1338 :       
; 1339 :       for ( m = 0 ; m < EDGE_CTRL ; m++ )

	xor	edi, edi
	lea	edx, DWORD PTR _grad$[ebp]
	mov	DWORD PTR _m$[ebp], edi
	mov	DWORD PTR tv2415[ebp], edx
$LL14@constr_vol:

; 1340 :       { vgptri = get_vertex_vgrad(v[m]);

	mov	eax, DWORD PTR _v$[ebp+edi*4]
	push	eax
	call	_get_vertex_vgrad
	mov	esi, eax
	add	esp, 4

; 1341 :         for  ( ; vgptri ; vgptri = vgptri->chain )

	test	esi, esi
	je	$LN13@constr_vol
	mov	edi, DWORD PTR _web+328
	mov	ebx, DWORD PTR _dymem
	npad	11
$LL11@constr_vol:

; 1342 :         { 
; 1343 :           if ( !valid_id(vgptri->bb_id) ) continue; /* skip quantities */

	test	DWORD PTR [esi+8], 268435456		; 10000000H
	je	$LN10@constr_vol

; 1344 :           if ( !equal_id(get_facet_body(f_id),vgptri->bb_id) ) 

	mov	ecx, DWORD PTR _f_id$[ebp]
	push	ecx
	call	_get_facet_body
	add	esp, 4
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN7@constr_vol

; 1345 :           { if ( !equal_id(get_facet_body(inverse_id(f_id)),vgptri->bb_id) )

	mov	eax, DWORD PTR _f_id$[ebp]
	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN92@constr_vol
	xor	eax, eax
	jmp	SHORT $LN89@constr_vol
$LN92@constr_vol:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN91@constr_vol
	xor	eax, eax
	jmp	SHORT $LN89@constr_vol
$LN91@constr_vol:
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [edi+ebx+784]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN90@constr_vol
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN89@constr_vol
$LN90@constr_vol:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN89@constr_vol:
	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN10@constr_vol

; 1346 :                 continue; 
; 1347 :             else  bodysign = -sign;

	mov	edx, DWORD PTR _sign$[ebp]
	neg	edx
	mov	DWORD PTR _bodysign$[ebp], edx

; 1348 :           }
; 1349 :           else bodysign = sign;

	jmp	SHORT $LN4@constr_vol
$LN7@constr_vol:
	mov	eax, DWORD PTR _sign$[ebp]
	mov	DWORD PTR _bodysign$[ebp], eax
$LN4@constr_vol:

; 1350 :           
; 1351 :           for ( k = 0 ; k < SDIM ; k++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN10@constr_vol
	fild	DWORD PTR _bodysign$[ebp]
	mov	edx, DWORD PTR tv2415[ebp]
$LN3@constr_vol:

; 1352 :             vgptri->grad[k] += bodysign*grad[m][k];

	fld	QWORD PTR [edx]
	mov	ecx, DWORD PTR [esi+16]
	fmul	ST(0), ST(1)
	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	eax
	add	edx, 8
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@constr_vol

; 1350 :           
; 1351 :           for ( k = 0 ; k < SDIM ; k++ )

	mov	edi, DWORD PTR _web+328
	fstp	ST(0)
	mov	ebx, DWORD PTR _dymem
$LN10@constr_vol:

; 1341 :         for  ( ; vgptri ; vgptri = vgptri->chain )

	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	jne	$LL11@constr_vol
	mov	ebx, DWORD PTR _fe$[ebp]
	mov	edi, DWORD PTR _m$[ebp]
$LN13@constr_vol:

; 1338 :       
; 1339 :       for ( m = 0 ; m < EDGE_CTRL ; m++ )

	add	DWORD PTR tv2415[ebp], 48		; 00000030H
	inc	edi
	mov	DWORD PTR _m$[ebp], edi
	cmp	edi, 3
	jl	$LL14@constr_vol
	mov	edx, DWORD PTR _web+460
$LN17@constr_vol:

; 1353 :         }
; 1354 :       }
; 1355 :     } while ( !equal_id(fe,start_fe));

	cmp	ebx, DWORD PTR _start_fe$[ebp]
	jne	$LL18@constr_vol
$LN16@constr_vol:

; 1356 : 
; 1357 : } // constr_vol_grad_q()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_constr_vol_grad_q ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DK@MCJDPGFH@Vertex?5?$CFs?5has?5more?5constraints?5t@ ; `string'
PUBLIC	_basis$GSCopy$
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_constr_basis
EXTRN	_kernel_basis:PROC
;	COMDAT ??_C@_0DK@MCJDPGFH@Vertex?5?$CFs?5has?5more?5constraints?5t@
CONST	SEGMENT
??_C@_0DK@MCJDPGFH@Vertex?5?$CFs?5has?5more?5constraints?5t@ DB 'Vertex %'
	DB	's has more constraints than space dimension, %d', 0aH, '.', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _constr_basis
_TEXT	SEGMENT
_basqXvS$ = -680					; size = 24
_con$ = -656						; size = 28
_grad$ = -628						; size = 24
_fval$ = -604						; size = 8
_basis$GSCopy$ = -596					; size = 4
_v_id$GSCopy$ = -592					; size = 4
_bas$ = -588						; size = 4
_oncount$ = -584					; size = 4
_ggrad$ = -580						; size = 288
_basxJ$ = -292						; size = 288
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_basis$ = 12						; size = 4
_constr_basis PROC					; COMDAT

; 1371 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 680				; 000002a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1402 : 
; 1403 :   /* transpose */
; 1404 :   for ( i = 0 ; i < nullity ; i++ )

	mov	eax, DWORD PTR _basis$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _v_id$[ebp]
	push	esi
	push	edi
	push	6
	push	6
	lea	ecx, DWORD PTR _basxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _basqXvS$[ebp]
	push	edx
	mov	DWORD PTR _v_id$GSCopy$[ebp], ebx
	mov	DWORD PTR _basis$GSCopy$[ebp], eax
	call	_mat2d_setup
	mov	ecx, DWORD PTR _web+104
	mov	DWORD PTR _bas$[ebp], eax
	mov	eax, DWORD PTR _dymem
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [ecx+eax+1288], 0
	je	SHORT $LN17@constr_bas

; 1372 :   conmap_t *conmap;
; 1373 :   struct constraint *con[MAXCONHIT];
; 1374 :   int oncount = 0;
; 1375 :   REAL ggrad[MAXCOORD][MAXCOORD];
; 1376 :   REAL *grad[MAXCOORD]; /* for proper matrix form */
; 1377 :   REAL fval;
; 1378 :   int i,j;
; 1379 :   MAT2D(bas,MAXCOORD,MAXCOORD);
; 1380 :   int nullity;
; 1381 : 
; 1382 :   conmap = get_v_constraint_map(v_id);

	mov	esi, DWORD PTR _web+12
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+edx*4]
	add	esi, DWORD PTR [ecx+eax+1264]
	jmp	SHORT $LN18@constr_bas
$LN17@constr_bas:
	mov	esi, OFFSET _nullcon
$LN18@constr_bas:

; 1383 :   for ( j = 1 , oncount = 0; j <= (int)conmap[0] ; j++ )

	mov	edi, 1
	xor	eax, eax
	mov	DWORD PTR _oncount$[ebp], eax
	cmp	DWORD PTR [esi], edi
	jl	$LN30@constr_bas
$LL14@constr_bas:

; 1384 :    if ( conmap[j] & CON_HIT_BIT )

	test	DWORD PTR [esi+edi*4], -2147483648	; 80000000H
	je	$LN13@constr_bas

; 1385 :    { if ( oncount >= web.sdim ) 

	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN10@constr_bas

; 1386 :      { sprintf(errmsg,
; 1387 :        "Vertex %s has more constraints than space dimension, %d\n.",
; 1388 :           ELNAME(v_id),SDIM);  

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN19@constr_bas
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN20@constr_bas
$LN19@constr_bas:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN20@constr_bas:
	mov	ecx, DWORD PTR _web+616
	push	ecx
	push	eax
	push	OFFSET ??_C@_0DK@MCJDPGFH@Vertex?5?$CFs?5has?5more?5constraints?5t@
	push	OFFSET _errmsg
	call	_sprintf

; 1389 :        kb_error(5886,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5886					; 000016feH
	call	_kb_error
	mov	eax, DWORD PTR _oncount$[ebp]
	add	esp, 28					; 0000001cH
$LN10@constr_bas:

; 1390 :      } 
; 1391 :      con[oncount++] = get_constraint(conmap[j]);

	mov	edx, DWORD PTR [esi+edi*4]
	and	edx, 1073741823				; 3fffffffH
	imul	edx, 176				; 000000b0H
	add	edx, DWORD PTR _web+652
	inc	eax
	mov	DWORD PTR _con$[ebp+eax*4-4], edx
	mov	DWORD PTR _oncount$[ebp], eax
$LN13@constr_bas:

; 1383 :   for ( j = 1 , oncount = 0; j <= (int)conmap[0] ; j++ )

	inc	edi
	cmp	edi, DWORD PTR [esi]
	jle	$LL14@constr_bas
$LN30@constr_bas:

; 1392 :    }
; 1393 : 
; 1394 :   /* first calc constraint gradients */
; 1395 :   for ( i = 0 ; i < oncount ; i++ )     

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN7@constr_bas
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	lea	edi, DWORD PTR _ggrad$[ebp]
	npad	8
$LL31@constr_bas:

; 1396 :   { grad[i] = ggrad[i];
; 1397 :     eval_all(con[i]->formula,get_coord(v_id),SDIM,&fval,grad[i],v_id);

	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	mov	edx, DWORD PTR _web+616
	push	eax
	mov	eax, DWORD PTR _web+12
	push	edi
	lea	ecx, DWORD PTR _fval$[ebp]
	push	ecx
	mov	DWORD PTR _grad$[ebp+esi*4], edi
	mov	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR _dymem
	push	edx
	mov	edx, DWORD PTR _web+104
	add	ecx, DWORD PTR [edx+eax+64]
	push	ecx
	mov	ecx, DWORD PTR _con$[ebp+esi*4]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	_eval_all
	inc	esi
	add	esp, 24					; 00000018H
	add	edi, 48					; 00000030H
	cmp	esi, DWORD PTR _oncount$[ebp]
	jl	SHORT $LL31@constr_bas

; 1392 :    }
; 1393 : 
; 1394 :   /* first calc constraint gradients */
; 1395 :   for ( i = 0 ; i < oncount ; i++ )     

	mov	eax, DWORD PTR _oncount$[ebp]
$LN7@constr_bas:

; 1398 :   }
; 1399 : 
; 1400 :   /* now get basis */
; 1401 :   nullity = kernel_basis(grad,bas,oncount,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _bas$[ebp]
	push	ecx
	push	eax
	push	edx
	lea	eax, DWORD PTR _grad$[ebp]
	push	eax
	call	_kernel_basis
	add	esp, 16					; 00000010H

; 1402 : 
; 1403 :   /* transpose */
; 1404 :   for ( i = 0 ; i < nullity ; i++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN4@constr_bas
	mov	edi, DWORD PTR _web+616
$LL6@constr_bas:

; 1405 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN5@constr_bas

; 1402 : 
; 1403 :   /* transpose */
; 1404 :   for ( i = 0 ; i < nullity ; i++ )

	mov	edx, DWORD PTR _basis$GSCopy$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
$LL3@constr_bas:

; 1406 :       basis[i][j] = bas[j][i];

	mov	edi, DWORD PTR _bas$[ebp]
	mov	edi, DWORD PTR [edi+ecx*4]
	fld	QWORD PTR [edi+esi*8]
	inc	ecx
	fstp	QWORD PTR [edx]
	mov	edi, DWORD PTR _web+616
	add	edx, 8
	cmp	ecx, edi
	jl	SHORT $LL3@constr_bas
$LN5@constr_bas:

; 1402 : 
; 1403 :   /* transpose */
; 1404 :   for ( i = 0 ; i < nullity ; i++ )

	inc	esi
	cmp	esi, eax
	jl	SHORT $LL6@constr_bas
$LN4@constr_bas:

; 1407 : 
; 1408 :   return nullity;
; 1409 : 
; 1410 : }  // end constr_basis()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_constr_basis ENDP
_TEXT	ENDS
PUBLIC	_v_id$GSCopy$
PUBLIC	_fout$GSCopy$
PUBLIC	_fin$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_force_project
EXTRN	_matvec_mul:PROC
EXTRN	_b_proj:PROC
EXTRN	_V_BOUNDARY_ATTR:DWORD
; Function compile flags: /Ogtp
;	COMDAT _force_project
_TEXT	SEGMENT
_con$90329 = -416					; size = 28
_attr$ = -388						; size = 8
_v_id$GSCopy$ = -380					; size = 4
_fin$GSCopy$ = -376					; size = 4
_fout$GSCopy$ = -372					; size = 4
_axJ$90358 = -368					; size = 288
_conlist$90330 = -80					; size = 28
_aqXvS$90357 = -76					; size = 24
_perp$90331 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_fin$ = 8						; size = 4
_v_id$ = 12						; size = 4
_fout$ = 16						; size = 4
_force_project PROC					; COMDAT

; 1425 : { ATTR attr = get_vattr(v_id);

	push	ebp
	mov	ebp, esp
	sub	esp, 416				; 000001a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1459 :     return;
; 1460 :   }
; 1461 : 
; 1462 :   /* no projecting to do */
; 1463 :   for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _fout$[ebp]
	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR _fin$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _v_id$[ebp]
	push	esi
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	mov	DWORD PTR _fin$GSCopy$[ebp], eax
	mov	DWORD PTR _fout$GSCopy$[ebp], ecx
	mov	ecx, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _attr$[ebp+4], eax
	mov	eax, edx
	push	edi
	and	eax, 1024				; 00000400H
	xor	edi, edi
	or	eax, edi
	mov	DWORD PTR _v_id$GSCopy$[ebp], ebx
	je	$LN15@force_proj

; 1426 :   int i,j;
; 1427 :   if ( attr & CONSTRAINT )
; 1428 :   { conmap_t * conmap = get_v_constraint_map(v_id);

	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	cmp	DWORD PTR [edx+eax+1288], edi
	je	SHORT $LN18@force_proj
	mov	ebx, DWORD PTR [edx+eax+1264]
	add	ebx, ecx
	jmp	SHORT $LN19@force_proj
$LN18@force_proj:
	mov	ebx, OFFSET _nullcon
$LN19@force_proj:

; 1429 :     int oncount = 0;
; 1430 :     struct constraint *con[MAXCONHIT];
; 1431 :     int conlist[MAXCONHIT];
; 1432 :     REAL perp[MAXCOORD];
; 1433 : 
; 1434 :     for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR [ebx]
	mov	edi, 1
	cmp	eax, edi
	jl	SHORT $LN34@force_proj
	npad	2
$LL14@force_proj:

; 1435 :     { if ( conmap[j] & CON_HIT_BIT )

	test	DWORD PTR [ebx+edi*4], -2147483648	; 80000000H
	jne	SHORT $LN32@force_proj

; 1429 :     int oncount = 0;
; 1430 :     struct constraint *con[MAXCONHIT];
; 1431 :     int conlist[MAXCONHIT];
; 1432 :     REAL perp[MAXCOORD];
; 1433 : 
; 1434 :     for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	inc	edi
	cmp	edi, eax
	jle	SHORT $LL14@force_proj
$LN34@force_proj:

; 1459 :     return;
; 1460 :   }
; 1461 : 
; 1462 :   /* no projecting to do */
; 1463 :   for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN1@force_proj
	mov	eax, DWORD PTR _fout$GSCopy$[ebp]
	mov	edx, DWORD PTR _fin$GSCopy$[ebp]
	sub	edx, eax
$LL3@force_proj:

; 1464 :     fout[i] = fin[i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL3@force_proj
$LN1@force_proj:
	pop	edi
	pop	esi
	pop	ebx

; 1465 : 
; 1466 : } // end force_project()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@force_proj:

; 1436 :       { 
; 1437 :         if ( oncount >= web.sdim )

	cmp	DWORD PTR _web+616, 0
	jg	SHORT $LN10@force_proj

; 1438 :         { sprintf(errmsg,"Vertex %s hits more constraints than dimension of space.\n",
; 1439 :               ELNAME(v_id));

	test	DWORD PTR _v_id$GSCopy$[ebp], 268435456	; 10000000H
	je	SHORT $LN20@force_proj
	lea	ecx, DWORD PTR [esi+1]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN21@force_proj
$LN20@force_proj:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@force_proj:
	push	eax
	push	OFFSET ??_C@_0DK@NBHPKLFK@Vertex?5?$CFs?5hits?5more?5constraints?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1440 :           kb_error(5887,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5887					; 000016ffH
	call	_kb_error
	mov	edx, DWORD PTR _web+104
	add	esp, 24					; 00000018H
$LN10@force_proj:

; 1441 :         }
; 1442 :         conlist[oncount] = conmap[j] & CONMASK;

	mov	eax, DWORD PTR [ebx+edi*4]
	and	eax, 1073741823				; 3fffffffH
	mov	DWORD PTR _conlist$90330[ebp], eax

; 1443 :         con[oncount] = get_constraint(conmap[j]);

	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 1444 :         oncount++;
; 1445 :       }
; 1446 :       if ( oncount )
; 1447 :       { constr_proj(TANGPROJ,oncount,con,get_coord(v_id),
; 1448 :                                  fin,perp,conlist,0,v_id);

	mov	edi, DWORD PTR _fin$GSCopy$[ebp]
	mov	DWORD PTR _con$90329[ebp], eax
	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _conlist$90330[ebp]
	push	ecx
	mov	ecx, DWORD PTR _web+12
	lea	eax, DWORD PTR _perp$90331[ebp]
	push	eax
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ecx+64]
	push	edi
	push	eax
	lea	edx, DWORD PTR _con$90329[ebp]
	push	edx
	push	1
	push	2
	call	_constr_proj

; 1449 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	add	esp, 36					; 00000024H
	cmp	DWORD PTR _web+616, eax
	jle	$LN1@force_proj
	lea	edx, DWORD PTR _perp$90331[ebp]
	mov	ecx, edi
	sub	ecx, edx
	mov	edx, DWORD PTR _fout$GSCopy$[ebp]
	lea	esi, DWORD PTR _perp$90331[ebp]
	sub	edx, esi
$LL8@force_proj:
	lea	esi, DWORD PTR [ecx+eax*8]

; 1450 :           fout[j] = fin[j] - perp[j];

	fld	QWORD PTR _perp$90331[ebp+esi]
	lea	esi, DWORD PTR [edx+eax*8]
	fsub	QWORD PTR _perp$90331[ebp+eax*8]
	inc	eax
	fstp	QWORD PTR _perp$90331[ebp+esi]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL8@force_proj
	pop	edi
	pop	esi
	pop	ebx

; 1465 : 
; 1466 : } // end force_project()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@force_proj:

; 1451 :         return;
; 1452 :       }
; 1453 :     }
; 1454 :   }
; 1455 :   else if ( attr & BOUNDARY )

	and	edx, 128				; 00000080H
	xor	eax, eax
	or	edx, eax
	je	$LN34@force_proj

; 1456 :   { MAT2D(a,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _axJ$90358[ebp]
	push	eax
	lea	ecx, DWORD PTR _aqXvS$90357[ebp]
	push	ecx
	call	_mat2d_setup

; 1457 :     b_proj(get_boundary(v_id),get_param(v_id),a,TANGPROJ,v_id);

	mov	ecx, DWORD PTR _web+104
	mov	edi, eax
	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN22@force_proj
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, ecx
	mov	eax, DWORD PTR [eax+edx+64]
	mov	edx, DWORD PTR _web+12
	mov	edx, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [eax+edx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN23@force_proj
$LN22@force_proj:
	xor	eax, eax
$LN23@force_proj:
	mov	edx, DWORD PTR _web+12
	mov	edx, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR _dymem
	add	edx, DWORD PTR [ecx+esi+544]
	push	ebx
	push	2
	push	edi
	push	edx
	push	eax
	call	_b_proj

; 1458 :     matvec_mul(a,fin,fout,SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _fin$GSCopy$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR _fout$GSCopy$[ebp]
	push	eax
	push	ecx
	push	edi
	call	_matvec_mul

; 1465 : 
; 1466 : } // end force_project()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 40					; 00000028H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_force_project ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@COJLOKFL@calc_constr_force_e?$CI?$CJ?3?5Cannot?5do@ ; `string'
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_calc_constr_force_e
EXTRN	_gauss1Dwt:DWORD
EXTRN	_gauss1Dpt:DWORD
EXTRN	_gauss1D_num:DWORD
;	COMDAT ??_C@_0DC@COJLOKFL@calc_constr_force_e?$CI?$CJ?3?5Cannot?5do@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DC@COJLOKFL@calc_constr_force_e?$CI?$CJ?3?5Cannot?5do@ DB 'calc_co'
	DB	'nstr_force_e(): Cannot do LAGRANGE model.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\cnstrnt.c
CONST	ENDS
;	COMDAT _calc_constr_force_e
_TEXT	SEGMENT
tv1061 = -492						; size = 4
tv597 = -488						; size = 4
_hforce$ = -484						; size = 4
tv649 = -480						; size = 4
_e_id$GSCopy$ = -476					; size = 4
_hcoord$ = -472						; size = 4
_j$ = -468						; size = 4
_sign$ = -464						; size = 4
_tcoord$ = -460						; size = 4
_tforce$ = -456						; size = 4
_conmap$ = -452						; size = 4
tv508 = -448						; size = 4
_m$ = -448						; size = 4
tv518 = -444						; size = 4
_constr$ = -444						; size = 4
tv411 = -440						; size = 4
_i$ = -440						; size = 4
_green_deriv$ = -436					; size = 288
_side$ = -148						; size = 48
_midpt$ = -100						; size = 48
_green$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_calc_constr_force_e PROC				; COMDAT

; 456  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 492				; 000001ecH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	mov	edi, DWORD PTR _e_id$[ebp]

; 457  :   REAL *tcoord,*hcoord;
; 458  :   REAL *tforce,*hforce;
; 459  :   struct constraint *constr;
; 460  :   int i,k,m;
; 461  :   REAL side[MAXCOORD];
; 462  :   REAL green[MAXCOORD];
; 463  :   REAL green_deriv[MAXCOORD][MAXCOORD];
; 464  :   int j,sign;
; 465  :   REAL midpt[MAXCOORD];
; 466  :   REAL grad;
; 467  :   vertex_id headv,tailv;
; 468  :   conmap_t *conmap;
; 469  : 
; 470  :   int_val = ordinal(get_original(e_id))+1;  /* for eval  of file parameters */

	mov	eax, edi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [ecx+esi]
	mov	eax, DWORD PTR [edx+20]

; 502  :         eval_all(constr->envect[i],midpt,SDIM,&green[i],green_deriv[i],e_id);

	mov	DWORD PTR _e_id$GSCopy$[ebp], edi
	test	eax, 268435456				; 10000000H
	je	SHORT $LN32@calc_const@4

; 457  :   REAL *tcoord,*hcoord;
; 458  :   REAL *tforce,*hforce;
; 459  :   struct constraint *constr;
; 460  :   int i,k,m;
; 461  :   REAL side[MAXCOORD];
; 462  :   REAL green[MAXCOORD];
; 463  :   REAL green_deriv[MAXCOORD][MAXCOORD];
; 464  :   int j,sign;
; 465  :   REAL midpt[MAXCOORD];
; 466  :   REAL grad;
; 467  :   vertex_id headv,tailv;
; 468  :   conmap_t *conmap;
; 469  : 
; 470  :   int_val = ordinal(get_original(e_id))+1;  /* for eval  of file parameters */

	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN33@calc_const@4
$LN32@calc_const@4:
	or	eax, -1
$LN33@calc_const@4:
	inc	eax
	mov	DWORD PTR _int_val, eax

; 471  :   if ( web.modeltype == QUADRATIC )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	jne	SHORT $LN29@calc_const@4

; 472  :   { constr_edge_force_q(e_id);

	push	edi
	call	_constr_edge_force_q
	add	esp, 4
	pop	edi
	pop	esi

; 508  :       }
; 509  :     }
; 510  :   }
; 511  : 
; 512  :   return;
; 513  : 
; 514  : } // end calc_constr_force_e()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@calc_const@4:

; 473  :     return;
; 474  :   }
; 475  :   else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	SHORT $LN58@calc_const@4

; 476  :      kb_error(1793,"calc_constr_force_e(): Cannot do LAGRANGE model.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DC@COJLOKFL@calc_constr_force_e?$CI?$CJ?3?5Cannot?5do@
	push	1793					; 00000701H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN58@calc_const@4:

; 477  : 
; 478  :   conmap = get_e_constraint_map(e_id);

	mov	edx, DWORD PTR _web+216
	mov	ecx, DWORD PTR _web+124
	push	ebx
	mov	ebx, DWORD PTR _dymem
	cmp	DWORD PTR [edx+ebx+1048], 0
	je	SHORT $LN34@calc_const@4
	mov	eax, DWORD PTR [esi+ecx]
	add	eax, DWORD PTR [edx+ebx+1024]
	mov	DWORD PTR _conmap$[ebp], eax
	jmp	SHORT $LN35@calc_const@4
$LN34@calc_const@4:
	mov	DWORD PTR _conmap$[ebp], OFFSET _nullcon
$LN35@calc_const@4:

; 479  :   if ( get_eattr(e_id) & NEGBOUNDARY ) sign = -1;

	mov	esi, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	or	eax, ecx
	mov	DWORD PTR tv508[ebp], esi
	je	SHORT $LN26@calc_const@4
	or	ecx, -1
	jmp	SHORT $LN95@calc_const@4
$LN26@calc_const@4:

; 480  :   else sign = 1;

	mov	ecx, 1
$LN95@calc_const@4:

; 481  :   if ( inverted(e_id) ) sign = -sign;

	mov	eax, edi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR _sign$[ebp], ecx
	mov	DWORD PTR tv518[ebp], eax
	je	SHORT $LN24@calc_const@4
	neg	ecx
	mov	DWORD PTR _sign$[ebp], ecx
$LN24@calc_const@4:

; 482  : 
; 483  :   headv = get_edge_headv(e_id);
; 484  :   tailv = get_edge_tailv(e_id);
; 485  : 
; 486  :   tcoord = get_coord(tailv);

	mov	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR [eax+ebx+64]
	push	edi
	call	_get_edge_tailv
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	add	eax, esi
	push	edi
	mov	DWORD PTR _tcoord$[ebp], eax
	call	_get_edge_headv

; 487  :   hcoord = get_coord(headv);

	mov	edi, DWORD PTR _web+12

; 488  :   for ( j = 0 ; j < SDIM ; j++ )

	mov	ecx, DWORD PTR _web+616
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+eax*4]
	add	edx, esi
	add	esp, 8
	mov	DWORD PTR _hcoord$[ebp], edx
	test	ecx, ecx
	jle	SHORT $LN21@calc_const@4
	mov	eax, DWORD PTR _tcoord$[ebp]
	lea	esi, DWORD PTR _side$[ebp]
	sub	edx, eax
	sub	esi, eax
	mov	edi, ecx
	npad	7
$LL23@calc_const@4:

; 489  :     side[j] = hcoord[j] - tcoord[j];

	fld	QWORD PTR [edx+eax]
	add	eax, 8
	dec	edi
	fsub	QWORD PTR [eax-8]
	fstp	QWORD PTR [esi+eax-8]
	jne	SHORT $LL23@calc_const@4

; 488  :   for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _web+12
$LN21@calc_const@4:

; 490  : 
; 491  :   tforce = get_force(get_edge_tailv(e_id));

	mov	edx, DWORD PTR _web+216
	mov	eax, DWORD PTR [edx+ebx+304]
	mov	edx, DWORD PTR tv508[ebp]
	add	edx, eax
	cmp	DWORD PTR tv518[ebp], 0
	je	SHORT $LN37@calc_const@4
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN36@calc_const@4
$LN37@calc_const@4:
	mov	eax, DWORD PTR [edx]
$LN36@calc_const@4:
	mov	esi, DWORD PTR _web+104
	mov	esi, DWORD PTR [esi+ebx+784]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	add	eax, esi

; 492  :   hforce = get_force(get_edge_headv(e_id));

	cmp	DWORD PTR tv518[ebp], 0
	mov	DWORD PTR _tforce$[ebp], eax
	je	SHORT $LN41@calc_const@4
	mov	edx, DWORD PTR [edx]
	jmp	SHORT $LN40@calc_const@4
$LN41@calc_const@4:
	mov	ebx, DWORD PTR _web+636
	mov	edx, DWORD PTR [edx+ebx*4]
$LN40@calc_const@4:
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	add	edx, esi
	mov	DWORD PTR _hforce$[ebp], edx

; 493  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	edx, DWORD PTR _conmap$[ebp]
	mov	ebx, 1
	mov	DWORD PTR _j$[ebp], ebx
	cmp	DWORD PTR [edx], ebx
	jl	$LN61@calc_const@4
	fld1
	fldz
$LN59@calc_const@4:

; 494  :   { constr = get_constraint(conmap[j]);

	mov	edx, DWORD PTR _conmap$[ebp]
	mov	esi, DWORD PTR [edx+ebx*4]
	and	esi, 1073741823				; 3fffffffH
	imul	esi, 176				; 000000b0H
	add	esi, DWORD PTR _web+652

; 495  :     if ( !(constr->attr & CON_ENERGY) || (constr->compcount != SDIM) )

	xor	edi, edi
	mov	edx, DWORD PTR [esi+32]
	and	edx, 64					; 00000040H
	or	edx, edi
	mov	DWORD PTR _constr$[ebp], esi
	je	$LN19@calc_const@4
	cmp	DWORD PTR [esi+44], ecx
	jne	$LN19@calc_const@4

; 496  :        continue;
; 497  :     for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	edx, edx
	mov	DWORD PTR _m$[ebp], edx
	cmp	DWORD PTR _gauss1D_num, edx
	jle	$LN19@calc_const@4
$LN60@calc_const@4:

; 498  :     {
; 499  :       for ( i = 0 ; i < SDIM ; i++ )

	test	ecx, ecx
	jle	SHORT $LN10@calc_const@4
	mov	eax, DWORD PTR _hcoord$[ebp]
	mov	edi, DWORD PTR _tcoord$[ebp]
	lea	ebx, DWORD PTR _midpt$[ebp]
	sub	edi, eax
	sub	ebx, eax
	mov	DWORD PTR tv411[ebp], ecx
$LN12@calc_const@4:

; 500  :         midpt[i] = gauss1Dpt[m]*hcoord[i] + (1 - gauss1Dpt[m])*tcoord[i];

	mov	esi, DWORD PTR _gauss1Dpt
	fld	ST(1)
	fsub	QWORD PTR [esi+edx*8]
	add	eax, 8
	dec	DWORD PTR tv411[ebp]
	fmul	QWORD PTR [edi+eax-8]
	fld	QWORD PTR [esi+edx*8]
	fmul	QWORD PTR [eax-8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ebx+eax-8]
	jne	SHORT $LN12@calc_const@4

; 498  :     {
; 499  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _constr$[ebp]
	mov	eax, DWORD PTR _tforce$[ebp]
$LN10@calc_const@4:

; 501  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	ecx, ecx
	jle	SHORT $LN7@calc_const@4
	fstp	ST(1)
	lea	ebx, DWORD PTR _green$[ebp]
	fstp	ST(0)
	lea	edi, DWORD PTR _green_deriv$[ebp]
	add	esi, 48					; 00000030H
	npad	4
$LL9@calc_const@4:

; 502  :         eval_all(constr->envect[i],midpt,SDIM,&green[i],green_deriv[i],e_id);

	mov	eax, DWORD PTR _e_id$GSCopy$[ebp]
	mov	edx, DWORD PTR [esi]
	push	eax
	push	edi
	push	ebx
	push	ecx
	lea	ecx, DWORD PTR _midpt$[ebp]
	push	ecx
	push	edx
	call	_eval_all
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _web+616
	inc	eax
	add	esp, 24					; 00000018H
	add	esi, 4
	add	edi, 48					; 00000030H
	add	ebx, 8
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, ecx
	jl	SHORT $LL9@calc_const@4

; 501  :       for ( i = 0 ; i < SDIM ; i++ )

	fldz
	mov	edx, DWORD PTR _m$[ebp]
	fld1
	mov	esi, DWORD PTR _constr$[ebp]
	mov	eax, DWORD PTR _tforce$[ebp]
	fxch	ST(1)
$LN7@calc_const@4:

; 503  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	test	ecx, ecx
	jle	$LN14@calc_const@4
	mov	esi, DWORD PTR _gauss1Dpt
	fild	DWORD PTR _sign$[ebp]
	mov	edi, DWORD PTR _gauss1Dwt
	mov	ebx, DWORD PTR _hforce$[ebp]
	lea	esi, DWORD PTR [esi+edx*8]
	lea	edx, DWORD PTR [edi+edx*8]
	mov	DWORD PTR tv649[ebp], edx
	lea	edx, DWORD PTR _green_deriv$[ebp]
	sub	edx, eax
	lea	edi, DWORD PTR _green$[ebp]
	sub	edi, eax
	sub	ebx, DWORD PTR _tforce$[ebp]
	mov	DWORD PTR tv597[ebp], esi
	mov	DWORD PTR tv1061[ebp], edx
$LN6@calc_const@4:

; 504  :       { for ( grad = 0.0, k = 0 ; k < SDIM ; k++ )

	xor	edx, edx
	fld	ST(1)
	test	ecx, ecx
	jle	SHORT $LN1@calc_const@4
	mov	esi, DWORD PTR tv1061[ebp]
	add	esi, eax
$LN3@calc_const@4:

; 505  :           grad += side[k]*green_deriv[k][i];

	fld	QWORD PTR _side$[ebp+edx*8]
	inc	edx
	fmul	QWORD PTR [esi]
	add	esi, 48					; 00000030H
	faddp	ST(1), ST(0)
	cmp	edx, ecx
	jl	SHORT $LN3@calc_const@4

; 504  :       { for ( grad = 0.0, k = 0 ; k < SDIM ; k++ )

	mov	esi, DWORD PTR tv597[ebp]
$LN1@calc_const@4:

; 506  :         tforce[i] -= sign*gauss1Dwt[m]*((1-gauss1Dpt[m])*grad - green[i]);

	mov	ecx, DWORD PTR tv649[ebp]
	fld	ST(3)
	fsub	QWORD PTR [esi]
	inc	DWORD PTR _i$[ebp]
	add	eax, 8
	fmul	ST(0), ST(1)
	fsub	QWORD PTR [edi+eax-8]
	fld	ST(2)
	fmul	QWORD PTR [ecx]
	fmulp	ST(1), ST(0)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]

; 507  :         hforce[i] -= sign*gauss1Dwt[m]*(gauss1Dpt[m]*grad + green[i]);

	fmul	QWORD PTR [esi]
	fadd	QWORD PTR [edi+eax-8]
	fld	ST(1)
	fmul	QWORD PTR [ecx]
	fmulp	ST(1), ST(0)
	fsubr	QWORD PTR [ebx+eax-8]
	fstp	QWORD PTR [ebx+eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	DWORD PTR _i$[ebp], ecx
	jl	SHORT $LN6@calc_const@4

; 503  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _m$[ebp]
	fstp	ST(0)
	mov	esi, DWORD PTR _constr$[ebp]
	mov	eax, DWORD PTR _tforce$[ebp]
$LN14@calc_const@4:

; 496  :        continue;
; 497  :     for ( m = 0 ; m < gauss1D_num ; m++ )

	inc	edx
	mov	DWORD PTR _m$[ebp], edx
	cmp	edx, DWORD PTR _gauss1D_num
	jl	$LN60@calc_const@4
	mov	ebx, DWORD PTR _j$[ebp]
$LN19@calc_const@4:

; 493  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	edx, DWORD PTR _conmap$[ebp]
	inc	ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, DWORD PTR [edx]
	jle	$LN59@calc_const@4
	fstp	ST(1)
	fstp	ST(0)
$LN61@calc_const@4:

; 508  :       }
; 509  :     }
; 510  :   }
; 511  : 
; 512  :   return;
; 513  : 
; 514  : } // end calc_constr_force_e()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	ebx
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_calc_constr_force_e ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@NPJFOACB@calc_constr_energy_e?$CI?$CJ?3?5Cannot?5d@ ; `string'
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_calc_constr_energy_e
;	COMDAT ??_C@_0DD@NPJFOACB@calc_constr_energy_e?$CI?$CJ?3?5Cannot?5d@
CONST	SEGMENT
??_C@_0DD@NPJFOACB@calc_constr_energy_e?$CI?$CJ?3?5Cannot?5d@ DB 'calc_co'
	DB	'nstr_energy_e(): Cannot do LAGRANGE model.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _calc_constr_energy_e
_TEXT	SEGMENT
_energy$ = -184						; size = 8
_tcoord$ = -176						; size = 4
_hcoord$ = -172						; size = 4
_e_id$GSCopy$ = -168					; size = 4
_constr$ = -164						; size = 4
_j$ = -160						; size = 4
_conmap$ = -156						; size = 4
_sign$ = -152						; size = 4
_midpt$ = -148						; size = 48
_green$ = -100						; size = 48
_side$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_calc_constr_energy_e PROC				; COMDAT

; 551  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 552  :   REAL *tcoord,*hcoord;
; 553  :   struct constraint *constr;
; 554  :   int i,j,k;
; 555  :   REAL energy = 0.0;

	fldz
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	fstp	QWORD PTR _energy$[ebp]

; 556  :   REAL side[MAXCOORD];
; 557  :   REAL green[MAXCOORD];
; 558  :   int sign;
; 559  :   REAL midpt[MAXCOORD];
; 560  :   vertex_id headv,tailv;
; 561  :   conmap_t *conmap;
; 562  : 
; 563  :   int_val = ordinal(get_original(e_id))+1;  /* for eval  of file parameters */

	mov	eax, esi
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _web[eax+12]
	push	edi
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [ecx+edi]
	mov	eax, DWORD PTR [edx+20]

; 588  :     for ( k = 0 ; k < gauss1D_num ; k++ )

	mov	DWORD PTR _e_id$GSCopy$[ebp], esi
	test	eax, 268435456				; 10000000H
	je	SHORT $LN27@calc_const@5

; 556  :   REAL side[MAXCOORD];
; 557  :   REAL green[MAXCOORD];
; 558  :   int sign;
; 559  :   REAL midpt[MAXCOORD];
; 560  :   vertex_id headv,tailv;
; 561  :   conmap_t *conmap;
; 562  : 
; 563  :   int_val = ordinal(get_original(e_id))+1;  /* for eval  of file parameters */

	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN28@calc_const@5
$LN27@calc_const@5:
	or	eax, -1
$LN28@calc_const@5:
	inc	eax
	mov	DWORD PTR _int_val, eax

; 564  :   if ( web.modeltype == QUADRATIC )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	jne	SHORT $LN24@calc_const@5

; 565  :   { constr_edge_energy_q(e_id);

	push	esi
	call	_constr_edge_energy_q
	add	esp, 4
	pop	edi
	pop	esi

; 601  : 
; 602  : } // end calc_constr_energy_e()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@calc_const@5:

; 566  :     return;
; 567  :   }
; 568  :   else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	SHORT $LN42@calc_const@5

; 569  :      kb_error(1794,"calc_constr_energy_e(): Cannot do LAGRANGE model.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DD@NPJFOACB@calc_constr_energy_e?$CI?$CJ?3?5Cannot?5d@
	push	1794					; 00000702H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN42@calc_const@5:

; 570  : 
; 571  :   conmap = get_e_constraint_map(e_id);

	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+124
	push	ebx
	mov	ebx, DWORD PTR _web+216
	cmp	DWORD PTR [ebx+ecx+1048], 0
	je	SHORT $LN29@calc_const@5
	mov	eax, DWORD PTR [edi+edx]
	add	eax, DWORD PTR [ebx+ecx+1024]
	mov	DWORD PTR _conmap$[ebp], eax
	jmp	SHORT $LN30@calc_const@5
$LN29@calc_const@5:
	mov	DWORD PTR _conmap$[ebp], OFFSET _nullcon
$LN30@calc_const@5:

; 572  :   if ( get_eattr(e_id) & NEGBOUNDARY ) sign = -1;

	mov	edi, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 256				; 00000100H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN21@calc_const@5
	or	eax, -1
	jmp	SHORT $LN65@calc_const@5
$LN21@calc_const@5:

; 573  :   else sign = 1;

	mov	eax, 1
$LN65@calc_const@5:
	mov	DWORD PTR _sign$[ebp], eax

; 574  :   if ( inverted(e_id) ) sign = -sign;

	test	esi, 134217728				; 08000000H
	je	SHORT $LN19@calc_const@5
	neg	eax
	mov	DWORD PTR _sign$[ebp], eax
$LN19@calc_const@5:

; 575  : 
; 576  :   headv = get_edge_headv(e_id);
; 577  :   tailv = get_edge_tailv(e_id);
; 578  :         
; 579  :   tcoord = get_coord(tailv);

	mov	eax, DWORD PTR _web+104
	mov	ebx, DWORD PTR [eax+ecx+64]
	push	esi
	call	_get_edge_tailv
	mov	esi, DWORD PTR _web+12
	mov	ecx, DWORD PTR _e_id$GSCopy$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [esi+eax*4]
	add	edi, ebx
	push	ecx
	mov	DWORD PTR _tcoord$[ebp], edi
	call	_get_edge_headv

; 580  :   hcoord = get_coord(headv);

	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+eax*4]
	add	esi, ebx

; 581  :   for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _web+616
	add	esp, 8
	mov	DWORD PTR _hcoord$[ebp], esi
	test	ebx, ebx
	jle	SHORT $LN16@calc_const@5
	mov	ecx, esi
	sub	ecx, edi
	lea	edx, DWORD PTR _side$[ebp]
	mov	eax, edi
	sub	edx, edi
	mov	edi, ebx
	npad	2
$LL18@calc_const@5:

; 582  :     side[j] = hcoord[j] - tcoord[j];

	fld	QWORD PTR [ecx+eax]
	add	eax, 8
	dec	edi
	fsub	QWORD PTR [eax-8]
	fstp	QWORD PTR [edx+eax-8]
	jne	SHORT $LL18@calc_const@5
$LN16@calc_const@5:

; 583  : 
; 584  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _conmap$[ebp]
	mov	edx, 1
	mov	DWORD PTR _j$[ebp], edx
	cmp	DWORD PTR [eax], edx
	jl	$LN41@calc_const@5
	fld1
	jmp	SHORT $LN15@calc_const@5
$LN44@calc_const@5:
	mov	ebx, DWORD PTR _web+616
$LN15@calc_const@5:

; 585  :   { constr = get_constraint(conmap[j]);

	mov	edi, DWORD PTR [eax+edx*4]
	and	edi, 1073741823				; 3fffffffH
	imul	edi, 176				; 000000b0H
	add	edi, DWORD PTR _web+652

; 586  :     if ( !(constr->attr & CON_ENERGY) ) continue;

	xor	ecx, ecx
	mov	eax, DWORD PTR [edi+32]
	and	eax, 64					; 00000040H
	or	eax, ecx
	mov	DWORD PTR _constr$[ebp], edi
	je	$LN14@calc_const@5

; 587  :     if ( constr->compcount != SDIM ) continue;

	cmp	DWORD PTR [edi+44], ebx
	jne	$LN14@calc_const@5

; 588  :     for ( k = 0 ; k < gauss1D_num ; k++ )

	xor	ebx, ebx
	cmp	DWORD PTR _gauss1D_num, ecx
	jle	$LN14@calc_const@5
$LN10@calc_const@5:

; 589  :     { for ( i = 0 ; i < SDIM ; i++ )

	cmp	DWORD PTR _web+616, 0
	jle	SHORT $LN5@calc_const@5
	mov	ecx, DWORD PTR _tcoord$[ebp]
	sub	ecx, esi
	lea	edx, DWORD PTR _midpt$[ebp]
	mov	eax, esi
	sub	edx, esi
	mov	esi, DWORD PTR _web+616
$LN7@calc_const@5:

; 590  :         midpt[i] = gauss1Dpt[k]*hcoord[i] + (1 - gauss1Dpt[k])*tcoord[i];

	mov	edi, DWORD PTR _gauss1Dpt
	fld	ST(0)
	fsub	QWORD PTR [edi+ebx*8]
	add	eax, 8
	dec	esi
	fmul	QWORD PTR [ecx+eax-8]
	fld	QWORD PTR [eax-8]
	fmul	QWORD PTR [edi+ebx*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx+eax-8]
	jne	SHORT $LN7@calc_const@5

; 589  :     { for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR _constr$[ebp]
	mov	esi, DWORD PTR _hcoord$[ebp]
$LN5@calc_const@5:

; 591  :       if ( constr->attr & CON_ENERGY )

	mov	eax, DWORD PTR [edi+32]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN9@calc_const@5

; 592  :       { for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	fstp	ST(0)
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN1@calc_const@5
	add	edi, 48					; 00000030H
	npad	2
$LL3@calc_const@5:

; 593  :           green[i] = eval(constr->envect[i],midpt,e_id,NULL); 

	mov	edx, DWORD PTR _e_id$GSCopy$[ebp]
	mov	ecx, DWORD PTR [edi]
	push	0
	push	edx
	lea	eax, DWORD PTR _midpt$[ebp]
	push	eax
	push	ecx
	call	_eval
	fstp	QWORD PTR _green$[ebp+esi*8]
	inc	esi
	add	esp, 16					; 00000010H
	add	edi, 4
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL3@calc_const@5

; 592  :       { for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR _constr$[ebp]
$LN1@calc_const@5:

; 594  :         energy += sign*gauss1Dwt[k]*SDIM_dot(side,green);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _green$[ebp]
	push	eax
	lea	ecx, DWORD PTR _side$[ebp]
	push	ecx
	call	_dot
	fild	DWORD PTR _sign$[ebp]
	mov	edx, DWORD PTR _gauss1Dwt
	mov	esi, DWORD PTR _hcoord$[ebp]
	fmul	QWORD PTR [edx+ebx*8]
	add	esp, 12					; 0000000cH
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR _energy$[ebp]
	fstp	QWORD PTR _energy$[ebp]
	fld1
$LN9@calc_const@5:

; 588  :     for ( k = 0 ; k < gauss1D_num ; k++ )

	inc	ebx
	cmp	ebx, DWORD PTR _gauss1D_num
	jl	$LN10@calc_const@5
	mov	edx, DWORD PTR _j$[ebp]
$LN14@calc_const@5:

; 583  : 
; 584  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _conmap$[ebp]
	inc	edx
	mov	DWORD PTR _j$[ebp], edx
	cmp	edx, DWORD PTR [eax]
	jle	$LN44@calc_const@5
	fstp	ST(0)
$LN41@calc_const@5:

; 595  :       }
; 596  :     }
; 597  : 
; 598  :   }
; 599  : 
; 600  :   binary_tree_add(web.total_energy_addends,energy);

	fld	QWORD PTR _energy$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET _web+1248
	call	_binary_tree_add

; 601  : 
; 602  : } // end calc_constr_energy_e()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	pop	ebx
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_calc_constr_energy_e ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@PGKFMPGG@calc_constr_content_e?$CI?$CJ?3?5Cannot?5@ ; `string'
PUBLIC	_e_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_calc_constr_content_e
;	COMDAT ??_C@_0DE@PGKFMPGG@calc_constr_content_e?$CI?$CJ?3?5Cannot?5@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DE@PGKFMPGG@calc_constr_content_e?$CI?$CJ?3?5Cannot?5@ DB 'calc_co'
	DB	'nstr_content_e(): Cannot do LAGRANGE model.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\cnstrnt.c
CONST	ENDS
;	COMDAT _calc_constr_content_e
_TEXT	SEGMENT
tv768 = -200						; size = 8
_tcoord$ = -192						; size = 4
_hcoord$ = -188						; size = 4
_content$ = -184					; size = 8
_j$ = -176						; size = 4
_e_id$GSCopy$ = -172					; size = 4
_max_rank$ = -168					; size = 4
_sign$ = -164						; size = 4
_min_rank$ = -160					; size = 4
_conmap$ = -156						; size = 4
_first_fe$ = -152					; size = 4
_constr$ = -152						; size = 4
_green$ = -148						; size = 48
_midpt$ = -100						; size = 48
_side$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_calc_constr_content_e PROC				; COMDAT

; 696  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 697  :   REAL *tcoord,*hcoord;
; 698  :   struct constraint *constr;
; 699  :   int i,k;
; 700  :   REAL content = 0.0;
; 701  :   REAL midpt[MAXCOORD];
; 702  :   REAL side[MAXCOORD];
; 703  :   REAL green[MAXCOORD];
; 704  :   body_id b_id;
; 705  :   facetedge_id fe_id;
; 706  :   facet_id f_id;
; 707  :   int j;
; 708  :   conmap_t *conmap;
; 709  :   int sign;
; 710  :   vertex_id headv,tailv;
; 711  :   facetedge_id first_fe;
; 712  :   int min_rank, max_rank;
; 713  : 
; 714  :   if ( web.modeltype == QUADRATIC )

	mov	eax, DWORD PTR _web+628
	push	ebx
	mov	ebx, DWORD PTR _e_id$[ebp]

; 758  :       content += sign*gauss1Dwt[k]*SDIM_dot(side,green);

	mov	DWORD PTR _e_id$GSCopy$[ebp], ebx
	cmp	eax, 2
	jne	SHORT $LN37@calc_const@6

; 715  :   { constr_edge_content_q(e_id);

	push	ebx
	call	_constr_edge_content_q
	add	esp, 4
	pop	ebx

; 784  : 
; 785  :   }
; 786  :   return;
; 787  : 
; 788  : } // end calc_constr_content_e()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@calc_const@6:

; 716  :     return;
; 717  :   }
; 718  :   else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	SHORT $LN82@calc_const@6

; 719  :      kb_error(1795,"calc_constr_content_e(): Cannot do LAGRANGE model.\n",
; 720  :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DE@PGKFMPGG@calc_constr_content_e?$CI?$CJ?3?5Cannot?5@
	push	1795					; 00000703H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN82@calc_const@6:

; 721  : 
; 722  : 
; 723  :   int_val = ordinal(get_original(e_id))+1;  /* for eval  of file parameters */

	mov	ecx, ebx
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [edx+eax]
	mov	ecx, DWORD PTR [ecx+20]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN40@calc_const@6
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN41@calc_const@6
$LN40@calc_const@6:
	or	ecx, -1
$LN41@calc_const@6:

; 724  :   conmap = get_e_constraint_map(e_id); 

	mov	edx, DWORD PTR _web+216
	push	esi
	inc	ecx
	push	edi
	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR _int_val, ecx
	cmp	DWORD PTR [edx+edi+1048], 0
	mov	ecx, DWORD PTR _web+124
	je	SHORT $LN42@calc_const@6
	mov	esi, DWORD PTR [eax+ecx]
	add	esi, DWORD PTR [edx+edi+1024]
	mov	DWORD PTR _conmap$[ebp], esi
	jmp	SHORT $LN43@calc_const@6
$LN42@calc_const@6:
	mov	DWORD PTR _conmap$[ebp], OFFSET _nullcon
$LN43@calc_const@6:

; 725  :   if ( get_eattr(e_id) & NEGBOUNDARY ) sign = -1;

	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 256				; 00000100H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN34@calc_const@6
	or	eax, -1
	jmp	SHORT $LN110@calc_const@6
$LN34@calc_const@6:

; 726  :   else sign = 1;

	mov	eax, 1
$LN110@calc_const@6:
	mov	DWORD PTR _sign$[ebp], eax

; 727  :   if ( inverted(e_id) ) sign = -sign;

	test	ebx, 134217728				; 08000000H
	je	SHORT $LN32@calc_const@6
	neg	eax
	mov	DWORD PTR _sign$[ebp], eax
$LN32@calc_const@6:

; 728  : 
; 729  :   headv = get_edge_headv(e_id);
; 730  :   tailv = get_edge_tailv(e_id);
; 731  : 
; 732  :   tcoord = get_coord(tailv);

	mov	edx, DWORD PTR _web+104
	mov	esi, DWORD PTR [edx+edi+64]
	push	ebx
	call	_get_edge_tailv
	mov	edi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _e_id$GSCopy$[ebp]
	add	ebx, esi
	push	eax
	mov	DWORD PTR _tcoord$[ebp], ebx
	call	_get_edge_headv

; 733  :   hcoord = get_coord(headv);

	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+eax*4]
	add	ecx, esi

; 734  :   for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _web+616
	add	esp, 8
	mov	DWORD PTR _hcoord$[ebp], ecx
	test	esi, esi
	jle	SHORT $LN29@calc_const@6
	lea	edx, DWORD PTR _side$[ebp]
	sub	ecx, ebx
	mov	eax, ebx
	sub	edx, ebx
$LL31@calc_const@6:

; 735  :     side[j] = hcoord[j] - tcoord[j];

	fld	QWORD PTR [ecx+eax]
	add	eax, 8
	dec	esi
	fsub	QWORD PTR [eax-8]
	fstp	QWORD PTR [edx+eax-8]
	jne	SHORT $LL31@calc_const@6
$LN29@calc_const@6:

; 736  : 
; 737  : 
; 738  :   min_rank = MAXINT; max_rank = 0;
; 739  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	esi, DWORD PTR _conmap$[ebp]
	mov	edx, DWORD PTR [esi]
	mov	ecx, 1
	mov	DWORD PTR _min_rank$[ebp], 2147483647	; 7fffffffH
	mov	DWORD PTR _max_rank$[ebp], 0
	cmp	edx, ecx
	jl	SHORT $LN83@calc_const@6
	npad	7
$LL88@calc_const@6:

; 740  :   { 
; 741  :     constr = get_constraint(conmap[j]);

	mov	eax, DWORD PTR [esi+ecx*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 742  :     if ( constr->content_rank < min_rank ) min_rank = constr->content_rank;

	mov	eax, DWORD PTR [eax+172]
	cmp	eax, DWORD PTR _min_rank$[ebp]
	jge	SHORT $LN25@calc_const@6
	mov	DWORD PTR _min_rank$[ebp], eax
$LN25@calc_const@6:

; 743  :     if ( constr->content_rank > max_rank ) max_rank = constr->content_rank;

	cmp	eax, DWORD PTR _max_rank$[ebp]
	jle	SHORT $LN27@calc_const@6
	mov	DWORD PTR _max_rank$[ebp], eax
$LN27@calc_const@6:

; 736  : 
; 737  : 
; 738  :   min_rank = MAXINT; max_rank = 0;
; 739  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	inc	ecx
	cmp	ecx, edx
	jle	SHORT $LL88@calc_const@6
$LN83@calc_const@6:

; 744  :   }
; 745  :     
; 746  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	edi, 1
	mov	DWORD PTR _j$[ebp], edi
	cmp	edx, edi
	jl	$LN89@calc_const@6
	fld1
	jmp	SHORT $LN23@calc_const@6
$LN85@calc_const@6:
	mov	esi, DWORD PTR _conmap$[ebp]
$LN23@calc_const@6:

; 747  :   {
; 748  :     constr = get_constraint(conmap[j]);

	mov	ebx, DWORD PTR [esi+edi*4]
	and	ebx, 1073741823				; 3fffffffH
	imul	ebx, 176				; 000000b0H
	add	ebx, DWORD PTR _web+652

; 749  :     if ( !(constr->attr & CON_CONTENT) ) continue;

	xor	ecx, ecx
	mov	eax, DWORD PTR [ebx+32]
	and	eax, 128				; 00000080H
	or	eax, ecx
	mov	DWORD PTR _constr$[ebp], ebx
	je	$LN22@calc_const@6

; 750  :     if ( constr->compcount != SDIM ) continue;

	mov	ecx, DWORD PTR _web+616
	cmp	DWORD PTR [ebx+44], ecx
	jne	$LN22@calc_const@6

; 751  :     content = 0.0;

	fldz

; 752  :     for ( k = 0 ; k < gauss1D_num ; k++ )

	xor	edi, edi
	fstp	QWORD PTR _content$[ebp]
	cmp	DWORD PTR _gauss1D_num, edi
	jle	$LN98@calc_const@6
	fild	DWORD PTR _sign$[ebp]
	fstp	QWORD PTR tv768[ebp]
	jmp	SHORT $LN18@calc_const@6
	npad	8
$LL81@calc_const@6:
	fld1
$LN18@calc_const@6:

; 753  :     {
; 754  :       for ( i = 0 ; i < SDIM ; i++ )

	cmp	DWORD PTR _web+616, 0
	jle	SHORT $LN102@calc_const@6
	mov	eax, DWORD PTR _hcoord$[ebp]
	mov	edx, DWORD PTR _tcoord$[ebp]
	mov	ecx, DWORD PTR _gauss1Dpt
	mov	ebx, DWORD PTR _web+616
	lea	esi, DWORD PTR _midpt$[ebp]
	sub	edx, eax
	sub	esi, eax
$LN15@calc_const@6:

; 755  :         midpt[i] = gauss1Dpt[k]*hcoord[i] + (1 - gauss1Dpt[k])*tcoord[i];

	fld	ST(0)
	add	eax, 8
	dec	ebx
	fsub	QWORD PTR [ecx+edi*8]
	fmul	QWORD PTR [edx+eax-8]
	fld	QWORD PTR [ecx+edi*8]
	fmul	QWORD PTR [eax-8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+eax-8]
	jne	SHORT $LN15@calc_const@6

; 753  :     {
; 754  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	ebx, DWORD PTR _constr$[ebp]
$LN102@calc_const@6:

; 756  :       for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	fstp	ST(0)
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN10@calc_const@6
	add	ebx, 108				; 0000006cH
	npad	6
$LL12@calc_const@6:

; 757  :         green[i] = eval(constr->convect[i],midpt,e_id,NULL);

	mov	edx, DWORD PTR _e_id$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ebx]
	push	0
	push	edx
	lea	eax, DWORD PTR _midpt$[ebp]
	push	eax
	push	ecx
	call	_eval
	fstp	QWORD PTR _green$[ebp+esi*8]
	inc	esi
	add	esp, 16					; 00000010H
	add	ebx, 4
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL12@calc_const@6

; 756  :       for ( i = 0 ; i < SDIM ; i++ )

	mov	ebx, DWORD PTR _constr$[ebp]
$LN10@calc_const@6:

; 758  :       content += sign*gauss1Dwt[k]*SDIM_dot(side,green);

	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _green$[ebp]
	push	eax
	lea	ecx, DWORD PTR _side$[ebp]
	push	ecx
	call	_dot
	mov	edx, DWORD PTR _gauss1Dwt
	fld	QWORD PTR [edx+edi*8]
	inc	edi
	fmul	QWORD PTR tv768[ebp]
	add	esp, 12					; 0000000cH
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR _content$[ebp]
	fstp	QWORD PTR _content$[ebp]
	cmp	edi, DWORD PTR _gauss1D_num
	jl	$LL81@calc_const@6

; 752  :     for ( k = 0 ; k < gauss1D_num ; k++ )

	jmp	SHORT $LN16@calc_const@6
$LN98@calc_const@6:
	fstp	ST(0)
$LN16@calc_const@6:

; 759  :     }
; 760  : 
; 761  :     fe_id = first_fe = get_edge_fe(e_id);

	mov	eax, DWORD PTR _e_id$GSCopy$[ebp]
	push	eax
	call	_get_edge_fe
	mov	DWORD PTR _first_fe$[ebp], eax
	mov	edi, eax

; 762  :     if ( valid_id(fe_id) ) do

	shr	eax, 28					; 0000001cH
	add	esp, 4
	test	al, 1
	je	$LN6@calc_const@6
	npad	5
$LL8@calc_const@6:

; 763  :     { /* cell on plus side of edge */
; 764  :       f_id = get_fe_facet(fe_id);

	test	al, 1
	jne	SHORT $LN45@calc_const@6
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN44@calc_const@6
$LN45@calc_const@6:
	mov	edx, DWORD PTR _web+460
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	esi, DWORD PTR [eax+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN44@calc_const@6
	xor	esi, 134217728				; 08000000H
$LN44@calc_const@6:

; 765  :       if ( valid_id(f_id) && !(get_fattr(f_id) & NONCONTENT)
; 766  :         && (constr->content_rank >= max_rank) ) 

	test	esi, 268435456				; 10000000H
	je	$LN84@calc_const@6
	mov	edx, DWORD PTR _web+236
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 536870912				; 20000000H
	xor	edx, edx
	or	eax, edx
	jne	SHORT $LN84@calc_const@6
	mov	eax, DWORD PTR _max_rank$[ebp]
	cmp	DWORD PTR [ebx+172], eax
	jl	SHORT $LN84@calc_const@6

; 767  :       {
; 768  :         b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, edx
	jne	SHORT $LN51@calc_const@6
	xor	ecx, ecx
	jmp	SHORT $LN48@calc_const@6
$LN51@calc_const@6:
	test	esi, 134217728				; 08000000H
	je	SHORT $LN49@calc_const@6
	mov	edx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+784]
	mov	ecx, DWORD PTR [edx+ecx+4]
	jmp	SHORT $LN48@calc_const@6
$LN49@calc_const@6:
	mov	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+784]
	mov	ecx, DWORD PTR [ecx+eax]
$LN48@calc_const@6:

; 769  :         if ( valid_id(b_id) )

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN84@calc_const@6

; 770  :           add_body_volume(b_id,content);

	fld	QWORD PTR _content$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	call	_add_body_volume
	add	esp, 12					; 0000000cH
$LN84@calc_const@6:

; 771  :       }
; 772  :   
; 773  :       /* cell on other side of edge */
; 774  :       f_id = get_fe_facet(inverse_id(fe_id));

	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN55@calc_const@6
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN54@calc_const@6
$LN55@calc_const@6:
	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	esi, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN54@calc_const@6
	xor	esi, 134217728				; 08000000H
$LN54@calc_const@6:

; 775  :       if ( valid_id(f_id) && !(get_fattr(f_id) & NONCONTENT)
; 776  :          && (constr->content_rank <= min_rank) ) 

	test	esi, 268435456				; 10000000H
	je	$LN87@calc_const@6
	mov	eax, DWORD PTR _web+236
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 536870912				; 20000000H
	xor	edx, edx
	or	eax, edx
	jne	SHORT $LN87@calc_const@6
	mov	edx, DWORD PTR _min_rank$[ebp]
	cmp	DWORD PTR [ebx+172], edx
	jg	SHORT $LN87@calc_const@6

; 777  :       {
; 778  :         b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, eax
	jne	SHORT $LN61@calc_const@6
	xor	ecx, ecx
	jmp	SHORT $LN58@calc_const@6
$LN61@calc_const@6:
	test	esi, 134217728				; 08000000H
	je	SHORT $LN59@calc_const@6
	mov	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+784]
	mov	ecx, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN58@calc_const@6
$LN59@calc_const@6:
	mov	edx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+784]
	mov	ecx, DWORD PTR [ecx+edx]
$LN58@calc_const@6:

; 779  :         if ( valid_id(b_id) )

	test	ecx, 268435456				; 10000000H
	je	SHORT $LN87@calc_const@6

; 780  :           add_body_volume(b_id,-content);

	fld	QWORD PTR _content$[ebp]
	sub	esp, 8
	fchs
	fstp	QWORD PTR [esp]
	push	ecx
	call	_add_body_volume
	add	esp, 12					; 0000000cH
$LN87@calc_const@6:

; 781  :       }
; 782  :       fe_id = get_next_facet(fe_id);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN65@calc_const@6
	mov	eax, DWORD PTR _web+460
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR [ecx+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN7@calc_const@6
$LN65@calc_const@6:
	mov	edx, DWORD PTR _web+460
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+edi*4]
	mov	edi, DWORD PTR [eax+40]
$LN7@calc_const@6:

; 783  :     } while ( valid_id(fe_id) && !equal_id(fe_id,first_fe) );

	mov	eax, edi
	shr	eax, 28					; 0000001cH
	test	al, 1
	je	SHORT $LN6@calc_const@6
	cmp	edi, DWORD PTR _first_fe$[ebp]
	jne	$LL8@calc_const@6
$LN6@calc_const@6:
	fld1
	mov	edi, DWORD PTR _j$[ebp]
$LN22@calc_const@6:

; 744  :   }
; 745  :     
; 746  :   for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	ecx, DWORD PTR _conmap$[ebp]
	inc	edi
	mov	DWORD PTR _j$[ebp], edi
	cmp	edi, DWORD PTR [ecx]
	jle	$LN85@calc_const@6
	fstp	ST(0)
$LN89@calc_const@6:

; 784  : 
; 785  :   }
; 786  :   return;
; 787  : 
; 788  : } // end calc_constr_content_e()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_calc_constr_content_e ENDP
_TEXT	ENDS
END
