; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\METIS.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_get_fe_facet
EXTRN	_web:BYTE
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_@2
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_@2:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_@2
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_@2:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_tail_edge PROC				; COMDAT

; 270  : { return eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4+32]
	pop	ebp
	ret	0
_get_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_head_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_head_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_head_edge PROC				; COMDAT

; 273  : { return inverse_id(eptr(e_id)->next_vedge[inverted(e_id) ?0: 1]); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	not	ecx
	and	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4+32]
	xor	eax, 134217728				; 08000000H
	pop	ebp
	ret	0
_get_next_head_edge ENDP
_TEXT	ENDS
PUBLIC	_get_extra
; Function compile flags: /Ogtp
;	COMDAT _get_extra
_TEXT	SEGMENT
_id$ = 8						; size = 4
_n$ = 12						; size = 4
_get_extra PROC						; COMDAT

; 348  : { int type = id_type(id);

	push	ebp
	mov	ebp, esp

; 349  : 
; 350  :   return ( (char*)elptr(id) + EXTRAS(type)[n].offset);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	shr	eax, 29					; 0000001dH
	imul	esi, 240				; 000000f0H
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	push	edi
	mov	edi, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edi, esi
	add	eax, DWORD PTR [edi+ecx+64]
	pop	edi
	pop	esi

; 351  : }

	pop	ebp
	ret	0
_get_extra ENDP
_TEXT	ENDS
PUBLIC	??_C@_07MMLFAKMN@METIS?4C?$AA@			; `string'
PUBLIC	??_C@_05PFCIMAOF@vpart?$AA@			; `string'
PUBLIC	??_C@_0CL@GJAGFHFE@Need?5packed?5vertex?5numbering?5to?5@ ; `string'
PUBLIC	??_C@_0CD@EFFOKEN@Cannot?5do?5Metis?5on?5simplex?5model@ ; `string'
PUBLIC	??_C@_0DH@EKLKLIE@metis?5called?5with?5?$CFd?5parts?$DL?5must@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_metis_partition_plain
EXTRN	_temp_free:PROC
EXTRN	_METIS_PartGraphKway:PROC
EXTRN	_kb_temp_calloc:PROC
EXTRN	_add_attribute:PROC
EXTRN	_find_attribute:PROC
EXTRN	_kb_error:PROC
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_07MMLFAKMN@METIS?4C?$AA@
CONST	SEGMENT
??_C@_07MMLFAKMN@METIS?4C?$AA@ DB 'METIS.C', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PFCIMAOF@vpart?$AA@
CONST	SEGMENT
??_C@_05PFCIMAOF@vpart?$AA@ DB 'vpart', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GJAGFHFE@Need?5packed?5vertex?5numbering?5to?5@
CONST	SEGMENT
??_C@_0CL@GJAGFHFE@Need?5packed?5vertex?5numbering?5to?5@ DB 'Need packed'
	DB	' vertex numbering to do Metis.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EFFOKEN@Cannot?5do?5Metis?5on?5simplex?5model@
CONST	SEGMENT
??_C@_0CD@EFFOKEN@Cannot?5do?5Metis?5on?5simplex?5model@ DB 'Cannot do Me'
	DB	'tis on simplex model.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@EKLKLIE@metis?5called?5with?5?$CFd?5parts?$DL?5must@
CONST	SEGMENT
??_C@_0DH@EKLKLIE@metis?5called?5with?5?$CFd?5parts?$DL?5must@ DB 'metis '
	DB	'called with %d parts; must be at least 2 parts.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\metis.c
CONST	ENDS
;	COMDAT _metis_partition_plain
_TEXT	SEGMENT
_graph$ = -208						; size = 116
_edgecut$ = -92						; size = 4
_numbering$ = -88					; size = 4
_one$91818 = -84					; size = 4
_nparts$ = -80						; size = 4
tv593 = -76						; size = 4
_weightflag$ = -72					; size = 4
tv553 = -68						; size = 4
tv559 = -64						; size = 8
tv641 = -60						; size = 4
_vpart$ = -56						; size = 4
_j$ = -52						; size = 4
_k$ = -52						; size = 4
tv704 = -48						; size = 4
_partition$ = -48					; size = 4
_options$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_parts$ = 8						; size = 4
_algorithm$ = 12					; size = 4
_metis_partition_plain PROC				; COMDAT

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi

; 72   :   int i;
; 73   :   GraphType graph;
; 74   :   int *partition, options[10], edgecut, nparts, numbering;
; 75   :   vertex_id v_id;
; 76   :   edge_id e_id,start_e;
; 77   :   int j,k;
; 78   :   int vpart;
; 79   :   int weightflag = 0;
; 80   : 
; 81   :   if ( parts <= 1 )

	mov	esi, DWORD PTR _parts$[ebp]
	push	edi
	xor	edi, edi
	mov	DWORD PTR _weightflag$[ebp], edi
	cmp	esi, 1
	jg	SHORT $LN25@metis_part

; 82   :   { sprintf(errmsg,"metis called with %d parts; must be at least 2 parts.\n",parts);

	push	esi
	push	OFFSET ??_C@_0DH@EKLKLIE@metis?5called?5with?5?$CFd?5parts?$DL?5must@
	push	OFFSET _errmsg
	call	_sprintf

; 83   :     kb_error(6006,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	6006					; 00001776H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN25@metis_part:

; 84   :   }
; 85   : 
; 86   :   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN24@metis_part

; 87   :      kb_error(1627,"Cannot do Metis on simplex model.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CD@EFFOKEN@Cannot?5do?5Metis?5on?5simplex?5model@
	push	1627					; 0000065bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN24@metis_part:

; 88   : 
; 89   :   if ( web.skel[VERTEX].count != web.skel[VERTEX].max_ord+1 )

	mov	eax, DWORD PTR _web+68
	inc	eax
	cmp	DWORD PTR _web+64, eax
	je	SHORT $LN23@metis_part

; 90   :      kb_error(1628,"Need packed vertex numbering to do Metis.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CL@GJAGFHFE@Need?5packed?5vertex?5numbering?5to?5@
	push	1628					; 0000065cH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN23@metis_part:

; 91   : 
; 92   :   /* use partition attribute for contiguous numbering */
; 93   :   vpart = find_attribute(VERTEX,"vpart");

	push	OFFSET ??_C@_05PFCIMAOF@vpart?$AA@
	push	edi
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _vpart$[ebp], eax

; 94   :   if ( vpart < 0 ) 

	cmp	eax, edi
	jge	SHORT $LN22@metis_part

; 95   :   { int one = 1;
; 96   :     vpart = add_attribute(VERTEX,"vpart",INTEGER_TYPE,0,&one,1,NULL,MPI_NO_PROPAGATE);

	push	edi
	push	edi
	push	1
	lea	ecx, DWORD PTR _one$91818[ebp]
	push	ecx
	push	edi
	push	2
	push	OFFSET ??_C@_05PFCIMAOF@vpart?$AA@
	push	edi
	mov	DWORD PTR _one$91818[ebp], 1
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _vpart$[ebp], eax
$LN22@metis_part:

; 97   :   }
; 98   :   k = 0;
; 99   :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+48
	mov	DWORD PTR _k$[ebp], edi
	test	edx, 268435456				; 10000000H
	je	$LN48@metis_part
	mov	edi, DWORD PTR _web+12
	npad	7
$LL50@metis_part:
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+edi]
	mov	esi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv559[ebp+4], eax
	mov	eax, esi
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN20@metis_part

; 100  :     if ( !(get_vattr(v_id) & (Q_MIDPOINT|Q_MIDEDGE|Q_MIDFACET)) )

	and	esi, 6422528				; 00620000H
	xor	eax, eax
	or	esi, eax
	jne	SHORT $LN20@metis_part

; 101  :       ((int*)get_extra(v_id,vpart))[0] = k++;

	mov	eax, DWORD PTR _vpart$[ebp]
	shr	edx, 29					; 0000001dH
	imul	eax, 240				; 000000f0H
	imul	edx, 112				; 00000070H
	mov	esi, DWORD PTR _web[edx+104]
	mov	edx, DWORD PTR _web[edx+12]
	mov	edx, DWORD PTR [edx+ecx]
	add	esi, eax
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [esi+eax+64]
	mov	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR [esi+edx], eax
	mov	edi, DWORD PTR _web+12
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
$LN20@metis_part:

; 97   :   }
; 98   :   k = 0;
; 99   :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [ecx+edi]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL50@metis_part
	mov	esi, DWORD PTR _parts$[ebp]
	xor	edi, edi
$LN48@metis_part:

; 104  :   memset((char*)&graph,0,sizeof(graph));

	push	116					; 00000074H
	lea	ecx, DWORD PTR _graph$[ebp]
	push	edi
	push	ecx
	mov	DWORD PTR _nparts$[ebp], esi
	call	_memset

; 105  :   
; 106  :   /* construct graph data */
; 107  :   graph.xadj = (int*)temp_calloc(web.skel[VERTEX].count+1,sizeof(int));

	mov	edx, DWORD PTR _web+64
	push	107					; 0000006bH
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	inc	edx
	push	4
	push	edx
	call	_kb_temp_calloc

; 108  :   graph.adjncy = (int*)temp_calloc(2*web.skel[EDGE].count,sizeof(int));

	push	108					; 0000006cH
	mov	DWORD PTR _graph$[ebp+16], eax
	mov	eax, DWORD PTR _web+176
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	lea	ecx, DWORD PTR [eax+eax]
	push	4
	push	ecx
	call	_kb_temp_calloc
	mov	DWORD PTR _graph$[ebp+28], eax

; 109  :   j = 0; i = 0;
; 110  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	add	esp, 44					; 0000002cH
	mov	DWORD PTR _j$[ebp], edi
	test	eax, 268435456				; 10000000H
	je	$LN13@metis_part

; 102  : 
; 103  :   nparts = parts;

	mov	DWORD PTR tv704[ebp], edi
	mov	edi, DWORD PTR _web+12
$LL15@metis_part:

; 109  :   j = 0; i = 0;
; 110  :   FOR_ALL_VERTICES(v_id)

	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	edx, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv559[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv553[ebp], esi
	je	$LN14@metis_part

; 111  :     if ( !(get_vattr(v_id) & (Q_MIDPOINT|Q_MIDEDGE|Q_MIDFACET)) )

	and	ecx, 6422528				; 00620000H
	xor	eax, eax
	or	ecx, eax
	jne	$LN14@metis_part

; 112  :     { e_id = start_e = get_vertex_edge(v_id);

	mov	eax, DWORD PTR [edx+28]
	mov	edi, DWORD PTR _vpart$[ebp]
	mov	esi, DWORD PTR _web+124
	imul	edi, 240				; 000000f0H
	mov	ecx, eax
	or	ecx, 134217728				; 08000000H
	mov	DWORD PTR tv641[ebp], ecx
	npad	7
$LL9@metis_part:

; 113  :       do 
; 114  :       { vertex_id vv_id = get_edge_headv(e_id); 

	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	DWORD PTR tv593[ebp], ecx
	je	SHORT $LN31@metis_part
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edx, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [edx+esi]
	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+esi+304]
	mov	ecx, DWORD PTR [ecx+eax]
	jmp	SHORT $LN30@metis_part
$LN31@metis_part:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edx, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [edx+esi]
	mov	eax, DWORD PTR _web+216
	mov	esi, DWORD PTR _dymem
	add	ecx, DWORD PTR [eax+esi+304]
	mov	eax, DWORD PTR _web+636
	mov	ecx, DWORD PTR [ecx+eax*4]
$LN30@metis_part:

; 115  :         graph.adjncy[j++] = ((int*)get_extra(vv_id,vpart))[0];

	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ebx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web[eax+104]
	add	eax, edi
	mov	eax, DWORD PTR [eax+esi+64]
	mov	esi, DWORD PTR _graph$[ebp+28]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	eax, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR [esi+ecx*4], eax

; 116  :         e_id = get_next_tail_edge(e_id);

	mov	esi, DWORD PTR _web+124
	mov	edx, DWORD PTR [edx+esi]
	mov	eax, DWORD PTR tv593[ebp]
	mov	eax, DWORD PTR [edx+eax*4+32]

; 117  :       } while ( !equal_element(e_id,start_e) );

	mov	edx, eax
	inc	ecx
	or	edx, 134217728				; 08000000H
	mov	DWORD PTR _j$[ebp], ecx
	cmp	edx, DWORD PTR tv641[ebp]
	jne	$LL9@metis_part

; 118  :       graph.xadj[++i] = j;

	mov	eax, DWORD PTR tv704[ebp]
	mov	edx, DWORD PTR _graph$[ebp+16]
	mov	esi, DWORD PTR tv553[ebp]
	add	eax, 4
	mov	DWORD PTR [eax+edx], ecx
	mov	edi, DWORD PTR _web+12
	mov	DWORD PTR tv704[ebp], eax
$LN14@metis_part:

; 109  :   j = 0; i = 0;
; 110  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	jne	$LL15@metis_part
	xor	edi, edi
$LN13@metis_part:

; 119  :     }
; 120  : 
; 121  :   /* do partition */
; 122  :   options[0] = 0;  /* take defaults */
; 123  :   numbering = 0;
; 124  :   graph.nvtxs = web.skel[VERTEX].count;

	mov	eax, DWORD PTR _web+64

; 125  :   partition = (int*)temp_calloc(graph.nvtxs,sizeof(int));

	push	125					; 0000007dH
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	push	4
	push	eax
	mov	DWORD PTR _options$[ebp], edi
	mov	DWORD PTR _numbering$[ebp], edi
	mov	DWORD PTR _graph$[ebp+8], eax
	call	_kb_temp_calloc
	mov	esi, eax

; 126  :   METIS_PartGraphKway(&graph.nvtxs, graph.xadj, graph.adjncy, NULL, NULL, 
; 127  :         &weightflag,&numbering, &nparts, options, &edgecut, partition);

	push	esi
	lea	ecx, DWORD PTR _edgecut$[ebp]
	push	ecx
	lea	edx, DWORD PTR _options$[ebp]
	push	edx
	lea	eax, DWORD PTR _nparts$[ebp]
	push	eax
	mov	eax, DWORD PTR _graph$[ebp+28]
	lea	ecx, DWORD PTR _numbering$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _graph$[ebp+16]
	lea	edx, DWORD PTR _weightflag$[ebp]
	push	edx
	push	edi
	push	edi
	push	eax
	push	ecx
	lea	edx, DWORD PTR _graph$[ebp+8]
	push	edx
	mov	DWORD PTR _partition$[ebp], esi
	call	_METIS_PartGraphKway

; 128  : 
; 129  :   /* label things */
; 130  : 
; 131  :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+48
	add	esp, 60					; 0000003cH
	test	edx, 268435456				; 10000000H
	je	$LN4@metis_part
	mov	edi, DWORD PTR _web+12
	npad	3
$LL6@metis_part:
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+edi]
	mov	esi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv559[ebp+4], eax
	mov	eax, esi
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN5@metis_part

; 132  :     if ( !(get_vattr(v_id) & (Q_MIDPOINT|Q_MIDEDGE|Q_MIDFACET)) )

	and	esi, 6422528				; 00620000H
	xor	eax, eax
	or	esi, eax
	jne	SHORT $LN5@metis_part

; 133  :     { int *vspot = ((int*)get_extra(v_id,vpart));

	mov	eax, DWORD PTR _vpart$[ebp]
	shr	edx, 29					; 0000001dH
	imul	eax, 240				; 000000f0H
	imul	edx, 112				; 00000070H
	mov	esi, DWORD PTR _web[edx+104]
	mov	edx, DWORD PTR _web[edx+12]
	add	esi, eax
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [esi+eax+64]
	add	eax, DWORD PTR [edx+ecx]

; 134  :       *vspot = partition[*vspot];

	mov	esi, DWORD PTR _partition$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [eax], edx
	mov	edi, DWORD PTR _web+12
$LN5@metis_part:

; 128  : 
; 129  :   /* label things */
; 130  : 
; 131  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [ecx+edi]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL6@metis_part
	mov	esi, DWORD PTR _partition$[ebp]
$LN4@metis_part:

; 135  :     }
; 136  : 
; 137  :   /* free storage */
; 138  :   temp_free((char*)graph.xadj);

	mov	ecx, DWORD PTR _graph$[ebp+16]
	push	ecx
	call	_temp_free

; 139  :   temp_free((char*)graph.adjncy);

	mov	edx, DWORD PTR _graph$[ebp+28]
	push	edx
	call	_temp_free

; 140  :   temp_free((char*)partition);

	push	esi
	call	_temp_free

; 141  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_metis_partition_plain ENDP
_TEXT	ENDS
PUBLIC	??_C@_05PGPOMCHO@fpart?$AA@			; `string'
PUBLIC	??_C@_05HAGKLANA@epart?$AA@			; `string'
PUBLIC	??_C@_0DA@MAPPALIP@Number?5of?5METIS?5partitions?5must?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_metis_partition_dual
EXTRN	_get_edge_valence:PROC
;	COMDAT ??_C@_05PGPOMCHO@fpart?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_05PGPOMCHO@fpart?$AA@ DB 'fpart', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HAGKLANA@epart?$AA@
CONST	SEGMENT
??_C@_05HAGKLANA@epart?$AA@ DB 'epart', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@MAPPALIP@Number?5of?5METIS?5partitions?5must?5@
CONST	SEGMENT
??_C@_0DA@MAPPALIP@Number?5of?5METIS?5partitions?5must?5@ DB 'Number of M'
	DB	'ETIS partitions must be at least 2.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\metis.c
CONST	ENDS
;	COMDAT _metis_partition_dual
_TEXT	SEGMENT
_graph$ = -208						; size = 116
tv1355 = -92						; size = 4
_edgecut$ = -88						; size = 4
_weightflag$ = -84					; size = 4
_nparts$ = -80						; size = 4
tv1293 = -76						; size = 4
_one$91979 = -76					; size = 4
tv1399 = -72						; size = 4
_one$91911 = -72					; size = 4
_numbering$ = -68					; size = 4
tv1580 = -64						; size = 4
tv682 = -64						; size = 4
tv1603 = -60						; size = 4
tv1224 = -60						; size = 4
_j$ = -56						; size = 4
_start_fe$92014 = -52					; size = 4
_epart$91906 = -52					; size = 4
tv1244 = -48						; size = 4
_fpart$91974 = -48					; size = 4
_adj$91907 = -48					; size = 4
_options$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_parts$ = 8						; size = 4
_algorithm$ = 12					; size = 4
_metis_partition_dual PROC				; COMDAT

; 156  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 157  :   int i,k;
; 158  :   GraphType graph;
; 159  :   int *partition, options[10], edgecut, nparts, numbering;
; 160  :   vertex_id v_id;
; 161  :   edge_id e_id;
; 162  :   int j;
; 163  :   int weightflag = 0;

	xor	ebx, ebx

; 164  : 
; 165  :   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	push	esi
	push	edi
	mov	DWORD PTR _weightflag$[ebp], ebx
	lea	edi, DWORD PTR [ebx+1]
	jne	SHORT $LN58@metis_part@2

; 166  :      kb_error(1629,"Cannot do Metis on simplex model.\n",RECOVERABLE);

	push	edi
	push	OFFSET ??_C@_0CD@EFFOKEN@Cannot?5do?5Metis?5on?5simplex?5model@
	push	1629					; 0000065dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN58@metis_part@2:

; 167  : 
; 168  :   if ( parts < 2 )

	mov	esi, DWORD PTR _parts$[ebp]
	cmp	esi, 2
	jge	SHORT $LN57@metis_part@2

; 169  :      kb_error(3632,"Number of METIS partitions must be at least 2.\n",
; 170  :          RECOVERABLE);

	push	edi
	push	OFFSET ??_C@_0DA@MAPPALIP@Number?5of?5METIS?5partitions?5must?5@
	push	3632					; 00000e30H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN57@metis_part@2:

; 171  : 
; 172  :   
; 173  :   nparts = parts;
; 174  :   memset((char*)&graph,0,sizeof(graph));

	push	116					; 00000074H
	lea	eax, DWORD PTR _graph$[ebp]
	push	ebx
	push	eax
	mov	DWORD PTR _nparts$[ebp], esi
	call	_memset
	add	esp, 12					; 0000000cH

; 175  :   
; 176  :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, edi
	jne	$LN56@metis_part@2

; 177  :   {
; 178  :      int epart;
; 179  :      int adj; /* total adjacencies */
; 180  :      edge_id ee;
; 181  : 
; 182  :      /* get partition attribute */
; 183  :      epart = find_attribute(EDGE,"epart");

	push	OFFSET ??_C@_05HAGKLANA@epart?$AA@
	push	edi
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _epart$91906[ebp], eax

; 184  :      if ( epart < 0 ) 

	cmp	eax, ebx
	jge	SHORT $LN55@metis_part@2

; 185  :      { int one = 1;
; 186  :        epart = add_attribute(EDGE,"epart",INTEGER_TYPE,0,&one,1,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	edi
	lea	ecx, DWORD PTR _one$91911[ebp]
	push	ecx
	push	ebx
	push	2
	push	OFFSET ??_C@_05HAGKLANA@epart?$AA@
	push	edi
	mov	DWORD PTR _one$91911[ebp], edi
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _epart$91906[ebp], eax
$LN55@metis_part@2:

; 187  :      }
; 188  : 
; 189  :      /* use partition attribute for contiguous numbering */
; 190  :      k = 0;
; 191  :      FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	mov	edi, DWORD PTR _web+124
	test	edx, 268435456				; 10000000H
	je	SHORT $LN52@metis_part@2
	npad	3
$LL54@metis_part@2:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edi]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	esi, esi
	or	ecx, esi
	je	SHORT $LN53@metis_part@2

; 192  :         ((int*)get_extra(e_id,epart))[0] = k++;

	mov	ecx, DWORD PTR _epart$91906[ebp]
	shr	edx, 29					; 0000001dH
	imul	ecx, 240				; 000000f0H
	imul	edx, 112				; 00000070H
	mov	esi, DWORD PTR _web[edx+104]
	mov	edx, DWORD PTR _web[edx+12]
	mov	edx, DWORD PTR [edx+eax]
	add	esi, ecx
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [esi+ecx+64]
	mov	DWORD PTR [ecx+edx], ebx
	mov	edi, DWORD PTR _web+124
	inc	ebx
$LN53@metis_part@2:

; 187  :      }
; 188  : 
; 189  :      /* use partition attribute for contiguous numbering */
; 190  :      k = 0;
; 191  :      FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL54@metis_part@2
$LN52@metis_part@2:

; 193  : 
; 194  :      /* count adjacencies */
; 195  :      adj = 0;
; 196  :      FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	DWORD PTR _adj$91907[ebp], 0
	test	eax, 268435456				; 10000000H
	je	SHORT $LN47@metis_part@2
	npad	2
$LL49@metis_part@2:
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN48@metis_part@2

; 197  :      { int valence = 0;
; 198  :         e_id = ee = get_vertex_edge(v_id);

	mov	eax, DWORD PTR [esi+28]
	mov	edx, eax
	npad	1
$LL44@metis_part@2:

; 199  :         do{
; 200  :           valence++;
; 201  :           ee = get_next_tail_edge(ee);

	mov	ebx, eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	shr	ebx, 27					; 0000001bH
	and	ebx, 1
	mov	eax, DWORD PTR [eax+ebx*4+32]
	inc	ecx

; 202  :           } while ( !equal_id(ee,e_id) );

	cmp	eax, edx
	jne	SHORT $LL44@metis_part@2

; 203  :         adj += (valence-1)*valence;

	lea	edx, DWORD PTR [ecx-1]
	imul	edx, ecx
	add	DWORD PTR _adj$91907[ebp], edx
$LN48@metis_part@2:

; 193  : 
; 194  :      /* count adjacencies */
; 195  :      adj = 0;
; 196  :      FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [esi]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL49@metis_part@2
$LN47@metis_part@2:

; 204  :      }
; 205  :      /* construct graph data */
; 206  :      graph.xadj = (int*)temp_calloc(web.skel[EDGE].count+1,sizeof(int));

	mov	eax, DWORD PTR _web+176
	push	206					; 000000ceH
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	inc	eax
	push	4
	push	eax
	call	_kb_temp_calloc

; 207  :      graph.adjncy = (int*)temp_calloc(adj,sizeof(int));

	mov	ecx, DWORD PTR _adj$91907[ebp]
	push	207					; 000000cfH
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	push	4
	push	ecx
	mov	DWORD PTR _graph$[ebp+16], eax
	call	_kb_temp_calloc

; 208  :      j = 0; i = 0;
; 209  :      FOR_ALL_EDGES(e_id)

	mov	esi, DWORD PTR _web+160
	mov	DWORD PTR _graph$[ebp+28], eax
	xor	eax, eax
	add	esp, 32					; 00000020H
	mov	DWORD PTR _j$[ebp], eax
	test	esi, 268435456				; 10000000H
	je	$LN39@metis_part@2

; 204  :      }
; 205  :      /* construct graph data */
; 206  :      graph.xadj = (int*)temp_calloc(web.skel[EDGE].count+1,sizeof(int));

	mov	DWORD PTR tv1580[ebp], eax
$LL41@metis_part@2:

; 208  :      j = 0; i = 0;
; 209  :      FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+124
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+edx]
	mov	ecx, DWORD PTR [edx+8]
	and	ecx, 1
	xor	ebx, ebx
	or	ecx, ebx
	mov	DWORD PTR tv1224[ebp], edi
	je	$LN40@metis_part@2

; 210  :      { 
; 211  :         ee = get_next_tail_edge(e_id);

	mov	ecx, esi
	shr	ecx, 27					; 0000001bH
	mov	ebx, ecx
	and	ebx, 1
	mov	edx, DWORD PTR [edx+ebx*4+32]
	mov	DWORD PTR tv1293[ebp], ecx

; 212  :         while ( !equal_id(ee,e_id) )

	cmp	edx, esi
	je	SHORT $LN133@metis_part@2
	mov	edi, DWORD PTR _epart$91906[ebp]
	imul	edi, 240				; 000000f0H
	mov	DWORD PTR tv1244[ebp], edi
	jmp	SHORT $LN36@metis_part@2
	npad	4
$LL130@metis_part@2:
	mov	edi, DWORD PTR tv1244[ebp]
$LN36@metis_part@2:

; 213  :         { graph.adjncy[j++] = ((int*)get_extra(ee,epart))[0];

	mov	eax, edx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ebx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ebx, edi
	mov	edi, DWORD PTR _dymem
	mov	edi, DWORD PTR [ebx+edi+64]
	mov	ebx, DWORD PTR _graph$[ebp+28]
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [eax+ecx]
	mov	edi, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR [ebx+eax*4], edi

; 214  :           ee = get_next_tail_edge(ee);

	mov	edi, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ecx+edi]
	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	edx, DWORD PTR [ecx+edx*4+32]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	edx, esi
	jne	SHORT $LL130@metis_part@2

; 212  :         while ( !equal_id(ee,e_id) )

	mov	edi, DWORD PTR tv1224[ebp]
	mov	ecx, DWORD PTR tv1293[ebp]
$LN133@metis_part@2:

; 215  :         }
; 216  :         ee = get_next_head_edge(e_id);

	mov	edx, DWORD PTR _web+124
	mov	edx, DWORD PTR [edi+edx]
	not	ecx
	and	ecx, 1
	mov	ecx, DWORD PTR [edx+ecx*4+32]
	xor	ecx, 134217728				; 08000000H

; 217  :         while ( !equal_id(ee,e_id) )

	cmp	ecx, esi
	je	SHORT $LN33@metis_part@2
	mov	edi, DWORD PTR _epart$91906[ebp]
	imul	edi, 240				; 000000f0H
	mov	DWORD PTR tv1244[ebp], edi
	jmp	SHORT $LN34@metis_part@2
	npad	4
$LL131@metis_part@2:
	mov	edi, DWORD PTR tv1244[ebp]
$LN34@metis_part@2:

; 218  :         { graph.adjncy[j++] = ((int*)get_extra(ee,epart))[0];

	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ebx, DWORD PTR _web[eax+104]
	mov	eax, DWORD PTR _web[eax+12]
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	add	ebx, edi
	mov	edi, DWORD PTR _dymem
	mov	edi, DWORD PTR [ebx+edi+64]
	mov	ebx, DWORD PTR _graph$[ebp+28]
	add	edx, edx
	add	edx, edx
	mov	eax, DWORD PTR [eax+edx]
	mov	edi, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR _j$[ebp]

; 219  :           ee = get_next_head_edge(ee);

	shr	ecx, 27					; 0000001bH
	mov	DWORD PTR [ebx+eax*4], edi
	mov	edi, DWORD PTR _web+124
	mov	edx, DWORD PTR [edx+edi]
	not	ecx
	and	ecx, 1
	mov	ecx, DWORD PTR [edx+ecx*4+32]
	inc	eax
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR _j$[ebp], eax
	cmp	ecx, esi
	jne	SHORT $LL131@metis_part@2

; 217  :         while ( !equal_id(ee,e_id) )

	mov	edi, DWORD PTR tv1224[ebp]
$LN33@metis_part@2:

; 220  :         }
; 221  :         graph.xadj[++i] = j;

	mov	ecx, DWORD PTR tv1580[ebp]
	mov	edx, DWORD PTR _graph$[ebp+16]
	add	ecx, 4
	mov	DWORD PTR tv1580[ebp], ecx
	mov	DWORD PTR [ecx+edx], eax
$LN40@metis_part@2:

; 208  :      j = 0; i = 0;
; 209  :      FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [edi+ecx]
	mov	esi, DWORD PTR [edx]
	test	esi, 268435456				; 10000000H
	jne	$LL41@metis_part@2
$LN39@metis_part@2:

; 222  :      }
; 223  : 
; 224  :      /* do partition */
; 225  :      options[0] = 0; /* take defaults */
; 226  :      numbering = 0;
; 227  :      graph.nvtxs = web.skel[EDGE].count;

	mov	eax, DWORD PTR _web+176

; 228  :      partition = (int*)temp_calloc(graph.nvtxs,sizeof(int));

	push	228					; 000000e4H
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	xor	esi, esi
	push	4
	push	eax
	mov	DWORD PTR _options$[ebp], esi
	mov	DWORD PTR _numbering$[ebp], esi
	mov	DWORD PTR _graph$[ebp+8], eax
	call	_kb_temp_calloc
	mov	edi, eax

; 229  :      METIS_PartGraphKway(&graph.nvtxs, graph.xadj, graph.adjncy, NULL, NULL, 
; 230  :           &weightflag,&numbering, &nparts, options, &edgecut, partition);

	push	edi
	lea	eax, DWORD PTR _edgecut$[ebp]
	push	eax
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	lea	edx, DWORD PTR _nparts$[ebp]
	push	edx
	mov	edx, DWORD PTR _graph$[ebp+28]
	lea	eax, DWORD PTR _numbering$[ebp]
	push	eax
	mov	eax, DWORD PTR _graph$[ebp+16]
	lea	ecx, DWORD PTR _weightflag$[ebp]
	push	ecx
	push	esi
	push	esi
	push	edx
	push	eax
	lea	ecx, DWORD PTR _graph$[ebp+8]
	push	ecx
	call	_METIS_PartGraphKway

; 231  :      /* label things */
; 232  :      FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	add	esp, 60					; 0000003cH
	test	edx, 268435456				; 10000000H
	je	$LN3@metis_part@2
	mov	ebx, DWORD PTR _web+124
$LL32@metis_part@2:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	esi, esi
	or	ecx, esi
	je	SHORT $LN31@metis_part@2

; 233  :      { int *espot = ((int*)get_extra(e_id,epart));

	mov	ecx, DWORD PTR _epart$91906[ebp]
	shr	edx, 29					; 0000001dH
	imul	ecx, 240				; 000000f0H
	imul	edx, 112				; 00000070H
	mov	esi, DWORD PTR _web[edx+104]
	mov	edx, DWORD PTR _web[edx+12]
	add	esi, ecx
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [esi+ecx+64]
	add	ecx, DWORD PTR [edx+eax]

; 234  :        *espot = partition[*espot];

	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [ecx], edx
	mov	ebx, DWORD PTR _web+124
$LN31@metis_part@2:

; 231  :      /* label things */
; 232  :      FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR [eax+ebx]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL32@metis_part@2

; 235  :      }
; 236  :   }
; 237  :   else /* SOAPFILM */

	jmp	$LN3@metis_part@2
$LN56@metis_part@2:

; 238  :   { 
; 239  :      int fpart;
; 240  :      int adj; /* total adjacencies */
; 241  :      facet_id f_id;
; 242  : 
; 243  :      /* get facet partition attribute */
; 244  :      fpart = find_attribute(FACET,"fpart");

	push	OFFSET ??_C@_05PGPOMCHO@fpart?$AA@
	push	2
	call	_find_attribute
	add	esp, 8
	mov	DWORD PTR _fpart$91974[ebp], eax

; 245  :      if ( fpart < 0 ) 

	cmp	eax, ebx
	jge	SHORT $LN26@metis_part@2

; 246  :      { int one = 1;
; 247  :        fpart = add_attribute(FACET,"fpart",INTEGER_TYPE,0,&one,1,NULL,MPI_NO_PROPAGATE);

	push	ebx
	push	ebx
	push	edi
	lea	ecx, DWORD PTR _one$91979[ebp]
	push	ecx
	push	ebx
	push	2
	push	OFFSET ??_C@_05PGPOMCHO@fpart?$AA@
	push	2
	mov	DWORD PTR _one$91979[ebp], edi
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _fpart$91974[ebp], eax
$LN26@metis_part@2:

; 248  :      }
; 249  : 
; 250  :      /* use partition attribute to hold contiguous ordinals */
; 251  :      k = 0;
; 252  :      FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	xor	ebx, ebx
	test	edx, 268435456				; 10000000H
	je	SHORT $LN23@metis_part@2
	mov	edi, DWORD PTR _web+236
$LL25@metis_part@2:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edi]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	esi, esi
	or	ecx, esi
	je	SHORT $LN24@metis_part@2

; 253  :         ((int*)get_extra(f_id,fpart))[0] = k++;

	mov	ecx, DWORD PTR _fpart$91974[ebp]
	shr	edx, 29					; 0000001dH
	imul	ecx, 240				; 000000f0H
	imul	edx, 112				; 00000070H
	mov	esi, DWORD PTR _web[edx+104]
	mov	edx, DWORD PTR _web[edx+12]
	mov	edx, DWORD PTR [edx+eax]
	add	esi, ecx
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [esi+ecx+64]
	mov	DWORD PTR [ecx+edx], ebx
	mov	edi, DWORD PTR _web+236
	inc	ebx
$LN24@metis_part@2:

; 248  :      }
; 249  : 
; 250  :      /* use partition attribute to hold contiguous ordinals */
; 251  :      k = 0;
; 252  :      FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL25@metis_part@2
$LN23@metis_part@2:

; 254  : 
; 255  :      /* count adjacencies */
; 256  :      adj = 0;
; 257  :      FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+160
	xor	ebx, ebx
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN18@metis_part@2
	mov	edi, DWORD PTR _web+124
$LL20@metis_part@2:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN19@metis_part@2

; 258  :      { int valence = get_edge_valence(e_id);

	push	ecx
	call	_get_edge_valence

; 259  :        adj += (valence-1)*valence;

	mov	edi, DWORD PTR _web+124
	lea	ecx, DWORD PTR [eax-1]
	imul	ecx, eax
	add	esp, 4
	add	ebx, ecx
$LN19@metis_part@2:

; 254  : 
; 255  :      /* count adjacencies */
; 256  :      adj = 0;
; 257  :      FOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR [esi+edi]
	mov	ecx, DWORD PTR [edx]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL20@metis_part@2
$LN18@metis_part@2:

; 260  :      }
; 261  :      /* construct graph data */
; 262  :      graph.xadj = (int*)temp_calloc(web.skel[FACET].count+1,sizeof(int));

	mov	eax, DWORD PTR _web+288
	push	262					; 00000106H
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	inc	eax
	push	4
	push	eax
	call	_kb_temp_calloc

; 263  :      graph.adjncy = (int*)temp_calloc(adj,sizeof(int));

	push	263					; 00000107H
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	push	4
	push	ebx
	mov	DWORD PTR _graph$[ebp+16], eax
	call	_kb_temp_calloc

; 264  :      j = 0; i = 0;
; 265  :      FOR_ALL_FACETS(f_id)

	mov	esi, DWORD PTR _web+272
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	add	esp, 32					; 00000020H
	and	ecx, 1
	mov	DWORD PTR _graph$[ebp+28], eax
	mov	DWORD PTR _j$[ebp], 0
	je	$LN13@metis_part@2

; 260  :      }
; 261  :      /* construct graph data */
; 262  :      graph.xadj = (int*)temp_calloc(web.skel[FACET].count+1,sizeof(int));

	mov	ebx, DWORD PTR _web+236
	mov	DWORD PTR tv1603[ebp], 0
$LL15@metis_part@2:

; 264  :      j = 0; i = 0;
; 265  :      FOR_ALL_FACETS(f_id)

	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ebx]
	mov	DWORD PTR tv1355[ebp], eax
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN14@metis_part@2

; 266  :      { facetedge_id start_fe = get_facet_fe(f_id);

	test	ecx, ecx
	jne	SHORT $LN82@metis_part@2
	xor	edx, edx
	jmp	SHORT $LN81@metis_part@2
$LN82@metis_part@2:
	mov	edx, DWORD PTR [edx+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN81@metis_part@2
	xor	edx, 134217728				; 08000000H
$LN81@metis_part@2:

; 267  :        facetedge_id fe;
; 268  :         
; 269  :        for ( k = 0 ; k < FACET_EDGES ; k++ )

	mov	eax, DWORD PTR _web+460
	mov	DWORD PTR _start_fe$92014[ebp], edx
	mov	DWORD PTR tv682[ebp], 3
	npad	5
$LL10@metis_part@2:

; 270  :        { fe = get_next_facet(start_fe);

	mov	edi, edx
	shr	edi, 27					; 0000001bH
	and	edi, 1
	mov	DWORD PTR tv1399[ebp], edi
	mov	esi, edx
	je	SHORT $LN86@metis_part@2
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	mov	ecx, DWORD PTR [ecx+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN116@metis_part@2
$LN86@metis_part@2:
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	mov	ecx, DWORD PTR [ecx+40]
$LN116@metis_part@2:

; 271  :          while ( !equal_id(fe,start_fe) )

	cmp	ecx, edx
	je	$LN6@metis_part@2
	mov	edi, DWORD PTR _fpart$91974[ebp]
	imul	edi, 240				; 000000f0H
$LL7@metis_part@2:

; 272  :          { facet_id ff_id = get_fe_facet(fe); 

	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN90@metis_part@2
	mov	edx, DWORD PTR _NULLFACET
	jmp	SHORT $LN89@metis_part@2
$LN90@metis_part@2:
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [eax+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN89@metis_part@2
	xor	edx, 134217728				; 08000000H
$LN89@metis_part@2:

; 273  :            graph.adjncy[j++] = ((int*)get_extra(ff_id,fpart))[0];

	mov	eax, edx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	ebx, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web[eax+104]
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _dymem
	add	eax, edi
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	edx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ebx, DWORD PTR _graph$[ebp+28]
	mov	DWORD PTR [ebx+eax*4], edx
	inc	eax
	mov	DWORD PTR _j$[ebp], eax

; 274  :            fe = get_next_facet(fe);

	mov	eax, DWORD PTR _web+460
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN96@metis_part@2
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [ecx+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN95@metis_part@2
$LN96@metis_part@2:
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [edx+40]
$LN95@metis_part@2:

; 271  :          while ( !equal_id(fe,start_fe) )

	cmp	ecx, DWORD PTR _start_fe$92014[ebp]
	jne	$LL7@metis_part@2
	mov	edi, DWORD PTR tv1399[ebp]
$LN6@metis_part@2:

; 275  :          }
; 276  :          start_fe = get_next_edge(start_fe);

	test	edi, edi
	je	SHORT $LN100@metis_part@2
	mov	ecx, DWORD PTR [esi+eax]
	mov	edx, DWORD PTR [ecx+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN136@metis_part@2
$LN100@metis_part@2:
	mov	edx, DWORD PTR [esi+eax]
	mov	edx, DWORD PTR [edx+32]
$LN136@metis_part@2:
	dec	DWORD PTR tv682[ebp]
	mov	DWORD PTR _start_fe$92014[ebp], edx
	jne	$LL10@metis_part@2

; 277  :        }
; 278  :        graph.xadj[++i] = j;

	mov	eax, DWORD PTR tv1603[ebp]
	mov	ecx, DWORD PTR _graph$[ebp+16]
	mov	edx, DWORD PTR _j$[ebp]
	add	eax, 4
	mov	DWORD PTR [eax+ecx], edx
	mov	ebx, DWORD PTR _web+236
	mov	DWORD PTR tv1603[ebp], eax
$LN14@metis_part@2:

; 264  :      j = 0; i = 0;
; 265  :      FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR tv1355[ebp]
	mov	ecx, DWORD PTR [eax+ebx]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LL15@metis_part@2
$LN13@metis_part@2:

; 279  :      }
; 280  : 
; 281  :      /* do partition */
; 282  :      options[0] = 0; /* take defaults */
; 283  :      numbering = 0;
; 284  :      graph.nvtxs = web.skel[FACET].count;

	mov	eax, DWORD PTR _web+288

; 285  :      partition = (int*)temp_calloc(graph.nvtxs,sizeof(int));

	push	285					; 0000011dH
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	xor	esi, esi
	push	4
	push	eax
	mov	DWORD PTR _options$[ebp], esi
	mov	DWORD PTR _numbering$[ebp], esi
	mov	DWORD PTR _graph$[ebp+8], eax
	call	_kb_temp_calloc
	mov	edi, eax

; 286  :      METIS_PartGraphKway(&graph.nvtxs, graph.xadj, graph.adjncy, NULL, NULL, 
; 287  :           &weightflag,&numbering, &nparts, options, &edgecut, partition);

	push	edi
	lea	edx, DWORD PTR _edgecut$[ebp]
	push	edx
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nparts$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _graph$[ebp+28]
	lea	edx, DWORD PTR _numbering$[ebp]
	push	edx
	mov	edx, DWORD PTR _graph$[ebp+16]
	lea	eax, DWORD PTR _weightflag$[ebp]
	push	eax
	push	esi
	push	esi
	push	ecx
	push	edx
	lea	eax, DWORD PTR _graph$[ebp+8]
	push	eax
	call	_METIS_PartGraphKway

; 288  :      /* label things */
; 289  :      FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	add	esp, 60					; 0000003cH
	test	edx, 268435456				; 10000000H
	je	SHORT $LN3@metis_part@2
	mov	ebx, DWORD PTR _web+236
	npad	3
$LL5@metis_part@2:
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [ecx+8]
	and	ecx, 1
	xor	esi, esi
	or	ecx, esi
	je	SHORT $LN4@metis_part@2

; 290  :      { int *fspot = ((int*)get_extra(f_id,fpart));

	mov	ecx, DWORD PTR _fpart$91974[ebp]
	shr	edx, 29					; 0000001dH
	imul	ecx, 240				; 000000f0H
	imul	edx, 112				; 00000070H
	mov	esi, DWORD PTR _web[edx+104]
	mov	edx, DWORD PTR _web[edx+12]
	add	esi, ecx
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [esi+ecx+64]
	add	ecx, DWORD PTR [edx+eax]

; 291  :        *fspot = partition[*fspot];

	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [ecx], edx
	mov	ebx, DWORD PTR _web+236
$LN4@metis_part@2:

; 288  :      /* label things */
; 289  :      FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR [eax+ebx]
	mov	edx, DWORD PTR [eax]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL5@metis_part@2
$LN3@metis_part@2:

; 292  :      }
; 293  :   }
; 294  : 
; 295  :   /* free storage */
; 296  :   temp_free((char*)graph.xadj);

	mov	ecx, DWORD PTR _graph$[ebp+16]
	push	ecx
	call	_temp_free

; 297  :   temp_free((char*)graph.adjncy);

	mov	edx, DWORD PTR _graph$[ebp+28]
	push	edx
	call	_temp_free

; 298  :   temp_free((char*)partition);

	push	edi
	call	_temp_free

; 299  : 
; 300  : } /* end metis_partition_dual */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_metis_partition_dual ENDP
_TEXT	ENDS
PUBLIC	_adjcomp
; Function compile flags: /Ogtp
;	COMDAT _adjcomp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_adjcomp PROC						; COMDAT

; 314  : { if ( a->b1 < b->b1 ) return -1;

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [esi]
	cmp	eax, ecx
	jge	SHORT $LN7@adjcomp
$LN8@adjcomp:
	or	eax, -1
	pop	esi

; 318  :   return 0;
; 319  : }

	pop	ebp
	ret	0
$LN7@adjcomp:

; 315  :   if ( a->b1 > b->b1 ) return  1;

	jle	SHORT $LN3@adjcomp
	mov	eax, 1
	pop	esi

; 318  :   return 0;
; 319  : }

	pop	ebp
	ret	0
$LN3@adjcomp:

; 316  :   if ( a->b2 < b->b2 ) return -1;

	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [esi+4]
	cmp	eax, ecx
	jl	SHORT $LN8@adjcomp

; 317  :   if ( a->b2 > b->b2 ) return  1;

	xor	edx, edx
	cmp	eax, ecx
	setg	dl
	pop	esi
	mov	eax, edx

; 318  :   return 0;
; 319  : }

	pop	ebp
	ret	0
_adjcomp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@BCNANHFE@internal?5error?5?9?5body?5count?5disa@ ; `string'
PUBLIC	??_C@_05GNGPIAGI@bpart?$AA@			; `string'
PUBLIC	??_C@_0CI@MIKHPBJE@Cannot?5do?5body?5Metis?5in?5string?5m@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_metis_partition_body
EXTRN	_kb_temp_realloc:PROC
EXTRN	_qsort:PROC
;	COMDAT ??_C@_0CL@BCNANHFE@internal?5error?5?9?5body?5count?5disa@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CL@BCNANHFE@internal?5error?5?9?5body?5count?5disa@ DB 'internal e'
	DB	'rror - body count disagreement ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GNGPIAGI@bpart?$AA@
CONST	SEGMENT
??_C@_05GNGPIAGI@bpart?$AA@ DB 'bpart', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MIKHPBJE@Cannot?5do?5body?5Metis?5in?5string?5m@
CONST	SEGMENT
??_C@_0CI@MIKHPBJE@Cannot?5do?5body?5Metis?5in?5string?5m@ DB 'Cannot do '
	DB	'body Metis in string model. ', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\metis.c
CONST	ENDS
;	COMDAT _metis_partition_body
_TEXT	SEGMENT
_graph$ = -208						; size = 116
_edgecut$ = -92						; size = 4
_numbering$ = -88					; size = 4
tv706 = -84						; size = 4
_nparts$ = -80						; size = 4
_weightflag$ = -76					; size = 4
_one$92087 = -72					; size = 4
_adjcount$ = -68					; size = 4
_inx_to_bdy$ = -64					; size = 4
_adjlist$ = -60						; size = 4
_bdy_to_inx$ = -56					; size = 4
tv454 = -52						; size = 4
_bpart$ = -52						; size = 4
_partition$ = -48					; size = 4
_bcount$ = -48						; size = 4
_options$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_parts$ = 8						; size = 4
_algorithm$ = 12					; size = 4
_metis_partition_body PROC				; COMDAT

; 325  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 326  :   int i,m;
; 327  :   GraphType graph;
; 328  :   int *partition, options[10], edgecut, nparts, numbering;
; 329  :   int adjcount; /* total adjacencies */
; 330  :   facet_id f_id;
; 331  :   int *bdy_to_inx;
; 332  :   body_id *inx_to_bdy;
; 333  :   int bcount = web.skel[BODY].count;

	mov	edi, DWORD PTR _web+400

; 334  :   int weightflag;
; 335  :   struct bb_adj *adjlist;
; 336  :   body_id b_id;
; 337  :   int bod;
; 338  :   int bpart;
; 339  :   int inx,spot;
; 340  : 
; 341  :   if ( web.representation == STRING )

	mov	ebx, 1
	mov	DWORD PTR _bcount$[ebp], edi
	cmp	DWORD PTR _web+624, ebx
	jne	SHORT $LN31@metis_part@3

; 342  :      kb_error(3770,"Cannot do body Metis in string model. \n",RECOVERABLE);

	push	ebx
	push	OFFSET ??_C@_0CI@MIKHPBJE@Cannot?5do?5body?5Metis?5in?5string?5m@
	push	3770					; 00000ebaH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN31@metis_part@3:

; 343  : 
; 344  :   if ( parts < 2 )

	mov	esi, DWORD PTR _parts$[ebp]
	cmp	esi, 2
	jge	SHORT $LN30@metis_part@3

; 345  :      kb_error(3771,"Number of METIS partitions must be at least 2.\n",
; 346  :          RECOVERABLE);

	push	ebx
	push	OFFSET ??_C@_0DA@MAPPALIP@Number?5of?5METIS?5partitions?5must?5@
	push	3771					; 00000ebbH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN30@metis_part@3:

; 347  : 
; 348  :   
; 349  :   nparts = parts;
; 350  :   memset((char*)&graph,0,sizeof(graph));

	push	116					; 00000074H
	lea	eax, DWORD PTR _graph$[ebp]
	push	0
	push	eax
	mov	DWORD PTR _nparts$[ebp], esi
	call	_memset

; 351  : 
; 352  :   bpart = find_attribute(BODY,"bpart");

	push	OFFSET ??_C@_05GNGPIAGI@bpart?$AA@
	push	3
	call	_find_attribute
	add	esp, 20					; 00000014H
	mov	DWORD PTR _bpart$[ebp], eax

; 353  :   if ( bpart < 0 ) 

	test	eax, eax
	jns	SHORT $LN29@metis_part@3

; 354  :   { int one = 1;
; 355  :     bpart = add_attribute(BODY,"bpart",INTEGER_TYPE,0,&one,1,NULL,MPI_NO_PROPAGATE);

	push	0
	push	0
	push	ebx
	lea	ecx, DWORD PTR _one$92087[ebp]
	push	ecx
	push	0
	push	2
	push	OFFSET ??_C@_05GNGPIAGI@bpart?$AA@
	push	3
	mov	DWORD PTR _one$92087[ebp], ebx
	call	_add_attribute
	add	esp, 32					; 00000020H
	mov	DWORD PTR _bpart$[ebp], eax
$LN29@metis_part@3:

; 356  :   }
; 357  :   
; 358  :   /* get contiguous indexes for bodies */
; 359  :   bdy_to_inx = (int*)temp_calloc(web.skel[BODY].max_ord+1,sizeof(int));

	mov	edx, DWORD PTR _web+404
	push	359					; 00000167H
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	inc	edx
	push	4
	push	edx
	call	_kb_temp_calloc

; 360  :   inx_to_bdy = (body_id*)temp_calloc(bcount,sizeof(body_id));

	push	360					; 00000168H
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	push	4
	push	edi
	mov	DWORD PTR _bdy_to_inx$[ebp], eax
	call	_kb_temp_calloc

; 361  :   inx = 0;
; 362  :   FOR_ALL_BODIES(b_id)

	mov	edx, DWORD PTR _web+384
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	add	esp, 32					; 00000020H
	xor	ebx, ebx
	and	ecx, 1
	mov	DWORD PTR _inx_to_bdy$[ebp], eax
	je	SHORT $LN26@metis_part@3
	npad	5
$LL68@metis_part@3:
	mov	eax, DWORD PTR _web+348
	mov	esi, edx
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN27@metis_part@3

; 363  :   { int ord = ordinal(b_id);

	test	ecx, ecx
	je	SHORT $LN34@metis_part@3
	mov	eax, esi
	jmp	SHORT $LN35@metis_part@3
$LN34@metis_part@3:
	or	eax, -1
$LN35@metis_part@3:

; 364  :     bdy_to_inx[ord] = inx;

	mov	ecx, DWORD PTR _bdy_to_inx$[ebp]
	mov	DWORD PTR [ecx+eax*4], ebx

; 365  :     inx_to_bdy[inx] = b_id;

	mov	eax, DWORD PTR _inx_to_bdy$[ebp]
	mov	DWORD PTR [eax+ebx*4], edx

; 366  :     inx++;

	inc	ebx
$LN27@metis_part@3:

; 361  :   inx = 0;
; 362  :   FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	SHORT $LL68@metis_part@3
	mov	edi, DWORD PTR _bcount$[ebp]
$LN26@metis_part@3:

; 367  :   }
; 368  :   if ( inx != bcount )

	cmp	ebx, edi
	je	SHORT $LN23@metis_part@3

; 369  :     kb_error(3772,"internal error - body count disagreement \n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CL@BCNANHFE@internal?5error?5?9?5body?5count?5disa@
	push	3772					; 00000ebcH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN23@metis_part@3:

; 370  :     
; 371  : 
; 372  :   /* gather adjacencies */
; 373  :   adjlist = (struct bb_adj *)temp_calloc(2*web.skel[FACET].count+1,
; 374  :                                     sizeof(struct bb_adj));

	mov	eax, DWORD PTR _web+288
	push	374					; 00000176H
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	lea	ecx, DWORD PTR [eax+eax+1]
	push	12					; 0000000cH
	push	ecx
	call	_kb_temp_calloc

; 375  :   adjcount = 0;
; 376  :   FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	mov	esi, edx
	xor	ebx, ebx
	shr	esi, 28					; 0000001cH
	add	esp, 16					; 00000010H
	and	esi, 1
	mov	edi, eax
	mov	DWORD PTR _adjlist$[ebp], edi
	mov	DWORD PTR _adjcount$[ebp], ebx
	je	$LN71@metis_part@3
$LL70@metis_part@3:
	mov	edi, DWORD PTR _web+236
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [ecx+edi]
	mov	DWORD PTR tv706[ebp], ecx
	mov	ecx, DWORD PTR [edi+8]
	and	ecx, 1
	xor	ebx, ebx
	or	ecx, ebx
	je	$LN21@metis_part@3

; 377  :   { body_id b_id = get_facet_body(f_id);

	mov	ebx, DWORD PTR _web+400
	test	ebx, ebx
	jne	SHORT $LN43@metis_part@3
	xor	edi, edi
	jmp	SHORT $LN40@metis_part@3
$LN43@metis_part@3:
	test	esi, esi
	jne	SHORT $LN42@metis_part@3
	xor	edi, edi
	jmp	SHORT $LN40@metis_part@3
$LN42@metis_part@3:
	mov	ecx, DWORD PTR _web+328
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+esi+784]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN41@metis_part@3
	mov	edi, DWORD PTR [ecx+edi+4]
	jmp	SHORT $LN40@metis_part@3
$LN41@metis_part@3:
	mov	edi, DWORD PTR [edi+ecx]
$LN40@metis_part@3:

; 378  :     body_id bb_id = get_facet_body(inverse_id(f_id));

	xor	edx, 134217728				; 08000000H
	mov	ecx, edx
	test	ebx, ebx
	jne	SHORT $LN49@metis_part@3
	xor	edx, edx
	jmp	SHORT $LN46@metis_part@3
$LN49@metis_part@3:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN48@metis_part@3
	xor	edx, edx
	jmp	SHORT $LN46@metis_part@3
$LN48@metis_part@3:
	mov	edx, DWORD PTR _web+236
	mov	esi, DWORD PTR _dymem
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN47@metis_part@3
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+328
	mov	edx, DWORD PTR [edx+esi+784]
	mov	edx, DWORD PTR [ecx+edx+4]
	jmp	SHORT $LN46@metis_part@3
$LN47@metis_part@3:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+328
	mov	edx, DWORD PTR [edx+esi+784]
	mov	edx, DWORD PTR [ecx+edx]
$LN46@metis_part@3:

; 379  :     int ord1,ord2;
; 380  : 
; 381  :     if ( !valid_id(b_id) || !valid_id(bb_id) ) continue;

	test	edi, 268435456				; 10000000H
	je	SHORT $LN21@metis_part@3
	test	edx, 268435456				; 10000000H
	je	SHORT $LN21@metis_part@3

; 382  :     ord1 = ordinal(b_id);

	and	edi, 134217727				; 07ffffffH
	mov	ecx, edi

; 383  :     ord2 = ordinal(bb_id);

	and	edx, 134217727				; 07ffffffH

; 384  :     if ( ord1 == ord2 ) continue;

	cmp	ecx, edx
	je	SHORT $LN21@metis_part@3

; 385  :     /* metis wants adjacencies in both directions */
; 386  :     adjlist[adjcount].b1 = bdy_to_inx[ord1];

	mov	esi, DWORD PTR _bdy_to_inx$[ebp]
	mov	edi, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [eax], edi

; 387  :     adjlist[adjcount].b2 = bdy_to_inx[ord2];

	mov	edi, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [eax+4], edi

; 388  :     adjlist[adjcount].weight = 1;
; 389  :     adjcount++;

	mov	edi, DWORD PTR _adjcount$[ebp]
	mov	ebx, 1
	mov	DWORD PTR [eax+8], ebx

; 390  :     adjlist[adjcount].b1 = bdy_to_inx[ord2];

	mov	edx, DWORD PTR [esi+edx*4]
	add	edi, ebx
	mov	DWORD PTR [eax+12], edx

; 391  :     adjlist[adjcount].b2 = bdy_to_inx[ord1];

	mov	ecx, DWORD PTR [esi+ecx*4]

; 392  :     adjlist[adjcount].weight = 1;
; 393  :     adjcount++;

	add	edi, ebx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ebx
	mov	DWORD PTR _adjcount$[ebp], edi
	add	eax, 24					; 00000018H
$LN21@metis_part@3:

; 375  :   adjcount = 0;
; 376  :   FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR tv706[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR [edx]
	mov	esi, edx
	shr	esi, 28					; 0000001cH
	and	esi, 1
	jne	$LL70@metis_part@3
	mov	edi, DWORD PTR _adjlist$[ebp]
	mov	ebx, DWORD PTR _adjcount$[ebp]
$LN71@metis_part@3:

; 394  :   }
; 395  :   /* sort */
; 396  :   qsort((void*)adjlist,adjcount,sizeof(struct bb_adj),FCAST adjcomp);

	push	OFFSET _adjcomp
	push	12					; 0000000cH
	push	ebx
	push	edi
	call	_qsort
	add	esp, 16					; 00000010H

; 397  :     
; 398  :   /* uniquify and gather number of facets as weights */
; 399  :   for ( i = 1, m = 0 ; i < adjcount ; i++ )

	xor	esi, esi
	cmp	ebx, 1
	jle	SHORT $LN12@metis_part@3

; 394  :   }
; 395  :   /* sort */
; 396  :   qsort((void*)adjlist,adjcount,sizeof(struct bb_adj),FCAST adjcomp);

	mov	eax, edi
	lea	ecx, DWORD PTR [edi+12]
	lea	edx, DWORD PTR [ebx-1]
	npad	3
$LL14@metis_part@3:

; 400  :   { if ( (adjlist[i].b1 != adjlist[m].b1) || (adjlist[i].b2 != adjlist[m].b2) )

	mov	ebx, DWORD PTR [ecx]
	cmp	ebx, DWORD PTR [eax]
	jne	SHORT $LN10@metis_part@3
	mov	ebx, DWORD PTR [ecx+4]
	cmp	ebx, DWORD PTR [eax+4]
	jne	SHORT $LN10@metis_part@3

; 403  :     } 
; 404  :     else
; 405  :      adjlist[m].weight += adjlist[i].weight;

	mov	ebx, DWORD PTR [ecx+8]
	add	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN13@metis_part@3
$LN10@metis_part@3:

; 401  :     { m++;
; 402  :       adjlist[m] = adjlist[i];

	mov	ebx, DWORD PTR [ecx]
	inc	esi
	lea	eax, DWORD PTR [esi+esi*2]
	lea	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebx
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebx
$LN13@metis_part@3:

; 397  :     
; 398  :   /* uniquify and gather number of facets as weights */
; 399  :   for ( i = 1, m = 0 ; i < adjcount ; i++ )

	add	ecx, 12					; 0000000cH
	dec	edx
	jne	SHORT $LL14@metis_part@3
$LN12@metis_part@3:

; 406  :   }
; 407  :   adjcount = m;
; 408  :   adjlist = (struct bb_adj*)temp_realloc((char*)adjlist,
; 409  :                    adjcount*sizeof(struct bb_adj));

	push	409					; 00000199H
	lea	ecx, DWORD PTR [esi+esi*2]
	add	ecx, ecx
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	add	ecx, ecx
	push	ecx
	push	edi
	call	_kb_temp_realloc

; 410  : 
; 411  : 
; 412  :   /* construct graph data */
; 413  :   graph.xadj = (idxtype*)temp_calloc(bcount+1,sizeof(idxtype));

	mov	edi, DWORD PTR _bcount$[ebp]
	push	413					; 0000019dH
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	lea	edx, DWORD PTR [edi+1]
	mov	ebx, eax
	push	4
	push	edx
	mov	DWORD PTR _adjlist$[ebp], ebx
	call	_kb_temp_calloc

; 414  :   graph.vwgt = (idxtype*)temp_calloc(bcount,sizeof(idxtype));

	push	414					; 0000019eH
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	push	4
	push	edi
	mov	DWORD PTR _graph$[ebp+16], eax
	call	_kb_temp_calloc

; 415  :   graph.adjncy = (idxtype*)temp_calloc(adjcount,sizeof(idxtype));

	push	415					; 0000019fH
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	push	4
	push	esi
	mov	DWORD PTR _graph$[ebp+20], eax
	call	_kb_temp_calloc
	add	esp, 64					; 00000040H

; 416  :   graph.adjwgt = (idxtype*)temp_calloc(adjcount,sizeof(idxtype));

	push	416					; 000001a0H
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	push	4
	push	esi
	mov	DWORD PTR _graph$[ebp+28], eax
	call	_kb_temp_calloc
	mov	DWORD PTR _graph$[ebp+32], eax
	add	esp, 16					; 00000010H

; 417  :   for ( bod = 0, spot = 0 ; spot < adjcount ; spot++ )

	xor	eax, eax
	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN6@metis_part@3

; 406  :   }
; 407  :   adjcount = m;
; 408  :   adjlist = (struct bb_adj*)temp_realloc((char*)adjlist,
; 409  :                    adjcount*sizeof(struct bb_adj));

	lea	edx, DWORD PTR [ebx+8]
$LL72@metis_part@3:

; 418  :   { while ( adjlist[spot].b1 != bod )

	cmp	DWORD PTR [edx-8], eax
	je	SHORT $LN4@metis_part@3
	npad	4
$LL5@metis_part@3:

; 419  :     { bod++;
; 420  :       graph.xadj[bod] = spot;

	mov	edi, DWORD PTR _graph$[ebp+16]
	inc	eax
	mov	DWORD PTR [edi+eax*4], ecx
	cmp	DWORD PTR [edx-8], eax
	jne	SHORT $LL5@metis_part@3
$LN4@metis_part@3:

; 421  :     }
; 422  :     graph.adjncy[spot] = adjlist[spot].b2;

	mov	edi, DWORD PTR [edx-4]
	mov	ebx, DWORD PTR _graph$[ebp+28]
	mov	DWORD PTR [ebx+ecx*4], edi

; 423  :     graph.adjwgt[spot] = adjlist[spot].weight;

	mov	edi, DWORD PTR [edx]
	mov	ebx, DWORD PTR _graph$[ebp+32]
	mov	DWORD PTR [ebx+ecx*4], edi

; 424  :     graph.vwgt[bod] += adjlist[spot].weight;

	mov	ebx, DWORD PTR [edx]
	mov	edi, DWORD PTR _graph$[ebp+20]
	add	DWORD PTR [edi+eax*4], ebx
	inc	ecx
	add	edx, 12					; 0000000cH
	cmp	ecx, esi
	jl	SHORT $LL72@metis_part@3

; 417  :   for ( bod = 0, spot = 0 ; spot < adjcount ; spot++ )

	mov	ebx, DWORD PTR _adjlist$[ebp]
	mov	edi, DWORD PTR _bcount$[ebp]
$LN6@metis_part@3:

; 425  :   }
; 426  :   bod++;
; 427  :   graph.xadj[bod] = adjcount;

	mov	ecx, DWORD PTR _graph$[ebp+16]

; 428  :   temp_free((char*)adjlist);

	push	ebx
	mov	DWORD PTR [ecx+eax*4+4], esi
	call	_temp_free

; 429  : 
; 430  :   /* do partition */
; 431  :   options[0] = 0; /* take defaults */
; 432  :   numbering = 0;  /* C-style 0-based indexing */
; 433  :   graph.nvtxs = bcount;
; 434  :   weightflag = 3; /* both weights */
; 435  :   partition = (int*)temp_calloc(graph.nvtxs,sizeof(int));

	push	435					; 000001b3H
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	xor	eax, eax
	push	4
	push	edi
	mov	DWORD PTR _options$[ebp], eax
	mov	DWORD PTR _numbering$[ebp], eax
	mov	DWORD PTR _graph$[ebp+8], edi
	mov	DWORD PTR _weightflag$[ebp], 3
	call	_kb_temp_calloc
	mov	ebx, eax

; 436  :   METIS_PartGraphKway(&graph.nvtxs, graph.xadj, graph.adjncy, graph.vwgt, 
; 437  :          graph.adjwgt, 
; 438  :           &weightflag,&numbering, &nparts, options, &edgecut, partition);

	push	ebx
	lea	edx, DWORD PTR _edgecut$[ebp]
	push	edx
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nparts$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _graph$[ebp+32]
	lea	edx, DWORD PTR _numbering$[ebp]
	push	edx
	mov	edx, DWORD PTR _graph$[ebp+20]
	lea	eax, DWORD PTR _weightflag$[ebp]
	push	eax
	mov	eax, DWORD PTR _graph$[ebp+28]
	push	ecx
	mov	ecx, DWORD PTR _graph$[ebp+16]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR _graph$[ebp+8]
	push	edx
	mov	DWORD PTR _partition$[ebp], ebx
	call	_METIS_PartGraphKway
	add	esp, 64					; 00000040H

; 439  : 
; 440  :   /* label things */
; 441  :   for ( i = 0 ; i < bcount ; i++ )

	test	edi, edi
	jle	SHORT $LN73@metis_part@3
	mov	esi, DWORD PTR _bpart$[ebp]

; 442  :    ((int*)get_extra(inx_to_bdy[i],bpart))[0] = partition[i];

	mov	edx, ebx
	imul	esi, 240				; 000000f0H
	mov	ebx, DWORD PTR _inx_to_bdy$[ebp]
	sub	ebx, edx
	mov	DWORD PTR tv454[ebp], edi
$LL3@metis_part@3:
	mov	ecx, DWORD PTR [ebx+edx]
	mov	eax, ecx
	shr	eax, 29					; 0000001dH
	imul	eax, 112				; 00000070H
	mov	edi, DWORD PTR _web[eax+12]
	mov	eax, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR _dymem
	add	eax, esi
	mov	eax, DWORD PTR [eax+edi+64]
	mov	edi, DWORD PTR [edx]
	add	edx, 4
	dec	DWORD PTR tv454[ebp]
	mov	DWORD PTR [ecx+eax], edi
	jne	SHORT $LL3@metis_part@3

; 439  : 
; 440  :   /* label things */
; 441  :   for ( i = 0 ; i < bcount ; i++ )

	mov	ebx, DWORD PTR _partition$[ebp]
$LN73@metis_part@3:

; 443  : 
; 444  :   /* free storage */
; 445  :   temp_free((char*)graph.xadj);

	mov	ecx, DWORD PTR _graph$[ebp+16]
	push	ecx
	call	_temp_free

; 446  :   temp_free((char*)graph.vwgt);

	mov	edx, DWORD PTR _graph$[ebp+20]
	push	edx
	call	_temp_free

; 447  :   temp_free((char*)graph.adjncy);

	mov	eax, DWORD PTR _graph$[ebp+28]
	push	eax
	call	_temp_free

; 448  :   temp_free((char*)graph.adjwgt);

	mov	ecx, DWORD PTR _graph$[ebp+32]
	push	ecx
	call	_temp_free

; 449  :   temp_free((char*)partition);

	push	ebx
	call	_temp_free

; 450  :   temp_free((char*)bdy_to_inx);

	mov	edx, DWORD PTR _bdy_to_inx$[ebp]
	push	edx
	call	_temp_free

; 451  :   temp_free((char*)inx_to_bdy);

	mov	eax, DWORD PTR _inx_to_bdy$[ebp]
	push	eax
	call	_temp_free

; 452  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_metis_partition_body ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@OKDKLMGM@No?5tree?5available?5in?5METIS?94?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_metis_vertex_order
EXTRN	_puts:PROC
EXTRN	_METIS_NodeND:PROC
;	COMDAT ??_C@_0BO@OKDKLMGM@No?5tree?5available?5in?5METIS?94?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BO@OKDKLMGM@No?5tree?5available?5in?5METIS?94?6?$AA@ DB 'No tree a'
	DB	'vailable in METIS-4', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\metis.c
CONST	ENDS
;	COMDAT _metis_vertex_order
_TEXT	SEGMENT
_graph$ = -180						; size = 116
_numbering$ = -64					; size = 4
tv405 = -60						; size = 4
tv361 = -56						; size = 4
_j$ = -52						; size = 4
tv464 = -48						; size = 4
_options$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_mmdswitch$ = 8						; size = 4
_metis_vertex_order PROC				; COMDAT

; 463  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 464  :   int i;
; 465  :   GraphType graph;
; 466  :   int  options[10], numbering;
; 467  :   vertex_id v_id;
; 468  :   edge_id e_id,start_e;
; 469  :   int j;
; 470  :   int *perm,*iperm;
; 471  : 
; 472  :   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN10@metis_vert

; 473  :      kb_error(1634,"Cannot do Metis on simplex model.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CD@EFFOKEN@Cannot?5do?5Metis?5on?5simplex?5model@
	push	1634					; 00000662H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN10@metis_vert:

; 474  : 
; 475  :   if ( web.skel[VERTEX].count != web.skel[VERTEX].max_ord+1 )

	mov	eax, DWORD PTR _web+68
	inc	eax
	cmp	DWORD PTR _web+64, eax
	je	SHORT $LN9@metis_vert

; 476  :      kb_error(1635,"Need packed vertex numbering to do Metis.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CL@GJAGFHFE@Need?5packed?5vertex?5numbering?5to?5@
	push	1635					; 00000663H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN9@metis_vert:

; 477  :   memset((char*)&graph,0,sizeof(graph));

	push	ebx
	push	esi
	push	edi
	push	116					; 00000074H
	xor	ebx, ebx
	lea	ecx, DWORD PTR _graph$[ebp]
	push	ebx
	push	ecx
	call	_memset

; 478  : 
; 479  :   /* construct graph data */
; 480  :   graph.xadj = (int*)temp_calloc(web.skel[VERTEX].count+1,sizeof(int));

	mov	edx, DWORD PTR _web+64
	push	480					; 000001e0H
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	inc	edx
	push	4
	push	edx
	call	_kb_temp_calloc

; 481  :   graph.adjncy = (int*)temp_calloc(2*web.skel[EDGE].count,sizeof(int));

	push	481					; 000001e1H
	mov	DWORD PTR _graph$[ebp+16], eax
	mov	eax, DWORD PTR _web+176
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	lea	ecx, DWORD PTR [eax+eax]
	push	4
	push	ecx
	call	_kb_temp_calloc
	mov	DWORD PTR _graph$[ebp+28], eax

; 482  :   j = 0; i = 0;
; 483  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	add	esp, 44					; 0000002cH
	mov	DWORD PTR _j$[ebp], ebx
	test	eax, 268435456				; 10000000H
	je	$LN6@metis_vert

; 477  :   memset((char*)&graph,0,sizeof(graph));

	mov	esi, DWORD PTR _web+12
	mov	DWORD PTR tv464[ebp], ebx
$LL8@metis_vert:

; 482  :   j = 0; i = 0;
; 483  :   FOR_ALL_VERTICES(v_id)

	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	edi, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [edi+esi]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv361[ebp], edi
	je	$LN7@metis_vert

; 484  :   { e_id = start_e = get_vertex_edge(v_id);

	mov	eax, DWORD PTR [ecx+28]
	mov	ecx, eax
	or	ecx, 134217728				; 08000000H
	mov	DWORD PTR tv405[ebp], ecx
	mov	ecx, DWORD PTR _web+124
	npad	8
$LL3@metis_vert:

; 485  :      do 
; 486  :      { graph.adjncy[j++] = loc_ordinal(get_edge_headv(e_id)); 

	mov	esi, DWORD PTR _web+216
	mov	ebx, DWORD PTR _dymem
	mov	edi, DWORD PTR _web+636
	mov	esi, DWORD PTR [esi+ebx+304]
	mov	edx, eax
	shr	edx, 27					; 0000001bH
	and	edx, 1
	je	SHORT $LN16@metis_vert
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	add	ecx, esi
	mov	esi, DWORD PTR [ecx]
	jmp	SHORT $LN15@metis_vert
$LN16@metis_vert:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	add	ecx, esi
	mov	esi, DWORD PTR [ecx+edi*4]
$LN15@metis_vert:
	test	esi, 268435456				; 10000000H
	je	SHORT $LN13@metis_vert
	test	edx, edx
	je	SHORT $LN20@metis_vert
	mov	ecx, DWORD PTR [ecx]
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN14@metis_vert
$LN20@metis_vert:
	mov	ecx, DWORD PTR [ecx+edi*4]
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN14@metis_vert
$LN13@metis_vert:
	or	ecx, -1
$LN14@metis_vert:
	mov	esi, DWORD PTR _j$[ebp]
	mov	edi, DWORD PTR _graph$[ebp+28]
	mov	DWORD PTR [edi+esi*4], ecx

; 487  :         e_id = get_next_tail_edge(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [eax+edx*4+32]

; 488  :      } while ( !equal_element(e_id,start_e) );

	mov	edx, eax
	inc	esi
	or	edx, 134217728				; 08000000H
	mov	DWORD PTR _j$[ebp], esi
	cmp	edx, DWORD PTR tv405[ebp]
	jne	$LL3@metis_vert

; 489  :      graph.xadj[++i] = j;

	mov	eax, DWORD PTR tv464[ebp]
	mov	ecx, DWORD PTR _graph$[ebp+16]
	mov	edi, DWORD PTR tv361[ebp]
	add	eax, 4
	mov	DWORD PTR [eax+ecx], esi
	mov	esi, DWORD PTR _web+12
	mov	DWORD PTR tv464[ebp], eax
	xor	ebx, ebx
$LN7@metis_vert:

; 482  :   j = 0; i = 0;
; 483  :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR [edi+esi]
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	$LL8@metis_vert
$LN6@metis_vert:

; 490  :   }
; 491  : 
; 492  :   /* do partition */
; 493  :   numbering = 0;
; 494  :   graph.nvtxs = web.skel[VERTEX].count;

	mov	eax, DWORD PTR _web+64

; 495  :   perm = (int*)temp_calloc(graph.nvtxs,sizeof(int));

	push	495					; 000001efH
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	push	4
	push	eax
	mov	DWORD PTR _numbering$[ebp], ebx
	mov	DWORD PTR _graph$[ebp+8], eax
	call	_kb_temp_calloc

; 496  :   iperm = (int*)temp_calloc(graph.nvtxs,sizeof(int));

	push	496					; 000001f0H
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	mov	esi, eax
	mov	eax, DWORD PTR _graph$[ebp+8]
	push	4
	push	eax
	call	_kb_temp_calloc
	mov	edi, eax

; 497  : 
; 498  : #ifndef METIS2
; 499  :   options[0] = 1; /* enable options, METIS 4.0 version */
; 500  :   options[1] = 3;  /* Sorted Heavy-Edge Matching */
; 501  :   options[2] = 1;  /* Edge-based region growing */
; 502  :   options[3] = 2;    /* One-sided node FM refinement */
; 503  :   options[4] = 0;    /* debugging only */
; 504  :   options[5] = 0;   /* no compression */
; 505  :   options[6] = 0;   /* don't order dense columns last */
; 506  :   options[7] = 1;   /* number of separators to find each step */
; 507  :   METIS_NodeND(&graph.nvtxs, graph.xadj, graph.adjncy,&numbering,options,perm,iperm);

	mov	eax, DWORD PTR _graph$[ebp+28]
	push	edi
	push	esi
	lea	ecx, DWORD PTR _options$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _graph$[ebp+16]
	lea	edx, DWORD PTR _numbering$[ebp]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR _graph$[ebp+8]
	push	edx
	mov	DWORD PTR _options$[ebp], 1
	mov	DWORD PTR _options$[ebp+4], 3
	mov	DWORD PTR _options$[ebp+8], 1
	mov	DWORD PTR _options$[ebp+12], 2
	mov	DWORD PTR _options$[ebp+16], ebx
	mov	DWORD PTR _options$[ebp+20], ebx
	mov	DWORD PTR _options$[ebp+24], ebx
	mov	DWORD PTR _options$[ebp+28], 1
	call	_METIS_NodeND

; 508  :   puts("No tree available in METIS-4\n");

	push	OFFSET ??_C@_0BO@OKDKLMGM@No?5tree?5available?5in?5METIS?94?6?$AA@
	call	_puts

; 509  : #else
; 510  :   /* metis 2 with my modifications */
; 511  :   options[0] = 1; /* enable options, METIS 2.0 version */
; 512  :   options[1] = 100;  /* coarsen to */
; 513  :   options[2] = 21;  /* MType SHEM */
; 514  :   options[3] = 2;    /* IPType GGGP */
; 515  :   options[4] = 13;    /* RType BGKLR */
; 516  :   OMETIS(&graph.nvtxs, graph.xadj, graph.adjncy,&options,&numbering,
; 517  :      perm,iperm,&mmdswitch);
; 518  :   /* print separation tree (just a temporary thing */
; 519  :   puts("node  subtree size         separator");
; 520  :   for ( i = 0 ; i < graph.nvtxs ; i++ )
; 521  :      if ( stree[i].nvtxs > 0 )
; 522  :         printf("%4d.      %d        %d-%d \n",i,stree[i].nvtxs,stree[i].lo,
; 523  :             stree[i].hi);
; 524  :   myfree((char*)stree);
; 525  : #endif
; 526  :   /* free storage */
; 527  :   temp_free((char*)graph.xadj);

	mov	eax, DWORD PTR _graph$[ebp+16]
	add	esp, 64					; 00000040H
	push	eax
	call	_temp_free

; 528  :   temp_free((char*)graph.adjncy);

	mov	ecx, DWORD PTR _graph$[ebp+28]
	push	ecx
	call	_temp_free

; 529  :   temp_free((char*)perm);

	push	esi
	call	_temp_free

; 530  :   temp_free((char*)iperm);

	push	edi
	call	_temp_free

; 531  : 
; 532  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_metis_vertex_order ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_metis_order
; Function compile flags: /Ogtp
;	COMDAT _metis_order
_TEXT	SEGMENT
_graph$ = -168						; size = 116
_end$92246 = -52					; size = 4
_numbering$ = -48					; size = 4
_options$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_metis_order PROC					; COMDAT

; 544  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	push	edi

; 545  :   int i,k;
; 546  :   GraphType graph;
; 547  :   int  options[10], numbering;
; 548  :   int j;
; 549  :   int tot;
; 550  : 
; 551  :   memset((char*)&graph,0,sizeof(graph));

	push	116					; 00000074H
	lea	eax, DWORD PTR _graph$[ebp]
	push	0
	push	eax
	call	_memset

; 552  : 
; 553  :   /* construct graph data */
; 554  :   /* metis requires full graph matrix, not just symmetric part */
; 555  :   graph.xadj = (int*)temp_calloc(S->N+1,sizeof(int));

	mov	ecx, DWORD PTR [esi+4]
	push	555					; 0000022bH
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	inc	ecx
	push	4
	push	ecx
	call	_kb_temp_calloc

; 556  :   graph.adjncy = (int*)temp_calloc(2*S->IA[S->N],sizeof(int));

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _graph$[ebp+16], eax
	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	556					; 0000022cH
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	add	ecx, ecx
	push	4
	push	ecx
	call	_kb_temp_calloc

; 557  :   /* first have to count neighbors into graph.xadj */
; 558  :   for ( i = 0 ; i < S->N ; i++ ) 

	xor	edi, edi
	add	esp, 44					; 0000002cH
	mov	DWORD PTR _graph$[ebp+28], eax
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN22@metis_orde
$LL24@metis_orde:
	mov	edx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR _graph$[ebp+16]
	lea	eax, DWORD PTR [edx+edi*4]

; 559  :   { int end;
; 560  :      graph.xadj[i] += S->IA[i+1] - S->IA[i] - 1;  /* not self */

	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [eax]
	dec	edx
	add	DWORD PTR [ecx+edi*4], edx
	mov	eax, DWORD PTR [esi+52]

; 561  :      end = S->IA[i+1] - A_OFF;

	mov	ecx, DWORD PTR [eax+edi*4+4]
	lea	eax, DWORD PTR [eax+edi*4]

; 562  :      for ( j = S->IA[i]+1 - A_OFF ; j < end ; j++ )

	mov	eax, DWORD PTR [eax]
	dec	ecx
	cmp	eax, ecx
	jge	SHORT $LN23@metis_orde
	npad	8
$LL21@metis_orde:

; 563  :          graph.xadj[S->JA[j] - A_OFF]++;

	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	ebx, DWORD PTR _graph$[ebp+16]
	inc	DWORD PTR [ebx+edx*4-4]
	lea	edx, DWORD PTR [ebx+edx*4-4]
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL21@metis_orde
$LN23@metis_orde:

; 557  :   /* first have to count neighbors into graph.xadj */
; 558  :   for ( i = 0 ; i < S->N ; i++ ) 

	inc	edi
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL24@metis_orde
$LN22@metis_orde:

; 564  :   }
; 565  :   /* reset xadj to starts of intervals */
; 566  :   for ( tot = 0, i = 0 ; i < S->N ; i++ )

	xor	eax, eax
	xor	ecx, ecx
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN16@metis_orde
	npad	8
$LL18@metis_orde:
	mov	edx, DWORD PTR _graph$[ebp+16]

; 567  :   { int num = graph.xadj[i];

	mov	edi, DWORD PTR [edx+eax*4]

; 568  :      graph.xadj[i] = tot;

	mov	DWORD PTR [edx+eax*4], ecx
	inc	eax

; 569  :      tot += num;

	add	ecx, edi
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL18@metis_orde
$LN16@metis_orde:

; 570  :   }
; 571  :   graph.xadj[S->N] = tot;

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _graph$[ebp+16]
	mov	DWORD PTR [edx+eax*4], ecx

; 572  :   /* insert adjacencies */
; 573  :   for ( i = 0 ; i < S->N ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN13@metis_orde
	npad	9
$LL15@metis_orde:
	mov	eax, DWORD PTR [esi+52]

; 574  :   { int end = S->IA[i+1] - A_OFF;

	mov	edx, DWORD PTR [eax+ecx*4+4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 575  :      for ( j = S->IA[i]+1 - A_OFF ; j < end ; j++ )

	mov	eax, DWORD PTR [eax]
	dec	edx
	mov	DWORD PTR _end$92246[ebp], edx
	cmp	eax, edx
	jge	SHORT $LN14@metis_orde
$LL12@metis_orde:

; 576  :      { graph.adjncy[graph.xadj[i]++] = S->JA[j] - A_OFF;

	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR _graph$[ebp+16]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	ebx, DWORD PTR _graph$[ebp+28]
	dec	edx
	mov	DWORD PTR [ebx+edi*4], edx
	mov	edx, DWORD PTR _graph$[ebp+16]
	inc	DWORD PTR [edx+ecx*4]

; 577  :        graph.adjncy[graph.xadj[S->JA[j] - A_OFF]++] = i;

	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR _graph$[ebp+16]
	mov	edx, DWORD PTR [edi+edx*4-4]
	mov	edi, DWORD PTR _graph$[ebp+28]
	mov	DWORD PTR [edi+edx*4], ecx
	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR _graph$[ebp+16]
	inc	DWORD PTR [edi+edx*4-4]
	lea	edx, DWORD PTR [edi+edx*4-4]
	inc	eax
	cmp	eax, DWORD PTR _end$92246[ebp]
	jl	SHORT $LL12@metis_orde
$LN14@metis_orde:

; 572  :   /* insert adjacencies */
; 573  :   for ( i = 0 ; i < S->N ; i++ )

	inc	ecx
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LL15@metis_orde
$LN13@metis_orde:

; 578  :      }
; 579  :   }
; 580  :   /* reset xadj */
; 581  :   for ( i = S->N  ; i > 0 ; i-- )

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	jle	SHORT $LN7@metis_orde
	npad	10
$LL9@metis_orde:
	mov	ecx, DWORD PTR _graph$[ebp+16]

; 582  :       graph.xadj[i] = graph.xadj[i-1];

	mov	edx, DWORD PTR [ecx+eax*4-4]
	mov	DWORD PTR [ecx+eax*4], edx
	dec	eax
	test	eax, eax
	jg	SHORT $LL9@metis_orde
$LN7@metis_orde:

; 583  :   graph.xadj[0] = 0;

	mov	eax, DWORD PTR _graph$[ebp+16]
	mov	DWORD PTR [eax], 0

; 584  : 
; 585  :   /* do partition */
; 586  :   options[0] = 0; /* default options */
; 587  :   memset(options,0,sizeof(options));

	xor	eax, eax

; 588  :   numbering = 0;
; 589  :   graph.nvtxs = S->N;
; 590  :   if ( !S->P )

	cmp	DWORD PTR [esi+68], 0
	mov	DWORD PTR _options$[ebp], eax
	mov	DWORD PTR _options$[ebp+4], eax
	mov	DWORD PTR _options$[ebp+8], eax
	mov	DWORD PTR _options$[ebp+12], eax
	mov	DWORD PTR _options$[ebp+16], eax
	mov	DWORD PTR _options$[ebp+20], eax
	mov	DWORD PTR _options$[ebp+24], eax
	mov	DWORD PTR _options$[ebp+28], eax
	mov	DWORD PTR _options$[ebp+32], eax
	mov	DWORD PTR _options$[ebp+36], eax
	mov	DWORD PTR _numbering$[ebp], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _graph$[ebp+8], eax
	jne	SHORT $LN41@metis_orde

; 591  :      S->P = (int*)temp_calloc(graph.nvtxs,sizeof(int));

	push	591					; 0000024fH
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	push	4
	push	eax
	call	_kb_temp_calloc
	mov	DWORD PTR [esi+68], eax
	mov	eax, DWORD PTR _graph$[ebp+8]
	add	esp, 16					; 00000010H
$LN41@metis_orde:

; 592  :   if ( !S->IP )

	cmp	DWORD PTR [esi+72], 0
	jne	SHORT $LN5@metis_orde

; 593  :      S->IP = (int*)temp_calloc(graph.nvtxs,sizeof(int));

	push	593					; 00000251H
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	push	4
	push	eax
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+72], eax
$LN5@metis_orde:

; 594  : 
; 595  :   METIS_NodeND(&graph.nvtxs, graph.xadj, graph.adjncy,&numbering,options,
; 596  :         S->P,S->IP);

	mov	ecx, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [esi+68]
	push	ecx
	push	edx
	mov	edx, DWORD PTR _graph$[ebp+28]
	lea	eax, DWORD PTR _options$[ebp]
	push	eax
	mov	eax, DWORD PTR _graph$[ebp+16]
	lea	ecx, DWORD PTR _numbering$[ebp]
	push	ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR _graph$[ebp+8]
	push	ecx
	call	_METIS_NodeND
	add	esp, 28					; 0000001cH

; 597  : 
; 598  :   /* adjust zero based indexing */
; 599  :   /* ysmp wants 1 based */
; 600  :   if ( numbering == 0 )

	cmp	DWORD PTR _numbering$[ebp], 0
	jne	SHORT $LN1@metis_orde

; 601  :     for ( k = 0 ; k < S->N ; k++ ) { S->P[k]++; S->IP[k]++; }

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN1@metis_orde
$LL3@metis_orde:
	mov	edx, DWORD PTR [esi+68]
	inc	DWORD PTR [edx+eax*4]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [esi+72]
	inc	DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	inc	eax
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL3@metis_orde
$LN1@metis_orde:

; 602  : 
; 603  :   S->flags |= S_ORDERFOUND;
; 604  : 
; 605  : #ifdef METIS2
; 606  :   /* find length of stree list and clean up stree fields */
; 607  :   S->maxsepsize = 0;
; 608  :   for ( k = 0, S->streemax = 1, s = S->stree ; k <= S->streemax ; k++,s++ )
; 609  :   { if ( s->nvtxs < 0 )
; 610  :      { s->lo = s->hi = s->isleaf = 0;}
; 611  :      s->u.info.size = 0;
; 612  :      s->u.info.vlist = NULL;
; 613  :      s->u.info.mat = NULL;
; 614  :      if ( S->maxsepsize < (s->hi-s->lo) )
; 615  :          S->maxsepsize = (s->hi-s->lo);
; 616  :      if ( (s->nvtxs > 0) && !(s->isleaf & 1) ) 
; 617  :         S->streemax = 2*k+1;
; 618  :   }
; 619  : #endif
; 620  : 
; 621  : #ifdef PRINTSEPTREE 
; 622  :   /* print separation tree (just a temporary thing */
; 623  :   for ( i = 0 ; i <= S->streemax ; i++ )
; 624  :      if ( S-> [i].nvtxs > 0 )
; 625  :         printf("%4d.  %d    %d-%d \n",i,S->stree[i].nvtxs,S->stree[i].lo,
; 626  :             S->stree[i].hi);
; 627  : #endif
; 628  : 
; 629  :   /* free storage */
; 630  :   temp_free((char*)graph.xadj);

	mov	edx, DWORD PTR _graph$[ebp+16]
	or	DWORD PTR [esi], 64			; 00000040H
	push	edx
	call	_temp_free

; 631  :   temp_free((char*)graph.adjncy);

	mov	eax, DWORD PTR _graph$[ebp+28]
	push	eax
	call	_temp_free

; 632  : 
; 633  : /*
; 634  :   if ( !hessian_quiet_flag )
; 635  :     tree_analyze(S);
; 636  : */
; 637  : 
; 638  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_metis_order ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	_do_tree_factor
EXTRN	_hessian_epsilon:QWORD
EXTRN	_Met:BYTE
EXTRN	_hessian_linear_metric_flag:DWORD
EXTRN	_kb_calloc:PROC
EXTRN	_nprocs:DWORD
EXTRN	_win_get_thread_data:PROC
EXTRN	_thread_data_key:DWORD
EXTRN	__fltused:DWORD
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _do_tree_factor
_TEXT	SEGMENT
_h$92298 = -52						; size = 12
tv1432 = -40						; size = 4
tv1421 = -40						; size = 4
tv1308 = -40						; size = 4
_mat$ = -40						; size = 4
tv192 = -40						; size = 4
_rsep$92320 = -40					; size = 4
_spot$ = -36						; size = 4
tv2996 = -32						; size = 4
_sonsrc$92411 = -32					; size = 4
_end$92399 = -32					; size = 4
_varlist$92295 = -32					; size = 4
tv3032 = -28						; size = 4
tv837 = -28						; size = 4
_i$ = -28						; size = 4
_k$ = -28						; size = 4
tv3030 = -24						; size = 4
_sepsize$ = -24						; size = 4
tv3083 = -20						; size = 4
_right$92293 = -20					; size = 4
tv3081 = -16						; size = 4
_left$92292 = -16					; size = 4
_base$92302 = -12					; size = 4
_heapsize$ = -12					; size = 4
tv2058 = -8						; size = 4
_varcount$92297 = -8					; size = 4
_vtop$92296 = -8					; size = 4
_stree$92291 = -4					; size = 4
_S$ = 8							; size = 4
_do_tree_factor PROC					; COMDAT

; 655  : { int me = GET_THREAD_ID;

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR _thread_data_key
	push	ebx
	push	esi
	push	edi
	push	eax
	call	_win_get_thread_data

; 656  :   int spot; /* stree index */
; 657  :   int blocks;
; 658  :   int i,j;
; 659  :   size_t k;
; 660  :   REAL *mat;
; 661  :   int *work;  /* some workspace */
; 662  :   size_t sepsize; /* size of separator */
; 663  :   size_t heapsize; /* number of lists to merge */
; 664  :   struct hp { int row;  /* which row entry from */
; 665  :               int index; /* index into pJA */
; 666  :               int col;  /* column, from pJA or sentinel */
; 667  :             } *heap;
; 668  : 
; 669  :   work = (int*)temp_calloc(S->N*sizeof(int)+(S->maxsepsize+5)*sizeof(struct hp),1);

	mov	edi, DWORD PTR _S$[ebp]
	mov	ebx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+84]
	lea	ecx, DWORD PTR [eax+eax*2+15]
	add	ecx, DWORD PTR [edi+4]
	push	669					; 0000029dH
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	add	ecx, ecx
	add	ecx, ecx
	push	1
	push	ecx
	call	_kb_temp_calloc

; 670  : 
; 671  :   blocks = S->streemax/nprocs;

	mov	ecx, DWORD PTR [edi+80]
	mov	esi, eax
	mov	eax, ecx
	cdq
	idiv	DWORD PTR _nprocs

; 672  :   spot = blocks*nprocs + me;

	mov	edx, DWORD PTR _nprocs
	add	esp, 20					; 00000014H
	imul	eax, edx
	add	eax, ebx
	mov	DWORD PTR _spot$[ebp], eax

; 673  :   if ( spot > S->streemax ) spot -= nprocs;

	cmp	eax, ecx
	jle	SHORT $LN85@do_tree_fa
	sub	eax, edx
	mov	DWORD PTR _spot$[ebp], eax
$LN85@do_tree_fa:

; 674  : 
; 675  :   for ( ; spot >= 1 ; spot -= nprocs )  /* metis starts at stree[1] */

	cmp	eax, 1
	jl	$LN82@do_tree_fa
	npad	6
$LL84@do_tree_fa:

; 676  :   { /* factor one node */
; 677  :      SepNodeType *stree = S->stree + spot;  /* current node */

	mov	ebx, DWORD PTR [edi+76]
	mov	ecx, eax
	shl	ecx, 5
	add	ebx, ecx

; 678  :      SepNodeType *left = stree + spot,*right = left+1;  /* sons */

	add	ecx, ebx

; 679  :      SepNodeType *son;
; 680  :      int *varlist; /* temporary variable list */
; 681  :      int *vtop;      /* pointer into varlist */
; 682  :      size_t varcount;
; 683  :      struct hp h;
; 684  :      int hspot,next;
; 685  :      int kk;
; 686  :      REAL *base; /* pivot row */
; 687  :      int row;
; 688  : 
; 689  :      if ( stree->nvtxs <= 0 ) { stree->isleaf |= 2; continue; }

	cmp	DWORD PTR [ebx], 0
	lea	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _stree$92291[ebp], ebx
	mov	DWORD PTR _left$92292[ebp], ecx
	mov	DWORD PTR _right$92293[ebp], edx
	jg	SHORT $LN81@do_tree_fa
	or	DWORD PTR [ebx+12], 2
	jmp	$LN83@do_tree_fa
$LN81@do_tree_fa:

; 690  :      if ( !stree->isleaf )

	cmp	DWORD PTR [ebx+12], 0
	jne	SHORT $LN78@do_tree_fa
	mov	ecx, DWORD PTR [ecx+12]
	npad	1
$LL79@do_tree_fa:

; 691  :         /* busy wait for sons */
; 692  :         while ( !left->isleaf || !right->isleaf ) ;

	test	ecx, ecx
	je	SHORT $LL79@do_tree_fa
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LL79@do_tree_fa
$LN78@do_tree_fa:

; 693  : 
; 694  :      sepsize = stree->hi - stree->lo;

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, DWORD PTR [ebx+4]

; 695  :      heapsize = stree->isleaf ? sepsize : sepsize+2;

	mov	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR _sepsize$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN88@do_tree_fa
	mov	ecx, eax
	mov	DWORD PTR _heapsize$[ebp], eax
	jmp	SHORT $LN89@do_tree_fa
$LN88@do_tree_fa:
	lea	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR _heapsize$[ebp], ecx
$LN89@do_tree_fa:

; 696  : 
; 697  :      /* heap merge columns and sons */
; 698  :      heap = (struct hp*) work;
; 699  :      varlist = (int*)((char*)work+heapsize*sizeof(struct hp)); 

	lea	edx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR _varlist$92295[ebp], ecx

; 700  :      /* populate heap */
; 701  :      for ( k = 0 ; k < sepsize ; k++ )

	xor	ecx, ecx
	test	eax, eax
	je	SHORT $LN146@do_tree_fa

; 696  : 
; 697  :      /* heap merge columns and sons */
; 698  :      heap = (struct hp*) work;
; 699  :      varlist = (int*)((char*)work+heapsize*sizeof(struct hp)); 

	lea	eax, DWORD PTR [esi+8]
	npad	7
$LL145@do_tree_fa:

; 702  :      { 
; 703  :        heap[k].row = (int)(stree->lo + k);

	mov	edx, DWORD PTR [ebx+4]
	add	edx, ecx
	mov	DWORD PTR [eax-8], edx

; 704  :        heap[k].index = S->pIA[heap[k].row];

	mov	ebx, DWORD PTR [edi+96]
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR [eax-4], edx

; 705  :        heap[k].col = S->pJA[heap[k].index];

	mov	ebx, DWORD PTR [edi+100]
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _stree$92291[ebp]
	mov	DWORD PTR [eax], edx
	inc	ecx
	add	eax, 12					; 0000000cH
	cmp	ecx, DWORD PTR _sepsize$[ebp]
	jb	SHORT $LL145@do_tree_fa
$LN146@do_tree_fa:

; 706  :      }
; 707  :      if ( !stree->isleaf)

	cmp	DWORD PTR [ebx+12], 0
	jne	$LN69@do_tree_fa

; 708  :      { size_t lsep = left->hi-left->lo;

	mov	eax, DWORD PTR _left$92292[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]

; 709  :        size_t rsep = right->hi - right->lo;

	mov	eax, DWORD PTR _right$92293[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]

; 710  :        if ( left->u.info.size > lsep )

	mov	eax, DWORD PTR _left$92292[ebp]
	cmp	DWORD PTR [eax+16], ecx

; 711  :        { heap[sepsize].row = -1;  /* left son */

	mov	eax, DWORD PTR _sepsize$[ebp]
	mov	DWORD PTR _rsep$92320[ebp], edx
	jbe	SHORT $LN72@do_tree_fa
	lea	edx, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [esi+edx*4]

; 712  :          heap[sepsize].index = (int)lsep;
; 713  :          heap[sepsize].col = left->u.info.vlist[lsep];

	mov	edx, DWORD PTR _left$92292[ebp]
	mov	DWORD PTR [eax], -1
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [edx+ecx*4]

; 714  :        }
; 715  :        else

	mov	edx, DWORD PTR _rsep$92320[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN71@do_tree_fa
$LN72@do_tree_fa:

; 716  :        { heap[sepsize].row = -3;

	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [eax], -3			; fffffffdH

; 717  :          heap[sepsize].index = 0;

	mov	DWORD PTR [eax+4], 0

; 718  :          heap[sepsize].col = MAXINT;

	mov	DWORD PTR [eax+8], 2147483647		; 7fffffffH
$LN71@do_tree_fa:

; 719  :        }
; 720  :        if ( right->u.info.size > rsep )

	mov	ecx, DWORD PTR _right$92293[ebp]
	cmp	DWORD PTR [ecx+16], edx
	jbe	SHORT $LN70@do_tree_fa

; 721  :        { heap[sepsize+1].row = -2;  /* right son */

	mov	DWORD PTR [eax+12], -2			; fffffffeH

; 722  :          heap[sepsize+1].index = (int)rsep;

	mov	DWORD PTR [eax+16], edx

; 723  :          heap[sepsize+1].col = right->u.info.vlist[rsep];

	mov	ecx, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [eax+20], edx

; 724  :        }
; 725  :        else

	jmp	SHORT $LN69@do_tree_fa
$LN70@do_tree_fa:

; 726  :        { heap[sepsize+1].row = -3;

	mov	DWORD PTR [eax+12], -3			; fffffffdH

; 727  :           heap[sepsize+1].index = 0;

	mov	DWORD PTR [eax+16], 0

; 728  :           heap[sepsize+1].col = MAXINT;

	mov	DWORD PTR [eax+20], 2147483647		; 7fffffffH
$LN69@do_tree_fa:

; 729  :        }
; 730  :      }
; 731  :      /* initial ordering */
; 732  :      for ( k = 0 ; k < heapsize ; k++ )

	xor	edx, edx
	mov	DWORD PTR _k$[ebp], edx
	cmp	DWORD PTR _heapsize$[ebp], edx
	jbe	$LN66@do_tree_fa
	mov	DWORD PTR tv2058[ebp], esi
	npad	4
$LL68@do_tree_fa:

; 733  :      { int parent = (int)((k-1)>>1);
; 734  :        hspot = (int)k;
; 735  :        h = heap[hspot];          

	mov	ebx, DWORD PTR tv2058[ebp]
	mov	ebx, DWORD PTR [ebx]
	mov	DWORD PTR _h$92298[ebp], ebx
	mov	ebx, DWORD PTR tv2058[ebp]
	mov	ebx, DWORD PTR [ebx+4]
	mov	DWORD PTR _h$92298[ebp+4], ebx
	mov	ebx, DWORD PTR tv2058[ebp]
	mov	ebx, DWORD PTR [ebx+8]
	lea	eax, DWORD PTR [edx-1]
	shr	eax, 1
	mov	ecx, edx
	mov	DWORD PTR _h$92298[ebp+8], ebx

; 736  :        while ( hspot > 0 )

	test	edx, edx
	jle	SHORT $LN143@do_tree_fa
$LL65@do_tree_fa:

; 737  :        { if ( h.col < heap[parent].col )

	mov	ebx, DWORD PTR _h$92298[ebp+8]
	lea	edx, DWORD PTR [eax+eax*2]
	cmp	ebx, DWORD PTR [esi+edx*4+8]
	lea	edx, DWORD PTR [esi+edx*4]
	jge	SHORT $LN134@do_tree_fa

; 738  :              { heap[hspot] = heap[parent]; 

	mov	ebx, DWORD PTR [edx]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [ecx], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 739  :                hspot = parent;

	mov	ecx, eax

; 740  :                parent = (parent-1)>>1;

	dec	eax
	sar	eax, 1
	test	ecx, ecx
	jg	SHORT $LL65@do_tree_fa
$LN134@do_tree_fa:

; 736  :        while ( hspot > 0 )

	mov	edx, DWORD PTR _k$[ebp]
$LN143@do_tree_fa:

; 729  :        }
; 730  :      }
; 731  :      /* initial ordering */
; 732  :      for ( k = 0 ; k < heapsize ; k++ )

	add	DWORD PTR tv2058[ebp], 12		; 0000000cH

; 736  :        while ( hspot > 0 )

	mov	ebx, DWORD PTR _stree$92291[ebp]

; 741  :              }
; 742  :           else break;
; 743  :        }
; 744  :        heap[hspot] = h;

	lea	eax, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR _h$92298[ebp]
	lea	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _h$92298[ebp+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR _h$92298[ebp+8]
	inc	edx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR _k$[ebp], edx
	cmp	edx, DWORD PTR _heapsize$[ebp]
	jb	SHORT $LL68@do_tree_fa
$LN66@do_tree_fa:

; 745  :      }
; 746  :      /* heap sort */
; 747  :      vtop = varlist;

	mov	ecx, DWORD PTR _varlist$92295[ebp]

; 748  :      *vtop = heap[0].col;

	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx], edx

; 749  :      while ( heap[0].row >= -2 )

	cmp	DWORD PTR [esi], -2			; fffffffeH
	mov	DWORD PTR _vtop$92296[ebp], ecx
	jl	$LN60@do_tree_fa
$LL61@do_tree_fa:

; 750  :      {
; 751  :        if ( heap[0].col > *vtop )

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, DWORD PTR [ecx]
	jle	SHORT $LN59@do_tree_fa

; 752  :            *(++vtop) = heap[0].col;  /* add to list */

	add	ecx, 4
	mov	DWORD PTR _vtop$92296[ebp], ecx
	mov	DWORD PTR [ecx], eax
$LN59@do_tree_fa:

; 753  : 
; 754  :        /* delete from heap */
; 755  :        switch ( heap[0].row )

	mov	eax, DWORD PTR [esi]
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN56@do_tree_fa
	cmp	eax, -1
	je	SHORT $LN53@do_tree_fa

; 782  :           default:
; 783  :            if ( heap[0].index+1 < S->pIA[heap[0].row+1] )

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edi+96]
	inc	ecx
	cmp	ecx, DWORD PTR [edx+eax*4+4]
	jge	SHORT $LN55@do_tree_fa

; 784  :            { /* have more */
; 785  :               h.index = heap[0].index + 1;
; 786  :               h.col = S->pJA[h.index];

	mov	edx, DWORD PTR [edi+100]
	mov	DWORD PTR _h$92298[ebp+4], ecx
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _h$92298[ebp+8], ecx

; 787  :               h.row = heap[0].row;

	mov	DWORD PTR _h$92298[ebp], eax

; 788  :            }
; 789  :            else
; 790  :              { /* end of left son */
; 791  :                h.row = -3;
; 792  :                h.col = MAXINT;  /* sentinel */
; 793  :              }
; 794  :              break;

	jmp	SHORT $LN54@do_tree_fa
$LN53@do_tree_fa:

; 767  :              }
; 768  :              break;
; 769  :           case -1:
; 770  :              if ( heap[0].index+1 < (int)left->u.info.size )

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _left$92292[ebp]
	inc	eax
	cmp	eax, DWORD PTR [ecx+16]
	jge	SHORT $LN55@do_tree_fa

; 771  :              { /* have more */
; 772  :                h.index = heap[0].index + 1;
; 773  :                h.col = left->u.info.vlist[h.index];

	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _h$92298[ebp+4], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _h$92298[ebp+8], eax

; 774  :                h.row = -1;

	mov	DWORD PTR _h$92298[ebp], -1

; 775  :              }
; 776  :              else
; 777  :              { /* end of left son */
; 778  :                h.row = -3;
; 779  :                h.col = MAXINT;  /* sentinel */
; 780  :              }
; 781  :              break;

	jmp	SHORT $LN54@do_tree_fa
$LN56@do_tree_fa:

; 756  :        { case -2:
; 757  :              if ( heap[0].index+1 < (int)right->u.info.size )

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _right$92293[ebp]
	inc	eax
	cmp	eax, DWORD PTR [ecx+16]
	jge	SHORT $LN55@do_tree_fa

; 758  :              { /* have more */
; 759  :                h.index = heap[0].index + 1;
; 760  :                h.col = right->u.info.vlist[h.index];

	mov	ecx, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _h$92298[ebp+4], eax
	mov	DWORD PTR _h$92298[ebp+8], edx

; 761  :                h.row = -2;

	mov	DWORD PTR _h$92298[ebp], -2		; fffffffeH

; 762  :              }
; 763  :              else

	jmp	SHORT $LN54@do_tree_fa
$LN55@do_tree_fa:

; 764  :              { /* end of right son */
; 765  :                h.row = -3;

	mov	DWORD PTR _h$92298[ebp], -3		; fffffffdH

; 766  :                h.col = MAXINT;  /* sentinel */

	mov	DWORD PTR _h$92298[ebp+8], 2147483647	; 7fffffffH
$LN54@do_tree_fa:

; 795  :        }          
; 796  :        /* percolate up heap */
; 797  :        hspot = 0;
; 798  :        for (;;)
; 799  :        { next = 2*hspot+1;

	mov	eax, 1
	xor	edx, edx

; 800  :           if ( next >= (int)heapsize ) break;

	cmp	DWORD PTR _heapsize$[ebp], eax
	jle	SHORT $LN147@do_tree_fa
	mov	ecx, DWORD PTR _heapsize$[ebp]
	npad	7
$LL47@do_tree_fa:

; 801  :           if ( (next+1 < (int)heapsize) && (heap[next+1].col < heap[next].col) )

	lea	ebx, DWORD PTR [eax+1]
	cmp	ebx, ecx
	jge	SHORT $LN44@do_tree_fa
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	ebx, DWORD PTR [esi+ecx*4+20]
	cmp	ebx, DWORD PTR [esi+ecx*4+8]
	lea	ecx, DWORD PTR [esi+ecx*4]
	jge	SHORT $LN44@do_tree_fa

; 802  :              next++;  /* right son is lower */

	inc	eax
$LN44@do_tree_fa:

; 803  :           if ( h.col > heap[next].col )

	mov	ebx, DWORD PTR _h$92298[ebp+8]
	lea	ecx, DWORD PTR [eax+eax*2]
	cmp	ebx, DWORD PTR [esi+ecx*4+8]
	lea	ecx, DWORD PTR [esi+ecx*4]
	jle	SHORT $LN144@do_tree_fa

; 804  :           { heap[hspot] = heap[next];

	mov	ebx, DWORD PTR [ecx]
	lea	edx, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ebx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR _heapsize$[ebp]

; 805  :              hspot = next;

	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+1]
	cmp	eax, ecx
	jl	SHORT $LL47@do_tree_fa
$LN144@do_tree_fa:

; 800  :           if ( next >= (int)heapsize ) break;

	mov	ebx, DWORD PTR _stree$92291[ebp]
$LN147@do_tree_fa:
	mov	ecx, DWORD PTR _vtop$92296[ebp]

; 806  :              continue;
; 807  :           }
; 808  :           break;
; 809  :        }
; 810  :        heap[hspot] = h;

	lea	edx, DWORD PTR [edx+edx*2]
	lea	eax, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR _h$92298[ebp]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR _h$92298[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _h$92298[ebp+8]
	mov	DWORD PTR [eax+8], edx
	cmp	DWORD PTR [esi], -2			; fffffffeH
	jge	$LL61@do_tree_fa
$LN60@do_tree_fa:

; 811  :      }
; 812  : 
; 813  :      /* allocate variable list */
; 814  :      stree->u.info.size = varcount = vtop - varlist + 1;

	sub	ecx, DWORD PTR _varlist$92295[ebp]

; 815  :      stree->u.info.vlist = (int*)mycalloc(stree->u.info.size,sizeof(int));

	push	815					; 0000032fH
	sar	ecx, 2
	inc	ecx
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	push	4
	push	ecx
	mov	DWORD PTR _varcount$92297[ebp], ecx
	mov	DWORD PTR [ebx+16], ecx
	call	_kb_calloc
	mov	DWORD PTR [ebx+20], eax

; 816  :      for ( k = 0 ; k < varcount ; k++ ) 

	xor	eax, eax
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _varcount$92297[ebp], eax
	jbe	SHORT $LN148@do_tree_fa
	npad	4
$LL42@do_tree_fa:

; 817  :        stree->u.info.vlist[k] = varlist[k];

	mov	edx, DWORD PTR _varlist$92295[ebp]
	mov	ecx, DWORD PTR [ebx+20]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	ecx, DWORD PTR _varcount$92297[ebp]
	inc	eax
	cmp	eax, ecx
	jb	SHORT $LL42@do_tree_fa

; 816  :      for ( k = 0 ; k < varcount ; k++ ) 

	jmp	SHORT $LN40@do_tree_fa
$LN148@do_tree_fa:
	mov	ecx, DWORD PTR _varcount$92297[ebp]
$LN40@do_tree_fa:

; 818  :      for ( k = 0 ; k < varcount ; k++ )

	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN37@do_tree_fa
	npad	1
$LL39@do_tree_fa:

; 819  :        work[stree->u.info.vlist[k]] = (int)k;  /* inverse mapping */

	mov	edx, DWORD PTR [ebx+20]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [esi+edx*4], eax
	inc	eax
	cmp	eax, ecx
	jb	SHORT $LL39@do_tree_fa
$LN37@do_tree_fa:

; 820  :       
; 821  :      /* allocate matrix */
; 822  :      stree->u.info.mat =(REAL*) 
; 823  :        mycalloc(varcount*(varcount+1)/2,sizeof(REAL));

	mov	eax, DWORD PTR _varcount$92297[ebp]
	lea	ecx, DWORD PTR [eax+1]
	imul	ecx, eax
	push	823					; 00000337H
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	shr	ecx, 1
	push	8
	push	ecx
	call	_kb_calloc

; 824  : 
; 825  :      /* fill matrix */
; 826  :      base = stree->u.info.mat;
; 827  :      for ( i = stree->lo ; i < stree->hi ; base+=(varcount-i-1+stree->lo),i++ )

	mov	edx, DWORD PTR [ebx+4]
	fldz
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ebx+24], eax
	mov	ecx, eax
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, DWORD PTR [ebx+8]
	jge	$LN34@do_tree_fa
$LN36@do_tree_fa:
	mov	eax, DWORD PTR [edi+96]
	lea	ebx, DWORD PTR [eax+edx*4]

; 828  :      { for ( j = S->pIA[i] ; j < S->pIA[i+1] ; j++ )

	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR [ebx+4]
	jge	SHORT $LN140@do_tree_fa
$LN132@do_tree_fa:

; 829  :           base[work[S->pJA[j]]] += S->pA[j];

	mov	ebx, DWORD PTR [edi+100]
	mov	ebx, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR [esi+ebx*4]
	lea	ebx, DWORD PTR [ecx+ebx*8]
	mov	DWORD PTR tv1308[ebp], ebx
	mov	ebx, DWORD PTR [edi+104]
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR tv1308[ebp]
	fadd	QWORD PTR [ebx]
	inc	eax
	fstp	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [edi+96]
	cmp	eax, DWORD PTR [ebx+edx*4+4]
	jl	SHORT $LN132@do_tree_fa
$LN140@do_tree_fa:

; 830  :        /* add in shift and metric */
; 831  :        if ( hessian_linear_metric_flag )

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	$LN30@do_tree_fa

; 832  :        { if ( S->lambda != 0.0 )

	fld	QWORD PTR [edi+112]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN35@do_tree_fa

; 833  :           { int end = Met.pIA[i+1];

	mov	eax, DWORD PTR _Met+96
	mov	ebx, DWORD PTR [eax+edx*4+4]

; 834  :              for ( j = Met.pIA[i] ; j < end ; j++ )

	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _end$92399[ebp], ebx
	cmp	eax, ebx
	jge	$LN35@do_tree_fa
	sub	ebx, eax
	cmp	ebx, 4
	jl	$LN141@do_tree_fa
$LN127@do_tree_fa:

; 835  :                base[work[Met.pJA[j]]] -= S->lambda*Met.pA[j];

	mov	ebx, DWORD PTR _Met+104
	fld	QWORD PTR [ebx+eax*8]
	mov	edx, DWORD PTR _Met+100
	mov	edx, DWORD PTR [edx+eax*4]
	fmul	QWORD PTR [edi+112]
	mov	edx, DWORD PTR [esi+edx*4]
	lea	edx, DWORD PTR [ecx+edx*8]
	fsubr	QWORD PTR [edx]
	add	eax, 4
	fstp	QWORD PTR [edx]
	mov	ebx, DWORD PTR _Met+104
	fld	QWORD PTR [ebx+eax*8-24]
	mov	edx, DWORD PTR _Met+100
	mov	edx, DWORD PTR [edx+eax*4-12]
	fmul	QWORD PTR [edi+112]
	mov	edx, DWORD PTR [esi+edx*4]
	lea	edx, DWORD PTR [ecx+edx*8]
	fsubr	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	ebx, DWORD PTR _Met+104
	mov	edx, DWORD PTR _Met+100
	fld	QWORD PTR [ebx+eax*8-16]
	mov	edx, DWORD PTR [edx+eax*4-8]
	fmul	QWORD PTR [edi+112]
	mov	edx, DWORD PTR [esi+edx*4]
	lea	edx, DWORD PTR [ecx+edx*8]
	fsubr	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR _Met+100
	mov	edx, DWORD PTR [edx+eax*4-4]
	mov	ebx, DWORD PTR _Met+104
	fld	QWORD PTR [ebx+eax*8-8]
	mov	edx, DWORD PTR [esi+edx*4]
	fmul	QWORD PTR [edi+112]
	lea	edx, DWORD PTR [ecx+edx*8]
	fsubr	QWORD PTR [edx]
	fstp	QWORD PTR [edx]

; 849  :           mat = stree->u.info.mat + row*varcount - (((row-1)*row)>>1) - row;

	mov	edx, DWORD PTR _end$92399[ebp]
	add	edx, -3					; fffffffdH
	cmp	eax, edx
	jl	$LN127@do_tree_fa

; 835  :                base[work[Met.pJA[j]]] -= S->lambda*Met.pA[j];

	mov	edx, DWORD PTR _i$[ebp]
$LN141@do_tree_fa:

; 834  :              for ( j = Met.pIA[i] ; j < end ; j++ )

	cmp	eax, DWORD PTR _end$92399[ebp]
	jge	SHORT $LN35@do_tree_fa
$LC28@do_tree_fa:

; 835  :                base[work[Met.pJA[j]]] -= S->lambda*Met.pA[j];

	mov	ebx, DWORD PTR _Met+100
	mov	ebx, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR [esi+ebx*4]
	lea	ebx, DWORD PTR [ecx+ebx*8]
	mov	DWORD PTR tv1421[ebp], ebx
	mov	ebx, DWORD PTR _Met+104
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR tv1421[ebp]
	fmul	QWORD PTR [edi+112]
	inc	eax
	fsubr	QWORD PTR [ebx]
	fstp	QWORD PTR [ebx]
	cmp	eax, DWORD PTR _end$92399[ebp]
	jl	SHORT $LC28@do_tree_fa

; 836  :           }

	jmp	SHORT $LN35@do_tree_fa
$LN30@do_tree_fa:

; 837  :        }
; 838  :        else if ( web.area_norm_flag )
; 839  :            base[i-stree->lo] -= S->lambda*Met.A[S->P[i]]; /* special metric */

	mov	ebx, DWORD PTR _stree$92291[ebp]
	mov	eax, edx
	sub	eax, DWORD PTR [ebx+4]
	cmp	DWORD PTR _web+876, 0
	lea	eax, DWORD PTR [ecx+eax*8]
	je	SHORT $LN24@do_tree_fa
	mov	ebx, DWORD PTR _Met+60
	mov	DWORD PTR tv1432[ebp], eax
	mov	eax, DWORD PTR [edi+68]
	mov	eax, DWORD PTR [eax+edx*4]
	fld	QWORD PTR [ebx+eax*8]
	mov	eax, DWORD PTR tv1432[ebp]
	fmul	QWORD PTR [edi+112]
	fsubr	QWORD PTR [eax]
	jmp	SHORT $LN214@do_tree_fa
$LN24@do_tree_fa:

; 840  :        else base[i-stree->lo] -= S->lambda;

	fld	QWORD PTR [eax]
	fsub	QWORD PTR [edi+112]
$LN214@do_tree_fa:
	fstp	QWORD PTR [eax]
$LN35@do_tree_fa:

; 824  : 
; 825  :      /* fill matrix */
; 826  :      base = stree->u.info.mat;
; 827  :      for ( i = stree->lo ; i < stree->hi ; base+=(varcount-i-1+stree->lo),i++ )

	mov	eax, DWORD PTR _stree$92291[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR _stree$92291[ebp]
	sub	eax, edx
	add	eax, DWORD PTR _varcount$92297[ebp]
	inc	edx
	lea	ecx, DWORD PTR [ecx+eax*8-8]
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, DWORD PTR [ebx+8]
	jl	$LN36@do_tree_fa
$LN34@do_tree_fa:

; 841  :      }
; 842  :      if ( !stree->isleaf )

	cmp	DWORD PTR [ebx+12], 0
	jne	$LN19@do_tree_fa

; 843  :      for ( son = left, kk = 0 ; kk < 2 ; kk++, son=right )

	mov	eax, DWORD PTR _left$92292[ebp]
	mov	DWORD PTR tv837[ebp], 2
$LN21@do_tree_fa:

; 844  :      { int sonsepsize = son->hi - son->lo;

	mov	edi, DWORD PTR [eax+8]
	sub	edi, DWORD PTR [eax+4]

; 845  :        REAL *sonsrc = son->u.info.mat + sonsepsize*son->u.info.size
; 846  :                               - (((sonsepsize-1)*sonsepsize)>>1);

	mov	ecx, DWORD PTR [eax+16]
	lea	edx, DWORD PTR [edi-1]
	imul	ecx, edi
	imul	edx, edi
	sar	edx, 1
	sub	ecx, edx
	mov	edx, DWORD PTR [eax+24]
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _sonsrc$92411[ebp], ecx

; 847  :        for ( k = sonsepsize ; k < son->u.info.size ; k++ )

	cmp	edi, DWORD PTR [eax+16]
	jae	SHORT $LN20@do_tree_fa
$LN135@do_tree_fa:

; 848  :        { row = work[son->u.info.vlist[k]];

	mov	edx, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR [edx+edi*4]
	mov	ecx, DWORD PTR [esi+ecx*4]

; 849  :           mat = stree->u.info.mat + row*varcount - (((row-1)*row)>>1) - row;

	mov	edx, DWORD PTR _varcount$92297[ebp]
	lea	ebx, DWORD PTR [ecx-1]
	imul	ebx, ecx
	dec	edx
	imul	edx, ecx
	sar	ebx, 1
	sub	edx, ebx
	mov	ebx, DWORD PTR _stree$92291[ebp]
	mov	ecx, DWORD PTR [ebx+24]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _mat$[ebp], edx

; 850  :           for ( j = (int)k ; j < (int)son->u.info.size ; j++,sonsrc++ )

	mov	ecx, edi
	cmp	edi, DWORD PTR [eax+16]
	jge	SHORT $LN17@do_tree_fa
$LN136@do_tree_fa:

; 851  :              mat[work[son->u.info.vlist[j]]] += *sonsrc;

	mov	edx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	ebx, DWORD PTR _mat$[ebp]
	fld	QWORD PTR [ebx+edx*8]
	lea	edx, DWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR _sonsrc$92411[ebp]
	fadd	QWORD PTR [ebx]
	inc	ecx
	add	ebx, 8
	mov	DWORD PTR _sonsrc$92411[ebp], ebx
	fstp	QWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+16]
	jl	SHORT $LN136@do_tree_fa

; 850  :           for ( j = (int)k ; j < (int)son->u.info.size ; j++,sonsrc++ )

	mov	ebx, DWORD PTR _stree$92291[ebp]
$LN17@do_tree_fa:

; 847  :        for ( k = sonsepsize ; k < son->u.info.size ; k++ )

	inc	edi
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN135@do_tree_fa
$LN20@do_tree_fa:

; 843  :      for ( son = left, kk = 0 ; kk < 2 ; kk++, son=right )

	dec	DWORD PTR tv837[ebp]
	mov	eax, DWORD PTR _right$92293[ebp]
	jne	$LN21@do_tree_fa
$LN19@do_tree_fa:

; 857  :      for ( row = 0 ; row < (int)sepsize ; row++, base += varcount-row )

	mov	edx, DWORD PTR _sepsize$[ebp]
	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR _base$92302[ebp], eax
	test	edx, edx
	jle	$LN183@do_tree_fa

; 852  :        }
; 853  :      }     
; 854  : 
; 855  :      /* factor */
; 856  :      base = stree->u.info.mat;

	mov	ecx, DWORD PTR _varcount$92297[ebp]
	fld1
	lea	eax, DWORD PTR [ecx*8]
	dec	ecx
	mov	DWORD PTR tv3030[ebp], 1
	mov	DWORD PTR tv3032[ebp], 0
	mov	DWORD PTR tv3081[ebp], eax
	mov	DWORD PTR tv3083[ebp], ecx
	mov	DWORD PTR tv192[ebp], edx
$LN12@do_tree_fa:

; 858  :      { REAL piv;
; 859  :         if ( fabs(base[row]) <= hessian_epsilon) 

	mov	edx, DWORD PTR tv3032[ebp]
	mov	ecx, DWORD PTR _base$92302[ebp]
	fld	QWORD PTR [edx+ecx]
	fabs
	fcomp	QWORD PTR _hessian_epsilon
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN9@do_tree_fa

; 860  :         { S->zero++; base[row] = 1.0; continue; }

	mov	eax, DWORD PTR _S$[ebp]
	inc	DWORD PTR [eax+192]
	fst	QWORD PTR [edx+ecx]
	jmp	$LN11@do_tree_fa
$LN9@do_tree_fa:

; 861  :         if ( base[row] > 0.0 ) 

	fxch	ST(1)
	fcom	QWORD PTR [edx+ecx]
	fnstsw	ax
	test	ah, 5

; 862  :             S->pos++; 

	mov	eax, DWORD PTR _S$[ebp]
	jp	SHORT $LN8@do_tree_fa
	inc	DWORD PTR [eax+184]

; 863  :         else 

	jmp	SHORT $LN7@do_tree_fa
$LN8@do_tree_fa:

; 864  :             S->neg++;

	inc	DWORD PTR [eax+188]
$LN7@do_tree_fa:

; 866  :         mat = base + varcount;
; 867  :         for ( i = row+1 ; i < (int)varcount ; i++ )

	mov	ebx, DWORD PTR tv3030[ebp]
	fld	ST(1)
	fdiv	QWORD PTR [edx+ecx]
	mov	edx, DWORD PTR _varcount$92297[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	cmp	ebx, edx
	jge	$LN209@do_tree_fa

; 865  :         piv = 1/base[row];

	mov	ecx, DWORD PTR tv3083[ebp]
	mov	DWORD PTR tv2996[ebp], ecx
$LN6@do_tree_fa:

; 868  :         { REAL q = base[i]*piv;

	mov	edx, DWORD PTR _base$92302[ebp]
	fld	QWORD PTR [edx+ebx*8]

; 869  :           for ( j = i ; j < (int)varcount ; j++ )

	mov	edi, ebx
	fmul	ST(0), ST(1)
	cmp	ebx, DWORD PTR _varcount$92297[ebp]
	jge	SHORT $LN128@do_tree_fa
	cmp	DWORD PTR tv2996[ebp], 4
	jl	SHORT $LC129@do_tree_fa

; 866  :         mat = base + varcount;
; 867  :         for ( i = row+1 ; i < (int)varcount ; i++ )

	mov	ecx, edx
	lea	edx, DWORD PTR [ecx+ebx*8+16]

; 870  :              *(mat++) -= q*base[j];

	mov	ecx, DWORD PTR _varcount$92297[ebp]
	sub	ecx, ebx
	sub	ecx, 4
	shr	ecx, 2
	inc	ecx
	lea	edi, DWORD PTR [ebx+ecx*4]
$LN130@do_tree_fa:
	fld	QWORD PTR [edx-16]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	dec	ecx
	fsubr	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	fld	QWORD PTR [edx-24]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LN130@do_tree_fa
$LC129@do_tree_fa:

; 869  :           for ( j = i ; j < (int)varcount ; j++ )

	mov	ecx, DWORD PTR _varcount$92297[ebp]
	cmp	edi, ecx
	jge	SHORT $LN128@do_tree_fa
	mov	edx, DWORD PTR _base$92302[ebp]
$LC3@do_tree_fa:

; 870  :              *(mat++) -= q*base[j];

	fld	QWORD PTR [edx+edi*8]
	inc	edi
	fmul	ST(0), ST(1)
	add	eax, 8
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	edi, ecx
	jl	SHORT $LC3@do_tree_fa
$LN128@do_tree_fa:

; 871  :           base[i] = q;

	mov	edx, DWORD PTR _base$92302[ebp]
	dec	DWORD PTR tv2996[ebp]
	fstp	QWORD PTR [edx+ebx*8]
	inc	ebx
	cmp	ebx, DWORD PTR _varcount$92297[ebp]
	jl	$LN6@do_tree_fa
$LN209@do_tree_fa:

; 866  :         mat = base + varcount;
; 867  :         for ( i = row+1 ; i < (int)varcount ; i++ )

	fstp	ST(0)
	fxch	ST(1)
$LN11@do_tree_fa:

; 857  :      for ( row = 0 ; row < (int)sepsize ; row++, base += varcount-row )

	mov	eax, DWORD PTR tv3081[ebp]
	add	DWORD PTR tv3032[ebp], 8
	mov	ecx, 1
	add	DWORD PTR tv3030[ebp], ecx
	sub	DWORD PTR tv3083[ebp], ecx
	sub	eax, 8
	add	DWORD PTR _base$92302[ebp], eax
	sub	DWORD PTR tv192[ebp], ecx
	mov	DWORD PTR tv3081[ebp], eax
	jne	$LN12@do_tree_fa

; 866  :         mat = base + varcount;
; 867  :         for ( i = row+1 ; i < (int)varcount ; i++ )

	fstp	ST(0)
$LN183@do_tree_fa:

; 872  :         }
; 873  :      }
; 874  :      /* mark as done */
; 875  :      stree->isleaf |= 2;

	mov	eax, DWORD PTR _stree$92291[ebp]
	fstp	ST(0)
	or	DWORD PTR [eax+12], 2
	mov	eax, DWORD PTR _spot$[ebp]
	mov	edi, DWORD PTR _S$[ebp]
$LN83@do_tree_fa:

; 674  : 
; 675  :   for ( ; spot >= 1 ; spot -= nprocs )  /* metis starts at stree[1] */

	sub	eax, DWORD PTR _nprocs
	mov	DWORD PTR _spot$[ebp], eax
	cmp	eax, 1
	jge	$LL84@do_tree_fa
$LN82@do_tree_fa:

; 876  :   }
; 877  : 
; 878  :   temp_free((char*)work);

	push	esi
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 879  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_do_tree_factor ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@MACJPBFA@Total?5fill?3?5?$CFld?5?5Total?5flops?$CIflo@ ; `string'
PUBLIC	??_C@_0BN@BPGHLJII@Critical?5path?5flops?3?5?$CF12?40f?6?$AA@ ; `string'
PUBLIC	??_C@_0L@BOIELEFH@?$CF2d?5?5?$CF12g?6?$AA@	; `string'
PUBLIC	??_C@_0P@ONFFEDEC@Proc?5?5?5?5Flops?6?$AA@	; `string'
PUBLIC	__real@41f0000000000000
PUBLIC	??_C@_0BG@JPLEOGDK@Empty?5linear?5system?4?6?$AA@ ; `string'
PUBLIC	_S$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_tree_factor
EXTRN	_msg:DWORD
EXTRN	_outstring:PROC
EXTRN	_hessian_quiet_flag:DWORD
EXTRN	_sparse_permute:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0EC@MACJPBFA@Total?5fill?3?5?$CFld?5?5Total?5flops?$CIflo@
CONST	SEGMENT
??_C@_0EC@MACJPBFA@Total?5fill?3?5?$CFld?5?5Total?5flops?$CIflo@ DB 'Tota'
	DB	'l fill: %ld  Total flops(flop=mul+add): %g    Fillspace: %ld', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BPGHLJII@Critical?5path?5flops?3?5?$CF12?40f?6?$AA@
CONST	SEGMENT
??_C@_0BN@BPGHLJII@Critical?5path?5flops?3?5?$CF12?40f?6?$AA@ DB 'Critica'
	DB	'l path flops: %12.0f', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BOIELEFH@?$CF2d?5?5?$CF12g?6?$AA@
CONST	SEGMENT
??_C@_0L@BOIELEFH@?$CF2d?5?5?$CF12g?6?$AA@ DB '%2d  %12g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ONFFEDEC@Proc?5?5?5?5Flops?6?$AA@
CONST	SEGMENT
??_C@_0P@ONFFEDEC@Proc?5?5?5?5Flops?6?$AA@ DB 'Proc    Flops', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
CONST	ENDS
;	COMDAT ??_C@_0BG@JPLEOGDK@Empty?5linear?5system?4?6?$AA@
CONST	SEGMENT
??_C@_0BG@JPLEOGDK@Empty?5linear?5system?4?6?$AA@ DB 'Empty linear system'
	DB	'.', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _tree_factor
_TEXT	SEGMENT
_S$GSCopy$ = -1192					; size = 4
_critpath$92470 = -1188					; size = 8
tv508 = -1184						; size = 4
tv495 = -1184						; size = 4
_flops$92451 = -1180					; size = 8
tv480 = -1176						; size = 4
_fillspace$92454 = -1172				; size = 4
tv371 = -1168						; size = 4
_k$92455 = -1164					; size = 4
_fill$92453 = -1160					; size = 4
_critflops$92452 = -1156				; size = 1152
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_tree_factor PROC					; COMDAT

; 889  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 1192				; 000004a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _S$[ebp]
	push	esi

; 890  : 
; 891  :   if ( S->N <= 0 )

	xor	esi, esi

; 933  :         fillspace += size*(size+1)/2;

	mov	DWORD PTR _S$GSCopy$[ebp], ebx
	cmp	DWORD PTR [ebx+4], esi
	jg	SHORT $LN17@tree_facto

; 892  :   { kb_error(1638,"Empty linear system.\n",WARNING); 

	push	2
	push	OFFSET ??_C@_0BG@JPLEOGDK@Empty?5linear?5system?4?6?$AA@
	push	1638					; 00000666H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebx

; 957  :   }
; 958  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@tree_facto:

; 893  :     return;
; 894  :   }
; 895  :   S->neg = S->zero = S->pos = 0;
; 896  :   S->degencon = 0;
; 897  : 
; 898  :   sparse_permute(S);

	push	ebx
	mov	DWORD PTR [ebx+184], esi
	mov	DWORD PTR [ebx+192], esi
	mov	DWORD PTR [ebx+188], esi
	mov	DWORD PTR [ebx+196], esi
	call	_sparse_permute
	add	esp, 4

; 899  :   if ( hessian_linear_metric_flag && (S->lambda != 0.0) )

	cmp	DWORD PTR _hessian_linear_metric_flag, esi
	je	SHORT $LN16@tree_facto
	fld	QWORD PTR [ebx+112]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@tree_facto

; 900  :   { memcpy((char*)Met.P,(char*)S->P,S->N*sizeof(int));

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx+68]
	mov	edx, DWORD PTR _Met+68
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	edx
	call	_memcpy

; 901  :     memcpy((char*)Met.IP,(char*)S->IP,S->N*sizeof(int));

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx+72]
	mov	edx, DWORD PTR _Met+72
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	edx
	call	_memcpy

; 902  :     sparse_permute(&Met);

	push	OFFSET _Met
	call	_sparse_permute
	add	esp, 28					; 0000001cH
$LN16@tree_facto:

; 903  :   }
; 904  : 
; 905  : 
; 906  :   /* this set up to be done in parallel */
; 907  : #ifdef SGI_MULTI
; 908  :   if ( mpflag == M_INACTIVE ) m_rele_procs();
; 909  :   mpflag = M_ACTIVE;
; 910  :   m_fork(do_tree_factor,S);
; 911  :   m_park_procs();
; 912  :   mpflag = M_INACTIVE;
; 913  : #else
; 914  :   do_tree_factor(S);

	push	ebx
	call	_do_tree_factor
	add	esp, 4

; 915  : #endif
; 916  : 
; 917  :   if ( !hessian_quiet_flag )

	cmp	DWORD PTR _hessian_quiet_flag, esi
	jne	$LN15@tree_facto

; 918  :   { /* A few statistics */
; 919  :      REAL flops = 0.0;

	fldz

; 920  :      REAL critflops[MAXPROCS];  /* critical path flops */
; 921  :      size_t fill = 0;
; 922  :      size_t fillspace = 0;
; 923  :      int k;
; 924  : 
; 925  :      for ( k = 0 ; k < nprocs ; k++ ) critflops[k] = 0.0;

	mov	edx, DWORD PTR _nprocs
	fld	ST(0)
	push	edi
	fst	QWORD PTR _flops$92451[ebp]
	mov	DWORD PTR _fill$92453[ebp], esi
	mov	DWORD PTR _fillspace$92454[ebp], esi
	cmp	edx, esi
	jle	SHORT $LN14@tree_facto

; 918  :   { /* A few statistics */
; 919  :      REAL flops = 0.0;

	mov	ecx, edx
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	lea	edi, DWORD PTR _critflops$92452[ebp]
	rep stosd
$LN14@tree_facto:

; 926  :      for ( k = 0 ; k < S->streemax ; k++ )

	mov	DWORD PTR _k$92455[ebp], esi
	cmp	DWORD PTR [ebx+80], esi
	jle	$LN9@tree_facto

; 956  :      outstring(msg);

	mov	eax, DWORD PTR [ebx+80]
	mov	DWORD PTR tv371[ebp], eax
	mov	eax, DWORD PTR [ebx+76]
	mov	DWORD PTR tv480[ebp], eax
$LN11@tree_facto:

; 927  :      { int sep = S->stree[k].hi - S->stree[k].lo;

	mov	esi, DWORD PTR [eax+8]
	sub	esi, DWORD PTR [eax+4]

; 928  :        size_t size = S->stree[k].u.info.size;

	mov	ecx, DWORD PTR [eax+16]

; 929  :        size_t rem = size - sep;

	mov	edi, ecx
	sub	edi, esi

; 930  :        size_t fl;
; 931  : 
; 932  :         if ( S->stree[k].nvtxs <= 0 ) continue;

	cmp	DWORD PTR [eax], 0
	jle	$LN10@tree_facto

; 933  :         fillspace += size*(size+1)/2;

	lea	ebx, DWORD PTR [ecx+1]
	mov	edx, ebx
	imul	edx, ecx
	shr	edx, 1
	add	DWORD PTR _fillspace$92454[ebp], edx

; 934  :         fill += size*sep - sep*(sep-1)/2;

	lea	eax, DWORD PTR [esi-1]
	imul	eax, esi
	cdq
	sub	eax, edx
	mov	edx, ecx
	imul	edx, esi
	sar	eax, 1
	sub	edx, eax
	add	DWORD PTR _fill$92453[ebp], edx

; 935  :         fl = size*(size+1)*(size+2)/6 - rem*(rem+1)*(rem+2)/6;

	lea	eax, DWORD PTR [edi+1]
	lea	edx, DWORD PTR [edi+2]
	imul	edx, eax
	imul	edx, edi
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	shr	edx, 2
	mov	esi, edx
	lea	edx, DWORD PTR [ecx+2]
	imul	edx, ebx
	imul	edx, ecx
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx

; 936  :         critflops[k % nprocs] += (REAL)fl;

	mov	eax, DWORD PTR _k$92455[ebp]
	shr	edx, 2
	mov	ecx, edx
	cdq
	idiv	DWORD PTR _nprocs
	sub	ecx, esi
	mov	DWORD PTR tv508[ebp], ecx
	fild	DWORD PTR tv508[ebp]
	lea	eax, DWORD PTR _critflops$92452[ebp+edx*8]
	test	ecx, ecx
	jns	SHORT $LN48@tree_facto
	fadd	QWORD PTR __real@41f0000000000000
$LN48@tree_facto:

; 937  :         flops += (REAL)fl;

	mov	ebx, DWORD PTR _S$GSCopy$[ebp]
	fld	ST(0)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	eax, DWORD PTR tv480[ebp]
	faddp	ST(1), ST(0)
$LN10@tree_facto:

; 926  :      for ( k = 0 ; k < S->streemax ; k++ )

	mov	ecx, DWORD PTR _k$92455[ebp]
	inc	ecx
	add	eax, 32					; 00000020H
	mov	DWORD PTR _k$92455[ebp], ecx
	mov	DWORD PTR tv480[ebp], eax
	cmp	ecx, DWORD PTR tv371[ebp]
	jl	$LN11@tree_facto
	mov	edx, DWORD PTR _nprocs

; 937  :         flops += (REAL)fl;

	fst	QWORD PTR _flops$92451[ebp]
	xor	esi, esi
$LN9@tree_facto:

; 938  :      }
; 939  : 
; 940  :      if ( nprocs > 1 )

	cmp	edx, 1
	jle	$LN42@tree_facto

; 952  :         outstring(msg);

	fstp	ST(0)
	push	OFFSET ??_C@_0P@ONFFEDEC@Proc?5?5?5?5Flops?6?$AA@
	fstp	QWORD PTR _critpath$92470[ebp]
	call	_outstring
	add	esp, 4
	xor	eax, eax
	cmp	DWORD PTR _nprocs, esi
	jle	SHORT $LN4@tree_facto
	npad	5
$LL6@tree_facto:

; 941  :      { REAL critpath = 0.0;
; 942  :         outstring("Proc    Flops\n");
; 943  :         for ( k = 0 ; k < nprocs ; k++ )
; 944  :         { sprintf(msg,"%2d  %12g\n",k+1,(DOUBLE)critflops[k]); outstring(msg); }

	fld	QWORD PTR _critflops$92452[ebp+eax*8]
	sub	esp, 8
	lea	esi, DWORD PTR [eax+1]
	fstp	QWORD PTR [esp]
	mov	eax, DWORD PTR _msg
	push	esi
	push	OFFSET ??_C@_0L@BOIELEFH@?$CF2d?5?5?$CF12g?6?$AA@
	push	eax
	call	_sprintf
	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	mov	eax, esi
	add	esp, 24					; 00000018H
	cmp	eax, DWORD PTR _nprocs
	jl	SHORT $LL6@tree_facto
$LN4@tree_facto:

; 945  :         for ( k = 1 ; k <= S->streemax ; k *= 2 )

	fld	QWORD PTR _critpath$92470[ebp]
	mov	esi, 1
	cmp	DWORD PTR [ebx+80], esi
	jl	SHORT $LN1@tree_facto

; 946  :         { int sep = S->stree[k].hi - S->stree[k].lo;
; 947  :           size_t size = S->stree[k].u.info.size;

	mov	edx, DWORD PTR [ebx+80]
	mov	edi, DWORD PTR [ebx+76]
	mov	DWORD PTR tv371[ebp], edx
$LN3@tree_facto:
	mov	edx, esi
	shl	edx, 5

; 948  :           size_t rem = size - sep;

	mov	eax, DWORD PTR [edx+edi+4]
	sub	eax, DWORD PTR [edx+edi+8]
	mov	ecx, DWORD PTR [edx+edi+16]
	add	eax, ecx

; 949  :           critpath += (REAL)(size*(size+1)*(size+2)/6 - rem*(rem+1)*(rem+2)/6);

	lea	ebx, DWORD PTR [eax+1]
	lea	edx, DWORD PTR [eax+2]
	imul	edx, ebx
	imul	edx, eax
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	shr	edx, 2
	mov	ebx, edx
	lea	eax, DWORD PTR [ecx+1]
	lea	edx, DWORD PTR [ecx+2]
	imul	edx, eax
	imul	edx, ecx
	mov	eax, -1431655765			; aaaaaaabH
	mul	edx
	shr	edx, 2
	sub	edx, ebx
	mov	DWORD PTR tv495[ebp], edx
	fild	DWORD PTR tv495[ebp]
	jns	SHORT $LN49@tree_facto
	fadd	QWORD PTR __real@41f0000000000000
$LN49@tree_facto:

; 945  :         for ( k = 1 ; k <= S->streemax ; k *= 2 )

	add	esi, esi

; 949  :           critpath += (REAL)(size*(size+1)*(size+2)/6 - rem*(rem+1)*(rem+2)/6);

	faddp	ST(1), ST(0)
	cmp	esi, DWORD PTR tv371[ebp]
	jle	SHORT $LN3@tree_facto
$LN1@tree_facto:

; 950  :         }
; 951  :         sprintf(msg,"Critical path flops: %12.0f\n",(DOUBLE)critpath);

	mov	ecx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BN@BPGHLJII@Critical?5path?5flops?3?5?$CF12?40f?6?$AA@
	push	ecx
	call	_sprintf

; 952  :         outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	fld	QWORD PTR _flops$92451[ebp]
	add	esp, 20					; 00000014H
	jmp	SHORT $LN7@tree_facto
$LN42@tree_facto:
	fstp	ST(1)
$LN7@tree_facto:

; 953  :      }
; 954  :      sprintf(msg,"Total fill: %ld  Total flops(flop=mul+add): %g    Fillspace: %ld\n",
; 955  :          (long)fill,(DOUBLE)flops,(long)fillspace);

	mov	eax, DWORD PTR _fillspace$92454[ebp]
	mov	ecx, DWORD PTR _fill$92453[ebp]
	mov	edx, DWORD PTR _msg
	push	eax
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	push	OFFSET ??_C@_0EC@MACJPBFA@Total?5fill?3?5?$CFld?5?5Total?5flops?$CIflo@
	push	edx
	call	_sprintf

; 956  :      outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 28					; 0000001cH
	pop	edi
$LN15@tree_facto:

; 957  :   }
; 958  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_tree_factor ENDP
_TEXT	ENDS
PUBLIC	_do_tree_solve
; Function compile flags: /Ogtp
;	COMDAT _do_tree_solve
_TEXT	SEGMENT
_stree$ = -28						; size = 4
tv975 = -24						; size = 4
tv558 = -20						; size = 4
_spot$ = -20						; size = 4
tv249 = -16						; size = 4
_estart$92525 = -16					; size = 4
tv985 = -12						; size = 4
tv546 = -12						; size = 4
tv965 = -8						; size = 4
tv569 = -8						; size = 4
_n$ = -4						; size = 4
_S$ = 8							; size = 4
_BB$ = 12						; size = 4
_Y$ = 16						; size = 4
_do_tree_solve PROC					; COMDAT

; 975  : { SepNodeType *stree;

	push	ebp
	mov	ebp, esp

; 976  :   int spot;
; 977  :   int n;
; 978  :   REAL *e;
; 979  : 
; 980  :   /* solve U^T Y = B */
; 981  :   for ( spot = S->streemax; spot >= 1 ; spot-- )  /* metis starts at stree[1] */

	mov	edx, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [edx+80]
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	mov	esi, DWORD PTR _BB$[ebp]
	push	edi
	cmp	eax, 1
	jl	$LN16@do_tree_so
	mov	ebx, eax
	shl	ebx, 5
	mov	DWORD PTR tv569[ebp], ebx
	mov	DWORD PTR tv249[ebp], eax
	npad	10
$LL18@do_tree_so:
	mov	ecx, DWORD PTR [edx+76]

; 983  : 
; 984  :      for ( n = stree->lo, e = stree->u.info.mat ; n < stree->hi ; n++ )

	mov	eax, DWORD PTR [ecx+ebx+4]
	mov	edi, DWORD PTR [ecx+ebx+24]
	add	ecx, ebx
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, DWORD PTR [ecx+8]
	jge	SHORT $LN17@do_tree_so

; 982  :   { stree = S->stree + spot;

	mov	ebx, DWORD PTR _Y$[ebp]
	lea	edx, DWORD PTR [ebx+eax*8]

; 983  : 
; 984  :      for ( n = stree->lo, e = stree->u.info.mat ; n < stree->hi ; n++ )

	mov	eax, esi
	sub	eax, ebx
	mov	DWORD PTR tv546[ebp], edx
	mov	DWORD PTR tv558[ebp], eax
	jmp	SHORT $LN15@do_tree_so
$LL38@do_tree_so:
	mov	eax, DWORD PTR tv558[ebp]
$LN15@do_tree_so:

; 985  :      { int start;
; 986  :        REAL y;
; 987  :        int i,*jp;
; 988  : 
; 989  :        y = Y[n] = BB[n]; 

	fld	QWORD PTR [eax+edx]

; 990  :        Y[n] /= *e; e++;  /* having saved Y[n], can divide by diag */
; 991  :        start = n-stree->lo+1;

	mov	eax, DWORD PTR _n$[ebp]
	fld	ST(0)
	add	edi, 8
	fxch	ST(1)
	fstp	QWORD PTR [edx]
	fld	ST(0)
	fxch	ST(1)
	fdiv	QWORD PTR [edi-8]
	fstp	QWORD PTR [edx]
	sub	eax, DWORD PTR [ecx+4]

; 992  :        for ( i=start, jp = stree->u.info.vlist+start ; 
; 993  :                      i < (int)stree->u.info.size ; i++,e++,jp++ )

	mov	ebx, DWORD PTR [ecx+20]
	inc	eax
	lea	ebx, DWORD PTR [ebx+eax*4]
	cmp	eax, DWORD PTR [ecx+16]
	jge	SHORT $LN40@do_tree_so
$LN12@do_tree_so:

; 994  :           BB[*jp] -= (*e)*y;

	fld	QWORD PTR [edi]
	mov	edx, DWORD PTR [ebx]
	fmul	ST(0), ST(1)
	lea	edx, DWORD PTR [esi+edx*8]
	inc	eax
	add	edi, 8
	fsubr	QWORD PTR [edx]
	add	ebx, 4
	fstp	QWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx+16]
	jl	SHORT $LN12@do_tree_so

; 992  :        for ( i=start, jp = stree->u.info.vlist+start ; 
; 993  :                      i < (int)stree->u.info.size ; i++,e++,jp++ )

	mov	edx, DWORD PTR tv546[ebp]
$LN40@do_tree_so:

; 983  : 
; 984  :      for ( n = stree->lo, e = stree->u.info.mat ; n < stree->hi ; n++ )

	mov	eax, DWORD PTR _n$[ebp]

; 992  :        for ( i=start, jp = stree->u.info.vlist+start ; 
; 993  :                      i < (int)stree->u.info.size ; i++,e++,jp++ )

	fstp	ST(0)
	inc	eax
	add	edx, 8
	mov	DWORD PTR _n$[ebp], eax
	mov	DWORD PTR tv546[ebp], edx
	cmp	eax, DWORD PTR [ecx+8]
	jl	SHORT $LL38@do_tree_so

; 983  : 
; 984  :      for ( n = stree->lo, e = stree->u.info.mat ; n < stree->hi ; n++ )

	mov	ebx, DWORD PTR tv569[ebp]
	mov	edx, DWORD PTR _S$[ebp]
$LN17@do_tree_so:

; 976  :   int spot;
; 977  :   int n;
; 978  :   REAL *e;
; 979  : 
; 980  :   /* solve U^T Y = B */
; 981  :   for ( spot = S->streemax; spot >= 1 ; spot-- )  /* metis starts at stree[1] */

	sub	ebx, 32					; 00000020H
	dec	DWORD PTR tv249[ebp]
	mov	DWORD PTR tv569[ebp], ebx
	jne	$LL18@do_tree_so
$LN16@do_tree_so:

; 995  :      }
; 996  : 
; 997  :   }
; 998  : 
; 999  :   /* solve U BB = Y */
; 1000 :   for ( spot = 1 ; spot <= S->streemax ; spot++ )

	mov	eax, 1
	mov	DWORD PTR _spot$[ebp], eax
	cmp	DWORD PTR [edx+80], eax
	jl	$LN7@do_tree_so
	mov	DWORD PTR tv985[ebp], 32		; 00000020H
	npad	2
$LL39@do_tree_so:
	mov	ebx, DWORD PTR [edx+76]
	add	ebx, DWORD PTR tv985[ebp]

; 1002 :      for ( n = stree->hi-1 ; n >= stree->lo ; n-- )

	mov	ecx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+4]
	dec	ecx
	mov	DWORD PTR _stree$[ebp], ebx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	ecx, eax
	jl	$LN8@do_tree_so

; 1001 :   { stree = S->stree + spot;

	lea	edx, DWORD PTR [esi+ecx*8]
	mov	DWORD PTR tv965[ebp], edx

; 1002 :      for ( n = stree->hi-1 ; n >= stree->lo ; n-- )

	mov	edx, DWORD PTR _Y$[ebp]
	sub	edx, esi
	mov	DWORD PTR tv975[ebp], edx
	jmp	SHORT $LN6@do_tree_so
	npad	5
$LL36@do_tree_so:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR tv975[ebp]
$LN6@do_tree_so:

; 1003 :      { int row,i,*jp;
; 1004 :         REAL y = Y[n];

	mov	edi, DWORD PTR tv965[ebp]
	fld	QWORD PTR [edx+edi]

; 1005 :         REAL *estart;
; 1006 :         row = n - stree->lo;
; 1007 :         estart = stree->u.info.mat + row*stree->u.info.size
; 1008 :           - ((row*(row-1))/2) - row;

	mov	edi, DWORD PTR [ebx+16]
	sub	ecx, eax
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	cdq
	sub	eax, edx
	lea	edx, DWORD PTR [edi-1]
	imul	edx, ecx
	sar	eax, 1
	sub	edx, eax
	mov	eax, DWORD PTR [ebx+24]
	lea	edx, DWORD PTR [eax+edx*8]

; 1009 :         for ( i=row+1, jp=stree->u.info.vlist+i  ; 
; 1010 :             i < (int)stree->u.info.size ; i++,jp++ )

	mov	eax, DWORD PTR [ebx+20]
	inc	ecx
	mov	DWORD PTR _estart$92525[ebp], edx
	lea	eax, DWORD PTR [eax+ecx*4]
	cmp	ecx, edi
	jge	SHORT $LN33@do_tree_so
	mov	edx, edi
	sub	edx, ecx
	cmp	edx, 4
	jl	SHORT $LN37@do_tree_so

; 1011 :               y -= estart[i]*BB[*jp];

	mov	edx, DWORD PTR _estart$92525[ebp]
	sub	edi, ecx
	sub	edi, 4
	shr	edi, 2
	inc	edi
	lea	edx, DWORD PTR [edx+ecx*8+16]
	lea	ecx, DWORD PTR [ecx+edi*4]
$LN35@do_tree_so:
	mov	ebx, DWORD PTR [eax]
	fld	QWORD PTR [esi+ebx*8]
	mov	ebx, DWORD PTR [eax+4]
	fmul	QWORD PTR [edx-16]
	add	eax, 16					; 00000010H
	add	edx, 32					; 00000020H
	dec	edi
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [esi+ebx*8]
	mov	ebx, DWORD PTR [eax-8]
	fmul	QWORD PTR [edx-40]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [esi+ebx*8]
	mov	ebx, DWORD PTR [eax-4]
	fmul	QWORD PTR [edx-32]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [esi+ebx*8]
	fmul	QWORD PTR [edx-24]
	fsubp	ST(1), ST(0)
	jne	SHORT $LN35@do_tree_so
	mov	ebx, DWORD PTR _stree$[ebp]
$LN37@do_tree_so:

; 1009 :         for ( i=row+1, jp=stree->u.info.vlist+i  ; 
; 1010 :             i < (int)stree->u.info.size ; i++,jp++ )

	cmp	ecx, DWORD PTR [ebx+16]
	jge	SHORT $LN33@do_tree_so
$LC3@do_tree_so:

; 1011 :               y -= estart[i]*BB[*jp];

	mov	edi, DWORD PTR _estart$92525[ebp]
	mov	edx, DWORD PTR [eax]
	fld	QWORD PTR [edi+ecx*8]
	fmul	QWORD PTR [esi+edx*8]
	inc	ecx
	add	eax, 4
	fsubp	ST(1), ST(0)
	cmp	ecx, DWORD PTR [ebx+16]
	jl	SHORT $LC3@do_tree_so
$LN33@do_tree_so:

; 1012 :         BB[n] = y;

	mov	eax, DWORD PTR tv965[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	fstp	QWORD PTR [eax]
	sub	eax, 8
	dec	ecx
	mov	DWORD PTR tv965[ebp], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR _n$[ebp], ecx
	cmp	ecx, eax
	jge	$LL36@do_tree_so

; 1002 :      for ( n = stree->hi-1 ; n >= stree->lo ; n-- )

	mov	edx, DWORD PTR _S$[ebp]
$LN8@do_tree_so:

; 995  :      }
; 996  : 
; 997  :   }
; 998  : 
; 999  :   /* solve U BB = Y */
; 1000 :   for ( spot = 1 ; spot <= S->streemax ; spot++ )

	mov	eax, DWORD PTR _spot$[ebp]
	add	DWORD PTR tv985[ebp], 32		; 00000020H
	inc	eax
	mov	DWORD PTR _spot$[ebp], eax
	cmp	eax, DWORD PTR [edx+80]
	jle	$LL39@do_tree_so
$LN7@do_tree_so:
	pop	edi
	pop	esi
	pop	ebx

; 1013 :       }
; 1014 :   }
; 1015 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_do_tree_solve ENDP
_TEXT	ENDS
PUBLIC	_tree_solve
; Function compile flags: /Ogtp
;	COMDAT _tree_solve
_TEXT	SEGMENT
_S$ = 8							; size = 4
_B$ = 12						; size = 4
_x$ = 16						; size = 4
_tree_solve PROC					; COMDAT

; 1031 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 1032 :   int n; /* row index */
; 1033 :   REAL *BB,*Y;
; 1034 : 
; 1035 : 
; 1036 :   BB = (REAL*)temp_calloc(S->N,sizeof(REAL));  /* intermediate solutions */

	mov	esi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [esi+4]
	push	edi
	push	1036					; 0000040cH
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc

; 1037 :   Y = (REAL*)temp_calloc(S->N,sizeof(REAL));  /* intermediate solutions */

	mov	ecx, DWORD PTR [esi+4]
	push	1037					; 0000040dH
	push	OFFSET ??_C@_07MMLFAKMN@METIS?4C?$AA@
	push	8
	push	ecx
	mov	edi, eax
	call	_kb_temp_calloc
	mov	ebx, eax

; 1038 : 
; 1039 :   for ( n = 0 ; n < S->N ; n++ ) BB[n] = B[S->P[n]]; /* permute */

	xor	eax, eax
	add	esp, 32					; 00000020H
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN4@tree_solve
	mov	ecx, DWORD PTR _B$[ebp]
$LL6@tree_solve:
	mov	edx, DWORD PTR [esi+68]
	mov	edx, DWORD PTR [edx+eax*4]
	fld	QWORD PTR [ecx+edx*8]
	inc	eax
	fstp	QWORD PTR [edi+eax*8-8]
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL6@tree_solve
$LN4@tree_solve:

; 1040 : 
; 1041 :   /* NOT set up for parallel */
; 1042 :   do_tree_solve(S,BB,Y);

	push	ebx
	push	edi
	push	esi
	call	_do_tree_solve

; 1043 : 
; 1044 :   /* unpermute */
; 1045 :   for ( n = 0 ; n < S->N ; n++ )

	xor	eax, eax
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN1@tree_solve
	mov	ecx, DWORD PTR _x$[ebp]
	npad	4
$LL3@tree_solve:

; 1046 :      x[S->P[n]] = BB[n];

	mov	edx, DWORD PTR [esi+68]
	fld	QWORD PTR [edi+eax*8]
	mov	edx, DWORD PTR [edx+eax*4]
	inc	eax
	fstp	QWORD PTR [ecx+edx*8]
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL3@tree_solve
$LN1@tree_solve:

; 1047 : 
; 1048 :   temp_free((char*)Y);

	push	ebx
	call	_temp_free

; 1049 :   temp_free((char*)BB);

	push	edi
	call	_temp_free
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1050 : }

	pop	ebp
	ret	0
_tree_solve ENDP
_TEXT	ENDS
PUBLIC	_tree_solve_multi
; Function compile flags: /Ogtp
;	COMDAT _tree_solve_multi
_TEXT	SEGMENT
_S$ = 8							; size = 4
_B$ = 12						; size = 4
_x$ = 16						; size = 4
_rk$ = 20						; size = 4
_tree_solve_multi PROC					; COMDAT

; 1067 : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 1068 :   int k;
; 1069 :   for ( k = 0 ; k < rk ; k++ )

	mov	ebx, DWORD PTR _rk$[ebp]
	test	ebx, ebx
	jle	SHORT $LN1@tree_solve@2
	push	esi
	mov	esi, DWORD PTR _B$[ebp]
	push	edi
	mov	edi, DWORD PTR _x$[ebp]
	sub	edi, esi
$LL3@tree_solve@2:

; 1070 :      tree_solve(S,B[k],x[k]);

	mov	eax, DWORD PTR [edi+esi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _S$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_tree_solve
	add	esp, 12					; 0000000cH
	add	esi, 4
	dec	ebx
	jne	SHORT $LL3@tree_solve@2
	pop	edi
	pop	esi
$LN1@tree_solve@2:
	pop	ebx

; 1071 : }

	pop	ebp
	ret	0
_tree_solve_multi ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@LDNHFAKC@Dense?5block?5?$CFd?5to?5?$CFd?6?$AA@ ; `string'
PUBLIC	_tree_analyze
EXTRN	_printf:PROC
;	COMDAT ??_C@_0BG@LDNHFAKC@Dense?5block?5?$CFd?5to?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BG@LDNHFAKC@Dense?5block?5?$CFd?5to?5?$CFd?6?$AA@ DB 'Dense block '
	DB	'%d to %d', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _tree_analyze
_TEXT	SEGMENT
tv204 = -4						; size = 4
_S$ = 8							; size = 4
_tree_analyze PROC					; COMDAT

; 1081 : { int k; /* end of block */

	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi

; 1082 :   int n; /* member of block */
; 1083 : 
; 1084 :   /* get things lined up in S->pIA and S->pJA so we can analyze */
; 1085 :   if ( S->pIA == NULL )

	mov	edi, DWORD PTR _S$[ebp]
	cmp	DWORD PTR [edi+96], 0
	jne	SHORT $LN8@tree_analy

; 1086 :     sparse_permute(S);

	push	edi
	call	_sparse_permute
	add	esp, 4
$LN8@tree_analy:

; 1087 : 
; 1088 :   /* start at end, looking for dense blocks */
; 1089 :   for ( k = S->N - 1 ; k >= 0  ;  )

	mov	ecx, DWORD PTR [edi+4]
	dec	ecx
	js	SHORT $LN6@tree_analy
	push	ebx
	push	esi
	jmp	SHORT $LN7@tree_analy
$LL19@tree_analy:
	mov	edi, DWORD PTR _S$[ebp]
$LN7@tree_analy:

; 1090 :   { for ( n = k-1 ; n >= 0 ; n-- )

	lea	esi, DWORD PTR [ecx-1]
	test	esi, esi
	js	SHORT $LN17@tree_analy
	mov	edi, DWORD PTR [edi+96]
	mov	eax, ecx
	sub	eax, esi
	mov	DWORD PTR tv204[ebp], edi
	lea	edx, DWORD PTR [edi+esi*4+4]
	jmp	SHORT $LN5@tree_analy
	npad	5
$LL16@tree_analy:
	mov	edi, DWORD PTR tv204[ebp]
$LN5@tree_analy:

; 1091 :     { if ( S->pIA[n+1]-S->pIA[n] < k-n || S->pJA[S->pIA[n]+(k-n)] != k ) 

	mov	ebx, DWORD PTR [edx]
	sub	ebx, DWORD PTR [edi+esi*4]
	cmp	ebx, eax
	jl	SHORT $LN17@tree_analy
	mov	edi, DWORD PTR _S$[ebp]
	mov	ebx, DWORD PTR [edi+96]
	mov	ebx, DWORD PTR [ebx+esi*4]
	mov	edi, DWORD PTR [edi+100]
	sub	ebx, esi
	add	ebx, ecx
	cmp	DWORD PTR [edi+ebx*4], ecx
	jne	SHORT $LN17@tree_analy

; 1090 :   { for ( n = k-1 ; n >= 0 ; n-- )

	inc	eax
	sub	edx, 4
	dec	esi
	jns	SHORT $LL16@tree_analy
$LN17@tree_analy:

; 1092 :         break;
; 1093 :     }
; 1094 :     printf("Dense block %d to %d\n",n+1,k);

	push	ecx
	lea	eax, DWORD PTR [esi+1]
	push	eax
	push	OFFSET ??_C@_0BG@LDNHFAKC@Dense?5block?5?$CFd?5to?5?$CFd?6?$AA@
	call	_printf
	add	esp, 12					; 0000000cH

; 1095 :     k = n;

	mov	ecx, esi
	test	esi, esi
	jns	SHORT $LL19@tree_analy
	pop	esi
	pop	ebx
$LN6@tree_analy:
	pop	edi

; 1096 :   }
; 1097 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_tree_analyze ENDP
_TEXT	ENDS
END
