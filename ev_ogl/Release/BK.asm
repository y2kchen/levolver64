; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\BK.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	__real@0000000000000000
PUBLIC	_get_body_pressure
EXTRN	_web:BYTE
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_body_pressure
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_pressure PROC					; COMDAT

; 317  :     { return  ( valid_id(b_id) ?    bptr(b_id)->pressure : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_p
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+312]
	pop	ebp
	ret	0
$LN3@get_body_p:
	fldz
	pop	ebp
	ret	0
_get_body_pressure ENDP
_TEXT	ENDS
PUBLIC	_set_body_pressure
; Function compile flags: /Ogtp
;	COMDAT _set_body_pressure
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_set_body_pressure PROC					; COMDAT

; 326  :       {         ( valid_id(b_id) ?  bptr(b_id)->pressure = (v) : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@set_body_p
	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [edx+312]
$LN3@set_body_p:
	pop	ebp
	ret	0
_set_body_pressure ENDP
_TEXT	ENDS
PUBLIC	_free_system
EXTRN	_mkl_free:PROC
EXTRN	_ysmp_flag:DWORD
EXTRN	_blas_flag:DWORD
EXTRN	_free_matrix:PROC
EXTRN	_temp_free:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\bk.c
;	COMDAT _free_system
_TEXT	SEGMENT
_S$ = 8							; size = 4
_free_system PROC					; COMDAT

; 127  : { 

	push	ebp
	mov	ebp, esp
	push	esi

; 128  :   if ( S->IA ) temp_free((char*)S->IA);

	mov	esi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN35@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN35@free_syste:

; 129  :   if ( S->JA && !(S->flags & S_JA_INCLUDED) ) temp_free((char*)S->JA);

	mov	eax, DWORD PTR [esi+56]
	test	eax, eax
	je	SHORT $LN34@free_syste
	test	BYTE PTR [esi], 32			; 00000020H
	jne	SHORT $LN34@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN34@free_syste:

; 130  :   if ( S->A ) temp_free((char*)S->A);

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN33@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN33@free_syste:

; 131  :   if ( S->pIA ) temp_free((char*)S->pIA);

	mov	eax, DWORD PTR [esi+96]
	test	eax, eax
	je	SHORT $LN32@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN32@free_syste:

; 132  :   if ( S->pJA ) temp_free((char*)S->pJA);

	mov	eax, DWORD PTR [esi+100]
	test	eax, eax
	je	SHORT $LN31@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN31@free_syste:

; 133  :   if ( S->pA ) temp_free((char*)S->pA);

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	je	SHORT $LN30@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN30@free_syste:

; 134  :   if ( S->P ) temp_free((char*)S->P);

	mov	eax, DWORD PTR [esi+68]
	test	eax, eax
	je	SHORT $LN29@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN29@free_syste:

; 135  :   if ( S->IP ) temp_free((char*)S->IP);

	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $LN28@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN28@free_syste:

; 136  :   if ( S->ISP ) temp_free((char*)S->ISP);

	mov	eax, DWORD PTR [esi+92]
	test	eax, eax
	je	SHORT $LN27@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN27@free_syste:

; 137  :   if ( S->psize ) temp_free((char*)S->psize);

	mov	eax, DWORD PTR [esi+120]
	test	eax, eax
	je	SHORT $LN26@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN26@free_syste:

; 138  :   if ( S->LIA ) temp_free((char*)S->LIA);

	mov	eax, DWORD PTR [esi+128]
	test	eax, eax
	je	SHORT $LN25@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN25@free_syste:

; 139  :   if ( S->LJA ) temp_free((char*)S->LJA);

	mov	eax, DWORD PTR [esi+132]
	test	eax, eax
	je	SHORT $LN24@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN24@free_syste:

; 140  :   if ( S->LIJA ) temp_free((char*)S->LIJA);

	mov	eax, DWORD PTR [esi+136]
	test	eax, eax
	je	SHORT $LN23@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN23@free_syste:

; 141  :   if ( S->LA ) temp_free((char*)S->LA);

	mov	eax, DWORD PTR [esi+140]
	test	eax, eax
	je	SHORT $LN22@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN22@free_syste:

; 142  :   if ( S->CIA ) temp_free((char*)S->CIA);

	mov	eax, DWORD PTR [esi+172]
	test	eax, eax
	je	SHORT $LN21@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN21@free_syste:

; 143  :   if ( S->CJA ) temp_free((char*)S->CJA);

	mov	eax, DWORD PTR [esi+176]
	test	eax, eax
	je	SHORT $LN20@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN20@free_syste:

; 144  :   if ( S->CA ) temp_free((char*)S->CA);

	mov	eax, DWORD PTR [esi+180]
	test	eax, eax
	je	SHORT $LN19@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN19@free_syste:

; 145  :   if ( S->coninx ) temp_free((char*)S->coninx);

	mov	eax, DWORD PTR [esi+152]
	test	eax, eax
	je	SHORT $LN18@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN18@free_syste:

; 146  :   if ( S->coninxinv ) temp_free((char*)S->coninxinv);

	mov	eax, DWORD PTR [esi+156]
	test	eax, eax
	je	SHORT $LN17@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN17@free_syste:

; 147  :   if ( S->rowmag ) temp_free((char*)S->rowmag);

	mov	eax, DWORD PTR [esi+204]
	test	eax, eax
	je	SHORT $LN16@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN16@free_syste:

; 148  :   if ( S->apinv ) temp_free((char*)S->apinv);

	mov	eax, DWORD PTR [esi+200]
	test	eax, eax
	je	SHORT $LN15@free_syste
	push	eax
	call	_temp_free
	add	esp, 4
$LN15@free_syste:

; 149  :   if ( S->HinvC ) free_matrix(S->HinvC);

	mov	eax, DWORD PTR [esi+164]
	test	eax, eax
	je	SHORT $LN14@free_syste
	push	eax
	call	_free_matrix
	add	esp, 4
$LN14@free_syste:

; 150  :   if ( S->CHinvCinv ) 

	mov	eax, DWORD PTR [esi+168]
	test	eax, eax
	je	SHORT $LN11@free_syste

; 151  :   { if ( blas_flag )

	cmp	DWORD PTR _blas_flag, 0
	je	SHORT $LN12@free_syste

; 152  :     { temp_free((char*)S->CHinvCinv[0]); temp_free((char*)S->CHinvCinv); }

	mov	eax, DWORD PTR [eax]
	push	eax
	call	_temp_free
	mov	ecx, DWORD PTR [esi+168]
	push	ecx
	call	_temp_free
	add	esp, 8
	jmp	SHORT $LN11@free_syste
$LN12@free_syste:

; 153  :     else free_matrix(S->CHinvCinv);

	push	eax
	call	_free_matrix
	add	esp, 4
$LN11@free_syste:

; 154  :   }
; 155  :   if ( S->C ) { temp_free((char *)S->C[0]); temp_free((char*)S->C);}

	mov	eax, DWORD PTR [esi+160]
	test	eax, eax
	je	SHORT $LN10@free_syste
	mov	edx, DWORD PTR [eax]
	push	edx
	call	_temp_free
	mov	eax, DWORD PTR [esi+160]
	push	eax
	call	_temp_free
	add	esp, 8
$LN10@free_syste:

; 156  :   if ( S->stree )

	cmp	DWORD PTR [esi+76], 0
	je	SHORT $LN6@free_syste

; 157  :   { int k;
; 158  :     for (  k = 0 ; k <= S->streemax ; k++ )

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+80], ebx
	jl	SHORT $LN40@free_syste
	push	edi
	xor	edi, edi
$LL8@free_syste:

; 159  :     { if ( S->stree[k].u.info.mat) 

	mov	ecx, DWORD PTR [esi+76]
	mov	eax, DWORD PTR [edi+ecx+24]
	test	eax, eax
	je	SHORT $LN7@free_syste

; 160  :       { temp_free((char*)S->stree[k].u.info.mat);

	push	eax
	call	_temp_free

; 161  :         temp_free((char*)S->stree[k].u.info.vlist);

	mov	edx, DWORD PTR [esi+76]
	mov	eax, DWORD PTR [edi+edx+20]
	push	eax
	call	_temp_free
	add	esp, 8
$LN7@free_syste:

; 157  :   { int k;
; 158  :     for (  k = 0 ; k <= S->streemax ; k++ )

	inc	ebx
	add	edi, 32					; 00000020H
	cmp	ebx, DWORD PTR [esi+80]
	jle	SHORT $LL8@free_syste
	pop	edi
$LN40@free_syste:
	pop	ebx
$LN6@free_syste:

; 162  :       }
; 163  :     }
; 164  :   }
; 165  : 
; 166  :   if ( S->low_rank_vectors ) free_matrix(S->low_rank_vectors);

	mov	eax, DWORD PTR [esi+216]
	test	eax, eax
	je	SHORT $LN4@free_syste
	push	eax
	call	_free_matrix
	add	esp, 4
$LN4@free_syste:

; 167  :   if ( S->low_rank_form ) free_matrix(S->low_rank_form);

	mov	eax, DWORD PTR [esi+220]
	test	eax, eax
	je	SHORT $LN3@free_syste
	push	eax
	call	_free_matrix
	add	esp, 4
$LN3@free_syste:

; 168  :   if ( S->low_rank_inverse_form ) free_matrix(S->low_rank_inverse_form);

	mov	eax, DWORD PTR [esi+224]
	test	eax, eax
	je	SHORT $LN2@free_syste
	push	eax
	call	_free_matrix
	add	esp, 4
$LN2@free_syste:

; 169  : 
; 170  :   if ( ysmp_flag == MKL_FACTORING )

	cmp	DWORD PTR _ysmp_flag, 3
	jne	SHORT $LN1@free_syste

; 171  :     mkl_free(S);

	push	esi
	call	_mkl_free
	add	esp, 4
$LN1@free_syste:

; 172  : 
; 173  :   memset((char*)S,0,sizeof(struct linsys));

	push	232					; 000000e8H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	pop	esi

; 174  : } /* end free_system() */

	pop	ebp
	ret	0
_free_system ENDP
_TEXT	ENDS
PUBLIC	_xcomp
; Function compile flags: /Ogtp
;	COMDAT _xcomp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_xcomp	PROC						; COMDAT

; 192  : { if ( a->x < b->x ) return -1;

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	fld	QWORD PTR [edx+8]
	fcomp	QWORD PTR [ecx+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN6@xcomp
	or	eax, -1

; 198  :   return 0;
; 199  : } /* end xcomp() */

	pop	ebp
	ret	0
$LN6@xcomp:

; 193  :   if ( a->x > b->x ) return  1;

	fld	QWORD PTR [edx+8]
	fcomp	QWORD PTR [ecx+8]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN5@xcomp
	mov	eax, 1

; 198  :   return 0;
; 199  : } /* end xcomp() */

	pop	ebp
	ret	0
$LN5@xcomp:

; 194  :   if ( a->ord < b->ord ) return -1;

	mov	eax, DWORD PTR [ecx+16]
	push	esi
	mov	esi, DWORD PTR [edx+16]
	cmp	eax, esi
	jl	SHORT $LN11@xcomp

; 195  :   if ( a->ord > b->ord ) return  1;

	jle	SHORT $LN3@xcomp
	mov	eax, 1
	pop	esi

; 198  :   return 0;
; 199  : } /* end xcomp() */

	pop	ebp
	ret	0
$LN3@xcomp:

; 196  :   if ( a->deg < b->deg ) return -1;

	mov	ecx, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR [edx+20]
	cmp	ecx, edx
	jge	SHORT $LN2@xcomp
$LN11@xcomp:
	or	eax, -1
	pop	esi

; 198  :   return 0;
; 199  : } /* end xcomp() */

	pop	ebp
	ret	0
$LN2@xcomp:

; 197  :   if ( a->deg > b->deg ) return  1;

	xor	eax, eax
	cmp	ecx, edx
	setg	al
	pop	esi

; 198  :   return 0;
; 199  : } /* end xcomp() */

	pop	ebp
	ret	0
_xcomp	ENDP
_TEXT	ENDS
PUBLIC	??_C@_04LOHMKLNL@BK?4C?$AA@			; `string'
PUBLIC	_find_ordering
EXTRN	_qsort:PROC
EXTRN	_dymem:DWORD
EXTRN	_kb_temp_calloc:PROC
;	COMDAT ??_C@_04LOHMKLNL@BK?4C?$AA@
CONST	SEGMENT
??_C@_04LOHMKLNL@BK?4C?$AA@ DB 'BK.C', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _find_ordering
_TEXT	SEGMENT
tv232 = -8						; size = 4
_xlist$ = -4						; size = 4
_verlist$ = 8						; size = 4
_n$ = 12						; size = 4
_P$ = 16						; size = 4
_find_ordering PROC					; COMDAT

; 206  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 207  :   int i,j;
; 208  :   struct xsorting *xlist,*Bptr;
; 209  :   vertex_id v_id;
; 210  : 
; 211  :   /* sort vertices in x order */
; 212  :   xlist = (struct xsorting *)temp_calloc(n,sizeof(struct xsorting));

	mov	ebx, DWORD PTR _n$[ebp]
	push	esi
	push	edi
	push	212					; 000000d4H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	24					; 00000018H
	push	ebx
	call	_kb_temp_calloc
	mov	edi, eax
	add	esp, 16					; 00000010H

; 213  :   for ( i = 0, Bptr = xlist ; i < n ; i++,Bptr++ ) Bptr->inx = i;

	xor	eax, eax
	mov	DWORD PTR _xlist$[ebp], edi
	mov	ecx, edi
	test	ebx, ebx
	jle	SHORT $LN12@find_order
	npad	2
$LL14@find_order:
	mov	DWORD PTR [ecx], eax
	inc	eax
	add	ecx, 24					; 00000018H
	cmp	eax, ebx
	jl	SHORT $LL14@find_order
$LN12@find_order:

; 214  :   FOR_ALL_VERTICES(v_id)

	mov	esi, DWORD PTR _web+48
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	je	$LN9@find_order
	mov	edi, DWORD PTR _web+12
$LL11@find_order:
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv232[ebp], esi
	je	SHORT $LN10@find_order

; 215  :   { struct hess_verlist *v;      /* current  vertex */
; 216  :     v = verlist + loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN17@find_order
	mov	eax, esi
	jmp	SHORT $LN18@find_order
$LN17@find_order:
	or	eax, -1
$LN18@find_order:

; 217  :     Bptr = xlist + v->rownum;

	mov	edx, DWORD PTR _xlist$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR _verlist$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [edx+ecx*8+20]

; 218  :     for ( j = 0 ; j < v->freedom ; j++, Bptr++ )

	xor	edx, edx
	cmp	DWORD PTR [eax+8], edx
	jle	SHORT $LN10@find_order
$LL29@find_order:

; 219  :     {
; 220  :       Bptr->ord = loc_ordinal(v->v_id);

	mov	esi, DWORD PTR [eax]
	test	esi, 268435456				; 10000000H
	je	SHORT $LN19@find_order
	and	esi, 134217727				; 07ffffffH
	jmp	SHORT $LN20@find_order
$LN19@find_order:
	or	esi, -1
$LN20@find_order:
	mov	DWORD PTR [ecx-4], esi

; 221  :       Bptr->deg = j;

	mov	DWORD PTR [ecx], edx

; 222  :       Bptr->x = get_coord(v->v_id)[0];

	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR _web+12
	mov	ebx, DWORD PTR _dymem
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR _web+104
	mov	edi, DWORD PTR [edi+ebx+64]
	fld	QWORD PTR [esi+edi]
	inc	edx
	fstp	QWORD PTR [ecx-12]
	add	ecx, 24					; 00000018H
	cmp	edx, DWORD PTR [eax+8]
	jl	SHORT $LL29@find_order

; 218  :     for ( j = 0 ; j < v->freedom ; j++, Bptr++ )

	mov	edi, DWORD PTR _web+12
	mov	ebx, DWORD PTR _n$[ebp]
	mov	esi, DWORD PTR tv232[ebp]
$LN10@find_order:

; 214  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [edi+esi*4]
	mov	esi, DWORD PTR [eax]
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LL11@find_order
	mov	edi, DWORD PTR _xlist$[ebp]
$LN9@find_order:

; 223  :     }
; 224  :   }
; 225  :   qsort((char*)xlist,n,sizeof(struct xsorting),FCAST xcomp);

	push	OFFSET _xcomp
	push	24					; 00000018H
	push	ebx
	push	edi
	call	_qsort
	add	esp, 16					; 00000010H

; 226  :   for ( i = 0 ; i < n ; i++ ) 

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN1@find_order

; 223  :     }
; 224  :   }
; 225  :   qsort((char*)xlist,n,sizeof(struct xsorting),FCAST xcomp);

	mov	edx, DWORD PTR _P$[ebp]
	mov	ecx, edi
	npad	7
$LL3@find_order:

; 227  :   { P[i] = xlist[i].inx + A_OFF;

	mov	esi, DWORD PTR [ecx]
	inc	esi
	mov	DWORD PTR [edx+eax*4], esi
	inc	eax
	add	ecx, 24					; 00000018H
	cmp	eax, ebx
	jl	SHORT $LL3@find_order
$LN1@find_order:

; 228  :   }
; 229  :   temp_free((char*)xlist);

	push	edi
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 230  : } /* end find_ordering() */

	mov	esp, ebp
	pop	ebp
	ret	0
_find_ordering ENDP
_TEXT	ENDS
PUBLIC	_bk_AIJ_setup
; Function compile flags: /Ogtp
;	COMDAT _bk_AIJ_setup
_TEXT	SEGMENT
_N$ = 8							; size = 4
_S$ = 12						; size = 4
_bk_AIJ_setup PROC					; COMDAT

; 245  : 
; 246  : #ifdef OLDHASH
; 247  :   int i,j,n;
; 248  :   int  total = 0;
; 249  :   struct hess_entry *e;
; 250  :   int spot;
; 251  :   int *ptr,*cptr,*dptr;
; 252  :   int isize,dsize;
; 253  : 
; 254  :   PROF_START(hessian_AIJ_setup);
; 255  : 
; 256  :   S->flags &= ~ S_ODRV_REORDERED; 
; 257  :   S->flags |= S_JA_INCLUDED;  /* S->JA not separately allocated */.
; 258  :   if ( augmented_hessian_mode )
; 259  :     N = total_rows;
; 260  :   S->N = N;
; 261  : 
; 262  :   for ( i = 0 ; i < N ; i++ ) total += array[i].count;
; 263  : 
; 264  :   /* incoming list of hess_entry structs is compacted in place */
; 265  :   isize = sizeof(int);
; 266  :   dsize = sizeof(REAL);
; 267  :   /* delete row numbers */
; 268  :   e = hashtable;
; 269  :   ptr = (int*)e;  
; 270  :   if ( 2*isize == dsize )
; 271  :    for ( n = 0; n < total; n++,e++,ptr+=3 )
; 272  :    { ptr[0] = ((int*)e)[0];
; 273  :      ptr[1] = ((int*)e)[1];
; 274  :      ptr[2] = e->col;
; 275  :    }
; 276  :   else if ( isize == dsize )
; 277  :    for ( n = 0; n < total; n++,e++,ptr+=2 )
; 278  :    { ptr[0] = ((int*)e)[0];
; 279  :      ptr[1] = e->col;
; 280  :    }
; 281  :   else if ( 4*isize == dsize )
; 282  :    for ( n = 0; n < total; n++,e++,ptr+=5 )
; 283  :    { ptr[0] = ((int*)e)[0];
; 284  :      ptr[1] = ((int*)e)[1];
; 285  :      ptr[2] = ((int*)e)[2];
; 286  :      ptr[3] = ((int*)e)[3];
; 287  :      ptr[4] = e->col;
; 288  :    }
; 289  :   else  /* i.e. 10-byte long double */
; 290  :   { char *p = (char*)ptr;
; 291  :     for ( n = 0; n < total; n++,e++,p+=dsize+isize )
; 292  :      { *(REAL *)p = e->value;
; 293  :        *(int *)(p+dsize)  = e->col;
; 294  :      }
; 295  :     ptr = (int *)p;
; 296  :   }
; 297  :   /* now extract cols to room at the end */
; 298  :   S->JA = cptr = ptr;
; 299  :   S->A = (REAL*)(hashtable);
; 300  :   hashtable = NULL;
; 301  :   ptr = (int*)(S->A);
; 302  :   dptr = ptr;
; 303  :   if ( 2*isize == dsize )
; 304  :    for ( n = 0 ; n < total; n++,dptr+=3,ptr+=2,cptr++)
; 305  :      { ptr[0] = dptr[0];
; 306  :        ptr[1] = dptr[1];
; 307  :        *cptr =  dptr[2]+A_OFF;
; 308  :      }
; 309  :   else if ( isize == dsize )
; 310  :      for ( n = 0 ; n < total; n++,dptr+=2,ptr+=1,cptr++)
; 311  :      { ptr[0] = dptr[0];
; 312  :        *cptr =  dptr[1]+A_OFF;
; 313  :      }
; 314  :   else if ( 4*isize == dsize )
; 315  :      for ( n = 0 ; n < total; n++,dptr+=5,ptr+=4,cptr++)
; 316  :      { ptr[0] = dptr[0];
; 317  :        ptr[1] = dptr[1];
; 318  :        ptr[2] = dptr[2];
; 319  :        ptr[3] = dptr[3];
; 320  :        *cptr =  dptr[4]+A_OFF;
; 321  :      }
; 322  :   else
; 323  :   { char *p = (char *)ptr;
; 324  :     REAL *d = (REAL *)ptr;
; 325  :     for ( n = 0 ; n < total; n++,p+=isize+dsize,d++,cptr++ )
; 326  :     { *d = *(REAL*)p;
; 327  :       *cptr = *(int*)(p+dsize)+A_OFF; 
; 328  :     }
; 329  :   }
; 330  : 
; 331  :   /* allocate other bits */
; 332  :   S->IA = (int *)temp_calloc(N+1,sizeof(int));
; 333  :   if ( S->P == NULL ) S->P = (int *)temp_calloc(N,sizeof(int));
; 334  :   if ( S->IP == NULL ) S->IP = (int *)temp_calloc(N,sizeof(int));
; 335  :   S->flags &= ~ S_ODRV_REORDERED; 
; 336  : 
; 337  :   for ( i = 0, spot = 0 ; i < N ; i++ )
; 338  :   { S->IA[i] = spot + A_OFF;
; 339  :     spot +=  harray[i].count; 
; 340  :   }
; 341  :   S->IA[N] = spot + A_OFF;
; 342  : 
; 343  :   /* test for NaN's */
; 344  :   for ( i = 0 ; i < S->IA[S->N]-A_OFF ; i++ )
; 345  :   if ( !is_finite(S->A[i]) )
; 346  :   { kb_error(1822,"NaNs in Hessian. Replacing with big value.\n",WARNING);
; 347  :     S->A[i] = 1e30; 
; 348  :   }
; 349  : 
; 350  :   PROF_FINISH(hessian_AIJ_setup);
; 351  : #endif
; 352  : } /* end bk_AIJ_setup() */

	ret	0
_bk_AIJ_setup ENDP
_TEXT	ENDS
PUBLIC	??_C@_04NLBFMIPC@C?$CFd?3?$AA@			; `string'
PUBLIC	??_C@_06KOAMMFPH@?$CF9?46f?5?$AA@		; `string'
PUBLIC	??_C@_0O@CLBBBIKE@Constraints?3?6?$AA@		; `string'
PUBLIC	??_C@_0BI@BCMBPOBF@With?5low?9rank?5update?3?5?6?$AA@ ; `string'
PUBLIC	??_C@_06FNCNKGB@?5?$CF9?46f?$AA@		; `string'
PUBLIC	??_C@_0L@CCBFPMDD@?5?5?5?5?5?5?5?5?5?5?$AA@	; `string'
PUBLIC	??_C@_03DCCPMNLC@q?$CFd?$AA@			; `string'
PUBLIC	??_C@_03HAIDDFMD@b?$CFd?$AA@			; `string'
PUBLIC	??_C@_04FIBCPIPH@?$CF10s?$AA@			; `string'
PUBLIC	??_C@_06HLMCDJKP@v?$CFs?4?$CFd?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_05GCDFEGGO@?6JA?3?5?$AA@			; `string'
PUBLIC	??_C@_03EBJOKFHF@?5?$CFd?$AA@			; `string'
PUBLIC	??_C@_04PDOOEJGG@IA?3?5?$AA@			; `string'
PUBLIC	??_C@_07DCIPCGNI@N?5?$DN?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0DM@OPAKPLJM@Fixed?5quantity?5?$CFs?5is?5not?5connect@ ; `string'
PUBLIC	??_C@_0DI@IFKKLDIP@Fixed?5body?5?$CFs?5is?5not?5connected?5t@ ; `string'
PUBLIC	??_C@_0DK@BCCPIJCI@Internal?5error?3?5hessian?5setup?5sk@ ; `string'
PUBLIC	??_C@_0DG@POGHCDNE@Internal?5error?3?5hessian?5setup?5sk@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_0DA@HPIKCON@Internal?5error?3?5S?9?$DOA?5got?5bigger?5@ ; `string'
PUBLIC	??_C@_0DA@FLECGOPC@Internal?5error?3?5S?9?$DON?5got?5bigger?5@ ; `string'
PUBLIC	??_C@_0DF@GAHABIOI@Degrees?5of?5freedom?0?5?$CFd?0?5fewer?5th@ ; `string'
PUBLIC	_bk_constraint_setup
EXTRN	_everything_quantities_flag:DWORD
EXTRN	_localbase:DWORD
EXTRN	_optparam:BYTE
EXTRN	_msg:DWORD
EXTRN	_vhead_attr:DWORD
EXTRN	_printf:PROC
EXTRN	_hess_debug:DWORD
EXTRN	_gen_quant_list:DWORD
EXTRN	_elnames:BYTE
EXTRN	_vhead:DWORD
EXTRN	_optparamcount:DWORD
EXTRN	_sparse_constraints_flag:DWORD
EXTRN	_augmented_hessian_mode:DWORD
EXTRN	_kb_error:PROC
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
;	COMDAT ??_C@_04NLBFMIPC@C?$CFd?3?$AA@
CONST	SEGMENT
??_C@_04NLBFMIPC@C?$CFd?3?$AA@ DB 'C%d:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KOAMMFPH@?$CF9?46f?5?$AA@
CONST	SEGMENT
??_C@_06KOAMMFPH@?$CF9?46f?5?$AA@ DB '%9.6f ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CLBBBIKE@Constraints?3?6?$AA@
CONST	SEGMENT
??_C@_0O@CLBBBIKE@Constraints?3?6?$AA@ DB 'Constraints:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BCMBPOBF@With?5low?9rank?5update?3?5?6?$AA@
CONST	SEGMENT
??_C@_0BI@BCMBPOBF@With?5low?9rank?5update?3?5?6?$AA@ DB 'With low-rank u'
	DB	'pdate: ', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06FNCNKGB@?5?$CF9?46f?$AA@
CONST	SEGMENT
??_C@_06FNCNKGB@?5?$CF9?46f?$AA@ DB ' %9.6f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CCBFPMDD@?5?5?5?5?5?5?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_0L@CCBFPMDD@?5?5?5?5?5?5?5?5?5?5?$AA@ DB '          ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DCCPMNLC@q?$CFd?$AA@
CONST	SEGMENT
??_C@_03DCCPMNLC@q?$CFd?$AA@ DB 'q%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03HAIDDFMD@b?$CFd?$AA@
CONST	SEGMENT
??_C@_03HAIDDFMD@b?$CFd?$AA@ DB 'b%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FIBCPIPH@?$CF10s?$AA@
CONST	SEGMENT
??_C@_04FIBCPIPH@?$CF10s?$AA@ DB '%10s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HLMCDJKP@v?$CFs?4?$CFd?$AA@
CONST	SEGMENT
??_C@_06HLMCDJKP@v?$CFs?4?$CFd?$AA@ DB 'v%s.%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GCDFEGGO@?6JA?3?5?$AA@
CONST	SEGMENT
??_C@_05GCDFEGGO@?6JA?3?5?$AA@ DB 0aH, 'JA: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03EBJOKFHF@?5?$CFd?$AA@
CONST	SEGMENT
??_C@_03EBJOKFHF@?5?$CFd?$AA@ DB ' %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PDOOEJGG@IA?3?5?$AA@
CONST	SEGMENT
??_C@_04PDOOEJGG@IA?3?5?$AA@ DB 'IA: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCIPCGNI@N?5?$DN?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_07DCIPCGNI@N?5?$DN?5?$CFd?6?$AA@ DB 'N = %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@OPAKPLJM@Fixed?5quantity?5?$CFs?5is?5not?5connect@
CONST	SEGMENT
??_C@_0DM@OPAKPLJM@Fixed?5quantity?5?$CFs?5is?5not?5connect@ DB 'Fixed qu'
	DB	'antity %s is not connected to any mobile vertices.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@IFKKLDIP@Fixed?5body?5?$CFs?5is?5not?5connected?5t@
CONST	SEGMENT
??_C@_0DI@IFKKLDIP@Fixed?5body?5?$CFs?5is?5not?5connected?5t@ DB 'Fixed b'
	DB	'ody %s is not connected to any mobile vertices.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@BCCPIJCI@Internal?5error?3?5hessian?5setup?5sk@
CONST	SEGMENT
??_C@_0DK@BCCPIJCI@Internal?5error?3?5hessian?5setup?5sk@ DB 'Internal er'
	DB	'ror: hessian setup skipped fixed quantity %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@POGHCDNE@Internal?5error?3?5hessian?5setup?5sk@
CONST	SEGMENT
??_C@_0DG@POGHCDNE@Internal?5error?3?5hessian?5setup?5sk@ DB 'Internal er'
	DB	'ror: hessian setup skipped fixed body %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HPIKCON@Internal?5error?3?5S?9?$DOA?5got?5bigger?5@
CONST	SEGMENT
??_C@_0DA@HPIKCON@Internal?5error?3?5S?9?$DOA?5got?5bigger?5@ DB 'Interna'
	DB	'l error: S->A got bigger than expected.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FLECGOPC@Internal?5error?3?5S?9?$DON?5got?5bigger?5@
CONST	SEGMENT
??_C@_0DA@FLECGOPC@Internal?5error?3?5S?9?$DON?5got?5bigger?5@ DB 'Intern'
	DB	'al error: S->N got bigger than expected.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GAHABIOI@Degrees?5of?5freedom?0?5?$CFd?0?5fewer?5th@
CONST	SEGMENT
??_C@_0DF@GAHABIOI@Degrees?5of?5freedom?0?5?$CFd?0?5fewer?5th@ DB 'Degree'
	DB	's of freedom, %d, fewer than constraints, %d.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _bk_constraint_setup
_TEXT	SEGMENT
tv1765 = -16						; size = 4
_m$89429 = -12						; size = 4
_ii$89430 = -8						; size = 4
tv1637 = -4						; size = 4
_k$89428 = -4						; size = 4
_kk$89276 = -4						; size = 4
_concount$ = 8						; size = 4
tv1639 = 12						; size = 4
tv1391 = 12						; size = 4
_m$89411 = 12						; size = 4
_newj$89334 = 12					; size = 4
_i$ = 12						; size = 4
_S$ = 12						; size = 4
_bk_constraint_setup PROC				; COMDAT

; 367  : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 368  :  
; 369  :   PROF_START(hessian_constraint_setup);
; 370  : 
; 371  :   if ( S->CN == 0 ) 

	mov	esi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [esi+148]
	push	edi
	test	eax, eax
	jne	SHORT $LN141@bk_constra

; 372  :   { S->N = S->A_rows; goto debug_print; }

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+4], eax
	jmp	$debug_print$89258
$LN141@bk_constra:

; 373  : 
; 374  :   if ( S->A_rows < S->CN )

	mov	ecx, DWORD PTR [esi+12]
	cmp	ecx, eax
	jge	SHORT $LN140@bk_constra

; 375  :   { sprintf(errmsg,"Degrees of freedom, %d, fewer than constraints, %d.\n",
; 376  :        S->A_rows,S->CN);

	push	eax
	push	ecx
	push	OFFSET ??_C@_0DF@GAHABIOI@Degrees?5of?5freedom?0?5?$CFd?0?5fewer?5th@
	push	OFFSET _errmsg
	call	_sprintf

; 377  :     kb_error(3382,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3382					; 00000d36H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN140@bk_constra:

; 378  :   }
; 379  :   if ( augmented_hessian_mode )

	cmp	DWORD PTR _augmented_hessian_mode, 0
	je	$LN139@bk_constra

; 380  :   { /* Keeping constraints in sparse augmented hessian. */
; 381  :     /* So not much to do, except eliminate unused constraints,  */
; 382  :     /* building constraint conversion index in the process,   */
; 383  :     /* and make sure zero elements exist on diagonal for constraints. */
; 384  : 
; 385  :     if ( S->A_rows + S->CN > S->maxN )

	mov	ecx, DWORD PTR [esi+148]
	add	ecx, DWORD PTR [esi+12]
	cmp	ecx, DWORD PTR [esi+8]
	jle	SHORT $LN138@bk_constra

; 386  :       kb_error(2549,"Internal error: S->N got bigger than expected.\n",
; 387  :         RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DA@FLECGOPC@Internal?5error?3?5S?9?$DON?5got?5bigger?5@
	push	2549					; 000009f5H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN138@bk_constra:

; 388  :     S->N = S->A_rows + S->CN;

	mov	eax, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+148]

; 389  : 
; 390  :     /* convert entries in S->JA */
; 391  :     for ( i = 0 ; i < S->IA[S->A_rows]-A_OFF ; i++ )

	mov	ecx, DWORD PTR [esi+52]
	add	edx, eax
	mov	DWORD PTR [esi+4], edx
	mov	eax, DWORD PTR [ecx+eax*4]
	dec	eax
	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN135@bk_constra
$LL137@bk_constra:
	mov	ecx, DWORD PTR [esi+56]

; 392  :       if ( S->JA[i]-A_OFF >= S->A_rows )

	mov	edi, DWORD PTR [ecx+edx*4]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [esi+12]
	dec	edi
	cmp	edi, ecx
	jl	SHORT $LN136@bk_constra

; 393  :         S->JA[i] = S->A_rows + S->coninx[S->JA[i]-A_OFF-S->A_rows] + A_OFF;

	mov	edi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [esi+152]
	sub	edi, ecx
	mov	edi, DWORD PTR [ebx+edi*4-4]
	lea	ecx, DWORD PTR [edi+ecx+1]
	mov	DWORD PTR [eax], ecx
$LN136@bk_constra:

; 389  : 
; 390  :     /* convert entries in S->JA */
; 391  :     for ( i = 0 ; i < S->IA[S->A_rows]-A_OFF ; i++ )

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [ecx+eax*4]
	inc	edx
	dec	eax
	cmp	edx, eax
	jl	SHORT $LL137@bk_constra
$LN135@bk_constra:

; 394  : 
; 395  :     /* create diagonal for constraints */
; 396  :     for ( i = 1 ; i <= S->CN ; i++ )

	mov	eax, 1
	cmp	DWORD PTR [esi+148], eax
	jl	SHORT $LN131@bk_constra
$LL133@bk_constra:

; 397  :     { S->IA[i+S->A_rows] = S->IA[i+S->A_rows-1] + 1;

	mov	ecx, DWORD PTR [esi+12]

; 398  :       S->JA[S->IA[i+S->A_rows-1]-A_OFF] = i + S->A_rows - 1 + A_OFF;
; 399  :       S->A[S->IA[i+S->A_rows-1]-A_OFF] = 0.0;

	fldz
	mov	edx, DWORD PTR [esi+52]
	add	ecx, eax
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ecx-4]
	inc	edx
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+52]
	mov	edi, DWORD PTR [esi+56]
	add	ecx, eax
	mov	edx, DWORD PTR [edx+ecx*4-4]
	mov	DWORD PTR [edi+edx*4-4], ecx
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+52]
	add	ecx, eax
	mov	ecx, DWORD PTR [edx+ecx*4-4]
	mov	edx, DWORD PTR [esi+60]
	inc	eax
	fstp	QWORD PTR [edx+ecx*8-8]
	cmp	eax, DWORD PTR [esi+148]
	jle	SHORT $LL133@bk_constra
$LN131@bk_constra:

; 400  :     }
; 401  : 
; 402  :     if ( S->IA[S->N] > S->maxA )

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+eax*4]
	cmp	edx, DWORD PTR [esi+64]
	jle	$debug_print$89258

; 403  :       kb_error(2598,"Internal error: S->A got bigger than expected.\n",
; 404  :              RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DA@HPIKCON@Internal?5error?3?5S?9?$DOA?5got?5bigger?5@
	push	2598					; 00000a26H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 405  :   }
; 406  :   else if ( sparse_constraints_flag )

	jmp	$debug_print$89258
$LN139@bk_constra:
	cmp	DWORD PTR _sparse_constraints_flag, 0
	je	$LN128@bk_constra

; 407  :   { 
; 408  :     /* Have to strip constraint gradients from A and put in CA */
; 409  :     int k,kk;
; 410  : 
; 411  :     /* First, count entries for each constraint */
; 412  :     S->CIA = (int *)temp_calloc(concount+1,sizeof(int));

	mov	ebx, DWORD PTR _concount$[ebp]
	push	412					; 0000019cH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	lea	eax, DWORD PTR [ebx+1]
	push	4
	push	eax
	call	_kb_temp_calloc

; 413  :     for ( i = S->A_rows ; i > 0 ; i-- )

	mov	edi, DWORD PTR [esi+12]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+172], eax
	test	edi, edi
	jle	SHORT $LN125@bk_constra
	npad	6
$LL127@bk_constra:
	mov	ecx, DWORD PTR [esi+52]

; 414  :     { for ( j = S->IA[i]-A_OFF - 1 ; j > S->IA[i-1]-A_OFF ; j-- )

	mov	eax, DWORD PTR [ecx+edi*4]
	mov	edx, DWORD PTR [ecx+edi*4-4]
	lea	ecx, DWORD PTR [ecx+edi*4]
	sub	eax, 2
	dec	edx
	cmp	eax, edx
	jle	SHORT $LN126@bk_constra
$LL124@bk_constra:
	mov	ecx, DWORD PTR [esi+56]

; 415  :         if ( S->JA[j]-A_OFF >= S->A_rows )

	mov	ebx, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [esi+12]
	lea	ecx, DWORD PTR [ecx+eax*4]
	dec	ebx
	cmp	ebx, edx
	jl	SHORT $LN234@bk_constra

; 416  :           S->CIA[S->JA[j]-A_OFF - S->A_rows]++;

	mov	ecx, DWORD PTR [ecx]
	sub	ecx, edx
	mov	edx, DWORD PTR [esi+172]
	inc	DWORD PTR [edx+ecx*4-4]
	lea	ecx, DWORD PTR [edx+ecx*4-4]
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+edi*4-4]
	dec	eax
	dec	edx
	cmp	eax, edx
	jg	SHORT $LL124@bk_constra
$LN234@bk_constra:

; 414  :     { for ( j = S->IA[i]-A_OFF - 1 ; j > S->IA[i-1]-A_OFF ; j-- )

	mov	ebx, DWORD PTR _concount$[ebp]
$LN126@bk_constra:

; 413  :     for ( i = S->A_rows ; i > 0 ; i-- )

	dec	edi
	test	edi, edi
	jg	SHORT $LL127@bk_constra
$LN125@bk_constra:

; 417  :         else break;
; 418  :     }
; 419  :     /* Running totals to S->CIA */
; 420  :     for ( i = 0, j = 0 ; i < concount ; i++ )

	xor	eax, eax
	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN117@bk_constra
	npad	11
$LL119@bk_constra:
	mov	ecx, DWORD PTR [esi+172]

; 421  :     { int tmp = S->CIA[i];

	mov	edx, DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]

; 422  :       S->CIA[i] = j;

	mov	DWORD PTR [ecx], edi
	inc	eax

; 423  :       j += tmp;

	add	edi, edx
	cmp	eax, ebx
	jl	SHORT $LL119@bk_constra
$LN117@bk_constra:

; 424  :     }
; 425  :     S->CJA = (int *)temp_calloc(j,sizeof(int));

	push	425					; 000001a9H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	4
	push	edi
	call	_kb_temp_calloc

; 426  :     S->CA  = (REAL*)temp_calloc(j,sizeof(REAL));

	push	426					; 000001aaH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	edi
	mov	DWORD PTR [esi+176], eax
	call	_kb_temp_calloc
	add	esp, 32					; 00000020H
	mov	DWORD PTR [esi+180], eax

; 427  :     for ( i = concount ; i > 0 ; i-- )

	mov	eax, ebx
	test	ebx, ebx
	jle	SHORT $LN238@bk_constra
	npad	2
$LL116@bk_constra:
	mov	edx, DWORD PTR [esi+172]
	lea	ecx, DWORD PTR [edx+eax*4]

; 428  :       S->CIA[i] = S->CIA[i-1];

	mov	edx, DWORD PTR [ecx-4]
	dec	eax
	mov	DWORD PTR [ecx], edx
	test	eax, eax
	jg	SHORT $LL116@bk_constra
$LN238@bk_constra:

; 429  :     /* place constraint gradients and compact A,JA */
; 430  :     for ( i = 1, kk = 0, j = 0 ; i <= S->A_rows ; i++ )

	mov	edx, 1
	xor	edi, edi
	xor	eax, eax
	mov	DWORD PTR _i$[ebp], edx
	mov	DWORD PTR _kk$89276[ebp], edi
	cmp	DWORD PTR [esi+12], edx
	jl	$LN239@bk_constra
	npad	5
$LL113@bk_constra:

; 431  :     { for ( ; j < S->IA[i]-A_OFF ; j++ )

	mov	ecx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [ecx+edx*4]
	dec	ecx
	cmp	eax, ecx
	jge	SHORT $LN108@bk_constra
	npad	5
$LL110@bk_constra:

; 432  :         if ( S->JA[j]-A_OFF >= S->A_rows )

	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	edi, DWORD PTR [esi+12]
	lea	ebx, DWORD PTR [edx-1]
	cmp	ebx, edi
	jl	SHORT $LN107@bk_constra

; 433  :         { k = S->CIA[S->JA[j]-A_OFF-S->A_rows+1]++;

	mov	ecx, DWORD PTR [esi+172]
	sub	edx, edi
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [edx]
	lea	edi, DWORD PTR [ecx+1]
	mov	DWORD PTR [edx], edi

; 434  :           S->CJA[k] = i-1;

	mov	edx, DWORD PTR _i$[ebp]
	mov	ebx, DWORD PTR [esi+176]
	lea	edi, DWORD PTR [edx-1]
	mov	DWORD PTR [ebx+ecx*4], edi

; 435  :           S->CA[k]  = S->A[j];

	mov	edi, DWORD PTR [esi+60]
	fld	QWORD PTR [edi+eax*8]
	mov	ebx, DWORD PTR [esi+180]

; 436  :         }
; 437  :         else 

	mov	edi, DWORD PTR _kk$89276[ebp]
	fstp	QWORD PTR [ebx+ecx*8]
	jmp	SHORT $LN109@bk_constra
$LN107@bk_constra:

; 438  :         { S->JA[kk] = S->JA[j];

	mov	edi, DWORD PTR _kk$89276[ebp]
	mov	DWORD PTR [ecx+edi*4], edx

; 439  :           S->A[kk]  = S->A[j];

	mov	ecx, DWORD PTR [esi+60]
	fld	QWORD PTR [ecx+eax*8]

; 440  :           kk++;

	mov	edx, DWORD PTR _i$[ebp]
	fstp	QWORD PTR [ecx+edi*8]
	inc	edi
	mov	DWORD PTR _kk$89276[ebp], edi
$LN109@bk_constra:

; 431  :     { for ( ; j < S->IA[i]-A_OFF ; j++ )

	mov	ecx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [ecx+edx*4]
	inc	eax
	dec	ecx
	cmp	eax, ecx
	jl	SHORT $LL110@bk_constra
$LN108@bk_constra:

; 441  :         }
; 442  :       S->IA[i] = kk+A_OFF;

	mov	ebx, DWORD PTR [esi+52]
	lea	ecx, DWORD PTR [edi+1]
	mov	DWORD PTR [ebx+edx*4], ecx
	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, DWORD PTR [esi+12]
	jle	$LL113@bk_constra
$LN239@bk_constra:

; 443  :     }
; 444  :     S->N = S->A_rows;    

	mov	edx, DWORD PTR [esi+12]

; 445  : 
; 446  :     /* check the constraints we thought were going to be used actually are */
; 447  :     for ( i = 0 ; i < S->concount ; i++ )

	xor	edi, edi
	mov	DWORD PTR [esi+4], edx
	cmp	DWORD PTR [esi+144], edi
	jle	$LN103@bk_constra
$LL105@bk_constra:
	mov	eax, DWORD PTR [esi+172]

; 448  :     { /* a check on if any fixed constraints are null */
; 449  :       if ( (S->CIA[i] != S->CIA[i+1]) && (S->coninx[i] == -1) )

	mov	ecx, DWORD PTR [eax+edi*4]
	cmp	ecx, DWORD PTR [eax+edi*4+4]
	lea	eax, DWORD PTR [eax+edi*4]
	je	$LN243@bk_constra
	mov	edx, DWORD PTR [esi+152]
	cmp	DWORD PTR [edx+edi*4], -1
	jne	$LN243@bk_constra

; 450  :       { struct hess_verlist *vh = vhead + web.skel[VERTEX].max_ord+1+
; 451  :                   optparamcount + i;

	mov	ecx, DWORD PTR _optparamcount
	add	ecx, DWORD PTR _web+68
	lea	eax, DWORD PTR [ecx+edi+1]
	shl	eax, 5
	add	eax, DWORD PTR _vhead

; 452  :         if ( valid_id(vh->v_id) )

	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN101@bk_constra

; 453  :           sprintf(errmsg,
; 454  :           "Internal error: hessian setup skipped fixed body %s.\n",
; 455  :                 ELNAME(vh->v_id));

	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	push	OFFSET _elnames
	push	OFFSET ??_C@_0DG@POGHCDNE@Internal?5error?3?5hessian?5setup?5sk@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 24					; 00000018H

; 456  :         else 

	jmp	SHORT $LN100@bk_constra
$LN101@bk_constra:

; 457  :           sprintf(errmsg,
; 458  :           "Internal error: hessian setup skipped fixed quantity %s.\n",
; 459  :                 GEN_QUANT(vh->v_id)->name);

	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list
	push	eax
	push	OFFSET ??_C@_0DK@BCCPIJCI@Internal?5error?3?5hessian?5setup?5sk@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN100@bk_constra:

; 460  :         kb_error(2552,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2552					; 000009f8H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN243@bk_constra:

; 461  :       }
; 462  :       if ( (S->CIA[i] == S->CIA[i+1]) && (S->coninx[i] != -1) )

	mov	edx, DWORD PTR [esi+172]
	mov	ecx, DWORD PTR [edx+edi*4]
	cmp	ecx, DWORD PTR [edx+edi*4+4]
	lea	eax, DWORD PTR [edx+edi*4]
	jne	$LN104@bk_constra
	mov	edx, DWORD PTR [esi+152]
	cmp	DWORD PTR [edx+edi*4], -1
	je	$LN104@bk_constra

; 463  :       { struct hess_verlist *vh = vhead + web.skel[VERTEX].max_ord+1+
; 464  :                   optparamcount + i;

	mov	ecx, DWORD PTR _optparamcount
	add	ecx, DWORD PTR _web+68
	lea	eax, DWORD PTR [ecx+edi+1]
	shl	eax, 5
	add	eax, DWORD PTR _vhead

; 465  :         if ( valid_id(vh->v_id) )

	mov	eax, DWORD PTR [eax]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN98@bk_constra

; 466  :           sprintf(errmsg,
; 467  :             "Fixed body %s is not connected to any mobile vertices.\n",
; 468  :                 ELNAME(vh->v_id));

	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	push	OFFSET _elnames
	push	OFFSET ??_C@_0DI@IFKKLDIP@Fixed?5body?5?$CFs?5is?5not?5connected?5t@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 24					; 00000018H

; 469  :         else 

	jmp	SHORT $LN97@bk_constra
$LN98@bk_constra:

; 470  :           sprintf(errmsg,
; 471  :             "Fixed quantity %s is not connected to any mobile vertices.\n",
; 472  :                 GEN_QUANT(vh->v_id)->name);

	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list
	push	eax
	push	OFFSET ??_C@_0DM@OPAKPLJM@Fixed?5quantity?5?$CFs?5is?5not?5connect@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN97@bk_constra:

; 473  :         kb_error(3362,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3362					; 00000d22H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN104@bk_constra:

; 445  : 
; 446  :     /* check the constraints we thought were going to be used actually are */
; 447  :     for ( i = 0 ; i < S->concount ; i++ )

	inc	edi
	cmp	edi, DWORD PTR [esi+144]
	jl	$LL105@bk_constra
$LN103@bk_constra:

; 474  :       }
; 475  :     }
; 476  :     /* Strip out empty constraints */
; 477  :     for ( i = 0 ; i < S->CN ; i++ )

	xor	eax, eax
	cmp	DWORD PTR [esi+148], eax
	jle	$debug_print$89258
$LL96@bk_constra:

; 478  :       S->CIA[i+1] = S->CIA[S->coninxinv[i]+1];

	mov	edx, DWORD PTR [esi+156]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [esi+172]
	mov	edx, DWORD PTR [ecx+edx*4+4]
	mov	DWORD PTR [ecx+eax*4+4], edx
	inc	eax
	cmp	eax, DWORD PTR [esi+148]
	jl	SHORT $LL96@bk_constra

; 479  :   }
; 480  :   else   /* dense constraints */

	jmp	$debug_print$89258
$LN128@bk_constra:

; 481  :   { int startj,newj;
; 482  :     S->C = (REAL**)temp_calloc(S->CN,sizeof(REAL*));

	mov	eax, DWORD PTR [esi+148]
	push	482					; 000001e2H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	4
	push	eax
	call	_kb_temp_calloc

; 483  :     S->C[0] = (REAL*)temp_calloc(S->CN*S->N,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+4]
	imul	ecx, DWORD PTR [esi+148]
	push	483					; 000001e3H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	ecx
	mov	DWORD PTR [esi+160], eax
	call	_kb_temp_calloc
	mov	edx, DWORD PTR [esi+160]
	mov	DWORD PTR [edx], eax

; 484  :     for ( i = 1 ; i < S->CN ; i++ ) S->C[i] = S->C[0] + i*S->N;

	mov	eax, 1
	add	esp, 32					; 00000020H
	cmp	DWORD PTR [esi+148], eax
	jle	SHORT $LN90@bk_constra
	npad	9
$LL92@bk_constra:
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+160]
	imul	edx, eax
	mov	edi, DWORD PTR [ecx]
	lea	edx, DWORD PTR [edi+edx*8]
	mov	DWORD PTR [ecx+eax*4], edx
	inc	eax
	cmp	eax, DWORD PTR [esi+148]
	jl	SHORT $LL92@bk_constra
$LN90@bk_constra:

; 485  :     for ( i = 0, startj = 0, newj = 0 ; i < S->N ; i++ )

	xor	eax, eax
	xor	edi, edi
	xor	edx, edx
	mov	DWORD PTR _newj$89334[ebp], edi
	cmp	DWORD PTR [esi+4], eax
	jle	$debug_print$89258
	npad	1
$LL89@bk_constra:

; 486  :     { /* fill in C  (really C transpose) */
; 487  :       /* and compact JA, A */
; 488  :       for ( j = startj ; j < S->IA[i+1]-A_OFF ; j++ )

	mov	ecx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [ecx+edx*4+4]
	dec	ecx
	cmp	eax, ecx
	jge	SHORT $LN232@bk_constra
	npad	4
$LL86@bk_constra:

; 489  :         if ( S->JA[j]-A_OFF >= S->A_rows )

	mov	ecx, DWORD PTR [esi+56]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	edi, DWORD PTR [esi+12]
	lea	ebx, DWORD PTR [ecx-1]
	cmp	ebx, edi
	jl	SHORT $LN83@bk_constra

; 490  :         { int row = S->coninx[S->JA[j]-A_OFF - S->A_rows];
; 491  :           S->C[row][i] = S->A[j];

	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+eax*8]
	sub	ecx, edi
	mov	edi, DWORD PTR [esi+152]
	mov	ecx, DWORD PTR [edi+ecx*4-4]
	mov	edi, DWORD PTR [esi+160]
	mov	ecx, DWORD PTR [edi+ecx*4]

; 492  :         }
; 493  :         else /* keep in A but move it down */

	mov	edi, DWORD PTR _newj$89334[ebp]
	fstp	QWORD PTR [ecx+edx*8]
	jmp	SHORT $LN85@bk_constra
$LN83@bk_constra:

; 494  :         { S->A[newj] = S->A[j];

	mov	ecx, DWORD PTR [esi+60]
	mov	edi, DWORD PTR _newj$89334[ebp]
	fld	QWORD PTR [ecx+eax*8]
	fstp	QWORD PTR [ecx+edi*8]

; 495  :           S->JA[newj] = S->JA[j];

	mov	ecx, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx+edi*4], ebx

; 496  :           newj++;

	inc	edi
	mov	DWORD PTR _newj$89334[ebp], edi
$LN85@bk_constra:

; 486  :     { /* fill in C  (really C transpose) */
; 487  :       /* and compact JA, A */
; 488  :       for ( j = startj ; j < S->IA[i+1]-A_OFF ; j++ )

	mov	ecx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [ecx+edx*4+4]
	inc	eax
	dec	ecx
	cmp	eax, ecx
	jl	SHORT $LL86@bk_constra
$LN232@bk_constra:

; 497  :         }
; 498  :       startj = S->IA[i+1] - A_OFF;  /* for next loop */

	mov	eax, DWORD PTR [esi+52]
	lea	ecx, DWORD PTR [eax+edx*4+4]
	mov	eax, DWORD PTR [ecx]

; 499  :       S->IA[i+1] = newj + A_OFF;

	lea	ebx, DWORD PTR [edi+1]
	inc	edx
	dec	eax
	mov	DWORD PTR [ecx], ebx
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LL89@bk_constra
$debug_print$89258:

; 500  :     }
; 501  :    
; 502  :   }
; 503  : 
; 504  : debug_print:
; 505  :   /* some debug printing */
; 506  :   if ( hess_debug )

	cmp	DWORD PTR _hess_debug, 0
	je	$LN18@bk_constra

; 507  :   { vertex_id v_id;
; 508  :   
; 509  :     printf("N = %d\n",S->N);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	push	OFFSET ??_C@_07DCIPCGNI@N?5?$DN?5?$CFd?6?$AA@
	call	_printf

; 510  :     printf("IA: ");

	push	OFFSET ??_C@_04PDOOEJGG@IA?3?5?$AA@
	call	_printf

; 511  :     for ( i = 0 ; i <= S->N ; i++ ) printf(" %d",S->IA[i]);

	xor	edi, edi
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+4], edi
	jl	SHORT $LN240@bk_constra
	npad	3
$LL80@bk_constra:
	mov	edx, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [edx+edi*4]
	push	eax
	push	OFFSET ??_C@_03EBJOKFHF@?5?$CFd?$AA@
	call	_printf
	inc	edi
	add	esp, 8
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LL80@bk_constra
$LN240@bk_constra:

; 512  :     printf("\nJA: ");

	push	OFFSET ??_C@_05GCDFEGGO@?6JA?3?5?$AA@
	call	_printf

; 513  :     for ( i = 0 ; i < S->IA[S->N]-A_OFF ; i++ ) printf(" %d",S->JA[i]);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [edx+ecx*4]
	dec	eax
	add	esp, 4
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN75@bk_constra
$LL77@bk_constra:
	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [ecx+edi*4]
	push	edx
	push	OFFSET ??_C@_03EBJOKFHF@?5?$CFd?$AA@
	call	_printf
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+eax*4]
	inc	edi
	dec	edx
	add	esp, 8
	cmp	edi, edx
	jl	SHORT $LL77@bk_constra
$LN75@bk_constra:

; 514  :     printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf

; 515  :     /* column labels */
; 516  :     MFOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	add	esp, 4
	and	ecx, 1
	mov	DWORD PTR tv1637[ebp], ecx
	je	$LN224@bk_constra
	mov	edx, DWORD PTR _web+12
$LL74@bk_constra:
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv1639[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	$LN73@bk_constra

; 517  :     { struct hess_verlist *vh = get_vertex_vhead(v_id);

	mov	eax, DWORD PTR _vhead_attr
	mov	edi, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104

; 518  :       for ( j = 0 ; j < vh->freedom ; j++ )

	xor	ebx, ebx
	mov	eax, DWORD PTR [eax+edi+64]
	mov	edi, DWORD PTR [ecx+eax]
	shl	edi, 5
	add	edi, DWORD PTR _vhead
	cmp	DWORD PTR [edi+8], ebx
	jle	SHORT $LN73@bk_constra
	npad	4
$LL69@bk_constra:

; 519  :       { sprintf(msg,"v%s.%d",ELNAME(v_id),j+1); 

	cmp	DWORD PTR tv1637[ebp], 0
	je	SHORT $LN148@bk_constra
	mov	ecx, DWORD PTR tv1639[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN149@bk_constra
$LN148@bk_constra:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN149@bk_constra:
	mov	edx, DWORD PTR _msg
	inc	ebx
	push	ebx
	push	eax
	push	OFFSET ??_C@_06HLMCDJKP@v?$CFs?4?$CFd?$AA@
	push	edx
	call	_sprintf

; 520  :         printf("%10s",msg);

	mov	eax, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_04FIBCPIPH@?$CF10s?$AA@
	call	_printf
	add	esp, 24					; 00000018H
	cmp	ebx, DWORD PTR [edi+8]
	jl	SHORT $LL69@bk_constra

; 518  :       for ( j = 0 ; j < vh->freedom ; j++ )

	mov	edx, DWORD PTR _web+12
$LN73@bk_constra:

; 515  :     /* column labels */
; 516  :     MFOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR tv1639[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR tv1637[ebp], ecx
	jne	$LL74@bk_constra
$LN224@bk_constra:

; 521  :       }
; 522  :     }
; 523  :     for ( i = 0 ; i < optparamcount ; i++ )

	xor	ebx, ebx
	cmp	DWORD PTR _optparamcount, ebx
	jle	$LN64@bk_constra
	mov	edi, OFFSET _optparam
	npad	9
$LL225@bk_constra:

; 524  :       printf("%10s",globals(optparam[i].pnum)->name);

	mov	eax, DWORD PTR [edi]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN150@bk_constra
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN152@bk_constra
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN151@bk_constra
$LN152@bk_constra:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN150@bk_constra
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN151@bk_constra
$LN150@bk_constra:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN151@bk_constra:
	push	eax
	push	OFFSET ??_C@_04FIBCPIPH@?$CF10s?$AA@
	call	_printf
	inc	ebx
	add	esp, 8
	add	edi, 56					; 00000038H
	cmp	ebx, DWORD PTR _optparamcount
	jl	SHORT $LL225@bk_constra
$LN64@bk_constra:

; 525  :     if ( augmented_hessian_mode )

	cmp	DWORD PTR _augmented_hessian_mode, 0
	je	$LN241@bk_constra

; 526  :     { if ( !everything_quantities_flag )
; 527  :       { for ( i = 0 ; i <= web.skel[BODY].max_ord ; i++ )

	xor	edi, edi
	cmp	DWORD PTR _everything_quantities_flag, edi
	jne	$LN62@bk_constra
	cmp	DWORD PTR _web+404, edi
	jl	SHORT $LN228@bk_constra
	npad	6
$LL61@bk_constra:

; 528  :           if ( S->coninx[i] >= 0 )

	mov	ecx, DWORD PTR [esi+152]
	cmp	DWORD PTR [ecx+edi*4], 0
	jl	SHORT $LN60@bk_constra

; 529  :           { sprintf(msg,"b%d",i+1); printf("%10s",msg); }

	mov	eax, DWORD PTR _msg
	lea	edx, DWORD PTR [edi+1]
	push	edx
	push	OFFSET ??_C@_03HAIDDFMD@b?$CFd?$AA@
	push	eax
	call	_sprintf
	mov	ecx, DWORD PTR _msg
	push	ecx
	push	OFFSET ??_C@_04FIBCPIPH@?$CF10s?$AA@
	call	_printf
	add	esp, 20					; 00000014H
$LN60@bk_constra:

; 526  :     { if ( !everything_quantities_flag )
; 527  :       { for ( i = 0 ; i <= web.skel[BODY].max_ord ; i++ )

	inc	edi
	cmp	edi, DWORD PTR _web+404
	jle	SHORT $LL61@bk_constra
$LN228@bk_constra:

; 530  :         for ( i = 0 ; i < gen_quant_count ; i++ )

	xor	edi, edi
	cmp	DWORD PTR _web+5528, edi
	jle	$LN241@bk_constra
	npad	5
$LL242@bk_constra:

; 531  :           if ( S->coninx[i + web.skel[BODY].max_ord+1] >= 0 )

	mov	edx, DWORD PTR _web+404
	mov	eax, DWORD PTR [esi+152]
	add	edx, edi
	cmp	DWORD PTR [eax+edx*4+4], 0
	jl	SHORT $LN56@bk_constra

; 532  :           { sprintf(msg,"q%d",i+1); printf("%10s",msg); }

	mov	edx, DWORD PTR _msg
	lea	ecx, DWORD PTR [edi+1]
	push	ecx
	push	OFFSET ??_C@_03DCCPMNLC@q?$CFd?$AA@
	push	edx
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_04FIBCPIPH@?$CF10s?$AA@
	call	_printf
	add	esp, 20					; 00000014H
$LN56@bk_constra:

; 530  :         for ( i = 0 ; i < gen_quant_count ; i++ )

	inc	edi
	cmp	edi, DWORD PTR _web+5528
	jl	SHORT $LL242@bk_constra

; 533  :        }
; 534  :        else /* just the quantities */

	jmp	SHORT $LN241@bk_constra
$LN62@bk_constra:

; 535  :        for ( i = 0 ; i < gen_quant_count ; i++ )

	cmp	DWORD PTR _web+5528, edi
	jle	SHORT $LN241@bk_constra
$LL52@bk_constra:

; 536  :           if ( S->coninx[i] >= 0 )

	mov	ecx, DWORD PTR [esi+152]
	cmp	DWORD PTR [ecx+edi*4], 0
	jl	SHORT $LN51@bk_constra

; 537  :           { sprintf(msg,"q%d",i+1); printf("%10s",msg); }

	mov	eax, DWORD PTR _msg
	lea	edx, DWORD PTR [edi+1]
	push	edx
	push	OFFSET ??_C@_03DCCPMNLC@q?$CFd?$AA@
	push	eax
	call	_sprintf
	mov	ecx, DWORD PTR _msg
	push	ecx
	push	OFFSET ??_C@_04FIBCPIPH@?$CF10s?$AA@
	call	_printf
	add	esp, 20					; 00000014H
$LN51@bk_constra:

; 535  :        for ( i = 0 ; i < gen_quant_count ; i++ )

	inc	edi
	cmp	edi, DWORD PTR _web+5528
	jl	SHORT $LL52@bk_constra
$LN241@bk_constra:

; 538  :     }
; 539  :     printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf

; 540  : 
; 541  :     /* now the body of the sparse part of the hessian, just upper triangle */
; 542  :     for ( i = 0 ; i < S->N ; i++ ) 

	xor	ebx, ebx
	add	esp, 4
	cmp	DWORD PTR [esi+4], ebx
	jle	$LN46@bk_constra
$LL235@bk_constra:

; 543  :       { int k,m;
; 544  :         for ( m = 0 ; m < i ; m++ ) printf("          ");

	test	ebx, ebx
	jle	SHORT $LN43@bk_constra
	mov	edi, ebx
	npad	5
$LL45@bk_constra:
	push	OFFSET ??_C@_0L@CCBFPMDD@?5?5?5?5?5?5?5?5?5?5?$AA@
	call	_printf
	add	esp, 4
	dec	edi
	jne	SHORT $LL45@bk_constra
$LN43@bk_constra:

; 545  :         for ( m = i,  k = S->IA[i]-A_OFF ; m < S->N ; m++ )

	mov	edx, DWORD PTR [esi+52]
	mov	edi, DWORD PTR [edx+ebx*4]
	mov	eax, ebx
	dec	edi
	mov	DWORD PTR _m$89411[ebp], eax
	cmp	ebx, DWORD PTR [esi+4]
	jge	SHORT $LN40@bk_constra
$LL42@bk_constra:

; 546  :           if ( (m == S->JA[k]-A_OFF) && (k < S->IA[i+1]-A_OFF) )

	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [ecx+edi*4]
	dec	edx
	cmp	eax, edx
	jne	SHORT $LN39@bk_constra
	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [eax+ebx*4+4]
	dec	ecx
	cmp	edi, ecx
	jge	SHORT $LN39@bk_constra

; 547  :             { printf(" %9.6f",(DOUBLE)S->A[k]); k++; }

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+edi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_06FNCNKGB@?5?$CF9?46f?$AA@
	call	_printf
	add	esp, 12					; 0000000cH
	inc	edi
	jmp	SHORT $LN41@bk_constra
$LN39@bk_constra:

; 548  :           else printf(" %9.6f",0.0);

	fldz
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_06FNCNKGB@?5?$CF9?46f?$AA@
	call	_printf
	add	esp, 12					; 0000000cH
$LN41@bk_constra:

; 545  :         for ( m = i,  k = S->IA[i]-A_OFF ; m < S->N ; m++ )

	mov	eax, DWORD PTR _m$89411[ebp]
	inc	eax
	mov	DWORD PTR _m$89411[ebp], eax
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL42@bk_constra
$LN40@bk_constra:

; 549  :         printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	inc	ebx
	add	esp, 4
	cmp	ebx, DWORD PTR [esi+4]
	jl	$LL235@bk_constra
$LN46@bk_constra:

; 550  :      }
; 551  : 
; 552  :     /* Add on low-rank update */
; 553  :     if ( S->low_rank )

	cmp	DWORD PTR [esi+208], 0
	je	$LN34@bk_constra

; 554  :     {
; 555  :       printf("With low-rank update: \n");

	push	OFFSET ??_C@_0BI@BCMBPOBF@With?5low?9rank?5update?3?5?6?$AA@
	call	_printf

; 556  :       for ( i = 0 ; i < S->N ; i++ ) 

	xor	ebx, ebx
	add	esp, 4
	mov	DWORD PTR _i$[ebp], ebx
	cmp	DWORD PTR [esi+4], ebx
	jle	$LN34@bk_constra
$LL36@bk_constra:

; 557  :       { int k,m,ii,jj;
; 558  :         for ( m = 0 ; m < i ; m++ ) printf("          ");

	test	ebx, ebx
	jle	SHORT $LN230@bk_constra
	mov	edi, ebx
	npad	6
$LL33@bk_constra:
	push	OFFSET ??_C@_0L@CCBFPMDD@?5?5?5?5?5?5?5?5?5?5?$AA@
	call	_printf
	add	esp, 4
	dec	edi
	jne	SHORT $LL33@bk_constra
$LN230@bk_constra:

; 559  :         for ( m = i,  k = S->IA[i]-A_OFF ; m < S->N ; m++ )

	mov	eax, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [eax+ebx*4]
	dec	eax
	mov	edi, ebx
	mov	DWORD PTR _m$89429[ebp], edi
	mov	DWORD PTR _k$89428[ebp], eax
	cmp	ebx, DWORD PTR [esi+4]
	jge	$LN28@bk_constra
	npad	8
$LL30@bk_constra:

; 560  :         { REAL val;
; 561  :           if ( (m == S->JA[k]-A_OFF) && (k < S->IA[i+1]-A_OFF) )

	mov	ecx, DWORD PTR [esi+56]
	mov	eax, DWORD PTR _k$89428[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	dec	edx
	cmp	edi, edx
	jne	SHORT $LN27@bk_constra
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+ebx*4+4]
	dec	edx
	cmp	eax, edx
	jge	SHORT $LN27@bk_constra

; 562  :           { val = S->A[k]; k++; }

	mov	ecx, DWORD PTR [esi+60]
	fld	QWORD PTR [ecx+eax*8]
	inc	eax
	mov	DWORD PTR _k$89428[ebp], eax
	jmp	SHORT $LN26@bk_constra
$LN27@bk_constra:

; 563  :           else val = 0.0;

	fldz
$LN26@bk_constra:

; 564  :           /* add low-rank stuff */
; 565  :           if ( m < S->low_rank_vecsize )

	cmp	edi, DWORD PTR [esi+212]
	jge	SHORT $LN22@bk_constra

; 566  :             for ( ii = 0 ; ii < S->low_rank ; ii++ )

	xor	eax, eax
	mov	DWORD PTR _ii$89430[ebp], eax
	cmp	DWORD PTR [esi+208], eax
	jle	SHORT $LN22@bk_constra
	mov	edx, DWORD PTR [esi+208]
$LN24@bk_constra:
	mov	ecx, DWORD PTR [esi+216]

; 556  :       for ( i = 0 ; i < S->N ; i++ ) 

	mov	edi, DWORD PTR [ecx+eax*4]
	lea	edi, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR tv1765[ebp], edi

; 567  :               for ( jj = 0 ; jj < S->low_rank ; jj++ )

	mov	edi, DWORD PTR [esi+220]
	mov	eax, DWORD PTR [edi+eax*4]
$LN227@bk_constra:

; 568  :                 val += S->low_rank_vectors[ii][i]*S->low_rank_form[ii][jj]*
; 569  :                          S->low_rank_vectors[jj][m];

	mov	edi, DWORD PTR tv1765[ebp]
	fld	QWORD PTR [edi]
	mov	ebx, DWORD PTR [ecx]
	fmul	QWORD PTR [eax]
	mov	edi, DWORD PTR _m$89429[ebp]
	add	eax, 8
	add	ecx, 4
	dec	edx
	fmul	QWORD PTR [ebx+edi*8]
	faddp	ST(1), ST(0)
	jne	SHORT $LN227@bk_constra

; 566  :             for ( ii = 0 ; ii < S->low_rank ; ii++ )

	mov	eax, DWORD PTR _ii$89430[ebp]
	mov	edx, DWORD PTR [esi+208]
	mov	ebx, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _ii$89430[ebp], eax
	cmp	eax, edx
	jl	SHORT $LN24@bk_constra
$LN22@bk_constra:

; 570  :           printf(" %9.6f",(DOUBLE)val);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_06FNCNKGB@?5?$CF9?46f?$AA@
	call	_printf
	inc	edi
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _m$89429[ebp], edi
	cmp	edi, DWORD PTR [esi+4]
	jl	$LL30@bk_constra
$LN28@bk_constra:

; 571  :         }
; 572  :         printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	inc	ebx
	add	esp, 4
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ebx, DWORD PTR [esi+4]
	jl	$LL36@bk_constra
$LN34@bk_constra:

; 573  :       }
; 574  :     } 
; 575  : 
; 576  :     if ( !augmented_hessian_mode )

	xor	ebx, ebx
	cmp	DWORD PTR _augmented_hessian_mode, ebx
	jne	$LN18@bk_constra

; 577  :     {
; 578  :       printf("Constraints:\n");

	push	OFFSET ??_C@_0O@CLBBBIKE@Constraints?3?6?$AA@
	call	_printf
	add	esp, 4

; 579  :       if ( sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, ebx
	je	$LN17@bk_constra

; 580  :       { for ( i = 0 ; i < S->CN ; i++ )

	mov	DWORD PTR _i$[ebp], ebx
	cmp	DWORD PTR [esi+148], ebx
	jle	$LN231@bk_constra
	npad	7
$LL16@bk_constra:
	mov	edx, DWORD PTR [esi+172]
	mov	eax, DWORD PTR _i$[ebp]

; 581  :         { int k = 0;
; 582  :           for ( j = S->CIA[i] ; j < S->CIA[i+1] ; j++ ) 

	mov	edi, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [edx+eax*4]
	xor	ebx, ebx
	cmp	edi, DWORD PTR [eax+4]
	jge	SHORT $LN11@bk_constra
$LL13@bk_constra:

; 583  :           { for ( ; k < S->CJA[j]-1 ; k++ ) printf("%9.6f ",0.0);

	mov	ecx, DWORD PTR [esi+176]
	mov	edx, DWORD PTR [ecx+edi*4]
	dec	edx
	cmp	ebx, edx
	jge	SHORT $LN8@bk_constra
$LL10@bk_constra:
	fldz
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_06KOAMMFPH@?$CF9?46f?5?$AA@
	call	_printf
	mov	eax, DWORD PTR [esi+176]
	mov	ecx, DWORD PTR [eax+edi*4]
	inc	ebx
	dec	ecx
	add	esp, 12					; 0000000cH
	cmp	ebx, ecx
	jl	SHORT $LL10@bk_constra
$LN8@bk_constra:

; 584  :             printf("%9.6f ",(DOUBLE)S->CA[j]); 

	mov	edx, DWORD PTR [esi+180]
	fld	QWORD PTR [edx+edi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_06KOAMMFPH@?$CF9?46f?5?$AA@
	call	_printf

; 585  :             k = S->CJA[j];

	mov	eax, DWORD PTR [esi+176]
	mov	ebx, DWORD PTR [eax+edi*4]
	mov	ecx, DWORD PTR [esi+172]
	mov	edx, DWORD PTR _i$[ebp]
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR [ecx+edx*4+4]
	jl	SHORT $LL13@bk_constra
$LN11@bk_constra:

; 586  :           }
; 587  :           printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [esi+148]
	jl	$LL16@bk_constra

; 596  :         }
; 597  :       }
; 598  :       printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 599  :     }
; 600  :    } /* end hess_debug */
; 601  : 
; 602  :   PROF_FINISH(hessian_constraint_setup);
; 603  : } /* end bk_constraint_setup */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@bk_constra:

; 588  :         }
; 589  :       }
; 590  :       else
; 591  :       { 
; 592  :         for ( i = 0 ; i < S->CN ; i++ )

	cmp	DWORD PTR [esi+148], ebx
	jle	SHORT $LN231@bk_constra
	npad	7
$LL6@bk_constra:

; 593  :         { printf("C%d:",i+1);

	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	OFFSET ??_C@_04NLBFMIPC@C?$CFd?3?$AA@
	mov	DWORD PTR tv1391[ebp], eax
	call	_printf

; 594  :           for ( j = 0 ; j < S->N ; j++ ) printf(" %9.6f",(double)(S->C[i][j]));

	xor	edi, edi
	add	esp, 8
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN1@bk_constra
	npad	5
$LL3@bk_constra:
	mov	eax, DWORD PTR [esi+160]
	mov	ecx, DWORD PTR [eax+ebx*4]
	fld	QWORD PTR [ecx+edi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_06FNCNKGB@?5?$CF9?46f?$AA@
	call	_printf
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL3@bk_constra
$LN1@bk_constra:

; 595  :             printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	mov	ebx, DWORD PTR tv1391[ebp]
	add	esp, 4
	cmp	ebx, DWORD PTR [esi+148]
	jl	SHORT $LL6@bk_constra
$LN231@bk_constra:

; 596  :         }
; 597  :       }
; 598  :       printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	add	esp, 4
$LN18@bk_constra:
	pop	edi
	pop	esi
	pop	ebx

; 599  :     }
; 600  :    } /* end hess_debug */
; 601  : 
; 602  :   PROF_FINISH(hessian_constraint_setup);
; 603  : } /* end bk_constraint_setup */

	mov	esp, ebp
	pop	ebp
	ret	0
_bk_constraint_setup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@FEPPCLLD@?$CF3d?4?5?5?5?5?$CF3?417g?5?5converged?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@CMJBFKAG@?$CF3d?4?5?5?5?5?$CF3?417g?5?5max?5iterations?6?$AA@ ; `string'
PUBLIC	__real@4024000000000000
PUBLIC	??_C@_08PCNGPKFM@?5?$CF18?415g?$AA@		; `string'
PUBLIC	??_C@_06PMGOCIHL@?$CF3d?4?5?5?$AA@		; `string'
PUBLIC	??_C@_0BH@BNPHLKFG@Enter?5max?5iterations?3?5?$AA@ ; `string'
PUBLIC	__real@46293e5939a08cea
PUBLIC	__real@3fe0000000000000
PUBLIC	_S$GSCopy$
PUBLIC	_x$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_cg_ritz
EXTRN	_last_eigenvalue:QWORD
EXTRN	_machine_eps:QWORD
EXTRN	_outstring:PROC
EXTRN	_jacobi_eigenpairs:PROC
EXTRN	_matcopy:PROC
EXTRN	_dot:PROC
EXTRN	_tr_mat_mul:PROC
EXTRN	_sp_mul_func:DWORD
EXTRN	_atoi:PROC
EXTRN	_prompt:PROC
EXTRN	_LQ_decomp:PROC
EXTRN	_vector_add_smul:PROC
EXTRN	_mat_mult:PROC
EXTRN	_drand48:PROC
EXTRN	_mat_inv:PROC
EXTRN	_mat_mul_tr:PROC
EXTRN	_kb_dmatrix:PROC
EXTRN	_Met:BYTE
EXTRN	_hessian_linear_metric_flag:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0BL@FEPPCLLD@?$CF3d?4?5?5?5?5?$CF3?417g?5?5converged?6?$AA@
CONST	SEGMENT
??_C@_0BL@FEPPCLLD@?$CF3d?4?5?5?5?5?$CF3?417g?5?5converged?6?$AA@ DB '%3d'
	DB	'.    %3.17g  converged', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CMJBFKAG@?$CF3d?4?5?5?5?5?$CF3?417g?5?5max?5iterations?6?$AA@
CONST	SEGMENT
??_C@_0CA@CMJBFKAG@?$CF3d?4?5?5?5?5?$CF3?417g?5?5max?5iterations?6?$AA@ DB '%'
	DB	'3d.    %3.17g  max iterations', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT ??_C@_08PCNGPKFM@?5?$CF18?415g?$AA@
CONST	SEGMENT
??_C@_08PCNGPKFM@?5?$CF18?415g?$AA@ DB ' %18.15g', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PMGOCIHL@?$CF3d?4?5?5?$AA@
CONST	SEGMENT
??_C@_06PMGOCIHL@?$CF3d?4?5?5?$AA@ DB '%3d.  ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BNPHLKFG@Enter?5max?5iterations?3?5?$AA@
CONST	SEGMENT
??_C@_0BH@BNPHLKFG@Enter?5max?5iterations?3?5?$AA@ DB 'Enter max iteratio'
	DB	'ns: ', 00H					; `string'
CONST	ENDS
;	COMDAT __real@46293e5939a08cea
CONST	SEGMENT
__real@46293e5939a08cea DQ 046293e5939a08cear	; 1e+030
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _cg_ritz
_TEXT	SEGMENT
_old_trxax$ = -244					; size = 8
_S$GSCopy$ = -236					; size = 4
_xh$ = -232						; size = 4
_work$ = -228						; size = 4
_hx$ = -224						; size = 4
_M$ = -220						; size = 4
_xah$ = -216						; size = 4
_Linv$ = -212						; size = 4
_Q$ = -208						; size = 4
_NN$ = -204						; size = 4
_L$ = -200						; size = 4
_Cf$ = -196						; size = 4
_mx$ = -192						; size = 4
_Gf$ = -188						; size = 4
tv1277 = -184						; size = 4
_hah$ = -184						; size = 4
_CCinv$ = -180						; size = 4
_mh$ = -176						; size = 4
_count$ = -172						; size = 4
tv4346 = -168						; size = 4
tv3321 = -168						; size = 4
tv3193 = -168						; size = 4
tv3102 = -168						; size = 4
_k$ = -168						; size = 4
tv1964 = -164						; size = 4
tv869 = -164						; size = 4
_evectors$ = -164					; size = 4
_f$ = -160						; size = 4
_B$ = -156						; size = 4
tv2047 = -152						; size = 4
_evalues$ = -152					; size = 4
_ah$ = -148						; size = 4
_x$GSCopy$ = -144					; size = 4
_h$ = -140						; size = 4
_denom$89874 = -136					; size = 8
tv3082 = -132						; size = 4
tv2299 = -132						; size = 4
tv531 = -132						; size = 4
_j$ = -132						; size = 4
tv2160 = -128						; size = 4
tv2091 = -128						; size = 4
_maxcount$ = -128					; size = 4
_trxax$ = -124						; size = 8
tv3737 = -120						; size = 4
tv3369 = -120						; size = 4
tv3306 = -120						; size = 4
tv3155 = -120						; size = 4
tv2547 = -120						; size = 4
tv2227 = -120						; size = 4
tv2191 = -120						; size = 4
tv2055 = -120						; size = 4
tv1973 = -120						; size = 4
tv874 = -120						; size = 4
_numer$89905 = -116					; size = 8
tv4319 = -112						; size = 4
tv3109 = -112						; size = 4
tv2511 = -112						; size = 4
tv2389 = -112						; size = 4
tv2314 = -112						; size = 4
tv1416 = -112						; size = 4
tv1181 = -112						; size = 4
tv1115 = -112						; size = 4
tv557 = -112						; size = 4
tv3281 = -108						; size = 4
tv3198 = -108						; size = 4
tv2457 = -108						; size = 4
tv2060 = -108						; size = 4
tv1968 = -108						; size = 4
tv1034 = -108						; size = 4
tv899 = -108						; size = 4
tv890 = -108						; size = 4
tv231 = -108						; size = 4
_response$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_n$ = 12						; size = 4
_x$ = 16						; size = 4
_ev$ = 20						; size = 4
_cg_ritz PROC						; COMDAT

; 1247 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1273 :   else M = NULL;

	mov	eax, DWORD PTR _x$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _S$[ebp]
	mov	DWORD PTR _x$GSCopy$[ebp], eax
	xor	eax, eax
	push	esi
	mov	esi, DWORD PTR _n$[ebp]

; 1325 :     maxcount = atoi(response);

	mov	DWORD PTR _S$GSCopy$[ebp], ebx
	mov	DWORD PTR _mx$[ebp], eax
	mov	DWORD PTR _mh$[ebp], eax
	mov	DWORD PTR _CCinv$[ebp], eax
	mov	DWORD PTR _Cf$[ebp], eax
	mov	DWORD PTR _Gf$[ebp], eax
	cmp	DWORD PTR _web+876, eax
	jne	SHORT $LN114@cg_ritz

; 1248 :   int i,j,k;
; 1249 :   REAL **h=NULL; /* search direction */
; 1250 :   REAL **ah=NULL; 
; 1251 :   REAL **f=NULL,**If=NULL; /* gradient of XAX, form and vector */
; 1252 :   REAL **mx=NULL; /* MX */
; 1253 :   REAL **mh=NULL; /* MH */
; 1254 :   REAL cgamma; /* cg coefficient */
; 1255 :   REAL **xax=NULL;
; 1256 :   REAL trxax,old_trxax; /* objective */
; 1257 :   int count;
; 1258 :   int maxcount;
; 1259 :   char response[100];
; 1260 :   REAL **CCinv=NULL;
; 1261 :   REAL **Cf=NULL,**Gf=NULL;
; 1262 :   struct linsys *M;  /* Hessian metric to use */
; 1263 :   REAL **L,**Linv; /* for LQ decomp */
; 1264 :   REAL **Q;
; 1265 :   REAL **hax,**xah,**hah;
; 1266 :   REAL **B;  /* 2n x 2n matrix to find low eigenvalues for */
; 1267 :   REAL **hx,**xh;
; 1268 :   REAL **evectors,*evalues;
; 1269 :   REAL **NN; /* temp */
; 1270 :   REAL *work;
; 1271 : 
; 1272 :   if ( web.area_norm_flag || hessian_linear_metric_flag ) M =  &Met;

	mov	DWORD PTR _M$[ebp], eax
	cmp	DWORD PTR _hessian_linear_metric_flag, eax
	je	SHORT $LN113@cg_ritz
$LN114@cg_ritz:
	mov	DWORD PTR _M$[ebp], OFFSET _Met
$LN113@cg_ritz:

; 1274 : 
; 1275 :   if ( n <= 0 ) return;

	cmp	esi, eax
	jle	$LN1@cg_ritz

; 1276 : 
; 1277 :   h = dmatrix(0,n-1,0,S->N);

	mov	ecx, DWORD PTR [ebx+4]
	push	edi
	push	1277					; 000004fdH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	ecx
	push	0
	lea	edi, DWORD PTR [esi-1]
	push	edi
	push	0
	call	_kb_dmatrix

; 1278 :   ah = dmatrix(0,n-1,0,S->N);

	mov	edx, DWORD PTR [ebx+4]
	push	1278					; 000004feH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	edx
	push	0
	push	edi
	push	0
	mov	DWORD PTR _h$[ebp], eax
	call	_kb_dmatrix

; 1279 :   f = dmatrix(0,n-1,0,S->N);

	push	1279					; 000004ffH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	mov	DWORD PTR _ah$[ebp], eax
	mov	eax, DWORD PTR [ebx+4]
	push	eax
	push	0
	push	edi
	push	0
	call	_kb_dmatrix

; 1280 :   Q = dmatrix(0,n-1,0,S->N);

	mov	ecx, DWORD PTR [ebx+4]
	add	esp, 72					; 00000048H
	push	1280					; 00000500H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	ecx
	push	0
	push	edi
	push	0
	mov	DWORD PTR _f$[ebp], eax
	call	_kb_dmatrix

; 1281 :   hx = dmatrix(0,2*n-1,0,S->N);

	mov	edx, DWORD PTR [ebx+4]
	push	1281					; 00000501H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	edx
	mov	DWORD PTR _Q$[ebp], eax
	lea	eax, DWORD PTR [esi+esi-1]
	push	0
	push	eax
	push	0
	mov	DWORD PTR tv1416[ebp], eax
	call	_kb_dmatrix

; 1282 :   xh = (REAL**)temp_calloc(2*n,sizeof(REAL*));

	push	1282					; 00000502H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	mov	DWORD PTR _hx$[ebp], eax
	lea	eax, DWORD PTR [esi+esi]
	push	4
	push	eax
	call	_kb_temp_calloc
	add	esp, 64					; 00000040H

; 1283 :   work = (REAL*)temp_calloc(2*n,sizeof(REAL));

	push	1283					; 00000503H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	mov	DWORD PTR _xh$[ebp], eax
	lea	eax, DWORD PTR [esi+esi]
	push	8
	push	eax
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _work$[ebp], eax

; 1284 :   for ( i = 0 ; i < n ; i++ ) { xh[i] = x[i]; xh[i+n] = Q[i]; }

	test	esi, esi
	jle	SHORT $LN109@cg_ritz

; 1276 : 
; 1277 :   h = dmatrix(0,n-1,0,S->N);

	mov	eax, DWORD PTR _xh$[ebp]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	DWORD PTR tv1964[ebp], ecx

; 1284 :   for ( i = 0 ; i < n ; i++ ) { xh[i] = x[i]; xh[i+n] = Q[i]; }

	mov	ecx, DWORD PTR _x$GSCopy$[ebp]
	sub	ecx, eax
	mov	DWORD PTR tv1968[ebp], ecx
	mov	ecx, DWORD PTR _Q$[ebp]
	sub	ecx, eax
	mov	DWORD PTR tv1973[ebp], ecx
	mov	DWORD PTR tv1277[ebp], esi
	jmp	SHORT $LN111@cg_ritz
$LL357@cg_ritz:

; 1276 : 
; 1277 :   h = dmatrix(0,n-1,0,S->N);

	mov	ecx, DWORD PTR tv1973[ebp]
$LN111@cg_ritz:

; 1284 :   for ( i = 0 ; i < n ; i++ ) { xh[i] = x[i]; xh[i+n] = Q[i]; }

	mov	edx, DWORD PTR tv1968[ebp]
	mov	edx, DWORD PTR [edx+eax]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR tv1964[ebp]
	mov	DWORD PTR [ecx], edx
	add	ecx, 4
	add	eax, 4
	dec	DWORD PTR tv1277[ebp]
	mov	DWORD PTR tv1964[ebp], ecx
	jne	SHORT $LL357@cg_ritz
$LN109@cg_ritz:

; 1285 :   NN = dmatrix(0,n-1,0,n-1);

	push	1285					; 00000505H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	edi
	push	0
	push	edi
	push	0
	call	_kb_dmatrix

; 1286 :   L = dmatrix(0,n-1,0,n-1);

	push	1286					; 00000506H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	edi
	push	0
	push	edi
	push	0
	mov	DWORD PTR _NN$[ebp], eax
	call	_kb_dmatrix

; 1287 :   Linv = dmatrix(0,n-1,0,n-1);

	push	1287					; 00000507H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	edi
	push	0
	push	edi
	push	0
	mov	DWORD PTR _L$[ebp], eax
	call	_kb_dmatrix
	add	esp, 72					; 00000048H

; 1288 :   B = dmatrix(0,2*n-1,0,2*n-1);

	push	1288					; 00000508H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	mov	DWORD PTR _Linv$[ebp], eax
	mov	eax, DWORD PTR tv1416[ebp]
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 1289 :   xax = B;
; 1290 :   hax = B+n;
; 1291 :   xah = (REAL**)temp_calloc(n,sizeof(REAL*));

	push	1291					; 0000050bH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	4
	push	esi
	mov	DWORD PTR _B$[ebp], eax
	call	_kb_temp_calloc

; 1292 :   hah = (REAL**)temp_calloc(n,sizeof(REAL*));

	push	1292					; 0000050cH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	4
	push	esi
	mov	DWORD PTR _xah$[ebp], eax
	call	_kb_temp_calloc
	add	esp, 56					; 00000038H
	mov	DWORD PTR _hah$[ebp], eax

; 1293 :   for ( j = 0 ; j < n ; j++ ) { xah[j] = B[j]+n; hah[j] = B[j+n]+n; }

	test	esi, esi
	jle	SHORT $LN106@cg_ritz

; 1285 :   NN = dmatrix(0,n-1,0,n-1);

	mov	eax, DWORD PTR _B$[ebp]
	mov	ecx, DWORD PTR _xah$[ebp]
	lea	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR tv2047[ebp], eax

; 1293 :   for ( j = 0 ; j < n ; j++ ) { xah[j] = B[j]+n; hah[j] = B[j+n]+n; }

	mov	eax, DWORD PTR _B$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv2055[ebp], eax
	mov	eax, DWORD PTR _hah$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv2060[ebp], eax
	mov	DWORD PTR tv869[ebp], esi
	npad	9
$LL354@cg_ritz:
	mov	edx, DWORD PTR tv2055[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	lea	eax, DWORD PTR [esi*8]
	add	edx, eax
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR tv2047[ebp]
	mov	edx, DWORD PTR [edx]
	add	DWORD PTR tv2047[ebp], 4
	add	edx, eax
	mov	eax, DWORD PTR tv2060[ebp]
	mov	DWORD PTR [ecx+eax], edx
	add	ecx, 4
	dec	DWORD PTR tv869[ebp]
	jne	SHORT $LL354@cg_ritz
$LN106@cg_ritz:

; 1294 :   evalues = (REAL *)temp_calloc(2*n,sizeof(REAL));

	push	1294					; 0000050eH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	lea	eax, DWORD PTR [esi+esi]
	push	8
	push	eax
	call	_kb_temp_calloc

; 1295 :   evectors = dmatrix(0,2*n-1,0,2*n-1);

	push	1295					; 0000050fH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	mov	DWORD PTR _evalues$[ebp], eax
	mov	eax, DWORD PTR tv1416[ebp]
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix
	add	esp, 40					; 00000028H

; 1296 :   if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	mov	DWORD PTR _evectors$[ebp], eax
	jne	SHORT $LN104@cg_ritz
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $LN105@cg_ritz
$LN104@cg_ritz:

; 1297 :     { mx = dmatrix(0,n-1,0,S->N);

	mov	ecx, DWORD PTR [ebx+4]
	push	1297					; 00000511H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	ecx
	push	0
	push	edi
	push	0
	call	_kb_dmatrix

; 1298 :       mh = dmatrix(0,n-1,0,S->N);

	mov	edx, DWORD PTR [ebx+4]
	push	1298					; 00000512H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	edx
	push	0
	push	edi
	push	0
	mov	DWORD PTR _mx$[ebp], eax
	call	_kb_dmatrix
	add	esp, 48					; 00000030H
	mov	DWORD PTR _mh$[ebp], eax
$LN105@cg_ritz:

; 1299 :     }
; 1300 :   if ( S->CN )

	cmp	DWORD PTR [ebx+148], 0
	je	$LN103@cg_ritz

; 1301 :     { CCinv = dmatrix(0,S->CN,0,S->CN);

	mov	eax, DWORD PTR [ebx+148]
	push	1301					; 00000515H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 1302 :       mat_mul_tr(S->C,S->C,CCinv,S->CN,S->N,S->CN);

	mov	ecx, DWORD PTR [ebx+148]
	mov	edx, DWORD PTR [ebx+160]
	push	ecx
	mov	DWORD PTR _CCinv$[ebp], eax
	mov	eax, DWORD PTR [ebx+4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _CCinv$[ebp]
	push	ecx
	push	edx
	push	edx
	call	_mat_mul_tr

; 1303 :       mat_inv(CCinv,S->CN);

	mov	edx, DWORD PTR [ebx+148]
	mov	eax, DWORD PTR _CCinv$[ebp]
	push	edx
	push	eax
	call	_mat_inv

; 1304 :       Cf = dmatrix(0,S->CN-1,0,n-1);

	mov	ecx, DWORD PTR [ebx+148]
	push	1304					; 00000518H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	edi
	push	0
	dec	ecx
	push	ecx
	push	0
	call	_kb_dmatrix

; 1305 :       Gf = dmatrix(0,S->CN-1,0,n-1); 

	mov	edx, DWORD PTR [ebx+148]
	add	esp, 80					; 00000050H
	push	1305					; 00000519H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	edi
	push	0
	dec	edx
	push	edx
	push	0
	mov	DWORD PTR _Cf$[ebp], eax
	call	_kb_dmatrix
	add	esp, 24					; 00000018H
	mov	DWORD PTR _Gf$[ebp], eax
$LN103@cg_ritz:

; 1306 :     }
; 1307 : 
; 1308 :   /* initial random guess */
; 1309 :   for ( j = 0 ; j < n ; j++ )

	test	esi, esi
	jle	SHORT $LN100@cg_ritz
	mov	ecx, DWORD PTR _x$GSCopy$[ebp]
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR tv2091[ebp], ecx
	mov	DWORD PTR tv557[ebp], esi
	npad	2
$LL102@cg_ritz:

; 1310 :     for ( i = 0 ; i < S->N ; i++ ) x[j][i] = drand48() - .5;

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN101@cg_ritz
$LL99@cg_ritz:
	call	_drand48
	fsub	QWORD PTR __real@3fe0000000000000
	mov	edx, DWORD PTR tv2091[ebp]
	mov	eax, DWORD PTR [edx]
	fstp	QWORD PTR [eax+edi*8]
	mov	eax, DWORD PTR [ebx+4]
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL99@cg_ritz
$LN101@cg_ritz:

; 1306 :     }
; 1307 : 
; 1308 :   /* initial random guess */
; 1309 :   for ( j = 0 ; j < n ; j++ )

	add	DWORD PTR tv2091[ebp], 4
	dec	DWORD PTR tv557[ebp]
	jne	SHORT $LL102@cg_ritz
$LN100@cg_ritz:

; 1311 :   /* project to constraints */
; 1312 :   if ( S->CN )

	mov	eax, DWORD PTR [ebx+148]

; 1313 :     { mat_mul_tr(S->C,x,Cf,S->CN,S->N,n);

	mov	edi, DWORD PTR _x$GSCopy$[ebp]
	test	eax, eax
	je	$LN93@cg_ritz
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR _Cf$[ebp]
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR [ebx+160]
	push	edx
	push	edi
	push	eax
	call	_mat_mul_tr

; 1314 :       mat_mult(CCinv,Cf,Gf,S->CN,S->CN,n);

	mov	eax, DWORD PTR [ebx+148]
	mov	ecx, DWORD PTR _Gf$[ebp]
	mov	edx, DWORD PTR _Cf$[ebp]
	push	esi
	push	eax
	push	eax
	mov	eax, DWORD PTR _CCinv$[ebp]
	push	ecx
	push	edx
	push	eax
	call	_mat_mult
	add	esp, 48					; 00000030H

; 1315 :       for ( j = 0 ; j < n ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	test	esi, esi
	jle	SHORT $LN93@cg_ritz

; 1313 :     { mat_mul_tr(S->C,x,Cf,S->CN,S->N,n);

	mov	eax, DWORD PTR [ebx+148]
	mov	DWORD PTR tv2160[ebp], edi
$LL95@cg_ritz:

; 1316 :        for ( i = 0 ; i < S->CN ; i++ )

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN94@cg_ritz
	npad	5
$LL92@cg_ritz:

; 1317 :         vector_add_smul(x[j],S->C[i],-Gf[i][j],S->N);

	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR _Gf$[ebp]
	mov	eax, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR [ebx+160]
	push	ecx
	mov	ecx, DWORD PTR _j$[ebp]
	fld	QWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [edx+edi*4]
	mov	ecx, DWORD PTR tv2160[ebp]
	fchs
	mov	edx, DWORD PTR [ecx]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	push	edx
	call	_vector_add_smul
	mov	eax, DWORD PTR [ebx+148]
	inc	edi
	add	esp, 20					; 00000014H
	cmp	edi, eax
	jl	SHORT $LL92@cg_ritz
$LN94@cg_ritz:

; 1315 :       for ( j = 0 ; j < n ; j++ )

	mov	ecx, DWORD PTR _j$[ebp]
	add	DWORD PTR tv2160[ebp], 4
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, esi
	jl	SHORT $LL95@cg_ritz
	mov	edi, DWORD PTR _x$GSCopy$[ebp]
$LN93@cg_ritz:

; 1318 :     }
; 1319 :   /* project to Steifel manifold XMX = I */
; 1320 :   LQ_decomp(x,n,S->N,x,L,M);

	mov	eax, DWORD PTR _M$[ebp]
	mov	ecx, DWORD PTR _L$[ebp]
	mov	edx, DWORD PTR [ebx+4]
	push	eax
	push	ecx
	push	edi
	push	edx
	push	esi
	push	edi
	call	_LQ_decomp

; 1321 : 
; 1322 :   trxax = 1e30; /* silly value for start of convergence test */

	fld	QWORD PTR __real@46293e5939a08cea

; 1323 :   for(;;)
; 1324 :   { prompt("Enter max iterations: ",response,sizeof(response)); 

	push	100					; 00000064H
	fstp	QWORD PTR _trxax$[ebp]
	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	push	OFFSET ??_C@_0BH@BNPHLKFG@Enter?5max?5iterations?3?5?$AA@
	call	_prompt

; 1325 :     maxcount = atoi(response);

	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	call	_atoi
	add	esp, 40					; 00000028H
	mov	DWORD PTR _maxcount$[ebp], eax

; 1326 :     if ( maxcount == 0 ) break;

	test	eax, eax
	je	$LN148@cg_ritz
	npad	10
$LL89@cg_ritz:

; 1327 :     if ( maxcount < 0 ) { count = 0 ; maxcount = -maxcount; }

	mov	eax, DWORD PTR _maxcount$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _count$[ebp], ecx
	cmp	eax, ecx
	jge	SHORT $LN312@cg_ritz
	neg	eax
	mov	DWORD PTR _maxcount$[ebp], eax
$LN312@cg_ritz:

; 1328 :     else count = 0;

	fld	QWORD PTR _trxax$[ebp]
$LN84@cg_ritz:

; 1329 : 
; 1330 :     do
; 1331 :     { REAL denom;
; 1332 :       old_trxax = trxax;
; 1333 : 
; 1334 :       count++;

	inc	DWORD PTR _count$[ebp]
	fstp	QWORD PTR _old_trxax$[ebp]

; 1335 :       /* get cg search direction */
; 1336 :       for ( j = 0 ; j < n ; j++ )

	test	esi, esi
	jle	SHORT $LN341@cg_ritz
	mov	edi, DWORD PTR _x$GSCopy$[ebp]
	mov	eax, DWORD PTR _f$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv2191[ebp], eax
	mov	DWORD PTR tv1181[ebp], esi
	npad	5
$LL81@cg_ritz:

; 1337 :         (*sp_mul_func)(S,x[j],f[j]);  /* AX */

	mov	edx, DWORD PTR tv2191[ebp]
	mov	eax, DWORD PTR [edx+edi]
	mov	ecx, DWORD PTR [edi]
	push	eax
	push	ecx
	push	ebx
	call	DWORD PTR _sp_mul_func
	add	esp, 12					; 0000000cH
	add	edi, 4
	dec	DWORD PTR tv1181[ebp]
	jne	SHORT $LL81@cg_ritz
$LN341@cg_ritz:

; 1338 :       mat_mul_tr(x,f,xax,n,S->N,n);

	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR _B$[ebp]
	mov	ecx, DWORD PTR _f$[ebp]
	mov	edi, DWORD PTR _x$GSCopy$[ebp]
	push	esi
	push	edx
	push	esi
	push	eax
	push	ecx
	push	edi
	call	_mat_mul_tr
	add	esp, 24					; 00000018H

; 1339 :       if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN77@cg_ritz
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN77@cg_ritz

; 1342 :       else mx = x;

	mov	DWORD PTR _mx$[ebp], edi
	jmp	SHORT $LN342@cg_ritz
$LN77@cg_ritz:

; 1340 :         for ( j = 0 ; j < n ; j++ )

	test	esi, esi
	jle	SHORT $LN342@cg_ritz
	mov	eax, DWORD PTR _mx$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv2227[ebp], eax
	mov	DWORD PTR tv1115[ebp], esi
	npad	5
$LL76@cg_ritz:

; 1341 :           (*sp_mul_func)(&Met,x[j],mx[j]);

	mov	edx, DWORD PTR tv2227[ebp]
	mov	eax, DWORD PTR [edx+edi]
	mov	ecx, DWORD PTR [edi]
	push	eax
	push	ecx
	push	OFFSET _Met
	call	DWORD PTR _sp_mul_func
	add	esp, 12					; 0000000cH
	add	edi, 4
	dec	DWORD PTR tv1115[ebp]
	jne	SHORT $LL76@cg_ritz
$LN342@cg_ritz:

; 1343 : 
; 1344 :       mat_mult(xax,mx,ah,n,n,S->N);  /* ah just used as temp */

	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR _ah$[ebp]
	mov	ecx, DWORD PTR _mx$[ebp]
	push	edx
	mov	edx, DWORD PTR _B$[ebp]
	push	esi
	push	esi
	push	eax
	push	ecx
	push	edx
	call	_mat_mult
	add	esp, 24					; 00000018H

; 1345 :       for ( j = 0 ; j < n ; j++ )

	test	esi, esi
	jle	SHORT $LN70@cg_ritz
	mov	edi, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR _ah$[ebp]
	mov	ecx, DWORD PTR [ebx+4]
	sub	eax, edi
	mov	DWORD PTR tv2299[ebp], edi
	mov	DWORD PTR tv2314[ebp], eax
	mov	DWORD PTR tv1034[ebp], esi
$LL72@cg_ritz:

; 1346 :         for ( i = 0 ; i < S->N ; i++ ) f[j][i] -= ah[j][i];

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN71@cg_ritz
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR tv2314[ebp]
	mov	edi, DWORD PTR [ecx+edi]
	sub	edi, eax
$LL69@cg_ritz:
	fld	QWORD PTR [eax]
	inc	edx
	fsub	QWORD PTR [edi+eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR [ebx+4]
	cmp	edx, ecx
	jl	SHORT $LL69@cg_ritz
	mov	edi, DWORD PTR tv2299[ebp]
$LN71@cg_ritz:

; 1345 :       for ( j = 0 ; j < n ; j++ )

	add	edi, 4
	dec	DWORD PTR tv1034[ebp]
	mov	DWORD PTR tv2299[ebp], edi
	jne	SHORT $LL72@cg_ritz
$LN70@cg_ritz:

; 1347 : 
; 1348 :       /* convert form f to vector If with cg metric I */
; 1349 :       If = f;
; 1350 :       /* project to constraints */
; 1351 :       if ( S->CN )

	mov	eax, DWORD PTR [ebx+148]
	test	eax, eax
	je	$LN63@cg_ritz

; 1352 :       { mat_mul_tr(S->C,If,Cf,S->CN,S->N,n);

	mov	edx, DWORD PTR [ebx+4]
	mov	edi, DWORD PTR _Cf$[ebp]
	mov	ecx, DWORD PTR [ebx+160]
	push	esi
	push	edx
	push	eax
	mov	eax, DWORD PTR _f$[ebp]
	push	edi
	push	eax
	push	ecx
	call	_mat_mul_tr

; 1353 :         mat_mult(CCinv,Cf,Gf,S->CN,S->CN,n);

	mov	eax, DWORD PTR [ebx+148]
	mov	edx, DWORD PTR _Gf$[ebp]
	push	esi
	push	eax
	push	eax
	mov	eax, DWORD PTR _CCinv$[ebp]
	push	edx
	push	edi
	push	eax
	call	_mat_mult
	add	esp, 48					; 00000030H

; 1354 :         for ( j = 0 ; j < n ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	test	esi, esi
	jle	SHORT $LN63@cg_ritz

; 1352 :       { mat_mul_tr(S->C,If,Cf,S->CN,S->N,n);

	mov	ecx, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR [ebx+148]
	mov	DWORD PTR tv2389[ebp], ecx
$LL65@cg_ritz:

; 1355 :          for ( i = 0 ; i < S->CN ; i++ )

	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN64@cg_ritz
	npad	4
$LL62@cg_ritz:

; 1356 :           vector_add_smul(If[j],S->C[i],-Gf[i][j],S->N);

	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR _Gf$[ebp]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [ebx+160]
	push	edx
	mov	edx, DWORD PTR _j$[ebp]
	fld	QWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	edx, DWORD PTR tv2389[ebp]
	fchs
	mov	eax, DWORD PTR [edx]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	push	eax
	call	_vector_add_smul
	mov	eax, DWORD PTR [ebx+148]
	inc	edi
	add	esp, 20					; 00000014H
	cmp	edi, eax
	jl	SHORT $LL62@cg_ritz
$LN64@cg_ritz:

; 1354 :         for ( j = 0 ; j < n ; j++ )

	mov	ecx, DWORD PTR _j$[ebp]
	add	DWORD PTR tv2389[ebp], 4
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, esi
	jl	SHORT $LL65@cg_ritz
$LN63@cg_ritz:

; 1357 :       }
; 1358 :       /* project If tangent to Steifel manifold */
; 1359 :       mat_mul_tr(mx,If,NN,n,S->N,n); 

	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR _NN$[ebp]
	mov	edi, DWORD PTR _f$[ebp]
	mov	eax, DWORD PTR _mx$[ebp]
	push	esi
	push	ecx
	push	esi
	push	edx
	push	edi
	push	eax
	call	_mat_mul_tr

; 1360 :       tr_mat_mul(NN,x,ah,n,n,S->N);

	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR _ah$[ebp]
	mov	eax, DWORD PTR _x$GSCopy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _NN$[ebp]
	push	esi
	push	esi
	push	edx
	push	eax
	push	ecx
	call	_tr_mat_mul
	add	esp, 48					; 00000030H

; 1361 :       for ( j = 0 ; j < n ; j++ )

	test	esi, esi
	jle	SHORT $LN343@cg_ritz
	mov	eax, DWORD PTR _ah$[ebp]
	mov	ecx, DWORD PTR [ebx+4]
	sub	eax, edi
	mov	DWORD PTR tv2457[ebp], edi
	mov	DWORD PTR tv2314[ebp], eax
	mov	DWORD PTR tv531[ebp], esi
$LL59@cg_ritz:

; 1362 :         for ( i = 0 ; i < S->N ; i++ ) If[j][i] -= ah[j][i];

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN58@cg_ritz
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR tv2314[ebp]
	mov	edi, DWORD PTR [edi+ecx]
	sub	edi, eax
$LL56@cg_ritz:
	fld	QWORD PTR [eax]
	inc	edx
	fsub	QWORD PTR [edi+eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR [ebx+4]
	cmp	edx, ecx
	jl	SHORT $LL56@cg_ritz
	mov	edi, DWORD PTR tv2457[ebp]
$LN58@cg_ritz:

; 1361 :       for ( j = 0 ; j < n ; j++ )

	add	edi, 4
	dec	DWORD PTR tv531[ebp]
	mov	DWORD PTR tv2457[ebp], edi
	jne	SHORT $LL59@cg_ritz
$LN343@cg_ritz:

; 1363 : 
; 1364 :       if ( count <= 1 ) cgamma = 0.0;

	cmp	DWORD PTR _count$[ebp], 1
	jg	SHORT $LN53@cg_ritz
	fldz

; 1365 :       else

	jmp	$LN52@cg_ritz
$LN53@cg_ritz:

; 1366 :       { /* proper Hessian is A - XAX M */
; 1367 :         REAL numer;
; 1368 :         for ( j = 0 ; j < n ; j++ )

	test	esi, esi
	jle	SHORT $LN344@cg_ritz
	mov	edi, DWORD PTR _h$[ebp]
	mov	eax, DWORD PTR _ah$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv2511[ebp], eax
	mov	DWORD PTR tv899[ebp], esi
$LL51@cg_ritz:

; 1369 :           (*sp_mul_func)(S,h[j],ah[j]);

	mov	edx, DWORD PTR tv2511[ebp]
	mov	eax, DWORD PTR [edx+edi]
	mov	ecx, DWORD PTR [edi]
	push	eax
	push	ecx
	push	ebx
	call	DWORD PTR _sp_mul_func
	add	esp, 12					; 0000000cH
	add	edi, 4
	dec	DWORD PTR tv899[ebp]
	jne	SHORT $LL51@cg_ritz
$LN344@cg_ritz:

; 1370 :         if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN47@cg_ritz
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN47@cg_ritz

; 1373 :         else mh = h;

	mov	edx, DWORD PTR _h$[ebp]
	mov	DWORD PTR _mh$[ebp], edx
	jmp	SHORT $LN44@cg_ritz
$LN47@cg_ritz:

; 1371 :          for ( j = 0 ; j < n ; j++ )

	test	esi, esi
	jle	$LN40@cg_ritz
	mov	edi, DWORD PTR _h$[ebp]
	mov	eax, DWORD PTR _mh$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv2547[ebp], eax
	mov	DWORD PTR tv890[ebp], esi
$LL46@cg_ritz:

; 1372 :           (*sp_mul_func)(&Met,h[j],mh[j]);

	mov	eax, DWORD PTR tv2547[ebp]
	mov	ecx, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [edi]
	push	ecx
	push	edx
	push	OFFSET _Met
	call	DWORD PTR _sp_mul_func
	add	esp, 12					; 0000000cH
	add	edi, 4
	dec	DWORD PTR tv890[ebp]
	jne	SHORT $LL46@cg_ritz
$LN44@cg_ritz:

; 1374 :         for ( j = 0 ; j < n ; j++ )

	test	esi, esi
	jle	$LN40@cg_ritz
	mov	ecx, DWORD PTR _ah$[ebp]
	mov	eax, DWORD PTR _B$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv3082[ebp], ecx
	mov	DWORD PTR tv3109[ebp], eax
	mov	DWORD PTR tv874[ebp], esi
	npad	6
$LL42@cg_ritz:

; 1375 :          for ( i = 0 ; i < S->N ; i++ ) 

	xor	ecx, ecx
	cmp	DWORD PTR [ebx+4], ecx
	jle	$LN41@cg_ritz
	npad	5
$LL39@cg_ritz:

; 1376 :           for ( k = 0 ; k < n ; k++ ) ah[j][i] -= xax[j][k]*mh[k][i];

	xor	eax, eax
	cmp	esi, 4
	jl	$LN339@cg_ritz

; 1375 :          for ( i = 0 ; i < S->N ; i++ ) 

	mov	eax, DWORD PTR tv3082[ebp]
	mov	edx, DWORD PTR [eax]

; 1376 :           for ( k = 0 ; k < n ; k++ ) ah[j][i] -= xax[j][k]*mh[k][i];

	mov	ebx, DWORD PTR tv3109[ebp]
	mov	eax, DWORD PTR [ebx+eax]
	lea	ebx, DWORD PTR [esi-4]
	shr	ebx, 2
	inc	ebx
	lea	edi, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _mh$[ebp]
	mov	DWORD PTR tv231[ebp], ebx
	add	ebx, ebx
	add	edx, 8
	add	eax, 16					; 00000010H
	add	ebx, ebx
	mov	DWORD PTR _k$[ebp], ebx
	npad	4
$LL178@cg_ritz:
	mov	ebx, DWORD PTR [edx-8]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [edx-4]
	fmul	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv231[ebp]
	fsubr	QWORD PTR [edi]
	fst	QWORD PTR [edi]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [edx-16]
	fmul	QWORD PTR [eax-40]
	fsubp	ST(1), ST(0)
	fst	QWORD PTR [edi]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [edx-12]
	fmul	QWORD PTR [eax-32]
	fsubp	ST(1), ST(0)
	fst	QWORD PTR [edi]
	fld	QWORD PTR [ebx+ecx*8]
	fmul	QWORD PTR [eax-24]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [edi]
	jne	SHORT $LL178@cg_ritz
	mov	eax, DWORD PTR _k$[ebp]
	mov	ebx, DWORD PTR _S$GSCopy$[ebp]
$LN339@cg_ritz:
	cmp	eax, esi
	jge	SHORT $LN38@cg_ritz

; 1375 :          for ( i = 0 ; i < S->N ; i++ ) 

	mov	edx, DWORD PTR tv3082[ebp]
	mov	edi, DWORD PTR [edx]
	lea	edi, DWORD PTR [edi+ecx*8]
	mov	DWORD PTR tv3102[ebp], edi

; 1376 :           for ( k = 0 ; k < n ; k++ ) ah[j][i] -= xax[j][k]*mh[k][i];

	mov	edi, DWORD PTR tv3109[ebp]
	mov	edx, DWORD PTR [edi+edx]
	lea	edx, DWORD PTR [edx+eax*8]
	npad	7
$LL340@cg_ritz:
	mov	edi, DWORD PTR _mh$[ebp]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR tv3102[ebp]
	fmul	QWORD PTR [edx]
	inc	eax
	add	edx, 8
	fsubr	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	cmp	eax, esi
	jl	SHORT $LL340@cg_ritz
$LN38@cg_ritz:

; 1375 :          for ( i = 0 ; i < S->N ; i++ ) 

	inc	ecx
	cmp	ecx, DWORD PTR [ebx+4]
	jl	$LL39@cg_ritz
$LN41@cg_ritz:

; 1374 :         for ( j = 0 ; j < n ; j++ )

	add	DWORD PTR tv3082[ebp], 4
	dec	DWORD PTR tv874[ebp]
	jne	$LL42@cg_ritz
$LN40@cg_ritz:

; 1377 :            for ( j = 0, numer = denom = 0.0 ; j < n ; j++ )

	fldz
	fld	ST(0)
	fst	QWORD PTR _denom$89874[ebp]
	fxch	ST(1)
	fstp	QWORD PTR _numer$89905[ebp]
	test	esi, esi
	jle	SHORT $LN31@cg_ritz
	mov	edi, DWORD PTR _ah$[ebp]
	mov	eax, DWORD PTR _f$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv3193[ebp], eax
	mov	eax, DWORD PTR _h$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv3198[ebp], eax
	mov	DWORD PTR tv3155[ebp], esi
	npad	1
$LL375@cg_ritz:

; 1378 :            { numer += dot(If[j],ah[j],S->N);

	mov	eax, DWORD PTR [ebx+4]
	fstp	ST(0)
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR tv3193[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+edi]
	push	ecx
	push	eax
	call	_dot
	fadd	QWORD PTR _numer$89905[ebp]

; 1379 :              denom += dot(h[j],ah[j],S->N);

	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR tv3198[ebp]
	fstp	QWORD PTR _numer$89905[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+edi]
	push	edx
	push	ecx
	call	_dot
	fadd	QWORD PTR _denom$89874[ebp]
	add	esp, 24					; 00000018H
	add	edi, 4
	dec	DWORD PTR tv3155[ebp]
	fst	QWORD PTR _denom$89874[ebp]
	jne	SHORT $LL375@cg_ritz
$LN31@cg_ritz:

; 1380 :            }
; 1381 :         cgamma = -numer/denom;

	fdivr	QWORD PTR _numer$89905[ebp]
	fchs
$LN52@cg_ritz:

; 1382 :       }
; 1383 :       for ( j = 0 ; j < n ; j++ )

	test	esi, esi
	jle	SHORT $LN371@cg_ritz
	mov	edi, DWORD PTR _h$[ebp]
	mov	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR [ebx+4]
	sub	eax, edi
	mov	DWORD PTR tv3306[ebp], edi
	mov	DWORD PTR tv3321[ebp], eax
	mov	DWORD PTR tv3281[ebp], esi
$LN30@cg_ritz:

; 1384 :         for ( i = 0 ; i < S->N ; i++ ) h[j][i] = If[j][i] + cgamma*h[j][i];

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN29@cg_ritz
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR tv3321[ebp]
	mov	edi, DWORD PTR [ecx+edi]
	sub	edi, eax
$LN27@cg_ritz:
	fld	QWORD PTR [eax]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8
	fadd	QWORD PTR [edi+eax-8]
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR [ebx+4]
	cmp	edx, ecx
	jl	SHORT $LN27@cg_ritz
	mov	edi, DWORD PTR tv3306[ebp]
$LN29@cg_ritz:

; 1382 :       }
; 1383 :       for ( j = 0 ; j < n ; j++ )

	add	edi, 4
	dec	DWORD PTR tv3281[ebp]
	mov	DWORD PTR tv3306[ebp], edi
	jne	SHORT $LN30@cg_ritz
$LN371@cg_ritz:

; 1385 : 
; 1386 :       /* normalize h to be orthonormal wrt M, hMh = I */
; 1387 :       LQ_decomp(h,n,S->N,Q,L,M); 

	mov	edx, DWORD PTR _M$[ebp]
	fstp	ST(0)
	mov	edi, DWORD PTR _L$[ebp]
	mov	eax, DWORD PTR _Q$[ebp]
	mov	ecx, DWORD PTR [ebx+4]
	push	edx
	mov	edx, DWORD PTR _h$[ebp]
	push	edi
	push	eax
	push	ecx
	push	esi
	push	edx
	call	_LQ_decomp

; 1388 :       matcopy(Linv,L,n,n);

	push	esi
	push	esi
	push	edi
	mov	edi, DWORD PTR _Linv$[ebp]
	push	edi
	call	_matcopy

; 1389 :       mat_inv(Linv,n);

	push	esi
	push	edi
	call	_mat_inv
	add	esp, 48					; 00000030H

; 1390 : 
; 1391 :       /* compute Ah */
; 1392 :       for ( j = 0 ; j < n ; j++ )

	test	esi, esi
	jle	SHORT $LN22@cg_ritz
	mov	edi, DWORD PTR _h$[ebp]
	mov	eax, DWORD PTR _ah$[ebp]
	sub	eax, edi
	mov	DWORD PTR tv2511[ebp], eax
	mov	DWORD PTR tv3369[ebp], esi
	npad	2
$LL24@cg_ritz:

; 1393 :        (*sp_mul_func)(S,h[j],ah[j]);

	mov	eax, DWORD PTR tv2511[ebp]
	mov	ecx, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [edi]
	push	ecx
	push	edx
	push	ebx
	call	DWORD PTR _sp_mul_func
	add	esp, 12					; 0000000cH
	add	edi, 4
	dec	DWORD PTR tv3369[ebp]
	jne	SHORT $LL24@cg_ritz
$LN22@cg_ritz:

; 1394 : 
; 1395 :       /* load up matrix */
; 1396 :       /* B = | xax xah |  */
; 1397 :       /*      | hax hah |  */
; 1398 :       mat_mul_tr(h,ah,hah,n,S->N,n);

	mov	eax, DWORD PTR [ebx+4]
	mov	edi, DWORD PTR _hah$[ebp]
	mov	ecx, DWORD PTR _ah$[ebp]
	mov	edx, DWORD PTR _h$[ebp]
	push	esi
	push	eax
	push	esi
	push	edi
	push	ecx
	push	edx
	call	_mat_mul_tr

; 1399 :       mat_mult(Linv,hah,NN,n,n,n);

	mov	eax, DWORD PTR _NN$[ebp]
	mov	ecx, DWORD PTR _Linv$[ebp]
	push	esi
	push	esi
	push	esi
	push	eax
	push	edi
	push	ecx
	call	_mat_mult

; 1400 :       mat_mul_tr(NN,Linv,hah,n,n,n);

	mov	edx, DWORD PTR _Linv$[ebp]
	mov	eax, DWORD PTR _NN$[ebp]
	push	esi
	push	esi
	push	esi
	push	edi
	push	edx
	push	eax
	call	_mat_mul_tr

; 1401 :       mat_mul_tr(Q,f,hax,n,S->N,n);

	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR _B$[ebp]
	add	esp, 72					; 00000048H
	push	esi
	push	ecx
	mov	ecx, DWORD PTR _Q$[ebp]
	push	esi
	lea	eax, DWORD PTR [edx+esi*4]
	push	eax
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	push	ecx
	call	_mat_mul_tr
	add	esp, 24					; 00000018H

; 1402 :       for ( i = 0 ; i < n ; i++ )

	xor	ecx, ecx
	test	esi, esi
	jle	$LN19@cg_ritz
	npad	3
$LL21@cg_ritz:

; 1403 :        for ( j = 0 ; j < n ; j++ )

	xor	eax, eax
	cmp	esi, 4
	jl	SHORT $LC180@cg_ritz
	mov	edx, DWORD PTR _xah$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _B$[ebp]
	lea	edi, DWORD PTR [esi-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv3737[ebp], edi
	add	edi, edi
	add	eax, 16					; 00000010H
	add	edi, edi
	lea	edx, DWORD PTR [edx+esi*4+8]
	mov	DWORD PTR _j$[ebp], edi
$LL181@cg_ritz:

; 1404 :          xah[i][j] = hax[j][i];

	mov	edi, DWORD PTR [edx-8]
	fld	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR [edx-4]
	fstp	QWORD PTR [eax-16]
	add	edx, 16					; 00000010H
	fld	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR [edx-16]
	fstp	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	dec	DWORD PTR tv3737[ebp]
	fld	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR [edx-12]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edi+ecx*8]
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LL181@cg_ritz

; 1403 :        for ( j = 0 ; j < n ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
$LC180@cg_ritz:
	cmp	eax, esi
	jge	SHORT $LN20@cg_ritz
	mov	edx, DWORD PTR _xah$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	lea	edx, DWORD PTR [edx+eax*8]
	npad	10
$LL349@cg_ritz:

; 1404 :          xah[i][j] = hax[j][i];

	mov	edi, DWORD PTR _B$[ebp]
	lea	edi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edi+ecx*8]
	inc	eax
	fstp	QWORD PTR [edx]
	add	edx, 8
	cmp	eax, esi
	jl	SHORT $LL349@cg_ritz
$LN20@cg_ritz:

; 1402 :       for ( i = 0 ; i < n ; i++ )

	inc	ecx
	cmp	ecx, esi
	jl	$LL21@cg_ritz
$LN19@cg_ritz:

; 1405 :       jacobi_eigenpairs(B,2*n,evalues,evectors,work);

	mov	eax, DWORD PTR _work$[ebp]
	mov	ecx, DWORD PTR _evectors$[ebp]
	mov	edx, DWORD PTR _evalues$[ebp]
	push	eax
	mov	eax, DWORD PTR _B$[ebp]
	push	ecx
	push	edx
	lea	edi, DWORD PTR [esi+esi]
	push	edi
	push	eax
	call	_jacobi_eigenpairs

; 1406 :       /* returns eigenvectors in columns of evectors, in descending order */
; 1407 : 
; 1408 :       /* use lowest n eigenvectors */
; 1409 :       for ( j = n, trxax = 0.0; j < 2*n ; j++ ) trxax += evalues[j];

	fldz
	add	esp, 20					; 00000014H
	fst	QWORD PTR _trxax$[ebp]
	mov	ecx, esi
	cmp	esi, edi
	jge	SHORT $LN386@cg_ritz
	mov	edx, edi
	sub	edx, esi
	cmp	edx, 4
	mov	edx, DWORD PTR _evalues$[ebp]
	jl	SHORT $LC183@cg_ritz
	sub	edi, esi
	sub	edi, 4
	shr	edi, 2
	inc	edi
	lea	eax, DWORD PTR [edx+esi*8+16]
	lea	ecx, DWORD PTR [esi+edi*4]
$LN184@cg_ritz:
	fadd	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	edi
	fadd	QWORD PTR [eax-40]
	fadd	QWORD PTR [eax-32]
	fadd	QWORD PTR [eax-24]
	jne	SHORT $LN184@cg_ritz
	fst	QWORD PTR _trxax$[ebp]
$LC183@cg_ritz:
	lea	edi, DWORD PTR [esi+esi]
	cmp	ecx, edi
	jge	SHORT $LN386@cg_ritz
$LC15@cg_ritz:
	fadd	QWORD PTR [edx+ecx*8]
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LC15@cg_ritz
	fstp	QWORD PTR _trxax$[ebp]
	jmp	SHORT $LN348@cg_ritz
$LN386@cg_ritz:
	fstp	ST(0)
$LN348@cg_ritz:

; 1410 : 
; 1411 :       /* rotate h and x */
; 1412 :       tr_mat_mul(evectors,xh,hx,2*n,2*n,S->N);

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR _xh$[ebp]
	mov	edx, DWORD PTR _evectors$[ebp]
	push	eax
	push	edi
	push	edi
	mov	edi, DWORD PTR _hx$[ebp]
	push	edi
	push	ecx
	push	edx
	call	_tr_mat_mul

; 1413 :       matcopy(x,hx+n,n,S->N);

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR _x$GSCopy$[ebp]
	push	eax
	push	esi
	lea	eax, DWORD PTR [edi+esi*4]
	push	eax
	push	ecx
	call	_matcopy

; 1414 :       mat_mult(L,hx,h,n,n,S->N);

	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR _h$[ebp]
	mov	ecx, DWORD PTR _L$[ebp]
	push	edx
	push	esi
	push	esi
	push	eax
	push	edi
	push	ecx
	call	_mat_mult

; 1415 : 
; 1416 :       if ( (count < maxcount) && (maxcount > 5) && (count % (maxcount/5) == 0) )

	mov	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _maxcount$[ebp]
	add	esp, 64					; 00000040H
	cmp	ecx, edx
	jge	$LN83@cg_ritz
	cmp	edx, 5
	jle	$LN83@cg_ritz
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 1
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	mov	eax, ecx
	cdq
	idiv	edi
	test	edx, edx
	jne	$LN356@cg_ritz

; 1417 :       { sprintf(msg,"%3d.  ",count);

	mov	edx, DWORD PTR _msg
	push	ecx
	push	OFFSET ??_C@_06PMGOCIHL@?$CF3d?4?5?5?$AA@
	push	edx
	call	_sprintf
	mov	ecx, DWORD PTR _evalues$[ebp]
	mov	eax, esi
	add	esp, 12					; 0000000cH

; 1418 :           for ( j = 0 ; (j < 4)&&(j<n) ; j++ )

	xor	edi, edi
	add	eax, eax
	lea	edx, DWORD PTR [ecx+eax*8-8]
	mov	DWORD PTR tv4319[ebp], edx
$LL350@cg_ritz:
	cmp	edi, esi
	jge	SHORT $LN9@cg_ritz

; 1419 : #ifdef FLOAT128
; 1420 :               sprintf(msg+strlen(msg)," %*.*Qg",DWIDTH,DPREC,evalues[2*n-1-j]);
; 1421 : #elif defined(LONGDOUBLE)
; 1422 :               sprintf(msg+strlen(msg)," %*.*Lg",DWIDTH,DPREC,evalues[2*n-1-j]);
; 1423 : #else
; 1424 :               sprintf(msg+strlen(msg)," %18.15g",evalues[2*n-1-j]);

	mov	edx, DWORD PTR _msg
	mov	eax, edx
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR tv4346[ebp], ecx
$LL310@cg_ritz:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL310@cg_ritz
	mov	ecx, DWORD PTR tv4319[ebp]
	sub	eax, DWORD PTR tv4346[ebp]
	fld	QWORD PTR [ecx]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	add	eax, edx
	push	OFFSET ??_C@_08PCNGPKFM@?5?$CF18?415g?$AA@
	push	eax
	call	_sprintf
	sub	DWORD PTR tv4319[ebp], 8
	inc	edi
	add	esp, 16					; 00000010H
	cmp	edi, 4
	jl	SHORT $LL350@cg_ritz
$LN9@cg_ritz:

; 1425 : #endif 
; 1426 :         strcat(msg,"\n");

	mov	edi, DWORD PTR _msg
	dec	edi
	npad	2
$LL311@cg_ritz:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL311@cg_ritz
	mov	dx, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@
	mov	WORD PTR [edi], dx

; 1427 :         outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	mov	ecx, DWORD PTR _count$[ebp]
	add	esp, 4
$LN356@cg_ritz:
	mov	edx, DWORD PTR _maxcount$[ebp]
$LN83@cg_ritz:

; 1428 :       }
; 1429 :     } while ( (fabs(trxax-old_trxax) > 10*machine_eps*fabs(trxax)) && (count<maxcount) );

	fld	QWORD PTR _trxax$[ebp]
	fld	QWORD PTR _old_trxax$[ebp]
	fsubr	ST(0), ST(1)
	fabs
	fld	ST(1)
	fabs
	fld	QWORD PTR _machine_eps
	fmul	QWORD PTR __real@4024000000000000
	fmulp	ST(1), ST(0)
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN8@cg_ritz
	cmp	ecx, edx
	jl	$LN84@cg_ritz

; 1430 :     if ( count < maxcount )

	mov	ecx, DWORD PTR _count$[ebp]
$LN7@cg_ritz:

; 1442 : #ifdef FLOAT128
; 1443 :      sprintf(msg,"%3d.    %3.*Qg  max iterations\n",count,DPREC,trxax);
; 1444 : #elif defined(LONGDOUBLE)
; 1445 :      sprintf(msg,"%3d.    %3.*Lg  max iterations\n",count,DPREC,trxax);
; 1446 : #else
; 1447 :      sprintf(msg,"%3d.    %3.17g  max iterations\n",count,trxax);

	mov	eax, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	push	OFFSET ??_C@_0CA@CMJBFKAG@?$CF3d?4?5?5?5?5?$CF3?417g?5?5max?5iterations?6?$AA@
	push	eax
	call	_sprintf

; 1448 : #endif 
; 1449 :      outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
$LN399@cg_ritz:
	call	_outstring
	add	esp, 24					; 00000018H
	push	100					; 00000064H
	lea	edx, DWORD PTR _response$[ebp]
	push	edx
	push	OFFSET ??_C@_0BH@BNPHLKFG@Enter?5max?5iterations?3?5?$AA@
	call	_prompt
	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	call	_atoi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _maxcount$[ebp], eax
	test	eax, eax
	jne	$LL89@cg_ritz
$LN148@cg_ritz:

; 1450 :       }
; 1451 :   }
; 1452 :   if ( (S->zero != 0) && (S->neg == 0) ) last_eigenvalue = S->lambda;

	cmp	DWORD PTR [ebx+192], 0
	pop	edi
	je	SHORT $LN5@cg_ritz
	cmp	DWORD PTR [ebx+188], 0
	jne	SHORT $LN5@cg_ritz
	fld	QWORD PTR [ebx+112]

; 1453 :   else

	jmp	SHORT $LN400@cg_ritz
$LN8@cg_ritz:

; 1430 :     if ( count < maxcount )

	cmp	ecx, edx
	jge	SHORT $LN7@cg_ritz

; 1431 :       { 
; 1432 : #ifdef FLOAT128
; 1433 :      sprintf(msg,"%3d.    %3.*Qg  converged\n",count,DPREC,trxax);
; 1434 : #elif defined(LONGDOUBLE)
; 1435 :      sprintf(msg,"%3d.    %3.*Lg  converged\n",count,DPREC,trxax);
; 1436 : #else
; 1437 :      sprintf(msg,"%3d.    %3.17g  converged\n",count,trxax);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	mov	ecx, DWORD PTR _msg
	push	OFFSET ??_C@_0BL@FEPPCLLD@?$CF3d?4?5?5?5?5?$CF3?417g?5?5converged?6?$AA@
	push	ecx
	call	_sprintf

; 1438 : #endif 
; 1439 :      outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx

; 1440 :       }
; 1441 :     else  { 

	jmp	SHORT $LN399@cg_ritz
$LN5@cg_ritz:

; 1454 :   last_eigenvalue = evalues[0];

	mov	ecx, DWORD PTR _evalues$[ebp]
	fld	QWORD PTR [ecx]
$LN400@cg_ritz:

; 1455 : 
; 1456 :   free_matrix(h);

	mov	edx, DWORD PTR _h$[ebp]
	fstp	QWORD PTR _last_eigenvalue
	push	edx
	call	_free_matrix

; 1457 :   free_matrix(ah);

	mov	eax, DWORD PTR _ah$[ebp]
	push	eax
	call	_free_matrix

; 1458 :   free_matrix(hx);

	mov	ecx, DWORD PTR _hx$[ebp]
	push	ecx
	call	_free_matrix

; 1459 :   free_matrix(f);

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	call	_free_matrix

; 1460 :   free_matrix(B);

	mov	eax, DWORD PTR _B$[ebp]
	push	eax
	call	_free_matrix

; 1461 :   free_matrix(L);

	mov	ecx, DWORD PTR _L$[ebp]
	push	ecx
	call	_free_matrix

; 1462 :   free_matrix(Q);

	mov	edx, DWORD PTR _Q$[ebp]
	push	edx
	call	_free_matrix

; 1463 :   free_matrix(Linv);

	mov	eax, DWORD PTR _Linv$[ebp]
	push	eax
	call	_free_matrix

; 1464 :   temp_free((char*)hah);

	mov	ecx, DWORD PTR _hah$[ebp]
	push	ecx
	call	_temp_free

; 1465 :   temp_free((char*)xah);

	mov	edx, DWORD PTR _xah$[ebp]
	push	edx
	call	_temp_free

; 1466 :   temp_free((char*)evalues);

	mov	eax, DWORD PTR _evalues$[ebp]
	push	eax
	call	_temp_free

; 1467 :   temp_free((char*)work);

	mov	ecx, DWORD PTR _work$[ebp]
	push	ecx
	call	_temp_free

; 1468 :   free_matrix(evectors);

	mov	edx, DWORD PTR _evectors$[ebp]
	push	edx
	call	_free_matrix
	add	esp, 52					; 00000034H

; 1469 : 
; 1470 :   if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN2@cg_ritz
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $LN3@cg_ritz
$LN2@cg_ritz:

; 1471 :   { free_matrix(mx);

	mov	eax, DWORD PTR _mx$[ebp]
	push	eax
	call	_free_matrix

; 1472 :     free_matrix(mh);

	mov	ecx, DWORD PTR _mh$[ebp]
	push	ecx
	call	_free_matrix
	add	esp, 8
$LN3@cg_ritz:

; 1473 :   }
; 1474 :   if ( S->CN )

	cmp	DWORD PTR [ebx+148], 0
	je	SHORT $LN1@cg_ritz

; 1475 :   { free_matrix(Gf);

	mov	edx, DWORD PTR _Gf$[ebp]
	push	edx
	call	_free_matrix

; 1476 :     free_matrix(Cf);

	mov	eax, DWORD PTR _Cf$[ebp]
	push	eax
	call	_free_matrix

; 1477 :     free_matrix(CCinv);

	mov	ecx, DWORD PTR _CCinv$[ebp]
	push	ecx
	call	_free_matrix
	add	esp, 12					; 0000000cH
$LN1@cg_ritz:

; 1478 :   }
; 1479 : } /* end cg_ritz() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_cg_ritz ENDP
_TEXT	ENDS
PUBLIC	_sparse_metric_dot
; Function compile flags: /Ogtp
;	COMDAT _sparse_metric_dot
_TEXT	SEGMENT
_j$ = -24						; size = 4
_end$ = -20						; size = 4
tv996 = -16						; size = 4
tv832 = -12						; size = 4
tv739 = -12						; size = 4
tv937 = -8						; size = 4
tv338 = -4						; size = 4
_u$ = 8							; size = 4
_v$ = 12						; size = 4
_M$ = 16						; size = 4
_sparse_metric_dot PROC					; COMDAT

; 1829 : { int i,j,end;

	push	ebp
	mov	ebp, esp

; 1830 :   REAL sum;
; 1831 : 
; 1832 :   sum = 0.0;

	mov	ecx, DWORD PTR _M$[ebp]
	fldz
	mov	edx, DWORD PTR [ecx+4]
	sub	esp, 24					; 00000018H

; 1833 :   for ( i = 0 ; i < M->N ; i++ )

	test	edx, edx
	jle	$LN4@sparse_met

; 1830 :   REAL sum;
; 1831 : 
; 1832 :   sum = 0.0;

	mov	eax, DWORD PTR [ecx+60]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+52]
	push	edi

; 1833 :   for ( i = 0 ; i < M->N ; i++ )

	mov	edi, DWORD PTR _u$[ebp]
	mov	DWORD PTR tv338[ebp], eax
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR tv937[ebp], esi
	sub	edi, eax
	mov	DWORD PTR tv996[ebp], edx
	jmp	SHORT $LN6@sparse_met
$LN19@sparse_met:

; 1830 :   REAL sum;
; 1831 : 
; 1832 :   sum = 0.0;

	mov	esi, DWORD PTR tv937[ebp]
$LN6@sparse_met:

; 1834 :   { j = M->IA[i]-A_OFF;

	mov	ecx, DWORD PTR [esi]

; 1835 :     end = M->IA[i+1]-A_OFF;
; 1836 :     sum += M->A[j]*u[i]*v[i];

	mov	edx, DWORD PTR tv338[ebp]
	fld	QWORD PTR [edx+ecx*8-8]
	mov	esi, DWORD PTR [esi+4]
	fmul	QWORD PTR [eax+edi]
	dec	esi

; 1837 :     for ( j++  ; j < end  ; j++ )

	mov	ebx, ecx
	mov	DWORD PTR _end$[ebp], esi
	fmul	QWORD PTR [eax]
	faddp	ST(1), ST(0)
	cmp	ebx, esi
	jge	$LN5@sparse_met
	mov	ecx, esi
	sub	ecx, ebx
	cmp	ecx, 4
	jl	$LN17@sparse_met

; 1839 :        sum += M->A[j]*(u[i]*v[ii] + u[ii]*v[i]);

	mov	ecx, DWORD PTR _M$[ebp]
	mov	ecx, DWORD PTR [ecx+56]
	sub	esi, ebx
	sub	esi, 4
	shr	esi, 2
	inc	esi
	mov	DWORD PTR tv739[ebp], esi
	lea	esi, DWORD PTR [ebx+esi*4]
	lea	edx, DWORD PTR [edx+ebx*8+16]
	lea	ecx, DWORD PTR [ecx+ebx*4+8]
	mov	DWORD PTR _j$[ebp], esi
$LN15@sparse_met:
	mov	esi, DWORD PTR [ecx-8]
	mov	ebx, DWORD PTR _u$[ebp]
	fld	QWORD PTR [ebx+esi*8-8]
	mov	ebx, DWORD PTR _v$[ebp]
	fmul	QWORD PTR [eax]
	add	ecx, 16					; 00000010H
	fld	QWORD PTR [ebx+esi*8-8]
	mov	esi, DWORD PTR [ecx-20]
	fmul	QWORD PTR [eax+edi]
	mov	ebx, DWORD PTR _u$[ebp]
	add	edx, 32					; 00000020H
	dec	DWORD PTR tv739[ebp]
	faddp	ST(1), ST(0)
	fmul	QWORD PTR [edx-48]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+esi*8-8]
	mov	ebx, DWORD PTR _v$[ebp]
	fmul	QWORD PTR [eax]
	fld	QWORD PTR [ebx+esi*8-8]
	mov	esi, DWORD PTR [ecx-16]
	fmul	QWORD PTR [eax+edi]
	mov	ebx, DWORD PTR _u$[ebp]
	faddp	ST(1), ST(0)
	fmul	QWORD PTR [edx-40]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+esi*8-8]
	mov	ebx, DWORD PTR _v$[ebp]
	fmul	QWORD PTR [eax]
	fld	QWORD PTR [ebx+esi*8-8]
	mov	esi, DWORD PTR [ecx-12]
	fmul	QWORD PTR [eax+edi]
	mov	ebx, DWORD PTR _u$[ebp]
	faddp	ST(1), ST(0)
	fmul	QWORD PTR [edx-32]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+esi*8-8]
	mov	ebx, DWORD PTR _v$[ebp]
	fmul	QWORD PTR [eax]
	fld	QWORD PTR [ebx+esi*8-8]
	fmul	QWORD PTR [eax+edi]
	faddp	ST(1), ST(0)
	fmul	QWORD PTR [edx-24]
	faddp	ST(1), ST(0)
	jne	SHORT $LN15@sparse_met
	mov	esi, DWORD PTR _end$[ebp]
	mov	ebx, DWORD PTR _j$[ebp]
$LN17@sparse_met:

; 1837 :     for ( j++  ; j < end  ; j++ )

	cmp	ebx, esi
	jge	SHORT $LN5@sparse_met
	mov	edx, DWORD PTR tv338[ebp]
	lea	ecx, DWORD PTR [edx+ebx*8]
	mov	edx, DWORD PTR _M$[ebp]
	mov	DWORD PTR tv832[ebp], ecx
	mov	ecx, DWORD PTR [edx+56]
	lea	edx, DWORD PTR [ecx+ebx*4]
	sub	esi, ebx
$LC3@sparse_met:

; 1838 :      { int ii = M->JA[j]-A_OFF;

	mov	ecx, DWORD PTR [edx]

; 1839 :        sum += M->A[j]*(u[i]*v[ii] + u[ii]*v[i]);

	mov	ebx, DWORD PTR _u$[ebp]
	fld	QWORD PTR [ebx+ecx*8-8]
	mov	ebx, DWORD PTR _v$[ebp]
	fmul	QWORD PTR [eax]
	add	edx, 4
	fld	QWORD PTR [ebx+ecx*8-8]
	mov	ecx, DWORD PTR tv832[ebp]
	fmul	QWORD PTR [eax+edi]
	add	ecx, 8
	dec	esi
	mov	DWORD PTR tv832[ebp], ecx
	faddp	ST(1), ST(0)
	fmul	QWORD PTR [ecx-8]
	faddp	ST(1), ST(0)
	jne	SHORT $LC3@sparse_met
$LN5@sparse_met:

; 1833 :   for ( i = 0 ; i < M->N ; i++ )

	mov	edx, DWORD PTR tv937[ebp]
	add	edx, 4
	add	eax, 8
	dec	DWORD PTR tv996[ebp]
	mov	DWORD PTR tv937[ebp], edx
	jne	$LN19@sparse_met
	pop	edi
	pop	esi
	pop	ebx
$LN4@sparse_met:

; 1840 :      }
; 1841 :   }
; 1842 :   return sum;
; 1843 : } /* end sparse_metric_dot() */

	mov	esp, ebp
	pop	ebp
	ret	0
_sparse_metric_dot ENDP
_TEXT	ENDS
PUBLIC	_sp_solution
EXTRN	_vec_mat_mul:PROC
EXTRN	_matvec_mul:PROC
EXTRN	_sp_solve_func:DWORD
; Function compile flags: /Ogtp
;	COMDAT _sp_solution
_TEXT	SEGMENT
_W$ = 8							; size = 4
_S$ = 8							; size = 4
_rhs$ = 12						; size = 4
_X$ = 16						; size = 4
_mtype$ = 20						; size = 4
_sp_solution PROC					; COMDAT

; 1909 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 1910 :   REAL *Y; /* working full-size vector */
; 1911 :   REAL *Z; /* low rank working vector */
; 1912 :   REAL *W; /* low rank working vector */
; 1913 :   int i;
; 1914 : 
; 1915 :   if ( S->low_rank == 0 )

	mov	esi, DWORD PTR _S$[ebp]
	cmp	DWORD PTR [esi+208], 0
	jne	SHORT $LN7@sp_solutio

; 1916 :   { /* no low-rank update */
; 1917 :     (*sp_solve_func)(S,rhs,X,mtype);

	mov	eax, DWORD PTR _mtype$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR _rhs$[ebp]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR _sp_solve_func
	add	esp, 16					; 00000010H
	pop	esi

; 1940 : 
; 1941 : }  // sp_solution()

	pop	ebp
	ret	0
$LN7@sp_solutio:

; 1918 :     return;
; 1919 :   }
; 1920 : 
; 1921 :   /* rest is solution of system with low rank update */
; 1922 :   Y = (REAL*)temp_calloc(S->N,sizeof(REAL));

	mov	eax, DWORD PTR [esi+4]
	push	ebx
	push	edi
	push	1922					; 00000782H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc

; 1923 :   Z = (REAL*)temp_calloc(S->low_rank, sizeof(REAL));

	mov	ecx, DWORD PTR [esi+208]
	push	1923					; 00000783H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	ecx
	mov	edi, eax
	call	_kb_temp_calloc

; 1924 :   W = (REAL*)temp_calloc(S->low_rank, sizeof(REAL));

	mov	edx, DWORD PTR [esi+208]
	push	1924					; 00000784H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	edx
	mov	ebx, eax
	call	_kb_temp_calloc

; 1925 :   (*sp_solve_func)(S,rhs,Y,mtype);

	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	DWORD PTR _W$[ebp], eax
	mov	eax, DWORD PTR _mtype$[ebp]
	push	eax
	push	edi
	push	ecx
	push	esi
	call	DWORD PTR _sp_solve_func

; 1926 :   matvec_mul(S->low_rank_vectors,Y,Z,S->low_rank,S->low_rank_vecsize);

	mov	edx, DWORD PTR [esi+212]
	mov	eax, DWORD PTR [esi+208]
	mov	ecx, DWORD PTR [esi+216]
	add	esp, 64					; 00000040H
	push	edx
	push	eax
	push	ebx
	push	edi
	push	ecx
	call	_matvec_mul

; 1927 :   matvec_mul(S->low_rank_form,Z,W,S->low_rank,S->low_rank);

	mov	eax, DWORD PTR [esi+208]
	mov	edx, DWORD PTR _W$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR [esi+220]
	push	edx
	push	ebx
	push	eax
	call	_matvec_mul

; 1928 :   matvec_mul(S->low_rank_inverse_form,W,Z,S->low_rank,S->low_rank);

	mov	eax, DWORD PTR [esi+208]
	mov	ecx, DWORD PTR _W$[ebp]
	mov	edx, DWORD PTR [esi+224]
	push	eax
	push	eax
	push	ebx
	push	ecx
	push	edx
	call	_matvec_mul

; 1929 :   vec_mat_mul(Z,S->low_rank_vectors,Y,S->low_rank,S->low_rank_vecsize);

	mov	eax, DWORD PTR [esi+212]
	mov	ecx, DWORD PTR [esi+208]
	mov	edx, DWORD PTR [esi+216]
	push	eax
	push	ecx
	push	edi
	push	edx
	push	ebx
	call	_vec_mat_mul

; 1930 :   for ( i = 0 ;  i < S->low_rank_vecsize ; i++ )

	xor	eax, eax
	add	esp, 80					; 00000050H
	cmp	DWORD PTR [esi+212], eax
	jle	SHORT $LN4@sp_solutio
	mov	edx, DWORD PTR _rhs$[ebp]
	mov	ecx, edi
	sub	edx, edi
$LL6@sp_solutio:

; 1931 :     Y[i] = rhs[i] - Y[i];

	fld	QWORD PTR [edx+ecx]
	inc	eax
	fsub	QWORD PTR [ecx]
	add	ecx, 8
	fstp	QWORD PTR [ecx-8]
	cmp	eax, DWORD PTR [esi+212]
	jl	SHORT $LL6@sp_solutio
$LN4@sp_solutio:

; 1932 :   for ( ; i < S->N ; i++ )

	cmp	eax, DWORD PTR [esi+4]
	jge	SHORT $LN1@sp_solutio
	mov	edx, DWORD PTR _rhs$[ebp]
	lea	ecx, DWORD PTR [edi+eax*8]
	sub	edx, edi
	npad	7
$LL3@sp_solutio:

; 1933 :     Y[i] = rhs[i];

	fld	QWORD PTR [ecx+edx]
	inc	eax
	fstp	QWORD PTR [ecx]
	add	ecx, 8
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL3@sp_solutio
$LN1@sp_solutio:

; 1934 :     
; 1935 :   (*sp_solve_func)(S,Y,X,mtype);

	mov	eax, DWORD PTR _mtype$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	push	eax
	push	ecx
	push	edi
	push	esi
	call	DWORD PTR _sp_solve_func

; 1936 : 
; 1937 :   temp_free((char*)Y);

	push	edi
	call	_temp_free

; 1938 :   temp_free((char*)Z);

	push	ebx
	call	_temp_free

; 1939 :   temp_free((char*)W);

	mov	edx, DWORD PTR _W$[ebp]
	push	edx
	call	_temp_free
	add	esp, 28					; 0000001cH
	pop	edi
	pop	ebx
	pop	esi

; 1940 : 
; 1941 : }  // sp_solution()

	pop	ebp
	ret	0
_sp_solution ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	_sp_factor
EXTRN	_sp_solve_multi_func:DWORD
EXTRN	_sp_factor_func:DWORD
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _sp_factor
_TEXT	SEGMENT
_S$ = 8							; size = 4
_mtype$ = 12						; size = 4
_sp_factor PROC						; COMDAT

; 1952 : { 

	push	ebp
	mov	ebp, esp

; 1953 :   (*sp_factor_func)(S,mtype);  /* factor just the matrix */

	mov	eax, DWORD PTR _mtype$[ebp]
	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	push	eax
	push	esi
	call	DWORD PTR _sp_factor_func

; 1954 : 
; 1955 :   if ( S->low_rank )

	mov	eax, DWORD PTR [esi+208]
	add	esp, 8
	test	eax, eax
	je	$LN4@sp_factor

; 1956 :   { REAL **W = dmatrix(0,S->low_rank-1,0,S->N-1);

	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	push	edi
	push	1956					; 000007a4H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	dec	ecx
	push	ecx
	push	0
	dec	eax
	push	eax
	push	0
	call	_kb_dmatrix

; 1957 :     REAL **Z = dmatrix(0,S->low_rank-1,0,S->low_rank-1);

	push	1957					; 000007a5H
	mov	edi, eax
	mov	eax, DWORD PTR [esi+208]
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 1958 :     int i;
; 1959 : 
; 1960 :     (*sp_solve_multi_func)(S,S->low_rank_vectors,W,S->low_rank,mtype);

	mov	edx, DWORD PTR _mtype$[ebp]
	mov	ecx, DWORD PTR [esi+216]
	push	edx
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+208]
	push	eax
	push	edi
	push	ecx
	push	esi
	call	DWORD PTR _sp_solve_multi_func

; 1961 :     mat_mul_tr(S->low_rank_vectors,W,Z,S->low_rank,S->low_rank_vecsize,
; 1962 :          S->low_rank);

	mov	eax, DWORD PTR [esi+208]
	mov	edx, DWORD PTR [esi+212]
	add	esp, 68					; 00000044H
	push	eax
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+216]
	push	ebx
	push	edi
	push	eax
	call	_mat_mul_tr

; 1963 :     mat_mult(S->low_rank_form,Z,S->low_rank_inverse_form,S->low_rank,
; 1964 :          S->low_rank,S->low_rank);

	mov	eax, DWORD PTR [esi+208]
	mov	ecx, DWORD PTR [esi+224]
	mov	edx, DWORD PTR [esi+220]
	push	eax
	push	eax
	push	eax
	push	ecx
	push	ebx
	push	edx
	call	_mat_mult

; 1965 :     for ( i = 0 ; i < S->low_rank ; i++ )

	xor	eax, eax
	add	esp, 48					; 00000030H
	cmp	DWORD PTR [esi+208], eax
	jle	SHORT $LN1@sp_factor
	fld1
$LN3@sp_factor:
	mov	ecx, DWORD PTR [esi+224]
	mov	edx, DWORD PTR [ecx+eax*4]

; 1966 :       S->low_rank_inverse_form[i][i] += 1;

	fld	QWORD PTR [edx+eax*8]
	lea	ecx, DWORD PTR [edx+eax*8]
	fadd	ST(0), ST(1)
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR [esi+208]
	jl	SHORT $LN3@sp_factor

; 1965 :     for ( i = 0 ; i < S->low_rank ; i++ )

	fstp	ST(0)
$LN1@sp_factor:

; 1967 :     mat_inv(S->low_rank_inverse_form,S->low_rank);

	mov	eax, DWORD PTR [esi+208]
	mov	ecx, DWORD PTR [esi+224]
	push	eax
	push	ecx
	call	_mat_inv

; 1968 :     free_matrix(W);

	push	edi
	call	_free_matrix

; 1969 :     free_matrix(Z);

	push	ebx
	call	_free_matrix
	add	esp, 16					; 00000010H
	pop	edi
	pop	ebx
$LN4@sp_factor:
	pop	esi

; 1970 :   }
; 1971 : }  /* end sp_factor() */

	pop	ebp
	ret	0
_sp_factor ENDP
_TEXT	ENDS
PUBLIC	_sp_aug_solve
; Function compile flags: /Ogtp
;	COMDAT _sp_aug_solve
_TEXT	SEGMENT
_i$89063 = -4						; size = 4
_S$ = 8							; size = 4
_X$ = 12						; size = 4
_B$ = 16						; size = 4
_T1$ = 20						; size = 4
_T2$ = 24						; size = 4
_T3$ = 28						; size = 4
_sp_aug_solve PROC					; COMDAT

; 45   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 46   :   if ( sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, 0
	push	ebx

; 47   :   { int i,j;
; 48   :     memset(T1,0,S->CN*sizeof(REAL));

	mov	ebx, DWORD PTR _T1$[ebp]
	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [esi+148]
	push	edi
	je	$LN22@sp_aug_sol
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	0
	push	ebx
	call	_memset

; 49   :     for ( i = 0 ; i < S->CN ; i++ )

	xor	edi, edi
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _i$89063[ebp], edi
	cmp	DWORD PTR [esi+148], edi
	jle	SHORT $LN19@sp_aug_sol

; 47   :   { int i,j;
; 48   :     memset(T1,0,S->CN*sizeof(REAL));

	mov	edx, DWORD PTR [esi+172]
	mov	ecx, ebx
	mov	ebx, DWORD PTR _X$[ebp]
	npad	6
$LL21@sp_aug_sol:

; 50   :       for ( j = S->CIA[i] ; j < S->CIA[i+1] ; j++ )

	mov	eax, DWORD PTR [edx+edi*4]
	cmp	eax, DWORD PTR [edx+edi*4+4]
	jge	SHORT $LN20@sp_aug_sol
	npad	7
$LL18@sp_aug_sol:

; 51   :          T1[i] += S->CA[j]*X[S->CJA[j]];

	mov	edx, DWORD PTR [esi+176]
	mov	edx, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [esi+180]
	fld	QWORD PTR [ebx+edx*8]
	fmul	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR _i$89063[ebp]
	inc	eax
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	edx, DWORD PTR [esi+172]
	cmp	eax, DWORD PTR [edx+edi*4+4]
	jl	SHORT $LL18@sp_aug_sol
$LN20@sp_aug_sol:

; 49   :     for ( i = 0 ; i < S->CN ; i++ )

	inc	edi
	add	ecx, 8
	mov	DWORD PTR _i$89063[ebp], edi
	cmp	edi, DWORD PTR [esi+148]
	jl	SHORT $LL21@sp_aug_sol
	mov	ebx, DWORD PTR _T1$[ebp]
$LN19@sp_aug_sol:

; 52   :     if ( B )

	mov	edx, DWORD PTR _B$[ebp]
	test	edx, edx
	je	SHORT $LN12@sp_aug_sol

; 53   :       for ( i = 0 ; i < S->CN ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR [esi+148], ecx
	jle	SHORT $LN12@sp_aug_sol
	mov	eax, ebx
	sub	edx, ebx
$LL14@sp_aug_sol:

; 54   :         T1[i] += B[i]; /* corrections */

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+148]
	jl	SHORT $LL14@sp_aug_sol
$LN12@sp_aug_sol:

; 55   : #ifdef BLAS
; 56   :     if ( blas_flag )
; 57   :       LD_block_solve(S->CHinvCinv,T1,T2,S->CN);
; 58   :     else
; 59   : #endif
; 60   :     matvec_mul(S->CHinvCinv,T1,T2,S->CN,S->CN);

	mov	eax, DWORD PTR [esi+148]
	mov	edi, DWORD PTR _T2$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR [esi+168]
	push	edi
	push	ebx
	push	eax
	call	_matvec_mul

; 61   :     memset(T3,0,S->N*sizeof(REAL));

	mov	ecx, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR _T3$[ebp]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	0
	push	ebx
	call	_memset

; 62   :     for ( i = 0 ; i < S->CN ; i++ )

	xor	edx, edx
	add	esp, 32					; 00000020H
	cmp	DWORD PTR [esi+148], edx
	jle	SHORT $LN9@sp_aug_sol
	mov	ecx, DWORD PTR [esi+172]
$LL11@sp_aug_sol:

; 63   :       for ( j = S->CIA[i] ; j < S->CIA[i+1] ; j++ )

	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR [ecx+edx*4+4]
	jge	SHORT $LN10@sp_aug_sol
	npad	2
$LL37@sp_aug_sol:

; 64   :         T3[S->CJA[j]] += S->CA[j]*T2[i];

	mov	ecx, DWORD PTR [esi+176]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	ebx, DWORD PTR _T3$[ebp]
	lea	ecx, DWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [esi+180]
	fld	QWORD PTR [ebx+eax*8]
	inc	eax
	fmul	QWORD PTR [edi]
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+172]
	cmp	eax, DWORD PTR [ecx+edx*4+4]
	jl	SHORT $LL37@sp_aug_sol
$LN10@sp_aug_sol:

; 62   :     for ( i = 0 ; i < S->CN ; i++ )

	inc	edx
	add	edi, 8
	cmp	edx, DWORD PTR [esi+148]
	jl	SHORT $LL11@sp_aug_sol
	mov	ebx, DWORD PTR _T3$[ebp]
$LN9@sp_aug_sol:

; 65   :     sp_solution(S,T3,T3,MKL_INDEF);

	push	-2					; fffffffeH
	push	ebx
	push	ebx
	push	esi
	call	_sp_solution
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 80   :   }
; 81   : } // end sp_aug_solve()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@sp_aug_sol:

; 66   :   }
; 67   :   else
; 68   :   { int i;
; 69   :     matvec_mul(S->C,X,T1,S->CN,S->N);

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _X$[ebp]
	push	edx
	mov	edx, DWORD PTR [esi+160]
	push	eax
	push	ebx
	push	ecx
	push	edx
	call	_matvec_mul

; 70   :     if ( B )

	mov	edx, DWORD PTR _B$[ebp]
	add	esp, 20					; 00000014H
	test	edx, edx
	je	SHORT $LN1@sp_aug_sol

; 71   :       for ( i = 0 ; i < S->CN ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR [esi+148], ecx
	jle	SHORT $LN1@sp_aug_sol
	mov	eax, ebx
	sub	edx, ebx
	npad	4
$LL3@sp_aug_sol:

; 72   :         T1[i] += B[i]; /* corrections */

	fld	QWORD PTR [eax+edx]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+148]
	jl	SHORT $LL3@sp_aug_sol
$LN1@sp_aug_sol:

; 73   : #ifdef BLAS
; 74   :     if ( blas_flag )
; 75   :       LD_block_solve(S->CHinvCinv,T1,T2,S->CN);
; 76   :     else
; 77   : #endif
; 78   :     matvec_mul(S->CHinvCinv,T1,T2,S->CN,S->CN); /* Lagrange multipliers */

	mov	eax, DWORD PTR [esi+148]
	mov	edi, DWORD PTR _T2$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR [esi+168]
	push	edi
	push	ebx
	push	eax
	call	_matvec_mul

; 79   :     vec_mat_mul(T2,S->HinvC,T3,S->CN,S->N);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+148]
	mov	eax, DWORD PTR _T3$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [esi+164]
	push	edx
	push	eax
	push	ecx
	push	edi
	call	_vec_mat_mul
	add	esp, 40					; 00000028H
	pop	edi
	pop	esi
	pop	ebx

; 80   :   }
; 81   : } // end sp_aug_solve()

	mov	esp, ebp
	pop	ebp
	ret	0
_sp_aug_solve ENDP
_TEXT	ENDS
PUBLIC	_bk_mul
; Function compile flags: /Ogtp
;	COMDAT _bk_mul
_TEXT	SEGMENT
tv405 = 8						; size = 4
_S$ = 8							; size = 4
_w$ = 12						; size = 4
_v$ = 16						; size = 4
_bk_mul	PROC						; COMDAT

; 94   : { int row,col,i;

	push	ebp
	mov	ebp, esp
	push	ebx

; 95   : 
; 96   :   PROF_START(hessian_mul);
; 97   : 
; 98   :   memset((char*)v,0,S->N*sizeof(REAL));

	mov	ebx, DWORD PTR _v$[ebp]
	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [esi+4]
	add	eax, eax
	add	eax, eax
	push	edi
	add	eax, eax
	push	eax
	push	0
	push	ebx
	call	_memset

; 99   :   for ( row = 0 ; row < S->N ; row++ )

	xor	edi, edi
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN9@bk_mul
	mov	edx, DWORD PTR _w$[ebp]
	mov	eax, ebx
	sub	eax, edx
	mov	DWORD PTR tv405[ebp], eax
$LL11@bk_mul:
	mov	ecx, DWORD PTR [esi+52]
	lea	eax, DWORD PTR [ecx+edi*4]

; 100  :   { for ( i = S->IA[row]-A_OFF ; i < S->IA[row+1]-A_OFF ; i++ )

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	dec	ecx
	dec	eax
	cmp	ecx, eax
	jge	SHORT $LN10@bk_mul
$LL8@bk_mul:

; 101  :     { col = S->JA[i] - A_OFF;

	mov	eax, DWORD PTR [esi+56]

; 102  :       v[row] += S->A[i]*w[col];

	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+ecx*8]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ebx, DWORD PTR _w$[ebp]
	fmul	QWORD PTR [ebx+eax*8-8]
	mov	ebx, DWORD PTR tv405[ebp]
	dec	eax
	fadd	QWORD PTR [ebx+edx]
	fstp	QWORD PTR [ebx+edx]

; 103  :       if ( col != row ) v[col] += S->A[i]*w[row];

	cmp	eax, edi
	je	SHORT $LN20@bk_mul
	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR _v$[ebp]
	fmul	QWORD PTR [edx]
	fadd	QWORD PTR [ebx+eax*8]
	fstp	QWORD PTR [ebx+eax*8]
	jmp	SHORT $LN7@bk_mul
$LN20@bk_mul:
	mov	ebx, DWORD PTR _v$[ebp]
$LN7@bk_mul:

; 100  :   { for ( i = S->IA[row]-A_OFF ; i < S->IA[row+1]-A_OFF ; i++ )

	mov	eax, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [eax+edi*4+4]
	inc	ecx
	dec	eax
	cmp	ecx, eax
	jl	SHORT $LL8@bk_mul
$LN10@bk_mul:

; 99   :   for ( row = 0 ; row < S->N ; row++ )

	inc	edi
	add	edx, 8
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL11@bk_mul
$LN9@bk_mul:

; 104  :     }
; 105  :   }
; 106  :   if ( (S->CN > 0) && S->CHinvCinv )

	cmp	DWORD PTR [esi+148], 0
	jle	SHORT $LN4@bk_mul
	cmp	DWORD PTR [esi+168], 0
	je	SHORT $LN4@bk_mul

; 107  :   { /* project back */
; 108  :      REAL *tempv = (REAL*)temp_calloc(2*S->N,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+4]
	push	108					; 0000006cH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	add	ecx, ecx
	push	8
	push	ecx
	call	_kb_temp_calloc

; 109  :      REAL *tempvv = tempv + S->N;

	mov	edx, DWORD PTR [esi+4]
	mov	edi, eax

; 110  :      sp_aug_solve(S,v,NULL,tempv,tempvv,tempv);

	push	edi
	lea	eax, DWORD PTR [edi+edx*8]
	push	eax
	push	edi
	push	0
	push	ebx
	push	esi
	call	_sp_aug_solve

; 111  :      for ( i = 0 ; i < S->N ; i++ ) v[i] -= tempv[i];

	xor	ecx, ecx
	add	esp, 40					; 00000028H
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN1@bk_mul
	mov	edx, edi
	mov	eax, ebx
	sub	edx, ebx
	npad	6
$LL3@bk_mul:
	fld	QWORD PTR [eax]
	inc	ecx
	fsub	QWORD PTR [edx+eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LL3@bk_mul
$LN1@bk_mul:

; 112  :      temp_free((char*)tempv);

	push	edi
	call	_temp_free
	add	esp, 4
$LN4@bk_mul:
	pop	edi
	pop	esi
	pop	ebx

; 113  :   }
; 114  : 
; 115  :   PROF_FINISH(hessian_mul);
; 116  : } /* end bk_mul() */

	pop	ebp
	ret	0
_bk_mul	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@IGOGGAJB@Constraints?5not?5independent?0?5or?5@ ; `string'
PUBLIC	??_C@_0DB@FBMHGLLP@sparse_constraints?5need?5ysmp?5off@ ; `string'
PUBLIC	_BK_hess_project_setup
EXTRN	_eigen_pos:DWORD
EXTRN	_eigen_neg:DWORD
EXTRN	_mat_inv_sym:PROC
EXTRN	_sp_CHinvC_func:DWORD
;	COMDAT ??_C@_0DH@IGOGGAJB@Constraints?5not?5independent?0?5or?5@
CONST	SEGMENT
??_C@_0DH@IGOGGAJB@Constraints?5not?5independent?0?5or?5@ DB 'Constraints'
	DB	' not independent, or Hessian too singular.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@FBMHGLLP@sparse_constraints?5need?5ysmp?5off@
CONST	SEGMENT
??_C@_0DB@FBMHGLLP@sparse_constraints?5need?5ysmp?5off@ DB 'sparse_constr'
	DB	'aints need ysmp off (mindeg mode).', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _BK_hess_project_setup
_TEXT	SEGMENT
_S$ = 8							; size = 4
_BK_hess_project_setup PROC				; COMDAT

; 615  : { int i;

	push	ebp
	mov	ebp, esp
	push	esi

; 616  :   int con_index=0;
; 617  : 
; 618  :   PROF_START(hessian_project_setup);
; 619  : 
; 620  :   if ( S->CN == 0 ) goto set_counts;

	mov	esi, DWORD PTR _S$[ebp]
	cmp	DWORD PTR [esi+148], 0
	je	$LN20@BK_hess_pr

; 621  :   if ( augmented_hessian_mode ) goto adjust_index;

	cmp	DWORD PTR _augmented_hessian_mode, 0
	push	edi
	jne	$LN19@BK_hess_pr

; 622  : 
; 623  :   if ( !sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, 0
	jne	SHORT $LN8@BK_hess_pr

; 624  :   {
; 625  :     /* HinvC */
; 626  :     if ( S->HinvC ) free_matrix(S->HinvC);

	mov	eax, DWORD PTR [esi+164]
	test	eax, eax
	je	SHORT $LN11@BK_hess_pr
	push	eax
	call	_free_matrix
	add	esp, 4
$LN11@BK_hess_pr:

; 627  :     S->HinvC = dmatrix(0,S->CN-1,0,S->N-1);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+148]
	push	627					; 00000273H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	dec	eax
	push	eax
	push	0
	dec	ecx
	push	ecx
	push	0
	call	_kb_dmatrix

; 628  :     for ( i = 0 ; i < S->CN ; i++ )

	xor	edi, edi
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+164], eax
	cmp	DWORD PTR [esi+148], edi
	jle	SHORT $LN8@BK_hess_pr
$LL10@BK_hess_pr:

; 629  :        sp_solution(S,S->C[i],S->HinvC[i],MKL_INDEF);

	mov	edx, DWORD PTR [esi+164]
	mov	eax, DWORD PTR [edx+edi*4]
	mov	ecx, DWORD PTR [esi+160]
	mov	edx, DWORD PTR [ecx+edi*4]
	push	-2					; fffffffeH
	push	eax
	push	edx
	push	esi
	call	_sp_solution
	inc	edi
	add	esp, 16					; 00000010H
	cmp	edi, DWORD PTR [esi+148]
	jl	SHORT $LL10@BK_hess_pr
$LN8@BK_hess_pr:

; 630  :   }
; 631  : 
; 632  :   if ( S->CHinvCinv ) free_matrix(S->CHinvCinv);

	mov	eax, DWORD PTR [esi+168]
	test	eax, eax
	je	SHORT $LN7@BK_hess_pr
	push	eax
	call	_free_matrix
	add	esp, 4
$LN7@BK_hess_pr:

; 633  : 
; 634  : #ifdef BLAS
; 635  :   if ( blas_flag )
; 636  :   { int fillsize = ((S->CN+BLAS_BLOCKSIZE)*(S->CN+BLAS_BLOCKSIZE+1))/2;
; 637  :     S->CHinvCinv = (REAL**)temp_calloc(S->CN,sizeof(REAL*));
; 638  :     S->CHinvCinv[0] = (REAL*)temp_calloc(fillsize,sizeof(REAL));
; 639  :     for ( i = 0 ; i < S->CN ; i += BLAS_BLOCKSIZE )
; 640  :     { int j;
; 641  :       for ( j = i ; (j < i+BLAS_BLOCKSIZE) && (j < S->CN-1) ; j++ )
; 642  :       { 
; 643  :         S->CHinvCinv[j+1] = S->CHinvCinv[j] + i + BLAS_BLOCKSIZE;
; 644  :       }
; 645  :     }
; 646  : 
; 647  :   }
; 648  :   else
; 649  : #endif
; 650  :   S->CHinvCinv = dmatrix(0,S->CN-1,0,S->CN-1);

	mov	eax, DWORD PTR [esi+148]
	push	650					; 0000028aH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+168], eax

; 651  : 
; 652  :   if ( sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, 0
	je	SHORT $LN6@BK_hess_pr

; 653  :   {
; 654  :     if ( sp_CHinvC_func == NULL )

	cmp	DWORD PTR _sp_CHinvC_func, 0
	jne	SHORT $LN5@BK_hess_pr

; 655  :        kb_error(2445,"sparse_constraints need ysmp off (mindeg mode).\n",
; 656  :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DB@FBMHGLLP@sparse_constraints?5need?5ysmp?5off@
	push	2445					; 0000098dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN5@BK_hess_pr:

; 657  :     (*sp_CHinvC_func)(S);    

	push	esi
	call	DWORD PTR _sp_CHinvC_func
	add	esp, 4

; 658  :   }
; 659  :   else

	jmp	SHORT $LN4@BK_hess_pr
$LN6@BK_hess_pr:

; 660  :   {
; 661  :     /* CHinvCinv */
; 662  : #ifdef BLAS
; 663  :     if ( blas_flag )
; 664  :     { for ( i = 0 ; i <  S->CN ; i += BLAS_BLOCKSIZE )
; 665  :       { int rowcount = (S->CN-i < BLAS_BLOCKSIZE) ? S->CN-i : BLAS_BLOCKSIZE;
; 666  :         int colcount = (S->CN < i+BLAS_BLOCKSIZE) ? S->CN : i+BLAS_BLOCKSIZE;
; 667  : 
; 668  :         int transa = 'T';
; 669  :         int transb = 'N';
; 670  :         REAL alpha = 1.0;
; 671  :         REAL beta  = 0.0;
; 672  :         int stridea = i+BLAS_BLOCKSIZE; 
; 673  :         int strideb = S->C[1]-S->C[0];  /* WHoops! rows individually alloc! */
; 674  :         int stridec = S->CHinvCinv[1] - S->CHinvCinv[0];
; 675  : 
; 676  :         mat_mul_tr(S->HinvC+i,S->C,S->CHinvCinv+i,rowcount,S->N,colcount); 
; 677  : 
; 678  : /*      DGEMM(&transa,&transb,&rowcount,&colcount,&S->N,&alpha,S->HinvC[i],
; 679  :                &stridea,S->C[0],&strideb,&beta,S->CHinvCinv[i],&stridec);
; 680  : */
; 681  :       }
; 682  :     }    
; 683  :     else 
; 684  : #endif
; 685  :       mat_mul_tr(S->HinvC,S->C,S->CHinvCinv,S->CN,S->N,S->CN);

	mov	ecx, DWORD PTR [esi+148]
	mov	edx, DWORD PTR [esi+4]
	push	ecx
	push	edx
	push	ecx
	mov	ecx, DWORD PTR [esi+164]
	push	eax
	mov	eax, DWORD PTR [esi+160]
	push	eax
	push	ecx
	call	_mat_mul_tr
	add	esp, 24					; 00000018H
$LN4@BK_hess_pr:

; 686  :   }
; 687  : 
; 688  : #ifdef BLAS
; 689  :   if ( blas_flag )
; 690  :     con_index = LD_block_factor(S->CHinvCinv,S->CN);
; 691  :   else
; 692  : #endif
; 693  : 
; 694  : /* Kludge here since mat_inv() doesn't calculate index correctly */
; 695  : /*
; 696  :   con_index = matrix_index(S->CHinvCinv,S->CN);
; 697  :   mat_inv(S->CHinvCinv,S->CN);
; 698  : */
; 699  :   con_index = mat_inv_sym(S->CHinvCinv,S->CN);

	mov	edx, DWORD PTR [esi+148]
	mov	eax, DWORD PTR [esi+168]
	push	edx
	push	eax
	call	_mat_inv_sym
	mov	edi, eax
	add	esp, 8

; 700  : 
; 701  : 
; 702  :  if ( con_index < 0 )

	test	edi, edi
	jns	SHORT $adjust_index$89481

; 703  :      kb_error(1823,"Constraints not independent, or Hessian too singular.\n",
; 704  :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DH@IGOGGAJB@Constraints?5not?5independent?0?5or?5@
	push	1823					; 0000071fH
	call	_kb_error
	add	esp, 12					; 0000000cH
$adjust_index$89481:

; 705  : 
; 706  : adjust_index:
; 707  :   /* adjust index for constraints */
; 708  :   if ( augmented_hessian_mode )

	cmp	DWORD PTR _augmented_hessian_mode, 0
	je	SHORT $LN2@BK_hess_pr
$LN19@BK_hess_pr:

; 709  :   { S->neg -= (S->CN - S->degencon);

	mov	ecx, DWORD PTR [esi+196]
	mov	eax, ecx
	sub	eax, DWORD PTR [esi+148]
	pop	edi
	add	DWORD PTR [esi+188], eax

; 710  :     S->pos -= (S->CN - S->degencon);

	add	DWORD PTR [esi+184], eax

; 711  :     S->zero -= S->degencon;

	sub	DWORD PTR [esi+192], ecx

; 716  :   }
; 717  : set_counts:
; 718  :   eigen_neg = S->neg; eigen_pos = S->pos;

	mov	ecx, DWORD PTR [esi+188]
	mov	DWORD PTR _eigen_neg, ecx
	mov	edx, DWORD PTR [esi+184]
	mov	DWORD PTR _eigen_pos, edx
$set_counts$89479:
	pop	esi

; 719  : 
; 720  :   PROF_FINISH(hessian_project_setup);
; 721  : } /* end BK_hess_project_setup */

	pop	ebp
	ret	0
$LN2@BK_hess_pr:

; 712  :   }
; 713  :   else 
; 714  :   { S->neg -= con_index;

	sub	DWORD PTR [esi+188], edi

; 715  :     S->pos -= S->CN - con_index;

	sub	edi, DWORD PTR [esi+148]

; 716  :   }
; 717  : set_counts:
; 718  :   eigen_neg = S->neg; eigen_pos = S->pos;

	mov	eax, DWORD PTR [esi+188]
	add	DWORD PTR [esi+184], edi
	mov	DWORD PTR _eigen_neg, eax
	mov	ecx, DWORD PTR [esi+184]
	pop	edi
	mov	DWORD PTR _eigen_pos, ecx
	pop	esi

; 719  : 
; 720  :   PROF_FINISH(hessian_project_setup);
; 721  : } /* end BK_hess_project_setup */

	pop	ebp
	ret	0
$LN20@BK_hess_pr:

; 716  :   }
; 717  : set_counts:
; 718  :   eigen_neg = S->neg; eigen_pos = S->pos;

	mov	edx, DWORD PTR [esi+188]
	mov	DWORD PTR _eigen_neg, edx
	mov	eax, DWORD PTR [esi+184]
	mov	DWORD PTR _eigen_pos, eax
	pop	esi

; 719  : 
; 720  :   PROF_FINISH(hessian_project_setup);
; 721  : } /* end BK_hess_project_setup */

	pop	ebp
	ret	0
_BK_hess_project_setup ENDP
_TEXT	ENDS
PUBLIC	_BK_hess_project
; Function compile flags: /Ogtp
;	COMDAT _BK_hess_project
_TEXT	SEGMENT
_T1$ = 8						; size = 4
_S$ = 8							; size = 4
_B$ = 12						; size = 4
_x$ = 16						; size = 4
_BK_hess_project PROC					; COMDAT

; 736  : { REAL *T1,*T2,*T3;

	push	ebp
	mov	ebp, esp
	push	esi

; 737  :   int i;
; 738  :   if ( S->CN == 0 ) return;

	mov	esi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [esi+148]
	test	eax, eax
	je	SHORT $LN5@BK_hess_pr@2

; 739  :   T1 = (REAL *)temp_calloc(2*S->CN+S->N,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+4]
	push	ebx
	push	edi
	push	739					; 000002e3H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	lea	edx, DWORD PTR [ecx+eax*2]
	push	8
	push	edx
	call	_kb_temp_calloc
	mov	ebx, eax

; 740  :   T2 = T1 + S->CN;

	mov	eax, DWORD PTR [esi+148]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	lea	ecx, DWORD PTR [eax+ebx]

; 741  :   T3 = T2 + S->CN;

	lea	edi, DWORD PTR [eax+ecx]

; 742  :   sp_aug_solve(S,B,NULL,T1,T2,T3);

	mov	eax, DWORD PTR _B$[ebp]
	push	edi
	push	ecx
	push	ebx
	push	0
	push	eax
	push	esi
	mov	DWORD PTR _T1$[ebp], ebx
	call	_sp_aug_solve

; 743  :   for ( i = 0 ; i < S->N ; i++ )

	xor	ecx, ecx
	add	esp, 40					; 00000028H
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN1@BK_hess_pr@2
	mov	edx, DWORD PTR _B$[ebp]
	mov	ebx, DWORD PTR _x$[ebp]
	sub	edx, edi
	mov	eax, edi
	sub	ebx, edi
$LL3@BK_hess_pr@2:

; 744  :      x[i] = B[i] - T3[i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fsub	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [ebx+eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LL3@BK_hess_pr@2

; 743  :   for ( i = 0 ; i < S->N ; i++ )

	mov	ebx, DWORD PTR _T1$[ebp]
$LN1@BK_hess_pr@2:

; 745  :   temp_free((char*)T1);

	push	ebx
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	ebx
$LN5@BK_hess_pr@2:
	pop	esi

; 746  : } /* end BK_hess_project */

	pop	ebp
	ret	0
_BK_hess_project ENDP
_TEXT	ENDS
PUBLIC	__real@bf847ae147ae147b
PUBLIC	_lowest_eigenpair
EXTRN	_do_ritz:PROC
EXTRN	_quiet_flag:DWORD
EXTRN	_sp_hess_project_setup_func:DWORD
;	COMDAT __real@bf847ae147ae147b
CONST	SEGMENT
__real@bf847ae147ae147b DQ 0bf847ae147ae147br	; -0.01
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _lowest_eigenpair
_TEXT	SEGMENT
_S$ = 8							; size = 4
_v$ = 12						; size = 4
_lowest_eigenpair PROC					; COMDAT

; 761  : { REAL lo;

	push	ebp
	mov	ebp, esp

; 762  :   int old_quiet;
; 763  : 
; 764  : #ifdef XXX
; 765  :   REAL old_ev,new_ev;
; 766  :   int i;
; 767  :   int krydim = 20;
; 768  :   int nlook = 2;
; 769  :   REAL evalues[5];
; 770  :   REAL *vtmp = (REAL*)temp_calloc(S->N,sizeof(REAL));
; 771  : #endif
; 772  : 
; 773  :   /* find lower bound on lowest eigenvalue */
; 774  :   lo = -0.01;
; 775  :   S->lambda = lo; 

	fld	QWORD PTR __real@bf847ae147ae147b
	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	push	edi
	fstp	QWORD PTR [esi+112]

; 776  :   sp_factor(S,MKL_INDEF);

	push	-2					; fffffffeH
	push	esi
	call	_sp_factor

; 777  :   (*sp_hess_project_setup_func)(S);

	push	esi
	call	DWORD PTR _sp_hess_project_setup_func
	add	esp, 12					; 0000000cH

; 778  :   while ( S->neg > 0)

	cmp	DWORD PTR [esi+188], 0
	jle	SHORT $LN1@lowest_eig
	npad	4
$LL2@lowest_eig:

; 779  :   { 
; 780  :     S->lambda *= 10;

	fld	QWORD PTR [esi+112]

; 781  :     sp_factor(S,MKL_INDEF);

	push	-2					; fffffffeH
	fmul	QWORD PTR __real@4024000000000000
	push	esi
	fstp	QWORD PTR [esi+112]
	call	_sp_factor

; 782  :     (*sp_hess_project_setup_func)(S);

	push	esi
	call	DWORD PTR _sp_hess_project_setup_func
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+188], 0
	jg	SHORT $LL2@lowest_eig
$LN1@lowest_eig:

; 783  :   }
; 784  :   
; 785  :   old_quiet = quiet_flag;

	mov	edi, DWORD PTR _quiet_flag

; 786  :   quiet_flag = 1;
; 787  :   do_ritz(S,S->lambda,1,&v);

	lea	eax, DWORD PTR _v$[ebp]
	push	eax
	push	1
	mov	DWORD PTR _quiet_flag, 1
	fld	QWORD PTR [esi+112]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	esi
	call	_do_ritz

; 788  :   quiet_flag = old_quiet;
; 789  :   return last_eigenvalue;

	fld	QWORD PTR _last_eigenvalue
	add	esp, 20					; 00000014H
	mov	DWORD PTR _quiet_flag, edi
	pop	edi
	pop	esi

; 790  :   
; 791  :   #ifdef XXX
; 792  :   //lanczos(S,krydim,evalues,nlook);
; 793  : 
; 794  :   /* inverse iteration to find eigenvector */
; 795  :   S->lambda = evalues[0] - .0001;
; 796  :   sp_factor(S);
; 797  :   (*sp_hess_project_setup_func)(S);
; 798  :   for ( i = 0 ; i < S->N ; i++ ) v[i] = drand48();
; 799  :   old_ev = new_ev = 11231.0;  /* weird number, nonzero */
; 800  :   do
; 801  :   { sp_hessian_solve(S,v,vtmp,NO_SET_PRESSURE);
; 802  :     old_ev = new_ev;
; 803  :     new_ev = sqrt(dot(vtmp,vtmp,S->N));
; 804  :     for ( i = 0 ; i < S->N ; i++ ) v[i] = vtmp[i]/new_ev;
; 805  :   } while ( fabs(1/old_ev-1/new_ev) > 1000*machine_eps );
; 806  :   temp_free((char*)vtmp);
; 807  : 
; 808  :   if ( S->zero != 0 ) last_eigenvalue = S->lambda;
; 809  :   else
; 810  :   last_eigenvalue = S->lambda + 1/new_ev;
; 811  :   return S->lambda + 1/new_ev;
; 812  :   #endif
; 813  : } /* end lowest_eigenpair */

	pop	ebp
	ret	0
_lowest_eigenpair ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@HPGBJIPI@?$CF3d?4?5?5?5?5?$CF3?417g?6?$AA@ ; `string'
PUBLIC	__real@4010000000000000
PUBLIC	_x$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_old_cg_lowest_eigenpair
EXTRN	__CIsqrt:PROC
;	COMDAT ??_C@_0BA@HPGBJIPI@?$CF3d?4?5?5?5?5?$CF3?417g?6?$AA@
CONST	SEGMENT
??_C@_0BA@HPGBJIPI@?$CF3d?4?5?5?5?5?$CF3?417g?6?$AA@ DB '%3d.    %3.17g', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _old_cg_lowest_eigenpair
_TEXT	SEGMENT
tv924 = -200						; size = 8
_hnorm_inv$89605 = -192					; size = 8
_old_xax$ = -184					; size = 8
tv1137 = -176						; size = 8
tv920 = -176						; size = 8
_hnorm$89604 = -168					; size = 8
tv1135 = -160						; size = 8
_b$89598 = -160						; size = 8
_h$ = -152						; size = 4
_Cf$ = -148						; size = 4
_xax$ = -144						; size = 8
_CCinv$ = -136						; size = 4
_mx$ = -132						; size = 4
_mh$ = -128						; size = 4
_Gf$ = -124						; size = 4
_maxcount$ = -120					; size = 4
_count$ = -116						; size = 4
_ah$ = -112						; size = 4
_x$GSCopy$ = -108					; size = 4
_response$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_x$ = 12						; size = 4
_old_cg_lowest_eigenpair PROC				; COMDAT

; 831  : { REAL norm_inv;

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _S$[ebp]

; 832  :   int i;
; 833  :   REAL *h=NULL; /* search direction */
; 834  :   REAL *ah=NULL; 
; 835  :   REAL *f=NULL,*If=NULL; /* gradient of XAX, form and vector */
; 836  :   REAL *mx=NULL; /* MX */
; 837  :   REAL *mh=NULL; /* MH */
; 838  :   REAL cgamma; /* cg coefficient */
; 839  :   REAL xax,old_xax;
; 840  :   int count;
; 841  :   int maxcount;
; 842  :   char response[100];
; 843  :   REAL **CCinv=NULL;
; 844  :   REAL *Cf=NULL,*Gf=NULL;
; 845  : 
; 846  :   h = (REAL *)temp_calloc(S->N,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	push	846					; 0000034eH
	xor	edi, edi
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	ecx
	mov	DWORD PTR _x$GSCopy$[ebp], eax
	mov	DWORD PTR _mx$[ebp], edi
	mov	DWORD PTR _mh$[ebp], edi
	mov	DWORD PTR _CCinv$[ebp], edi
	mov	DWORD PTR _Cf$[ebp], edi
	mov	DWORD PTR _Gf$[ebp], edi
	call	_kb_temp_calloc

; 847  :   ah = (REAL *)temp_calloc(S->N,sizeof(REAL));

	mov	edx, DWORD PTR [esi+4]
	push	847					; 0000034fH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	edx
	mov	DWORD PTR _h$[ebp], eax
	call	_kb_temp_calloc

; 848  :   f = (REAL *)temp_calloc(S->N,sizeof(REAL));

	push	848					; 00000350H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	mov	DWORD PTR _ah$[ebp], eax
	mov	eax, DWORD PTR [esi+4]
	push	8
	push	eax
	call	_kb_temp_calloc
	add	esp, 48					; 00000030H
	mov	ebx, eax

; 849  :   if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, edi
	jne	SHORT $LN64@old_cg_low
	cmp	DWORD PTR _hessian_linear_metric_flag, edi
	je	SHORT $LN65@old_cg_low
$LN64@old_cg_low:

; 850  :     { mx = (REAL *)temp_calloc(S->N,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+4]
	push	850					; 00000352H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	ecx
	call	_kb_temp_calloc

; 851  :       mh = (REAL *)temp_calloc(S->N,sizeof(REAL));

	mov	edx, DWORD PTR [esi+4]
	push	851					; 00000353H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	edx
	mov	DWORD PTR _mx$[ebp], eax
	call	_kb_temp_calloc
	add	esp, 32					; 00000020H
	mov	DWORD PTR _mh$[ebp], eax
$LN65@old_cg_low:

; 852  :     }
; 853  :   if ( S->CN )

	cmp	DWORD PTR [esi+148], edi
	je	$LN63@old_cg_low

; 854  :     { CCinv = dmatrix(0,S->CN,0,S->CN);

	mov	eax, DWORD PTR [esi+148]
	push	854					; 00000356H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	eax
	push	edi
	push	eax
	push	edi
	call	_kb_dmatrix

; 855  :       mat_mul_tr(S->C,S->C,CCinv,S->CN,S->N,S->CN);

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+160]
	mov	edi, eax
	mov	DWORD PTR _CCinv$[ebp], eax
	mov	eax, DWORD PTR [esi+148]
	push	eax
	push	edx
	push	eax
	push	edi
	push	ecx
	push	ecx
	call	_mat_mul_tr

; 856  :       mat_inv(CCinv,S->CN);

	mov	eax, DWORD PTR [esi+148]
	push	eax
	push	edi
	call	_mat_inv

; 857  :       Cf = (REAL*)temp_calloc(S->CN,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+148]
	push	857					; 00000359H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	ecx
	call	_kb_temp_calloc

; 858  :       Gf = (REAL*)temp_calloc(S->CN,sizeof(REAL));

	mov	edx, DWORD PTR [esi+148]
	add	esp, 72					; 00000048H
	push	858					; 0000035aH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	edx
	mov	DWORD PTR _Cf$[ebp], eax
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _Gf$[ebp], eax
$LN63@old_cg_low:

; 859  :     }
; 860  : 
; 861  :   /* initial random guess */
; 862  :   for ( i = 0 ; i < S->N ; i++ ) x[i] = drand48() - .5;

	xor	edi, edi
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN60@old_cg_low
$LL62@old_cg_low:
	call	_drand48
	fsub	QWORD PTR __real@3fe0000000000000
	mov	eax, DWORD PTR _x$GSCopy$[ebp]
	inc	edi
	fstp	QWORD PTR [eax+edi*8-8]
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL62@old_cg_low
$LN60@old_cg_low:

; 863  :   /* project to constraints */
; 864  :   if ( S->CN )

	mov	eax, DWORD PTR [esi+148]
	test	eax, eax
	je	SHORT $LN111@old_cg_low

; 865  :   { matvec_mul(S->C,x,Cf,S->CN,S->N);

	mov	ecx, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _Cf$[ebp]
	mov	edx, DWORD PTR _x$GSCopy$[ebp]
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+160]
	push	edi
	push	edx
	push	eax
	call	_matvec_mul

; 866  :     matvec_mul(CCinv,Cf,Gf,S->CN,S->CN);

	mov	eax, DWORD PTR [esi+148]
	mov	ecx, DWORD PTR _Gf$[ebp]
	mov	edx, DWORD PTR _CCinv$[ebp]
	push	eax
	push	eax
	push	ecx
	push	edi
	push	edx
	call	_matvec_mul

; 867  :     for ( i = 0 ; i < S->CN ; i++ )

	xor	edi, edi
	add	esp, 40					; 00000028H
	cmp	DWORD PTR [esi+148], edi
	jle	SHORT $LN111@old_cg_low
	npad	6
$LL58@old_cg_low:

; 868  :        vector_add_smul(x,S->C[i],-Gf[i],S->N);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _Gf$[ebp]
	fld	QWORD PTR [ecx+edi*8]
	mov	edx, DWORD PTR [esi+160]
	mov	ecx, DWORD PTR _x$GSCopy$[ebp]
	fchs
	push	eax
	mov	eax, DWORD PTR [edx+edi*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	push	ecx
	call	_vector_add_smul
	inc	edi
	add	esp, 20					; 00000014H
	cmp	edi, DWORD PTR [esi+148]
	jl	SHORT $LL58@old_cg_low
$LN111@old_cg_low:

; 869  :   }
; 870  :   if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN54@old_cg_low
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN54@old_cg_low

; 872  :   else norm_inv = 1/sqrt(dot(x,x,S->N));

	mov	edx, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _x$GSCopy$[ebp]
	push	edx
	push	edi
	push	edi
	call	_dot
	jmp	SHORT $LN169@old_cg_low
$LN54@old_cg_low:

; 871  :       norm_inv = 1/sqrt(sparse_metric_dot(x,x,&Met));

	mov	edi, DWORD PTR _x$GSCopy$[ebp]
	push	OFFSET _Met
	push	edi
	push	edi
	call	_sparse_metric_dot
$LN169@old_cg_low:
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fld1

; 873  :   for ( i = 0 ; i < S->N ; i++ ) x[i] *= norm_inv;

	xor	eax, eax
	fdivrp	ST(1), ST(0)
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN121@old_cg_low
$LN52@old_cg_low:
	fld	QWORD PTR [edi+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edi+eax*8-8]
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LN52@old_cg_low
$LN121@old_cg_low:

; 874  : 
; 875  :   xax = 1e30; /* silly value for start of convergence test */
; 876  :   for(;;)
; 877  :   { prompt("Enter max iterations: ",response,sizeof(response)); 

	push	100					; 00000064H
	fstp	ST(0)
	fld	QWORD PTR __real@46293e5939a08cea
	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	fstp	QWORD PTR _xax$[ebp]
	push	OFFSET ??_C@_0BH@BNPHLKFG@Enter?5max?5iterations?3?5?$AA@
	call	_prompt

; 878  :     maxcount = atoi(response);

	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	call	_atoi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _maxcount$[ebp], eax

; 879  :     if ( maxcount == 0 ) break;

	test	eax, eax
	je	$LN80@old_cg_low
	npad	7
$LL49@old_cg_low:

; 880  :     if ( maxcount < 0 ) { count = 0 ; maxcount = -maxcount; }

	mov	eax, DWORD PTR _maxcount$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _count$[ebp], ecx
	cmp	eax, ecx
	jge	SHORT $LN104@old_cg_low
	neg	eax
	mov	DWORD PTR _maxcount$[ebp], eax
$LN104@old_cg_low:

; 881  :     else count = 0;

	fld	QWORD PTR _xax$[ebp]
$LN44@old_cg_low:

; 882  : 
; 883  :     do
; 884  :     { REAL a,b,c,evalue,denom,q2,q1comp,hnorm,hnorm_inv;
; 885  :       old_xax = xax;
; 886  : 
; 887  :       count++;
; 888  :       /* get cg search direction */
; 889  :       (*sp_mul_func)(S,x,f);  /* AX */

	mov	edi, DWORD PTR _x$GSCopy$[ebp]
	fstp	QWORD PTR _old_xax$[ebp]
	inc	DWORD PTR _count$[ebp]
	push	ebx
	push	edi
	push	esi
	call	DWORD PTR _sp_mul_func

; 890  :       xax = dot(x,f,S->N);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	push	ebx
	push	edi
	call	_dot
	fst	QWORD PTR _xax$[ebp]
	add	esp, 24					; 00000018H

; 891  :       if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN127@old_cg_low
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN127@old_cg_low

; 893  :       else mx = x;

	mov	DWORD PTR _mx$[ebp], edi
	jmp	SHORT $LN39@old_cg_low
$LN127@old_cg_low:

; 892  :           (*sp_mul_func)(&Met,x,mx);

	mov	eax, DWORD PTR _mx$[ebp]
	fstp	ST(0)
	push	eax
	push	edi
	push	OFFSET _Met
	call	DWORD PTR _sp_mul_func
	fld	QWORD PTR _xax$[ebp]
	add	esp, 12					; 0000000cH
$LN39@old_cg_low:

; 894  :       for ( i = 0 ; i < S->N ; i++ ) f[i] -= xax*mx[i];

	xor	ecx, ecx
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN134@old_cg_low
	mov	edx, DWORD PTR _mx$[ebp]
	mov	eax, ebx
	sub	edx, ebx
$LN38@old_cg_low:
	fld	QWORD PTR [eax+edx]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LN38@old_cg_low
$LN134@old_cg_low:

; 895  : 
; 896  :       /* convert form f to vector If with cg metric I */
; 897  :       If = f;
; 898  :       /* project to constraints */
; 899  :       if ( S->CN )

	mov	eax, DWORD PTR [esi+148]
	fstp	ST(0)
	test	eax, eax
	je	SHORT $LN112@old_cg_low

; 900  :       { matvec_mul(S->C,If,Cf,S->CN,S->N);

	mov	ecx, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _Cf$[ebp]
	mov	edx, DWORD PTR [esi+160]
	push	ecx
	push	eax
	push	edi
	push	ebx
	push	edx
	call	_matvec_mul

; 901  :         matvec_mul(CCinv,Cf,Gf,S->CN,S->CN);

	mov	eax, DWORD PTR [esi+148]
	mov	ecx, DWORD PTR _CCinv$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR _Gf$[ebp]
	push	eax
	push	edi
	push	ecx
	call	_matvec_mul

; 902  :         for ( i = 0 ; i < S->CN ; i++ )

	xor	edi, edi
	add	esp, 40					; 00000028H
	cmp	DWORD PTR [esi+148], edi
	jle	SHORT $LN112@old_cg_low
	npad	8
$LL34@old_cg_low:

; 903  :           vector_add_smul(If,S->C[i],-Gf[i],S->N);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR _Gf$[ebp]
	fld	QWORD PTR [eax+edi*8]
	mov	ecx, DWORD PTR [esi+160]
	push	edx
	fchs
	mov	edx, DWORD PTR [ecx+edi*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	push	ebx
	call	_vector_add_smul
	inc	edi
	add	esp, 20					; 00000014H
	cmp	edi, DWORD PTR [esi+148]
	jl	SHORT $LL34@old_cg_low
$LN112@old_cg_low:

; 904  :       }
; 905  :       /* project If tangent to Steifel manifold */
; 906  :       if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN30@old_cg_low
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN30@old_cg_low

; 908  :       else c = dot(x,If,S->N);

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _x$GSCopy$[ebp]
	push	eax
	push	ebx
	push	edi
	call	_dot
	jmp	SHORT $LN170@old_cg_low
$LN30@old_cg_low:

; 907  :          c = sparse_metric_dot(x,If,&Met);

	mov	edi, DWORD PTR _x$GSCopy$[ebp]
	push	OFFSET _Met
	push	ebx
	push	edi
	call	_sparse_metric_dot
$LN170@old_cg_low:

; 909  :       for ( i = 0 ; i < S->N ; i++ ) If[i] -= c*x[i];

	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN140@old_cg_low
	mov	edx, edi
	mov	eax, ebx
	sub	edx, ebx
$LN28@old_cg_low:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LN28@old_cg_low
$LN140@old_cg_low:

; 910  : 
; 911  :       /* compute Ah */
; 912  :       /* proper Hessian is A - XAX M */
; 913  :       (*sp_mul_func)(S,h,ah);

	mov	ecx, DWORD PTR _ah$[ebp]
	fstp	ST(0)
	mov	edi, DWORD PTR _h$[ebp]
	push	ecx
	push	edi
	push	esi
	call	DWORD PTR _sp_mul_func
	add	esp, 12					; 0000000cH

; 914  :       if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN24@old_cg_low
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN24@old_cg_low

; 916  :       else mh = h;

	mov	DWORD PTR _mh$[ebp], edi
	jmp	SHORT $LN23@old_cg_low
$LN24@old_cg_low:

; 915  :           (*sp_mul_func)(&Met,h,mh);

	mov	edx, DWORD PTR _mh$[ebp]
	push	edx
	push	edi
	push	OFFSET _Met
	call	DWORD PTR _sp_mul_func
	add	esp, 12					; 0000000cH
$LN23@old_cg_low:

; 917  :       for ( i = 0 ; i < S->N ; i++ ) ah[i] -= xax*mh[i];

	xor	ecx, ecx
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN114@old_cg_low
	mov	eax, DWORD PTR _ah$[ebp]
	fld	QWORD PTR _xax$[ebp]
	mov	edx, DWORD PTR _mh$[ebp]
	sub	edx, eax
$LN22@old_cg_low:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LN22@old_cg_low
	fstp	ST(0)
$LN114@old_cg_low:

; 918  : 
; 919  :       /* compute gamma */
; 920  :       if ( count <= 1 ) cgamma = 0.0;

	cmp	DWORD PTR _count$[ebp], 1
	jg	SHORT $LN19@old_cg_low
	fldz

; 921  :       else

	jmp	SHORT $LN18@old_cg_low
$LN19@old_cg_low:

; 922  :       { cgamma = -dot(If,ah,S->N)/dot(h,ah,S->N);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _ah$[ebp]
	push	eax
	push	ecx
	push	ebx
	call	_dot
	fstp	QWORD PTR tv1135[ebp]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR _ah$[ebp]
	push	edx
	push	eax
	push	edi
	call	_dot
	fdivr	QWORD PTR tv1135[ebp]
	add	esp, 24					; 00000018H
	fchs
$LN18@old_cg_low:

; 923  :       }
; 924  : 
; 925  :       /* compute search direction */
; 926  :       for ( i = 0 ; i < S->N ; i++ ) h[i] = If[i] + cgamma*h[i];

	xor	ecx, ecx
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN149@old_cg_low
	mov	edx, ebx
	mov	eax, edi
	sub	edx, edi
$LN17@old_cg_low:
	fld	ST(0)
	inc	ecx
	fmul	QWORD PTR [eax]
	add	eax, 8
	fadd	QWORD PTR [edx+eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LN17@old_cg_low
$LN149@old_cg_low:

; 927  : 
; 928  :       if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	fstp	ST(0)
	jne	SHORT $LN13@old_cg_low
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN13@old_cg_low

; 930  :       else hnorm = sqrt(dot(h,h,S->N));

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	push	edi
	push	edi
	call	_dot
	jmp	SHORT $LN171@old_cg_low
$LN13@old_cg_low:

; 929  :          hnorm = sqrt(sparse_metric_dot(h,h,&Met));

	push	OFFSET _Met
	push	edi
	push	edi
	call	_sparse_metric_dot
$LN171@old_cg_low:
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fst	QWORD PTR _hnorm$89604[ebp]

; 931  :       hnorm_inv = 1/hnorm;

	fld1

; 932  : 
; 933  :       /* recompute Ah */
; 934  :       (*sp_mul_func)(S,h,ah); 

	mov	edx, DWORD PTR _ah$[ebp]
	fdivrp	ST(1), ST(0)
	push	edx
	push	edi
	push	esi
	fstp	QWORD PTR _hnorm_inv$89605[ebp]
	call	DWORD PTR _sp_mul_func

; 935  : #ifdef XXX
; 936  : projecting off XAX M seems to hurt 
; 937  :       if ( web.area_norm_flag || hessian_linear_metric_flag ) 
; 938  :     (*sp_mul_func)(&Met,h,mh);
; 939  :       else mh = h;
; 940  :       for ( i = 0 ; i < S->N ; i++ ) ah[i] -= xax*mh[i];
; 941  : #endif
; 942  : 
; 943  :       /* find minimum along geodesic */
; 944  :       a = xax;
; 945  :       b = dot(x,ah,S->N)/hnorm;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _ah$[ebp]
	mov	edx, DWORD PTR _x$GSCopy$[ebp]
	push	eax
	push	ecx
	push	edx
	call	_dot
	fdiv	QWORD PTR _hnorm$89604[ebp]

; 946  :       c = dot(h,ah,S->N)/hnorm/hnorm;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _ah$[ebp]
	push	eax
	push	ecx
	push	edi
	fstp	QWORD PTR _b$89598[ebp]
	call	_dot
	fld	QWORD PTR _hnorm$89604[ebp]
	fdiv	ST(1), ST(0)
	add	esp, 36					; 00000024H
	fdivp	ST(1), ST(0)

; 947  :       evalue = 0.5*(a+c-sqrt((a-c)*(a-c)+4*b*b));  /* smallest ev */

	fld	QWORD PTR _xax$[ebp]
	fld	ST(0)
	fsub	ST(0), ST(2)
	fxch	ST(2)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR tv1137[ebp]
	fld	QWORD PTR _b$89598[ebp]
	fld	QWORD PTR __real@4010000000000000
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fsubr	QWORD PTR tv1137[ebp]
	fmul	QWORD PTR __real@3fe0000000000000

; 948  :       denom = sqrt(b*b + (evalue - a)*(evalue - a));

	fsub	QWORD PTR _xax$[ebp]
	fst	QWORD PTR tv920[ebp]
	fmul	ST(0), ST(0)
	fst	QWORD PTR tv924[ebp]
	fld	QWORD PTR _b$89598[ebp]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt

; 949  :       if ( b < 0.0 ) denom = -denom;

	fldz
	fld	QWORD PTR _b$89598[ebp]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN11@old_cg_low
	fxch	ST(1)
	fchs
	fxch	ST(1)
$LN11@old_cg_low:

; 950  :       q2 = (evalue - a)/denom;

	fld	QWORD PTR tv920[ebp]

; 951  :       q1comp = (evalue-a)*(evalue-a)/denom/(denom+b);
; 952  :       /* rotate h and x */
; 953  :       for ( i = 0 ; i < S->N ; i++ )

	xor	edx, edx
	fdiv	ST(0), ST(2)
	fld	QWORD PTR tv924[ebp]
	fdiv	ST(0), ST(3)
	fxch	ST(3)
	faddp	ST(2), ST(0)
	fxch	ST(2)
	fdivrp	ST(1), ST(0)
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN156@old_cg_low
	mov	ecx, DWORD PTR _x$GSCopy$[ebp]
	fld	QWORD PTR _hnorm_inv$89605[ebp]
	fld	QWORD PTR _hnorm$89604[ebp]
	mov	eax, edi
	sub	ecx, edi
$LN10@old_cg_low:

; 954  :       { REAL xtmp = x[i]*hnorm;

	fld	QWORD PTR [ecx+eax]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8

; 955  :         REAL htmp = h[i]*hnorm_inv;

	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(3)

; 956  :         x[i] += -q1comp*x[i] + q2*htmp;

	fmul	ST(0), ST(5)
	fld	QWORD PTR [ecx+eax-8]
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fadd	QWORD PTR [ecx+eax-8]
	fstp	QWORD PTR [ecx+eax-8]

; 957  :         h[i] += -q2*xtmp  -q1comp*h[i]; 

	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(4)
	fxch	ST(1)
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LN10@old_cg_low

; 951  :       q1comp = (evalue-a)*(evalue-a)/denom/(denom+b);
; 952  :       /* rotate h and x */
; 953  :       for ( i = 0 ; i < S->N ; i++ )

	fstp	ST(2)
	fstp	ST(2)
	fstp	ST(1)
	jmp	SHORT $LN172@old_cg_low
$LN156@old_cg_low:
	fstp	ST(0)
$LN172@old_cg_low:
	mov	edi, DWORD PTR _count$[ebp]
	fstp	ST(0)

; 958  :       }
; 959  :       if ( (count < maxcount) && (maxcount > 5) && (count % (maxcount/5) == 0) )

	mov	ecx, DWORD PTR _maxcount$[ebp]
	cmp	edi, ecx
	jge	SHORT $LN43@old_cg_low
	cmp	ecx, 5
	jle	SHORT $LN43@old_cg_low
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	eax, edi
	cdq
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN117@old_cg_low

; 960  :       { 
; 961  : #ifdef FLOAT128
; 962  :      sprintf(msg,"%3d.    %3.*Qg\n",count,DPREC,xax);
; 963  : #elif defined(LONGDOUBLE)
; 964  :      sprintf(msg,"%3d.    %3.*Lg\n",count,DPREC,xax);
; 965  : #else
; 966  :      sprintf(msg,"%3d.    %3.17g\n",count,xax);

	fld	QWORD PTR _xax$[ebp]
	mov	edx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	push	OFFSET ??_C@_0BA@HPGBJIPI@?$CF3d?4?5?5?5?5?$CF3?417g?6?$AA@
	push	edx
	call	_sprintf

; 967  : #endif 
; 968  :      outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 24					; 00000018H
$LN117@old_cg_low:
	mov	ecx, DWORD PTR _maxcount$[ebp]
$LN43@old_cg_low:

; 969  :       }
; 970  :     } while ( (fabs(xax - old_xax) > 10*machine_eps*fabs(xax)) && (count<maxcount) );

	fld	QWORD PTR _xax$[ebp]
	fld	QWORD PTR _old_xax$[ebp]
	fsubr	ST(0), ST(1)
	fabs
	fld	ST(1)
	fabs
	fld	QWORD PTR _machine_eps
	fmul	QWORD PTR __real@4024000000000000
	fmulp	ST(1), ST(0)
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	$LN6@old_cg_low
	cmp	edi, ecx
	jl	$LN44@old_cg_low

; 971  :     if ( count < maxcount )

	mov	edi, DWORD PTR _count$[ebp]
$LN5@old_cg_low:

; 983  : #ifdef FLOAT128
; 984  :      sprintf(msg,"%3d.    %3.*Qg  max iterations\n",count,DPREC,xax);
; 985  : #elif defined(LONGDOUBLE)
; 986  :      sprintf(msg,"%3d.    %3.*Lg  max iterations\n",count,DPREC,xax);
; 987  : #else
; 988  :      sprintf(msg,"%3d.    %3.17g  max iterations\n",count,xax);

	mov	eax, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	push	OFFSET ??_C@_0CA@CMJBFKAG@?$CF3d?4?5?5?5?5?$CF3?417g?5?5max?5iterations?6?$AA@
	push	eax
	call	_sprintf

; 989  : #endif 
; 990  :      outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
$LN173@old_cg_low:
	call	_outstring
	add	esp, 24					; 00000018H
	push	100					; 00000064H
	lea	edx, DWORD PTR _response$[ebp]
	push	edx
	push	OFFSET ??_C@_0BH@BNPHLKFG@Enter?5max?5iterations?3?5?$AA@
	call	_prompt
	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	call	_atoi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _maxcount$[ebp], eax
	test	eax, eax
	jne	$LL49@old_cg_low
$LN80@old_cg_low:

; 991  :       }
; 992  :   }
; 993  : 
; 994  : 
; 995  :   temp_free((char*)h);

	mov	ecx, DWORD PTR _h$[ebp]
	push	ecx
	call	_temp_free

; 996  :   temp_free((char*)ah);

	mov	edx, DWORD PTR _ah$[ebp]
	push	edx
	call	_temp_free

; 997  :   temp_free((char*)f);

	push	ebx
	call	_temp_free
	add	esp, 12					; 0000000cH

; 998  :   if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN2@old_cg_low
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $LN3@old_cg_low
$LN2@old_cg_low:

; 999  :   { temp_free((char*)mx);

	mov	eax, DWORD PTR _mx$[ebp]
	push	eax
	call	_temp_free

; 1000 :     temp_free((char*)mh);

	mov	ecx, DWORD PTR _mh$[ebp]
	push	ecx
	call	_temp_free
	add	esp, 8
$LN3@old_cg_low:

; 1001 :   }
; 1002 :   if ( S->CN )

	cmp	DWORD PTR [esi+148], 0
	pop	edi
	pop	esi
	pop	ebx
	je	SHORT $LN1@old_cg_low

; 1003 :   { temp_free((char*)Gf);

	mov	edx, DWORD PTR _Gf$[ebp]
	push	edx
	call	_temp_free

; 1004 :     temp_free((char*)Cf);

	mov	eax, DWORD PTR _Cf$[ebp]
	push	eax
	call	_temp_free

; 1005 :     free_matrix(CCinv);

	mov	ecx, DWORD PTR _CCinv$[ebp]
	push	ecx
	call	_free_matrix
	add	esp, 12					; 0000000cH
$LN1@old_cg_low:

; 1006 :   }
; 1007 :   last_eigenvalue = xax;
; 1008 :   return xax;
; 1009 : } /* end old_cg_lowest_eigenpair */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fld	QWORD PTR _xax$[ebp]
	xor	ecx, ebp
	fst	QWORD PTR _last_eigenvalue
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@old_cg_low:

; 971  :     if ( count < maxcount )

	cmp	edi, ecx
	jge	$LN5@old_cg_low

; 972  :       { 
; 973  : #ifdef FLOAT128
; 974  :      sprintf(msg,"%3d.    %3.*Qg  converged\n",count,DPREC,xax);
; 975  : #elif defined(LONGDOUBLE)
; 976  :      sprintf(msg,"%3d.    %3.*Lg  converged\n",count,DPREC,xax);
; 977  : #else
; 978  :      sprintf(msg,"%3d.    %3.17g  converged\n",count,xax);

	mov	ecx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	push	OFFSET ??_C@_0BL@FEPPCLLD@?$CF3d?4?5?5?5?5?$CF3?417g?5?5converged?6?$AA@
	push	ecx
	call	_sprintf

; 979  : #endif 
; 980  :      outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx

; 981  :       }
; 982  :     else  { 

	jmp	$LN173@old_cg_low
_old_cg_lowest_eigenpair ENDP
_TEXT	ENDS
PUBLIC	_x$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_cg_lowest_eigenpair
; Function compile flags: /Ogtp
;	COMDAT _cg_lowest_eigenpair
_TEXT	SEGMENT
_hnorm_inv$89729 = -208					; size = 8
_old_xax$ = -200					; size = 8
tv1164 = -192						; size = 8
_P$ = -184						; size = 4
tv1378 = -180						; size = 8
tv1160 = -180						; size = 8
_b$89722 = -172						; size = 8
tv1495 = -168						; size = 4
_hnorm$89728 = -164					; size = 8
tv1490 = -160						; size = 4
_xax$ = -156						; size = 8
_Gf$ = -148						; size = 4
_x$GSCopy$ = -144					; size = 4
_mh$ = -140						; size = 4
_maxcount$ = -136					; size = 4
_Cf$ = -132						; size = 4
_Pinv$ = -128						; size = 4
_ah$ = -124						; size = 4
_h$ = -120						; size = 4
_ax$ = -116						; size = 4
_mx$ = -112						; size = 4
_count$ = -108						; size = 4
_i$ = -108						; size = 4
_response$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_x$ = 12						; size = 4
_cg_lowest_eigenpair PROC				; COMDAT

; 1026 : { REAL norm_inv;

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _S$[ebp]

; 1027 :   int i,j;
; 1028 :   REAL *h; /* search direction */
; 1029 :   REAL *ah;  /* (A-XAX M)H */
; 1030 :   REAL *ax; /* AX */
; 1031 :   REAL *mx; /* MX */
; 1032 :   REAL *mh; /* MH */
; 1033 :   REAL xax,old_xax;
; 1034 :   int count;
; 1035 :   int maxcount;
; 1036 :   char response[100];
; 1037 :   REAL *Cf,*Gf;
; 1038 :   REAL **P; /* matrix of coeff for Lagrange mult */
; 1039 :   REAL **Pinv; /* inverse of P */
; 1040 : 
; 1041 :   h = (REAL *)temp_calloc(S->N,sizeof(REAL));

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _x$[ebp]
	push	1041					; 00000411H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	eax
	mov	DWORD PTR _x$GSCopy$[ebp], edi
	call	_kb_temp_calloc

; 1042 :   ah = (REAL *)temp_calloc(S->N,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+4]
	push	1042					; 00000412H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	mov	ebx, eax
	push	8
	push	ecx
	mov	DWORD PTR _h$[ebp], ebx
	call	_kb_temp_calloc

; 1043 :   ax = (REAL *)temp_calloc(S->N,sizeof(REAL));

	mov	edx, DWORD PTR [esi+4]
	push	1043					; 00000413H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	edx
	mov	DWORD PTR _ah$[ebp], eax
	call	_kb_temp_calloc
	add	esp, 48					; 00000030H

; 1044 :   if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	mov	DWORD PTR _ax$[ebp], eax
	jne	SHORT $LN60@cg_lowest_
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN60@cg_lowest_

; 1047 :     }
; 1048 :   else { mx = x; mh = h; }

	mov	DWORD PTR _mx$[ebp], edi
	mov	DWORD PTR _mh$[ebp], ebx
	jmp	SHORT $LN59@cg_lowest_
$LN60@cg_lowest_:

; 1045 :     { mx = (REAL *)temp_calloc(S->N,sizeof(REAL));

	mov	eax, DWORD PTR [esi+4]
	push	1045					; 00000415H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc

; 1046 :       mh = (REAL *)temp_calloc(S->N,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+4]
	push	1046					; 00000416H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	ecx
	mov	DWORD PTR _mx$[ebp], eax
	call	_kb_temp_calloc
	add	esp, 32					; 00000020H
	mov	DWORD PTR _mh$[ebp], eax
$LN59@cg_lowest_:

; 1049 :   P = dmatrix(0,S->CN+1,0,S->CN+1);

	mov	eax, DWORD PTR [esi+148]
	push	1049					; 00000419H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	inc	eax
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix
	mov	ebx, eax

; 1050 :   Pinv = dmatrix(0,S->CN+1,0,S->CN+1);

	mov	eax, DWORD PTR [esi+148]
	push	1050					; 0000041aH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	inc	eax
	push	eax
	push	0
	push	eax
	push	0
	mov	DWORD PTR _P$[ebp], ebx
	call	_kb_dmatrix

; 1051 :   Cf = (REAL*)temp_calloc(S->CN+2,sizeof(REAL));

	mov	edx, DWORD PTR [esi+148]
	push	1051					; 0000041bH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	add	edx, 2
	push	8
	push	edx
	mov	DWORD PTR _Pinv$[ebp], eax
	call	_kb_temp_calloc
	add	esp, 64					; 00000040H

; 1052 :   Gf = (REAL*)temp_calloc(S->CN+2,sizeof(REAL));

	push	1052					; 0000041cH
	mov	DWORD PTR _Cf$[ebp], eax
	mov	eax, DWORD PTR [esi+148]
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	add	eax, 2
	push	8
	push	eax
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H

; 1053 :   if ( S->CN )

	cmp	DWORD PTR [esi+148], 0
	mov	DWORD PTR _Gf$[ebp], eax
	je	SHORT $LN58@cg_lowest_

; 1054 :     { /* CGC goes in upper left corner of P */
; 1055 :       mat_mul_tr(S->C,S->C,P,S->CN,S->N,S->CN);

	mov	eax, DWORD PTR [esi+148]
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+160]
	push	eax
	push	edx
	push	eax
	push	ebx
	push	ecx
	push	ecx
	call	_mat_mul_tr
	add	esp, 24					; 00000018H
$LN58@cg_lowest_:

; 1056 :     }
; 1057 : 
; 1058 :   /* initial random guess */
; 1059 :   for ( i = 0 ; i < S->N ; i++ ) x[i] = drand48() - .5;

	cmp	DWORD PTR [esi+4], 0
	mov	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN55@cg_lowest_
$LL57@cg_lowest_:
	call	_drand48
	fsub	QWORD PTR __real@3fe0000000000000
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	fstp	QWORD PTR [edi+eax*8-8]
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL57@cg_lowest_
$LN55@cg_lowest_:

; 1060 :   /* project to constraints */
; 1061 :   if ( S->CN )

	mov	eax, DWORD PTR [esi+148]
	test	eax, eax
	je	$LN121@cg_lowest_

; 1062 :     { matvec_mul(S->C,x,Cf,S->CN,S->N);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _Cf$[ebp]
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+160]
	push	edx
	push	edi
	push	eax
	call	_matvec_mul

; 1063 :       matcopy(Pinv,P,S->CN,S->CN);

	mov	eax, DWORD PTR [esi+148]
	mov	ecx, DWORD PTR _Pinv$[ebp]
	push	eax
	push	eax
	push	ebx
	push	ecx
	call	_matcopy

; 1064 :       mat_inv(Pinv,S->CN);

	mov	edx, DWORD PTR [esi+148]
	mov	eax, DWORD PTR _Pinv$[ebp]
	push	edx
	push	eax
	call	_mat_inv

; 1065 :       matvec_mul(Pinv,Cf,Gf,S->CN,S->CN);

	mov	eax, DWORD PTR [esi+148]
	mov	ecx, DWORD PTR _Gf$[ebp]
	mov	edx, DWORD PTR _Cf$[ebp]
	push	eax
	push	eax
	mov	eax, DWORD PTR _Pinv$[ebp]
	push	ecx
	push	edx
	push	eax
	call	_matvec_mul

; 1066 :       for ( i = 0 ; i < S->CN ; i++ )

	xor	eax, eax
	add	esp, 64					; 00000040H
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR [esi+148], eax
	jle	SHORT $LN121@cg_lowest_
	jmp	SHORT $LN53@cg_lowest_
	npad	11
$LL120@cg_lowest_:
	mov	eax, DWORD PTR _i$[ebp]
$LN53@cg_lowest_:

; 1067 :       vector_add_smul(x,S->C[i],-Gf[i],S->N);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _Gf$[ebp]
	fld	QWORD PTR [edx+eax*8]
	push	ecx
	mov	ecx, DWORD PTR [esi+160]
	fchs
	mov	edx, DWORD PTR [ecx+eax*4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edx
	push	edi
	call	_vector_add_smul
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	esp, 20					; 00000014H
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [esi+148]
	jl	SHORT $LL120@cg_lowest_
$LN121@cg_lowest_:

; 1068 :     }
; 1069 :   if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN49@cg_lowest_
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN49@cg_lowest_

; 1071 :   else norm_inv = 1/sqrt(dot(x,x,S->N));

	mov	eax, DWORD PTR [esi+4]
	push	eax
	push	edi
	push	edi
	call	_dot
	jmp	SHORT $LN164@cg_lowest_
$LN49@cg_lowest_:

; 1070 :       norm_inv = 1/sqrt(sparse_metric_dot(x,x,&Met));

	push	OFFSET _Met
	push	edi
	push	edi
	call	_sparse_metric_dot
$LN164@cg_lowest_:
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fld1

; 1072 :   for ( i = 0 ; i < S->N ; i++ ) x[i] *= norm_inv;

	xor	eax, eax
	fdivrp	ST(1), ST(0)
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN126@cg_lowest_
$LN47@cg_lowest_:
	fld	ST(0)
	inc	eax
	fmul	QWORD PTR [edi+eax*8-8]
	fstp	QWORD PTR [edi+eax*8-8]
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LN47@cg_lowest_
$LN126@cg_lowest_:

; 1073 : 
; 1074 :   xax = 1e30; /* silly value for start of convergence test */
; 1075 :   for(;;)
; 1076 :   { prompt("Enter max iterations: ",response,sizeof(response)); 

	push	100					; 00000064H
	fstp	ST(0)
	fld	QWORD PTR __real@46293e5939a08cea
	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	fstp	QWORD PTR _xax$[ebp]
	push	OFFSET ??_C@_0BH@BNPHLKFG@Enter?5max?5iterations?3?5?$AA@
	call	_prompt

; 1077 :     maxcount = atoi(response);

	lea	edx, DWORD PTR _response$[ebp]
	push	edx
	call	_atoi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _maxcount$[ebp], eax

; 1078 :     if ( maxcount == 0 ) break;

	test	eax, eax
	je	$LN76@cg_lowest_
	jmp	SHORT $LN44@cg_lowest_
$LL117@cg_lowest_:
	mov	eax, DWORD PTR _maxcount$[ebp]
	mov	edi, DWORD PTR _x$GSCopy$[ebp]
$LN44@cg_lowest_:

; 1079 :     if ( maxcount < 0 ) { count = 0 ; maxcount = -maxcount; }

	xor	ecx, ecx
	mov	DWORD PTR _count$[ebp], ecx
	cmp	eax, ecx
	jge	SHORT $LN108@cg_lowest_
	neg	eax
	mov	DWORD PTR _maxcount$[ebp], eax
$LN108@cg_lowest_:

; 1080 :     else count = 0;

	fld	QWORD PTR _xax$[ebp]
	jmp	SHORT $LN39@cg_lowest_
$LN118@cg_lowest_:
	mov	edi, DWORD PTR _x$GSCopy$[ebp]
$LN39@cg_lowest_:

; 1081 : 
; 1082 :     do
; 1083 :     { REAL a,b,c,evalue,denom,q2,q1comp,hnorm,hnorm_inv;
; 1084 :       int pdim;
; 1085 : 
; 1086 :       old_xax = xax;
; 1087 : 
; 1088 :       count++;

	inc	DWORD PTR _count$[ebp]
	fstp	QWORD PTR _old_xax$[ebp]

; 1089 : 
; 1090 :       /* get cg search direction */
; 1091 : 
; 1092 :       /* calculate needed vectors */
; 1093 : 
; 1094 :       /* MX */
; 1095 :       if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN35@cg_lowest_
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $LN34@cg_lowest_
$LN35@cg_lowest_:

; 1096 :          (*sp_mul_func)(&Met,x,mx);

	mov	eax, DWORD PTR _mx$[ebp]
	push	eax
	push	edi
	push	OFFSET _Met
	call	DWORD PTR _sp_mul_func
	add	esp, 12					; 0000000cH

; 1097 : 
; 1098 :       /* MH */
; 1099 :       if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN33@cg_lowest_
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $LN34@cg_lowest_
$LN33@cg_lowest_:

; 1100 :          (*sp_mul_func)(&Met,h,mh);

	mov	ecx, DWORD PTR _mh$[ebp]
	mov	edx, DWORD PTR _h$[ebp]
	push	ecx
	push	edx
	push	OFFSET _Met
	call	DWORD PTR _sp_mul_func
	add	esp, 12					; 0000000cH
$LN34@cg_lowest_:

; 1101 :       
; 1102 :       /* (A - XAX M)X */
; 1103 :       (*sp_mul_func)(S,x,ax); 

	mov	eax, DWORD PTR _ax$[ebp]
	push	eax
	push	edi
	push	esi
	call	DWORD PTR _sp_mul_func

; 1104 :       xax = dot(x,ax,S->N);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _ax$[ebp]
	push	ecx
	push	edx
	push	edi
	call	_dot
	fst	QWORD PTR _xax$[ebp]

; 1105 :       for ( i = 0 ; i < S->N ; i++ ) ax[i] -= xax*mx[i];

	xor	ecx, ecx
	add	esp, 24					; 00000018H
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN132@cg_lowest_
	mov	eax, DWORD PTR _ax$[ebp]
	mov	edx, DWORD PTR _mx$[ebp]
	sub	edx, eax
$LN32@cg_lowest_:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LN32@cg_lowest_
$LN132@cg_lowest_:

; 1106 : 
; 1107 :       /* (A - XAX M)H */
; 1108 :       (*sp_mul_func)(S,h,ah); 

	mov	edi, DWORD PTR _ah$[ebp]
	fstp	ST(0)
	mov	eax, DWORD PTR _h$[ebp]
	push	edi
	push	eax
	push	esi
	call	DWORD PTR _sp_mul_func

; 1109 :       for ( i = 0 ; i < S->N ; i++ ) ah[i] -= xax*mh[i];

	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN27@cg_lowest_
	mov	edx, DWORD PTR _mh$[ebp]
	fld	QWORD PTR _xax$[ebp]
	mov	eax, edi
	sub	edx, edi
$LN29@cg_lowest_:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LN29@cg_lowest_
	fstp	ST(0)
$LN27@cg_lowest_:

; 1110 : 
; 1111 :       /* fill in P, which already has CGC in upper left */
; 1112 :       if ( S->CN > 0 )

	cmp	DWORD PTR [esi+148], 0
	jle	SHORT $LN26@cg_lowest_

; 1113 :       { matvec_mul(S->C,mx,P[S->CN],S->CN,S->N);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+148]
	mov	edx, DWORD PTR [ebx+eax*4]
	push	ecx
	mov	ecx, DWORD PTR [esi+160]
	push	eax
	mov	eax, DWORD PTR _mx$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_matvec_mul

; 1114 :         matvec_mul(S->C,ah,P[S->CN+1],S->CN,S->N);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+148]
	mov	ecx, DWORD PTR [esi+160]
	push	edx
	push	eax
	mov	eax, DWORD PTR [ebx+eax*4+4]
	push	eax
	push	edi
	push	ecx
	call	_matvec_mul
	add	esp, 40					; 00000028H
$LN26@cg_lowest_:

; 1115 :       }
; 1116 :       P[S->CN][S->CN] = dot(mx,mx,S->N);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR _mx$[ebp]
	mov	edi, DWORD PTR [esi+148]
	push	edx
	push	eax
	push	eax
	call	_dot
	mov	eax, DWORD PTR [ebx+edi*4]

; 1117 :       P[S->CN+1][S->CN] = dot(ah,mx,S->N);

	mov	edx, DWORD PTR _mx$[ebp]
	fstp	QWORD PTR [eax+edi*8]
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR _ah$[ebp]
	mov	edi, DWORD PTR [esi+148]
	push	ecx
	push	edx
	push	eax
	call	_dot
	mov	ecx, DWORD PTR [ebx+edi*4+4]

; 1118 : 
; 1119 : #ifdef SYMMETRICWAY
; 1120 :       /* this way takes twice as long */
; 1121 :       P[S->CN+1][S->CN+1] = dot(ah,ah,S->N);
; 1122 :       for ( i = 0 ; i <= S->CN ; i++ )
; 1123 :         for ( j = S->CN ; j < S->CN+2 ; j++ )
; 1124 :            P[i][j] = P[j][i];
; 1125 : #else
; 1126 :       P[S->CN+1][S->CN+1] = dot(ah,h,S->N);

	mov	eax, DWORD PTR _h$[ebp]
	fstp	QWORD PTR [ecx+edi*8]
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _ah$[ebp]
	mov	edi, DWORD PTR [esi+148]
	push	edx
	push	eax
	push	ecx
	call	_dot
	mov	edx, DWORD PTR [ebx+edi*4+4]

; 1127 :       P[S->CN][S->CN+1] = dot(mx,h,S->N);

	mov	ecx, DWORD PTR _h$[ebp]
	fstp	QWORD PTR [edx+edi*8+8]
	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _mx$[ebp]
	mov	edi, DWORD PTR [esi+148]
	push	eax
	push	ecx
	push	edx
	call	_dot
	mov	eax, DWORD PTR [ebx+edi*4]
	fstp	QWORD PTR [eax+edi*8+8]

; 1128 :       for ( j = 0 ; j < S->CN ; j++ )

	xor	edi, edi
	add	esp, 48					; 00000030H
	cmp	DWORD PTR [esi+148], edi
	jle	SHORT $LN119@cg_lowest_
	npad	9
$LL25@cg_lowest_:

; 1129 :          P[j][S->CN+1] = dot(h,S->C[j],S->N);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+160]
	mov	eax, DWORD PTR [edx+edi*4]
	push	ecx
	mov	ecx, DWORD PTR _h$[ebp]
	push	eax
	push	ecx
	call	_dot
	mov	eax, DWORD PTR [ebx+edi*4]
	mov	edx, DWORD PTR [esi+148]
	inc	edi
	fstp	QWORD PTR [eax+edx*8+8]
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR [esi+148]
	jl	SHORT $LL25@cg_lowest_

; 1130 : #endif
; 1131 :       
; 1132 :       /* fill in right side */
; 1133 :       if ( S->CN > 0 ) matvec_mul(S->C,ax,Cf,S->CN,S->N);

	mov	eax, DWORD PTR [esi+148]
	test	eax, eax
	jle	SHORT $LN119@cg_lowest_
	mov	ecx, DWORD PTR [esi+4]
	mov	edi, DWORD PTR _Cf$[ebp]
	mov	edx, DWORD PTR _ax$[ebp]
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+160]
	push	edi
	push	edx
	push	eax
	call	_matvec_mul
	add	esp, 20					; 00000014H
	jmp	SHORT $LN22@cg_lowest_
$LN119@cg_lowest_:
	mov	edi, DWORD PTR _Cf$[ebp]
$LN22@cg_lowest_:

; 1134 :       Cf[S->CN] = dot(mx,ax,S->N);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _ax$[ebp]
	mov	eax, DWORD PTR _mx$[ebp]
	push	ecx
	push	edx
	push	eax
	call	_dot
	mov	ecx, DWORD PTR [esi+148]

; 1135 :       Cf[S->CN+1] = dot(ah,ax,S->N);

	mov	eax, DWORD PTR _ax$[ebp]
	fstp	QWORD PTR [edi+ecx*8]
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _ah$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_dot
	mov	edx, DWORD PTR [esi+148]

; 1136 : 
; 1137 :       /* solve */ 
; 1138 :       pdim = S->CN + ( count<=1 ? 1 : 2 );
; 1139 :       matcopy(Pinv,P,pdim,pdim);

	mov	ecx, DWORD PTR _Pinv$[ebp]
	fstp	QWORD PTR [edi+edx*8+8]
	xor	eax, eax
	cmp	DWORD PTR _count$[ebp], 1
	setg	al
	lea	edi, DWORD PTR [eax+1]
	add	edi, DWORD PTR [esi+148]
	push	edi
	push	edi
	push	ebx
	push	ecx
	call	_matcopy

; 1140 :       mat_inv(Pinv,pdim);

	mov	edx, DWORD PTR _Pinv$[ebp]
	push	edi
	push	edx
	call	_mat_inv

; 1141 :       matvec_mul(Pinv,Cf,Gf,pdim,pdim);

	mov	eax, DWORD PTR _Cf$[ebp]
	mov	ecx, DWORD PTR _Pinv$[ebp]
	push	edi
	push	edi
	mov	edi, DWORD PTR _Gf$[ebp]
	push	edi
	push	eax
	push	ecx
	call	_matvec_mul

; 1142 : 
; 1143 :       /* compute new search direction h */
; 1144 :       for ( i = 0 ; i < S->N ; i++ )

	xor	edx, edx
	add	esp, 68					; 00000044H
	cmp	DWORD PTR [esi+4], edx
	jle	$LN19@cg_lowest_
	mov	ecx, DWORD PTR _ax$[ebp]
	fldz
	sub	ecx, DWORD PTR _mx$[ebp]
	mov	eax, DWORD PTR _h$[ebp]
	mov	DWORD PTR tv1490[ebp], ecx
	mov	ecx, DWORD PTR _mx$[ebp]
	sub	ecx, eax
	mov	DWORD PTR tv1495[ebp], ecx
	jmp	SHORT $LN21@cg_lowest_
$LN115@cg_lowest_:
	mov	ecx, DWORD PTR tv1495[ebp]
$LN21@cg_lowest_:

; 1145 :       { 
; 1146 : #ifdef SYMMETRICWAY
; 1147 :         if ( count > 1 ) h[i] = -Gf[S->CN+1]*ah[i]; else h[i] = 0.0;
; 1148 : #else
; 1149 :         if ( count > 1 ) h[i] = -Gf[S->CN+1]*h[i]; else h[i] = 0.0;

	cmp	DWORD PTR _count$[ebp], 1
	jle	SHORT $LN18@cg_lowest_
	mov	ebx, DWORD PTR [esi+148]
	fld	QWORD PTR [edi+ebx*8+8]
	fmul	QWORD PTR [eax]
	fchs
	fstp	QWORD PTR [eax]
	jmp	SHORT $LN17@cg_lowest_
$LN18@cg_lowest_:
	fst	QWORD PTR [eax]
$LN17@cg_lowest_:

; 1150 : #endif
; 1151 :         h[i] += ax[i] - Gf[S->CN]*mx[i];

	mov	ebx, DWORD PTR [esi+148]
	fld	QWORD PTR [edi+ebx*8]
	mov	ebx, DWORD PTR tv1490[ebp]
	fmul	QWORD PTR [ecx+eax]
	add	ecx, eax
	fsubr	QWORD PTR [ecx+ebx]

; 1152 :         for ( j = 0 ; j < S->CN ; j++ )

	xor	ecx, ecx
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	cmp	DWORD PTR [esi+148], ecx
	jle	SHORT $LN20@cg_lowest_
$LN16@cg_lowest_:

; 1153 :           h[i] -= Gf[j]*S->C[j][i];

	mov	ebx, DWORD PTR [esi+160]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	fld	QWORD PTR [ebx+edx*8]
	inc	ecx
	fmul	QWORD PTR [edi+ecx*8-8]
	fsubr	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	cmp	ecx, DWORD PTR [esi+148]
	jl	SHORT $LN16@cg_lowest_
$LN20@cg_lowest_:

; 1142 : 
; 1143 :       /* compute new search direction h */
; 1144 :       for ( i = 0 ; i < S->N ; i++ )

	inc	edx
	add	eax, 8
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LN115@cg_lowest_
	mov	ebx, DWORD PTR _P$[ebp]
	fstp	ST(0)
$LN19@cg_lowest_:

; 1154 :       }
; 1155 : 
; 1156 :       /* recompute Ah */
; 1157 :       (*sp_mul_func)(S,h,ah); 

	mov	edx, DWORD PTR _ah$[ebp]
	mov	edi, DWORD PTR _h$[ebp]
	push	edx
	push	edi
	push	esi
	call	DWORD PTR _sp_mul_func
	add	esp, 12					; 0000000cH

; 1158 :       if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN12@cg_lowest_
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN12@cg_lowest_

; 1160 :       else hnorm = sqrt(dot(h,h,S->N));

	mov	eax, DWORD PTR [esi+4]
	push	eax
	push	edi
	push	edi
	call	_dot
	jmp	SHORT $LN165@cg_lowest_
$LN12@cg_lowest_:

; 1159 :         hnorm = sqrt(sparse_metric_dot(h,h,&Met));

	push	OFFSET _Met
	push	edi
	push	edi
	call	_sparse_metric_dot
$LN165@cg_lowest_:
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fst	QWORD PTR _hnorm$89728[ebp]

; 1161 :       hnorm_inv = 1/hnorm;

	fld1

; 1162 : 
; 1163 :       /* find minimum along geodesic */
; 1164 :       a = xax;
; 1165 :       b = dot(x,ah,S->N)/hnorm;

	mov	ecx, DWORD PTR [esi+4]
	fdivrp	ST(1), ST(0)
	mov	edx, DWORD PTR _ah$[ebp]
	mov	eax, DWORD PTR _x$GSCopy$[ebp]
	push	ecx
	push	edx
	push	eax
	fstp	QWORD PTR _hnorm_inv$89729[ebp]
	call	_dot
	fdiv	QWORD PTR _hnorm$89728[ebp]

; 1166 :       c = dot(h,ah,S->N)/hnorm/hnorm;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _ah$[ebp]
	push	ecx
	push	edx
	push	edi
	fstp	QWORD PTR _b$89722[ebp]
	call	_dot
	fld	QWORD PTR _hnorm$89728[ebp]
	fdiv	ST(1), ST(0)
	add	esp, 24					; 00000018H
	fdivp	ST(1), ST(0)

; 1167 :       evalue = 0.5*(a+c-sqrt((a-c)*(a-c)+4*b*b));  /* smallest ev */

	fld	QWORD PTR _xax$[ebp]
	fld	ST(0)
	fsub	ST(0), ST(2)
	fxch	ST(2)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR tv1378[ebp]
	fld	QWORD PTR _b$89722[ebp]
	fld	QWORD PTR __real@4010000000000000
	fmul	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fsubr	QWORD PTR tv1378[ebp]
	fmul	QWORD PTR __real@3fe0000000000000

; 1168 :       denom = sqrt(b*b + (evalue - a)*(evalue - a));

	fsub	QWORD PTR _xax$[ebp]
	fst	QWORD PTR tv1160[ebp]
	fmul	ST(0), ST(0)
	fst	QWORD PTR tv1164[ebp]
	fld	QWORD PTR _b$89722[ebp]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt

; 1169 :       if ( b < 0.0 ) denom = -denom;

	fldz
	fld	QWORD PTR _b$89722[ebp]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN10@cg_lowest_
	fxch	ST(1)
	fchs
	fxch	ST(1)
$LN10@cg_lowest_:

; 1170 :       q2 = (evalue - a)/denom;

	fld	QWORD PTR tv1160[ebp]

; 1171 :       q1comp = (evalue-a)*(evalue-a)/denom/(denom+b); 
; 1172 :       /* rotate h and x */
; 1173 :       for ( i = 0 ; i < S->N ; i++ )

	xor	edx, edx
	fdiv	ST(0), ST(2)
	fld	QWORD PTR tv1164[ebp]
	fdiv	ST(0), ST(3)
	fxch	ST(3)
	faddp	ST(2), ST(0)
	fxch	ST(2)
	fdivrp	ST(1), ST(0)
	cmp	DWORD PTR [esi+4], edx
	jle	$LN151@cg_lowest_
	mov	ecx, DWORD PTR _x$GSCopy$[ebp]
	fld	QWORD PTR _hnorm_inv$89729[ebp]
	fld	QWORD PTR _hnorm$89728[ebp]
	mov	eax, edi
	sub	ecx, edi
$LN9@cg_lowest_:

; 1174 :       { REAL xtmp = x[i]*hnorm;

	fld	QWORD PTR [ecx+eax]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8

; 1175 :         REAL htmp = h[i]*hnorm_inv;

	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(3)

; 1176 :         x[i] += -q1comp*x[i] + q2*htmp;

	fmul	ST(0), ST(5)
	fld	QWORD PTR [ecx+eax-8]
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fadd	QWORD PTR [ecx+eax-8]
	fstp	QWORD PTR [ecx+eax-8]

; 1177 :         h[i] += -q2*xtmp  -q1comp*h[i]; 

	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(4)
	fxch	ST(1)
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LN9@cg_lowest_

; 1171 :       q1comp = (evalue-a)*(evalue-a)/denom/(denom+b); 
; 1172 :       /* rotate h and x */
; 1173 :       for ( i = 0 ; i < S->N ; i++ )

	fstp	ST(2)
	fstp	ST(2)
	fstp	ST(1)
$LN166@cg_lowest_:

; 1178 :       }
; 1179 :       if ( (count < maxcount) && (maxcount > 5) && (count % (maxcount/5) == 0) )

	mov	edi, DWORD PTR _count$[ebp]
	fstp	ST(0)
	mov	ecx, DWORD PTR _maxcount$[ebp]
	cmp	edi, ecx
	jge	SHORT $LN38@cg_lowest_
	cmp	ecx, 5
	jle	SHORT $LN38@cg_lowest_
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	eax, edi
	cdq
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN122@cg_lowest_

; 1180 :       { 
; 1181 : #ifdef FLOAT128
; 1182 :      sprintf(msg,"%3d.    %3.*Qg\n",count,DPREC,xax);
; 1183 : #elif defined(LONGDOUBLE)
; 1184 :      sprintf(msg,"%3d.    %3.*Lg\n",count,DPREC,xax);
; 1185 : #else
; 1186 :      sprintf(msg,"%3d.    %3.17g\n",count,xax);

	fld	QWORD PTR _xax$[ebp]
	mov	edx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	push	OFFSET ??_C@_0BA@HPGBJIPI@?$CF3d?4?5?5?5?5?$CF3?417g?6?$AA@
	push	edx
	call	_sprintf

; 1187 : #endif 
; 1188 :      outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 24					; 00000018H
$LN122@cg_lowest_:
	mov	ecx, DWORD PTR _maxcount$[ebp]
$LN38@cg_lowest_:

; 1189 :       }
; 1190 :     } while ( (fabs(xax - old_xax) > 10*machine_eps*fabs(xax)) && (count<maxcount) );

	fld	QWORD PTR _xax$[ebp]
	fld	QWORD PTR _old_xax$[ebp]
	fsubr	ST(0), ST(1)
	fabs
	fld	ST(1)
	fabs
	fld	QWORD PTR _machine_eps
	fmul	QWORD PTR __real@4024000000000000
	fmulp	ST(1), ST(0)
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	$LN5@cg_lowest_
	cmp	edi, ecx
	jl	$LN118@cg_lowest_

; 1191 :     if ( count < maxcount )

	mov	edi, DWORD PTR _count$[ebp]
$LN4@cg_lowest_:

; 1203 : 
; 1204 : #ifdef FLOAT128
; 1205 :      sprintf(msg,"%3d.    %3.*Qg  max iterations\n",count,DPREC,xax);
; 1206 : #elif defined(LONGDOUBLE)
; 1207 :      sprintf(msg,"%3d.    %3.*Lg  max iterations\n",count,DPREC,xax);
; 1208 : #else
; 1209 :      sprintf(msg,"%3d.    %3.17g  max iterations\n",count,xax);

	mov	eax, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	push	OFFSET ??_C@_0CA@CMJBFKAG@?$CF3d?4?5?5?5?5?$CF3?417g?5?5max?5iterations?6?$AA@
	push	eax
	call	_sprintf

; 1210 : #endif 
; 1211 :      outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
$LN167@cg_lowest_:
	call	_outstring
	add	esp, 24					; 00000018H
	push	100					; 00000064H
	lea	edx, DWORD PTR _response$[ebp]
	push	edx
	push	OFFSET ??_C@_0BH@BNPHLKFG@Enter?5max?5iterations?3?5?$AA@
	call	_prompt
	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	call	_atoi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _maxcount$[ebp], eax
	test	eax, eax
	jne	$LL117@cg_lowest_
$LN76@cg_lowest_:

; 1212 :       }
; 1213 :   }
; 1214 : 
; 1215 : 
; 1216 :   temp_free((char*)h);

	mov	ecx, DWORD PTR _h$[ebp]
	push	ecx
	call	_temp_free

; 1217 :   temp_free((char*)ah);

	mov	edx, DWORD PTR _ah$[ebp]
	push	edx
	call	_temp_free

; 1218 :   temp_free((char*)ax);

	mov	eax, DWORD PTR _ax$[ebp]
	push	eax
	call	_temp_free
	add	esp, 12					; 0000000cH

; 1219 :   if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN1@cg_lowest_
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $LN2@cg_lowest_
$LN1@cg_lowest_:

; 1220 :   { temp_free((char*)mx);

	mov	ecx, DWORD PTR _mx$[ebp]
	push	ecx
	call	_temp_free

; 1221 :     temp_free((char*)mh);

	mov	edx, DWORD PTR _mh$[ebp]
	push	edx
	call	_temp_free
	add	esp, 8
$LN2@cg_lowest_:

; 1222 :   }
; 1223 :   temp_free((char*)Gf);

	mov	eax, DWORD PTR _Gf$[ebp]
	push	eax
	call	_temp_free

; 1224 :   temp_free((char*)Cf);

	mov	ecx, DWORD PTR _Cf$[ebp]
	push	ecx
	call	_temp_free

; 1225 :   free_matrix(P);

	push	ebx
	call	_free_matrix

; 1226 :   free_matrix(Pinv);

	mov	edx, DWORD PTR _Pinv$[ebp]
	push	edx
	call	_free_matrix

; 1227 :   last_eigenvalue = xax;

	fld	QWORD PTR _xax$[ebp]

; 1228 :   return xax;
; 1229 : } /* end cg_lowest_eigenpair */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fst	QWORD PTR _last_eigenvalue
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN151@cg_lowest_:

; 1171 :       q1comp = (evalue-a)*(evalue-a)/denom/(denom+b); 
; 1172 :       /* rotate h and x */
; 1173 :       for ( i = 0 ; i < S->N ; i++ )

	fstp	ST(0)
	jmp	$LN166@cg_lowest_
$LN5@cg_lowest_:

; 1191 :     if ( count < maxcount )

	cmp	edi, ecx
	jge	$LN4@cg_lowest_

; 1192 :       { 
; 1193 : #ifdef FLOAT128
; 1194 :      sprintf(msg,"%3d.    %3.*Qg  converged\n",count,DPREC,xax);
; 1195 : #elif defined(LONGDOUBLE)
; 1196 :      sprintf(msg,"%3d.    %3.*Lg  converged\n",count,DPREC,xax);
; 1197 : #else
; 1198 :      sprintf(msg,"%3d.    %3.17g  converged\n",count,xax);

	mov	ecx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	push	OFFSET ??_C@_0BL@FEPPCLLD@?$CF3d?4?5?5?5?5?$CF3?417g?5?5converged?6?$AA@
	push	ecx
	call	_sprintf

; 1199 : #endif 
; 1200 :      outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx

; 1201 :       }
; 1202 :     else  { 

	jmp	$LN167@cg_lowest_
_cg_lowest_eigenpair ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@NDEJPAPD@?5?5?5?5?$CFf?5?5X?$FL?$CFd?$FN?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@IDONHBBH@?5?5?5?5?$CF20?415f?5?5X?$FL?$CFd?$FN?5v?$CFd?4?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0DE@NELHADNM@Hessian?5solve?5only?5reduced?5resid@ ; `string'
PUBLIC	_sp_hessian_solve
EXTRN	_pressures:DWORD
EXTRN	_sp_hessian_mult:PROC
EXTRN	_itdebug:DWORD
;	COMDAT ??_C@_0BC@NDEJPAPD@?5?5?5?5?$CFf?5?5X?$FL?$CFd?$FN?5?$CFs?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BC@NDEJPAPD@?5?5?5?5?$CFf?5?5X?$FL?$CFd?$FN?5?$CFs?6?$AA@ DB '    '
	DB	'%f  X[%d] %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IDONHBBH@?5?5?5?5?$CF20?415f?5?5X?$FL?$CFd?$FN?5v?$CFd?4?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BL@IDONHBBH@?5?5?5?5?$CF20?415f?5?5X?$FL?$CFd?$FN?5v?$CFd?4?$CFd?6?$AA@ DB ' '
	DB	'   %20.15f  X[%d] v%d.%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NELHADNM@Hessian?5solve?5only?5reduced?5resid@
CONST	SEGMENT
??_C@_0DE@NELHADNM@Hessian?5solve?5only?5reduced?5resid@ DB 'Hessian solv'
	DB	'e only reduced residual from %g to %g.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\bk.c
CONST	ENDS
;	COMDAT _sp_hessian_solve
_TEXT	SEGMENT
_resmag$89991 = -24					; size = 8
_rhsmag$89990 = -16					; size = 8
_T1$ = -8						; size = 4
_i$ = -8						; size = 4
_T3$ = -4						; size = 4
_xrhs$89987 = -4					; size = 4
tv1689 = 8						; size = 4
tv1175 = 8						; size = 4
_T2$ = 8						; size = 4
_S$ = 8							; size = 4
_rhs$ = 12						; size = 4
_X$ = 16						; size = 4
_set_pressure_flag$ = 20				; size = 4
_sp_hessian_solve PROC					; COMDAT

; 1495 : { /* solve stuff */

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx

; 1496 :   int i,j,ii,jj;
; 1497 :   REAL *T1,*T2,*T3;
; 1498 :   body_id b_id;
; 1499 :   struct gen_quant*q;
; 1500 :  
; 1501 :   if ( (S->CN > 0) && augmented_hessian_mode )

	mov	ebx, DWORD PTR _rhs$[ebp]
	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	mov	ecx, DWORD PTR [esi+148]
	push	edi
	test	ecx, ecx
	jle	SHORT $LN53@sp_hessian
	cmp	DWORD PTR _augmented_hessian_mode, 0
	je	SHORT $LN53@sp_hessian

; 1502 :     { /* Kludge since volume deltas got in with wrong sign */
; 1503 :       for ( i = S->N - S->CN ; i < S->N ; i++ )

	mov	edx, DWORD PTR [esi+4]
	mov	eax, edx
	sub	eax, ecx
	cmp	eax, edx
	jge	SHORT $LN53@sp_hessian
	npad	3
$LL55@sp_hessian:

; 1504 :         rhs[i] = - rhs[i];

	fld	QWORD PTR [ebx+eax*8]
	inc	eax
	fchs
	fstp	QWORD PTR [ebx+eax*8-8]
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL55@sp_hessian
$LN53@sp_hessian:

; 1505 :     }
; 1506 : 
; 1507 :   sp_solution(S,rhs,X,MKL_INDEF);

	mov	eax, DWORD PTR _X$[ebp]
	push	-2					; fffffffeH
	push	eax
	push	ebx
	push	esi
	call	_sp_solution
	add	esp, 16					; 00000010H

; 1508 : 
; 1509 :   /* check decrease in residual */
; 1510 :   if ( itdebug || hess_debug )

	cmp	DWORD PTR _itdebug, 0
	jne	SHORT $LN51@sp_hessian
	cmp	DWORD PTR _hess_debug, 0
	je	$LN52@sp_hessian
$LN51@sp_hessian:

; 1511 :   { REAL *xrhs = (REAL *)temp_calloc(S->maxN,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+8]
	push	1511					; 000005e7H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	ecx
	call	_kb_temp_calloc

; 1512 :     REAL rhsmag = 0.0;

	fldz

; 1513 :     REAL resmag = 0.0;
; 1514 :     sp_hessian_mult(S,X,xrhs);

	mov	edx, DWORD PTR _X$[ebp]
	fst	QWORD PTR _rhsmag$89990[ebp]
	mov	ebx, eax
	fstp	QWORD PTR _resmag$89991[ebp]
	push	ebx
	push	edx
	push	esi
	mov	DWORD PTR _xrhs$89987[ebp], ebx
	call	_sp_hessian_mult
	fld	QWORD PTR _resmag$89991[ebp]
	mov	edi, DWORD PTR [esi+4]
	fld	QWORD PTR _rhsmag$89990[ebp]
	add	esp, 28					; 0000001cH

; 1515 :     
; 1516 :     for ( i = 0 ; i < S->N ; i++ )

	xor	edx, edx
	cmp	edi, 4
	jl	$LC108@sp_hessian

; 1511 :   { REAL *xrhs = (REAL *)temp_calloc(S->maxN,sizeof(REAL));

	mov	edx, DWORD PTR _rhs$[ebp]
	lea	ecx, DWORD PTR [ebx+24]

; 1518 :       resmag += (rhs[i] - xrhs[i])*(rhs[i] - xrhs[i]);

	sub	ebx, edx
	lea	eax, DWORD PTR [edx+8]
	lea	edx, DWORD PTR [edi-4]
	shr	edx, 2
	mov	DWORD PTR tv1689[ebp], ebx
	inc	edx
	lea	ebx, DWORD PTR [edx*4]
	mov	DWORD PTR _i$[ebp], ebx
	mov	ebx, DWORD PTR tv1689[ebp]
$LN109@sp_hessian:
	fld	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	fld	QWORD PTR [eax-32]
	add	ecx, 32					; 00000020H
	dec	edx
	fld	QWORD PTR [eax-24]
	fld	QWORD PTR [eax-16]
	fld	ST(3)
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	faddp	ST(4), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(3)
	faddp	ST(1), ST(0)
	fld	ST(2)
	fmulp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [eax-40]
	fsub	QWORD PTR [ecx-56]
	fld	QWORD PTR [eax-32]
	fsub	QWORD PTR [eax+ebx-32]
	fld	QWORD PTR [eax-24]
	fsub	QWORD PTR [ecx-40]
	fld	QWORD PTR [eax-16]
	fsub	QWORD PTR [ecx-32]
	fld	ST(3)
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	faddp	ST(5), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(4)
	faddp	ST(1), ST(0)
	fld	ST(3)
	fmulp	ST(4), ST(0)
	faddp	ST(3), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(2), ST(0)
	jne	SHORT $LN109@sp_hessian

; 1517 :     { rhsmag += rhs[i]*rhs[i];

	mov	ebx, DWORD PTR _xrhs$89987[ebp]
	fst	QWORD PTR _rhsmag$89990[ebp]
	mov	edx, DWORD PTR _i$[ebp]
$LC108@sp_hessian:

; 1515 :     
; 1516 :     for ( i = 0 ; i < S->N ; i++ )

	cmp	edx, edi
	jge	SHORT $LN107@sp_hessian
	mov	eax, DWORD PTR _rhs$[ebp]
	mov	ecx, ebx
	sub	ecx, DWORD PTR _rhs$[ebp]
	lea	eax, DWORD PTR [eax+edx*8]
	sub	edi, edx
$LC50@sp_hessian:

; 1517 :     { rhsmag += rhs[i]*rhs[i];

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	edi
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)

; 1518 :       resmag += (rhs[i] - xrhs[i])*(rhs[i] - xrhs[i]);

	fld	QWORD PTR [eax-8]
	fsub	QWORD PTR [eax+ecx-8]
	fmul	ST(0), ST(0)
	faddp	ST(2), ST(0)
	jne	SHORT $LC50@sp_hessian

; 1517 :     { rhsmag += rhs[i]*rhs[i];

	fst	QWORD PTR _rhsmag$89990[ebp]
$LN107@sp_hessian:

; 1519 :     }
; 1520 :     if ( resmag > rhsmag/10 )

	fdiv	QWORD PTR __real@4024000000000000
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN130@sp_hessian

; 1521 :     { sprintf(errmsg,"Hessian solve only reduced residual from %g to %g.\n",
; 1522 :              (DOUBLE)sqrt(rhsmag),(DOUBLE)sqrt(resmag));

	call	__CIsqrt
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	QWORD PTR _rhsmag$89990[ebp]
	call	__CIsqrt
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0DE@NELHADNM@Hessian?5solve?5only?5reduced?5resid@
	push	OFFSET _errmsg
	call	_sprintf

; 1523 :       kb_error(2561,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2561					; 00000a01H
	call	_kb_error
	add	esp, 36					; 00000024H
	jmp	SHORT $LN47@sp_hessian
$LN130@sp_hessian:
	fstp	ST(0)
$LN47@sp_hessian:

; 1524 :     }
; 1525 :     temp_free((char*)xrhs);

	push	ebx
	call	_temp_free
	mov	ebx, DWORD PTR _rhs$[ebp]
	add	esp, 4
$LN52@sp_hessian:

; 1526 :   }
; 1527 : 
; 1528 :   if ( S->CN > 0 ) /* have constraints */ 

	mov	eax, DWORD PTR [esi+148]
	test	eax, eax
	jle	$LN16@sp_hessian

; 1529 :   { if ( augmented_hessian_mode )

	cmp	DWORD PTR _augmented_hessian_mode, 0
	je	SHORT $LN45@sp_hessian

; 1530 :     { /* remap Lagrange multipliers*/
; 1531 :       for ( i = 0 ; i < S->concount ; i++ )

	xor	eax, eax
	cmp	DWORD PTR [esi+144], eax
	jle	$LN115@sp_hessian
	mov	edx, DWORD PTR _X$[ebp]
$LL44@sp_hessian:

; 1532 :         if ( S->coninx[i] >= 0 )

	mov	ecx, DWORD PTR [esi+152]
	mov	ecx, DWORD PTR [ecx+eax*4]
	test	ecx, ecx
	js	SHORT $LN43@sp_hessian

; 1533 :           pressures[i] = -X[S->N - S->CN + S->coninx[i]];

	mov	edi, DWORD PTR [esi+4]
	sub	edi, DWORD PTR [esi+148]
	add	edi, ecx
	fld	QWORD PTR [edx+edi*8]
	mov	ecx, DWORD PTR _pressures
	fchs
	fstp	QWORD PTR [ecx+eax*8]
$LN43@sp_hessian:

; 1530 :     { /* remap Lagrange multipliers*/
; 1531 :       for ( i = 0 ; i < S->concount ; i++ )

	inc	eax
	cmp	eax, DWORD PTR [esi+144]
	jl	SHORT $LL44@sp_hessian

; 1534 :     }
; 1535 :     else 

	jmp	$LN115@sp_hessian
$LN45@sp_hessian:

; 1536 :     { REAL *con_rhs = (REAL*)temp_calloc(S->CN,sizeof(REAL));

	push	1536					; 00000600H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc
	mov	edi, eax

; 1537 :      for ( i = 0 ; i < S->concount ; i++ )

	xor	eax, eax
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [esi+144], eax
	jle	SHORT $LN114@sp_hessian
	npad	7
$LL39@sp_hessian:

; 1538 :      { j = S->coninx[i];

	mov	edx, DWORD PTR [esi+152]
	mov	ecx, DWORD PTR [edx+eax*4]

; 1539 :        if ( j >= 0 ) con_rhs[j] = rhs[S->N+i];

	test	ecx, ecx
	js	SHORT $LN38@sp_hessian
	mov	edx, DWORD PTR [esi+4]
	add	edx, eax
	fld	QWORD PTR [ebx+edx*8]
	fstp	QWORD PTR [edi+ecx*8]
$LN38@sp_hessian:

; 1537 :      for ( i = 0 ; i < S->concount ; i++ )

	inc	eax
	cmp	eax, DWORD PTR [esi+144]
	jl	SHORT $LL39@sp_hessian
$LN114@sp_hessian:

; 1540 :      }
; 1541 :      T1 = (REAL*)temp_calloc(S->CN,sizeof(REAL));

	mov	eax, DWORD PTR [esi+148]
	push	1541					; 00000605H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc

; 1542 :      T2 = (REAL*)temp_calloc(S->CN,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+148]
	push	1542					; 00000606H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	mov	ebx, eax
	push	8
	push	ecx
	mov	DWORD PTR _T1$[ebp], ebx
	call	_kb_temp_calloc

; 1543 :      T3 = (REAL*)temp_calloc(S->N,sizeof(REAL));

	mov	edx, DWORD PTR [esi+4]
	push	1543					; 00000607H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	edx
	mov	DWORD PTR _T2$[ebp], eax
	call	_kb_temp_calloc

; 1544 : 
; 1545 :      sp_aug_solve(S,X,con_rhs,T1,T2,T3);

	push	eax
	mov	DWORD PTR _T3$[ebp], eax
	mov	eax, DWORD PTR _T2$[ebp]
	push	eax
	push	ebx
	mov	ebx, DWORD PTR _X$[ebp]
	push	edi
	push	ebx
	push	esi
	call	_sp_aug_solve

; 1546 : 
; 1547 :      for ( i = 0 ; i < S->N ; i++ )

	xor	ecx, ecx
	add	esp, 72					; 00000048H
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN117@sp_hessian
	mov	edx, DWORD PTR _T3$[ebp]
	mov	eax, ebx
	sub	edx, ebx
$LL35@sp_hessian:

; 1548 :        X[i] -= T3[i];

	fld	QWORD PTR [eax]
	inc	ecx
	fsub	QWORD PTR [edx+eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LL35@sp_hessian
$LN117@sp_hessian:

; 1549 :      for ( i = 0 ; i < S->CN ; i++ ) con_rhs[i] = -T2[i];

	xor	ecx, ecx
	cmp	DWORD PTR [esi+148], ecx
	jle	SHORT $LN118@sp_hessian
	mov	edx, DWORD PTR _T2$[ebp]
	mov	eax, edi
	sub	edx, edi
$LL32@sp_hessian:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fchs
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR [esi+148]
	jl	SHORT $LL32@sp_hessian
$LN118@sp_hessian:

; 1550 :      
; 1551 :      /* remap Lagrange multipliers*/
; 1552 :      for ( i = 0 ; i < S->concount ; i++ )

	xor	eax, eax
	cmp	DWORD PTR [esi+144], eax
	jle	SHORT $LN27@sp_hessian
$LL29@sp_hessian:

; 1553 :         if ( S->coninx[i] >= 0 )

	mov	ecx, DWORD PTR [esi+152]
	mov	ecx, DWORD PTR [ecx+eax*4]
	test	ecx, ecx
	js	SHORT $LN28@sp_hessian

; 1554 :           pressures[i] = con_rhs[S->coninx[i]];

	fld	QWORD PTR [edi+ecx*8]
	mov	edx, DWORD PTR _pressures
	fstp	QWORD PTR [edx+eax*8]
$LN28@sp_hessian:

; 1550 :      
; 1551 :      /* remap Lagrange multipliers*/
; 1552 :      for ( i = 0 ; i < S->concount ; i++ )

	inc	eax
	cmp	eax, DWORD PTR [esi+144]
	jl	SHORT $LL29@sp_hessian
$LN27@sp_hessian:

; 1555 :      temp_free((char*)T1);

	mov	eax, DWORD PTR _T1$[ebp]
	push	eax
	call	_temp_free

; 1556 :      temp_free((char*)T2);

	mov	ecx, DWORD PTR _T2$[ebp]
	push	ecx
	call	_temp_free

; 1557 :      temp_free((char*)T3);

	mov	edx, DWORD PTR _T3$[ebp]
	push	edx
	call	_temp_free

; 1558 :      temp_free((char*)con_rhs);

	push	edi
	call	_temp_free
	add	esp, 16					; 00000010H
$LN115@sp_hessian:

; 1559 :     }
; 1560 : 
; 1561 :     if ( set_pressure_flag == SET_PRESSURE )

	cmp	DWORD PTR _set_pressure_flag$[ebp], 1
	jne	$LN16@sp_hessian

; 1562 :     {  if ( ! everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN21@sp_hessian

; 1563 :        { FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR _web+384
	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	je	SHORT $LN21@sp_hessian
	mov	ebx, DWORD PTR _web+348
$LL23@sp_hessian:
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+ecx*4]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN22@sp_hessian

; 1564 :          { REAL p = get_body_pressure(b_id)+pressures[loc_ordinal(b_id)];

	test	edx, edx
	je	SHORT $LN22@sp_hessian
	fld	QWORD PTR [esi+312]
	mov	eax, DWORD PTR _pressures
	fadd	QWORD PTR [eax+ecx*8]

; 1565 :            set_body_pressure(b_id,p);

	fstp	QWORD PTR [esi+312]
	mov	ebx, DWORD PTR _web+348
$LN22@sp_hessian:

; 1563 :        { FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, ecx
	shr	edx, 28					; 0000001cH
	and	edx, 1
	jne	SHORT $LL23@sp_hessian
$LN21@sp_hessian:

; 1566 :          }
; 1567 :        }
; 1568 :        for ( i = 0 ; i < gen_quant_count ; i++ )

	xor	edx, edx
	cmp	DWORD PTR _web+5528, edx
	jle	$LN16@sp_hessian
	xor	esi, esi
	npad	12
$LL18@sp_hessian:

; 1569 :        { q = GEN_QUANT(i);

	mov	eax, DWORD PTR _gen_quant_list

; 1570 :          if ( q->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [eax+esi+136]
	add	eax, esi
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN17@sp_hessian

; 1571 :          if ( q->flags & (Q_FIXED|Q_CONSERVED) )

	test	cl, 10					; 0000000aH
	je	SHORT $LN17@sp_hessian

; 1572 :          { q->pressure += pressures[everything_quantities_flag ? i :
; 1573 :                      web.skel[BODY].max_ord+1+i];

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN61@sp_hessian
	mov	ecx, edx
	jmp	SHORT $LN62@sp_hessian
$LN61@sp_hessian:
	mov	ecx, DWORD PTR _web+404
	lea	ecx, DWORD PTR [ecx+edx+1]
$LN62@sp_hessian:
	mov	edi, DWORD PTR _pressures
	fld	QWORD PTR [edi+ecx*8]
	fadd	QWORD PTR [eax+192]
	fst	QWORD PTR [eax+192]

; 1574 :            if ( valid_id(q->b_id) )

	mov	eax, DWORD PTR [eax+216]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN136@sp_hessian

; 1575 :            set_body_pressure(q->b_id,q->pressure);

	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [eax+312]
	jmp	SHORT $LN17@sp_hessian
$LN136@sp_hessian:
	fstp	ST(0)
$LN17@sp_hessian:

; 1566 :          }
; 1567 :        }
; 1568 :        for ( i = 0 ; i < gen_quant_count ; i++ )

	inc	edx
	add	esi, 368				; 00000170H
	cmp	edx, DWORD PTR _web+5528
	jl	SHORT $LL18@sp_hessian
$LN16@sp_hessian:

; 1576 :          }
; 1577 :        }
; 1578 :     }
; 1579 :   }
; 1580 :   
; 1581 :   if ( hess_debug == 101010101 )  // disable all this printing

	cmp	DWORD PTR _hess_debug, 101010101	; 06054ab5H
	jne	$LN1@sp_hessian

; 1582 :   { 
; 1583 :     #ifdef MPI_EVOLVER
; 1584 :     for ( ii = 0 ; ii < S->N ; ii++ )
; 1585 :       printf("    %20.15f  X[%d] \n",(DOUBLE)X[ii],ii);
; 1586 :     #else
; 1587 :     vertex_id v_id;
; 1588 :     MFOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR tv1175[ebp], ecx
	je	$LN111@sp_hessian
	mov	edi, DWORD PTR _web+12
	npad	9
$LL11@sp_hessian:
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN10@sp_hessian

; 1589 :     { struct hess_verlist *vh = get_vertex_vhead(v_id);

	mov	edx, DWORD PTR _vhead_attr
	mov	eax, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+eax+64]
	mov	esi, DWORD PTR [ecx+edx]
	shl	esi, 5
	add	esi, DWORD PTR _vhead

; 1590 :       for ( j = 0 ; j < vh->freedom ; j++ )

	xor	eax, eax
	cmp	DWORD PTR [esi+8], eax
	jle	SHORT $LN10@sp_hessian
$LL6@sp_hessian:

; 1591 :       { ii = vh->rownum+j;

	mov	ecx, DWORD PTR [esi+12]
	add	ecx, eax

; 1592 :         printf("    %20.15f  X[%d] v%d.%d\n",(DOUBLE)X[ii],ii,ordinal(v_id)+1,j+1);

	cmp	DWORD PTR tv1175[ebp], 0
	je	SHORT $LN63@sp_hessian
	mov	edx, ebx
	jmp	SHORT $LN64@sp_hessian
$LN63@sp_hessian:
	or	edx, -1
$LN64@sp_hessian:
	lea	edi, DWORD PTR [eax+1]
	mov	eax, DWORD PTR _X$[ebp]
	fld	QWORD PTR [eax+ecx*8]
	push	edi
	inc	edx
	push	edx
	push	ecx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BL@IDONHBBH@?5?5?5?5?$CF20?415f?5?5X?$FL?$CFd?$FN?5v?$CFd?4?$CFd?6?$AA@
	call	_printf
	mov	eax, edi
	add	esp, 24					; 00000018H
	cmp	eax, DWORD PTR [esi+8]
	jl	SHORT $LL6@sp_hessian

; 1590 :       for ( j = 0 ; j < vh->freedom ; j++ )

	mov	edi, DWORD PTR _web+12
$LN10@sp_hessian:

; 1582 :   { 
; 1583 :     #ifdef MPI_EVOLVER
; 1584 :     for ( ii = 0 ; ii < S->N ; ii++ )
; 1585 :       printf("    %20.15f  X[%d] \n",(DOUBLE)X[ii],ii);
; 1586 :     #else
; 1587 :     vertex_id v_id;
; 1588 :     MFOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR tv1175[ebp], ecx
	jne	$LL11@sp_hessian
$LN111@sp_hessian:

; 1593 :       } 
; 1594 :     }
; 1595 :     #endif
; 1596 :     for ( i = 0 ; i < optparamcount ; i++ )

	xor	edi, edi
	cmp	DWORD PTR _optparamcount, edi
	jle	$LN1@sp_hessian
	mov	ebx, DWORD PTR _X$[ebp]
	mov	esi, OFFSET _optparam+48
$LL112@sp_hessian:

; 1597 :     { ii = optparam[i].pnum;

	mov	eax, DWORD PTR [esi-48]

; 1598 :       jj = optparam[i].rownum;

	mov	edx, DWORD PTR [esi]

; 1599 :       printf("    %f  X[%d] %s\n",(DOUBLE)X[jj],jj,globals(ii)->name);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN65@sp_hessian
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN67@sp_hessian
	mov	ecx, DWORD PTR _localbase
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN66@sp_hessian
$LN67@sp_hessian:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN65@sp_hessian
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN66@sp_hessian
$LN65@sp_hessian:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx]
$LN66@sp_hessian:
	fld	QWORD PTR [ebx+edx*8]
	push	eax
	push	edx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BC@NDEJPAPD@?5?5?5?5?$CFf?5?5X?$FL?$CFd?$FN?5?$CFs?6?$AA@
	call	_printf
	inc	edi
	add	esp, 20					; 00000014H
	add	esi, 56					; 00000038H
	cmp	edi, DWORD PTR _optparamcount
	jl	$LL112@sp_hessian
$LN1@sp_hessian:
	pop	edi
	pop	esi
	pop	ebx

; 1600 :     }
; 1601 :   }
; 1602 : } /* end sp_hessian_solve */

	mov	esp, ebp
	pop	ebp
	ret	0
_sp_hessian_solve ENDP
_TEXT	ENDS
PUBLIC	_sp_hessian_solve_multi
; Function compile flags: /Ogtp
;	COMDAT _sp_hessian_solve_multi
_TEXT	SEGMENT
_S$ = 8							; size = 4
_rhs$ = 12						; size = 4
_X$ = 16						; size = 4
_rk$ = 20						; size = 4
_sp_hessian_solve_multi PROC				; COMDAT

; 1618 : { /* solve stuff */

	push	ebp
	mov	ebp, esp
	push	ebx

; 1619 :   int k;
; 1620 :  
; 1621 :   for ( k = 0 ; k < rk ; k++ )

	mov	ebx, DWORD PTR _rk$[ebp]
	test	ebx, ebx
	jle	SHORT $LN1@sp_hessian@2
	push	esi
	mov	esi, DWORD PTR _rhs$[ebp]
	push	edi
	mov	edi, DWORD PTR _X$[ebp]
	sub	edi, esi
$LL8@sp_hessian@2:

; 1622 :     sp_hessian_solve(S,rhs[k],X[k],0);

	mov	eax, DWORD PTR [edi+esi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _S$[ebp]
	push	0
	push	eax
	push	ecx
	push	edx
	call	_sp_hessian_solve
	add	esp, 16					; 00000010H
	add	esi, 4
	dec	ebx
	jne	SHORT $LL8@sp_hessian@2
	pop	edi
	pop	esi
$LN1@sp_hessian@2:
	pop	ebx

; 1623 : 
; 1624 : #ifdef oldstuff
; 1625 :   (*sp_solve_multi_func)(S,rhs,X,rk);
; 1626 : 
; 1627 :   if ( S->CN > 0 ) /* have constraints */
; 1628 :   { REAL **con_rhs = dmatrix(0,rk-1,0,S->CN);
; 1629 :      for ( i = 0 ; i < S->concount ; i++ )
; 1630 :      { int j = S->coninx[i];
; 1631 :        if ( j >= 0 ) 
; 1632 :          for ( k = 0 ; k < rk ; k++ ) con_rhs[k][j] = rhs[k][S->N+i];
; 1633 :      }
; 1634 :      T1 = (REAL*)temp_calloc(S->CN,sizeof(REAL));
; 1635 :      T2 = (REAL*)temp_calloc(S->CN,sizeof(REAL));
; 1636 :      T3 = (REAL*)temp_calloc(S->N,sizeof(REAL));
; 1637 : 
; 1638 :      for ( k = 0 ; k < rk ; k++ )
; 1639 :      { 
; 1640 :        matvec_mul(S->C,X[k],T1,S->CN,S->N);
; 1641 :        for ( i = 0 ; i < S->CN ; i++ )
; 1642 :          T1[i] += con_rhs[k][i]; /* corrections */
; 1643 : #ifdef BLAS
; 1644 :        if ( blas_flag )
; 1645 :           LD_block_solve(S->CHinvCinv,T1,T2,S->CN);
; 1646 :        else
; 1647 : #endif
; 1648 :        matvec_mul(S->CHinvCinv,T1,T2,S->CN,S->CN); /* Lagrange multipliers */
; 1649 :        vec_mat_mul(T2,S->HinvC,T3,S->CN,S->N);
; 1650 :        for ( i = 0 ; i < S->N ; i++ )
; 1651 :          X[k][i] -= T3[i];
; 1652 :        for ( i = 0 ; i < S->CN ; i++ ) con_rhs[k][i] = -T2[i];
; 1653 :      }
; 1654 :      /* conrhs not used?? */
; 1655 : 
; 1656 :      temp_free((char*)T1);
; 1657 :      temp_free((char*)T2);
; 1658 :      temp_free((char*)T3);
; 1659 :      free_matrix(con_rhs);
; 1660 :   }
; 1661 : #endif
; 1662 : 
; 1663 : } /* end sp_hessian_solve_multi */

	pop	ebp
	ret	0
_sp_hessian_solve_multi ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@NAMCFDKN@Eigencounts?3?5?5?5?5?$CFd?5?$DM?0?5?5?$CFd?5?$DN?$DN?0?5?5?$CF@ ; `string'
PUBLIC	??_C@_0BE@OKNNBPGJ@Enter?5probe?5value?3?5?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_bk_eigenprobe
EXTRN	_atof:PROC
;	COMDAT ??_C@_0CG@NAMCFDKN@Eigencounts?3?5?5?5?5?$CFd?5?$DM?0?5?5?$CFd?5?$DN?$DN?0?5?5?$CF@
CONST	SEGMENT
??_C@_0CG@NAMCFDKN@Eigencounts?3?5?5?5?5?$CFd?5?$DM?0?5?5?$CFd?5?$DN?$DN?0?5?5?$CF@ DB 'E'
	DB	'igencounts:    %d <,  %d ==,  %d > ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OKNNBPGJ@Enter?5probe?5value?3?5?$AA@
CONST	SEGMENT
??_C@_0BE@OKNNBPGJ@Enter?5probe?5value?3?5?$AA@ DB 'Enter probe value: ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _bk_eigenprobe
_TEXT	SEGMENT
_response$90104 = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_bk_eigenprobe PROC					; COMDAT

; 1675 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	mov	esi, DWORD PTR _S$[ebp]

; 1676 :   for(;;)
; 1677 :   { char response[100];
; 1678 :     prompt("Enter probe value: ",response,sizeof(response));

	push	100					; 00000064H
	lea	eax, DWORD PTR _response$90104[ebp]
	push	eax
	push	OFFSET ??_C@_0BE@OKNNBPGJ@Enter?5probe?5value?3?5?$AA@
	call	_prompt

; 1679 :     if ( (response[0] == 0) || (response[0] == 'q') ) break;

	mov	al, BYTE PTR _response$90104[ebp]
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN8@bk_eigenpr
	npad	2
$LL4@bk_eigenpr:
	cmp	al, 113					; 00000071H
	je	SHORT $LN8@bk_eigenpr

; 1680 :     S->lambda = atof(response);

	lea	ecx, DWORD PTR _response$90104[ebp]
	push	ecx
	call	_atof
	fstp	QWORD PTR [esi+112]

; 1681 :     sp_factor(S,MKL_INDEF);

	push	-2					; fffffffeH
	push	esi
	call	_sp_factor

; 1682 :     (*sp_hess_project_setup_func)(S);

	push	esi
	call	DWORD PTR _sp_hess_project_setup_func

; 1683 :     sprintf(msg,"Eigencounts:    %d <,  %d ==,  %d > \n",S->neg,S->zero,S->pos);

	mov	edx, DWORD PTR [esi+184]
	mov	eax, DWORD PTR [esi+192]
	mov	ecx, DWORD PTR [esi+188]
	push	edx
	mov	edx, DWORD PTR _msg
	push	eax
	push	ecx
	push	OFFSET ??_C@_0CG@NAMCFDKN@Eigencounts?3?5?5?5?5?$CFd?5?$DM?0?5?5?$CFd?5?$DN?$DN?0?5?5?$CF@
	push	edx
	call	_sprintf

; 1684 :     outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	push	100					; 00000064H
	lea	ecx, DWORD PTR _response$90104[ebp]
	push	ecx
	push	OFFSET ??_C@_0BE@OKNNBPGJ@Enter?5probe?5value?3?5?$AA@
	call	_prompt
	mov	al, BYTE PTR _response$90104[ebp]
	add	esp, 52					; 00000034H
	test	al, al
	jne	SHORT $LL4@bk_eigenpr
$LN8@bk_eigenpr:

; 1685 :   }
; 1686 :   return;
; 1687 : } /* end bk_eigenprobe */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_bk_eigenprobe ENDP
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	??_C@_0BC@GPPINECM@?$CFd?5?5ev?5?$DN?5?$CF20?415f?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@NAKAGJGM@Enter?5maximum?5iterations?3?5?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_bk_inverse_it
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT ??_C@_0BC@GPPINECM@?$CFd?5?5ev?5?$DN?5?$CF20?415f?6?$AA@
CONST	SEGMENT
??_C@_0BC@GPPINECM@?$CFd?5?5ev?5?$DN?5?$CF20?415f?6?$AA@ DB '%d  ev = %20'
	DB	'.15f', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NAKAGJGM@Enter?5maximum?5iterations?3?5?$AA@
CONST	SEGMENT
??_C@_0BL@NAKAGJGM@Enter?5maximum?5iterations?3?5?$AA@ DB 'Enter maximum '
	DB	'iterations: ', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _bk_inverse_it
_TEXT	SEGMENT
_oldt$ = -148						; size = 8
_oldv0$90143 = -140					; size = 8
_its$ = -132						; size = 4
_oldvi$90144 = -128					; size = 4
_W$ = -124						; size = 4
_t$ = -120						; size = 8
tv305 = -116						; size = 4
_ii$ = -112						; size = 4
_k$ = -108						; size = 4
_response$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_S$ = 8							; size = 4
_V$ = 12						; size = 4
_bk_inverse_it PROC					; COMDAT

; 1700 : { int i,ii,k,its;

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _V$[ebp]
	push	edi
	mov	edi, DWORD PTR _S$[ebp]

; 1701 :   REAL t,oldt;
; 1702 :   char response[100];
; 1703 :   REAL *W = NULL, *WW = NULL; /* for use when metric is needed */
; 1704 : 
; 1705 :   prompt("Enter probe value: ",response,sizeof(response));

	push	100					; 00000064H
	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	xor	ebx, ebx
	push	OFFSET ??_C@_0BE@OKNNBPGJ@Enter?5probe?5value?3?5?$AA@
	mov	DWORD PTR _W$[ebp], ebx
	call	_prompt

; 1706 :   if ( (response[0] == 0) || (response[0] == 'q') ) return;

	mov	al, BYTE PTR _response$[ebp]
	add	esp, 12					; 0000000cH
	test	al, al
	je	$LN32@bk_inverse
	cmp	al, 113					; 00000071H
	je	$LN32@bk_inverse

; 1707 :   S->lambda = atof(response);

	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	call	_atof
	fstp	QWORD PTR [edi+112]

; 1708 :   sp_factor(S,MKL_INDEF);

	push	-2					; fffffffeH
	push	edi
	call	_sp_factor

; 1709 :   (*sp_hess_project_setup_func)(S);

	push	edi
	call	DWORD PTR _sp_hess_project_setup_func

; 1710 :   sprintf(msg,"Eigencounts:    %d <,  %d ==,  %d > \n",S->neg,S->zero,S->pos);

	mov	edx, DWORD PTR [edi+184]
	mov	eax, DWORD PTR [edi+192]
	mov	ecx, DWORD PTR [edi+188]
	push	edx
	mov	edx, DWORD PTR _msg
	push	eax
	push	ecx
	push	OFFSET ??_C@_0CG@NAMCFDKN@Eigencounts?3?5?5?5?5?$CFd?5?$DM?0?5?5?$CFd?5?$DN?$DN?0?5?5?$CF@
	push	edx
	call	_sprintf

; 1711 :   outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 40					; 00000028H

; 1712 : 
; 1713 :   if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, ebx
	jne	SHORT $LN30@bk_inverse
	cmp	DWORD PTR _hessian_linear_metric_flag, ebx
	je	SHORT $LN31@bk_inverse
$LN30@bk_inverse:

; 1714 :      W = (REAL*)temp_calloc(S->N,sizeof(REAL));

	mov	ecx, DWORD PTR [edi+4]
	push	1714					; 000006b2H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	ecx
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _W$[ebp], eax
$LN31@bk_inverse:

; 1715 :   /* inverse iteration */
; 1716 :   /* random starting vector */
; 1717 :   for ( i = 0 ; i < S->N ; i++ ) V[i] = drand48();

	cmp	DWORD PTR [edi+4], ebx
	jle	SHORT $LN27@bk_inverse
$LL29@bk_inverse:
	call	_drand48
	fstp	QWORD PTR [esi+ebx*8]
	inc	ebx
	cmp	ebx, DWORD PTR [edi+4]
	jl	SHORT $LL29@bk_inverse
$LN27@bk_inverse:

; 1718 :   t = 1/sqrt(dot(V,V,S->N));

	mov	edx, DWORD PTR [edi+4]
	push	edx
	push	esi
	push	esi
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fld1
	fdivrp	ST(1), ST(0)

; 1719 :   for ( i = ii = 0 ; i < S->N ; i++,ii++ ) V[i] *= t;

	xor	ebx, ebx
	xor	eax, eax
	fst	QWORD PTR _t$[ebp]
	cmp	DWORD PTR [edi+4], ebx
	jle	SHORT $LN59@bk_inverse
$LN26@bk_inverse:
	fld	ST(0)
	inc	eax
	fmul	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [esi+eax*8-8]
	cmp	eax, DWORD PTR [edi+4]
	jl	SHORT $LN26@bk_inverse
$LN59@bk_inverse:

; 1720 :   prompt("Enter maximum iterations: ",response,sizeof(response));

	push	100					; 00000064H
	fstp	ST(0)
	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	push	OFFSET ??_C@_0BL@NAKAGJGM@Enter?5maximum?5iterations?3?5?$AA@
	call	_prompt

; 1721 :   its = atoi(response);

	lea	ecx, DWORD PTR _response$[ebp]
	push	ecx
	call	_atoi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _its$[ebp], eax

; 1722 :   if ( its == 0 ) goto afterits;

	cmp	eax, ebx
	je	SHORT $afterits$90139

; 1723 :   oldt = 1e30; /* for convergence test */

	fld	QWORD PTR __real@46293e5939a08cea

; 1724 :   for ( k = 0, ii=0 ; k < its ; k++,ii++ )

	mov	DWORD PTR _k$[ebp], ebx
	fstp	QWORD PTR _oldt$[ebp]
	mov	DWORD PTR _ii$[ebp], ebx
	jg	SHORT $LN51@bk_inverse
	fld	QWORD PTR _t$[ebp]
$LN49@bk_inverse:

; 1753 :   }
; 1754 : #ifdef FLOAT128
; 1755 :   printf("%d  ev = %*.*Qf\n",k,DWIDTH,DPREC,S->lambda+t);
; 1756 : #elif defined(LONGDOUBLE)
; 1757 :   printf("%d  ev = %*.*Lf\n",k,DWIDTH,DPREC,S->lambda+t);
; 1758 : #else
; 1759 :   printf("%d  ev = %20.15f\n",k,S->lambda+t);

	fadd	QWORD PTR [edi+112]
	mov	eax, DWORD PTR _k$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	push	OFFSET ??_C@_0BC@GPPINECM@?$CFd?5?5ev?5?$DN?5?$CF20?415f?6?$AA@
	call	_printf
	add	esp, 16					; 00000010H
$afterits$90139:

; 1760 : #endif 
; 1761 : afterits:
; 1762 :   if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN1@bk_inverse
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	SHORT $LN32@bk_inverse
$LN1@bk_inverse:

; 1763 :       temp_free((char*)W);

	mov	ecx, DWORD PTR _W$[ebp]
	push	ecx
	call	_temp_free
	add	esp, 4
$LN32@bk_inverse:

; 1764 :   return;
; 1765 : } /* end bk_inverse_it() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LL85@bk_inverse:

; 1724 :   for ( k = 0, ii=0 ; k < its ; k++,ii++ )

	fstp	ST(0)
$LN51@bk_inverse:

; 1725 :   { REAL oldv0=1.0; /* for sign */
; 1726 :      int oldvi=0;     /* index of nonzero component */
; 1727 :      REAL eps = 1/sqrt((REAL)(S->N))/2;

	mov	ebx, DWORD PTR [edi+4]
	mov	DWORD PTR tv305[ebp], ebx
	fild	DWORD PTR tv305[ebp]
	mov	DWORD PTR _oldvi$90144[ebp], 0
	call	__CIsqrt
	fdivr	QWORD PTR __real@3fe0000000000000

; 1728 :      for ( i = 0, oldv0 = 0.0 ; i < S->N ; i++ ) 

	xor	ecx, ecx
	fldz
	fstp	QWORD PTR _oldv0$90143[ebp]
	test	ebx, ebx
	jle	SHORT $LN60@bk_inverse
$LN19@bk_inverse:

; 1729 :        if ( fabs(V[i]) > eps ) { oldvi = i; oldv0 = V[i]; break; }

	fld	QWORD PTR [esi+ecx*8]
	fabs
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN63@bk_inverse

; 1728 :      for ( i = 0, oldv0 = 0.0 ; i < S->N ; i++ ) 

	inc	ecx
	cmp	ecx, ebx
	jl	SHORT $LN19@bk_inverse
$LN60@bk_inverse:

; 1729 :        if ( fabs(V[i]) > eps ) { oldvi = i; oldv0 = V[i]; break; }

	fstp	ST(0)
$LN52@bk_inverse:

; 1730 :      if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN14@bk_inverse
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN14@bk_inverse

; 1732 :      else WW = V;

	mov	eax, esi
	jmp	SHORT $LN13@bk_inverse
$LN63@bk_inverse:

; 1729 :        if ( fabs(V[i]) > eps ) { oldvi = i; oldv0 = V[i]; break; }

	fstp	ST(0)
	mov	DWORD PTR _oldvi$90144[ebp], ecx
	fld	QWORD PTR [esi+ecx*8]
	fstp	QWORD PTR _oldv0$90143[ebp]
	jmp	SHORT $LN52@bk_inverse
$LN14@bk_inverse:

; 1731 :      {  (*sp_mul_func)(&Met,V,W); WW = W; }

	mov	ebx, DWORD PTR _W$[ebp]
	push	ebx
	push	esi
	push	OFFSET _Met
	call	DWORD PTR _sp_mul_func
	add	esp, 12					; 0000000cH
	mov	eax, ebx
$LN13@bk_inverse:

; 1733 :      sp_hessian_solve(S,WW,V,NO_SET_PRESSURE);

	push	0
	push	esi
	push	eax
	push	edi
	call	_sp_hessian_solve
	add	esp, 16					; 00000010H

; 1734 :      if ( web.area_norm_flag || hessian_linear_metric_flag ) 

	cmp	DWORD PTR _web+876, 0
	jne	SHORT $LN11@bk_inverse
	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	jne	SHORT $LN11@bk_inverse

; 1736 :      else t = 1/sqrt(dot(V,V,S->N));

	mov	edx, DWORD PTR [edi+4]
	push	edx
	push	esi
	push	esi
	call	_dot
	jmp	SHORT $LN87@bk_inverse
$LN11@bk_inverse:

; 1735 :        t = 1/sqrt(sparse_metric_dot(V,V,&Met));

	push	OFFSET _Met
	push	esi
	push	esi
	call	_sparse_metric_dot
$LN87@bk_inverse:
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fld1
	fdivrp	ST(1), ST(0)

; 1737 :      if ( V[oldvi]*oldv0 < 0. ) t = -t;  /* get sign right */

	mov	eax, DWORD PTR _oldvi$90144[ebp]
	fst	QWORD PTR _t$[ebp]
	fld	QWORD PTR [esi+eax*8]
	fmul	QWORD PTR _oldv0$90143[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN9@bk_inverse
	fchs
	fst	QWORD PTR _t$[ebp]
$LN9@bk_inverse:

; 1738 : #ifdef FLOAT128
; 1739 :      if ( k % 10 == 0 ) printf("%d  ev = %*.*Qf\n",k,DWIDTH,DPREC,S->lambda+t);
; 1740 : #elif defined(LONGDOUBLE)
; 1741 :      if ( k % 10 == 0 ) printf("%d  ev = %*.*Lf\n",k,DWIDTH,DPREC,S->lambda+t);
; 1742 : #else
; 1743 :      if ( k % 10 == 0 ) printf("%d  ev = %20.15f\n",k,S->lambda+t);

	mov	ebx, DWORD PTR _k$[ebp]
	mov	eax, -858993459				; cccccccdH
	mul	ebx
	shr	edx, 3
	lea	ecx, DWORD PTR [edx+edx*4]
	add	ecx, ecx
	mov	edx, ebx
	sub	edx, ecx
	jne	SHORT $LN53@bk_inverse
	fadd	QWORD PTR [edi+112]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ebx
	push	OFFSET ??_C@_0BC@GPPINECM@?$CFd?5?5ev?5?$DN?5?$CF20?415f?6?$AA@
	call	_printf
	fld	QWORD PTR _t$[ebp]
	add	esp, 16					; 00000010H
$LN53@bk_inverse:

; 1744 : #endif 
; 1745 :      for ( i = 0 ; i < S->N ; i++ ) V[i] *= t;

	xor	eax, eax
	cmp	DWORD PTR [edi+4], eax
	jle	SHORT $LN5@bk_inverse
$LN7@bk_inverse:
	fld	ST(0)
	inc	eax
	fmul	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [esi+eax*8-8]
	cmp	eax, DWORD PTR [edi+4]
	jl	SHORT $LN7@bk_inverse
$LN5@bk_inverse:

; 1746 :      if ( fabs(t-oldt) <= 100*machine_eps*fabs(t) ) 

	fld	QWORD PTR _oldt$[ebp]
	fsubr	ST(0), ST(1)
	fabs
	fld	ST(1)
	fabs
	fld	QWORD PTR _machine_eps
	fmul	QWORD PTR __real@4059000000000000
	fmulp	ST(1), ST(0)
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN3@bk_inverse

; 1747 :       { /* does twice as many iterations as needed to get t converged */
; 1748 :         /* so eigenvector gets fully converged also */
; 1749 :         ii -= 2;

	mov	eax, DWORD PTR _ii$[ebp]
	sub	eax, 2
	mov	DWORD PTR _ii$[ebp], eax

; 1750 :         if ( ii <= 0 )break;

	test	eax, eax
	jle	$LN49@bk_inverse
	mov	ebx, DWORD PTR _k$[ebp]
$LN3@bk_inverse:

; 1724 :   for ( k = 0, ii=0 ; k < its ; k++,ii++ )

	inc	DWORD PTR _ii$[ebp]

; 1751 :       }
; 1752 :      oldt = t;

	fst	QWORD PTR _oldt$[ebp]
	inc	ebx
	mov	DWORD PTR _k$[ebp], ebx
	cmp	ebx, DWORD PTR _its$[ebp]
	jl	$LL85@bk_inverse

; 1724 :   for ( k = 0, ii=0 ; k < its ; k++,ii++ )

	jmp	$LN49@bk_inverse
_bk_inverse_it ENDP
_TEXT	ENDS
PUBLIC	??_C@_06CFAAKBKG@check?3?$AA@			; `string'
PUBLIC	??_C@_02EHLIIHJM@X?3?$AA@			; `string'
PUBLIC	??_C@_0CK@PFMNGHPN@Hessian?5not?5positive?5definite?4?5I@ ; `string'
PUBLIC	??_C@_04FEKPMJEG@?$CFg?5?6?$AA@			; `string'
PUBLIC	??_C@_04DHEDGMNB@rhs?3?$AA@			; `string'
PUBLIC	_sp_Hessian_solver
EXTRN	_puts:PROC
EXTRN	_sp_ordering_func:DWORD
EXTRN	_sp_constraint_setup_func:DWORD
EXTRN	_sp_AIJ_setup_func:DWORD
;	COMDAT ??_C@_06CFAAKBKG@check?3?$AA@
CONST	SEGMENT
??_C@_06CFAAKBKG@check?3?$AA@ DB 'check:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02EHLIIHJM@X?3?$AA@
CONST	SEGMENT
??_C@_02EHLIIHJM@X?3?$AA@ DB 'X:', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PFMNGHPN@Hessian?5not?5positive?5definite?4?5I@
CONST	SEGMENT
??_C@_0CK@PFMNGHPN@Hessian?5not?5positive?5definite?4?5I@ DB 'Hessian not'
	DB	' positive definite. Index: %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FEKPMJEG@?$CFg?5?6?$AA@
CONST	SEGMENT
??_C@_04FEKPMJEG@?$CFg?5?6?$AA@ DB '%g ', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DHEDGMNB@rhs?3?$AA@
CONST	SEGMENT
??_C@_04DHEDGMNB@rhs?3?$AA@ DB 'rhs:', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _sp_Hessian_solver
_TEXT	SEGMENT
_S$ = 8							; size = 4
_rhs$ = 12						; size = 4
_X$ = 16						; size = 4
_Xptr$ = 16						; size = 4
_sp_Hessian_solver PROC					; COMDAT

; 1778 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 1779 :   REAL *X;
; 1780 :   
; 1781 :   if ( *Xptr == NULL )

	mov	esi, DWORD PTR _S$[ebp]
	push	edi
	mov	edi, DWORD PTR _Xptr$[ebp]
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN14@sp_Hessian

; 1782 :     *Xptr = (REAL*)temp_calloc(S->N,sizeof(REAL));

	mov	eax, DWORD PTR [esi+4]
	push	1782					; 000006f6H
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [edi], eax
$LN14@sp_Hessian:

; 1783 :   X = *Xptr;
; 1784 : 
; 1785 :   (*sp_AIJ_setup_func)(S->A_rows,S);

	mov	edx, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [edi]
	push	esi
	push	edx
	mov	DWORD PTR _X$[ebp], ecx
	call	DWORD PTR _sp_AIJ_setup_func

; 1786 :   (*sp_constraint_setup_func)
; 1787 :      (web.skel[BODY].max_ord+1 + gen_quant_count,S);

	mov	eax, DWORD PTR _web+404
	mov	ecx, DWORD PTR _web+5528
	lea	edx, DWORD PTR [ecx+eax+1]
	push	esi
	push	edx
	call	DWORD PTR _sp_constraint_setup_func

; 1788 :   if ( sp_ordering_func ) (*sp_ordering_func)(S);

	mov	eax, DWORD PTR _sp_ordering_func
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN13@sp_Hessian
	push	esi
	call	eax
	add	esp, 4
$LN13@sp_Hessian:

; 1789 :   sp_factor(S,MKL_INDEF);

	push	-2					; fffffffeH
	push	esi
	call	_sp_factor

; 1790 :   (*sp_hess_project_setup_func)(S);

	push	esi
	call	DWORD PTR _sp_hess_project_setup_func

; 1791 : 
; 1792 :   if ( hess_debug )

	mov	ebx, DWORD PTR _rhs$[ebp]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _hess_debug, 0
	je	SHORT $LN23@sp_Hessian

; 1793 :   { int i;
; 1794 :     puts("rhs:");

	push	OFFSET ??_C@_04DHEDGMNB@rhs?3?$AA@
	call	_puts

; 1795 :     for ( i = 0 ; i < S->N ; i++ ) printf("%g \n",(DOUBLE)rhs[i]);

	xor	edi, edi
	add	esp, 4
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN23@sp_Hessian
$LL11@sp_Hessian:
	fld	QWORD PTR [ebx+edi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_04FEKPMJEG@?$CFg?5?6?$AA@
	call	_printf
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL11@sp_Hessian
$LN23@sp_Hessian:

; 1796 :   }
; 1797 : 
; 1798 :   sp_hessian_solve(S,rhs,X,SET_PRESSURE);

	mov	eax, DWORD PTR _X$[ebp]
	push	1
	push	eax
	push	ebx
	push	esi
	call	_sp_hessian_solve

; 1799 :   if ( S->neg > 0 )

	mov	eax, DWORD PTR [esi+188]
	add	esp, 16					; 00000010H
	test	eax, eax
	jle	SHORT $LN8@sp_Hessian

; 1800 :     { sprintf(msg,"Hessian not positive definite. Index: %d\n",S->neg);

	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0CK@PFMNGHPN@Hessian?5not?5positive?5definite?4?5I@
	push	ecx
	call	_sprintf

; 1801 :       kb_error(1825,msg,WARNING);

	mov	edx, DWORD PTR _msg
	push	2
	push	edx
	push	1825					; 00000721H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN8@sp_Hessian:

; 1802 :     } 
; 1803 : 
; 1804 :   if ( hess_debug )

	cmp	DWORD PTR _hess_debug, 0
	je	$LN7@sp_Hessian

; 1805 :   { int i;
; 1806 :     REAL *out = (REAL*)temp_calloc(S->N,sizeof(REAL));

	mov	eax, DWORD PTR [esi+4]
	push	1806					; 0000070eH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc

; 1807 :     puts("X:");

	push	OFFSET ??_C@_02EHLIIHJM@X?3?$AA@
	mov	ebx, eax
	call	_puts

; 1808 :     for ( i = 0 ; i < S->N ; i++ ) printf("%g \n",(DOUBLE)X[i]);

	xor	edi, edi
	add	esp, 20					; 00000014H
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN4@sp_Hessian
	npad	4
$LL6@sp_Hessian:
	mov	ecx, DWORD PTR _X$[ebp]
	fld	QWORD PTR [ecx+edi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_04FEKPMJEG@?$CFg?5?6?$AA@
	call	_printf
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL6@sp_Hessian
$LN4@sp_Hessian:

; 1809 :     bk_mul(S,X,out);

	mov	edx, DWORD PTR _X$[ebp]
	push	ebx
	push	edx
	push	esi
	call	_bk_mul

; 1810 :     puts("check:");

	push	OFFSET ??_C@_06CFAAKBKG@check?3?$AA@
	call	_puts

; 1811 :     for ( i = 0 ; i < S->N ; i++ ) printf("%g \n",(DOUBLE)out[i]);

	xor	edi, edi
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN1@sp_Hessian
	npad	2
$LL3@sp_Hessian:
	fld	QWORD PTR [ebx+edi*8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_04FEKPMJEG@?$CFg?5?6?$AA@
	call	_printf
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL3@sp_Hessian
$LN1@sp_Hessian:

; 1812 :     temp_free((char*)out);

	push	ebx
	call	_temp_free
	add	esp, 4
$LN7@sp_Hessian:
	pop	edi
	pop	esi
	pop	ebx

; 1813 :   }
; 1814 : } /* end sp_hessian_solver() */

	pop	ebp
	ret	0
_sp_Hessian_solver ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@EKCPEPGG@Internal?5error?3?5Must?5call?5sp_fac@ ; `string'
PUBLIC	_sp_CHinvC
;	COMDAT ??_C@_0DH@EKCPEPGG@Internal?5error?3?5Must?5call?5sp_fac@
CONST	SEGMENT
??_C@_0DH@EKCPEPGG@Internal?5error?3?5Must?5call?5sp_fac@ DB 'Internal er'
	DB	'ror: Must call sp_factor before sp_CHinvC.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _sp_CHinvC
_TEXT	SEGMENT
$T91338 = -16						; size = 4
_i$ = -12						; size = 4
_j$ = -8						; size = 4
_BB$ = -4						; size = 4
_S$ = 8							; size = 4
_sp_CHinvC PROC						; COMDAT

; 1860 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi

; 1861 :   int n; /* row index */
; 1862 :   int i,j,k;
; 1863 :   REAL *BB,*Y;
; 1864 : 
; 1865 :   if ( S->P == NULL )

	mov	edi, DWORD PTR _S$[ebp]
	cmp	DWORD PTR [edi+68], 0
	jne	SHORT $LN28@sp_CHinvC

; 1866 :    kb_error(2530,"Internal error: Must call sp_factor before sp_CHinvC.\n",
; 1867 :      RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DH@EKCPEPGG@Internal?5error?3?5Must?5call?5sp_fac@
	push	2530					; 000009e2H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN28@sp_CHinvC:

; 1868 : 
; 1869 :   BB = (REAL*)temp_calloc(S->N,sizeof(REAL));  /* expanded rhs */

	mov	eax, DWORD PTR [edi+4]
	push	1869					; 0000074dH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	eax
	call	_kb_temp_calloc

; 1870 :   Y = (REAL*)temp_calloc(S->N,sizeof(REAL));  /* solution */

	mov	ecx, DWORD PTR [edi+4]
	push	1870					; 0000074eH
	push	OFFSET ??_C@_04LOHMKLNL@BK?4C?$AA@
	push	8
	push	ecx
	mov	DWORD PTR _BB$[ebp], eax
	call	_kb_temp_calloc

; 1871 : 
; 1872 :   for ( i = 0 ; i < S->CN ; i++ )

	xor	esi, esi
	add	esp, 32					; 00000020H
	mov	ebx, eax
	mov	DWORD PTR _i$[ebp], esi
	cmp	DWORD PTR [edi+148], esi
	jle	$LN11@sp_CHinvC
	npad	7
$LL29@sp_CHinvC:

; 1873 :   {
; 1874 :     /* solve H Y = C */
; 1875 :     memset(BB,0,S->N*sizeof(REAL));

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR _BB$[ebp]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	push	edx
	push	0
	push	eax
	call	_memset
	mov	ecx, DWORD PTR [edi+172]

; 1876 :     for ( n = S->CIA[i] ; n < S->CIA[i+1] ; n++ ) 

	mov	eax, DWORD PTR [ecx+esi*4]
	lea	ecx, DWORD PTR [ecx+esi*4]
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR [ecx+4]
	jge	SHORT $LN8@sp_CHinvC
	npad	7
$LL10@sp_CHinvC:

; 1877 :       BB[S->CJA[n]] = S->CA[n]; 

	mov	edx, DWORD PTR [edi+180]
	mov	ecx, DWORD PTR [edi+176]
	fld	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR _BB$[ebp]
	fstp	QWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [edi+172]
	inc	eax
	cmp	eax, DWORD PTR [ecx+esi*4+4]
	jl	SHORT $LL10@sp_CHinvC
$LN8@sp_CHinvC:

; 1878 :     sp_solution(S,BB,Y,MKL_INDEF);

	mov	edx, DWORD PTR _BB$[ebp]
	push	-2					; fffffffeH
	push	ebx
	push	edx
	push	edi
	call	_sp_solution

; 1879 : 
; 1880 :     /* multiply by rows of C */
; 1881 :     for ( j = 0 ; j <= i ; j++ )

	xor	eax, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _j$[ebp], eax
	test	esi, esi
	js	$LN12@sp_CHinvC
	fldz
$LN7@sp_CHinvC:
	mov	ecx, DWORD PTR [edi+172]

; 1882 :     { REAL sum;
; 1883 :       for ( k = S->CIA[j] , sum = 0.0 ; k < S->CIA[j+1] ; k++ )

	fld	ST(0)
	mov	edx, DWORD PTR [ecx+eax*4+4]
	mov	esi, DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T91338[ebp], edx
	cmp	esi, edx
	jge	$LN25@sp_CHinvC
	mov	ecx, edx
	sub	ecx, esi
	cmp	ecx, 4
	jl	SHORT $LC26@sp_CHinvC

; 1884 :         sum += S->CA[k]*Y[S->CJA[k]];

	mov	eax, DWORD PTR [edi+180]
	sub	edx, esi
	sub	edx, 4
	lea	ecx, DWORD PTR [eax+esi*8+16]
	mov	eax, DWORD PTR [edi+176]
	shr	edx, 2
	inc	edx
	lea	eax, DWORD PTR [eax+esi*4+8]
	lea	esi, DWORD PTR [esi+edx*4]
$LN27@sp_CHinvC:
	mov	edi, DWORD PTR [eax-8]
	fld	QWORD PTR [ebx+edi*8]
	mov	edi, DWORD PTR [eax-4]
	fmul	QWORD PTR [ecx-16]
	add	eax, 16					; 00000010H
	add	ecx, 32					; 00000020H
	dec	edx
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+edi*8]
	mov	edi, DWORD PTR [eax-16]
	fmul	QWORD PTR [ecx-40]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+edi*8]
	mov	edi, DWORD PTR [eax-12]
	fmul	QWORD PTR [ecx-32]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+edi*8]
	fmul	QWORD PTR [ecx-24]
	faddp	ST(1), ST(0)
	jne	SHORT $LN27@sp_CHinvC
	mov	edi, DWORD PTR _S$[ebp]
	mov	edx, DWORD PTR $T91338[ebp]
	mov	eax, DWORD PTR _j$[ebp]
$LC26@sp_CHinvC:

; 1882 :     { REAL sum;
; 1883 :       for ( k = S->CIA[j] , sum = 0.0 ; k < S->CIA[j+1] ; k++ )

	cmp	esi, edx
	jge	SHORT $LN25@sp_CHinvC
	mov	ecx, DWORD PTR [edi+180]
	mov	eax, DWORD PTR [edi+176]
	lea	ecx, DWORD PTR [ecx+esi*8]
	lea	eax, DWORD PTR [eax+esi*4]
	sub	edx, esi
$LC4@sp_CHinvC:

; 1884 :         sum += S->CA[k]*Y[S->CJA[k]];

	mov	esi, DWORD PTR [eax]
	fld	QWORD PTR [ebx+esi*8]
	add	eax, 4
	fmul	QWORD PTR [ecx]
	add	ecx, 8
	dec	edx
	faddp	ST(1), ST(0)
	jne	SHORT $LC4@sp_CHinvC

; 1882 :     { REAL sum;
; 1883 :       for ( k = S->CIA[j] , sum = 0.0 ; k < S->CIA[j+1] ; k++ )

	mov	eax, DWORD PTR _j$[ebp]
$LN25@sp_CHinvC:

; 1885 :       S->CHinvCinv[i][j] = sum;

	mov	edx, DWORD PTR [edi+168]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	fst	QWORD PTR [edx+eax*8]

; 1886 :       if ( ! blas_flag )

	cmp	DWORD PTR _blas_flag, 0
	jne	SHORT $LN46@sp_CHinvC

; 1887 :         S->CHinvCinv[j][i] = sum; /* symmetric */

	mov	edx, DWORD PTR [edi+168]
	mov	edx, DWORD PTR [edx+eax*4]
	fstp	QWORD PTR [edx+ecx*8]
	jmp	SHORT $LN6@sp_CHinvC
$LN46@sp_CHinvC:
	fstp	ST(0)
$LN6@sp_CHinvC:

; 1879 : 
; 1880 :     /* multiply by rows of C */
; 1881 :     for ( j = 0 ; j <= i ; j++ )

	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, ecx
	jle	$LN7@sp_CHinvC
	mov	esi, DWORD PTR _i$[ebp]
	fstp	ST(0)
$LN12@sp_CHinvC:

; 1871 : 
; 1872 :   for ( i = 0 ; i < S->CN ; i++ )

	inc	esi
	mov	DWORD PTR _i$[ebp], esi
	cmp	esi, DWORD PTR [edi+148]
	jl	$LL29@sp_CHinvC
$LN11@sp_CHinvC:

; 1888 :     }
; 1889 :   }
; 1890 : 
; 1891 :   temp_free((char*)BB);

	mov	eax, DWORD PTR _BB$[ebp]
	push	eax
	call	_temp_free

; 1892 :   temp_free((char*)Y);

	push	ebx
	call	_temp_free
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1893 : 
; 1894 : } // end sp_CHinvC()

	mov	esp, ebp
	pop	ebp
	ret	0
_sp_CHinvC ENDP
_TEXT	ENDS
END
