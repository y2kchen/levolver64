; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\PAINTER.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_debug_k
PUBLIC	_maxquaddepth
PUBLIC	_veps
PUBLIC	_vis_va
PUBLIC	_vis_vb
PUBLIC	_debug_seq
PUBLIC	_vis_eps
_DATA	SEGMENT
COMM	_swaps:QWORD
COMM	_loopbailouts:QWORD
COMM	_check_list_count:DWORD
COMM	_vis_conedge_max:DWORD
COMM	_vis_heap_count:DWORD
COMM	_sentinelv:BYTE:080H
COMM	_sep_line_calls:QWORD
COMM	_vis_crossing_count:DWORD
COMM	_tlist:DWORD
COMM	_vertex_event_spot:DWORD
COMM	_trilist:DWORD
COMM	_vis_conedges:DWORD
COMM	_vecount:DWORD
COMM	_vis_list:DWORD
COMM	_crossings:QWORD
COMM	_visdebuglevel:DWORD
COMM	_edgeedge:QWORD
COMM	_vis_count:DWORD
COMM	_facetedge:QWORD
COMM	_wrong_middles:DWORD
COMM	_check_list_max:DWORD
COMM	_vis_heap_max:DWORD
COMM	_sep_plane_calls:QWORD
COMM	_vis_vertices:DWORD
COMM	_active_edge_first:DWORD
COMM	_vis_heap:DWORD
COMM	_vis_max:DWORD
COMM	_sweep_u:QWORD
COMM	_in_back_calls:QWORD
COMM	_box_overlaps:QWORD
COMM	_vis_conedge_count:DWORD
COMM	_qtree:DWORD
COMM	_vis_vertex_count:DWORD
COMM	_done:QWORD
COMM	_vis_rawedges:DWORD
COMM	_tableau:QWORD:015H
COMM	_facetfacet:QWORD
COMM	_backstamp:DWORD
COMM	_vis_vertex_max:DWORD
COMM	_check_list:DWORD
COMM	_rawplist:DWORD
COMM	_sentinel:BYTE:048H
_DATA	ENDS
_BSS	SEGMENT
_debug_seq DD	01H DUP (?)
?this_seq@?1??handle_vertex_event@@9@9 DD 01H DUP (?)	; `handle_vertex_event'::`2'::this_seq
_BSS	ENDS
_DATA	SEGMENT
_gdim	DD	03H
_debug_k DD	07fffffffH
_sweep_low DQ	0c024000000000000r		; -10
_sweep_high DQ	04024000000000000r		; 10
_maxquaddepth DD 08H
	ORG $+4
_veps	DQ	03d06849b86a12b9br		; 1e-014
_vis_va	DQ	03fefff972474538fr		; 0.99995
_vis_vb	DQ	03f847ae147ae147br		; 0.01
_vis_eps DQ	03d3c25c268497682r		; 1e-013
_DATA	ENDS
PUBLIC	_get_fe_edge
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\painter.c
;	COMDAT _ttcompare
_TEXT	SEGMENT
_t1$ = 8						; size = 4
_t2$ = 12						; size = 4
_ttcompare PROC						; COMDAT

; 89   : {

	push	ebp
	mov	ebp, esp

; 90   :   /* First, compare back z */
; 91   :   if ( t1[0]->mins[2] > t2[0]->mins[2] ) return 1;

	mov	eax, DWORD PTR _t1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _t2$[ebp]
	fld	DWORD PTR [ecx+88]
	mov	edx, DWORD PTR [edx]
	fld	DWORD PTR [edx+88]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@ttcompare
$LN10@ttcompare:
	mov	eax, 1

; 100  :   return 0;
; 101  : 
; 102  : } // end ttcompare()

	pop	ebp
	ret	0
$LN6@ttcompare:

; 92   :   if ( t1[0]->mins[2] < t2[0]->mins[2] ) return -1;

	fld	DWORD PTR [ecx+88]
	fld	DWORD PTR [edx+88]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN5@ttcompare
$LN11@ttcompare:
	or	eax, -1

; 100  :   return 0;
; 101  : 
; 102  : } // end ttcompare()

	pop	ebp
	ret	0
$LN5@ttcompare:

; 93   :   /* Break ties with front z */
; 94   :   if ( t1[0]->maxs[2] > t2[0]->maxs[2] ) return 1;

	fld	DWORD PTR [ecx+100]
	fld	DWORD PTR [edx+100]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN10@ttcompare

; 95   :   if ( t1[0]->maxs[2] < t2[0]->maxs[2] ) return -1;

	fld	DWORD PTR [ecx+100]
	fld	DWORD PTR [edx+100]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN11@ttcompare

; 96   :   /* Finally, break ties with id to get consistent ordering,
; 97   :      independent of how many elements are being sorted */
; 98   :   if ( t1[0]->f_id > t2[0]->f_id ) return 1;

	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx]
	cmp	ecx, edx
	ja	SHORT $LN10@ttcompare

; 99   :   if ( t1[0]->f_id < t2[0]->f_id ) return -1;

	sbb	eax, eax

; 100  :   return 0;
; 101  : 
; 102  : } // end ttcompare()

	pop	ebp
	ret	0
_ttcompare ENDP
_TEXT	ENDS
PUBLIC	__real@4012d97c7f3321d2
PUBLIC	__real@bff921fb54442d18
PUBLIC	__real@401f6a7a2955385e
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@4022d97c7f3321d2
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@401921fb54442d18
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@40af400000000000
PUBLIC	__$ArrayPad$
PUBLIC	_find_bbox
EXTRN	_dot:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CIatan2:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@4012d97c7f3321d2
CONST	SEGMENT
__real@4012d97c7f3321d2 DQ 04012d97c7f3321d2r	; 4.71239
CONST	ENDS
;	COMDAT __real@bff921fb54442d18
CONST	SEGMENT
__real@bff921fb54442d18 DQ 0bff921fb54442d18r	; -1.5708
CONST	ENDS
;	COMDAT __real@401f6a7a2955385e
CONST	SEGMENT
__real@401f6a7a2955385e DQ 0401f6a7a2955385er	; 7.85398
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@4022d97c7f3321d2
CONST	SEGMENT
__real@4022d97c7f3321d2 DQ 04022d97c7f3321d2r	; 9.42478
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@401921fb54442d18
CONST	SEGMENT
__real@401921fb54442d18 DQ 0401921fb54442d18r	; 6.28319
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@40af400000000000
CONST	SEGMENT
__real@40af400000000000 DQ 040af400000000000r	; 4000
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _find_bbox
_TEXT	SEGMENT
_center$89113 = -140					; size = 16
_dx$ = -124						; size = 8
_angle1$89116 = -124					; size = 8
_det$89115 = -116					; size = 8
tv3173 = -112						; size = 4
tv3159 = -112						; size = 4
_dy$ = -108						; size = 8
_radius$89114 = -108					; size = 8
_mag1$89110 = -108					; size = 8
_w2$89109 = -100					; size = 48
_w1$89108 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_t$ = 8							; size = 4
_find_bbox PROC						; COMDAT

; 130  : { int n;

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _t$[ebp]

; 131  :   REAL dx,dy,len;
; 132  : 
; 133  :   if ( (t->flag & 0xF) == EDGE )

	mov	eax, DWORD PTR [ebx+28]
	mov	ecx, eax
	and	cl, 15					; 0000000fH
	push	esi
	push	edi
	cmp	cl, 1
	jne	$LN45@find_bbox

; 134  :   {
; 135  :     if ( t->flag & EDGE_ARC )

	test	eax, 32768				; 00008000H
	je	$LN44@find_bbox

; 136  :     { REAL w1[MAXCOORD],w2[MAXCOORD],mag1,mag2,w1w2,center[2],radius;
; 137  :       REAL det,angle1,angle2;
; 138  :       int i;
; 139  :       for (i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	xor	ecx, ecx
	cmp	edx, 4
	jl	SHORT $LC57@find_bbox
	lea	esi, DWORD PTR [edx-3]
	lea	eax, DWORD PTR [ebx+32]
$LL58@find_bbox:

; 140  :       { w1[i] = t->x[1][i] - t->x[0][i];

	fld	DWORD PTR [eax+12]

; 141  :         w2[i] = t->x[2][i] - t->x[0][i];

	add	ecx, 4
	fsub	DWORD PTR [eax]
	add	eax, 16					; 00000010H
	fstp	QWORD PTR _w1$89108[ebp+ecx*8-32]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [eax-16]
	fstp	QWORD PTR _w2$89109[ebp+ecx*8-32]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [eax-12]
	fstp	QWORD PTR _w1$89108[ebp+ecx*8-24]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR [eax-12]
	fstp	QWORD PTR _w2$89109[ebp+ecx*8-24]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [eax-8]
	fstp	QWORD PTR _w1$89108[ebp+ecx*8-16]
	fld	DWORD PTR [eax+16]
	fsub	DWORD PTR [eax-8]
	fstp	QWORD PTR _w2$89109[ebp+ecx*8-16]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [eax-4]
	fstp	QWORD PTR _w1$89108[ebp+ecx*8-8]
	fld	DWORD PTR [eax+20]
	fsub	DWORD PTR [eax-4]
	fstp	QWORD PTR _w2$89109[ebp+ecx*8-8]
	cmp	ecx, esi
	jl	SHORT $LL58@find_bbox
$LC57@find_bbox:

; 136  :     { REAL w1[MAXCOORD],w2[MAXCOORD],mag1,mag2,w1w2,center[2],radius;
; 137  :       REAL det,angle1,angle2;
; 138  :       int i;
; 139  :       for (i = 0 ; i < SDIM ; i++ )

	cmp	ecx, edx
	jge	SHORT $LN56@find_bbox
	lea	eax, DWORD PTR [ebx+ecx*4+32]
	npad	5
$LC43@find_bbox:

; 140  :       { w1[i] = t->x[1][i] - t->x[0][i];

	fld	DWORD PTR [eax+12]
	inc	ecx
	fsub	DWORD PTR [eax]
	add	eax, 4
	fstp	QWORD PTR _w1$89108[ebp+ecx*8-8]

; 141  :         w2[i] = t->x[2][i] - t->x[0][i];

	fld	DWORD PTR [eax+20]
	fsub	DWORD PTR [eax-4]
	fstp	QWORD PTR _w2$89109[ebp+ecx*8-8]
	cmp	ecx, edx
	jl	SHORT $LC43@find_bbox
$LN56@find_bbox:

; 142  :       }
; 143  :       det = w1[0]*w2[1] - w1[1]*w2[0];

	fld	QWORD PTR _w2$89109[ebp+8]

; 144  :       mag1 = SDIM_dot(w1,w1); mag2 = SDIM_dot(w2,w2);

	push	edx
	fmul	QWORD PTR _w1$89108[ebp]
	lea	edx, DWORD PTR _w1$89108[ebp]
	fld	QWORD PTR _w2$89109[ebp]
	push	edx
	fmul	QWORD PTR _w1$89108[ebp+8]
	mov	eax, edx
	push	eax
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _det$89115[ebp]
	call	_dot
	mov	ecx, DWORD PTR _web+616
	fstp	QWORD PTR _mag1$89110[ebp]
	push	ecx
	lea	edx, DWORD PTR _w2$89109[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot

; 145  :       w1w2 = w1[0]*w2[0] + w1[1]*w2[1];

	fld	QWORD PTR _w1$89108[ebp+8]

; 146  :       for ( n = 0 ; n < gdim ; n++ )

	mov	esi, DWORD PTR _gdim
	fld	ST(0)
	fld	QWORD PTR _w2$89109[ebp+8]
	add	esp, 24					; 00000018H
	fmul	ST(1), ST(0)
	xor	edi, edi
	fld	QWORD PTR _w2$89109[ebp]
	fld	QWORD PTR _w1$89108[ebp]
	fmul	ST(0), ST(1)
	faddp	ST(3), ST(0)
	cmp	esi, 4
	jl	$LC60@find_bbox

; 142  :       }
; 143  :       det = w1[0]*w2[1] - w1[1]*w2[0];

	lea	edx, DWORD PTR [esi-4]
	shr	edx, 2
	inc	edx
	lea	ecx, DWORD PTR [ebx+56]
	lea	edi, DWORD PTR [edx*4]

; 146  :       for ( n = 0 ; n < gdim ; n++ )

$LN69@find_bbox:

; 147  :       { /* endpoints first */
; 148  :         if ( t->x[0][n] < t->x[2][n] )

	fld	DWORD PTR [ecx-24]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN61@find_bbox

; 149  :          { t->maxs[n] = t->x[2][n];

	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+36]

; 150  :            t->mins[n] = t->x[0][n];

	fld	DWORD PTR [ecx-24]

; 151  :          }
; 152  :          else

	jmp	SHORT $LN160@find_bbox
$LN61@find_bbox:

; 153  :          { t->maxs[n] = t->x[0][n];

	fld	DWORD PTR [ecx-24]
	fstp	DWORD PTR [ecx+36]

; 154  :            t->mins[n] = t->x[2][n];

	fld	DWORD PTR [ecx]
$LN160@find_bbox:
	fstp	DWORD PTR [ecx+24]
	fld	DWORD PTR [ecx-20]
	fld	DWORD PTR [ecx+4]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN63@find_bbox

; 149  :          { t->maxs[n] = t->x[2][n];

	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ecx+40]

; 150  :            t->mins[n] = t->x[0][n];

	fld	DWORD PTR [ecx-20]

; 151  :          }
; 152  :          else

	jmp	SHORT $LN161@find_bbox
$LN63@find_bbox:

; 153  :          { t->maxs[n] = t->x[0][n];

	fld	DWORD PTR [ecx-20]
	fstp	DWORD PTR [ecx+40]

; 154  :            t->mins[n] = t->x[2][n];

	fld	DWORD PTR [ecx+4]
$LN161@find_bbox:
	fstp	DWORD PTR [ecx+28]
	fld	DWORD PTR [ecx-16]
	fld	DWORD PTR [ecx+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN65@find_bbox

; 149  :          { t->maxs[n] = t->x[2][n];

	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR [ecx+44]

; 150  :            t->mins[n] = t->x[0][n];

	fld	DWORD PTR [ecx-16]

; 151  :          }
; 152  :          else

	jmp	SHORT $LN162@find_bbox
$LN65@find_bbox:

; 153  :          { t->maxs[n] = t->x[0][n];

	fld	DWORD PTR [ecx-16]
	fstp	DWORD PTR [ecx+44]

; 154  :            t->mins[n] = t->x[2][n];

	fld	DWORD PTR [ecx+8]
$LN162@find_bbox:
	fstp	DWORD PTR [ecx+32]
	fld	DWORD PTR [ecx-12]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN67@find_bbox

; 149  :          { t->maxs[n] = t->x[2][n];

	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [ecx+48]

; 150  :            t->mins[n] = t->x[0][n];

	fld	DWORD PTR [ecx-12]

; 151  :          }
; 152  :          else

	jmp	SHORT $LN163@find_bbox
$LN67@find_bbox:

; 153  :          { t->maxs[n] = t->x[0][n];

	fld	DWORD PTR [ecx-12]
	fstp	DWORD PTR [ecx+48]

; 154  :            t->mins[n] = t->x[2][n];

	fld	DWORD PTR [ecx+12]
$LN163@find_bbox:
	fstp	DWORD PTR [ecx+36]
	add	ecx, 16					; 00000010H
	dec	edx
	jne	$LN69@find_bbox
$LC60@find_bbox:

; 146  :       for ( n = 0 ; n < gdim ; n++ )

	cmp	edi, esi
	jge	SHORT $LN59@find_bbox
	lea	ecx, DWORD PTR [ebx+edi*4+32]
	sub	esi, edi
$LC40@find_bbox:

; 147  :       { /* endpoints first */
; 148  :         if ( t->x[0][n] < t->x[2][n] )

	fld	DWORD PTR [ecx]
	fld	DWORD PTR [ecx+24]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN37@find_bbox

; 149  :          { t->maxs[n] = t->x[2][n];

	fld	DWORD PTR [ecx+24]
	fstp	DWORD PTR [ecx+60]

; 150  :            t->mins[n] = t->x[0][n];

	fld	DWORD PTR [ecx]

; 151  :          }
; 152  :          else

	jmp	SHORT $LN164@find_bbox
$LN37@find_bbox:

; 153  :          { t->maxs[n] = t->x[0][n];

	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+60]

; 154  :            t->mins[n] = t->x[2][n];

	fld	DWORD PTR [ecx+24]
$LN164@find_bbox:
	fstp	DWORD PTR [ecx+48]
	add	ecx, 4
	dec	esi
	jne	SHORT $LC40@find_bbox
$LN59@find_bbox:

; 155  :          }
; 156  :        }
; 157  :       if ( 4000*det*det > mag1*mag1*mag2 + mag1*mag2*mag2 - 2*mag1*w1w2*mag2 )

	fld	ST(4)
	fld	QWORD PTR _mag1$89110[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(6)
	fld	ST(1)
	fmul	ST(0), ST(2)
	fmul	ST(0), ST(7)
	faddp	ST(1), ST(0)
	fld	ST(1)
	fadd	ST(0), ST(0)
	fmulp	ST(5), ST(0)
	fxch	ST(4)
	fmul	ST(0), ST(6)
	fsubp	ST(4), ST(0)
	fld	QWORD PTR _det$89115[ebp]
	fld	QWORD PTR __real@40af400000000000
	fmul	ST(0), ST(1)
	fmul	ST(0), ST(1)
	fcomp	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN113@find_bbox

; 158  :       { /* circle rather that straight line */
; 159  :         center[0] = t->x[0][0] + 0.5*(w2[1]*mag1 - w1[1]*mag2)/det;

	fld	ST(1)
	fmulp	ST(4), ST(0)
	fld	ST(6)
	fmulp	ST(6), ST(0)
	fxch	ST(3)
	fsubrp	ST(5), ST(0)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(5), ST(0)
	fxch	ST(5)
	fdiv	ST(0), ST(3)
	fadd	DWORD PTR [ebx+32]
	fstp	QWORD PTR _center$89113[ebp]

; 160  :         center[1] = t->x[0][1] + 0.5*(-w2[0]*mag1 + w1[0]*mag2)/det;

	fxch	ST(5)
	fmul	QWORD PTR _w1$89108[ebp]
	fxch	ST(5)
	fmulp	ST(1), ST(0)
	fsubp	ST(4), ST(0)
	fxch	ST(3)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fdiv	ST(0), ST(2)
	fadd	DWORD PTR [ebx+36]
	fstp	QWORD PTR _center$89113[ebp+8]

; 161  :         radius =  sqrt((mag1*mag1*mag2+mag1*mag2*mag2-2*mag1*w1w2*mag2)
; 162  :                          /4/det/det);

	fmul	QWORD PTR __real@3fd0000000000000
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR _radius$89114[ebp]

; 163  :         angle1 = atan2(t->x[0][1]-center[1],t->x[0][0]-center[0]);

	fld	DWORD PTR [ebx+36]
	fsub	QWORD PTR _center$89113[ebp+8]
	fld	DWORD PTR [ebx+32]
	fsub	QWORD PTR _center$89113[ebp]
	call	__CIatan2
	fstp	QWORD PTR _angle1$89116[ebp]

; 164  :         angle2 = atan2(t->x[2][1]-center[1],t->x[2][0]-center[0]);

	fld	DWORD PTR [ebx+60]
	fsub	QWORD PTR _center$89113[ebp+8]
	fld	DWORD PTR [ebx+56]
	fsub	QWORD PTR _center$89113[ebp]
	call	__CIatan2

; 165  :         if ( det < 0 )

	fldz
	fcom	QWORD PTR _det$89115[ebp]
	fnstsw	ax

; 166  :         { REAL temp = angle1; angle1 = angle2; angle2 = temp; }

	fld	QWORD PTR _angle1$89116[ebp]
	test	ah, 65					; 00000041H
	je	SHORT $LN34@find_bbox
	fxch	ST(2)
$LN34@find_bbox:

; 167  :         if ( angle2 < angle1 ) angle2 += 2*M_PI;

	fcom	ST(2)
	fnstsw	ax
	fld	QWORD PTR __real@401921fb54442d18
	test	ah, 5
	jp	SHORT $LN33@find_bbox
	fadd	ST(1), ST(0)
$LN33@find_bbox:

; 168  :         if ( (angle1 < 0.0 && angle2 > 0.0 ) || 
; 169  :              (angle1 < 2*M_PI && angle2 > 2*M_PI) )

	fxch	ST(3)
	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN123@find_bbox
	fxch	ST(2)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN30@find_bbox
	fstp	ST(2)

; 170  :           t->maxs[0] = (float)(center[0] + radius);

	fld	QWORD PTR _radius$89114[ebp]
	fld	QWORD PTR _center$89113[ebp]
	fadd	ST(0), ST(1)
	fstp	DWORD PTR [ebx+92]
	jmp	SHORT $LN32@find_bbox
$LN123@find_bbox:

; 168  :         if ( (angle1 < 0.0 && angle2 > 0.0 ) || 
; 169  :              (angle1 < 2*M_PI && angle2 > 2*M_PI) )

	fstp	ST(2)
$LN30@find_bbox:
	fxch	ST(1)
	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN152@find_bbox
	fxch	ST(2)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN82@find_bbox
	fxch	ST(1)

; 170  :           t->maxs[0] = (float)(center[0] + radius);

	fld	QWORD PTR _radius$89114[ebp]
	fld	QWORD PTR _center$89113[ebp]
	fadd	ST(0), ST(1)
	fstp	DWORD PTR [ebx+92]
	jmp	SHORT $LN32@find_bbox
$LN152@find_bbox:

; 168  :         if ( (angle1 < 0.0 && angle2 > 0.0 ) || 
; 169  :              (angle1 < 2*M_PI && angle2 > 2*M_PI) )

	fstp	ST(2)
$LN82@find_bbox:

; 170  :           t->maxs[0] = (float)(center[0] + radius);

	fld	QWORD PTR _radius$89114[ebp]
	fxch	ST(1)
	fxch	ST(2)
	fxch	ST(1)
$LN32@find_bbox:

; 171  :         if ( (angle1 < M_PI && angle2 > M_PI ) || 
; 172  :              (angle1 < 3*M_PI && angle2 > 3*M_PI) )

	fld	QWORD PTR __real@400921fb54442d18
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN128@find_bbox
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN28@find_bbox
	jmp	SHORT $LN27@find_bbox
$LN128@find_bbox:
	fstp	ST(0)
$LN27@find_bbox:
	fld	QWORD PTR __real@4022d97c7f3321d2
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN149@find_bbox
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN29@find_bbox
$LN28@find_bbox:

; 173  :           t->mins[0] = (float)(center[0] - radius);

	fld	QWORD PTR _center$89113[ebp]
	fsub	ST(0), ST(1)
	fstp	DWORD PTR [ebx+80]
	jmp	SHORT $LN29@find_bbox
$LN149@find_bbox:

; 171  :         if ( (angle1 < M_PI && angle2 > M_PI ) || 
; 172  :              (angle1 < 3*M_PI && angle2 > 3*M_PI) )

	fstp	ST(0)
$LN29@find_bbox:

; 174  :         if ( (angle1 < M_PI/2 && angle2 > M_PI/2 ) || 
; 175  :              (angle1 < 5*M_PI/2 && angle2 > 5*M_PI/2) )

	fld	QWORD PTR __real@3ff921fb54442d18
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN133@find_bbox
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN25@find_bbox
	jmp	SHORT $LN24@find_bbox
$LN133@find_bbox:
	fstp	ST(0)
$LN24@find_bbox:
	fld	QWORD PTR __real@401f6a7a2955385e
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN146@find_bbox
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN83@find_bbox
$LN25@find_bbox:

; 176  :           t->maxs[1] = (float)(center[1] + radius);

	fld	QWORD PTR _center$89113[ebp+8]
	fadd	ST(0), ST(1)
	fstp	DWORD PTR [ebx+96]
	jmp	SHORT $LN83@find_bbox
$LN146@find_bbox:

; 174  :         if ( (angle1 < M_PI/2 && angle2 > M_PI/2 ) || 
; 175  :              (angle1 < 5*M_PI/2 && angle2 > 5*M_PI/2) )

	fstp	ST(0)
$LN83@find_bbox:

; 177  :         if ( (angle1 < -M_PI/2 && angle2 > -M_PI/2 ) || 
; 178  :              (angle1 < 3*M_PI/2 && angle2 > 3*M_PI/2) )

	fld	QWORD PTR __real@bff921fb54442d18
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN138@find_bbox
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN21@find_bbox
	fstp	ST(2)
	fstp	ST(0)
$LN22@find_bbox:

; 179  :           t->mins[1] = (float)(center[1] - radius);

	fsubr	QWORD PTR _center$89113[ebp+8]
	pop	edi
	pop	esi
	fstp	DWORD PTR [ebx+84]
	pop	ebx

; 235  :       }
; 236  :     }
; 237  :   }
; 238  : } // end find_bbox()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN138@find_bbox:

; 177  :         if ( (angle1 < -M_PI/2 && angle2 > -M_PI/2 ) || 
; 178  :              (angle1 < 3*M_PI/2 && angle2 > 3*M_PI/2) )

	fstp	ST(0)
$LN21@find_bbox:
	fld	QWORD PTR __real@4012d97c7f3321d2
	fcom	ST(2)
	fnstsw	ax
	fstp	ST(2)
	test	ah, 65					; 00000041H
	jne	$LN142@find_bbox
	fxch	ST(2)
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN158@find_bbox
	jmp	SHORT $LN22@find_bbox
$LN44@find_bbox:

; 180  :         return;
; 181  :       } 
; 182  :     } /* end EDGE_ARC */
; 183  :     else /* just a straight segment */
; 184  :     for ( n = 0 ; n < gdim ; n++ )

	mov	esi, DWORD PTR _gdim
	xor	edi, edi
	cmp	esi, 4
	jl	$LC71@find_bbox
	lea	edx, DWORD PTR [esi-4]
	shr	edx, 2
	inc	edx
	lea	ecx, DWORD PTR [ebx+32]
	lea	edi, DWORD PTR [edx*4]
$LL80@find_bbox:

; 185  :     { if ( t->x[0][n] < t->x[1][n] )

	fld	DWORD PTR [ecx]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN72@find_bbox

; 186  :       { t->maxs[n] = t->x[1][n];

	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [ecx+60]

; 187  :         t->mins[n] = t->x[0][n];

	fld	DWORD PTR [ecx]

; 188  :       }
; 189  :       else

	jmp	SHORT $LN165@find_bbox
$LN72@find_bbox:

; 190  :       { t->maxs[n] = t->x[0][n];

	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+60]

; 191  :         t->mins[n] = t->x[1][n];

	fld	DWORD PTR [ecx+12]
$LN165@find_bbox:
	fstp	DWORD PTR [ecx+48]
	fld	DWORD PTR [ecx+4]
	fld	DWORD PTR [ecx+16]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN74@find_bbox

; 186  :       { t->maxs[n] = t->x[1][n];

	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR [ecx+64]

; 187  :         t->mins[n] = t->x[0][n];

	fld	DWORD PTR [ecx+4]

; 188  :       }
; 189  :       else

	jmp	SHORT $LN166@find_bbox
$LN74@find_bbox:

; 190  :       { t->maxs[n] = t->x[0][n];

	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ecx+64]

; 191  :         t->mins[n] = t->x[1][n];

	fld	DWORD PTR [ecx+16]
$LN166@find_bbox:
	fstp	DWORD PTR [ecx+52]
	fld	DWORD PTR [ecx+8]
	fld	DWORD PTR [ecx+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN76@find_bbox

; 186  :       { t->maxs[n] = t->x[1][n];

	fld	DWORD PTR [ecx+20]
	fstp	DWORD PTR [ecx+68]

; 187  :         t->mins[n] = t->x[0][n];

	fld	DWORD PTR [ecx+8]

; 188  :       }
; 189  :       else

	jmp	SHORT $LN167@find_bbox
$LN76@find_bbox:

; 190  :       { t->maxs[n] = t->x[0][n];

	fld	DWORD PTR [ecx+8]
	fstp	DWORD PTR [ecx+68]

; 191  :         t->mins[n] = t->x[1][n];

	fld	DWORD PTR [ecx+20]
$LN167@find_bbox:
	fstp	DWORD PTR [ecx+56]
	fld	DWORD PTR [ecx+12]
	fld	DWORD PTR [ecx+24]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN78@find_bbox

; 186  :       { t->maxs[n] = t->x[1][n];

	fld	DWORD PTR [ecx+24]
	fstp	DWORD PTR [ecx+72]

; 187  :         t->mins[n] = t->x[0][n];

	fld	DWORD PTR [ecx+12]

; 188  :       }
; 189  :       else

	jmp	SHORT $LN168@find_bbox
$LN78@find_bbox:

; 190  :       { t->maxs[n] = t->x[0][n];

	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [ecx+72]

; 191  :         t->mins[n] = t->x[1][n];

	fld	DWORD PTR [ecx+24]
$LN168@find_bbox:
	fstp	DWORD PTR [ecx+60]
	add	ecx, 16					; 00000010H
	dec	edx
	jne	$LL80@find_bbox
$LC71@find_bbox:

; 180  :         return;
; 181  :       } 
; 182  :     } /* end EDGE_ARC */
; 183  :     else /* just a straight segment */
; 184  :     for ( n = 0 ; n < gdim ; n++ )

	cmp	edi, esi
	jge	SHORT $LN70@find_bbox
	lea	ecx, DWORD PTR [ebx+edi*4+32]
	sub	esi, edi
$LC19@find_bbox:

; 185  :     { if ( t->x[0][n] < t->x[1][n] )

	fld	DWORD PTR [ecx]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN16@find_bbox

; 186  :       { t->maxs[n] = t->x[1][n];

	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [ecx+60]

; 187  :         t->mins[n] = t->x[0][n];

	fld	DWORD PTR [ecx]

; 188  :       }
; 189  :       else

	jmp	SHORT $LN169@find_bbox
$LN16@find_bbox:

; 190  :       { t->maxs[n] = t->x[0][n];

	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+60]

; 191  :         t->mins[n] = t->x[1][n];

	fld	DWORD PTR [ecx+12]
$LN169@find_bbox:
	fstp	DWORD PTR [ecx+48]
	add	ecx, 4
	dec	esi
	jne	SHORT $LC19@find_bbox

; 180  :         return;
; 181  :       } 
; 182  :     } /* end EDGE_ARC */
; 183  :     else /* just a straight segment */
; 184  :     for ( n = 0 ; n < gdim ; n++ )

	jmp	SHORT $LN70@find_bbox
$LN113@find_bbox:
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(4)
	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)
$LN70@find_bbox:

; 192  :       }
; 193  :     }
; 194  :     /* adjust extents for thickness */
; 195  :     dx = fabs(t->x[1][0] - t->x[0][0]);

	fld	DWORD PTR [ebx+44]
	fsub	DWORD PTR [ebx+32]
	fabs
	fst	QWORD PTR _dx$[ebp]

; 196  :     dy = fabs(t->x[1][1] - t->x[0][1]);

	fld	DWORD PTR [ebx+48]
	fsub	DWORD PTR [ebx+36]
	fabs
	fst	QWORD PTR _dy$[ebp]

; 197  :     len = sqrt(dx*dx+dy*dy);

	fmul	ST(0), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt

; 198  :     if ( len > 0.0 )

	fldz
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	$LN158@find_bbox

; 199  :     { t->maxs[0] += (float)(dy/len*t->width/2);

	fld	QWORD PTR _dy$[ebp]
	pop	edi
	fdiv	ST(0), ST(1)
	pop	esi
	fmul	DWORD PTR [ebx+104]
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR tv3159[ebp]
	fld	DWORD PTR [ebx+92]
	fld	DWORD PTR tv3159[ebp]
	fld	ST(0)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR [ebx+92]

; 200  :       t->mins[0] -= (float)(dy/len*t->width/2);

	fsubr	DWORD PTR [ebx+80]
	fstp	DWORD PTR [ebx+80]

; 201  :       t->maxs[1] += (float)(dx/len*t->width/2);

	fld	QWORD PTR _dx$[ebp]
	fdivrp	ST(2), ST(0)
	fld	DWORD PTR [ebx+104]
	fmulp	ST(2), ST(0)
	fmulp	ST(1), ST(0)
	fstp	DWORD PTR tv3173[ebp]
	fld	DWORD PTR tv3173[ebp]
	fld	ST(0)
	fadd	DWORD PTR [ebx+96]
	fstp	DWORD PTR [ebx+96]

; 202  :       t->mins[1] -= (float)(dx/len*t->width/2);

	fsubr	DWORD PTR [ebx+84]
	fstp	DWORD PTR [ebx+84]
	pop	ebx

; 235  :       }
; 236  :     }
; 237  :   }
; 238  : } // end find_bbox()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@find_bbox:

; 203  :     }
; 204  :     return;
; 205  :   } /* end EDGE */
; 206  : 
; 207  :   /* facet */
; 208  :   for ( n = 0 ; n < gdim ; n++ )

	mov	eax, DWORD PTR _gdim
	test	eax, eax
	jle	$LN11@find_bbox
	lea	ecx, DWORD PTR [ebx+56]
	mov	edx, eax
	npad	7
$LL13@find_bbox:

; 209  :   { if ( t->x[0][n] < t->x[1][n] )

	fld	DWORD PTR [ecx-24]
	fld	DWORD PTR [ecx-12]
	fcompp
	fnstsw	ax

; 210  :     { if  ( t->x[2][n] < t->x[0][n] )

	fld	DWORD PTR [ecx]
	test	ah, 65					; 00000041H
	jne	SHORT $LN10@find_bbox
	fld	DWORD PTR [ecx-24]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN9@find_bbox

; 211  :       { t->maxs[n] = t->x[1][n];

	fld	DWORD PTR [ecx-12]
	fstp	DWORD PTR [ecx+36]

; 212  :         t->mins[n] = t->x[2][n];

	fld	DWORD PTR [ecx]
	jmp	SHORT $LN170@find_bbox
$LN9@find_bbox:

; 213  :       }
; 214  :       else if ( t->x[1][n] < t->x[2][n] )

	fld	DWORD PTR [ecx-12]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN7@find_bbox

; 215  :       { t->maxs[n] = t->x[2][n];

	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+36]

; 216  :         t->mins[n] = t->x[0][n];

	fld	DWORD PTR [ecx-24]

; 217  :       }
; 218  :       else

	jmp	SHORT $LN170@find_bbox
$LN7@find_bbox:

; 219  :       { t->maxs[n] = t->x[1][n];

	fld	DWORD PTR [ecx-12]
	fstp	DWORD PTR [ecx+36]

; 220  :         t->mins[n] = t->x[0][n];

	fld	DWORD PTR [ecx-24]

; 221  :       }
; 222  :     }
; 223  :     else

	jmp	SHORT $LN170@find_bbox
$LN10@find_bbox:

; 224  :     { if  ( t->x[2][n] < t->x[1][n] )

	fld	DWORD PTR [ecx-12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@find_bbox

; 225  :       { t->maxs[n] = t->x[0][n];

	fld	DWORD PTR [ecx-24]
	fstp	DWORD PTR [ecx+36]

; 226  :         t->mins[n] = t->x[2][n];

	fld	DWORD PTR [ecx]
	jmp	SHORT $LN170@find_bbox
$LN4@find_bbox:

; 227  :       }
; 228  :       else if ( t->x[0][n] < t->x[2][n] )

	fld	DWORD PTR [ecx-24]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@find_bbox

; 229  :       { t->maxs[n] = t->x[2][n];

	fld	DWORD PTR [ecx]

; 230  :         t->mins[n] = t->x[1][n];
; 231  :       }
; 232  :       else

	jmp	SHORT $LN171@find_bbox
$LN2@find_bbox:

; 233  :       { t->maxs[n] = t->x[0][n];

	fld	DWORD PTR [ecx-24]
$LN171@find_bbox:
	fstp	DWORD PTR [ecx+36]

; 234  :         t->mins[n] = t->x[1][n];

	fld	DWORD PTR [ecx-12]
$LN170@find_bbox:
	fstp	DWORD PTR [ecx+24]
	add	ecx, 4
	dec	edx
	jne	$LL13@find_bbox
	pop	edi
	pop	esi
	pop	ebx

; 235  :       }
; 236  :     }
; 237  :   }
; 238  : } // end find_bbox()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN142@find_bbox:

; 203  :     }
; 204  :     return;
; 205  :   } /* end EDGE */
; 206  : 
; 207  :   /* facet */
; 208  :   for ( n = 0 ; n < gdim ; n++ )

	fstp	ST(2)
	fstp	ST(0)
$LN158@find_bbox:

; 198  :     if ( len > 0.0 )

	fstp	ST(0)
$LN11@find_bbox:

; 235  :       }
; 236  :     }
; 237  :   }
; 238  : } // end find_bbox()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_find_bbox ENDP
_TEXT	ENDS
PUBLIC	_setquadcode
EXTRN	_minclipy:QWORD
EXTRN	_maxclipy:QWORD
EXTRN	_minclipx:QWORD
EXTRN	_maxclipx:QWORD
; Function compile flags: /Ogtp
;	COMDAT _setquadcode
_TEXT	SEGMENT
_t$ = 8							; size = 4
_setquadcode PROC					; COMDAT

; 249  : { unsigned int q = 0;  /* the quadcode */

	push	ebp
	mov	ebp, esp

; 250  :   unsigned int bit = 1;  /* for shifting to quad bit position */
; 251  :   int n;
; 252  :   REAL midx = (minclipx+maxclipx)/2;

	fld	QWORD PTR _maxclipx
	push	esi
	fld	ST(0)

; 253  :   REAL midy = (minclipy+maxclipy)/2;
; 254  :   REAL deltax = (maxclipx-minclipx)/4;
; 255  :   REAL deltay = (maxclipy-minclipy)/4;
; 256  : 
; 257  :   if ( t->maxs[0] < minclipx || t->mins[0] > maxclipx || t->maxs[1] < minclipy
; 258  :        || t->mins[1] > maxclipy ) return OUTOFBOX;

	mov	esi, DWORD PTR _t$[ebp]
	fld	QWORD PTR _minclipx
	xor	edx, edx
	fadd	ST(1), ST(0)
	lea	ecx, DWORD PTR [edx+1]
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(2), ST(0)
	fld	QWORD PTR _maxclipy
	fld	ST(0)
	fld	QWORD PTR _minclipy
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	fld	ST(6)
	fsub	ST(0), ST(5)
	fmul	QWORD PTR __real@3fd0000000000000
	fxch	ST(3)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR __real@3fd0000000000000
	fld	DWORD PTR [esi+92]
	fcomp	ST(5)
	fnstsw	ax
	fstp	ST(4)
	test	ah, 5
	jnp	$LN37@setquadcod
	fld	DWORD PTR [esi+80]
	fcomp	ST(6)
	fnstsw	ax
	fstp	ST(5)
	test	ah, 65					; 00000041H
	je	$LN46@setquadcod
	fld	DWORD PTR [esi+96]
	fcomp	QWORD PTR _minclipy
	fnstsw	ax
	test	ah, 5
	jnp	$LN46@setquadcod
	fld	DWORD PTR [esi+84]
	fcomp	QWORD PTR _maxclipy
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN46@setquadcod

; 259  : 
; 260  :   for ( n = 0  ; n < 8 ; n++, deltax /= 2, deltay /= 2 )

	push	edi
	xor	edi, edi
	jmp	SHORT $LN11@setquadcod
$LN82@setquadcod:
	fxch	ST(2)
$LN11@setquadcod:

; 261  :   {
; 262  :     if ( t->maxs[0] <= midx ) 

	fld	DWORD PTR [esi+92]
	fcomp	ST(4)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN8@setquadcod

; 263  :     { q |= bit; midx -= deltax; }

	or	edx, ecx
	fsub	ST(3), ST(0)
	jmp	SHORT $LN5@setquadcod
$LN8@setquadcod:

; 264  :     else if ( t->mins[0] >= midx )

	fld	DWORD PTR [esi+80]
	fcomp	ST(4)
	fnstsw	ax
	test	ah, 1
	jne	$LN112@setquadcod

; 265  :     { q |= bit<<1; midx += deltax; }

	lea	eax, DWORD PTR [ecx+ecx]
	fld	ST(0)
	or	edx, eax
	faddp	ST(4), ST(0)
$LN5@setquadcod:

; 266  :     else break;
; 267  :     bit <<= 2;
; 268  :     if ( t->maxs[1] <= midy ) 

	fld	DWORD PTR [esi+96]
	add	ecx, ecx
	fcomp	ST(5)
	add	ecx, ecx
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN4@setquadcod

; 269  :     { q |= bit; midy -= deltay; }

	fxch	ST(4)
	or	edx, ecx
	fsub	ST(0), ST(2)
	jmp	SHORT $LN1@setquadcod
$LN4@setquadcod:

; 270  :     else if ( t->mins[1] >= midy )

	fld	DWORD PTR [esi+84]
	fcomp	ST(5)
	fnstsw	ax
	test	ah, 1
	jne	$LN100@setquadcod

; 271  :     { q |= bit<<1; midy += deltay; }

	fld	ST(2)
	lea	eax, DWORD PTR [ecx+ecx]
	faddp	ST(5), ST(0)
	or	edx, eax
	fxch	ST(4)
$LN1@setquadcod:

; 272  :     else break;
; 273  :     bit <<= 2;

	fxch	ST(4)
	add	ecx, ecx
	fmul	ST(0), ST(1)
	add	ecx, ecx
	fxch	ST(2)
	fmul	ST(0), ST(1)
	fld	DWORD PTR [esi+92]
	fcomp	ST(4)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN18@setquadcod

; 263  :     { q |= bit; midx -= deltax; }

	fxch	ST(3)
	or	edx, ecx
	fsub	ST(0), ST(2)
	jmp	SHORT $LN19@setquadcod
$LN18@setquadcod:

; 264  :     else if ( t->mins[0] >= midx )

	fld	DWORD PTR [esi+80]
	fcomp	ST(4)
	fnstsw	ax
	test	ah, 1
	jne	$LN104@setquadcod

; 265  :     { q |= bit<<1; midx += deltax; }

	fld	ST(2)
	lea	eax, DWORD PTR [ecx+ecx]
	faddp	ST(4), ST(0)
	or	edx, eax
	fxch	ST(3)
$LN19@setquadcod:

; 266  :     else break;
; 267  :     bit <<= 2;
; 268  :     if ( t->maxs[1] <= midy ) 

	fld	DWORD PTR [esi+96]
	add	ecx, ecx
	fcomp	ST(5)
	add	ecx, ecx
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN20@setquadcod

; 269  :     { q |= bit; midy -= deltay; }

	fxch	ST(4)
	or	edx, ecx
	fsub	ST(0), ST(3)
	jmp	SHORT $LN21@setquadcod
$LN20@setquadcod:

; 270  :     else if ( t->mins[1] >= midy )

	fld	DWORD PTR [esi+84]
	fcomp	ST(5)
	fnstsw	ax
	test	ah, 1
	jne	$LN100@setquadcod

; 271  :     { q |= bit<<1; midy += deltay; }

	fld	ST(3)
	lea	eax, DWORD PTR [ecx+ecx]
	faddp	ST(5), ST(0)
	or	edx, eax
	fxch	ST(4)
$LN21@setquadcod:

; 272  :     else break;
; 273  :     bit <<= 2;

	fxch	ST(2)
	add	ecx, ecx
	fmul	ST(0), ST(1)
	add	ecx, ecx
	fxch	ST(3)
	fmul	ST(0), ST(1)
	fld	DWORD PTR [esi+92]
	fcomp	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN24@setquadcod

; 263  :     { q |= bit; midx -= deltax; }

	fxch	ST(4)
	or	edx, ecx
	fsub	ST(0), ST(3)
	jmp	SHORT $LN25@setquadcod
$LN24@setquadcod:

; 264  :     else if ( t->mins[0] >= midx )

	fld	DWORD PTR [esi+80]
	fcomp	ST(5)
	fnstsw	ax
	test	ah, 1
	jne	$LN96@setquadcod

; 265  :     { q |= bit<<1; midx += deltax; }

	fld	ST(3)
	lea	eax, DWORD PTR [ecx+ecx]
	faddp	ST(5), ST(0)
	or	edx, eax
	fxch	ST(4)
$LN25@setquadcod:

; 266  :     else break;
; 267  :     bit <<= 2;
; 268  :     if ( t->maxs[1] <= midy ) 

	fld	DWORD PTR [esi+96]
	add	ecx, ecx
	fcomp	ST(3)
	add	ecx, ecx
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN26@setquadcod

; 269  :     { q |= bit; midy -= deltay; }

	fxch	ST(2)
	or	edx, ecx
	fsub	ST(0), ST(4)
	jmp	SHORT $LN27@setquadcod
$LN26@setquadcod:

; 270  :     else if ( t->mins[1] >= midy )

	fld	DWORD PTR [esi+84]
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 1
	jne	$LN92@setquadcod

; 271  :     { q |= bit<<1; midy += deltay; }

	fld	ST(4)
	lea	eax, DWORD PTR [ecx+ecx]
	faddp	ST(3), ST(0)
	or	edx, eax
	fxch	ST(2)
$LN27@setquadcod:

; 272  :     else break;
; 273  :     bit <<= 2;

	fxch	ST(3)
	add	ecx, ecx
	fmul	ST(0), ST(1)
	add	ecx, ecx
	fxch	ST(4)
	fmul	ST(0), ST(1)
	fld	DWORD PTR [esi+92]
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN30@setquadcod

; 263  :     { q |= bit; midx -= deltax; }

	fxch	ST(2)
	or	edx, ecx
	fsub	ST(0), ST(4)
	jmp	SHORT $LN31@setquadcod
$LN30@setquadcod:

; 264  :     else if ( t->mins[0] >= midx )

	fld	DWORD PTR [esi+80]
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN88@setquadcod

; 265  :     { q |= bit<<1; midx += deltax; }

	fld	ST(4)
	lea	eax, DWORD PTR [ecx+ecx]
	faddp	ST(3), ST(0)
	or	edx, eax
	fxch	ST(2)
$LN31@setquadcod:

; 266  :     else break;
; 267  :     bit <<= 2;
; 268  :     if ( t->maxs[1] <= midy ) 

	fld	DWORD PTR [esi+96]
	add	ecx, ecx
	fcomp	ST(4)
	add	ecx, ecx
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN32@setquadcod

; 269  :     { q |= bit; midy -= deltay; }

	fxch	ST(3)
	or	edx, ecx
	fsub	ST(0), ST(2)
	jmp	SHORT $LN33@setquadcod
$LN32@setquadcod:

; 270  :     else if ( t->mins[1] >= midy )

	fld	DWORD PTR [esi+84]
	fcomp	ST(4)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN84@setquadcod

; 271  :     { q |= bit<<1; midy += deltay; }

	fld	ST(2)
	lea	eax, DWORD PTR [ecx+ecx]
	faddp	ST(4), ST(0)
	or	edx, eax
	fxch	ST(3)
$LN33@setquadcod:

; 272  :     else break;
; 273  :     bit <<= 2;

	add	ecx, ecx
	fxch	ST(4)
	fmul	ST(0), ST(1)
	add	edi, 4
	add	ecx, ecx
	fxch	ST(2)
	fmul	ST(0), ST(1)
	cmp	edi, 8
	jl	$LN82@setquadcod

; 259  : 
; 260  :   for ( n = 0  ; n < 8 ; n++, deltax /= 2, deltay /= 2 )

	fstp	ST(1)
	pop	edi
	fstp	ST(1)

; 274  :   }
; 275  : 
; 276  :   t->quadcode = q;

	mov	DWORD PTR [esi+120], edx
	fstp	ST(0)

; 277  :   return INTHEBOX;

	mov	eax, 1
	fstp	ST(1)
	pop	esi
	fstp	ST(0)

; 278  : } // end setquadcode()

	pop	ebp
	ret	0
$LN84@setquadcod:

; 270  :     else if ( t->mins[1] >= midy )

	fstp	ST(1)
	pop	edi
	fstp	ST(3)

; 274  :   }
; 275  : 
; 276  :   t->quadcode = q;

	mov	DWORD PTR [esi+120], edx
	fstp	ST(0)

; 277  :   return INTHEBOX;

	mov	eax, 1
	fstp	ST(0)
	pop	esi
	fstp	ST(0)

; 278  : } // end setquadcode()

	pop	ebp
	ret	0
$LN88@setquadcod:

; 264  :     else if ( t->mins[0] >= midx )

	fstp	ST(1)
	pop	edi
	fstp	ST(1)

; 274  :   }
; 275  : 
; 276  :   t->quadcode = q;

	mov	DWORD PTR [esi+120], edx
	fstp	ST(2)

; 277  :   return INTHEBOX;

	mov	eax, 1
	fstp	ST(1)
	pop	esi
	fstp	ST(0)

; 278  : } // end setquadcode()

	pop	ebp
	ret	0
$LN92@setquadcod:

; 270  :     else if ( t->mins[1] >= midy )

	fstp	ST(1)
	pop	edi
	fstp	ST(0)

; 274  :   }
; 275  : 
; 276  :   t->quadcode = q;

	mov	DWORD PTR [esi+120], edx
	fstp	ST(1)

; 277  :   return INTHEBOX;

	mov	eax, 1
	fstp	ST(1)
	pop	esi
	fstp	ST(0)

; 278  : } // end setquadcode()

	pop	ebp
	ret	0
$LN96@setquadcod:

; 264  :     else if ( t->mins[0] >= midx )

	fstp	ST(1)
	pop	edi
	fstp	ST(3)

; 274  :   }
; 275  : 
; 276  :   t->quadcode = q;

	mov	DWORD PTR [esi+120], edx
	fstp	ST(1)

; 277  :   return INTHEBOX;

	mov	eax, 1
	fstp	ST(1)
	pop	esi
	fstp	ST(0)

; 278  : } // end setquadcode()

	pop	ebp
	ret	0
$LN100@setquadcod:

; 270  :     else if ( t->mins[1] >= midy )

	fstp	ST(1)
	pop	edi
	fstp	ST(0)

; 274  :   }
; 275  : 
; 276  :   t->quadcode = q;

	mov	DWORD PTR [esi+120], edx
	fstp	ST(0)

; 277  :   return INTHEBOX;

	mov	eax, 1
	fstp	ST(0)
	pop	esi
	fstp	ST(0)

; 278  : } // end setquadcode()

	pop	ebp
	ret	0
$LN104@setquadcod:

; 264  :     else if ( t->mins[0] >= midx )

	fstp	ST(1)
	pop	edi
	fstp	ST(2)

; 274  :   }
; 275  : 
; 276  :   t->quadcode = q;

	mov	DWORD PTR [esi+120], edx
	fstp	ST(0)

; 277  :   return INTHEBOX;

	mov	eax, 1
	fstp	ST(0)
	pop	esi
	fstp	ST(0)

; 278  : } // end setquadcode()

	pop	ebp
	ret	0
$LN112@setquadcod:

; 264  :     else if ( t->mins[0] >= midx )

	fstp	ST(1)
	pop	edi
	fstp	ST(0)

; 274  :   }
; 275  : 
; 276  :   t->quadcode = q;

	mov	DWORD PTR [esi+120], edx
	fstp	ST(0)

; 277  :   return INTHEBOX;

	mov	eax, 1
	fstp	ST(1)
	pop	esi
	fstp	ST(0)

; 278  : } // end setquadcode()

	pop	ebp
	ret	0
$LN37@setquadcod:

; 253  :   REAL midy = (minclipy+maxclipy)/2;
; 254  :   REAL deltax = (maxclipx-minclipx)/4;
; 255  :   REAL deltay = (maxclipy-minclipy)/4;
; 256  : 
; 257  :   if ( t->maxs[0] < minclipx || t->mins[0] > maxclipx || t->maxs[1] < minclipy
; 258  :        || t->mins[1] > maxclipy ) return OUTOFBOX;

	fstp	ST(2)
	xor	eax, eax
	fstp	ST(0)
	pop	esi
	fstp	ST(1)
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)

; 278  : } // end setquadcode()

	pop	ebp
	ret	0
$LN46@setquadcod:

; 253  :   REAL midy = (minclipy+maxclipy)/2;
; 254  :   REAL deltax = (maxclipx-minclipx)/4;
; 255  :   REAL deltay = (maxclipy-minclipy)/4;
; 256  : 
; 257  :   if ( t->maxs[0] < minclipx || t->mins[0] > maxclipx || t->maxs[1] < minclipy
; 258  :        || t->mins[1] > maxclipy ) return OUTOFBOX;

	fstp	ST(1)
	xor	eax, eax
	fstp	ST(0)
	pop	esi
	fstp	ST(0)
	fstp	ST(1)
	fstp	ST(0)

; 278  : } // end setquadcode()

	pop	ebp
	ret	0
_setquadcode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@MPMLOOCO@Starting?5first?5sweep?4?6?$AA@ ; `string'
PUBLIC	__real@c6293e5939a08cea
PUBLIC	??_C@_0CG@LBNEOEHI@depth?5sort?3?5too?5many?5items?5in?5sw@ ; `string'
PUBLIC	__real@408f400000000000
PUBLIC	__real@c415af1d78b58c40
PUBLIC	__real@4415af1d78b58c40
PUBLIC	_multiple_sweep_prep
EXTRN	_erroutstring:PROC
EXTRN	_init_graphics:DWORD
EXTRN	_kb_error:PROC
EXTRN	_raw_generate:PROC
EXTRN	_bbox_maxx:QWORD
EXTRN	_bbox_maxy:QWORD
EXTRN	_bbox_minx:QWORD
EXTRN	_bbox_miny:QWORD
EXTRN	_memset:PROC
_BSS	SEGMENT
_sweep_bottom DQ 01H DUP (?)
_sweep_top DQ	01H DUP (?)
_sweep_done DD	01H DUP (?)
_sweep_k DD	01H DUP (?)
_count	DD	01H DUP (?)
_sweep_total DD	01H DUP (?)
_maxcount DD	01H DUP (?)
	ALIGN	8

_sweep_delta DQ	01H DUP (?)
_painter_multiple_sweep_flag DD 01H DUP (?)
_sweep_maxs DD	03e8H DUP (?)
_sweep_mins DD	03e8H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BH@MPMLOOCO@Starting?5first?5sweep?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@MPMLOOCO@Starting?5first?5sweep?4?6?$AA@ DB 'Starting first swe'
	DB	'ep.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@c6293e5939a08cea
CONST	SEGMENT
__real@c6293e5939a08cea DQ 0c6293e5939a08cear	; -1e+030
CONST	ENDS
;	COMDAT ??_C@_0CG@LBNEOEHI@depth?5sort?3?5too?5many?5items?5in?5sw@
CONST	SEGMENT
??_C@_0CG@LBNEOEHI@depth?5sort?3?5too?5many?5items?5in?5sw@ DB 'depth sor'
	DB	't: too many items in sweep.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@c415af1d78b58c40
CONST	SEGMENT
__real@c415af1d78b58c40 DQ 0c415af1d78b58c40r	; -1e+020
CONST	ENDS
;	COMDAT __real@4415af1d78b58c40
CONST	SEGMENT
__real@4415af1d78b58c40 DQ 04415af1d78b58c40r	; 1e+020
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _multiple_sweep_prep
_TEXT	SEGMENT
tv493 = -4						; size = 4
_multiple_sweep_prep PROC				; COMDAT

; 286  : { size_t total;

	push	ebp
	mov	ebp, esp
	push	ecx

; 287  :   int k;
; 288  : 
; 289  :   bbox_minx = bbox_miny = 1e20;

	fld	QWORD PTR __real@4415af1d78b58c40
	push	esi
	push	edi
	fst	QWORD PTR _bbox_miny

; 290  :   bbox_maxx = bbox_maxy = -1e20;
; 291  : 
; 292  :   memset((void*)sweep_mins,0,sizeof(sweep_mins));

	push	4000					; 00000fa0H
	fstp	QWORD PTR _bbox_minx
	fld	QWORD PTR __real@c415af1d78b58c40
	push	0
	fst	QWORD PTR _bbox_maxy
	push	OFFSET _sweep_mins
	fstp	QWORD PTR _bbox_maxx
	call	_memset

; 293  :   memset((void*)sweep_maxs,0,sizeof(sweep_maxs));

	push	4000					; 00000fa0H
	push	0
	push	OFFSET _sweep_maxs
	call	_memset

; 294  :   sweep_delta = (sweep_high - sweep_low)/SWEEPBINS;

	fld	QWORD PTR _sweep_high
	fsub	QWORD PTR _sweep_low
	add	esp, 24					; 00000018H

; 295  :   painter_multiple_sweep_flag = MULTIPLE_SWEEP_PREP;

	mov	DWORD PTR _painter_multiple_sweep_flag, 2
	fdiv	QWORD PTR __real@408f400000000000
	fstp	QWORD PTR _sweep_delta

; 296  :   raw_generate();

	call	_raw_generate

; 297  : 
; 298  :   // see if we are ever going to have more than maxcount
; 299  :   // items in a sweep
; 300  :   for ( total = 0, k = 0 ; k < SWEEPBINS ; k++ )

	mov	edx, DWORD PTR _maxcount
	xor	edi, edi
	xor	esi, esi
$LL8@multiple_s:

; 301  :   { total += sweep_mins[k] - (k ? sweep_maxs[k-1] : 0);

	test	esi, esi
	je	SHORT $LN11@multiple_s
	mov	eax, DWORD PTR _sweep_maxs[esi*4-4]
	jmp	SHORT $LN12@multiple_s
$LN11@multiple_s:
	xor	eax, eax
$LN12@multiple_s:
	mov	ecx, DWORD PTR _sweep_mins[esi*4]
	sub	ecx, eax
	add	edi, ecx

; 302  :     if ( total > maxcount )

	cmp	edi, edx
	jbe	SHORT $LN5@multiple_s

; 303  :       kb_error(5532,"depth sort: too many items in sweep.\n",
; 304  :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CG@LBNEOEHI@depth?5sort?3?5too?5many?5items?5in?5sw@
	push	5532					; 0000159cH
	call	_kb_error
	mov	edx, DWORD PTR _maxcount
	add	esp, 12					; 0000000cH
$LN5@multiple_s:

; 305  :     sweep_total += sweep_mins[k];

	mov	eax, DWORD PTR _sweep_mins[esi*4]
	add	DWORD PTR _sweep_total, eax
	inc	esi
	cmp	esi, 1000				; 000003e8H
	jl	SHORT $LL8@multiple_s

; 306  :   }
; 307  : 
; 308  :   // Now set up for first sweep
; 309  :   count = 0;
; 310  :   sweep_done = 0;
; 311  :   for ( total = 0, k = 0 ; k < SWEEPBINS ; k++ )

	xor	eax, eax
	mov	DWORD PTR _count, 0
	xor	ecx, ecx
	npad	4
$LL4@multiple_s:

; 312  :   { if ( total + sweep_mins[k] > maxcount )

	mov	esi, DWORD PTR _sweep_mins[ecx*4]
	add	esi, eax
	cmp	esi, edx
	ja	SHORT $LN15@multiple_s

; 313  :        break;
; 314  :     total += sweep_mins[k];

	mov	eax, esi
	mov	esi, DWORD PTR _sweep_mins[ecx*4+4]
	add	esi, eax
	cmp	esi, edx
	ja	SHORT $LN18@multiple_s
	mov	eax, esi
	mov	esi, DWORD PTR _sweep_mins[ecx*4+8]
	add	esi, eax
	cmp	esi, edx
	ja	SHORT $LN19@multiple_s
	mov	eax, esi
	mov	esi, DWORD PTR _sweep_mins[ecx*4+12]
	add	esi, eax
	cmp	esi, edx
	ja	SHORT $LN20@multiple_s
	mov	eax, esi
	mov	esi, DWORD PTR _sweep_mins[ecx*4+16]
	add	esi, eax
	cmp	esi, edx
	ja	SHORT $LN21@multiple_s
	add	ecx, 5
	mov	eax, esi
	cmp	ecx, 1000				; 000003e8H
	jl	SHORT $LL4@multiple_s
	jmp	SHORT $LN15@multiple_s
$LN18@multiple_s:

; 312  :   { if ( total + sweep_mins[k] > maxcount )

	inc	ecx
	jmp	SHORT $LN15@multiple_s
$LN19@multiple_s:
	add	ecx, 2
	jmp	SHORT $LN15@multiple_s
$LN20@multiple_s:
	add	ecx, 3
	jmp	SHORT $LN15@multiple_s
$LN21@multiple_s:
	add	ecx, 4
$LN15@multiple_s:

; 315  :   }
; 316  :   sweep_k = k;

	mov	DWORD PTR _sweep_k, ecx

; 317  :   sweep_done = total;
; 318  :   sweep_top = sweep_low + (k-1)*sweep_delta;

	dec	ecx
	mov	DWORD PTR tv493[ebp], ecx
	fild	DWORD PTR tv493[ebp]
	mov	DWORD PTR _sweep_done, eax

; 319  :   sweep_bottom = -1e30;
; 320  : 
; 321  :   painter_multiple_sweep_flag = MULTIPLE_SWEEP_GO;

	mov	DWORD PTR _painter_multiple_sweep_flag, 3
	fmul	QWORD PTR _sweep_delta
	fadd	QWORD PTR _sweep_low
	fstp	QWORD PTR _sweep_top
	fld	QWORD PTR __real@c6293e5939a08cea
	fstp	QWORD PTR _sweep_bottom

; 322  :   (*init_graphics)();  // print out postscript header

	call	DWORD PTR _init_graphics

; 323  :   erroutstring("Starting first sweep.\n");

	push	OFFSET ??_C@_0BH@MPMLOOCO@Starting?5first?5sweep?4?6?$AA@
	call	_erroutstring
	add	esp, 4
	pop	edi
	pop	esi

; 324  : 
; 325  : } // end multiple_sweep_prep()

	mov	esp, ebp
	pop	ebp
	ret	0
_multiple_sweep_prep ENDP
_TEXT	ENDS
PUBLIC	_sweep_prep_one
EXTRN	_need_bounding_box:DWORD
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Ogtp
;	COMDAT _sweep_prep_one
_TEXT	SEGMENT
_t$ = 8							; size = 4
_sweep_prep_one PROC					; COMDAT

; 333  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 334  :     int bin = (int)((t->mins[SDIM-1] - sweep_low)/sweep_delta);

	mov	esi, DWORD PTR _t$[ebp]
	push	edi
	mov	edi, DWORD PTR _web+616
	fld	DWORD PTR [esi+edi*4+76]
	fld	QWORD PTR _sweep_low
	fsub	ST(1), ST(0)
	fld	QWORD PTR _sweep_delta
	fdiv	ST(2), ST(0)
	fxch	ST(2)
	call	__ftol2_sse

; 335  :     if ( bin < 0 ) 

	test	eax, eax
	jns	SHORT $LN9@sweep_prep

; 336  :       bin = 0;

	xor	eax, eax

; 337  :     if ( bin >= SWEEPBINS )

	jmp	SHORT $LN8@sweep_prep
$LN9@sweep_prep:
	cmp	eax, 1000				; 000003e8H
	jl	SHORT $LN8@sweep_prep

; 338  :       bin = SWEEPBINS - 1;

	mov	eax, 999				; 000003e7H
$LN8@sweep_prep:

; 339  :     sweep_mins[bin]++;

	inc	DWORD PTR _sweep_mins[eax*4]

; 340  :     bin = (int)((t->maxs[SDIM-1] - sweep_low)/sweep_delta);

	fsubr	DWORD PTR [esi+edi*4+88]
	fdivrp	ST(1), ST(0)
	call	__ftol2_sse

; 341  :     if ( bin < 0 ) 

	test	eax, eax
	jns	SHORT $LN7@sweep_prep

; 342  :       bin = 0;

	xor	eax, eax

; 343  :     if ( bin >= SWEEPBINS )

	jmp	SHORT $LN6@sweep_prep
$LN7@sweep_prep:
	cmp	eax, 1000				; 000003e8H
	jl	SHORT $LN6@sweep_prep

; 344  :       bin = SWEEPBINS - 1;

	mov	eax, 999				; 000003e7H
$LN6@sweep_prep:

; 345  :     sweep_maxs[bin]++;

	inc	DWORD PTR _sweep_maxs[eax*4]

; 346  : 
; 347  :   /* find bounding box */
; 348  :   if ( need_bounding_box )

	cmp	DWORD PTR _need_bounding_box, 0
	je	SHORT $LN1@sweep_prep

; 349  :   { 
; 350  :     { if ( t->mins[0] < bbox_minx ) bbox_minx = (REAL)t->mins[0];

	fld	DWORD PTR [esi+80]
	fcomp	QWORD PTR _bbox_minx
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@sweep_prep
	fld	DWORD PTR [esi+80]
	fstp	QWORD PTR _bbox_minx
$LN4@sweep_prep:

; 351  :       if ( t->mins[1] < bbox_miny ) bbox_miny = (REAL)t->mins[1];

	fld	DWORD PTR [esi+84]
	fcomp	QWORD PTR _bbox_miny
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@sweep_prep
	fld	DWORD PTR [esi+84]
	fstp	QWORD PTR _bbox_miny
$LN3@sweep_prep:

; 352  :       if ( t->maxs[0] > bbox_maxx ) bbox_maxx = (REAL)t->maxs[0];

	fld	DWORD PTR [esi+92]
	fcomp	QWORD PTR _bbox_maxx
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@sweep_prep
	fld	DWORD PTR [esi+92]
	fstp	QWORD PTR _bbox_maxx
$LN2@sweep_prep:

; 353  :       if ( t->maxs[1] > bbox_maxy ) bbox_maxy = (REAL)t->maxs[1];

	fld	DWORD PTR [esi+96]
	fcomp	QWORD PTR _bbox_maxy
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@sweep_prep
	fld	DWORD PTR [esi+96]
	fstp	QWORD PTR _bbox_maxy
$LN1@sweep_prep:
	pop	edi
	pop	esi

; 354  :     }
; 355  :   }
; 356  : 
; 357  : } // end sweep_prep_one()

	pop	ebp
	ret	0
_sweep_prep_one ENDP
_TEXT	ENDS
PUBLIC	__real@41f0000000000000
PUBLIC	__real@46293e5939a08cea
PUBLIC	??_C@_0CL@KIDLEPMJ@Sweep?5completed?4?5Done?5?$CFlld?5of?5?$CFl@ ; `string'
PUBLIC	_reset_multiple_sweep
EXTRN	_sprintf:PROC
EXTRN	_msg:DWORD
_BSS	SEGMENT
_textra	DB	036b0H DUP (?)
_BSS	ENDS
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
CONST	ENDS
;	COMDAT __real@46293e5939a08cea
CONST	SEGMENT
__real@46293e5939a08cea DQ 046293e5939a08cear	; 1e+030
CONST	ENDS
;	COMDAT ??_C@_0CL@KIDLEPMJ@Sweep?5completed?4?5Done?5?$CFlld?5of?5?$CFl@
CONST	SEGMENT
??_C@_0CL@KIDLEPMJ@Sweep?5completed?4?5Done?5?$CFlld?5of?5?$CFl@ DB 'Swee'
	DB	'p completed. Done %lld of %lld items.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _reset_multiple_sweep
_TEXT	SEGMENT
tv581 = -4						; size = 4
tv564 = -4						; size = 4
tv134 = -4						; size = 4
_reset_multiple_sweep PROC				; COMDAT

; 365  : { size_t k,j,total;

	push	ebp
	mov	ebp, esp
	push	ecx

; 366  : 
; 367  :   sprintf(msg,"Sweep completed. Done %lld of %lld items.\n",(long long)sweep_done,
; 368  :       (long long)sweep_total);

	mov	eax, DWORD PTR _sweep_total
	mov	ecx, DWORD PTR _sweep_done
	mov	edx, DWORD PTR _msg
	push	0
	push	eax
	push	0
	push	ecx
	push	OFFSET ??_C@_0CL@KIDLEPMJ@Sweep?5completed?4?5Done?5?$CFlld?5of?5?$CFl@
	push	edx
	call	_sprintf

; 369  :   erroutstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_erroutstring
	add	esp, 28					; 0000001cH

; 370  : 
; 371  :   if ( sweep_k >= SWEEPBINS )

	cmp	DWORD PTR _sweep_k, 1000		; 000003e8H
	jb	SHORT $LN15@reset_mult

; 372  :   { painter_multiple_sweep_flag = MULTIPLE_SWEEP_DONE;

	mov	DWORD PTR _painter_multiple_sweep_flag, 4

; 400  : 
; 401  : } // end reset_multiple_sweep()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@reset_mult:

; 373  :     return;
; 374  :   }
; 375  : 
; 376  :   // compactify left-over trilist, with extra ones tacked on at end
; 377  :   for ( k = 0, j = 0 ; k < count ; k++ )

	mov	ecx, DWORD PTR _count
	push	ebx
	push	esi
	xor	ebx, ebx
	push	edi
	test	ecx, ecx
	je	SHORT $LN30@reset_mult
	xor	eax, eax
	mov	DWORD PTR tv134[ebp], ecx
	mov	ecx, DWORD PTR _trilist
	xor	edx, edx
	npad	6
$LL33@reset_mult:

; 378  :     if ( trilist[k].flag )

	cmp	DWORD PTR [edx+ecx+28], 0
	lea	esi, DWORD PTR [edx+ecx]
	je	SHORT $LN13@reset_mult

; 379  :       trilist[j++] = trilist[k];

	lea	edi, DWORD PTR [eax+ecx]
	mov	ecx, 35					; 00000023H
	rep movsd
	mov	ecx, DWORD PTR _trilist
	inc	ebx
	add	eax, 140				; 0000008cH
$LN13@reset_mult:

; 373  :     return;
; 374  :   }
; 375  : 
; 376  :   // compactify left-over trilist, with extra ones tacked on at end
; 377  :   for ( k = 0, j = 0 ; k < count ; k++ )

	add	edx, 140				; 0000008cH
	dec	DWORD PTR tv134[ebp]
	jne	SHORT $LL33@reset_mult
	jmp	SHORT $LN12@reset_mult
$LN30@reset_mult:
	mov	ecx, DWORD PTR _trilist
$LN12@reset_mult:

; 380  :   for ( k = 0 ; k < TEXTRA ; k++ )

	mov	eax, ebx
	imul	eax, 140				; 0000008cH
	mov	edx, OFFSET _textra
	mov	DWORD PTR tv564[ebp], 20		; 00000014H
$LL34@reset_mult:

; 381  :     if ( textra[k].flag )

	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN9@reset_mult

; 382  :       trilist[j++] = textra[k];

	lea	edi, DWORD PTR [eax+ecx]
	mov	ecx, 35					; 00000023H
	mov	esi, edx
	rep movsd
	mov	ecx, DWORD PTR _trilist
	inc	ebx
	add	eax, 140				; 0000008cH
$LN9@reset_mult:

; 381  :     if ( textra[k].flag )

	cmp	DWORD PTR [edx+168], 0
	je	SHORT $LN26@reset_mult

; 382  :       trilist[j++] = textra[k];

	lea	edi, DWORD PTR [eax+ecx]
	lea	esi, DWORD PTR [edx+140]
	mov	ecx, 35					; 00000023H
	rep movsd
	mov	ecx, DWORD PTR _trilist
	inc	ebx
	add	eax, 140				; 0000008cH
$LN26@reset_mult:

; 381  :     if ( textra[k].flag )

	cmp	DWORD PTR [edx+308], 0
	je	SHORT $LN27@reset_mult

; 382  :       trilist[j++] = textra[k];

	lea	edi, DWORD PTR [eax+ecx]
	lea	esi, DWORD PTR [edx+280]
	mov	ecx, 35					; 00000023H
	rep movsd
	mov	ecx, DWORD PTR _trilist
	inc	ebx
	add	eax, 140				; 0000008cH
$LN27@reset_mult:

; 381  :     if ( textra[k].flag )

	cmp	DWORD PTR [edx+448], 0
	je	SHORT $LN28@reset_mult

; 382  :       trilist[j++] = textra[k];

	lea	edi, DWORD PTR [eax+ecx]
	lea	esi, DWORD PTR [edx+420]
	mov	ecx, 35					; 00000023H
	rep movsd
	mov	ecx, DWORD PTR _trilist
	inc	ebx
	add	eax, 140				; 0000008cH
$LN28@reset_mult:

; 381  :     if ( textra[k].flag )

	cmp	DWORD PTR [edx+588], 0
	je	SHORT $LN29@reset_mult

; 382  :       trilist[j++] = textra[k];

	lea	edi, DWORD PTR [eax+ecx]
	lea	esi, DWORD PTR [edx+560]
	mov	ecx, 35					; 00000023H
	rep movsd
	mov	ecx, DWORD PTR _trilist
	inc	ebx
	add	eax, 140				; 0000008cH
$LN29@reset_mult:

; 380  :   for ( k = 0 ; k < TEXTRA ; k++ )

	add	edx, 700				; 000002bcH
	dec	DWORD PTR tv564[ebp]
	jne	$LL34@reset_mult

; 383  :   memset((void*)(trilist+j),0,(maxcount-j)*sizeof(struct tsort));

	mov	esi, DWORD PTR _maxcount
	mov	edx, esi
	sub	edx, ebx
	imul	edx, 140				; 0000008cH
	mov	eax, ebx
	imul	eax, 140				; 0000008cH
	push	edx
	add	eax, ecx
	push	0
	push	eax
	call	_memset

; 384  :   memset((void*)(textra),0,TEXTRA*sizeof(struct tsort));

	push	14000					; 000036b0H
	push	0
	push	OFFSET _textra
	call	_memset

; 385  :   count = j-TEXTRA;
; 386  : 
; 387  :   // Now get bounds for next sweep
; 388  :   for ( total = count, k = sweep_k ; k < SWEEPBINS ; k++ )

	mov	eax, DWORD PTR _sweep_k
	mov	edi, DWORD PTR _sweep_done
	lea	edx, DWORD PTR [ebx-100]
	add	esp, 24					; 00000018H
	mov	DWORD PTR _count, edx
$LL6@reset_mult:

; 389  :   { if ( total + sweep_mins[k] > maxcount )

	mov	ecx, DWORD PTR _sweep_mins[eax*4]
	add	edx, ecx
	cmp	edx, esi
	ja	SHORT $LN35@reset_mult

; 390  :        break;
; 391  :     total += sweep_mins[k];
; 392  :     sweep_done += sweep_mins[k];

	inc	eax
	add	edi, ecx
	cmp	eax, 1000				; 000003e8H
	jb	SHORT $LL6@reset_mult
$LN35@reset_mult:

; 393  :   }
; 394  :   sweep_k = k;
; 395  :   sweep_bottom = sweep_top;

	fld	QWORD PTR _sweep_top
	mov	DWORD PTR _sweep_done, edi
	pop	edi
	fstp	QWORD PTR _sweep_bottom
	pop	esi
	mov	DWORD PTR _sweep_k, eax
	pop	ebx

; 396  :   if ( sweep_k >= SWEEPBINS )

	cmp	eax, 1000				; 000003e8H
	jb	SHORT $LN2@reset_mult

; 397  :     sweep_top = 1e30;

	fld	QWORD PTR __real@46293e5939a08cea

; 398  :   else 
; 399  :     sweep_top = sweep_low + (k-1)*sweep_delta;

	fstp	QWORD PTR _sweep_top

; 400  : 
; 401  : } // end reset_multiple_sweep()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@reset_mult:

; 398  :   else 
; 399  :     sweep_top = sweep_low + (k-1)*sweep_delta;

	dec	eax
	mov	DWORD PTR tv581[ebp], eax
	fild	DWORD PTR tv581[ebp]
	jns	SHORT $LN36@reset_mult
	fadd	QWORD PTR __real@41f0000000000000
$LN36@reset_mult:
	fmul	QWORD PTR _sweep_delta
	fadd	QWORD PTR _sweep_low
	fstp	QWORD PTR _sweep_top

; 400  : 
; 401  : } // end reset_multiple_sweep()

	mov	esp, ebp
	pop	ebp
	ret	0
_reset_multiple_sweep ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@BNIENEOH@ps_linewidth?$AA@		; `string'
PUBLIC	??_C@_0DP@MCIPDJEM@Very?5big?5surface?0?5so?5painter?5alg@ ; `string'
PUBLIC	??_C@_09MBOBPMLK@PAINTER?4C?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_painter_start
EXTRN	_ps_widthattr:DWORD
EXTRN	_find_extra:PROC
EXTRN	_kb_temp_calloc:PROC
EXTRN	__imp__GlobalMemoryStatusEx@4:PROC
EXTRN	_transform_count:DWORD
EXTRN	_transforms_flag:DWORD
EXTRN	_bare_edge_count:DWORD
EXTRN	_torus_display_mode:DWORD
EXTRN	__aulldiv:PROC
;	COMDAT ??_C@_0N@BNIENEOH@ps_linewidth?$AA@
CONST	SEGMENT
??_C@_0N@BNIENEOH@ps_linewidth?$AA@ DB 'ps_linewidth', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@MCIPDJEM@Very?5big?5surface?0?5so?5painter?5alg@
CONST	SEGMENT
??_C@_0DP@MCIPDJEM@Very?5big?5surface?0?5so?5painter?5alg@ DB 'Very big s'
	DB	'urface, so painter algorithm doing multiple sweeps.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
CONST	SEGMENT
??_C@_09MBOBPMLK@PAINTER?4C?$AA@ DB 'PAINTER.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _painter_start
_TEXT	SEGMENT
_dummy$ = -72						; size = 4
_statex$89271 = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_painter_start PROC					; COMDAT

; 408  : { int dummy;

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 409  :   size_t allocsize;
; 410  : 
; 411  :   gdim = (SDIM <= 3) ? SDIM : 3;

	mov	eax, DWORD PTR _web+616
	mov	ecx, 3
	mov	DWORD PTR _gdim, eax
	cmp	eax, ecx
	jle	SHORT $LN15@painter_st
	mov	DWORD PTR _gdim, ecx
$LN15@painter_st:
	push	edi

; 416  :      if ( web.torus_flag ) maxcount *= 2;

	xor	edi, edi
	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN11@painter_st

; 412  : 
; 413  :   /* allocate space for depth sort list */
; 414  :   if ( web.representation == STRING )
; 415  :   {  maxcount = web.skel[EDGE].count + 5;

	mov	eax, DWORD PTR _web+176
	add	eax, 5
	mov	DWORD PTR _maxcount, eax

; 416  :      if ( web.torus_flag ) maxcount *= 2;

	cmp	DWORD PTR _web+860, edi
	je	SHORT $LN5@painter_st
	add	eax, eax

; 417  :   }
; 418  :   else

	jmp	SHORT $LN18@painter_st
$LN11@painter_st:

; 419  :   { if ( web.torus_flag )

	cmp	DWORD PTR _web+860, edi
	je	SHORT $LN8@painter_st

; 420  :       if ( torus_display_mode == TORUS_CLIPPED_MODE )

	cmp	DWORD PTR _torus_display_mode, ecx

; 421  :         maxcount = 5*web.skel[FACET].count+ bare_edge_count + 5;

	mov	ecx, DWORD PTR _web+288
	jne	SHORT $LN7@painter_st
	mov	eax, DWORD PTR _bare_edge_count
	inc	ecx
	lea	eax, DWORD PTR [eax+ecx*4]
	add	eax, ecx
	jmp	SHORT $LN18@painter_st
$LN7@painter_st:

; 422  :       else maxcount = 2*web.skel[FACET].count+ bare_edge_count + 5;

	mov	edx, DWORD PTR _bare_edge_count
	lea	eax, DWORD PTR [edx+ecx*2+5]

; 423  :     else

	jmp	SHORT $LN18@painter_st
$LN8@painter_st:

; 424  :       maxcount = web.skel[FACET].count + bare_edge_count + 5;

	mov	eax, DWORD PTR _web+288
	mov	ecx, DWORD PTR _bare_edge_count
	lea	eax, DWORD PTR [ecx+eax+5]
$LN18@painter_st:
	mov	DWORD PTR _maxcount, eax
$LN5@painter_st:

; 425  :   }
; 426  :   if ( transforms_flag ) maxcount *= transform_count;

	cmp	DWORD PTR _transforms_flag, edi
	je	SHORT $LN4@painter_st
	imul	eax, DWORD PTR _transform_count
	mov	DWORD PTR _maxcount, eax
$LN4@painter_st:

; 427  :   if ( web.dimension > 2 )

	mov	ecx, DWORD PTR _web+620
	cmp	ecx, 2
	jle	SHORT $LN3@painter_st

; 428  :      maxcount *= web.dimension+1; /* each simplex face becomes facet */

	inc	ecx
	imul	eax, ecx
	mov	DWORD PTR _maxcount, eax
$LN3@painter_st:

; 429  :   allocsize = (long)maxcount*sizeof(struct tsort);

	imul	eax, 140				; 0000008cH
	push	esi

; 430  :   painter_multiple_sweep_flag = 0;
; 431  : #ifdef WIN32
; 432  :   { MEMORYSTATUSEX statex;
; 433  :     statex.dwLength = sizeof (statex);
; 434  :     GlobalMemoryStatusEx (&statex);

	lea	edx, DWORD PTR _statex$89271[ebp]
	push	edx
	mov	esi, eax
	mov	DWORD PTR _painter_multiple_sweep_flag, edi
	mov	DWORD PTR _statex$89271[ebp], 64	; 00000040H
	call	DWORD PTR __imp__GlobalMemoryStatusEx@4

; 435  :     if ( allocsize > statex.ullAvailPhys/4 )

	mov	eax, DWORD PTR _statex$89271[ebp+20]
	mov	ecx, DWORD PTR _statex$89271[ebp+16]
	shrd	ecx, eax, 2
	shr	eax, 2
	xor	edx, edx
	cmp	edx, eax
	jb	SHORT $LN17@painter_st
	ja	SHORT $LN16@painter_st
	cmp	esi, ecx
	jbe	SHORT $LN17@painter_st
$LN16@painter_st:

; 436  :     { painter_multiple_sweep_flag = 1;
; 437  :       maxcount = (size_t)(statex.ullAvailPhys/4/sizeof(struct tsort));

	push	edi
	push	140					; 0000008cH
	push	eax
	push	ecx
	mov	DWORD PTR _painter_multiple_sweep_flag, 1
	call	__aulldiv
	mov	DWORD PTR _maxcount, eax
$LN17@painter_st:

; 438  :     }
; 439  :   }
; 440  : #elif defined(LINUX) && !defined(MAC_OS_X)
; 441  :   { struct sysinfo s;
; 442  :     sysinfo(&s);
; 443  :     if ( allocsize > (size_t)(s.freeram)*s.mem_unit/4 )
; 444  :     { painter_multiple_sweep_flag = 1;
; 445  :       maxcount = (size_t)(s.freeram)*s.mem_unit/4;
; 446  :     }
; 447  :   }
; 448  : #else
; 449  :   if ( maxcount >= 1000000  )
; 450  :   { painter_multiple_sweep_flag = 1;
; 451  :     maxcount = 1000000;
; 452  :   }
; 453  : #endif
; 454  :   trilist = (struct tsort *)temp_calloc(maxcount,sizeof(struct tsort));

	mov	eax, DWORD PTR _maxcount
	push	454					; 000001c6H
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	push	140					; 0000008cH
	push	eax
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _trilist, eax

; 455  :   count = 0;

	mov	DWORD PTR _count, edi
	pop	esi

; 456  :   if ( painter_multiple_sweep_flag )

	cmp	DWORD PTR _painter_multiple_sweep_flag, edi
	je	SHORT $LN1@painter_st

; 457  :   { erroutstring("Very big surface, so painter algorithm doing multiple sweeps.\n");

	push	OFFSET ??_C@_0DP@MCIPDJEM@Very?5big?5surface?0?5so?5painter?5alg@
	call	_erroutstring
	add	esp, 4

; 458  :     multiple_sweep_prep();

	call	_multiple_sweep_prep
$LN1@painter_st:

; 459  :   }
; 460  :   vis_count = 0;
; 461  :   vis_list = NULL;
; 462  :   vis_max = 0;
; 463  :   backstamp = 0;
; 464  :   ps_widthattr = find_extra(PS_WIDTHNAME,&dummy);

	lea	ecx, DWORD PTR _dummy$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@BNIENEOH@ps_linewidth?$AA@
	mov	DWORD PTR _vis_count, edi
	mov	DWORD PTR _vis_list, edi
	mov	DWORD PTR _vis_max, edi
	mov	DWORD PTR _backstamp, edi
	call	_find_extra

; 465  : } // end painter_start()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 8
	xor	ecx, ebp
	mov	DWORD PTR _ps_widthattr, eax
	pop	edi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_painter_start ENDP
_TEXT	ENDS
PUBLIC	__real@3f1a36e2e0000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_painter_edge
EXTRN	_dotf:PROC
EXTRN	_ps_gridedgewidth:QWORD
EXTRN	_ps_tripleedgewidth:QWORD
EXTRN	_ps_stringwidth:QWORD
EXTRN	_ps_conedgewidth:QWORD
EXTRN	_ps_fixededgewidth:QWORD
EXTRN	_ps_bareedgewidth:QWORD
EXTRN	_dymem:DWORD
EXTRN	_matvec_mul:PROC
EXTRN	_view:DWORD
EXTRN	_HOMDIM:DWORD
EXTRN	_kb_temp_realloc:PROC
;	COMDAT __real@3f1a36e2e0000000
CONST	SEGMENT
__real@3f1a36e2e0000000 DQ 03f1a36e2e0000000r	; 0.0001
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _painter_edge
_TEXT	SEGMENT
tv1588 = -132						; size = 4
_t$ = -128						; size = 4
tv193 = -124						; size = 4
_ctrl_pts$ = -124					; size = 4
tv1544 = -120						; size = 4
tv1533 = -120						; size = 4
tv1044 = -120						; size = 4
_b$ = -116						; size = 56
_a$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_gdata$ = 8						; size = 4
_e_id$ = 12						; size = 4
_painter_edge PROC					; COMDAT

; 477  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 478  :   struct tsort *t;
; 479  :   int i,j;
; 480  :   REAL a[MAXCOORD+1],b[MAXCOORD+1];
; 481  :   REAL dx,dy,dz,mag,width;
; 482  :   int ctrl_pts = gdata[0].flags & EDGE_ARC ? 3 : 2;

	mov	esi, DWORD PTR _gdata$[ebp]
	push	edi
	mov	edi, DWORD PTR [esi+136]
	and	edi, 32768				; 00008000H
	or	edi, 65536				; 00010000H
	shr	edi, 15					; 0000000fH

; 483  : 
; 484  :   if ( gdata->color == CLEAR ) return;

	cmp	DWORD PTR [esi+104], -1
	mov	DWORD PTR _ctrl_pts$[ebp], edi
	je	$LN44@painter_ed

; 485  :   if ( count >= maxcount-2 )

	mov	eax, DWORD PTR _maxcount
	push	ebx
	mov	ebx, DWORD PTR _count
	lea	ecx, DWORD PTR [eax-2]
	cmp	ebx, ecx
	jb	SHORT $LN75@painter_ed

; 486  :   { trilist = (struct tsort *)temp_realloc((char*)trilist,
; 487  :          (maxcount+200)*sizeof(struct tsort));

	mov	edx, DWORD PTR _trilist
	add	eax, 200				; 000000c8H
	imul	eax, 140				; 0000008cH
	push	487					; 000001e7H
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	push	eax
	push	edx
	call	_kb_temp_realloc

; 488  :     maxcount += 200;

	mov	ebx, DWORD PTR _count
	add	esp, 16					; 00000010H
	add	DWORD PTR _maxcount, 200		; 000000c8H
	mov	DWORD PTR _trilist, eax
$LN75@painter_ed:

; 489  :   }
; 490  : 
; 491  :   t = trilist + count;

	imul	ebx, 140				; 0000008cH
	add	ebx, DWORD PTR _trilist

; 492  :   t->flag = EDGE;

	mov	DWORD PTR [ebx+28], 1

; 493  :   t->flag |= (gdata->flags & (EDGE_ARC|LABEL_EDGE|LABEL_HEAD|LABEL_TAIL));

	mov	eax, DWORD PTR [esi+136]
	and	eax, 39936				; 00009c00H
	or	eax, 1
	mov	DWORD PTR [ebx+28], eax

; 494  :   for ( j =  SDIM ; j < HOMDIM-1 ; j++ ) a[j] = 0.0; /* filler */

	mov	ecx, DWORD PTR _HOMDIM
	mov	edx, DWORD PTR _web+616
	dec	ecx
	mov	DWORD PTR _t$[ebp], ebx
	cmp	edx, ecx
	jge	SHORT $LN41@painter_ed

; 489  :   }
; 490  : 
; 491  :   t = trilist + count;

	sub	ecx, edx
	add	ecx, ecx
	and	ecx, 1073741822				; 3ffffffeH
	lea	edi, DWORD PTR _a$[ebp+edx*8]
	xor	eax, eax
	rep stosd
	mov	edi, DWORD PTR _ctrl_pts$[ebp]
$LN41@painter_ed:

; 495  :   for ( i = 0 ; i < ctrl_pts ; i++ )

	test	edi, edi
	jle	$LN36@painter_ed
	lea	ecx, DWORD PTR [ebx+40]
	mov	DWORD PTR tv1544[ebp], ecx
	mov	ecx, DWORD PTR _ctrl_pts$[ebp]
	lea	eax, DWORD PTR [ebx+36]
	xor	esi, esi
	mov	DWORD PTR tv1588[ebp], eax
	mov	DWORD PTR tv193[ebp], ecx
	jmp	SHORT $LN38@painter_ed
$LL76@painter_ed:
	mov	edx, DWORD PTR _web+616
$LN38@painter_ed:

; 496  :   {
; 497  :     for ( j = 0 ; (j < SDIM) && (j < HOMDIM-1) ; j++ ) 

	xor	eax, eax
	cmp	edx, 4
	jl	SHORT $LC58@painter_ed

; 501  :     if ( SDIM <= 2 )

	mov	edi, DWORD PTR _HOMDIM
	dec	edi
	npad	7
$LL62@painter_ed:

; 496  :   {
; 497  :     for ( j = 0 ; (j < SDIM) && (j < HOMDIM-1) ; j++ ) 

	cmp	eax, edi
	jge	SHORT $LN82@painter_ed

; 498  :         a[j] = gdata[i].x[j];

	mov	ecx, DWORD PTR _gdata$[ebp]
	lea	edx, DWORD PTR [esi+eax]
	fld	QWORD PTR [ecx+edx*8]
	lea	edx, DWORD PTR [ecx+edx*8]
	lea	ecx, DWORD PTR [eax+2]
	fstp	QWORD PTR _a$[ebp+eax*8]
	lea	ebx, DWORD PTR [ecx-1]
	cmp	ebx, edi
	jge	SHORT $LN80@painter_ed
	fld	QWORD PTR [edx+8]
	fstp	QWORD PTR _a$[ebp+eax*8+8]
	cmp	ecx, edi
	jge	SHORT $LN80@painter_ed
	mov	edx, DWORD PTR _gdata$[ebp]
	lea	ebx, DWORD PTR [esi+eax+3]
	fld	QWORD PTR [edx+ebx*8-8]
	mov	ebx, DWORD PTR _t$[ebp]
	inc	ecx
	fstp	QWORD PTR _a$[ebp+eax*8+16]
	cmp	ecx, edi
	jge	SHORT $LN82@painter_ed
	lea	ecx, DWORD PTR [esi+eax+3]
	fld	QWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _web+616
	fstp	QWORD PTR _a$[ebp+eax*8+24]
	add	eax, 4
	lea	ecx, DWORD PTR [edx-3]
	cmp	eax, ecx
	jl	SHORT $LL62@painter_ed
$LC58@painter_ed:

; 496  :   {
; 497  :     for ( j = 0 ; (j < SDIM) && (j < HOMDIM-1) ; j++ ) 

	cmp	eax, edx
	jge	SHORT $LN82@painter_ed
	npad	1
$LL81@painter_ed:
	mov	ecx, DWORD PTR _HOMDIM
	dec	ecx
	cmp	eax, ecx
	jge	SHORT $LN82@painter_ed

; 498  :         a[j] = gdata[i].x[j];

	mov	edi, DWORD PTR _gdata$[ebp]
	lea	ecx, DWORD PTR [esi+eax]
	fld	QWORD PTR [edi+ecx*8]
	inc	eax
	fstp	QWORD PTR _a$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LL81@painter_ed

; 496  :   {
; 497  :     for ( j = 0 ; (j < SDIM) && (j < HOMDIM-1) ; j++ ) 

	jmp	SHORT $LN82@painter_ed
$LN80@painter_ed:
	mov	ebx, DWORD PTR _t$[ebp]
$LN82@painter_ed:

; 499  :     a[HOMDIM-1] = 1.0;

	mov	eax, DWORD PTR _HOMDIM
	fld1

; 500  :     matvec_mul(view,a,b,HOMDIM,HOMDIM);  /* transform */

	mov	ecx, DWORD PTR _view
	fstp	QWORD PTR _a$[ebp+eax*8-8]
	push	eax
	push	eax
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	push	ecx
	call	_matvec_mul

; 502  :       for ( j = 0 ; j < 3 ; j++ ) t->x[i][j] = (float)b[j];

	mov	ecx, DWORD PTR tv1588[ebp]
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _web+616, 2
	jg	SHORT $LN32@painter_ed
	fld	QWORD PTR _b$[ebp]
	fstp	DWORD PTR [ecx-4]
	fld	QWORD PTR _b$[ebp+8]
	fstp	DWORD PTR [ecx]
	fld	QWORD PTR _b$[ebp+16]
	fstp	DWORD PTR [ecx+4]

; 503  :     else  for ( j = 0 ; j < 3 ; j++ ) t->x[i][j] = (float)b[(j+1)%3];

	jmp	SHORT $LN67@painter_ed
$LN32@painter_ed:
	fld	QWORD PTR _b$[ebp+8]
	mov	eax, DWORD PTR tv1588[ebp]
	fstp	DWORD PTR [eax-4]
	fld	QWORD PTR _b$[ebp+16]
	fstp	DWORD PTR [eax]
	fld	QWORD PTR _b$[ebp]
	fstp	DWORD PTR [eax+4]
$LN67@painter_ed:

; 504  :     t->x[i][2] += (float).0001;   /* bias edges in front of facets */

	mov	eax, DWORD PTR tv1544[ebp]
	fld	DWORD PTR [eax]
	add	ecx, 12					; 0000000cH
	fadd	QWORD PTR __real@3f1a36e2e0000000
	add	eax, 12					; 0000000cH
	add	esi, 18					; 00000012H
	dec	DWORD PTR tv193[ebp]
	fstp	DWORD PTR [eax-12]
	mov	DWORD PTR tv1588[ebp], ecx
	mov	DWORD PTR tv1544[ebp], eax
	jne	$LL76@painter_ed

; 495  :   for ( i = 0 ; i < ctrl_pts ; i++ )

	mov	esi, DWORD PTR _gdata$[ebp]
$LN36@painter_ed:

; 505  :   }
; 506  : 
; 507  :   /* width of edge, in descending order of thickness */
; 508  :   if ( ps_widthattr >= 0 )

	mov	eax, DWORD PTR _ps_widthattr
	test	eax, eax
	js	SHORT $LN24@painter_ed

; 509  :     width = *EREAL(t->f_id,ps_widthattr);

	mov	edx, DWORD PTR [ebx]
	imul	eax, 240				; 000000f0H
	mov	ecx, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	add	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+64]
	fld	QWORD PTR [edx+eax]
	jmp	SHORT $LN11@painter_ed
$LN24@painter_ed:

; 510  :   else if ( gdata->etype & BARE_EDGE ) width = ps_bareedgewidth;

	movzx	eax, WORD PTR [esi+124]
	test	al, 64					; 00000040H
	je	SHORT $LN22@painter_ed
	fld	QWORD PTR _ps_bareedgewidth
	jmp	SHORT $LN11@painter_ed
$LN22@painter_ed:

; 511  :   else if ( gdata->etype & FIXED_EDGE ) width = ps_fixededgewidth;

	test	al, 16					; 00000010H
	je	SHORT $LN20@painter_ed
	fld	QWORD PTR _ps_fixededgewidth
	jmp	SHORT $LN11@painter_ed
$LN20@painter_ed:

; 512  :   else if ( gdata->etype & CONSTRAINT_EDGE ) width = ps_conedgewidth;

	test	al, 32					; 00000020H
	je	SHORT $LN18@painter_ed
	fld	QWORD PTR _ps_conedgewidth
	jmp	SHORT $LN11@painter_ed
$LN18@painter_ed:

; 513  :   else if ( gdata->etype & BOUNDARY_EDGE ) width = ps_conedgewidth;

	test	al, 8
	je	SHORT $LN16@painter_ed
	fld	QWORD PTR _ps_conedgewidth
	jmp	SHORT $LN11@painter_ed
$LN16@painter_ed:

; 514  :   else if ( gdata->etype & SINGLE_EDGE ) width = ps_stringwidth;

	test	al, 4
	je	SHORT $LN14@painter_ed
	fld	QWORD PTR _ps_stringwidth
	jmp	SHORT $LN11@painter_ed
$LN14@painter_ed:

; 515  :   else if ( gdata->etype & TRIPLE_EDGE ) width = ps_tripleedgewidth;

	test	al, 2
	je	SHORT $LN12@painter_ed
	fld	QWORD PTR _ps_tripleedgewidth
	jmp	SHORT $LN11@painter_ed
$LN12@painter_ed:

; 516  :   else width = ps_gridedgewidth; /* regular grid interior edge */

	fld	QWORD PTR _ps_gridedgewidth
$LN11@painter_ed:

; 517  :   t->width = (float)width;
; 518  : 
; 519  :   t->f_id = e_id;

	mov	ecx, DWORD PTR _e_id$[ebp]
	fstp	DWORD PTR [ebx+104]
	mov	DWORD PTR [ebx], ecx

; 520  :   t->color = t->ecolor[0] =  gdata->ecolor;

	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR [ebx+8], eax
	mov	DWORD PTR [ebx+4], eax

; 521  :   t->etype[0] = gdata->etype;

	mov	dx, WORD PTR [esi+124]

; 522  :   /* find extents */
; 523  :   find_bbox(t);

	push	ebx
	mov	WORD PTR [ebx+20], dx
	call	_find_bbox

; 524  : 
; 525  :   if ( painter_multiple_sweep_flag == MULTIPLE_SWEEP_PREP )

	mov	eax, DWORD PTR _painter_multiple_sweep_flag
	add	esp, 4
	cmp	eax, 2
	jne	SHORT $LN10@painter_ed

; 526  :   { sweep_prep_one(t);

	push	ebx
	call	_sweep_prep_one
	add	esp, 4
	pop	ebx
	pop	edi
	pop	esi

; 547  : } // end painter_edge()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@painter_ed:

; 527  :     return;
; 528  :   }
; 529  :   else if ( painter_multiple_sweep_flag == MULTIPLE_SWEEP_GO )

	cmp	eax, 3
	jne	SHORT $LN7@painter_ed

; 530  :   { if ( t->mins[SDIM-1] > sweep_top || t->mins[SDIM-1] <= sweep_bottom ) 

	mov	ecx, DWORD PTR _web+616
	fld	DWORD PTR [ebx+ecx*4+76]
	fcomp	QWORD PTR _sweep_top
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN83@painter_ed
	fld	DWORD PTR [ebx+ecx*4+76]
	fcomp	QWORD PTR _sweep_bottom
	fnstsw	ax
	test	ah, 65					; 00000041H

; 531  :       return;

	jnp	$LN83@painter_ed
$LN7@painter_ed:

; 532  :   }
; 533  : 
; 534  :   /* normal vector, closest to z axis */
; 535  :   dx = t->x[1][0] - t->x[0][0];

	fld	DWORD PTR [ebx+44]

; 536  :   dy = t->x[1][1] - t->x[0][1];
; 537  :   dz = t->x[1][2] - t->x[0][2];
; 538  :   t->normal[0] = (float)(dx*dz);

	lea	esi, DWORD PTR [ebx+68]
	fsub	DWORD PTR [ebx+32]

; 539  :   t->normal[1] = (float)(dy*dz);
; 540  :   t->normal[2] = -(float)(dx*dx+dy*dy);
; 541  :   mag = sqrt(dotf(t->normal,t->normal,3));

	push	3
	fld	DWORD PTR [ebx+48]
	push	esi
	fsub	DWORD PTR [ebx+36]
	push	esi
	fld	DWORD PTR [ebx+52]
	fsub	DWORD PTR [ebx+40]
	fld	ST(0)
	fmul	ST(0), ST(3)
	fstp	DWORD PTR [esi]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR [ebx+72]
	fmul	ST(0), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv1533[ebp]
	fld	DWORD PTR tv1533[ebp]
	fchs
	fstp	DWORD PTR [ebx+76]
	call	_dotf
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 542  :   if ( mag != 0.0 )

	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN86@painter_ed

; 543  :       for ( i = 0 ; i < 3; i++ ) t->normal[i] /= (float)mag;

	fstp	DWORD PTR tv1044[ebp]
	fld	DWORD PTR [esi]
	fld	DWORD PTR tv1044[ebp]
	fld	ST(0)
	fdivp	ST(2), ST(0)
	fxch	ST(1)
	fstp	DWORD PTR [esi]
	fld	DWORD PTR [ebx+72]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR [ebx+72]
	fdivr	DWORD PTR [ebx+76]
	fstp	DWORD PTR [ebx+76]
	jmp	SHORT $LN71@painter_ed
$LN86@painter_ed:
	fstp	ST(0)
$LN71@painter_ed:

; 544  : 
; 545  :   if ( setquadcode(t) == OUTOFBOX ) return;

	push	ebx
	call	_setquadcode
	add	esp, 4
	test	eax, eax
	je	SHORT $LN83@painter_ed

; 546  :   count++;

	inc	DWORD PTR _count
$LN83@painter_ed:
	pop	ebx
$LN44@painter_ed:

; 547  : } // end painter_edge()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_painter_edge ENDP
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	__real@3eb0c6f7a0b5ed8d
PUBLIC	__real@00000000
PUBLIC	__$ArrayPad$
PUBLIC	_painter_facet
EXTRN	_backcull_flag:DWORD
EXTRN	_vnormal:PROC
;	COMDAT __real@3f800000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3eb0c6f7a0b5ed8d
CONST	SEGMENT
__real@3eb0c6f7a0b5ed8d DQ 03eb0c6f7a0b5ed8dr	; 1e-006
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\painter.c
CONST	ENDS
;	COMDAT _painter_facet
_TEXT	SEGMENT
tv1932 = -580						; size = 4
tv1475 = -580						; size = 4
tv2073 = -576						; size = 4
tv2008 = -572						; size = 4
_i$ = -572						; size = 4
tv1922 = -568						; size = 4
_temp$89418 = -568					; size = 4
_fe$89370 = -568					; size = 4
_ggdata$89369 = -564					; size = 288
_b$ = -276						; size = 168
_normal$ = -108						; size = 48
_a$ = -60						; size = 56
__$ArrayPad$ = -4					; size = 4
_gdata$ = 8						; size = 4
_f_id$ = 12						; size = 4
_painter_facet PROC					; COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _gdata$[ebp]

; 560  :   int i,j;
; 561  :   REAL a[MAXCOORD+1],b[FACET_VERTS][MAXCOORD+1];
; 562  :   struct tsort *t;
; 563  :   REAL normal[MAXCOORD],mag;
; 564  : 
; 565  :   if ( gdata[0].color == UNSHOWN )

	cmp	DWORD PTR [ebx+104], -3			; fffffffdH
	push	esi
	push	edi
	jne	$LN40@painter_fa

; 566  :   { /* just do edges */
; 567  :     struct graphdata ggdata[2];
; 568  :     facetedge_id fe=NULLID;
; 569  :     if ( valid_id(f_id) )

	mov	eax, DWORD PTR _f_id$[ebp]
	xor	edx, edx
	mov	DWORD PTR _fe$89370[ebp], edx
	test	eax, 268435456				; 10000000H
	je	SHORT $LN82@painter_fa

; 570  :       fe = get_facet_fe(f_id);

	mov	esi, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN45@painter_fa
	xor	ecx, 134217728				; 08000000H
$LN45@painter_fa:
	mov	DWORD PTR _fe$89370[ebp], ecx
$LN82@painter_fa:

; 571  :     for ( i = 0 ; i < FACET_EDGES ; i++ )

	mov	DWORD PTR _i$[ebp], edx
$LL38@painter_fa:

; 572  :     { if ( (gdata[i].etype&EBITS) == INVISIBLE_EDGE ) continue;

	lea	eax, DWORD PTR [edx+edx*8]
	shl	eax, 4
	add	eax, ebx
	mov	ecx, 767				; 000002ffH
	test	WORD PTR [eax+124], cx
	je	$LN37@painter_fa

; 573  :       ggdata[0] = gdata[i]; 

	mov	esi, eax

; 574  :       ggdata[0].color = gdata[i].ecolor;

	mov	eax, DWORD PTR [eax+120]
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _ggdata$89369[ebp]
	rep movsd
	mov	DWORD PTR _ggdata$89369[ebp+104], eax

; 575  :       ggdata[1] = gdata[i==2 ? 0 : i+1];

	cmp	edx, 2
	jne	SHORT $LN43@painter_fa
	xor	eax, eax
	jmp	SHORT $LN44@painter_fa
$LN43@painter_fa:
	lea	eax, DWORD PTR [edx+1]
$LN44@painter_fa:
	lea	esi, DWORD PTR [eax+eax*8]

; 576  :       if ( valid_id(fe) )

	mov	eax, DWORD PTR _fe$89370[ebp]
	shl	esi, 4
	add	esi, ebx
	mov	ecx, 36					; 00000024H
	lea	edi, DWORD PTR _ggdata$89369[ebp+144]
	rep movsd
	test	eax, 268435456				; 10000000H
	je	SHORT $LN34@painter_fa

; 577  :       { painter_edge(ggdata,get_fe_edge(fe));

	mov	ecx, DWORD PTR _web+460
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+ecx]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	push	eax
	lea	eax, DWORD PTR _ggdata$89369[ebp]
	push	eax
	call	_painter_edge
	add	esp, 8

; 578  :         fe = get_next_edge(fe);

	test	DWORD PTR _fe$89370[ebp], 134217728	; 08000000H
	je	SHORT $LN52@painter_fa
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _fe$89370[ebp], eax
	jmp	SHORT $LN98@painter_fa
$LN52@painter_fa:
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [esi+eax]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _fe$89370[ebp], edx
	jmp	SHORT $LN98@painter_fa
$LN34@painter_fa:

; 579  :       }
; 580  :       else painter_edge(ggdata,NULLID);

	lea	eax, DWORD PTR _ggdata$89369[ebp]
	push	0
	push	eax
	call	_painter_edge
	add	esp, 8
$LN98@painter_fa:
	mov	edx, DWORD PTR _i$[ebp]
$LN37@painter_fa:

; 571  :     for ( i = 0 ; i < FACET_EDGES ; i++ )

	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, 3
	jl	$LL38@painter_fa
	pop	edi
	pop	esi
	pop	ebx

; 679  : } // end painter_facet()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@painter_fa:

; 581  :     }
; 582  :     return;
; 583  :   }
; 584  : 
; 585  :   if ( count >= maxcount )

	mov	esi, DWORD PTR _count
	mov	eax, DWORD PTR _maxcount
	cmp	esi, eax
	jb	SHORT $LN79@painter_fa

; 586  :   { trilist = (struct tsort *)temp_realloc((char*)trilist,
; 587  :          (maxcount+200)*sizeof(struct tsort));

	mov	ecx, DWORD PTR _trilist
	add	eax, 200				; 000000c8H
	imul	eax, 140				; 0000008cH
	push	587					; 0000024bH
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	push	eax
	push	ecx
	call	_kb_temp_realloc

; 588  :     maxcount += 200;

	mov	esi, DWORD PTR _count
	add	esp, 16					; 00000010H
	add	DWORD PTR _maxcount, 200		; 000000c8H
	mov	DWORD PTR _trilist, eax
$LN79@painter_fa:

; 591  :   t->flag = FACET | (gdata->flags&LABEL_FACET);

	mov	edx, DWORD PTR [ebx+136]
	imul	esi, 140				; 0000008cH
	add	esi, DWORD PTR _trilist

; 592  :   t->f_id = f_id;

	mov	eax, DWORD PTR _f_id$[ebp]
	mov	DWORD PTR [esi], eax
	and	edx, 8192				; 00002000H
	or	edx, 2
	mov	DWORD PTR [esi+28], edx

; 593  :   t->color = gdata[0].backcolor;  /* not sure why, but works */

	mov	ecx, DWORD PTR [ebx+108]
	mov	DWORD PTR [esi+4], ecx

; 594  :   for ( i = 0 ; i < FACET_EDGES ; i++ ) 
; 595  :   { t->ecolor[i] = gdata[i].ecolor;

	mov	edx, DWORD PTR [ebx+120]
	mov	DWORD PTR [esi+8], edx

; 596  :     t->etype[i] = gdata[i].etype;

	movzx	eax, WORD PTR [ebx+124]
	mov	WORD PTR [esi+20], ax

; 597  :     t->v_id[i] = gdata[i].v_id;

	mov	ecx, DWORD PTR [ebx+132]
	mov	DWORD PTR [esi+108], ecx
	mov	edx, DWORD PTR [ebx+264]
	mov	DWORD PTR [esi+12], edx
	movzx	eax, WORD PTR [ebx+268]
	mov	WORD PTR [esi+22], ax
	mov	ecx, DWORD PTR [ebx+276]
	mov	DWORD PTR [esi+112], ecx
	mov	edx, DWORD PTR [ebx+408]
	mov	DWORD PTR [esi+16], edx
	movzx	eax, WORD PTR [ebx+412]
	mov	WORD PTR [esi+24], ax
	mov	ecx, DWORD PTR [ebx+420]
	mov	DWORD PTR [esi+116], ecx

; 598  :   }
; 599  : 
; 600  :   /* accumulate list of triangles to display */
; 601  : 
; 602  :   for ( j = SDIM ; j < HOMDIM-1 ; j++ ) a[j] = 0.0;

	mov	ecx, DWORD PTR _HOMDIM
	mov	edx, DWORD PTR _web+616
	dec	ecx
	cmp	edx, ecx
	jge	SHORT $LN28@painter_fa

; 589  :   }
; 590  :   t = trilist + count;

	sub	ecx, edx
	add	ecx, ecx
	and	ecx, 1073741822				; 3ffffffeH
	lea	edi, DWORD PTR _a$[ebp+edx*8]
	xor	eax, eax
	rep stosd
$LN28@painter_fa:

; 603  :   for ( i = 0 ; i < FACET_VERTS ; i++ )

	xor	edi, edi
	lea	eax, DWORD PTR _b$[ebp]
	lea	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR tv1922[ebp], edi
	mov	DWORD PTR tv2008[ebp], eax
	mov	DWORD PTR tv2073[ebp], ecx
	jmp	SHORT $LN25@painter_fa
$LL80@painter_fa:
	mov	edx, DWORD PTR _web+616
$LN25@painter_fa:

; 604  :   {
; 605  :     for ( j = 0 ; (j < SDIM) && (j < HOMDIM-1) ; j++ ) 

	xor	eax, eax
	cmp	edx, 4
	jl	$LC71@painter_fa
	mov	edx, DWORD PTR _HOMDIM
	dec	edx
	npad	7
$LL85@painter_fa:
	cmp	eax, edx
	jge	$LN89@painter_fa

; 606  :       a[j] = gdata[i].x[j];

	add	edi, eax
	fld	QWORD PTR [ebx+edi*8]
	lea	ecx, DWORD PTR [ebx+edi*8]
	mov	DWORD PTR tv1932[ebp], ecx
	fstp	QWORD PTR _a$[ebp+eax*8]
	lea	ecx, DWORD PTR [eax+2]
	lea	edi, DWORD PTR [ecx-1]
	cmp	edi, edx
	jge	SHORT $LN86@painter_fa
	mov	edi, DWORD PTR tv1932[ebp]
	fld	QWORD PTR [edi+8]
	mov	edi, DWORD PTR tv1922[ebp]
	fstp	QWORD PTR _a$[ebp+eax*8+8]
	cmp	ecx, edx
	jge	SHORT $LN89@painter_fa
	lea	edi, DWORD PTR [edi+eax+3]
	fld	QWORD PTR [ebx+edi*8-8]
	mov	edi, DWORD PTR tv1922[ebp]
	inc	ecx
	fstp	QWORD PTR _a$[ebp+eax*8+16]
	cmp	ecx, edx
	jge	SHORT $LN89@painter_fa
	lea	ecx, DWORD PTR [edi+eax+3]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ecx, DWORD PTR _web+616
	fstp	QWORD PTR _a$[ebp+eax*8+24]
	add	eax, 4
	add	ecx, -3					; fffffffdH
	cmp	eax, ecx
	jl	SHORT $LL85@painter_fa
	mov	edx, DWORD PTR _web+616
$LC71@painter_fa:

; 604  :   {
; 605  :     for ( j = 0 ; (j < SDIM) && (j < HOMDIM-1) ; j++ ) 

	cmp	eax, edx
	jge	SHORT $LN89@painter_fa
$LC22@painter_fa:
	mov	ecx, DWORD PTR _HOMDIM
	dec	ecx
	cmp	eax, ecx
	jge	SHORT $LN89@painter_fa

; 606  :       a[j] = gdata[i].x[j];

	lea	ecx, DWORD PTR [edi+eax]
	fld	QWORD PTR [ebx+ecx*8]
	inc	eax
	fstp	QWORD PTR _a$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC22@painter_fa

; 604  :   {
; 605  :     for ( j = 0 ; (j < SDIM) && (j < HOMDIM-1) ; j++ ) 

	jmp	SHORT $LN89@painter_fa
$LN86@painter_fa:
	mov	edi, DWORD PTR tv1922[ebp]
$LN89@painter_fa:

; 607  :     a[HOMDIM-1] = 1.0;

	mov	eax, DWORD PTR _HOMDIM
	fld1

; 608  :     matvec_mul(view,a,b[i],HOMDIM,HOMDIM);  /* transform */

	mov	edx, DWORD PTR tv2008[ebp]
	fstp	QWORD PTR _a$[ebp+eax*8-8]
	mov	ecx, DWORD PTR _view
	push	eax
	push	eax
	push	edx
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	push	ecx
	call	_matvec_mul

; 609  :     if ( SDIM <= 2 )
; 610  :     { t->x[i][0] = (float)b[i][0];

	mov	eax, DWORD PTR tv2008[ebp]
	mov	ecx, DWORD PTR tv2073[ebp]
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _web+616, 2
	jg	SHORT $LN19@painter_fa
	fld	QWORD PTR [eax]
	fstp	DWORD PTR [ecx-4]

; 611  :       t->x[i][1] = (float)b[i][1];

	fld	QWORD PTR [eax+8]
	fstp	DWORD PTR [ecx]

; 612  :     }
; 613  :     else

	jmp	SHORT $LN24@painter_fa
$LN19@painter_fa:

; 614  :     { t->x[i][0] = (float)b[i][1];

	fld	QWORD PTR [eax+8]
	fstp	DWORD PTR [ecx-4]

; 615  :       t->x[i][1] = (float)b[i][2];

	fld	QWORD PTR [eax+16]
	fstp	DWORD PTR [ecx]

; 616  :       t->x[i][2] = (float)b[i][0];

	fld	QWORD PTR [eax]
	fstp	DWORD PTR [ecx+4]
$LN24@painter_fa:

; 603  :   for ( i = 0 ; i < FACET_VERTS ; i++ )

	add	DWORD PTR tv2008[ebp], 56		; 00000038H
	add	DWORD PTR tv2073[ebp], 12		; 0000000cH
	add	edi, 18					; 00000012H
	mov	DWORD PTR tv1922[ebp], edi
	cmp	edi, 54					; 00000036H
	jl	$LL80@painter_fa

; 617  :     }
; 618  :   } 
; 619  :   if ( SDIM <= 2 )

	cmp	DWORD PTR _web+616, 2
	fldz
	jg	SHORT $LN92@painter_fa

; 620  :   { t->normal[0] = t->normal[1] = 0.0;

	fst	DWORD PTR [esi+72]
	fst	DWORD PTR [esi+68]

; 621  :     t->normal[2] = 1.0;
; 622  :   }
; 623  :   else

	jmp	$LN99@painter_fa
$LN92@painter_fa:

; 624  :   { vnormal(b[0],b[1],b[2],normal); 

	lea	edx, DWORD PTR _normal$[ebp]
	fstp	ST(0)
	push	edx
	lea	eax, DWORD PTR _b$[ebp+112]
	push	eax
	lea	ecx, DWORD PTR _b$[ebp+56]
	push	ecx
	lea	edx, DWORD PTR _b$[ebp]
	push	edx
	call	_vnormal

; 625  :     mag = sqrt(SDIM_dot(normal,normal));

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _normal$[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	add	esp, 28					; 0000001cH
	call	__CIsqrt

; 626  :     if ( mag > 0.0 )

	fldz
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN96@painter_fa

; 627  :     { t->normal[0] = (float)(normal[1]/mag); 

	fld	QWORD PTR _normal$[ebp+8]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR [esi+68]

; 628  :       t->normal[1] = (float)(normal[2]/mag); 

	fld	QWORD PTR _normal$[ebp+16]
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR [esi+72]

; 629  :       t->normal[2] = (float)(normal[0]/mag);

	fdivr	QWORD PTR _normal$[ebp]
	fstp	DWORD PTR tv1475[ebp]
	fld	DWORD PTR tv1475[ebp]
	fst	DWORD PTR [esi+76]

; 630  :       if ( fabs(t->normal[2]) < 1e-6 ) t->normal[2] = 0.0; 

	fabs
	fcomp	QWORD PTR __real@3eb0c6f7a0b5ed8d
	fnstsw	ax
	fldz
	test	ah, 5
	jp	SHORT $LN13@painter_fa
	fst	DWORD PTR [esi+76]

; 631  :     } else

	jmp	SHORT $LN13@painter_fa
$LN96@painter_fa:

; 626  :     if ( mag > 0.0 )

	fstp	ST(0)

; 632  :     { t->normal[0] = 0.0f; 

	fldz
	fst	DWORD PTR [esi+68]

; 633  :       t->normal[1] = 0.0f; 

	fst	DWORD PTR [esi+72]
$LN99@painter_fa:

; 634  :       t->normal[2] = 1.0f;

	fld1
	fstp	DWORD PTR [esi+76]
$LN13@painter_fa:

; 635  :     }
; 636  :   }
; 637  :   if ( t->normal[2] > (float)0.0 ) /* frontward normal */

	fcomp	DWORD PTR [esi+76]
	fnstsw	ax
	test	ah, 5
	jp	$LN12@painter_fa

; 638  :   { int c;
; 639  :     vertex_id tv;
; 640  :     for ( i = 0 ; i < gdim ; i++ )

	mov	edx, DWORD PTR _gdim
	xor	edi, edi
	cmp	edx, 4
	jl	$LN83@painter_fa
	lea	ecx, DWORD PTR [edx-4]
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [esi+48]
	lea	edi, DWORD PTR [ecx*4]
$LL78@painter_fa:

; 641  :     { float temp = (float)t->x[1][i];

	fld	DWORD PTR [eax-4]

; 642  :       t->x[1][i] = t->x[2][i];

	add	eax, 16					; 00000010H
	dec	ecx
	fstp	DWORD PTR _temp$89418[ebp]
	fld	DWORD PTR [eax-8]
	fstp	DWORD PTR [eax-20]

; 643  :       t->x[2][i] = temp;

	fld	DWORD PTR _temp$89418[ebp]
	fstp	DWORD PTR [eax-8]
	fld	DWORD PTR [eax-16]
	fstp	DWORD PTR _temp$89418[ebp]
	fld	DWORD PTR [eax-4]
	fstp	DWORD PTR [eax-16]
	fld	DWORD PTR _temp$89418[ebp]
	fstp	DWORD PTR [eax-4]

; 644  :       t->normal[i] = -t->normal[i];

	fld	DWORD PTR [eax+8]
	fchs
	fstp	DWORD PTR [eax+8]
	fld	DWORD PTR [eax-12]
	fstp	DWORD PTR _temp$89418[ebp]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [eax-12]
	fld	DWORD PTR _temp$89418[ebp]
	fstp	DWORD PTR [eax]
	fld	DWORD PTR [eax+12]
	fchs
	fstp	DWORD PTR [eax+12]
	fld	DWORD PTR [eax-8]
	fstp	DWORD PTR _temp$89418[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	fstp	DWORD PTR [eax-8]
	fld	DWORD PTR _temp$89418[ebp]
	fstp	DWORD PTR [eax+4]
	fld	DWORD PTR [eax+16]
	fchs
	fstp	DWORD PTR [eax+16]
	jne	SHORT $LL78@painter_fa
$LN83@painter_fa:

; 638  :   { int c;
; 639  :     vertex_id tv;
; 640  :     for ( i = 0 ; i < gdim ; i++ )

	cmp	edi, edx
	jge	SHORT $LN76@painter_fa
	lea	eax, DWORD PTR [esi+edi*4+56]
	sub	edx, edi
	npad	5
$LC11@painter_fa:

; 641  :     { float temp = (float)t->x[1][i];

	fld	DWORD PTR [eax-12]
	add	eax, 4
	dec	edx
	fstp	DWORD PTR _temp$89418[ebp]

; 642  :       t->x[1][i] = t->x[2][i];

	fld	DWORD PTR [eax-4]
	fstp	DWORD PTR [eax-16]

; 643  :       t->x[2][i] = temp;

	fld	DWORD PTR _temp$89418[ebp]
	fstp	DWORD PTR [eax-4]

; 644  :       t->normal[i] = -t->normal[i];

	fld	DWORD PTR [eax+8]
	fchs
	fstp	DWORD PTR [eax+8]
	jne	SHORT $LC11@painter_fa
$LN76@painter_fa:

; 645  :     }
; 646  :     c = t->ecolor[0];

	mov	eax, DWORD PTR [esi+8]

; 647  :     t->ecolor[0] = t->ecolor[2];

	mov	ecx, DWORD PTR [esi+16]

; 648  :     t->ecolor[2] = c;

	mov	DWORD PTR [esi+16], eax

; 649  :     c = t->etype[0] ^ LABEL_REVERSED;

	movsx	eax, WORD PTR [esi+20]
	xor	eax, 16384				; 00004000H

; 650  :     t->etype[0] = t->etype[2] ^ LABEL_REVERSED;

	mov	edx, 16384				; 00004000H
	xor	dx, WORD PTR [esi+24]

; 651  :     t->etype[2] = (short)c;

	mov	WORD PTR [esi+24], ax

; 652  :     t->etype[1] ^= LABEL_REVERSED;

	mov	eax, 16384				; 00004000H
	xor	WORD PTR [esi+22], ax

; 653  :     t->color = gdata[0].color;
; 654  :     tv = t->v_id[1];

	mov	eax, DWORD PTR [esi+112]
	mov	WORD PTR [esi+20], dx

; 655  :     t->v_id[1] = t->v_id[2];

	mov	edx, DWORD PTR [esi+116]
	mov	DWORD PTR [esi+8], ecx
	mov	ecx, DWORD PTR [ebx+104]

; 656  :     t->v_id[2] = tv;
; 657  :     t->flag |= FLIPPED_FACET;

	or	DWORD PTR [esi+28], 4096		; 00001000H
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+112], edx
	mov	DWORD PTR [esi+116], eax

; 658  :   }
; 659  :   else

	jmp	SHORT $LN84@painter_fa
$LN12@painter_fa:

; 660  :   { 
; 661  :     if ( backcull_flag && (gdata[0].color == gdata[0].backcolor) ) return;

	cmp	DWORD PTR _backcull_flag, 0
	je	SHORT $LN84@painter_fa
	mov	eax, DWORD PTR [ebx+104]
	cmp	eax, DWORD PTR [ebx+108]
	je	SHORT $LN41@painter_fa
$LN84@painter_fa:

; 662  :   }
; 663  : 
; 664  :   /* find extents */
; 665  :   find_bbox(t);

	push	esi
	call	_find_bbox

; 666  : 
; 667  :   if ( painter_multiple_sweep_flag == MULTIPLE_SWEEP_PREP )

	mov	eax, DWORD PTR _painter_multiple_sweep_flag
	add	esp, 4
	cmp	eax, 2
	jne	SHORT $LN6@painter_fa

; 668  :   { sweep_prep_one(t);

	push	esi
	call	_sweep_prep_one
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 679  : } // end painter_facet()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@painter_fa:

; 669  :     return;
; 670  :   }
; 671  :   else if ( painter_multiple_sweep_flag == MULTIPLE_SWEEP_GO )

	cmp	eax, 3
	jne	SHORT $LN3@painter_fa

; 672  :   { if ( t->mins[SDIM-1] > sweep_top || t->mins[SDIM-1] <= sweep_bottom ) 

	mov	ecx, DWORD PTR _web+616
	fld	DWORD PTR [esi+ecx*4+76]
	fcomp	QWORD PTR _sweep_top
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN41@painter_fa
	fld	DWORD PTR [esi+ecx*4+76]
	fcomp	QWORD PTR _sweep_bottom
	fnstsw	ax
	test	ah, 65					; 00000041H

; 673  :       return;

	jnp	SHORT $LN41@painter_fa
$LN3@painter_fa:

; 674  :   }
; 675  : 
; 676  :   if ( setquadcode(t) == OUTOFBOX ) return;

	push	esi
	call	_setquadcode
	add	esp, 4
	test	eax, eax
	je	SHORT $LN41@painter_fa

; 677  : 
; 678  :   count++;

	inc	DWORD PTR _count
$LN41@painter_fa:

; 679  : } // end painter_facet()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_painter_facet ENDP
_TEXT	ENDS
PUBLIC	_get_quadindex
; Function compile flags: /Ogtp
;	COMDAT _get_quadindex
_TEXT	SEGMENT
_q$ = 8							; size = 4
_get_quadindex PROC					; COMDAT

; 1049 : { int inx,k;

	push	ebp
	mov	ebp, esp
	push	esi

; 1050 : 
; 1051 :   inx = 1;
; 1052 :   for ( k = 0 ; k < 2*maxquaddepth ; k++, q >>= 2 )

	mov	esi, DWORD PTR _maxquaddepth
	add	esi, esi
	xor	edx, edx
	push	edi
	mov	eax, 1
	test	esi, esi
	jle	SHORT $LN6@get_quadin
	mov	edi, DWORD PTR _q$[ebp]
	npad	5
$LL5@get_quadin:

; 1053 :   { int bits = q & 0x3;

	mov	ecx, edi
	and	ecx, 3

; 1054 :     if ( bits == 0 ) return inx;

	je	SHORT $LN6@get_quadin

; 1055 :     inx <<= 1;

	add	eax, eax

; 1056 :     if ( bits == 2 )

	cmp	ecx, 2
	jne	SHORT $LN4@get_quadin

; 1057 :       inx++;

	inc	eax
$LN4@get_quadin:

; 1050 : 
; 1051 :   inx = 1;
; 1052 :   for ( k = 0 ; k < 2*maxquaddepth ; k++, q >>= 2 )

	inc	edx
	shr	edi, 2
	cmp	edx, esi
	jl	SHORT $LL5@get_quadin
$LN6@get_quadin:
	pop	edi
	pop	esi

; 1058 :   }
; 1059 :   return inx;
; 1060 : } // end get_quadindex()

	pop	ebp
	ret	0
_get_quadindex ENDP
_TEXT	ENDS
PUBLIC	_qdepth_insert
; Function compile flags: /Ogtp
;	COMDAT _qdepth_insert
_TEXT	SEGMENT
_tc$ = 8						; size = 4
_qdepth_insert PROC					; COMDAT

; 1070 : { struct tsort *prev,*next;

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 1071 :   int qinx = get_quadindex(tc->quadcode);

	mov	esi, DWORD PTR _tc$[ebp]
	mov	eax, DWORD PTR [esi+120]
	push	edi
	push	eax
	call	_get_quadindex
	mov	ebx, eax
	add	esp, 4

; 1072 :   int sinx;
; 1073 : 
; 1074 :   /* take care of maxdepths of subtrees */
; 1075 :   sinx = qinx;

	mov	ecx, ebx

; 1076 :   while ( sinx && (tc->mins[2] < qtree[sinx].maxdepth) )

	test	ebx, ebx
	je	SHORT $LN19@qdepth_ins
	npad	3
$LL10@qdepth_ins:
	mov	edi, DWORD PTR _qtree
	fld	DWORD PTR [esi+88]
	fld	DWORD PTR [edi+ecx*8+4]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN20@qdepth_ins

; 1077 :   { qtree[sinx].maxdepth = tc->mins[2];

	fld	DWORD PTR [esi+88]
	fstp	DWORD PTR [edi+ecx*8+4]

; 1078 :     sinx >>= 1;

	sar	ecx, 1
	jne	SHORT $LL10@qdepth_ins
$LN19@qdepth_ins:

; 1076 :   while ( sinx && (tc->mins[2] < qtree[sinx].maxdepth) )

	mov	edi, DWORD PTR _qtree
$LN20@qdepth_ins:

; 1079 :   }
; 1080 : 
; 1081 :   prev = NULL;
; 1082 :   for ( next=qtree[qinx].depthhead; next != NULL; prev=next, next=next->next )

	mov	ecx, DWORD PTR [edi+ebx*8]
	xor	edx, edx
	test	ecx, ecx
	je	SHORT $LN21@qdepth_ins
$LL8@qdepth_ins:

; 1083 :   {
; 1084 :     if ( tc->mins[2] < next->mins[2] )

	fld	DWORD PTR [esi+88]
	fld	DWORD PTR [ecx+88]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN15@qdepth_ins

; 1079 :   }
; 1080 : 
; 1081 :   prev = NULL;
; 1082 :   for ( next=qtree[qinx].depthhead; next != NULL; prev=next, next=next->next )

	mov	edx, ecx
	mov	ecx, DWORD PTR [ecx+132]
	test	ecx, ecx
	jne	SHORT $LL8@qdepth_ins

; 1091 :       goto qdepth_insert_exit;
; 1092 :     }
; 1093 :   }
; 1094 :   /* at end of list */
; 1095 :   if ( prev ) prev->next = tc;

	test	edx, edx
	je	SHORT $LN21@qdepth_ins
	mov	DWORD PTR [edx+132], esi
	jmp	SHORT $LN1@qdepth_ins
$LN15@qdepth_ins:

; 1085 :     { tc->next = next;

	mov	DWORD PTR [esi+132], ecx

; 1086 :       tc->prev = prev;

	mov	DWORD PTR [esi+128], edx

; 1087 :       if ( prev )

	test	edx, edx
	je	SHORT $LN4@qdepth_ins

; 1088 :         prev->next = tc;

	mov	DWORD PTR [edx+132], esi
	pop	edi

; 1090 :       next->prev = tc;

	mov	DWORD PTR [ecx+128], esi
	pop	esi
	pop	ebx

; 1099 : 
; 1100 : qdepth_insert_exit:;
; 1101 : } // end qdepth_insert()

	pop	ebp
	ret	0
$LN4@qdepth_ins:

; 1089 :       else qtree[qinx].depthhead = tc;

	mov	edx, DWORD PTR _qtree
	mov	DWORD PTR [edx+ebx*8], esi
	pop	edi

; 1090 :       next->prev = tc;

	mov	DWORD PTR [ecx+128], esi
	pop	esi
	pop	ebx

; 1099 : 
; 1100 : qdepth_insert_exit:;
; 1101 : } // end qdepth_insert()

	pop	ebp
	ret	0
$LN21@qdepth_ins:

; 1096 :   else qtree[qinx].depthhead = tc;

	mov	DWORD PTR [edi+ebx*8], esi
$LN1@qdepth_ins:
	pop	edi

; 1097 :   tc->next = NULL;

	mov	DWORD PTR [esi+132], 0

; 1098 :   tc->prev = prev;

	mov	DWORD PTR [esi+128], edx
	pop	esi
$qdepth_insert_exit$89660:
	pop	ebx

; 1099 : 
; 1100 : qdepth_insert_exit:;
; 1101 : } // end qdepth_insert()

	pop	ebp
	ret	0
_qdepth_insert ENDP
_TEXT	ENDS
PUBLIC	__real@f149f2ca
PUBLIC	__real@7149f2ca
PUBLIC	_newell_split
;	COMDAT __real@f149f2ca
CONST	SEGMENT
__real@f149f2ca DD 0f149f2car			; -1e+030
CONST	ENDS
;	COMDAT __real@7149f2ca
CONST	SEGMENT
__real@7149f2ca DD 07149f2car			; 1e+030
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _newell_split
_TEXT	SEGMENT
_tmp$89785 = -192					; size = 140
_tmp$89741 = -192					; size = 140
_t$89709 = -192						; size = 140
_d2$ = -52						; size = 8
_d1$ = -44						; size = 8
_d0$ = -36						; size = 8
tv24569 = -28						; size = 4
tv22785 = -28						; size = 4
tv9526 = -24						; size = 8
tv9443 = -24						; size = 8
_db$ = -24						; size = 8
_retval$ = -20						; size = 4
tv22780 = -16						; size = 4
tv11137 = -16						; size = 4
tv24952 = -12						; size = 4
tv23689 = -12						; size = 4
tv23670 = -12						; size = 4
tv23653 = -12						; size = 4
tv23634 = -12						; size = 4
tv23613 = -12						; size = 4
tv23598 = -12						; size = 4
tv23577 = -12						; size = 4
tv23558 = -12						; size = 4
tv843 = -12						; size = 4
tv24598 = -8						; size = 4
tv23922 = -8						; size = 4
tv23515 = -8						; size = 4
tv18845 = -8						; size = 4
tv18826 = -8						; size = 4
tv18805 = -8						; size = 4
tv18788 = -8						; size = 4
tv17704 = -8						; size = 4
tv17683 = -8						; size = 4
tv17662 = -8						; size = 4
tv17641 = -8						; size = 4
tv16463 = -8						; size = 4
tv16444 = -8						; size = 4
tv16423 = -8						; size = 4
tv16374 = -8						; size = 4
_e$89755 = -8						; size = 2
_e$89746 = -8						; size = 2
tv12264 = -4						; size = 4
tv9265 = -4						; size = 4
tv413 = -4						; size = 4
tv390 = -4						; size = 4
tv367 = -4						; size = 4
tv344 = -4						; size = 4
tv238 = -4						; size = 4
tv215 = -4						; size = 4
tv192 = -4						; size = 4
tv169 = -4						; size = 4
_ta$ = 8						; size = 4
tv24791 = 12						; size = 4
tv24299 = 12						; size = 4
tv24124 = 12						; size = 4
tv19071 = 12						; size = 4
tv17961 = 12						; size = 4
tv16690 = 12						; size = 4
_temp$89760 = 12					; size = 4
_temp$89751 = 12					; size = 4
_mid$89686 = 12						; size = 4
_i$ = 12						; size = 4
_tmpspot$ = 12						; size = 4
_tb$ = 12						; size = 4
_tc$ = 16						; size = 4
_td$ = 20						; size = 4
_newell_split PROC					; COMDAT

; 1118 : { 

	push	ebp
	mov	ebp, esp

; 1119 :   int i;
; 1120 :   REAL d0,d1,d2,db;
; 1121 :   int retval;
; 1122 :   size_t tmpspot;
; 1123 : 
; 1124 :   backstamp++; /* clear loop indications */

	inc	DWORD PTR _backstamp

; 1125 : 
; 1126 :   if ( (tb->flag & 0xF) == EDGE )

	mov	eax, DWORD PTR _tb$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	sub	esp, 192				; 000000c0H
	push	ebx

; 1127 :   { struct tsort *t;
; 1128 :     if ( (ta->flag & 0xF) == EDGE )

	mov	ebx, DWORD PTR _ta$[ebp]
	and	cl, 15					; 0000000fH
	push	esi
	push	edi
	cmp	cl, 1
	jne	$LN84@newell_spl
	mov	edx, DWORD PTR [ebx+28]
	and	dl, 15					; 0000000fH
	cmp	dl, cl
	jne	$LN73@newell_spl

; 1129 :     { /* cut first edge in half */
; 1130 :       tmpspot = tc->spot; *tc = *ta; tc->spot = tmpspot;

	mov	eax, DWORD PTR _tc$[ebp]

; 1131 :       for ( i = 0 ; i < gdim ; i++ )

	fld	QWORD PTR __real@3fe0000000000000
	mov	edx, DWORD PTR [eax+136]
	mov	ecx, 35					; 00000023H
	mov	esi, ebx
	mov	edi, eax
	rep movsd
	xor	edi, edi
	cmp	DWORD PTR _gdim, 4
	mov	DWORD PTR [eax+136], edx
	jl	$LC132@newell_spl

; 1129 :     { /* cut first edge in half */
; 1130 :       tmpspot = tc->spot; *tc = *ta; tc->spot = tmpspot;

	mov	esi, DWORD PTR _gdim
	add	esi, -4					; fffffffcH
	lea	edx, DWORD PTR [eax+36]
	sub	eax, ebx
	shr	esi, 2
	inc	esi
	lea	ecx, DWORD PTR [ebx+32]
	mov	DWORD PTR tv11137[ebp], eax
	lea	edi, DWORD PTR [esi*4]

; 1131 :       for ( i = 0 ; i < gdim ; i++ )

$LN141@newell_spl:

; 1132 :       { float mid = (ta->x[0][i] + ta->x[1][i])/2; 

	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [ecx+12]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _mid$89686[ebp]

; 1133 :         if ( ta->x[0][2] > ta->x[1][2] )  /* ta is back half */

	fld	DWORD PTR [ebx+40]
	fld	DWORD PTR [ebx+52]
	fcompp
	fnstsw	ax

; 1134 :         { ta->x[0][i] = mid; tc->x[1][i] = mid; }

	fld	DWORD PTR _mid$89686[ebp]
	test	ah, 5
	jp	SHORT $LN133@newell_spl
	fst	DWORD PTR [ecx]
	fstp	DWORD PTR [edx+8]
	jmp	SHORT $LN134@newell_spl
$LN133@newell_spl:

; 1135 :         else { ta->x[1][i] = mid; tc->x[0][i] = mid; }

	mov	eax, DWORD PTR tv11137[ebp]
	fst	DWORD PTR [ecx+12]
	fstp	DWORD PTR [eax+ecx]
$LN134@newell_spl:

; 1132 :       { float mid = (ta->x[0][i] + ta->x[1][i])/2; 

	fld	DWORD PTR [ecx+16]
	fadd	DWORD PTR [ecx+4]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _mid$89686[ebp]

; 1133 :         if ( ta->x[0][2] > ta->x[1][2] )  /* ta is back half */

	fld	DWORD PTR [ebx+40]
	fld	DWORD PTR [ebx+52]
	fcompp
	fnstsw	ax

; 1134 :         { ta->x[0][i] = mid; tc->x[1][i] = mid; }

	fld	DWORD PTR _mid$89686[ebp]
	test	ah, 5
	jp	SHORT $LN135@newell_spl
	fst	DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+12]
	jmp	SHORT $LN136@newell_spl
$LN135@newell_spl:

; 1135 :         else { ta->x[1][i] = mid; tc->x[0][i] = mid; }

	fst	DWORD PTR [ecx+16]
	fstp	DWORD PTR [edx]
$LN136@newell_spl:

; 1132 :       { float mid = (ta->x[0][i] + ta->x[1][i])/2; 

	fld	DWORD PTR [ecx+8]
	fadd	DWORD PTR [ecx+20]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _mid$89686[ebp]

; 1133 :         if ( ta->x[0][2] > ta->x[1][2] )  /* ta is back half */

	fld	DWORD PTR [ebx+40]
	fld	DWORD PTR [ebx+52]
	fcompp
	fnstsw	ax

; 1134 :         { ta->x[0][i] = mid; tc->x[1][i] = mid; }

	fld	DWORD PTR _mid$89686[ebp]
	test	ah, 5
	jp	SHORT $LN137@newell_spl
	fst	DWORD PTR [ecx+8]
	fstp	DWORD PTR [edx+16]
	jmp	SHORT $LN138@newell_spl
$LN137@newell_spl:

; 1135 :         else { ta->x[1][i] = mid; tc->x[0][i] = mid; }

	fst	DWORD PTR [ecx+20]
	fstp	DWORD PTR [edx+4]
$LN138@newell_spl:

; 1132 :       { float mid = (ta->x[0][i] + ta->x[1][i])/2; 

	fld	DWORD PTR [ecx+24]
	fadd	DWORD PTR [ecx+12]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _mid$89686[ebp]

; 1133 :         if ( ta->x[0][2] > ta->x[1][2] )  /* ta is back half */

	fld	DWORD PTR [ebx+40]
	fld	DWORD PTR [ebx+52]
	fcompp
	fnstsw	ax

; 1134 :         { ta->x[0][i] = mid; tc->x[1][i] = mid; }

	fld	DWORD PTR _mid$89686[ebp]
	test	ah, 5
	jp	SHORT $LN139@newell_spl
	fst	DWORD PTR [ecx+12]
	fstp	DWORD PTR [edx+20]
	jmp	SHORT $LN140@newell_spl
$LN139@newell_spl:

; 1135 :         else { ta->x[1][i] = mid; tc->x[0][i] = mid; }

	fst	DWORD PTR [ecx+24]
	fstp	DWORD PTR [edx+8]
$LN140@newell_spl:

; 1129 :     { /* cut first edge in half */
; 1130 :       tmpspot = tc->spot; *tc = *ta; tc->spot = tmpspot;

	add	ecx, 16					; 00000010H
	add	edx, 16					; 00000010H
	dec	esi
	jne	$LN141@newell_spl
	mov	eax, DWORD PTR _tc$[ebp]
$LC132@newell_spl:

; 1131 :       for ( i = 0 ; i < gdim ; i++ )

	cmp	edi, DWORD PTR _gdim
	jge	SHORT $LN298@newell_spl
	mov	edx, DWORD PTR _gdim
	lea	esi, DWORD PTR [eax+edi*4+32]
	sub	eax, ebx
	lea	ecx, DWORD PTR [ebx+edi*4+44]
	sub	edx, edi
	mov	DWORD PTR tv11137[ebp], eax
	mov	edi, eax
$LC82@newell_spl:

; 1132 :       { float mid = (ta->x[0][i] + ta->x[1][i])/2; 

	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [ecx-12]
	fmul	ST(0), ST(1)
	fstp	DWORD PTR _mid$89686[ebp]

; 1133 :         if ( ta->x[0][2] > ta->x[1][2] )  /* ta is back half */

	fld	DWORD PTR [ebx+40]
	fld	DWORD PTR [ebx+52]
	fcompp
	fnstsw	ax

; 1134 :         { ta->x[0][i] = mid; tc->x[1][i] = mid; }

	fld	DWORD PTR _mid$89686[ebp]
	test	ah, 5
	jp	SHORT $LN79@newell_spl
	fst	DWORD PTR [ecx-12]
	fstp	DWORD PTR [edi+ecx]
	jmp	SHORT $LN81@newell_spl
$LN79@newell_spl:

; 1135 :         else { ta->x[1][i] = mid; tc->x[0][i] = mid; }

	fst	DWORD PTR [ecx]
	fstp	DWORD PTR [esi]
$LN81@newell_spl:

; 1131 :       for ( i = 0 ; i < gdim ; i++ )

	add	ecx, 4
	add	esi, 4
	dec	edx
	jne	SHORT $LC82@newell_spl
	mov	eax, DWORD PTR _tc$[ebp]
$LN298@newell_spl:

; 1136 :       }
; 1137 :       for ( i = 0 ; i < gdim ; i++ )

	mov	esi, DWORD PTR _gdim
	fstp	ST(0)
	mov	DWORD PTR _i$[ebp], 0
	cmp	esi, 4
	jl	$LC143@newell_spl
	add	esi, -4					; fffffffcH

; 1141 :         tc->maxs[i] = (tc->x[0][i]>tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	mov	edi, ebx
	sub	edi, eax
	shr	esi, 2
	inc	esi
	lea	ecx, DWORD PTR [eax+32]
	lea	eax, DWORD PTR [esi*4]
	lea	edx, DWORD PTR [ebx+36]
	mov	DWORD PTR _i$[ebp], eax
$LL176@newell_spl:

; 1138 :       { ta->mins[i] = (ta->x[0][i]<ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edi+ecx]
	fld	DWORD PTR [edx+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN144@newell_spl
	fld	DWORD PTR [edi+ecx]
	jmp	SHORT $LN502@newell_spl
$LN144@newell_spl:
	fld	DWORD PTR [edx+8]
$LN502@newell_spl:
	fstp	DWORD PTR tv169[ebp]
	fld	DWORD PTR tv169[ebp]
	fstp	DWORD PTR [ecx+edi+48]

; 1139 :         tc->mins[i] = (tc->x[0][i]<tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN146@newell_spl
	fld	DWORD PTR [ecx]
	jmp	SHORT $LN503@newell_spl
$LN146@newell_spl:
	fld	DWORD PTR [ecx+12]
$LN503@newell_spl:
	fstp	DWORD PTR tv192[ebp]
	fld	DWORD PTR tv192[ebp]
	fstp	DWORD PTR [ecx+48]

; 1140 :         ta->maxs[i] = (ta->x[0][i]>ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edi+ecx]
	fld	DWORD PTR [edx+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN148@newell_spl
	fld	DWORD PTR [edi+ecx]
	jmp	SHORT $LN504@newell_spl
$LN148@newell_spl:
	fld	DWORD PTR [edx+8]
$LN504@newell_spl:
	fstp	DWORD PTR tv215[ebp]
	fld	DWORD PTR tv215[ebp]
	fstp	DWORD PTR [edx+56]

; 1141 :         tc->maxs[i] = (tc->x[0][i]>tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN150@newell_spl
	fld	DWORD PTR [ecx]
	jmp	SHORT $LN505@newell_spl
$LN150@newell_spl:
	fld	DWORD PTR [ecx+12]
$LN505@newell_spl:
	fstp	DWORD PTR tv238[ebp]
	fld	DWORD PTR tv238[ebp]
	fstp	DWORD PTR [ecx+60]
	fld	DWORD PTR [edx]
	fld	DWORD PTR [edx+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN152@newell_spl

; 1138 :       { ta->mins[i] = (ta->x[0][i]<ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edx]
	jmp	SHORT $LN506@newell_spl
$LN152@newell_spl:
	fld	DWORD PTR [edx+12]
$LN506@newell_spl:
	fstp	DWORD PTR tv169[ebp]
	fld	DWORD PTR tv169[ebp]
	fstp	DWORD PTR [edx+48]

; 1139 :         tc->mins[i] = (tc->x[0][i]<tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx+4]
	fld	DWORD PTR [ecx+16]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN154@newell_spl
	fld	DWORD PTR [ecx+4]
	jmp	SHORT $LN507@newell_spl
$LN154@newell_spl:
	fld	DWORD PTR [ecx+16]
$LN507@newell_spl:
	fstp	DWORD PTR tv192[ebp]
	fld	DWORD PTR tv192[ebp]
	fstp	DWORD PTR [ecx+52]

; 1140 :         ta->maxs[i] = (ta->x[0][i]>ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edx]
	fld	DWORD PTR [edx+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN156@newell_spl
	fld	DWORD PTR [edx]
	jmp	SHORT $LN508@newell_spl
$LN156@newell_spl:
	fld	DWORD PTR [edx+12]
$LN508@newell_spl:
	fstp	DWORD PTR tv215[ebp]
	fld	DWORD PTR tv215[ebp]
	fstp	DWORD PTR [edx+60]

; 1141 :         tc->maxs[i] = (tc->x[0][i]>tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx+4]
	fld	DWORD PTR [ecx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN158@newell_spl
	fld	DWORD PTR [ecx+4]
	jmp	SHORT $LN509@newell_spl
$LN158@newell_spl:
	fld	DWORD PTR [ecx+16]
$LN509@newell_spl:
	fstp	DWORD PTR tv238[ebp]
	fld	DWORD PTR tv238[ebp]
	fstp	DWORD PTR [ecx+64]
	fld	DWORD PTR [edx+4]
	fld	DWORD PTR [edx+16]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN160@newell_spl

; 1138 :       { ta->mins[i] = (ta->x[0][i]<ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edx+4]
	jmp	SHORT $LN510@newell_spl
$LN160@newell_spl:
	fld	DWORD PTR [edx+16]
$LN510@newell_spl:
	fstp	DWORD PTR tv169[ebp]
	fld	DWORD PTR tv169[ebp]
	fstp	DWORD PTR [edx+52]

; 1139 :         tc->mins[i] = (tc->x[0][i]<tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx+8]
	fld	DWORD PTR [ecx+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN162@newell_spl
	fld	DWORD PTR [ecx+8]
	jmp	SHORT $LN511@newell_spl
$LN162@newell_spl:
	fld	DWORD PTR [ecx+20]
$LN511@newell_spl:
	fstp	DWORD PTR tv192[ebp]
	fld	DWORD PTR tv192[ebp]
	fstp	DWORD PTR [ecx+56]

; 1140 :         ta->maxs[i] = (ta->x[0][i]>ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edx+4]
	fld	DWORD PTR [edx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN164@newell_spl
	fld	DWORD PTR [edx+4]
	jmp	SHORT $LN512@newell_spl
$LN164@newell_spl:
	fld	DWORD PTR [edx+16]
$LN512@newell_spl:
	fstp	DWORD PTR tv215[ebp]
	fld	DWORD PTR tv215[ebp]
	fstp	DWORD PTR [edx+64]

; 1141 :         tc->maxs[i] = (tc->x[0][i]>tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx+8]
	fld	DWORD PTR [ecx+20]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN166@newell_spl
	fld	DWORD PTR [ecx+8]
	jmp	SHORT $LN513@newell_spl
$LN166@newell_spl:
	fld	DWORD PTR [ecx+20]
$LN513@newell_spl:
	fstp	DWORD PTR tv238[ebp]
	fld	DWORD PTR tv238[ebp]
	fstp	DWORD PTR [ecx+68]
	fld	DWORD PTR [edx+8]
	fld	DWORD PTR [edx+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN168@newell_spl

; 1138 :       { ta->mins[i] = (ta->x[0][i]<ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edx+8]
	jmp	SHORT $LN514@newell_spl
$LN168@newell_spl:
	fld	DWORD PTR [edx+20]
$LN514@newell_spl:
	fstp	DWORD PTR tv169[ebp]
	fld	DWORD PTR tv169[ebp]
	fstp	DWORD PTR [edx+56]

; 1139 :         tc->mins[i] = (tc->x[0][i]<tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx+12]
	fld	DWORD PTR [ecx+24]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN170@newell_spl
	fld	DWORD PTR [ecx+12]
	jmp	SHORT $LN515@newell_spl
$LN170@newell_spl:
	fld	DWORD PTR [ecx+24]
$LN515@newell_spl:
	fstp	DWORD PTR tv192[ebp]
	fld	DWORD PTR tv192[ebp]
	fstp	DWORD PTR [ecx+60]

; 1140 :         ta->maxs[i] = (ta->x[0][i]>ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edx+8]
	fld	DWORD PTR [edx+20]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN172@newell_spl
	fld	DWORD PTR [edx+8]
	jmp	SHORT $LN516@newell_spl
$LN172@newell_spl:
	fld	DWORD PTR [edx+20]
$LN516@newell_spl:
	fstp	DWORD PTR tv215[ebp]
	fld	DWORD PTR tv215[ebp]
	fstp	DWORD PTR [edx+68]

; 1141 :         tc->maxs[i] = (tc->x[0][i]>tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx+12]
	fld	DWORD PTR [ecx+24]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN174@newell_spl
	fld	DWORD PTR [ecx+12]
	jmp	SHORT $LN517@newell_spl
$LN174@newell_spl:
	fld	DWORD PTR [ecx+24]
$LN517@newell_spl:
	fstp	DWORD PTR tv238[ebp]
	add	ecx, 16					; 00000010H
	fld	DWORD PTR tv238[ebp]
	add	edx, 16					; 00000010H
	dec	esi
	fstp	DWORD PTR [ecx+56]
	jne	$LL176@newell_spl

; 1136 :       }
; 1137 :       for ( i = 0 ; i < gdim ; i++ )

	mov	eax, DWORD PTR _tc$[ebp]
	mov	esi, DWORD PTR _gdim
$LC143@newell_spl:
	cmp	DWORD PTR _i$[ebp], esi
	jge	$LN142@newell_spl
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edi, ebx
	mov	esi, eax
	lea	edx, DWORD PTR [eax+ecx*4+32]
	lea	ecx, DWORD PTR [ebx+ecx*4+44]
	sub	esi, ebx
	mov	ebx, DWORD PTR _gdim
	sub	edi, eax
	sub	ebx, DWORD PTR _i$[ebp]
	npad	7
$LC77@newell_spl:

; 1138 :       { ta->mins[i] = (ta->x[0][i]<ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [ecx-12]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN87@newell_spl
	fld	DWORD PTR [ecx-12]
	jmp	SHORT $LN518@newell_spl
$LN87@newell_spl:
	fld	DWORD PTR [ecx]
$LN518@newell_spl:
	fstp	DWORD PTR tv169[ebp]
	fld	DWORD PTR tv169[ebp]
	fstp	DWORD PTR [edi+edx+48]

; 1139 :         tc->mins[i] = (tc->x[0][i]<tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [edx]
	fld	DWORD PTR [esi+ecx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN89@newell_spl
	fld	DWORD PTR [edx]
	jmp	SHORT $LN519@newell_spl
$LN89@newell_spl:
	fld	DWORD PTR [esi+ecx]
$LN519@newell_spl:
	fstp	DWORD PTR tv192[ebp]
	fld	DWORD PTR tv192[ebp]
	fstp	DWORD PTR [edx+48]

; 1140 :         ta->maxs[i] = (ta->x[0][i]>ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [ecx-12]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN91@newell_spl
	fld	DWORD PTR [ecx-12]
	jmp	SHORT $LN520@newell_spl
$LN91@newell_spl:
	fld	DWORD PTR [ecx]
$LN520@newell_spl:
	fstp	DWORD PTR tv215[ebp]
	fld	DWORD PTR tv215[ebp]
	fstp	DWORD PTR [ecx+48]

; 1141 :         tc->maxs[i] = (tc->x[0][i]>tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [edx]
	fld	DWORD PTR [esi+ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN93@newell_spl
	fld	DWORD PTR [edx]
	jmp	SHORT $LN521@newell_spl
$LN93@newell_spl:
	fld	DWORD PTR [esi+ecx]
$LN521@newell_spl:
	fstp	DWORD PTR tv238[ebp]
	add	edx, 4
	fld	DWORD PTR tv238[ebp]
	add	ecx, 4
	dec	ebx
	fstp	DWORD PTR [edx+56]
	jne	$LC77@newell_spl

; 1136 :       }
; 1137 :       for ( i = 0 ; i < gdim ; i++ )

	mov	eax, DWORD PTR _tc$[ebp]
$LN142@newell_spl:

; 1142 :       }
; 1143 :       /* find_bbox(tc); */
; 1144 :       if ( setquadcode(tc) == INTHEBOX )

	push	eax
	call	_setquadcode
	add	esp, 4
	cmp	eax, 1
	jne	SHORT $LN74@newell_spl

; 1145 :       { qdepth_insert(tc);

	mov	ecx, DWORD PTR _tc$[ebp]
	push	ecx
	call	_qdepth_insert
	add	esp, 4
	pop	edi
	pop	esi

; 1146 :         return 1;

	mov	eax, 1
	pop	ebx

; 1361 : } // end newell_split()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@newell_spl:

; 1147 :       }
; 1148 :       else { tc->flag = 0; return 0; }

	mov	edx, DWORD PTR _tc$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+28], 0
	xor	eax, eax
	pop	ebx

; 1361 : } // end newell_split()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@newell_spl:

; 1149 :     }
; 1150 :     t = ta; ta = tb; tb = t; /* swap so edge first */

	mov	eax, ebx
	mov	ebx, DWORD PTR _tb$[ebp]
	mov	DWORD PTR _tb$[ebp], eax
$LN84@newell_spl:

; 1151 :   }
; 1152 : 
; 1153 :   if ( (ta->flag & 0xF) == EDGE ) /* tb assumed to be facet */

	mov	eax, DWORD PTR [ebx+28]

; 1154 :   {
; 1155 :     db = dotf(tb->normal,tb->x[0],gdim);

	mov	ecx, DWORD PTR _gdim
	and	al, 15					; 0000000fH
	cmp	al, 1
	mov	eax, DWORD PTR _tb$[ebp]
	push	ecx
	lea	esi, DWORD PTR [eax+68]
	jne	$LN62@newell_spl
	add	eax, 32					; 00000020H
	push	eax
	push	esi
	call	_dotf
	fstp	QWORD PTR _db$[ebp]

; 1156 :     d0 = dotf(tb->normal,ta->x[0],gdim); 

	mov	edx, DWORD PTR _gdim
	push	edx
	lea	eax, DWORD PTR [ebx+32]
	push	eax
	push	esi
	call	_dotf
	fstp	QWORD PTR _d0$[ebp]

; 1157 :     d1 = dotf(tb->normal,ta->x[1],gdim); 

	mov	eax, DWORD PTR _gdim
	push	eax
	lea	ecx, DWORD PTR [ebx+44]
	push	ecx
	push	esi
	call	_dotf

; 1158 : 
; 1159 :     /* fill in fragment info */
; 1160 :     tmpspot = tc->spot; *tc = *ta; tc->spot = tmpspot;
; 1161 :     for ( i = 0 ; i < gdim ; i++ )

	fld	QWORD PTR _db$[ebp]
	mov	edi, DWORD PTR _tc$[ebp]
	mov	eax, DWORD PTR [edi+136]
	mov	edx, DWORD PTR _tc$[ebp]
	mov	ecx, 35					; 00000023H
	mov	esi, ebx
	add	esp, 36					; 00000024H
	cmp	DWORD PTR _gdim, 4
	rep movsd
	mov	DWORD PTR [edx+136], eax
	mov	DWORD PTR _i$[ebp], 0
	jl	$LC178@newell_spl
	mov	esi, DWORD PTR _gdim
	fld	ST(0)
	fld	QWORD PTR _d0$[ebp]
	mov	eax, edx
	fsub	ST(1), ST(0)
	add	esi, -4					; fffffffcH
	mov	edi, eax
	fld	ST(3)
	shr	esi, 2
	fsub	ST(0), ST(3)
	sub	edi, ebx
	fld	ST(4)
	inc	esi
	fsubrp	ST(2), ST(0)
	lea	edx, DWORD PTR [eax+48]
	lea	eax, DWORD PTR [esi*4]
	lea	ecx, DWORD PTR [ebx+32]
	mov	DWORD PTR _i$[ebp], eax
$LN187@newell_spl:

; 1162 :     { double mid = (((db-d0)*ta->x[1][i] + (d1-db)*ta->x[0][i])/(d1-d0));

	fld	DWORD PTR [ecx]
	fmul	ST(0), ST(1)
	fld	DWORD PTR [ecx+12]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(2)

; 1163 :       if ( ta->x[0][2] < ta->x[1][2] ) /* keep ta as back part */

	fld	DWORD PTR [ebx+40]
	fld	DWORD PTR [ebx+52]
	fcompp
	fnstsw	ax

; 1164 :         ta->x[1][i] = tc->x[0][i] = (float)mid;

	fstp	DWORD PTR tv9265[ebp]
	fld	DWORD PTR tv9265[ebp]
	test	ah, 65					; 00000041H
	jne	SHORT $LN179@newell_spl
	fst	DWORD PTR [edi+ecx]
	fstp	DWORD PTR [ecx+12]
	jmp	SHORT $LN180@newell_spl
$LN179@newell_spl:

; 1165 :       else  ta->x[0][i] = tc->x[1][i] = (float)mid;

	fst	DWORD PTR [edx-4]
	fstp	DWORD PTR [ecx]
$LN180@newell_spl:

; 1162 :     { double mid = (((db-d0)*ta->x[1][i] + (d1-db)*ta->x[0][i])/(d1-d0));

	fld	DWORD PTR [ecx+16]
	fmul	ST(0), ST(3)
	fld	DWORD PTR [ecx+4]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(2)

; 1163 :       if ( ta->x[0][2] < ta->x[1][2] ) /* keep ta as back part */

	fld	DWORD PTR [ebx+40]
	fld	DWORD PTR [ebx+52]
	fcompp
	fnstsw	ax

; 1164 :         ta->x[1][i] = tc->x[0][i] = (float)mid;

	fstp	DWORD PTR tv9265[ebp]
	fld	DWORD PTR tv9265[ebp]
	test	ah, 65					; 00000041H
	jne	SHORT $LN181@newell_spl
	fst	DWORD PTR [edx-12]
	fstp	DWORD PTR [ecx+16]
	jmp	SHORT $LN182@newell_spl
$LN181@newell_spl:

; 1165 :       else  ta->x[0][i] = tc->x[1][i] = (float)mid;

	fst	DWORD PTR [edx]
	fstp	DWORD PTR [ecx+4]
$LN182@newell_spl:

; 1162 :     { double mid = (((db-d0)*ta->x[1][i] + (d1-db)*ta->x[0][i])/(d1-d0));

	fld	DWORD PTR [ecx+8]
	fmul	ST(0), ST(1)
	fld	DWORD PTR [ecx+20]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(2)

; 1163 :       if ( ta->x[0][2] < ta->x[1][2] ) /* keep ta as back part */

	fld	DWORD PTR [ebx+40]
	fld	DWORD PTR [ebx+52]
	fcompp
	fnstsw	ax

; 1164 :         ta->x[1][i] = tc->x[0][i] = (float)mid;

	fstp	DWORD PTR tv9265[ebp]
	fld	DWORD PTR tv9265[ebp]
	test	ah, 65					; 00000041H
	jne	SHORT $LN183@newell_spl
	fst	DWORD PTR [edx-8]
	fstp	DWORD PTR [ecx+20]
	jmp	SHORT $LN184@newell_spl
$LN183@newell_spl:

; 1165 :       else  ta->x[0][i] = tc->x[1][i] = (float)mid;

	fst	DWORD PTR [edx+4]
	fstp	DWORD PTR [ecx+8]
$LN184@newell_spl:

; 1162 :     { double mid = (((db-d0)*ta->x[1][i] + (d1-db)*ta->x[0][i])/(d1-d0));

	fld	DWORD PTR [ecx+24]
	fmul	ST(0), ST(3)
	fld	DWORD PTR [ecx+12]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(2)

; 1163 :       if ( ta->x[0][2] < ta->x[1][2] ) /* keep ta as back part */

	fld	DWORD PTR [ebx+40]
	fld	DWORD PTR [ebx+52]
	fcompp
	fnstsw	ax

; 1164 :         ta->x[1][i] = tc->x[0][i] = (float)mid;

	fstp	DWORD PTR tv9265[ebp]
	fld	DWORD PTR tv9265[ebp]
	test	ah, 65					; 00000041H
	jne	SHORT $LN185@newell_spl
	fst	DWORD PTR [edx-4]
	fstp	DWORD PTR [ecx+24]
	jmp	SHORT $LN186@newell_spl
$LN185@newell_spl:

; 1165 :       else  ta->x[0][i] = tc->x[1][i] = (float)mid;

	fst	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+12]
$LN186@newell_spl:

; 1154 :   {
; 1155 :     db = dotf(tb->normal,tb->x[0],gdim);

	add	ecx, 16					; 00000010H
	add	edx, 16					; 00000010H
	dec	esi
	jne	$LN187@newell_spl

; 1165 :       else  ta->x[0][i] = tc->x[1][i] = (float)mid;

	fstp	ST(2)
	fstp	ST(1)
	fstp	ST(0)
$LC178@newell_spl:

; 1158 : 
; 1159 :     /* fill in fragment info */
; 1160 :     tmpspot = tc->spot; *tc = *ta; tc->spot = tmpspot;
; 1161 :     for ( i = 0 ; i < gdim ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _gdim
	cmp	eax, esi
	jge	SHORT $LN331@newell_spl
	mov	ecx, DWORD PTR _tc$[ebp]
	fld	ST(0)
	fld	QWORD PTR _d0$[ebp]
	mov	edi, ebx
	sub	edi, DWORD PTR _tc$[ebp]
	fsub	ST(1), ST(0)
	fld	ST(3)
	lea	edx, DWORD PTR [ebx+eax*4+32]
	fsubrp	ST(3), ST(0)
	lea	ecx, DWORD PTR [ecx+eax*4+44]
	sub	esi, eax
	fsubp	ST(3), ST(0)
$LC71@newell_spl:

; 1162 :     { double mid = (((db-d0)*ta->x[1][i] + (d1-db)*ta->x[0][i])/(d1-d0));

	fld	DWORD PTR [edx]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [edi+ecx]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(3)

; 1163 :       if ( ta->x[0][2] < ta->x[1][2] ) /* keep ta as back part */

	fld	DWORD PTR [ebx+40]
	fld	DWORD PTR [ebx+52]
	fcompp
	fnstsw	ax

; 1164 :         ta->x[1][i] = tc->x[0][i] = (float)mid;

	fstp	DWORD PTR tv9265[ebp]
	fld	DWORD PTR tv9265[ebp]
	test	ah, 65					; 00000041H
	jne	SHORT $LN68@newell_spl
	fst	DWORD PTR [ecx-12]
	fstp	DWORD PTR [edi+ecx]
	jmp	SHORT $LN70@newell_spl
$LN68@newell_spl:

; 1165 :       else  ta->x[0][i] = tc->x[1][i] = (float)mid;

	fst	DWORD PTR [ecx]
	fstp	DWORD PTR [edx]
$LN70@newell_spl:

; 1158 : 
; 1159 :     /* fill in fragment info */
; 1160 :     tmpspot = tc->spot; *tc = *ta; tc->spot = tmpspot;
; 1161 :     for ( i = 0 ; i < gdim ; i++ )

	add	ecx, 4
	add	edx, 4
	dec	esi
	jne	SHORT $LC71@newell_spl
	mov	esi, DWORD PTR _gdim
	fstp	ST(0)
	fstp	ST(0)
	jmp	SHORT $LN522@newell_spl
$LN331@newell_spl:
	fstp	ST(1)
$LN522@newell_spl:

; 1166 :     }
; 1167 :     for ( i = 0 ; i < gdim ; i++ )

	xor	ecx, ecx
	fstp	ST(0)
	mov	DWORD PTR _i$[ebp], ecx
	cmp	esi, 4
	jl	$LC189@newell_spl
	mov	esi, DWORD PTR _gdim
	mov	eax, DWORD PTR _tc$[ebp]
	add	esi, -4					; fffffffcH

; 1171 :       tc->maxs[i] = (tc->x[0][i]>tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	mov	edi, ebx
	sub	edi, eax
	shr	esi, 2
	inc	esi
	lea	ecx, DWORD PTR [eax+32]
	lea	eax, DWORD PTR [esi*4]
	lea	edx, DWORD PTR [ebx+36]
	mov	DWORD PTR _i$[ebp], eax
$LL222@newell_spl:

; 1168 :     { ta->mins[i] = (ta->x[0][i]<ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edi+ecx]
	fld	DWORD PTR [edx+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN190@newell_spl
	fld	DWORD PTR [edi+ecx]
	jmp	SHORT $LN523@newell_spl
$LN190@newell_spl:
	fld	DWORD PTR [edx+8]
$LN523@newell_spl:
	fstp	DWORD PTR tv344[ebp]
	fld	DWORD PTR tv344[ebp]
	fstp	DWORD PTR [edi+ecx+48]

; 1169 :       tc->mins[i] = (tc->x[0][i]<tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN192@newell_spl
	fld	DWORD PTR [ecx]
	jmp	SHORT $LN524@newell_spl
$LN192@newell_spl:
	fld	DWORD PTR [ecx+12]
$LN524@newell_spl:
	fstp	DWORD PTR tv367[ebp]
	fld	DWORD PTR tv367[ebp]
	fstp	DWORD PTR [ecx+48]

; 1170 :       ta->maxs[i] = (ta->x[0][i]>ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edi+ecx]
	fld	DWORD PTR [edx+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN194@newell_spl
	fld	DWORD PTR [edi+ecx]
	jmp	SHORT $LN525@newell_spl
$LN194@newell_spl:
	fld	DWORD PTR [edx+8]
$LN525@newell_spl:
	fstp	DWORD PTR tv390[ebp]
	fld	DWORD PTR tv390[ebp]
	fstp	DWORD PTR [edx+56]

; 1171 :       tc->maxs[i] = (tc->x[0][i]>tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN196@newell_spl
	fld	DWORD PTR [ecx]
	jmp	SHORT $LN526@newell_spl
$LN196@newell_spl:
	fld	DWORD PTR [ecx+12]
$LN526@newell_spl:
	fstp	DWORD PTR tv413[ebp]
	fld	DWORD PTR tv413[ebp]
	fstp	DWORD PTR [ecx+60]
	fld	DWORD PTR [edx]
	fld	DWORD PTR [edx+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN198@newell_spl

; 1168 :     { ta->mins[i] = (ta->x[0][i]<ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edx]
	jmp	SHORT $LN527@newell_spl
$LN198@newell_spl:
	fld	DWORD PTR [edx+12]
$LN527@newell_spl:
	fstp	DWORD PTR tv344[ebp]
	fld	DWORD PTR tv344[ebp]
	fstp	DWORD PTR [edx+48]

; 1169 :       tc->mins[i] = (tc->x[0][i]<tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx+4]
	fld	DWORD PTR [ecx+16]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN200@newell_spl
	fld	DWORD PTR [ecx+4]
	jmp	SHORT $LN528@newell_spl
$LN200@newell_spl:
	fld	DWORD PTR [ecx+16]
$LN528@newell_spl:
	fstp	DWORD PTR tv367[ebp]
	fld	DWORD PTR tv367[ebp]
	fstp	DWORD PTR [ecx+52]

; 1170 :       ta->maxs[i] = (ta->x[0][i]>ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edx]
	fld	DWORD PTR [edx+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN202@newell_spl
	fld	DWORD PTR [edx]
	jmp	SHORT $LN529@newell_spl
$LN202@newell_spl:
	fld	DWORD PTR [edx+12]
$LN529@newell_spl:
	fstp	DWORD PTR tv390[ebp]
	fld	DWORD PTR tv390[ebp]
	fstp	DWORD PTR [edx+60]

; 1171 :       tc->maxs[i] = (tc->x[0][i]>tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx+4]
	fld	DWORD PTR [ecx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN204@newell_spl
	fld	DWORD PTR [ecx+4]
	jmp	SHORT $LN530@newell_spl
$LN204@newell_spl:
	fld	DWORD PTR [ecx+16]
$LN530@newell_spl:
	fstp	DWORD PTR tv413[ebp]
	fld	DWORD PTR tv413[ebp]
	fstp	DWORD PTR [ecx+64]
	fld	DWORD PTR [edx+4]
	fld	DWORD PTR [edx+16]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN206@newell_spl

; 1168 :     { ta->mins[i] = (ta->x[0][i]<ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edx+4]
	jmp	SHORT $LN531@newell_spl
$LN206@newell_spl:
	fld	DWORD PTR [edx+16]
$LN531@newell_spl:
	fstp	DWORD PTR tv344[ebp]
	fld	DWORD PTR tv344[ebp]
	fstp	DWORD PTR [edx+52]

; 1169 :       tc->mins[i] = (tc->x[0][i]<tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx+8]
	fld	DWORD PTR [ecx+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN208@newell_spl
	fld	DWORD PTR [ecx+8]
	jmp	SHORT $LN532@newell_spl
$LN208@newell_spl:
	fld	DWORD PTR [ecx+20]
$LN532@newell_spl:
	fstp	DWORD PTR tv367[ebp]
	fld	DWORD PTR tv367[ebp]
	fstp	DWORD PTR [ecx+56]

; 1170 :       ta->maxs[i] = (ta->x[0][i]>ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edx+4]
	fld	DWORD PTR [edx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN210@newell_spl
	fld	DWORD PTR [edx+4]
	jmp	SHORT $LN533@newell_spl
$LN210@newell_spl:
	fld	DWORD PTR [edx+16]
$LN533@newell_spl:
	fstp	DWORD PTR tv390[ebp]
	fld	DWORD PTR tv390[ebp]
	fstp	DWORD PTR [edx+64]

; 1171 :       tc->maxs[i] = (tc->x[0][i]>tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx+8]
	fld	DWORD PTR [ecx+20]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN212@newell_spl
	fld	DWORD PTR [ecx+8]
	jmp	SHORT $LN534@newell_spl
$LN212@newell_spl:
	fld	DWORD PTR [ecx+20]
$LN534@newell_spl:
	fstp	DWORD PTR tv413[ebp]
	fld	DWORD PTR tv413[ebp]
	fstp	DWORD PTR [ecx+68]
	fld	DWORD PTR [edx+8]
	fld	DWORD PTR [edx+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN214@newell_spl

; 1168 :     { ta->mins[i] = (ta->x[0][i]<ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edx+8]
	jmp	SHORT $LN535@newell_spl
$LN214@newell_spl:
	fld	DWORD PTR [edx+20]
$LN535@newell_spl:
	fstp	DWORD PTR tv344[ebp]
	fld	DWORD PTR tv344[ebp]
	fstp	DWORD PTR [edx+56]

; 1169 :       tc->mins[i] = (tc->x[0][i]<tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx+12]
	fld	DWORD PTR [ecx+24]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN216@newell_spl
	fld	DWORD PTR [ecx+12]
	jmp	SHORT $LN536@newell_spl
$LN216@newell_spl:
	fld	DWORD PTR [ecx+24]
$LN536@newell_spl:
	fstp	DWORD PTR tv367[ebp]
	fld	DWORD PTR tv367[ebp]
	fstp	DWORD PTR [ecx+60]

; 1170 :       ta->maxs[i] = (ta->x[0][i]>ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [edx+8]
	fld	DWORD PTR [edx+20]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN218@newell_spl
	fld	DWORD PTR [edx+8]
	jmp	SHORT $LN537@newell_spl
$LN218@newell_spl:
	fld	DWORD PTR [edx+20]
$LN537@newell_spl:
	fstp	DWORD PTR tv390[ebp]
	fld	DWORD PTR tv390[ebp]
	fstp	DWORD PTR [edx+68]

; 1171 :       tc->maxs[i] = (tc->x[0][i]>tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [ecx+12]
	fld	DWORD PTR [ecx+24]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN220@newell_spl
	fld	DWORD PTR [ecx+12]
	jmp	SHORT $LN538@newell_spl
$LN220@newell_spl:
	fld	DWORD PTR [ecx+24]
$LN538@newell_spl:
	fstp	DWORD PTR tv413[ebp]
	add	ecx, 16					; 00000010H
	fld	DWORD PTR tv413[ebp]
	add	edx, 16					; 00000010H
	dec	esi
	fstp	DWORD PTR [ecx+56]
	jne	$LL222@newell_spl

; 1166 :     }
; 1167 :     for ( i = 0 ; i < gdim ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
$LC189@newell_spl:
	mov	eax, DWORD PTR _gdim
	cmp	ecx, eax
	jge	$LN273@newell_spl
	mov	esi, DWORD PTR _tc$[ebp]
	mov	edx, DWORD PTR _tc$[ebp]
	mov	edi, ebx
	sub	edi, DWORD PTR _tc$[ebp]
	sub	esi, ebx
	sub	eax, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [edx+ecx*4+32]
	lea	ecx, DWORD PTR [ebx+ecx*4+44]
	mov	ebx, eax
$LC66@newell_spl:

; 1168 :     { ta->mins[i] = (ta->x[0][i]<ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [ecx-12]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN95@newell_spl
	fld	DWORD PTR [ecx-12]
	jmp	SHORT $LN539@newell_spl
$LN95@newell_spl:
	fld	DWORD PTR [ecx]
$LN539@newell_spl:
	fstp	DWORD PTR tv344[ebp]
	fld	DWORD PTR tv344[ebp]
	fstp	DWORD PTR [edi+edx+48]

; 1169 :       tc->mins[i] = (tc->x[0][i]<tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [edx]
	fld	DWORD PTR [esi+ecx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN97@newell_spl
	fld	DWORD PTR [edx]
	jmp	SHORT $LN540@newell_spl
$LN97@newell_spl:
	fld	DWORD PTR [esi+ecx]
$LN540@newell_spl:
	fstp	DWORD PTR tv367[ebp]
	fld	DWORD PTR tv367[ebp]
	fstp	DWORD PTR [edx+48]

; 1170 :       ta->maxs[i] = (ta->x[0][i]>ta->x[1][i]) ? ta->x[0][i] : ta->x[1][i];

	fld	DWORD PTR [ecx-12]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN99@newell_spl
	fld	DWORD PTR [ecx-12]
	jmp	SHORT $LN541@newell_spl
$LN99@newell_spl:
	fld	DWORD PTR [ecx]
$LN541@newell_spl:
	fstp	DWORD PTR tv390[ebp]
	fld	DWORD PTR tv390[ebp]
	fstp	DWORD PTR [ecx+48]

; 1171 :       tc->maxs[i] = (tc->x[0][i]>tc->x[1][i]) ? tc->x[0][i] : tc->x[1][i];

	fld	DWORD PTR [edx]
	fld	DWORD PTR [esi+ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN101@newell_spl
	fld	DWORD PTR [edx]
	jmp	SHORT $LN542@newell_spl
$LN101@newell_spl:
	fld	DWORD PTR [esi+ecx]
$LN542@newell_spl:
	fstp	DWORD PTR tv413[ebp]
	add	edx, 4
	fld	DWORD PTR tv413[ebp]
	add	ecx, 4
	dec	ebx
	fstp	DWORD PTR [edx+56]
	jne	$LC66@newell_spl
$LN273@newell_spl:

; 1172 :     }
; 1173 :     /* find_bbox(tc); */
; 1174 :     if ( setquadcode(tc) == INTHEBOX )

	mov	esi, DWORD PTR _tc$[ebp]
$LN549@newell_spl:
	push	esi
	call	_setquadcode
	add	esp, 4
	cmp	eax, 1
	jne	SHORT $LN63@newell_spl

; 1175 :     { qdepth_insert(tc);

	push	esi
	call	_qdepth_insert
	add	esp, 4
	pop	edi
	pop	esi

; 1176 :       return 1;

	mov	eax, 1
	pop	ebx

; 1361 : } // end newell_split()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@newell_spl:
	pop	edi

; 1177 :     }
; 1178 :     else { tc->flag = 0; return 0; }

	mov	DWORD PTR [esi+28], 0
	pop	esi
	xor	eax, eax
	pop	ebx

; 1361 : } // end newell_split()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@newell_spl:

; 1179 :   }
; 1180 : 
; 1181 :   /* figure out which vertices of ta on same side, and get as 0,1 */
; 1182 :   db = dotf(tb->normal,tb->x[0],gdim);

	add	eax, 32					; 00000020H
	push	eax
	push	esi
	call	_dotf
	fstp	QWORD PTR _db$[ebp]

; 1183 :   d0 = dotf(tb->normal,ta->x[0],gdim); 

	mov	edx, DWORD PTR _gdim
	push	edx
	lea	eax, DWORD PTR [ebx+32]
	push	eax
	push	esi
	call	_dotf
	fstp	QWORD PTR _d0$[ebp]

; 1184 :   d1 = dotf(tb->normal,ta->x[1],gdim); 

	mov	ecx, DWORD PTR _gdim
	push	ecx
	lea	edx, DWORD PTR [ebx+44]
	push	edx
	push	esi
	call	_dotf
	fstp	QWORD PTR _d1$[ebp]

; 1185 :   d2 = dotf(tb->normal,ta->x[2],gdim); 

	mov	ecx, DWORD PTR _gdim
	push	ecx
	lea	eax, DWORD PTR [ebx+56]
	push	eax
	push	esi
	call	_dotf
	fst	QWORD PTR _d2$[ebp]

; 1186 : 
; 1187 : if ( (d0<db) && (d1<db) && (d2<db) ) /* should never happen */

	fld	QWORD PTR _db$[ebp]
	add	esp, 48					; 00000030H
	fld	QWORD PTR _d0$[ebp]
	fcom	ST(1)
	fnstsw	ax
	fld	QWORD PTR _d1$[ebp]
	test	ah, 5
	jp	SHORT $LN61@newell_spl
	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN61@newell_spl
	fxch	ST(3)
	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN347@newell_spl

; 1188 : { struct tsort t;  
; 1189 :   t = *ta; *ta = *tb; *tb = t; return 0; }

	mov	eax, DWORD PTR _tb$[ebp]
	fstp	ST(1)
	mov	esi, ebx
	fstp	ST(0)
	mov	ecx, 35					; 00000023H
	fstp	ST(0)
	lea	edi, DWORD PTR _t$89709[ebp]
	fstp	ST(0)
	rep movsd
	mov	esi, eax
	mov	edi, ebx
	mov	ecx, 35					; 00000023H
	rep movsd
	mov	edi, eax
	mov	ecx, 35					; 00000023H
	lea	esi, DWORD PTR _t$89709[ebp]
	rep movsd
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 1361 : } // end newell_split()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN347@newell_spl:

; 1186 : 
; 1187 : if ( (d0<db) && (d1<db) && (d2<db) ) /* should never happen */

	fxch	ST(3)
$LN61@newell_spl:

; 1190 : if ( (d0>db) && (d1>db) && (d2>db) )

	fxch	ST(1)
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN60@newell_spl
	fxch	ST(1)
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN353@newell_spl
	fxch	ST(3)
	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN356@newell_spl
	fstp	ST(1)
	pop	edi
	fstp	ST(0)
	pop	esi
	fstp	ST(0)

; 1191 : { return 0; }

	xor	eax, eax
	fstp	ST(0)
	pop	ebx

; 1361 : } // end newell_split()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN356@newell_spl:

; 1190 : if ( (d0>db) && (d1>db) && (d2>db) )

	fxch	ST(3)
$LN353@newell_spl:
	fxch	ST(1)
$LN60@newell_spl:

; 1192 : 
; 1193 :   retval = 0;
; 1194 :   if ( db == d0 ) /* split thru vertex 0 of ta */

	mov	edx, DWORD PTR _gdim
	fld	ST(2)
	fld	ST(1)
	xor	ecx, ecx
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN59@newell_spl

; 1195 :   { 
; 1196 :      tmpspot = tc->spot; *tc = *ta; tc->spot = tmpspot;

	mov	eax, DWORD PTR _tc$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	DWORD PTR _tmpspot$[ebp], ecx
	mov	ecx, 35					; 00000023H
	mov	esi, ebx
	mov	edi, eax
	rep movsd
	mov	ecx, DWORD PTR _tmpspot$[ebp]
	mov	DWORD PTR [eax+136], ecx

; 1197 : 
; 1198 :      /* fill in fragment info */
; 1199 :      for ( i = 0 ; i < gdim ; i++ )

	xor	ecx, ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	edx, 4
	jl	$LN262@newell_spl
	mov	esi, DWORD PTR _tc$[ebp]
	fld	ST(2)
	fsub	ST(0), ST(2)
	lea	ecx, DWORD PTR [esi+44]

; 1200 :      { ta->x[2][i] = tc->x[1][i] = 
; 1201 :           (float)(((db-d1)*ta->x[2][i] + (d2-db)*ta->x[1][i])/(d2-d1));

	mov	edi, ebx
	fld	ST(4)
	sub	edi, esi
	fsub	ST(0), ST(4)
	lea	esi, DWORD PTR [edx-4]
	fld	ST(5)
	shr	esi, 2
	fsub	ST(0), ST(4)
	mov	DWORD PTR tv12264[ebp], edi
	inc	esi
	lea	edi, DWORD PTR [esi*4]
	fstp	QWORD PTR tv9443[ebp]
	mov	DWORD PTR _i$[ebp], edi
	mov	edi, DWORD PTR tv12264[ebp]
	lea	eax, DWORD PTR [ebx+60]
$LN225@newell_spl:
	fld	DWORD PTR [edi+ecx]
	add	ecx, 16					; 00000010H
	fmul	ST(0), ST(1)
	add	eax, 16					; 00000010H
	dec	esi
	fld	DWORD PTR [eax-20]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fdiv	QWORD PTR tv9443[ebp]
	fstp	DWORD PTR tv16374[ebp]
	fld	DWORD PTR tv16374[ebp]
	fst	DWORD PTR [ecx-16]
	fstp	DWORD PTR [eax-20]
	fld	DWORD PTR [eax-28]
	fmul	ST(0), ST(1)
	fld	DWORD PTR [eax-16]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fdiv	QWORD PTR tv9443[ebp]
	fstp	DWORD PTR tv16423[ebp]
	fld	DWORD PTR tv16423[ebp]
	fst	DWORD PTR [ecx-12]
	fstp	DWORD PTR [eax-16]
	fld	DWORD PTR [eax-24]
	fmul	ST(0), ST(1)
	fld	DWORD PTR [eax-12]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fdiv	QWORD PTR tv9443[ebp]
	fstp	DWORD PTR tv16444[ebp]
	fld	DWORD PTR tv16444[ebp]
	fst	DWORD PTR [ecx-8]
	fstp	DWORD PTR [eax-12]
	fld	DWORD PTR [eax-8]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax-20]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fdiv	QWORD PTR tv9443[ebp]
	fstp	DWORD PTR tv16463[ebp]
	fld	DWORD PTR tv16463[ebp]
	fst	DWORD PTR [ecx-4]
	fstp	DWORD PTR [eax-8]
	jne	SHORT $LN225@newell_spl

; 1195 :   { 
; 1196 :      tmpspot = tc->spot; *tc = *ta; tc->spot = tmpspot;

	mov	eax, DWORD PTR _tc$[ebp]
	fstp	ST(1)
	mov	ecx, DWORD PTR _i$[ebp]
	fstp	ST(0)
$LN262@newell_spl:

; 1197 : 
; 1198 :      /* fill in fragment info */
; 1199 :      for ( i = 0 ; i < gdim ; i++ )

	cmp	ecx, edx
	jge	SHORT $LN223@newell_spl
	fld	ST(2)
	mov	edi, ebx
	fsub	ST(0), ST(2)
	sub	edi, eax
	fld	ST(4)
	lea	esi, DWORD PTR [ebx+ecx*4+56]
	fsub	ST(0), ST(4)
	lea	ecx, DWORD PTR [eax+ecx*4+44]
	fld	ST(5)
	mov	eax, edx
	sub	eax, DWORD PTR _i$[ebp]
	fsub	ST(0), ST(4)
	mov	DWORD PTR tv12264[ebp], edi
	fstp	QWORD PTR tv9443[ebp]
$LC58@newell_spl:

; 1200 :      { ta->x[2][i] = tc->x[1][i] = 
; 1201 :           (float)(((db-d1)*ta->x[2][i] + (d2-db)*ta->x[1][i])/(d2-d1));

	fld	DWORD PTR [edi+ecx]
	add	ecx, 4
	fmul	ST(0), ST(1)
	add	esi, 4
	dec	eax
	fld	DWORD PTR [esi-4]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fdiv	QWORD PTR tv9443[ebp]
	fstp	DWORD PTR tv16690[ebp]
	fld	DWORD PTR tv16690[ebp]
	fst	DWORD PTR [ecx-4]
	fstp	DWORD PTR [esi-4]
	jne	SHORT $LC58@newell_spl

; 1197 : 
; 1198 :      /* fill in fragment info */
; 1199 :      for ( i = 0 ; i < gdim ; i++ )

	mov	eax, DWORD PTR _tc$[ebp]
	fstp	ST(1)
	fstp	ST(0)
$LN223@newell_spl:

; 1202 :      }
; 1203 :      /* internal edges invisible */
; 1204 :      ta->etype[2] = tc->etype[0] = SPLITTING_EDGE;

	mov	ecx, 128				; 00000080H
	mov	WORD PTR [eax+20], cx
	mov	eax, ecx
	mov	WORD PTR [ebx+24], ax

; 1205 :      retval = 1;

	lea	ecx, DWORD PTR [eax-127]
$LN59@newell_spl:

; 1206 :   }
; 1207 :   if ( db == d1 ) /* split thru vertex 1 of ta */

	fld	ST(2)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN55@newell_spl

; 1208 :   { 
; 1209 :      tmpspot = tc->spot; *tc = *ta; tc->spot = tmpspot;

	mov	eax, DWORD PTR _tc$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	DWORD PTR _tmpspot$[ebp], ecx
	mov	ecx, 35					; 00000023H
	mov	esi, ebx
	mov	edi, eax
	rep movsd
	mov	ecx, DWORD PTR _tmpspot$[ebp]
	mov	DWORD PTR [eax+136], ecx

; 1210 : 
; 1211 :      /* fill in fragment info */
; 1212 :      for ( i = 0 ; i < gdim ; i++ )

	xor	ecx, ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	edx, 4
	jl	$LN263@newell_spl
	mov	esi, DWORD PTR _tc$[ebp]
	fld	ST(3)
	fsub	ST(0), ST(3)
	lea	ecx, DWORD PTR [esi+32]

; 1213 :      { ta->x[2][i] = tc->x[0][i] = 
; 1214 :           (float)(((db-d0)*ta->x[2][i] + (d2-db)*ta->x[0][i])/(d2-d0));

	mov	edi, ebx
	fld	ST(3)
	sub	edi, esi
	fsub	ST(0), ST(2)
	lea	esi, DWORD PTR [edx-4]
	fld	ST(5)
	shr	esi, 2
	fsub	ST(0), ST(3)
	mov	DWORD PTR tv12264[ebp], edi
	inc	esi
	lea	edi, DWORD PTR [esi*4]
	fstp	QWORD PTR tv9526[ebp]
	mov	DWORD PTR _i$[ebp], edi
	mov	edi, DWORD PTR tv12264[ebp]
	lea	eax, DWORD PTR [ebx+56]
$LN228@newell_spl:
	fld	DWORD PTR [edi+ecx]
	add	ecx, 16					; 00000010H
	fmul	ST(0), ST(2)
	add	eax, 16					; 00000010H
	dec	esi
	fld	DWORD PTR [eax-16]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fdiv	QWORD PTR tv9526[ebp]
	fstp	DWORD PTR tv17641[ebp]
	fld	DWORD PTR tv17641[ebp]
	fst	DWORD PTR [ecx-16]
	fstp	DWORD PTR [eax-16]
	fld	DWORD PTR [eax-36]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax-12]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fdiv	QWORD PTR tv9526[ebp]
	fstp	DWORD PTR tv17662[ebp]
	fld	DWORD PTR tv17662[ebp]
	fst	DWORD PTR [ecx-12]
	fstp	DWORD PTR [eax-12]
	fld	DWORD PTR [eax-32]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax-8]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fdiv	QWORD PTR tv9526[ebp]
	fstp	DWORD PTR tv17683[ebp]
	fld	DWORD PTR tv17683[ebp]
	fst	DWORD PTR [ecx-8]
	fstp	DWORD PTR [eax-8]
	fld	DWORD PTR [eax-28]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax-4]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fdiv	QWORD PTR tv9526[ebp]
	fstp	DWORD PTR tv17704[ebp]
	fld	DWORD PTR tv17704[ebp]
	fst	DWORD PTR [ecx-4]
	fstp	DWORD PTR [eax-4]
	jne	SHORT $LN228@newell_spl

; 1208 :   { 
; 1209 :      tmpspot = tc->spot; *tc = *ta; tc->spot = tmpspot;

	mov	eax, DWORD PTR _tc$[ebp]
	fstp	ST(1)
	mov	ecx, DWORD PTR _i$[ebp]
	fstp	ST(0)
$LN263@newell_spl:

; 1210 : 
; 1211 :      /* fill in fragment info */
; 1212 :      for ( i = 0 ; i < gdim ; i++ )

	cmp	ecx, edx
	jge	SHORT $LN226@newell_spl
	fld	ST(3)
	mov	edi, ebx
	fsub	ST(0), ST(3)
	sub	edi, eax
	fld	ST(3)
	lea	esi, DWORD PTR [ebx+ecx*4+56]
	fsub	ST(0), ST(2)
	lea	ecx, DWORD PTR [eax+ecx*4+32]
	fld	ST(5)
	mov	eax, edx
	sub	eax, DWORD PTR _i$[ebp]
	fsub	ST(0), ST(3)
	mov	DWORD PTR tv12264[ebp], edi
	fstp	QWORD PTR tv9526[ebp]
$LC54@newell_spl:

; 1213 :      { ta->x[2][i] = tc->x[0][i] = 
; 1214 :           (float)(((db-d0)*ta->x[2][i] + (d2-db)*ta->x[0][i])/(d2-d0));

	fld	DWORD PTR [edi+ecx]
	add	ecx, 4
	fmul	ST(0), ST(2)
	add	esi, 4
	dec	eax
	fld	DWORD PTR [esi-4]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fdiv	QWORD PTR tv9526[ebp]
	fstp	DWORD PTR tv17961[ebp]
	fld	DWORD PTR tv17961[ebp]
	fst	DWORD PTR [ecx-4]
	fstp	DWORD PTR [esi-4]
	jne	SHORT $LC54@newell_spl

; 1210 : 
; 1211 :      /* fill in fragment info */
; 1212 :      for ( i = 0 ; i < gdim ; i++ )

	mov	eax, DWORD PTR _tc$[ebp]
	fstp	ST(1)
	fstp	ST(0)
$LN226@newell_spl:

; 1215 :      }
; 1216 :      /* internal edges invisible */
; 1217 :      ta->etype[1] = tc->etype[0] = SPLITTING_EDGE;

	mov	ecx, 128				; 00000080H
	mov	WORD PTR [eax+20], cx
	mov	eax, ecx
	mov	WORD PTR [ebx+22], ax

; 1218 :      retval = 1;

	lea	ecx, DWORD PTR [eax-127]
$LN55@newell_spl:

; 1219 :   }
; 1220 :   if ( db == d2 ) /* split thru vertex 2 of ta */

	fld	ST(2)
	fld	ST(4)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN51@newell_spl

; 1221 :   { 
; 1222 :     tmpspot = tc->spot; *tc = *ta; tc->spot = tmpspot;

	mov	eax, DWORD PTR _tc$[ebp]
	fstp	ST(3)
	mov	ecx, DWORD PTR [eax+136]
	mov	DWORD PTR _tmpspot$[ebp], ecx
	mov	ecx, 35					; 00000023H
	mov	esi, ebx
	mov	edi, eax
	rep movsd
	mov	ecx, DWORD PTR _tmpspot$[ebp]
	mov	DWORD PTR [eax+136], ecx

; 1223 : 
; 1224 :     /* fill in fragment info */
; 1225 :     for ( i = 0 ; i < gdim ; i++ )

	xor	ecx, ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	edx, 4
	jl	$LN264@newell_spl
	mov	esi, DWORD PTR _tc$[ebp]
	fld	ST(1)
	lea	ecx, DWORD PTR [esi+32]
	fsub	ST(0), ST(3)

; 1226 :     { ta->x[1][i] = tc->x[0][i] = 
; 1227 :           (float)(((db-d0)*ta->x[1][i] + (d1-db)*ta->x[0][i])/(d1-d0));

	mov	edi, ebx
	fld	ST(1)
	sub	edi, esi
	fsub	ST(0), ST(3)
	lea	esi, DWORD PTR [edx-4]
	fld	ST(2)
	shr	esi, 2
	fsub	ST(0), ST(5)
	mov	DWORD PTR tv12264[ebp], edi
	inc	esi
	lea	edi, DWORD PTR [esi*4]
	mov	DWORD PTR _i$[ebp], edi
	mov	edi, DWORD PTR tv12264[ebp]
	lea	eax, DWORD PTR [ebx+48]
$LN231@newell_spl:
	fld	DWORD PTR [ecx+edi]
	add	ecx, 16					; 00000010H
	fmul	ST(0), ST(2)
	add	eax, 16					; 00000010H
	dec	esi
	fld	DWORD PTR [eax-20]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR tv18788[ebp]
	fld	DWORD PTR tv18788[ebp]
	fst	DWORD PTR [ecx-16]
	fstp	DWORD PTR [eax-20]
	fld	DWORD PTR [eax-28]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax-16]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR tv18805[ebp]
	fld	DWORD PTR tv18805[ebp]
	fst	DWORD PTR [ecx-12]
	fstp	DWORD PTR [eax-16]
	fld	DWORD PTR [eax-24]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax-12]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR tv18826[ebp]
	fld	DWORD PTR tv18826[ebp]
	fst	DWORD PTR [ecx-8]
	fstp	DWORD PTR [eax-12]
	fld	DWORD PTR [eax-8]
	fmul	ST(0), ST(3)
	fld	DWORD PTR [eax-20]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(1)
	fstp	DWORD PTR tv18845[ebp]
	fld	DWORD PTR tv18845[ebp]
	fst	DWORD PTR [ecx-4]
	fstp	DWORD PTR [eax-8]
	jne	SHORT $LN231@newell_spl

; 1221 :   { 
; 1222 :     tmpspot = tc->spot; *tc = *ta; tc->spot = tmpspot;

	mov	eax, DWORD PTR _tc$[ebp]
	fstp	ST(2)
	mov	ecx, DWORD PTR _i$[ebp]
	fstp	ST(0)
	fstp	ST(0)
$LN264@newell_spl:

; 1223 : 
; 1224 :     /* fill in fragment info */
; 1225 :     for ( i = 0 ; i < gdim ; i++ )

	cmp	ecx, edx
	jge	SHORT $LN398@newell_spl
	fld	ST(1)
	mov	edi, ebx
	fsub	ST(0), ST(3)
	sub	edi, eax
	fld	ST(1)
	lea	esi, DWORD PTR [ebx+ecx*4+44]
	fsubrp	ST(3), ST(0)
	lea	ecx, DWORD PTR [eax+ecx*4+32]
	fxch	ST(1)
	mov	eax, edx
	sub	eax, DWORD PTR _i$[ebp]
	fsubrp	ST(3), ST(0)
	mov	DWORD PTR tv12264[ebp], edi
$LC50@newell_spl:

; 1226 :     { ta->x[1][i] = tc->x[0][i] = 
; 1227 :           (float)(((db-d0)*ta->x[1][i] + (d1-db)*ta->x[0][i])/(d1-d0));

	fld	DWORD PTR [edi+ecx]
	add	ecx, 4
	fmul	ST(0), ST(2)
	add	esi, 4
	dec	eax
	fld	DWORD PTR [esi-4]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(3)
	fstp	DWORD PTR tv19071[ebp]
	fld	DWORD PTR tv19071[ebp]
	fst	DWORD PTR [ecx-4]
	fstp	DWORD PTR [esi-4]
	jne	SHORT $LC50@newell_spl

; 1223 : 
; 1224 :     /* fill in fragment info */
; 1225 :     for ( i = 0 ; i < gdim ; i++ )

	mov	eax, DWORD PTR _tc$[ebp]
	fstp	ST(0)

; 1228 :     }
; 1229 :     /* internal edges invisible */
; 1230 :     ta->etype[1] = tc->etype[2] = SPLITTING_EDGE;

	mov	ecx, 128				; 00000080H
	mov	WORD PTR [eax+24], cx
	mov	eax, ecx
	mov	WORD PTR [ebx+22], ax

; 1231 :     retval = 1;
; 1232 :   }
; 1233 : 
; 1234 :   if ( retval == 1 )

	jmp	SHORT $LN544@newell_spl
$LN398@newell_spl:

; 1228 :     }
; 1229 :     /* internal edges invisible */
; 1230 :     ta->etype[1] = tc->etype[2] = SPLITTING_EDGE;

	mov	ecx, 128				; 00000080H
	fstp	ST(2)
	mov	WORD PTR [eax+24], cx
	mov	eax, ecx
	mov	WORD PTR [ebx+22], ax

; 1231 :     retval = 1;
; 1232 :   }
; 1233 : 
; 1234 :   if ( retval == 1 )

	jmp	SHORT $LN544@newell_spl
$LN51@newell_spl:
	cmp	ecx, 1
	jne	$LN34@newell_spl
	fstp	ST(0)
	fstp	ST(2)
$LN544@newell_spl:
	fstp	ST(0)
	fstp	ST(0)

; 1235 :   {
; 1236 :      /* set mins and maxs */
; 1237 :      for ( i = 0 ; i < gdim ; i++ )

	test	edx, edx
	jle	$LN265@newell_spl
	mov	eax, DWORD PTR _tc$[ebp]
	fld	DWORD PTR __real@7149f2ca
	fld	DWORD PTR __real@f149f2ca

; 1238 :      { int j;
; 1239 :         ta->mins[i] = tc->mins[i] = (float)1e30;

	mov	edi, ebx
	lea	esi, DWORD PTR [ebx+80]
	lea	ecx, DWORD PTR [eax+32]
	sub	edi, eax
$LN46@newell_spl:
	fxch	ST(1)
	fst	DWORD PTR [ecx+48]
	fst	DWORD PTR [esi]

; 1240 :         ta->maxs[i] = tc->maxs[i] = (float)(-1e30);

	fxch	ST(1)
	fst	DWORD PTR [ecx+60]
	fst	DWORD PTR [esi+12]

; 1241 :         for ( j = 0 ; j < FACET_VERTS ; j++ )
; 1242 :         { if ( ta->x[j][i] < ta->mins[i] ) ta->mins[i] = ta->x[j][i];

	fld	DWORD PTR [edi+ecx]
	fld	DWORD PTR [esi]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN40@newell_spl
	fld	DWORD PTR [edi+ecx]
	fstp	DWORD PTR [esi]
$LN40@newell_spl:

; 1243 :           if ( tc->x[j][i] < tc->mins[i] ) tc->mins[i] = tc->x[j][i];

	fld	DWORD PTR [ecx]
	fld	DWORD PTR [ecx+48]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN39@newell_spl
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+48]
$LN39@newell_spl:

; 1244 :           if ( ta->x[j][i] > ta->maxs[i] ) ta->maxs[i] = ta->x[j][i];

	fld	DWORD PTR [edi+ecx]
	fld	DWORD PTR [esi+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN38@newell_spl
	fld	DWORD PTR [edi+ecx]
	fstp	DWORD PTR [esi+12]
$LN38@newell_spl:

; 1245 :           if ( tc->x[j][i] > tc->maxs[i] ) tc->maxs[i] = tc->x[j][i];

	fld	DWORD PTR [ecx]
	fld	DWORD PTR [ecx+60]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN42@newell_spl
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+60]
$LN42@newell_spl:

; 1241 :         for ( j = 0 ; j < FACET_VERTS ; j++ )
; 1242 :         { if ( ta->x[j][i] < ta->mins[i] ) ta->mins[i] = ta->x[j][i];

	fld	DWORD PTR [esi-36]
	fld	DWORD PTR [esi]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN239@newell_spl
	fld	DWORD PTR [esi-36]
	fstp	DWORD PTR [esi]
$LN239@newell_spl:

; 1243 :           if ( tc->x[j][i] < tc->mins[i] ) tc->mins[i] = tc->x[j][i];

	fld	DWORD PTR [ecx+12]
	fld	DWORD PTR [ecx+48]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN240@newell_spl
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [ecx+48]
$LN240@newell_spl:

; 1244 :           if ( ta->x[j][i] > ta->maxs[i] ) ta->maxs[i] = ta->x[j][i];

	fld	DWORD PTR [esi-36]
	fld	DWORD PTR [esi+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN241@newell_spl
	fld	DWORD PTR [esi-36]
	fstp	DWORD PTR [esi+12]
$LN241@newell_spl:

; 1245 :           if ( tc->x[j][i] > tc->maxs[i] ) tc->maxs[i] = tc->x[j][i];

	fld	DWORD PTR [ecx+12]
	fld	DWORD PTR [ecx+60]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN242@newell_spl
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [ecx+60]
$LN242@newell_spl:

; 1241 :         for ( j = 0 ; j < FACET_VERTS ; j++ )
; 1242 :         { if ( ta->x[j][i] < ta->mins[i] ) ta->mins[i] = ta->x[j][i];

	fld	DWORD PTR [esi-24]
	fld	DWORD PTR [esi]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN244@newell_spl
	fld	DWORD PTR [esi-24]
	fstp	DWORD PTR [esi]
$LN244@newell_spl:

; 1243 :           if ( tc->x[j][i] < tc->mins[i] ) tc->mins[i] = tc->x[j][i];

	fld	DWORD PTR [ecx+24]
	fld	DWORD PTR [ecx+48]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN245@newell_spl
	fld	DWORD PTR [ecx+24]
	fstp	DWORD PTR [ecx+48]
$LN245@newell_spl:

; 1244 :           if ( ta->x[j][i] > ta->maxs[i] ) ta->maxs[i] = ta->x[j][i];

	fld	DWORD PTR [esi-24]
	fld	DWORD PTR [esi+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN246@newell_spl
	fld	DWORD PTR [esi-24]
	fstp	DWORD PTR [esi+12]
$LN246@newell_spl:

; 1245 :           if ( tc->x[j][i] > tc->maxs[i] ) tc->maxs[i] = tc->x[j][i];

	fld	DWORD PTR [ecx+24]
	fld	DWORD PTR [ecx+60]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN45@newell_spl
	fld	DWORD PTR [ecx+24]
	fstp	DWORD PTR [ecx+60]
$LN45@newell_spl:

; 1235 :   {
; 1236 :      /* set mins and maxs */
; 1237 :      for ( i = 0 ; i < gdim ; i++ )

	add	ecx, 4
	add	esi, 4
	dec	edx
	jne	$LN46@newell_spl
	fstp	ST(1)
	fstp	ST(0)
$LN265@newell_spl:

; 1246 :         }
; 1247 :      }
; 1248 :      if ( ta->mins[2] > tc->mins[2] )

	fld	DWORD PTR [ebx+88]
	mov	edx, DWORD PTR _tc$[ebp]
	fld	DWORD PTR [edx+88]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN36@newell_spl

; 1249 :      { struct tsort tmp;  /* get ta as back part */
; 1250 :        tmp = *ta;

	mov	ecx, 35					; 00000023H
	mov	esi, ebx
	lea	edi, DWORD PTR _tmp$89741[ebp]
	rep movsd

; 1251 :        *ta = *tc;

	mov	ecx, 35					; 00000023H
	mov	esi, edx
	mov	edi, ebx
	rep movsd

; 1252 :        *tc = tmp;

	mov	ecx, 35					; 00000023H
	lea	esi, DWORD PTR _tmp$89741[ebp]
	mov	edi, edx
	rep movsd

; 1253 :        tmpspot = ta->spot; ta->spot = tc->spot; tc->spot = tmpspot;

	mov	ecx, DWORD PTR [edx+136]
	mov	eax, DWORD PTR [ebx+136]
	mov	DWORD PTR [ebx+136], ecx
	mov	DWORD PTR [edx+136], eax
$LN36@newell_spl:

; 1254 :      }
; 1255 :      /* find_bbox(tc); */
; 1256 :      if ( setquadcode(tc) == INTHEBOX )

	mov	esi, edx

; 1257 :      { qdepth_insert(tc);
; 1258 :        return 1;

	jmp	$LN549@newell_spl
$LN34@newell_spl:

; 1259 :      }
; 1260 :      else { tc->flag = 0; return 0; }
; 1261 :   }
; 1262 : 
; 1263 :   if ( (d0-db)*(d2-db) > 0.0 )

	fld	ST(3)
	fsub	ST(0), ST(3)
	fld	ST(1)
	fsub	ST(0), ST(4)
	fmul	ST(0), ST(1)
	fldz
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	$LN33@newell_spl

; 1265 :     short e = ta->etype[1];

	movzx	eax, WORD PTR [ebx+22]
	fstp	ST(1)
	mov	edi, DWORD PTR [ebx+12]
	fstp	ST(0)

; 1266 :     REAL d = d1;
; 1267 :     for ( i = 0 ; i < gdim ; i++ )

	xor	esi, esi
	mov	DWORD PTR _e$89746[ebp], eax
	cmp	edx, 4
	jl	SHORT $LN266@newell_spl

; 1264 :   { int c = ta->ecolor[1]; 

	lea	ecx, DWORD PTR [edx-4]
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [ebx+48]
	lea	esi, DWORD PTR [ecx*4]

; 1266 :     REAL d = d1;
; 1267 :     for ( i = 0 ; i < gdim ; i++ )

$LN250@newell_spl:

; 1268 :     { float temp = ta->x[1][i]; 

	fld	DWORD PTR [eax-4]

; 1269 :       ta->x[1][i] = ta->x[0][i]; ta->x[0][i] = ta->x[2][i];

	add	eax, 16					; 00000010H
	dec	ecx
	fstp	DWORD PTR _temp$89751[ebp]
	fld	DWORD PTR [eax-32]
	fstp	DWORD PTR [eax-20]
	fld	DWORD PTR [eax-8]
	fstp	DWORD PTR [eax-32]

; 1270 :       ta->x[2][i] = temp;

	fld	DWORD PTR _temp$89751[ebp]
	fstp	DWORD PTR [eax-8]
	fld	DWORD PTR [eax-16]
	fstp	DWORD PTR _temp$89751[ebp]
	fld	DWORD PTR [eax-28]
	fstp	DWORD PTR [eax-16]
	fld	DWORD PTR [eax-4]
	fstp	DWORD PTR [eax-28]
	fld	DWORD PTR _temp$89751[ebp]
	fstp	DWORD PTR [eax-4]
	fld	DWORD PTR [eax-12]
	fstp	DWORD PTR _temp$89751[ebp]
	fld	DWORD PTR [eax-24]
	fstp	DWORD PTR [eax-12]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [eax-24]
	fld	DWORD PTR _temp$89751[ebp]
	fstp	DWORD PTR [eax]
	fld	DWORD PTR [eax-8]
	fstp	DWORD PTR _temp$89751[ebp]
	fld	DWORD PTR [eax-20]
	fstp	DWORD PTR [eax-8]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [eax-20]
	fld	DWORD PTR _temp$89751[ebp]
	fstp	DWORD PTR [eax+4]
	jne	SHORT $LN250@newell_spl
$LN266@newell_spl:

; 1266 :     REAL d = d1;
; 1267 :     for ( i = 0 ; i < gdim ; i++ )

	cmp	esi, edx
	jge	SHORT $LN248@newell_spl
	mov	ecx, edx
	lea	eax, DWORD PTR [ebx+esi*4+32]
	sub	ecx, esi
$LC32@newell_spl:

; 1268 :     { float temp = ta->x[1][i]; 

	fld	DWORD PTR [eax+12]
	add	eax, 4
	dec	ecx
	fstp	DWORD PTR _temp$89751[ebp]

; 1269 :       ta->x[1][i] = ta->x[0][i]; ta->x[0][i] = ta->x[2][i];

	fld	DWORD PTR [eax-4]
	fstp	DWORD PTR [eax+8]
	fld	DWORD PTR [eax+20]
	fstp	DWORD PTR [eax-4]

; 1270 :       ta->x[2][i] = temp;

	fld	DWORD PTR _temp$89751[ebp]
	fstp	DWORD PTR [eax+20]
	jne	SHORT $LC32@newell_spl
$LN248@newell_spl:

; 1271 :     }
; 1272 :     ta->ecolor[1] = ta->ecolor[0]; ta->ecolor[0] = ta->ecolor[2];

	mov	ecx, DWORD PTR [ebx+8]

; 1273 :     ta->ecolor[2] = c;
; 1274 :     ta->etype[1] = ta->etype[0]; ta->etype[0] = ta->etype[2];
; 1275 :     ta->etype[2] = e;
; 1276 :     d1 = d0; d0 = d2; d2 = d;

	fst	QWORD PTR _d1$[ebp]
	mov	eax, DWORD PTR [ebx+16]
	fxch	ST(3)
	mov	DWORD PTR [ebx+12], ecx
	fst	QWORD PTR _d0$[ebp]
	movzx	ecx, WORD PTR [ebx+20]
	fxch	ST(1)
	mov	WORD PTR [ebx+22], cx
	fst	QWORD PTR _d2$[ebp]
	movzx	ecx, WORD PTR _e$89746[ebp]
	mov	DWORD PTR [ebx+8], eax
	mov	ax, WORD PTR [ebx+24]
	mov	DWORD PTR [ebx+16], edi
	mov	WORD PTR [ebx+20], ax
	mov	WORD PTR [ebx+24], cx
	jmp	$LN28@newell_spl
$LN33@newell_spl:

; 1277 :   }
; 1278 :   else if ( (d1-db)*(d2-db) > 0.0 )

	fld	ST(3)
	fsub	ST(0), ST(5)
	fmulp	ST(2), ST(0)
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	$LN430@newell_spl

; 1280 :     short e = ta->etype[1];

	movzx	eax, WORD PTR [ebx+22]
	mov	edi, DWORD PTR [ebx+12]

; 1281 :     REAL d = d1;
; 1282 :     for ( i = 0 ; i < gdim ; i++ )

	xor	esi, esi
	mov	DWORD PTR _e$89755[ebp], eax
	cmp	edx, 4
	jl	SHORT $LN267@newell_spl

; 1279 :   { int c = ta->ecolor[1]; 

	lea	ecx, DWORD PTR [edx-4]
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [ebx+48]
	lea	esi, DWORD PTR [ecx*4]

; 1281 :     REAL d = d1;
; 1282 :     for ( i = 0 ; i < gdim ; i++ )

$LN253@newell_spl:

; 1283 :     { float temp = ta->x[1][i]; 

	fld	DWORD PTR [eax-4]

; 1284 :       ta->x[1][i] = ta->x[2][i]; ta->x[2][i] = ta->x[0][i];

	add	eax, 16					; 00000010H
	dec	ecx
	fstp	DWORD PTR _temp$89760[ebp]
	fld	DWORD PTR [eax-8]
	fstp	DWORD PTR [eax-20]
	fld	DWORD PTR [eax-32]
	fstp	DWORD PTR [eax-8]

; 1285 :       ta->x[0][i] = temp;

	fld	DWORD PTR _temp$89760[ebp]
	fstp	DWORD PTR [eax-32]
	fld	DWORD PTR [eax-16]
	fstp	DWORD PTR _temp$89760[ebp]
	fld	DWORD PTR [eax-4]
	fstp	DWORD PTR [eax-16]
	fld	DWORD PTR [eax-28]
	fstp	DWORD PTR [eax-4]
	fld	DWORD PTR _temp$89760[ebp]
	fstp	DWORD PTR [eax-28]
	fld	DWORD PTR [eax-12]
	fstp	DWORD PTR _temp$89760[ebp]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [eax-12]
	fld	DWORD PTR [eax-24]
	fstp	DWORD PTR [eax]
	fld	DWORD PTR _temp$89760[ebp]
	fstp	DWORD PTR [eax-24]
	fld	DWORD PTR [eax-8]
	fstp	DWORD PTR _temp$89760[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [eax-8]
	fld	DWORD PTR [eax-20]
	fstp	DWORD PTR [eax+4]
	fld	DWORD PTR _temp$89760[ebp]
	fstp	DWORD PTR [eax-20]
	jne	SHORT $LN253@newell_spl
$LN267@newell_spl:

; 1281 :     REAL d = d1;
; 1282 :     for ( i = 0 ; i < gdim ; i++ )

	cmp	esi, edx
	jge	SHORT $LN251@newell_spl
	mov	ecx, edx
	lea	eax, DWORD PTR [ebx+esi*4+56]
	sub	ecx, esi
$LC27@newell_spl:

; 1283 :     { float temp = ta->x[1][i]; 

	fld	DWORD PTR [eax-12]
	add	eax, 4
	dec	ecx
	fstp	DWORD PTR _temp$89760[ebp]

; 1284 :       ta->x[1][i] = ta->x[2][i]; ta->x[2][i] = ta->x[0][i];

	fld	DWORD PTR [eax-4]
	fstp	DWORD PTR [eax-16]
	fld	DWORD PTR [eax-28]
	fstp	DWORD PTR [eax-4]

; 1285 :       ta->x[0][i] = temp;

	fld	DWORD PTR _temp$89760[ebp]
	fstp	DWORD PTR [eax-28]
	jne	SHORT $LC27@newell_spl
$LN251@newell_spl:

; 1286 :     }
; 1287 :     ta->ecolor[1] = ta->ecolor[2]; ta->ecolor[2] = ta->ecolor[0];

	mov	ecx, DWORD PTR [ebx+16]

; 1288 :     ta->ecolor[0] = c;
; 1289 :     ta->etype[1] = ta->etype[2]; ta->etype[2] = ta->etype[0];
; 1290 :     ta->etype[0] = e;
; 1291 :     d1 = d2; d2 = d0; d0 = d;

	fxch	ST(3)
	mov	eax, DWORD PTR [ebx+8]
	fst	QWORD PTR _d1$[ebp]
	mov	DWORD PTR [ebx+12], ecx
	fxch	ST(3)
	movzx	ecx, WORD PTR [ebx+24]
	fst	QWORD PTR _d2$[ebp]
	mov	WORD PTR [ebx+22], cx
	fxch	ST(1)
	movzx	ecx, WORD PTR _e$89755[ebp]
	fst	QWORD PTR _d0$[ebp]
	fxch	ST(1)
	mov	DWORD PTR [ebx+16], eax
	mov	ax, WORD PTR [ebx+20]
	mov	DWORD PTR [ebx+8], edi
	mov	WORD PTR [ebx+24], ax
	mov	WORD PTR [ebx+20], cx
$LN28@newell_spl:

; 1292 :   }
; 1293 : 
; 1294 : 
; 1295 :   /* copy all info to fragments */
; 1296 :   tmpspot = tc->spot; *tc = *ta; tc->spot = tmpspot;

	mov	eax, DWORD PTR _tc$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	DWORD PTR _tmpspot$[ebp], ecx
	mov	edi, eax
	mov	ecx, 35					; 00000023H
	mov	esi, ebx
	rep movsd
	mov	ecx, DWORD PTR _tmpspot$[ebp]
	mov	DWORD PTR [eax+136], ecx

; 1297 :   tmpspot = td->spot; *td = *ta; td->spot = tmpspot;

	mov	eax, DWORD PTR _td$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	DWORD PTR _tmpspot$[ebp], ecx
	mov	edi, eax
	mov	ecx, 35					; 00000023H
	mov	esi, ebx
	rep movsd
	mov	ecx, DWORD PTR _tmpspot$[ebp]
	mov	DWORD PTR [eax+136], ecx

; 1298 :   retval = 2;
; 1299 : 
; 1300 :   /* fill in fragment info */
; 1301 :   for ( i = 0 ; i < gdim ; i++ )

	xor	eax, eax
	mov	DWORD PTR _retval$[ebp], 2
	mov	DWORD PTR _i$[ebp], eax
	cmp	edx, 4
	jl	$LN268@newell_spl
	mov	edx, DWORD PTR _td$[ebp]
	fld	ST(2)
	mov	esi, DWORD PTR _tc$[ebp]
	fsub	ST(0), ST(2)

; 1304 :     tc->x[2][i] = td->x[1][i] =
; 1305 :         (float)(((db-d1)*td->x[2][i] + (d2-db)*ta->x[1][i])/(d2-d1));

	mov	edi, ebx
	fld	ST(1)
	sub	edi, edx
	fsubrp	ST(3), ST(0)
	mov	DWORD PTR tv22780[ebp], edi
	fld	ST(1)
	mov	edi, DWORD PTR _tc$[ebp]
	fsub	ST(0), ST(4)
	sub	edi, edx
	fld	ST(4)
	lea	eax, DWORD PTR [edx+32]
	fsub	ST(0), ST(6)
	mov	edx, ebx
	fxch	ST(3)
	sub	edx, DWORD PTR _tc$[ebp]
	fsubrp	ST(6), ST(0)
	mov	DWORD PTR tv22785[ebp], edi
	mov	DWORD PTR tv12264[ebp], edx
	mov	edx, DWORD PTR _gdim
	lea	edi, DWORD PTR [edx-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv23515[ebp], edi
	add	edi, edi
	add	esi, 36					; 00000024H
	add	edi, edi
	lea	ecx, DWORD PTR [ebx+48]
	mov	DWORD PTR _i$[ebp], edi
$LN269@newell_spl:

; 1302 :   { ta->x[2][i] = tc->x[0][i] = td->x[0][i] =
; 1303 :         (float)(((db-d0)*td->x[2][i] + (d2-db)*ta->x[0][i])/(d2-d0));

	mov	edi, DWORD PTR tv22780[ebp]
	fld	DWORD PTR [eax+edi]
	mov	edi, DWORD PTR tv22785[ebp]
	fmul	ST(0), ST(1)
	fld	DWORD PTR [eax+24]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(4)
	fstp	DWORD PTR tv23558[ebp]
	fld	DWORD PTR tv23558[ebp]
	fst	DWORD PTR tv843[ebp]
	fstp	DWORD PTR [eax]
	fld	DWORD PTR tv843[ebp]
	fst	DWORD PTR [eax+edi]
	fstp	DWORD PTR [ecx+8]

; 1304 :     tc->x[2][i] = td->x[1][i] =
; 1305 :         (float)(((db-d1)*td->x[2][i] + (d2-db)*ta->x[1][i])/(d2-d1));

	fld	DWORD PTR [ecx-4]
	mov	edi, DWORD PTR tv12264[ebp]
	fmul	ST(0), ST(1)
	fld	DWORD PTR [eax+24]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(6)
	fstp	DWORD PTR tv23577[ebp]
	fld	DWORD PTR tv23577[ebp]
	fst	DWORD PTR [eax+12]
	fstp	DWORD PTR [esi+20]
	fld	DWORD PTR [edi+esi]
	fmul	ST(0), ST(1)
	fld	DWORD PTR [eax+28]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(4)
	fstp	DWORD PTR tv23598[ebp]
	fld	DWORD PTR tv23598[ebp]
	fst	DWORD PTR tv843[ebp]
	fstp	DWORD PTR [eax+4]
	fld	DWORD PTR tv843[ebp]
	fst	DWORD PTR [esi]
	fstp	DWORD PTR [ecx+12]
	fld	DWORD PTR [ecx]
	fmul	ST(0), ST(1)
	fld	DWORD PTR [eax+28]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(6)
	fstp	DWORD PTR tv23613[ebp]
	fld	DWORD PTR tv23613[ebp]
	fst	DWORD PTR [eax+16]
	fstp	DWORD PTR [esi+24]
	fld	DWORD PTR [ecx-8]
	fmul	ST(0), ST(1)
	fld	DWORD PTR [eax+32]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(4)
	fstp	DWORD PTR tv23634[ebp]
	fld	DWORD PTR tv23634[ebp]
	fst	DWORD PTR tv843[ebp]
	fstp	DWORD PTR [eax+8]
	fld	DWORD PTR tv843[ebp]
	fst	DWORD PTR [esi+4]
	fstp	DWORD PTR [ecx+16]
	fld	DWORD PTR [ecx+4]
	fmul	ST(0), ST(1)
	fld	DWORD PTR [eax+32]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(6)
	fstp	DWORD PTR tv23653[ebp]
	fld	DWORD PTR tv23653[ebp]
	fst	DWORD PTR [eax+20]
	fstp	DWORD PTR [esi+28]
	fld	DWORD PTR [ecx-4]
	fmul	ST(0), ST(1)
	fld	DWORD PTR [eax+36]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(4)
	fstp	DWORD PTR tv23670[ebp]
	fld	DWORD PTR tv23670[ebp]
	fst	DWORD PTR tv843[ebp]
	fstp	DWORD PTR [eax+12]
	add	eax, 16					; 00000010H
	fld	DWORD PTR tv843[ebp]
	add	esi, 16					; 00000010H
	fst	DWORD PTR [esi-8]
	add	ecx, 16					; 00000010H
	dec	DWORD PTR tv23515[ebp]
	fstp	DWORD PTR [ecx+4]
	fld	DWORD PTR [ecx-8]
	fmul	ST(0), ST(1)
	fld	DWORD PTR [eax+20]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(6)
	fstp	DWORD PTR tv23689[ebp]
	fld	DWORD PTR tv23689[ebp]
	fst	DWORD PTR [eax+8]
	fstp	DWORD PTR [esi+16]
	jne	$LN269@newell_spl

; 1292 :   }
; 1293 : 
; 1294 : 
; 1295 :   /* copy all info to fragments */
; 1296 :   tmpspot = tc->spot; *tc = *ta; tc->spot = tmpspot;

	mov	eax, DWORD PTR _i$[ebp]
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(1)
	fstp	ST(0)
	fstp	ST(1)
	fld	QWORD PTR _d0$[ebp]
	fld	QWORD PTR _d1$[ebp]
	fld	QWORD PTR _d2$[ebp]
	fxch	ST(1)
	fxch	ST(3)
	fxch	ST(2)
	fxch	ST(1)
$LN268@newell_spl:

; 1298 :   retval = 2;
; 1299 : 
; 1300 :   /* fill in fragment info */
; 1301 :   for ( i = 0 ; i < gdim ; i++ )

	cmp	eax, edx
	jge	$LN425@newell_spl
	mov	esi, DWORD PTR _td$[ebp]
	fld	ST(2)
	mov	ecx, DWORD PTR _tc$[ebp]
	fsub	ST(0), ST(2)
	fld	ST(1)
	mov	edi, ebx
	fsubrp	ST(3), ST(0)
	sub	edi, esi
	lea	ecx, DWORD PTR [ecx+eax*4+56]
	fld	ST(1)
	fsub	ST(0), ST(4)
	mov	DWORD PTR tv22780[ebp], edi
	mov	edi, DWORD PTR _tc$[ebp]
	fxch	ST(4)
	mov	DWORD PTR tv23922[ebp], ecx
	fsub	ST(0), ST(5)
	sub	edi, esi
	fxch	ST(2)
	lea	ecx, DWORD PTR [ebx+eax*4+44]
	fsubrp	ST(5), ST(0)
	lea	eax, DWORD PTR [esi+eax*4+32]
	mov	esi, edx
	sub	esi, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv22785[ebp], edi
$LN272@newell_spl:

; 1302 :   { ta->x[2][i] = tc->x[0][i] = td->x[0][i] =
; 1303 :         (float)(((db-d0)*td->x[2][i] + (d2-db)*ta->x[0][i])/(d2-d0));

	mov	edi, DWORD PTR tv22780[ebp]
	fld	DWORD PTR [eax+edi]
	mov	edi, DWORD PTR tv22785[ebp]
	fmul	ST(0), ST(4)
	add	eax, 4
	fld	DWORD PTR [eax+20]
	add	ecx, 4
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(3)
	fstp	DWORD PTR tv24124[ebp]
	fld	DWORD PTR tv24124[ebp]
	fst	DWORD PTR tv843[ebp]
	fstp	DWORD PTR [eax-4]
	fld	DWORD PTR tv843[ebp]
	fst	DWORD PTR [eax+edi-4]
	fstp	DWORD PTR [ecx+8]

; 1304 :     tc->x[2][i] = td->x[1][i] =
; 1305 :         (float)(((db-d1)*td->x[2][i] + (d2-db)*ta->x[1][i])/(d2-d1));

	fld	DWORD PTR [eax+20]
	mov	edi, DWORD PTR tv23922[ebp]
	fmul	ST(0), ST(2)
	add	edi, 4
	dec	esi
	fld	DWORD PTR [ecx-4]
	fmul	ST(0), ST(5)
	mov	DWORD PTR tv23922[ebp], edi
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(5)
	fstp	DWORD PTR tv24299[ebp]
	fld	DWORD PTR tv24299[ebp]
	fst	DWORD PTR [eax+8]
	fstp	DWORD PTR [edi-4]
	jne	SHORT $LN272@newell_spl

; 1298 :   retval = 2;
; 1299 : 
; 1300 :   /* fill in fragment info */
; 1301 :   for ( i = 0 ; i < gdim ; i++ )

	fstp	ST(3)
	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(1)
$LN545@newell_spl:

; 1306 :   }
; 1307 :   /* internal edges invisible */
; 1308 :   ta->etype[1] = tc->etype[0] = tc->etype[2] = td->etype[0] = SPLITTING_EDGE;

	mov	ecx, DWORD PTR _td$[ebp]
	fstp	ST(0)
	mov	eax, 128				; 00000080H
	mov	WORD PTR [ecx+20], ax
	mov	ecx, eax
	mov	eax, DWORD PTR _tc$[ebp]
	mov	WORD PTR [eax+24], cx
	mov	WORD PTR [eax+20], cx
	mov	eax, ecx
	mov	WORD PTR [ebx+22], ax

; 1309 : 
; 1310 :   /* set mins and maxs */
; 1311 :   for ( i = 0 ; i < gdim ; i++ )

	test	edx, edx
	jle	$LN19@newell_spl

; 1306 :   }
; 1307 :   /* internal edges invisible */
; 1308 :   ta->etype[1] = tc->etype[0] = tc->etype[2] = td->etype[0] = SPLITTING_EDGE;

	mov	ecx, DWORD PTR _td$[ebp]
	fld	DWORD PTR __real@7149f2ca
	fld	DWORD PTR __real@f149f2ca
	lea	eax, DWORD PTR [ecx+92]
	mov	DWORD PTR tv24791[ebp], eax
	mov	eax, DWORD PTR _tc$[ebp]

; 1312 :   { int j;
; 1313 :     ta->mins[i] = tc->mins[i] = td->mins[i] = (float)1e30;

	sub	ecx, eax
	mov	edi, ebx
	lea	esi, DWORD PTR [eax+80]
	sub	edi, eax
	mov	eax, ebx
	sub	eax, DWORD PTR _td$[ebp]
	mov	DWORD PTR tv24952[ebp], edx
	mov	DWORD PTR tv24598[ebp], ecx
	mov	DWORD PTR tv22780[ebp], eax
	mov	edx, ecx
$LN21@newell_spl:

; 1314 :     ta->maxs[i] = tc->maxs[i] = td->maxs[i] = (float)(-1e30);

	mov	eax, DWORD PTR tv24791[ebp]
	fxch	ST(1)
	mov	ecx, DWORD PTR tv22780[ebp]
	fst	DWORD PTR [esi+edx]
	fst	DWORD PTR [esi]
	mov	DWORD PTR tv24569[ebp], 3
	fst	DWORD PTR [edi+esi]
	fxch	ST(1)
	fst	DWORD PTR [eax]
	fst	DWORD PTR [esi+12]
	fst	DWORD PTR [ecx+eax]
	lea	ecx, DWORD PTR [esi-48]
$LN18@newell_spl:

; 1316 :     { if ( ta->x[j][i] < ta->mins[i] ) ta->mins[i] = ta->x[j][i];

	fld	DWORD PTR [edi+ecx]
	fld	DWORD PTR [edi+esi]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN15@newell_spl
	fld	DWORD PTR [edi+ecx]
	fstp	DWORD PTR [edi+esi]
$LN15@newell_spl:

; 1317 :       if ( tc->x[j][i] < tc->mins[i] ) tc->mins[i] = tc->x[j][i];

	fld	DWORD PTR [ecx]
	fld	DWORD PTR [esi]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN14@newell_spl
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [esi]
$LN14@newell_spl:

; 1318 :       if ( td->x[j][i] < td->mins[i] ) td->mins[i] = td->x[j][i];

	fld	DWORD PTR [ecx+edx]
	fld	DWORD PTR [esi+edx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN13@newell_spl
	fld	DWORD PTR [ecx+edx]
	fstp	DWORD PTR [esi+edx]
$LN13@newell_spl:

; 1319 :       if ( ta->x[j][i] > ta->maxs[i] ) ta->maxs[i] = ta->x[j][i];

	mov	eax, DWORD PTR tv22780[ebp]
	fld	DWORD PTR [edi+ecx]
	mov	edx, DWORD PTR tv24791[ebp]
	fld	DWORD PTR [eax+edx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN12@newell_spl
	fld	DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR tv22780[ebp]
	fstp	DWORD PTR [eax+edx]
$LN12@newell_spl:

; 1320 :       if ( tc->x[j][i] > tc->maxs[i] ) tc->maxs[i] = tc->x[j][i];

	fld	DWORD PTR [ecx]
	fld	DWORD PTR [esi+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN11@newell_spl
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [esi+12]
$LN11@newell_spl:

; 1321 :       if ( td->x[j][i] > td->maxs[i] ) td->maxs[i] = td->x[j][i];

	mov	edx, DWORD PTR tv24598[ebp]
	mov	eax, DWORD PTR tv24791[ebp]
	fld	DWORD PTR [ecx+edx]
	fld	DWORD PTR [eax]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN17@newell_spl
	fld	DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR tv24791[ebp]
	fstp	DWORD PTR [eax]
$LN17@newell_spl:

; 1315 :     for ( j = 0 ; j < 3 ; j++ )

	add	ecx, 12					; 0000000cH
	dec	DWORD PTR tv24569[ebp]
	jne	$LN18@newell_spl

; 1309 : 
; 1310 :   /* set mins and maxs */
; 1311 :   for ( i = 0 ; i < gdim ; i++ )

	add	DWORD PTR tv24791[ebp], 4
	add	esi, 4
	dec	DWORD PTR tv24952[ebp]
	jne	$LN21@newell_spl
	fstp	ST(1)
	fstp	ST(0)
$LN19@newell_spl:

; 1322 :     }
; 1323 :   }
; 1324 : 
; 1325 :   /* get ta as back part */
; 1326 :   if ( (tc->mins[2] < ta->mins[2]) && (tc->mins[2] <= td->mins[2]) )

	mov	ecx, DWORD PTR _tc$[ebp]
	fld	DWORD PTR [ecx+88]
	fld	DWORD PTR [ebx+88]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN271@newell_spl
	fld	DWORD PTR [ecx+88]
	mov	ecx, DWORD PTR _td$[ebp]
	fld	DWORD PTR [ecx+88]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN271@newell_spl

; 1327 :   { struct tsort tmp;  /* get ta as back part */
; 1328 :     tmp = *ta;
; 1329 :     *ta = *tc;

	mov	eax, DWORD PTR _tc$[ebp]

; 1330 :     *tc = tmp;
; 1331 :     tmpspot = ta->spot; ta->spot = tc->spot; tc->spot = tmpspot;

	jmp	SHORT $LN546@newell_spl
$LN430@newell_spl:

; 1277 :   }
; 1278 :   else if ( (d1-db)*(d2-db) > 0.0 )

	fxch	ST(1)
	fxch	ST(3)
	jmp	$LN28@newell_spl
$LN425@newell_spl:

; 1298 :   retval = 2;
; 1299 : 
; 1300 :   /* fill in fragment info */
; 1301 :   for ( i = 0 ; i < gdim ; i++ )

	fstp	ST(1)
	fstp	ST(0)
	fstp	ST(0)
	jmp	$LN545@newell_spl
$LN271@newell_spl:

; 1332 :   }
; 1333 :   else if ( td->mins[2] < ta->mins[2] )

	mov	eax, DWORD PTR _td$[ebp]
	fld	DWORD PTR [eax+88]
	fld	DWORD PTR [ebx+88]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN7@newell_spl

; 1336 :     *ta = *td;

	mov	eax, DWORD PTR _td$[ebp]
$LN546@newell_spl:

; 1334 :   { struct tsort tmp;  /* get ta as back part */
; 1335 :     tmp = *ta;

	mov	ecx, 35					; 00000023H
	lea	edi, DWORD PTR _tmp$89785[ebp]
	mov	esi, ebx
	rep movsd

; 1336 :     *ta = *td;

	mov	ecx, 35					; 00000023H
	mov	edi, ebx
	mov	esi, eax
	rep movsd

; 1337 :     *td = tmp;

	mov	ecx, 35					; 00000023H
	mov	edi, eax
	lea	esi, DWORD PTR _tmp$89785[ebp]
	rep movsd

; 1338 :     tmpspot = ta->spot; ta->spot = td->spot; td->spot = tmpspot;

	mov	edx, DWORD PTR [eax+136]
	mov	ecx, DWORD PTR [ebx+136]
	mov	DWORD PTR [ebx+136], edx
	mov	DWORD PTR [eax+136], ecx
$LN7@newell_spl:

; 1339 :   }
; 1340 : 
; 1341 :   /* find_bbox(tc); */
; 1342 :   /* find_bbox(td); */
; 1343 :   if ( setquadcode(tc) == INTHEBOX )

	mov	ebx, DWORD PTR _tc$[ebp]
	push	ebx
	call	_setquadcode
	add	esp, 4

; 1344 :   { qdepth_insert(tc);

	push	ebx
	cmp	eax, 1
	jne	SHORT $LN6@newell_spl
	call	_qdepth_insert

; 1345 :     if ( setquadcode(td) == INTHEBOX )

	mov	edi, DWORD PTR _td$[ebp]
	push	edi
	call	_setquadcode
	add	esp, 8
	cmp	eax, 1
	jne	SHORT $LN5@newell_spl

; 1346 :       qdepth_insert(td);

	push	edi
	call	_qdepth_insert
	mov	esi, DWORD PTR _retval$[ebp]
	add	esp, 4
	pop	edi

; 1359 :   }
; 1360 :   return retval;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1361 : } // end newell_split()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@newell_spl:

; 1347 :     else { retval--; td->flag = 0; td->next = (struct tsort *)0xFF; }

	mov	esi, 1
	mov	DWORD PTR [edi+28], 0
	mov	DWORD PTR [edi+132], 255		; 000000ffH
	pop	edi

; 1359 :   }
; 1360 :   return retval;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1361 : } // end newell_split()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@newell_spl:

; 1348 :   }
; 1349 :   else
; 1350 :   { /* discard tc */
; 1351 :     tmpspot = tc->spot;
; 1352 :     *tc = *td; 

	mov	eax, DWORD PTR _td$[ebp]
	mov	edx, DWORD PTR [ebx+136]
	mov	esi, eax
	mov	ecx, 35					; 00000023H
	mov	edi, ebx
	rep movsd

; 1353 :     tc->spot = tmpspot;

	mov	DWORD PTR [ebx+136], edx

; 1354 :     td->flag = 0; td->next = (struct tsort *)0xAA;

	xor	edi, edi
	mov	DWORD PTR [eax+28], edi
	mov	DWORD PTR [eax+132], 170		; 000000aaH

; 1355 :     retval--;

	lea	esi, DWORD PTR [edi+1]

; 1356 :     if ( setquadcode(tc) == INTHEBOX )

	call	_setquadcode
	add	esp, 4
	cmp	eax, esi
	jne	SHORT $LN2@newell_spl

; 1357 :       qdepth_insert(tc);

	push	ebx
	call	_qdepth_insert
	add	esp, 4
	pop	edi

; 1359 :   }
; 1360 :   return retval;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1361 : } // end newell_split()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@newell_spl:

; 1358 :     else { retval--; tc->flag = 0; tc->next = (struct tsort *)0xEE; }

	xor	esi, esi
	mov	DWORD PTR [ebx+28], edi
	pop	edi

; 1359 :   }
; 1360 :   return retval;

	mov	eax, esi
	pop	esi
	mov	DWORD PTR [ebx+132], 238		; 000000eeH
	pop	ebx

; 1361 : } // end newell_split()

	mov	esp, ebp
	pop	ebp
	ret	0
_newell_split ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	__real@3f1a36e2eb1c432d
PUBLIC	_tb$GSCopy$
PUBLIC	_ta$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_separating_plane
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@3f1a36e2eb1c432d
CONST	SEGMENT
__real@3f1a36e2eb1c432d DQ 03f1a36e2eb1c432dr	; 0.0001
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _separating_plane
_TEXT	SEGMENT
_b$ = -164						; size = 12
tv1969 = -156						; size = 8
_db$ = -156						; size = 8
_a$ = -148						; size = 12
tv1986 = -140						; size = 8
_da$ = -140						; size = 8
_bfar$ = -132						; size = 4
tv1959 = -128						; size = 4
_nna$ = -128						; size = 4
_beq$ = -124						; size = 4
_tb$GSCopy$ = -120					; size = 4
_ta$GSCopy$ = -116					; size = 4
_i$ = -112						; size = 4
_aeq$ = -112						; size = 4
_j$ = -108						; size = 4
_anear$ = -108						; size = 4
tv1699 = -104						; size = 4
tv401 = -104						; size = 4
_na$ = -104						; size = 4
_s$89848 = -100						; size = 24
_dbr$89851 = -76					; size = 24
_dar$89850 = -76					; size = 24
_da$89845 = -52						; size = 24
_db$89846 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_ta$ = 8						; size = 4
_tb$ = 12						; size = 4
_depth$ = 16						; size = 4
_separating_plane PROC					; COMDAT

; 1377 : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1378 :   int na,nb; /* vertices on respective elements */
; 1379 :   int nna; /* number of vertex pairs to check on ta */
; 1380 :   float *a[3],*b[3];
; 1381 :   int retval;
; 1382 :   REAL da,db,d;
; 1383 :   int n,k,bnear=0,beq=0,bfar=0,anear=0,afar=0,aeq=0;
; 1384 : 
; 1385 :   sep_plane_calls++;  /* for verbose statistics */

	fld	QWORD PTR _sep_plane_calls
	mov	eax, DWORD PTR _ta$[ebp]
	fadd	QWORD PTR __real@3ff0000000000000
	push	ebx
	mov	ebx, DWORD PTR _tb$[ebp]
	push	esi
	fstp	QWORD PTR _sep_plane_calls

; 1386 : 
; 1387 :   /* see where tb is with respect to ta plane */
; 1388 :   if ( (ta->flag & 0xF) == FACET  )

	mov	ecx, DWORD PTR [eax+28]
	xor	esi, esi
	and	cl, 15					; 0000000fH
	push	edi
	mov	DWORD PTR _ta$GSCopy$[ebp], eax
	mov	DWORD PTR _tb$GSCopy$[ebp], ebx
	mov	DWORD PTR _beq$[ebp], esi
	mov	DWORD PTR _bfar$[ebp], esi
	mov	DWORD PTR _anear$[ebp], esi
	mov	DWORD PTR _aeq$[ebp], esi
	cmp	cl, 2
	jne	$LN57@separating

; 1389 :   { da = dotf(ta->normal,ta->x[0],gdim);

	mov	edx, DWORD PTR _gdim
	lea	ecx, DWORD PTR [eax+68]
	push	edx
	add	eax, 32					; 00000020H
	push	eax
	push	ecx
	mov	DWORD PTR tv1959[ebp], ecx
	call	_dotf
	fst	QWORD PTR _da$[ebp]

; 1390 :     n = ((tb->flag & 0xF) == FACET) ? 3 : 2;

	mov	eax, DWORD PTR [ebx+28]
	xor	ecx, ecx
	and	al, 15					; 0000000fH
	add	esp, 12					; 0000000cH
	cmp	al, 2
	sete	cl
	lea	edi, DWORD PTR [ecx+2]

; 1391 :     for ( k = 0 ; k < n ; k++ )

	cmp	edi, esi
	jle	SHORT $LN166@separating

; 1389 :   { da = dotf(ta->normal,ta->x[0],gdim);

	fsub	QWORD PTR __real@3f1a36e2eb1c432d
	lea	esi, DWORD PTR [ebx+32]
	mov	DWORD PTR tv1699[ebp], edi

; 1391 :     for ( k = 0 ; k < n ; k++ )

	fstp	QWORD PTR tv1969[ebp]
	npad	7
$LL63@separating:

; 1392 :     { d = dotf(ta->normal,tb->x[k],gdim); 

	mov	edx, DWORD PTR _gdim
	mov	eax, DWORD PTR tv1959[ebp]
	push	edx
	push	esi
	push	eax
	call	_dotf

; 1393 :       if ( d < da - 0.0001 ) { bnear++; continue; }

	fld	QWORD PTR tv1969[ebp]
	fcomp	ST(1)
	add	esp, 12					; 0000000cH
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN169@separating

; 1394 :       if ( d < da + 0.0001 ) { beq++; continue; }

	fld	QWORD PTR _da$[ebp]
	fadd	QWORD PTR __real@3f1a36e2eb1c432d
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN59@separating
	inc	DWORD PTR _beq$[ebp]
	jmp	SHORT $LN62@separating
$LN59@separating:

; 1395 :       bfar++;

	inc	DWORD PTR _bfar$[ebp]
	jmp	SHORT $LN62@separating
$LN169@separating:
	fstp	ST(0)
$LN62@separating:

; 1391 :     for ( k = 0 ; k < n ; k++ )

	add	esi, 12					; 0000000cH
	dec	DWORD PTR tv1699[ebp]
	jne	SHORT $LL63@separating
	jmp	SHORT $LN161@separating
$LN166@separating:
	fstp	ST(0)
$LN161@separating:

; 1396 :     }
; 1397 :     if ( beq == n ) 

	cmp	DWORD PTR _beq$[ebp], edi
	jne	SHORT $LN58@separating

; 1398 :       return ((tb->flag&0xF)==EDGE)?FIRST_BACK:DISJOINT; /* in same plane */

	mov	ecx, DWORD PTR [ebx+28]
	and	cl, 15					; 0000000fH
	dec	cl
	movsx	eax, cl
	neg	eax
	pop	edi
	sbb	eax, eax
	pop	esi
	add	eax, 2
	pop	ebx

; 1479 :   return retval;
; 1480 : 
; 1481 : } // end separating_plane()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN58@separating:

; 1399 :     if ( bfar == 0 ) return FIRST_BACK;

	cmp	DWORD PTR _bfar$[ebp], 0
	je	$LN319@separating
$LN57@separating:

; 1400 :   }
; 1401 : 
; 1402 :   /* see where ta is with respect to tb plane */
; 1403 :   if ( (tb->flag & 0xF) == FACET )

	mov	edx, DWORD PTR [ebx+28]
	and	dl, 15					; 0000000fH
	cmp	dl, 2
	jne	$LN158@separating

; 1404 :   { db = dotf(tb->normal,tb->x[0],gdim);

	mov	ecx, DWORD PTR _gdim
	mov	eax, ebx
	lea	ebx, DWORD PTR [eax+68]
	push	ecx
	add	eax, 32					; 00000020H
	push	eax
	push	ebx
	call	_dotf
	fst	QWORD PTR _db$[ebp]

; 1405 :     n = ((ta->flag & 0xF) == FACET) ? 3 : 2;

	mov	edx, DWORD PTR _ta$GSCopy$[ebp]
	mov	eax, DWORD PTR [edx+28]
	xor	ecx, ecx
	and	al, 15					; 0000000fH
	add	esp, 12					; 0000000cH
	cmp	al, 2
	sete	cl
	lea	edi, DWORD PTR [ecx+2]

; 1406 :     for ( k = 0 ; k < n ; k++ )

	test	edi, edi
	jle	SHORT $LN172@separating

; 1404 :   { db = dotf(tb->normal,tb->x[0],gdim);

	fsub	QWORD PTR __real@3f1a36e2eb1c432d
	mov	esi, edx
	add	esi, 32					; 00000020H
	mov	DWORD PTR tv401[ebp], edi

; 1406 :     for ( k = 0 ; k < n ; k++ )

	fstp	QWORD PTR tv1986[ebp]
$LL55@separating:

; 1407 :     { d = dotf(tb->normal,ta->x[k],gdim); 

	mov	edx, DWORD PTR _gdim
	push	edx
	push	esi
	push	ebx
	call	_dotf

; 1408 :       if ( d < db - 0.0001 ) { anear++; continue; }

	fld	QWORD PTR tv1986[ebp]
	fcomp	ST(1)
	add	esp, 12					; 0000000cH
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN52@separating
	inc	DWORD PTR _anear$[ebp]
	fstp	ST(0)
	jmp	SHORT $LN54@separating
$LN52@separating:

; 1409 :       if ( d < db + 0.0001 ) { aeq++; continue; }

	fld	QWORD PTR _db$[ebp]
	fadd	QWORD PTR __real@3f1a36e2eb1c432d
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN54@separating
	inc	DWORD PTR _aeq$[ebp]
$LN54@separating:

; 1406 :     for ( k = 0 ; k < n ; k++ )

	add	esi, 12					; 0000000cH
	dec	DWORD PTR tv401[ebp]
	jne	SHORT $LL55@separating
	jmp	SHORT $LN157@separating
$LN172@separating:
	fstp	ST(0)
$LN157@separating:

; 1410 :       afar++;
; 1411 :     }
; 1412 :     if ( aeq == n ) 

	cmp	DWORD PTR _aeq$[ebp], edi
	jne	SHORT $LN50@separating

; 1413 :       return ((ta->flag&0xF)==EDGE)?SECOND_BACK:DISJOINT; /* same plane */

	mov	eax, DWORD PTR _ta$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	cl, 15					; 0000000fH
	dec	cl
	movsx	eax, cl
	neg	eax
	sbb	eax, eax
	pop	edi
	and	eax, -3					; fffffffdH
	pop	esi
	add	eax, 4
	pop	ebx

; 1479 :   return retval;
; 1480 : 
; 1481 : } // end separating_plane()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@separating:

; 1414 :      if ( anear == 0 ) return FIRST_BACK;

	cmp	DWORD PTR _anear$[ebp], 0
	je	$LN319@separating
$LN158@separating:

; 1415 :   }
; 1416 :   
; 1417 :   na = (ta->flag & 0xF) == FACET ? 3 : 2;

	mov	edx, DWORD PTR _ta$GSCopy$[ebp]
	mov	eax, DWORD PTR [edx+28]

; 1418 :   nna = (ta->flag & 0xF) == FACET ? 3 : 1;
; 1419 :   nb = (tb->flag & 0xF) == FACET ? 3 : 2;

	mov	edx, DWORD PTR _tb$GSCopy$[ebp]
	and	eax, 15					; 0000000fH
	xor	ebx, ebx
	cmp	eax, 2
	sete	bl
	xor	ecx, ecx

; 1420 : 
; 1421 :   for ( i = 0 ; i < nna ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	add	ebx, 2
	cmp	eax, 2
	mov	eax, DWORD PTR [edx+28]
	sete	cl
	and	al, 15					; 0000000fH
	mov	DWORD PTR _na$[ebp], ebx
	lea	edi, DWORD PTR [ecx+ecx+1]
	xor	ecx, ecx
	cmp	al, 2
	sete	cl
	mov	DWORD PTR _nna$[ebp], edi
	lea	esi, DWORD PTR [ecx+2]
	test	edi, edi
	jle	$LN46@separating
	npad	6
$LL164@separating:

; 1422 :   for ( j = 0 ; j < nb ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	test	esi, esi
	jle	$LN47@separating
	npad	1
$LL159@separating:

; 1423 :   { REAL c[3],d; /* coefficients for plane */
; 1424 :     REAL da[3],db[3],minarea,s[3],length,dar[3],dbr[3];
; 1425 :     int ii,jj,jjj;
; 1426 : 
; 1427 :     for ( ii = 0 ; ii < na ; ii++ )

	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN40@separating
	mov	edi, DWORD PTR _ta$GSCopy$[ebp]
	npad	7
$LL42@separating:

; 1428 :        a[ii] = ta->x[(i+ii)%na];

	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx]
	cdq
	idiv	DWORD PTR _na$[ebp]
	mov	ebx, DWORD PTR _na$[ebp]
	inc	ecx
	lea	eax, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [edi+eax*4+32]
	mov	DWORD PTR _a$[ebp+ecx*4-4], edx
	cmp	ecx, ebx
	jl	SHORT $LL42@separating
$LN40@separating:

; 1429 :     for ( jj = 0 ; jj < nb ; jj++ )

	mov	edi, DWORD PTR _tb$GSCopy$[ebp]
	xor	ecx, ecx
$LL39@separating:

; 1430 :        b[jj] = tb->x[(j+jj)%nb];

	mov	eax, DWORD PTR _j$[ebp]
	add	eax, ecx
	cdq
	idiv	esi
	inc	ecx
	lea	edx, DWORD PTR [edx+edx*2]
	lea	eax, DWORD PTR [edi+edx*4+32]
	mov	DWORD PTR _b$[ebp+ecx*4-4], eax
	cmp	ecx, esi
	jl	SHORT $LL39@separating

; 1431 :     for ( ii = 0 ; ii < 3 ; ii++ ) s[ii] = a[1][ii]-a[0][ii];

	mov	eax, DWORD PTR _a$[ebp+4]
	mov	edi, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [edi]
	fst	QWORD PTR _s$89848[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [edi+4]
	fst	QWORD PTR _s$89848[ebp+8]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [edi+8]
	fst	QWORD PTR _s$89848[ebp+16]

; 1432 :        length = sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]);

	fld	ST(1)
	fmulp	ST(2), ST(0)
	fld	ST(2)
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt

; 1433 :     minarea = 1e-4*length;

	fmul	QWORD PTR __real@3f1a36e2eb1c432d

; 1434 :     c[0] = s[1]*(b[0][2]-a[0][2]) - s[2]*(b[0][1]-a[0][1]);

	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [edi+8]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [edi+4]
	fld	ST(1)
	fld	QWORD PTR _s$89848[ebp+8]
	fmul	ST(1), ST(0)
	fld	ST(2)
	fld	QWORD PTR _s$89848[ebp+16]
	fmul	ST(1), ST(0)
	fxch	ST(3)
	fsubrp	ST(1), ST(0)

; 1435 :     c[1] = s[2]*(b[0][0]-a[0][0]) - s[0]*(b[0][2]-a[0][2]);

	fld	DWORD PTR [eax]
	fsub	DWORD PTR [edi]
	fld	ST(0)
	fmulp	ST(4), ST(0)
	fld	QWORD PTR _s$89848[ebp]
	fmul	ST(6), ST(0)
	fxch	ST(4)
	fsubrp	ST(6), ST(0)

; 1436 :     c[2] = s[0]*(b[0][1]-a[0][1]) - s[1]*(b[0][0]-a[0][0]);

	fxch	ST(4)
	fmulp	ST(3), ST(0)
	fxch	ST(3)
	fmulp	ST(1), ST(0)
	fsubp	ST(1), ST(0)

; 1437 : 
; 1438 :     if ( c[0]*c[0] + c[1]*c[1] + c[2]*c[2] <= minarea*minarea ) 

	fld	ST(2)
	fmul	ST(0), ST(3)
	fld	ST(2)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	ST(1)
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fld	ST(4)
	fmul	ST(0), ST(5)
	fcompp
	fnstsw	ax
	test	ah, 1
	je	$LN178@separating

; 1439 :          continue; /* degenerate */
; 1440 : 
; 1441 :     d = c[0]*a[0][0] + c[1]*a[0][1] + c[2]*a[0][2];

	fld	DWORD PTR [edi]

; 1442 : 
; 1443 :     for ( ii = 2 ; ii < na ; ii++ )

	mov	ecx, 2
	fmul	ST(0), ST(2)
	fld	DWORD PTR [edi+4]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fld	DWORD PTR [edi+8]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	cmp	ebx, ecx
	jle	$LN155@separating
	lea	edx, DWORD PTR [ebx-2]
	cmp	edx, 4
	jl	$LN154@separating
	fld	ST(4)
	lea	edx, DWORD PTR [ebx-3]
	fchs
$LN128@separating:

; 1444 :     { dar[ii] = c[0]*a[ii][0] + c[1]*a[ii][1] +c[2]*a[ii][2] - d;

	mov	eax, DWORD PTR _a$[ebp+ecx*4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(5)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+8]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(2)
	fst	QWORD PTR _dar$89850[ebp+ecx*8]

; 1445 :       da[ii] = ( dar[ii] < -minarea ? -1.0 : ( dar[ii] > minarea ? 1.0 : 0.0));

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN112@separating
	fstp	ST(0)
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN114@separating
$LN112@separating:
	fcomp	ST(6)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN113@separating
	fld1
	jmp	SHORT $LN114@separating
$LN113@separating:
	fldz
$LN114@separating:

; 1444 :     { dar[ii] = c[0]*a[ii][0] + c[1]*a[ii][1] +c[2]*a[ii][2] - d;

	mov	eax, DWORD PTR _a$[ebp+ecx*4+4]

; 1445 :       da[ii] = ( dar[ii] < -minarea ? -1.0 : ( dar[ii] > minarea ? 1.0 : 0.0));

	fstp	QWORD PTR _da$89845[ebp+ecx*8]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(5)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+8]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(2)
	fst	QWORD PTR _dar$89850[ebp+ecx*8+8]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN116@separating
	fstp	ST(0)
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN118@separating
$LN116@separating:
	fcomp	ST(6)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN117@separating
	fld1
	jmp	SHORT $LN118@separating
$LN117@separating:
	fldz
$LN118@separating:

; 1444 :     { dar[ii] = c[0]*a[ii][0] + c[1]*a[ii][1] +c[2]*a[ii][2] - d;

	mov	eax, DWORD PTR _a$[ebp+ecx*4+8]

; 1445 :       da[ii] = ( dar[ii] < -minarea ? -1.0 : ( dar[ii] > minarea ? 1.0 : 0.0));

	fstp	QWORD PTR _da$89845[ebp+ecx*8+8]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(5)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+8]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(2)
	fst	QWORD PTR _dar$89850[ebp+ecx*8+16]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN120@separating
	fstp	ST(0)
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN122@separating
$LN120@separating:
	fcomp	ST(6)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN121@separating
	fld1
	jmp	SHORT $LN122@separating
$LN121@separating:
	fldz
$LN122@separating:

; 1444 :     { dar[ii] = c[0]*a[ii][0] + c[1]*a[ii][1] +c[2]*a[ii][2] - d;

	mov	eax, DWORD PTR _a$[ebp+ecx*4+12]

; 1445 :       da[ii] = ( dar[ii] < -minarea ? -1.0 : ( dar[ii] > minarea ? 1.0 : 0.0));

	fstp	QWORD PTR _da$89845[ebp+ecx*8+16]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(5)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+8]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(2)
	fst	QWORD PTR _dar$89850[ebp+ecx*8+24]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN124@separating
	fstp	ST(0)
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN126@separating
$LN124@separating:
	fcomp	ST(6)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN125@separating
	fld1
	jmp	SHORT $LN126@separating
$LN125@separating:
	fldz
$LN126@separating:
	fstp	QWORD PTR _da$89845[ebp+ecx*8+24]
	add	ecx, 4
	cmp	ecx, edx
	jl	$LN128@separating

; 1442 : 
; 1443 :     for ( ii = 2 ; ii < na ; ii++ )

	fstp	ST(0)
$LN154@separating:
	cmp	ecx, ebx
	jge	SHORT $LN155@separating
	fld	ST(4)
	fchs
$LC32@separating:

; 1444 :     { dar[ii] = c[0]*a[ii][0] + c[1]*a[ii][1] +c[2]*a[ii][2] - d;

	mov	eax, DWORD PTR _a$[ebp+ecx*4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(5)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+8]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(2)
	fst	QWORD PTR _dar$89850[ebp+ecx*8]

; 1445 :       da[ii] = ( dar[ii] < -minarea ? -1.0 : ( dar[ii] > minarea ? 1.0 : 0.0));

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN69@separating
	fstp	ST(0)
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN68@separating
$LN69@separating:
	fcomp	ST(6)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN67@separating
	fld1
	jmp	SHORT $LN68@separating
$LN67@separating:
	fldz
$LN68@separating:
	fstp	QWORD PTR _da$89845[ebp+ecx*8]
	inc	ecx
	cmp	ecx, ebx
	jl	SHORT $LC32@separating

; 1442 : 
; 1443 :     for ( ii = 2 ; ii < na ; ii++ )

	fstp	ST(0)
$LN155@separating:

; 1446 :     }
; 1447 :     for ( jj = 1 ; jj < nb ; jj++ )

	mov	ecx, 1
	cmp	esi, ecx
	jle	$LN228@separating
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, 4
	jl	$LC130@separating
	fld	ST(4)
	lea	edx, DWORD PTR [esi-3]
	fchs
$LN147@separating:

; 1448 :     { dbr[jj] = c[0]*b[jj][0] + c[1]*b[jj][1] +c[2]*b[jj][2] - d;

	mov	eax, DWORD PTR _b$[ebp+ecx*4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(5)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+8]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(2)
	fst	QWORD PTR _dbr$89851[ebp+ecx*8]

; 1449 :       db[jj] = ( dbr[jj] < -minarea ? -1.0 : ( dbr[jj] > minarea ? 1.0 : 0.0));

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN131@separating
	fstp	ST(0)
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN133@separating
$LN131@separating:
	fcomp	ST(6)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN132@separating
	fld1
	jmp	SHORT $LN133@separating
$LN132@separating:
	fldz
$LN133@separating:

; 1448 :     { dbr[jj] = c[0]*b[jj][0] + c[1]*b[jj][1] +c[2]*b[jj][2] - d;

	mov	eax, DWORD PTR _b$[ebp+ecx*4+4]

; 1449 :       db[jj] = ( dbr[jj] < -minarea ? -1.0 : ( dbr[jj] > minarea ? 1.0 : 0.0));

	fstp	QWORD PTR _db$89846[ebp+ecx*8]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(5)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+8]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(2)
	fst	QWORD PTR _dbr$89851[ebp+ecx*8+8]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN135@separating
	fstp	ST(0)
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN137@separating
$LN135@separating:
	fcomp	ST(6)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN136@separating
	fld1
	jmp	SHORT $LN137@separating
$LN136@separating:
	fldz
$LN137@separating:

; 1448 :     { dbr[jj] = c[0]*b[jj][0] + c[1]*b[jj][1] +c[2]*b[jj][2] - d;

	mov	eax, DWORD PTR _b$[ebp+ecx*4+8]

; 1449 :       db[jj] = ( dbr[jj] < -minarea ? -1.0 : ( dbr[jj] > minarea ? 1.0 : 0.0));

	fstp	QWORD PTR _db$89846[ebp+ecx*8+8]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(5)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+8]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(2)
	fst	QWORD PTR _dbr$89851[ebp+ecx*8+16]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN139@separating
	fstp	ST(0)
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN141@separating
$LN139@separating:
	fcomp	ST(6)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN140@separating
	fld1
	jmp	SHORT $LN141@separating
$LN140@separating:
	fldz
$LN141@separating:

; 1448 :     { dbr[jj] = c[0]*b[jj][0] + c[1]*b[jj][1] +c[2]*b[jj][2] - d;

	mov	eax, DWORD PTR _b$[ebp+ecx*4+12]

; 1449 :       db[jj] = ( dbr[jj] < -minarea ? -1.0 : ( dbr[jj] > minarea ? 1.0 : 0.0));

	fstp	QWORD PTR _db$89846[ebp+ecx*8+16]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(5)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+8]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(2)
	fst	QWORD PTR _dbr$89851[ebp+ecx*8+24]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN143@separating
	fstp	ST(0)
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN145@separating
$LN143@separating:
	fcomp	ST(6)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN144@separating
	fld1
	jmp	SHORT $LN145@separating
$LN144@separating:
	fldz
$LN145@separating:
	fstp	QWORD PTR _db$89846[ebp+ecx*8+24]
	add	ecx, 4
	cmp	ecx, edx
	jl	$LN147@separating

; 1446 :     }
; 1447 :     for ( jj = 1 ; jj < nb ; jj++ )

	fstp	ST(0)
$LC130@separating:
	cmp	ecx, esi
	jge	$LN228@separating
	fld	ST(4)
	fchs
$LC29@separating:

; 1448 :     { dbr[jj] = c[0]*b[jj][0] + c[1]*b[jj][1] +c[2]*b[jj][2] - d;

	mov	eax, DWORD PTR _b$[ebp+ecx*4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(5)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fld	DWORD PTR [eax+8]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(2)
	fst	QWORD PTR _dbr$89851[ebp+ecx*8]

; 1449 :       db[jj] = ( dbr[jj] < -minarea ? -1.0 : ( dbr[jj] > minarea ? 1.0 : 0.0));

	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN73@separating
	fstp	ST(0)
	fld	QWORD PTR __real@bff0000000000000
	jmp	SHORT $LN72@separating
$LN73@separating:
	fcomp	ST(6)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN71@separating
	fld1
	jmp	SHORT $LN72@separating
$LN71@separating:
	fldz
$LN72@separating:
	fstp	QWORD PTR _db$89846[ebp+ecx*8]
	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LC29@separating

; 1446 :     }
; 1447 :     for ( jj = 1 ; jj < nb ; jj++ )

	fstp	ST(3)
	fstp	ST(3)
$LN317@separating:
	fstp	ST(2)

; 1450 :     }
; 1451 : 
; 1452 :     /* test opposite sidedness */
; 1453 :     for ( jj = 1 ; jj < nb ; jj++ )

	mov	eax, 1
	fstp	ST(0)
	fstp	ST(1)
	fldz
	cmp	esi, eax
	jle	SHORT $LN24@separating
	lea	edi, DWORD PTR _db$89846[ebp+8]
$LN26@separating:
	lea	edx, DWORD PTR [eax+1]

; 1454 :       for ( jjj = jj+1 ; jjj < nb ; jjj++ )

	mov	ecx, edx
	cmp	ecx, esi
	jge	SHORT $LN25@separating
$LN23@separating:

; 1455 :         if ( db[jj]*db[jjj] < 0.0 ) goto keeptrying;

	fld	QWORD PTR _db$89846[ebp+ecx*8]
	fmul	QWORD PTR [edi]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN282@separating

; 1454 :       for ( jjj = jj+1 ; jjj < nb ; jjj++ )

	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LN23@separating
$LN25@separating:

; 1450 :     }
; 1451 : 
; 1452 :     /* test opposite sidedness */
; 1453 :     for ( jj = 1 ; jj < nb ; jj++ )

	mov	eax, edx
	add	edi, 8
	cmp	eax, esi
	jl	SHORT $LN26@separating
$LN24@separating:

; 1456 :     for ( ii = 2 ; ii < na ; ii++ )

	mov	edi, 2
	lea	edx, DWORD PTR _da$89845[ebp+16]
$LN19@separating:
	cmp	edi, ebx
	jge	SHORT $LN17@separating

; 1457 :       for ( jj = 1 ; jj < nb ; jj++ )

	mov	ecx, 1
	cmp	esi, ecx
	jle	SHORT $LN18@separating
$LN16@separating:

; 1458 :         if ( da[ii]*db[jj] > 0.0 ) goto keeptrying;

	fld	QWORD PTR _db$89846[ebp+ecx*8]
	fmul	QWORD PTR [edx]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN282@separating

; 1457 :       for ( jj = 1 ; jj < nb ; jj++ )

	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LN16@separating
$LN18@separating:

; 1456 :     for ( ii = 2 ; ii < na ; ii++ )

	inc	edi
	add	edx, 8
	jmp	SHORT $LN19@separating
$LN228@separating:

; 1446 :     }
; 1447 :     for ( jj = 1 ; jj < nb ; jj++ )

	fstp	ST(2)

; 1445 :       da[ii] = ( dar[ii] < -minarea ? -1.0 : ( dar[ii] > minarea ? 1.0 : 0.0));

	jmp	SHORT $LN317@separating
$LN282@separating:

; 1455 :         if ( db[jj]*db[jjj] < 0.0 ) goto keeptrying;

	fstp	ST(1)
$keeptrying$89878:
	jmp	SHORT $LN318@separating
$LN178@separating:

; 1437 : 
; 1438 :     if ( c[0]*c[0] + c[1]*c[1] + c[2]*c[2] <= minarea*minarea ) 

	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(0)
$LN318@separating:
	mov	eax, DWORD PTR _j$[ebp]
	fstp	ST(0)
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, esi
	jl	$LL159@separating
$LN47@separating:

; 1420 : 
; 1421 :   for ( i = 0 ; i < nna ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _nna$[ebp]
	jl	$LL164@separating
$LN46@separating:

; 1467 :     }
; 1468 : keeptrying: ;
; 1469 :   }
; 1470 : 
; 1471 :   /* might have case of separating plane having two vertices on tb */
; 1472 :   if ( depth == 2 ) 

	cmp	DWORD PTR _depth$[ebp], 2
	jne	$LN3@separating

; 1473 :       return ASPLITTINGB|BSPLITTINGA;

	pop	edi
	pop	esi
	mov	eax, 24					; 00000018H
	pop	ebx

; 1479 :   return retval;
; 1480 : 
; 1481 : } // end separating_plane()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@separating:

; 1459 : 
; 1460 :      /* have separating plane */
; 1461 :     { REAL asum,bsum;
; 1462 :       /* decide which is in front */
; 1463 :       for ( ii = 2, asum = 0.0 ; ii < na ; ii++ ) asum += c[2]*da[ii];

	mov	eax, 2
	fld	ST(0)
	cmp	ebx, eax
	jle	SHORT $LN148@separating
	lea	ecx, DWORD PTR [ebx-2]
	cmp	ecx, 4
	jl	SHORT $LC149@separating
	lea	ecx, DWORD PTR [ebx-3]
$LN150@separating:
	fld	QWORD PTR _da$89845[ebp+eax*8]
	add	eax, 4
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	QWORD PTR _da$89845[ebp+eax*8-24]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	QWORD PTR _da$89845[ebp+eax*8-16]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fld	QWORD PTR _da$89845[ebp+eax*8-8]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	cmp	eax, ecx
	jl	SHORT $LN150@separating
$LC149@separating:
	cmp	eax, ebx
	jge	SHORT $LN148@separating
$LC12@separating:
	fld	QWORD PTR _da$89845[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	cmp	eax, ebx
	jl	SHORT $LC12@separating
$LN148@separating:

; 1464 :       for ( jj = 1, bsum = 0.0 ; jj < nb ; jj++ ) bsum += c[2]*db[jj];

	mov	eax, 1
	fld	ST(1)
	cmp	esi, eax
	jle	SHORT $LN313@separating
	lea	edx, DWORD PTR [esi-1]
	cmp	edx, 4
	jl	SHORT $LC152@separating
	lea	ecx, DWORD PTR [esi-3]
$LN153@separating:
	fld	QWORD PTR _db$89846[ebp+eax*8]
	add	eax, 4
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fld	QWORD PTR _db$89846[ebp+eax*8-24]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fld	QWORD PTR _db$89846[ebp+eax*8-16]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	fld	QWORD PTR _db$89846[ebp+eax*8-8]
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	cmp	eax, ecx
	jl	SHORT $LN153@separating
$LC152@separating:
	cmp	eax, esi
	jge	SHORT $LN313@separating
$LC9@separating:
	fld	QWORD PTR _db$89846[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(4)
	faddp	ST(1), ST(0)
	cmp	eax, esi
	jl	SHORT $LC9@separating
$LN313@separating:
	fstp	ST(3)

; 1465 :       if ( asum > 0.0 || bsum < 0.0 ) return SECOND_BACK;

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN315@separating
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN5@separating

; 1466 :       else   return FIRST_BACK;

	jmp	SHORT $LN319@separating
$LN315@separating:

; 1465 :       if ( asum > 0.0 || bsum < 0.0 ) return SECOND_BACK;

	fstp	ST(1)
	fstp	ST(0)
$LN5@separating:
	pop	edi
	pop	esi
	mov	eax, 4
	pop	ebx

; 1479 :   return retval;
; 1480 : 
; 1481 : } // end separating_plane()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@separating:

; 1474 :   retval = separating_plane(tb,ta,2);

	mov	eax, DWORD PTR _ta$GSCopy$[ebp]
	mov	ecx, DWORD PTR _tb$GSCopy$[ebp]
	push	2
	push	eax
	push	ecx
	call	_separating_plane
	add	esp, 12					; 0000000cH

; 1475 :   if ( retval == FIRST_BACK ) 

	cmp	eax, 2

; 1476 :       return SECOND_BACK;

	je	SHORT $LN5@separating

; 1477 :   if ( retval == SECOND_BACK ) 

	cmp	eax, 4
	jne	SHORT $LN65@separating
$LN319@separating:

; 1478 :       return FIRST_BACK;

	mov	eax, 2
$LN65@separating:

; 1479 :   return retval;
; 1480 : 
; 1481 : } // end separating_plane()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_separating_plane ENDP
_TEXT	ENDS
PUBLIC	__real@3bc79ca10c924223
PUBLIC	__real@bee4f8b588e368f1
PUBLIC	__$ArrayPad$
PUBLIC	_separating_line
;	COMDAT __real@3bc79ca10c924223
CONST	SEGMENT
__real@3bc79ca10c924223 DQ 03bc79ca10c924223r	; 1e-020
CONST	ENDS
;	COMDAT __real@bee4f8b588e368f1
CONST	SEGMENT
__real@bee4f8b588e368f1 DQ 0bee4f8b588e368f1r	; -1e-005
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _separating_line
_TEXT	SEGMENT
_width$ = -116						; size = 8
_nna$ = -108						; size = 4
_nnb$ = -104						; size = 4
_b$ = -100						; size = 12
_cx$89955 = -88						; size = 8
_d$89927 = -88						; size = 8
_d$89957 = -80						; size = 8
_cx$89925 = -80						; size = 8
_cy$89956 = -72						; size = 8
_cy$89926 = -72						; size = 8
_a$ = -64						; size = 12
_nb$ = -48						; size = 4
_i$ = -44						; size = 4
_aneg$ = -40						; size = 4
_na$ = -36						; size = 4
_bpos$ = -32						; size = 4
_dbr$89959 = -28					; size = 24
_dar$89958 = -28					; size = 24
_dbr$89929 = -28					; size = 24
_dar$89928 = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_ta$ = 8						; size = 4
_tb$ = 12						; size = 4
_separating_line PROC					; COMDAT

; 1497 : { int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1498 :   int same = 0;
; 1499 :   int na,nb; /* vertices on respective elements */
; 1500 :   int nna,nnb; /* number of lines to try */
; 1501 :   int apos,aneg,bpos,bneg;
; 1502 :   float *a[3],*b[3];
; 1503 :   REAL width; /* thickness of separating line */ 
; 1504 : 
; 1505 :   sep_line_calls++;  /* for verbose statistics */

	fld	QWORD PTR _sep_line_calls

; 1506 : 
; 1507 :   /* get edge first, if any */
; 1508 :   if ( ((ta->flag & 0xF) == FACET) && ((tb->flag & 0xF) == EDGE ) )

	mov	edx, DWORD PTR _tb$[ebp]
	fadd	QWORD PTR __real@3ff0000000000000
	push	ebx
	push	esi
	mov	esi, DWORD PTR _ta$[ebp]
	fstp	QWORD PTR _sep_line_calls
	mov	eax, DWORD PTR [esi+28]
	and	al, 15					; 0000000fH
	push	edi
	cmp	al, 2
	jne	SHORT $LN47@separating@2
	mov	ecx, DWORD PTR [edx+28]
	and	cl, 15					; 0000000fH
	cmp	cl, 1
	jne	SHORT $LN47@separating@2

; 1509 :   { struct tsort *tmp = ta; ta = tb; tb = tmp; }

	mov	eax, esi
	mov	esi, edx
	mov	edx, eax
	mov	DWORD PTR _ta$[ebp], esi
	mov	DWORD PTR _tb$[ebp], edx
$LN47@separating@2:

; 1510 : 
; 1511 :   /* want to prevent overlap of facet with thick edge; not going
; 1512 :      to worry about edge-edge overlap, since that too weird. */
; 1513 :   if ( ((ta->flag & 0xF) == EDGE) && ((tb->flag & 0xF) == FACET ) )

	mov	ecx, DWORD PTR [esi+28]
	and	ecx, 15					; 0000000fH
	cmp	ecx, 1
	jne	SHORT $LN46@separating@2
	mov	eax, DWORD PTR [edx+28]
	and	al, 15					; 0000000fH
	cmp	al, 2
	jne	SHORT $LN46@separating@2

; 1514 :   {
; 1515 :     width = ta->width/2;  /* actually need half-width */

	fld	DWORD PTR [esi+104]
	fmul	QWORD PTR __real@3fe0000000000000
	jmp	SHORT $LN313@separating@2
$LN46@separating@2:

; 1516 :   }
; 1517 :   else width = -1e-5;  /* allow slight overlap for numerical purposes */

	fld	QWORD PTR __real@bee4f8b588e368f1
$LN313@separating@2:

; 1518 : 
; 1519 :   na = (ta->flag & 0xF) == FACET ? 3 : 2;

	xor	eax, eax
	fstp	QWORD PTR _width$[ebp]
	cmp	ecx, 2
	sete	al

; 1520 :   nb = (tb->flag & 0xF) == FACET ? 3 : 2;

	xor	ebx, ebx

; 1521 :   nna = (ta->flag & 0xF) == FACET ? 3 : 1;
; 1522 :   nnb = (tb->flag & 0xF) == FACET ? 3 : 1;
; 1523 : 
; 1524 :   /* Try using edges of ta */
; 1525 :   for ( i = 0 ; i < nna ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	add	eax, 2
	mov	DWORD PTR _na$[ebp], eax
	mov	eax, DWORD PTR [edx+28]
	and	eax, 15					; 0000000fH
	cmp	eax, 2
	sete	bl
	xor	edx, edx
	add	ebx, 2
	cmp	ecx, 2
	sete	dl
	xor	ecx, ecx
	cmp	eax, 2
	sete	cl
	mov	DWORD PTR _nb$[ebp], ebx
	lea	esi, DWORD PTR [edx+edx+1]
	mov	DWORD PTR _nna$[ebp], esi
	lea	ecx, DWORD PTR [ecx+ecx+1]
	mov	DWORD PTR _nnb$[ebp], ecx
	test	esi, esi
	jle	$LN119@separating@2
$LL44@separating@2:

; 1526 :   { REAL cx,cy,d; /* coefficients for line */
; 1527 :     REAL dar[3],dbr[3],minarea;
; 1528 :     int ii,jj;
; 1529 : 
; 1530 :     for ( ii = 0 ; ii < na ; ii++ )

	mov	esi, DWORD PTR _na$[ebp]
	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN128@separating@2
	mov	edi, DWORD PTR _i$[ebp]
	npad	2
$LL41@separating@2:

; 1531 :        a[ii] = ta->x[(i+ii)%na];

	lea	eax, DWORD PTR [ecx+edi]
	cdq
	idiv	esi
	mov	eax, DWORD PTR _ta$[ebp]
	inc	ecx
	lea	edx, DWORD PTR [edx+edx*2]
	lea	edx, DWORD PTR [eax+edx*4+32]
	mov	DWORD PTR _a$[ebp+ecx*4-4], edx
	cmp	ecx, esi
	jl	SHORT $LL41@separating@2
$LN128@separating@2:

; 1526 :   { REAL cx,cy,d; /* coefficients for line */
; 1527 :     REAL dar[3],dbr[3],minarea;
; 1528 :     int ii,jj;
; 1529 : 
; 1530 :     for ( ii = 0 ; ii < na ; ii++ )

	mov	edx, DWORD PTR _a$[ebp]

; 1532 : 
; 1533 :     for ( jj = 0 ; jj < nb ; jj++ )

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN36@separating@2
	mov	ecx, DWORD PTR _tb$[ebp]
	add	ecx, 32					; 00000020H
$LL38@separating@2:

; 1534 :        b[jj] = tb->x[jj];

	mov	DWORD PTR _b$[ebp+eax*4], ecx
	inc	eax
	add	ecx, 12					; 0000000cH
	cmp	eax, ebx
	jl	SHORT $LL38@separating@2
$LN36@separating@2:

; 1535 : 
; 1536 :      cx = a[1][1] - a[0][1]; cy = a[0][0] - a[1][0]; 

	mov	eax, DWORD PTR _a$[ebp+4]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [edx+4]
	fst	QWORD PTR _cx$89925[ebp]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR [eax]
	fst	QWORD PTR _cy$89926[ebp]

; 1537 :      d = cx*a[0][0] + cy*a[0][1];

	fld	DWORD PTR [edx+4]
	fmul	ST(0), ST(1)
	fld	DWORD PTR [edx]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _d$89927[ebp]

; 1538 : 
; 1539 :      minarea = width*sqrt(cx*cx + cy*cy);

	fmul	ST(0), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fmul	QWORD PTR _width$[ebp]

; 1540 : 
; 1541 :      if ( fabs(minarea) < 1e-20 ) 

	fld	ST(0)
	fabs
	fcomp	QWORD PTR __real@3bc79ca10c924223
	fnstsw	ax
	test	ah, 5
	jnp	$LN131@separating@2

; 1542 :       { same++;    continue; /* same point */ }
; 1543 : 
; 1544 :      apos = aneg = bpos = bneg = 0;
; 1545 :      for ( ii = 2 ; ii < na ; ii++ )

	mov	edx, DWORD PTR _na$[ebp]
	xor	esi, esi
	mov	ecx, 2
	xor	edi, edi
	mov	DWORD PTR _bpos$[ebp], esi
	mov	DWORD PTR _aneg$[ebp], esi
	cmp	edx, ecx
	jle	$LN121@separating@2
	lea	eax, DWORD PTR [edx-2]
	cmp	eax, 4
	jl	$LN120@separating@2
	fld	ST(0)
	add	edx, -3					; fffffffdH
	fchs
	fld	QWORD PTR _d$89927[ebp]
	fld	QWORD PTR _cy$89926[ebp]
	fld	QWORD PTR _cx$89925[ebp]
$LN84@separating@2:

; 1546 :      { dar[ii] = cx*a[ii][0] + cy*a[ii][1] - d;

	mov	eax, DWORD PTR _a$[ebp+ecx*4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dar$89928[ebp+ecx*8]

; 1547 :        if ( dar[ii] > minarea ) apos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN76@separating@2
	inc	esi
$LN76@separating@2:

; 1548 :        if ( dar[ii] < -minarea ) aneg++;

	fcomp	ST(4)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN77@separating@2
	inc	DWORD PTR _aneg$[ebp]
$LN77@separating@2:

; 1546 :      { dar[ii] = cx*a[ii][0] + cy*a[ii][1] - d;

	mov	eax, DWORD PTR _a$[ebp+ecx*4+4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dar$89928[ebp+ecx*8+8]

; 1547 :        if ( dar[ii] > minarea ) apos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN78@separating@2
	inc	esi
$LN78@separating@2:

; 1548 :        if ( dar[ii] < -minarea ) aneg++;

	fcomp	ST(4)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN79@separating@2
	inc	DWORD PTR _aneg$[ebp]
$LN79@separating@2:

; 1546 :      { dar[ii] = cx*a[ii][0] + cy*a[ii][1] - d;

	mov	eax, DWORD PTR _a$[ebp+ecx*4+8]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dar$89928[ebp+ecx*8+16]

; 1547 :        if ( dar[ii] > minarea ) apos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN80@separating@2
	inc	esi
$LN80@separating@2:

; 1548 :        if ( dar[ii] < -minarea ) aneg++;

	fcomp	ST(4)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN81@separating@2
	inc	DWORD PTR _aneg$[ebp]
$LN81@separating@2:

; 1546 :      { dar[ii] = cx*a[ii][0] + cy*a[ii][1] - d;

	mov	eax, DWORD PTR _a$[ebp+ecx*4+12]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dar$89928[ebp+ecx*8+24]

; 1547 :        if ( dar[ii] > minarea ) apos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN82@separating@2
	inc	esi
$LN82@separating@2:

; 1548 :        if ( dar[ii] < -minarea ) aneg++;

	fcomp	ST(4)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN83@separating@2
	inc	DWORD PTR _aneg$[ebp]
$LN83@separating@2:
	add	ecx, 4
	cmp	ecx, edx
	jl	$LN84@separating@2
	mov	edx, DWORD PTR _na$[ebp]
	fstp	ST(3)
	jmp	SHORT $LC75@separating@2
$LN120@separating@2:
	fld	QWORD PTR _d$89927[ebp]
	fld	QWORD PTR _cy$89926[ebp]
	fld	QWORD PTR _cx$89925[ebp]
	fxch	ST(2)
	fxch	ST(1)
$LC75@separating@2:

; 1542 :       { same++;    continue; /* same point */ }
; 1543 : 
; 1544 :      apos = aneg = bpos = bneg = 0;
; 1545 :      for ( ii = 2 ; ii < na ; ii++ )

	cmp	ecx, edx
	jge	SHORT $LN74@separating@2
	mov	edx, DWORD PTR _na$[ebp]
	fld	ST(3)
	fchs
$LC34@separating@2:

; 1546 :      { dar[ii] = cx*a[ii][0] + cy*a[ii][1] - d;

	mov	eax, DWORD PTR _a$[ebp+ecx*4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dar$89928[ebp+ecx*8]

; 1547 :        if ( dar[ii] > minarea ) apos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN31@separating@2
	inc	esi
$LN31@separating@2:

; 1548 :        if ( dar[ii] < -minarea ) aneg++;

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN33@separating@2
	inc	DWORD PTR _aneg$[ebp]
$LN33@separating@2:
	inc	ecx

; 1542 :       { same++;    continue; /* same point */ }
; 1543 : 
; 1544 :      apos = aneg = bpos = bneg = 0;
; 1545 :      for ( ii = 2 ; ii < na ; ii++ )

	cmp	ecx, edx
	jl	SHORT $LC34@separating@2
	fstp	ST(0)
	jmp	SHORT $LN74@separating@2
$LN121@separating@2:
	fld	QWORD PTR _d$89927[ebp]
	fld	QWORD PTR _cy$89926[ebp]
	fld	QWORD PTR _cx$89925[ebp]
	fxch	ST(2)
	fxch	ST(1)
$LN74@separating@2:

; 1549 :      }
; 1550 :      for ( jj = 0 ; jj < nb ; jj++ )

	xor	ecx, ecx
	cmp	ebx, 4
	jl	$LC86@separating@2
	fld	ST(3)
	lea	edx, DWORD PTR [ebx-3]
	fchs
$LN95@separating@2:

; 1551 :      { dbr[jj] = cx*b[jj][0] + cy*b[jj][1] - d;

	mov	eax, DWORD PTR _b$[ebp+ecx*4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dbr$89929[ebp+ecx*8]

; 1552 :        if ( dbr[jj] > minarea ) bpos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN87@separating@2
	inc	DWORD PTR _bpos$[ebp]
$LN87@separating@2:

; 1553 :        if ( dbr[jj] < -minarea ) bneg++;

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN88@separating@2
	inc	edi
$LN88@separating@2:

; 1551 :      { dbr[jj] = cx*b[jj][0] + cy*b[jj][1] - d;

	mov	eax, DWORD PTR _b$[ebp+ecx*4+4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dbr$89929[ebp+ecx*8+8]

; 1552 :        if ( dbr[jj] > minarea ) bpos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN89@separating@2
	inc	DWORD PTR _bpos$[ebp]
$LN89@separating@2:

; 1553 :        if ( dbr[jj] < -minarea ) bneg++;

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN90@separating@2
	inc	edi
$LN90@separating@2:

; 1551 :      { dbr[jj] = cx*b[jj][0] + cy*b[jj][1] - d;

	mov	eax, DWORD PTR _b$[ebp+ecx*4+8]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dbr$89929[ebp+ecx*8+16]

; 1552 :        if ( dbr[jj] > minarea ) bpos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN91@separating@2
	inc	DWORD PTR _bpos$[ebp]
$LN91@separating@2:

; 1553 :        if ( dbr[jj] < -minarea ) bneg++;

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN92@separating@2
	inc	edi
$LN92@separating@2:

; 1551 :      { dbr[jj] = cx*b[jj][0] + cy*b[jj][1] - d;

	mov	eax, DWORD PTR _b$[ebp+ecx*4+12]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dbr$89929[ebp+ecx*8+24]

; 1552 :        if ( dbr[jj] > minarea ) bpos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN93@separating@2
	inc	DWORD PTR _bpos$[ebp]
$LN93@separating@2:

; 1553 :        if ( dbr[jj] < -minarea ) bneg++;

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN94@separating@2
	inc	edi
$LN94@separating@2:
	add	ecx, 4
	cmp	ecx, edx
	jl	$LN95@separating@2
	fstp	ST(0)
$LC86@separating@2:

; 1549 :      }
; 1550 :      for ( jj = 0 ; jj < nb ; jj++ )

	cmp	ecx, ebx
	jge	SHORT $LN209@separating@2
	mov	edx, DWORD PTR _bpos$[ebp]
	fld	ST(3)
	fchs
$LC29@separating@2:

; 1551 :      { dbr[jj] = cx*b[jj][0] + cy*b[jj][1] - d;

	mov	eax, DWORD PTR _b$[ebp+ecx*4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dbr$89929[ebp+ecx*8]

; 1552 :        if ( dbr[jj] > minarea ) bpos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN26@separating@2
	inc	edx
$LN26@separating@2:

; 1553 :        if ( dbr[jj] < -minarea ) bneg++;

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN28@separating@2
	inc	edi
$LN28@separating@2:
	inc	ecx

; 1549 :      }
; 1550 :      for ( jj = 0 ; jj < nb ; jj++ )

	cmp	ecx, ebx
	jl	SHORT $LC29@separating@2
	fstp	ST(3)

; 1552 :        if ( dbr[jj] > minarea ) bpos++;

	mov	DWORD PTR _bpos$[ebp], edx
	fstp	ST(3)
	fstp	ST(2)
	fstp	ST(1)
	jmp	SHORT $LN314@separating@2
$LN209@separating@2:
	fstp	ST(2)
	fstp	ST(2)
	fstp	ST(0)
$LN314@separating@2:

; 1554 :      }
; 1555 : 
; 1556 :      /* test opposite sidedness */
; 1557 :      if ( apos == (na-2) && bneg == nb ) return DISJOINT;

	mov	eax, DWORD PTR _na$[ebp]
	fstp	ST(0)
	add	eax, -2					; fffffffeH
	cmp	esi, eax
	jne	SHORT $LN24@separating@2
	cmp	edi, ebx
	je	SHORT $LN60@separating@2
$LN24@separating@2:

; 1558 :      if ( aneg == (na-2) && bpos == nb ) return DISJOINT;

	cmp	DWORD PTR _aneg$[ebp], eax
	jne	SHORT $LN43@separating@2
	cmp	DWORD PTR _bpos$[ebp], ebx
	jne	SHORT $LN43@separating@2
$LN60@separating@2:
	pop	edi
	pop	esi

; 1554 :      }
; 1555 : 
; 1556 :      /* test opposite sidedness */
; 1557 :      if ( apos == (na-2) && bneg == nb ) return DISJOINT;

	mov	eax, 1
	pop	ebx

; 1597 :   }
; 1598 : 
; 1599 :   return NOTKNOWN;
; 1600 : } // end separating_line(

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN131@separating@2:

; 1558 :      if ( aneg == (na-2) && bpos == nb ) return DISJOINT;

	fstp	ST(0)
$LN43@separating@2:

; 1521 :   nna = (ta->flag & 0xF) == FACET ? 3 : 1;
; 1522 :   nnb = (tb->flag & 0xF) == FACET ? 3 : 1;
; 1523 : 
; 1524 :   /* Try using edges of ta */
; 1525 :   for ( i = 0 ; i < nna ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _nna$[ebp]
	jl	$LL44@separating@2
$LN119@separating@2:

; 1559 :   }
; 1560 : 
; 1561 :   /* Try using edges of tb */
; 1562 :   for ( i = 0 ; i < nnb ; i++ )

	xor	esi, esi
	mov	DWORD PTR _i$[ebp], esi
	cmp	DWORD PTR _nnb$[ebp], esi
	jle	$LN20@separating@2
	jmp	SHORT $LN315@separating@2
$LL124@separating@2:
	mov	ebx, DWORD PTR _nb$[ebp]
	mov	esi, DWORD PTR _i$[ebp]
$LN315@separating@2:
	mov	edx, DWORD PTR _a$[ebp]
	mov	edi, DWORD PTR _tb$[ebp]

; 1563 :   { REAL cx,cy,d; /* coefficients for line */
; 1564 :     REAL dar[3],dbr[3],minarea;
; 1565 :     int ii,jj;
; 1566 : 
; 1567 :     for ( ii = 0 ; ii < nb ; ii++ )

	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN17@separating@2
$LL19@separating@2:

; 1568 :        a[ii] = tb->x[(i+ii)%nb];

	lea	eax, DWORD PTR [ecx+esi]
	cdq
	idiv	ebx
	inc	ecx
	lea	edx, DWORD PTR [edx+edx*2]
	lea	eax, DWORD PTR [edi+edx*4+32]
	mov	DWORD PTR _a$[ebp+ecx*4-4], eax
	cmp	ecx, ebx
	jl	SHORT $LL19@separating@2

; 1563 :   { REAL cx,cy,d; /* coefficients for line */
; 1564 :     REAL dar[3],dbr[3],minarea;
; 1565 :     int ii,jj;
; 1566 : 
; 1567 :     for ( ii = 0 ; ii < nb ; ii++ )

	mov	edx, DWORD PTR _a$[ebp]
$LN17@separating@2:

; 1569 : 
; 1570 :     for ( jj = 0 ; jj < na ; jj++ )

	mov	esi, DWORD PTR _na$[ebp]
	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN14@separating@2
	mov	ecx, DWORD PTR _ta$[ebp]
	add	ecx, 32					; 00000020H
	npad	6
$LL16@separating@2:

; 1571 :        b[jj] = ta->x[jj];

	mov	DWORD PTR _b$[ebp+eax*4], ecx
	inc	eax
	add	ecx, 12					; 0000000cH
	cmp	eax, esi
	jl	SHORT $LL16@separating@2
$LN14@separating@2:

; 1572 : 
; 1573 :      cx = a[1][1] - a[0][1]; cy = a[0][0] - a[1][0]; 

	mov	eax, DWORD PTR _a$[ebp+4]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [edx+4]
	fst	QWORD PTR _cx$89955[ebp]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR [eax]
	fst	QWORD PTR _cy$89956[ebp]

; 1574 :      d = cx*a[0][0] + cy*a[0][1];

	fld	DWORD PTR [edx+4]
	fmul	ST(0), ST(1)
	fld	DWORD PTR [edx]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _d$89957[ebp]

; 1575 : 
; 1576 :      width = -1e-5;
; 1577 :      minarea = width*sqrt(cx*cx + cy*cy);

	fmul	ST(0), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fmul	QWORD PTR __real@bee4f8b588e368f1

; 1578 : 
; 1579 :      if ( fabs(minarea) < 1e-20 ) 

	fld	ST(0)
	fabs
	fcomp	QWORD PTR __real@3bc79ca10c924223
	fnstsw	ax
	test	ah, 5
	jnp	$LN223@separating@2

; 1580 :       { same++;    continue; /* same point */ }
; 1581 : 
; 1582 :      apos = aneg = bpos = bneg = 0;
; 1583 :      for ( ii = 2 ; ii < nb ; ii++ )

	mov	edx, DWORD PTR _nb$[ebp]
	xor	esi, esi
	mov	ecx, 2
	xor	edi, edi
	xor	ebx, ebx
	mov	DWORD PTR _bpos$[ebp], esi
	cmp	edx, ecx
	jle	$LN123@separating@2
	lea	eax, DWORD PTR [edx-2]
	cmp	eax, 4
	jl	$LN122@separating@2
	fld	ST(0)
	add	edx, -3					; fffffffdH
	fchs
	fld	QWORD PTR _d$89957[ebp]
	fld	QWORD PTR _cy$89956[ebp]
	fld	QWORD PTR _cx$89955[ebp]
$LN106@separating@2:

; 1584 :      { dar[ii] = cx*a[ii][0] + cy*a[ii][1] - d;

	mov	eax, DWORD PTR _a$[ebp+ecx*4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dar$89958[ebp+ecx*8]

; 1585 :        if ( dar[ii] > minarea ) apos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN98@separating@2
	inc	esi
$LN98@separating@2:

; 1586 :        if ( dar[ii] < -minarea ) aneg++;

	fcomp	ST(4)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN99@separating@2
	inc	ebx
$LN99@separating@2:

; 1584 :      { dar[ii] = cx*a[ii][0] + cy*a[ii][1] - d;

	mov	eax, DWORD PTR _a$[ebp+ecx*4+4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dar$89958[ebp+ecx*8+8]

; 1585 :        if ( dar[ii] > minarea ) apos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN100@separating@2
	inc	esi
$LN100@separating@2:

; 1586 :        if ( dar[ii] < -minarea ) aneg++;

	fcomp	ST(4)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN101@separating@2
	inc	ebx
$LN101@separating@2:

; 1584 :      { dar[ii] = cx*a[ii][0] + cy*a[ii][1] - d;

	mov	eax, DWORD PTR _a$[ebp+ecx*4+8]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dar$89958[ebp+ecx*8+16]

; 1585 :        if ( dar[ii] > minarea ) apos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN102@separating@2
	inc	esi
$LN102@separating@2:

; 1586 :        if ( dar[ii] < -minarea ) aneg++;

	fcomp	ST(4)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN103@separating@2
	inc	ebx
$LN103@separating@2:

; 1584 :      { dar[ii] = cx*a[ii][0] + cy*a[ii][1] - d;

	mov	eax, DWORD PTR _a$[ebp+ecx*4+12]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(2)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dar$89958[ebp+ecx*8+24]

; 1585 :        if ( dar[ii] > minarea ) apos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN104@separating@2
	inc	esi
$LN104@separating@2:

; 1586 :        if ( dar[ii] < -minarea ) aneg++;

	fcomp	ST(4)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN105@separating@2
	inc	ebx
$LN105@separating@2:
	add	ecx, 4
	cmp	ecx, edx
	jl	$LN106@separating@2
	mov	edx, DWORD PTR _nb$[ebp]
	fstp	ST(3)
	jmp	SHORT $LC97@separating@2
$LN122@separating@2:
	fld	QWORD PTR _d$89957[ebp]
	fld	QWORD PTR _cy$89956[ebp]
	fld	QWORD PTR _cx$89955[ebp]
	fxch	ST(2)
	fxch	ST(1)
$LC97@separating@2:

; 1580 :       { same++;    continue; /* same point */ }
; 1581 : 
; 1582 :      apos = aneg = bpos = bneg = 0;
; 1583 :      for ( ii = 2 ; ii < nb ; ii++ )

	cmp	ecx, edx
	jge	SHORT $LN96@separating@2
	mov	edx, DWORD PTR _nb$[ebp]
	fld	ST(3)
	fchs
$LC12@separating@2:

; 1584 :      { dar[ii] = cx*a[ii][0] + cy*a[ii][1] - d;

	mov	eax, DWORD PTR _a$[ebp+ecx*4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dar$89958[ebp+ecx*8]

; 1585 :        if ( dar[ii] > minarea ) apos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN9@separating@2
	inc	esi
$LN9@separating@2:

; 1586 :        if ( dar[ii] < -minarea ) aneg++;

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN11@separating@2
	inc	ebx
$LN11@separating@2:
	inc	ecx

; 1580 :       { same++;    continue; /* same point */ }
; 1581 : 
; 1582 :      apos = aneg = bpos = bneg = 0;
; 1583 :      for ( ii = 2 ; ii < nb ; ii++ )

	cmp	ecx, edx
	jl	SHORT $LC12@separating@2
	fstp	ST(0)
	jmp	SHORT $LN96@separating@2
$LN123@separating@2:
	fld	QWORD PTR _d$89957[ebp]
	fld	QWORD PTR _cy$89956[ebp]
	fld	QWORD PTR _cx$89955[ebp]
	fxch	ST(2)
	fxch	ST(1)
$LN96@separating@2:

; 1587 :      }
; 1588 :      for ( jj = 0 ; jj < na ; jj++ )

	xor	ecx, ecx
	cmp	DWORD PTR _na$[ebp], 4
	jl	$LC108@separating@2
	mov	edx, DWORD PTR _na$[ebp]
	fld	ST(3)
	fchs
	add	edx, -3					; fffffffdH
$LN117@separating@2:

; 1589 :      { dbr[jj] = cx*b[jj][0] + cy*b[jj][1] - d;

	mov	eax, DWORD PTR _b$[ebp+ecx*4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dbr$89959[ebp+ecx*8]

; 1590 :        if ( dbr[jj] > minarea ) bpos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN109@separating@2
	inc	DWORD PTR _bpos$[ebp]
$LN109@separating@2:

; 1591 :        if ( dbr[jj] < -minarea ) bneg++;

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN110@separating@2
	inc	edi
$LN110@separating@2:

; 1589 :      { dbr[jj] = cx*b[jj][0] + cy*b[jj][1] - d;

	mov	eax, DWORD PTR _b$[ebp+ecx*4+4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dbr$89959[ebp+ecx*8+8]

; 1590 :        if ( dbr[jj] > minarea ) bpos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN111@separating@2
	inc	DWORD PTR _bpos$[ebp]
$LN111@separating@2:

; 1591 :        if ( dbr[jj] < -minarea ) bneg++;

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN112@separating@2
	inc	edi
$LN112@separating@2:

; 1589 :      { dbr[jj] = cx*b[jj][0] + cy*b[jj][1] - d;

	mov	eax, DWORD PTR _b$[ebp+ecx*4+8]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dbr$89959[ebp+ecx*8+16]

; 1590 :        if ( dbr[jj] > minarea ) bpos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN113@separating@2
	inc	DWORD PTR _bpos$[ebp]
$LN113@separating@2:

; 1591 :        if ( dbr[jj] < -minarea ) bneg++;

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN114@separating@2
	inc	edi
$LN114@separating@2:

; 1589 :      { dbr[jj] = cx*b[jj][0] + cy*b[jj][1] - d;

	mov	eax, DWORD PTR _b$[ebp+ecx*4+12]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dbr$89959[ebp+ecx*8+24]

; 1590 :        if ( dbr[jj] > minarea ) bpos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN115@separating@2
	inc	DWORD PTR _bpos$[ebp]
$LN115@separating@2:

; 1591 :        if ( dbr[jj] < -minarea ) bneg++;

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN116@separating@2
	inc	edi
$LN116@separating@2:
	add	ecx, 4
	cmp	ecx, edx
	jl	$LN117@separating@2
	fstp	ST(0)
$LC108@separating@2:

; 1587 :      }
; 1588 :      for ( jj = 0 ; jj < na ; jj++ )

	cmp	ecx, DWORD PTR _na$[ebp]
	jge	SHORT $LN301@separating@2
	mov	edx, DWORD PTR _na$[ebp]
	fld	ST(3)
	fchs
$LC7@separating@2:

; 1589 :      { dbr[jj] = cx*b[jj][0] + cy*b[jj][1] - d;

	mov	eax, DWORD PTR _b$[ebp+ecx*4]
	fld	DWORD PTR [eax+4]
	fmul	ST(0), ST(2)
	fld	DWORD PTR [eax]
	fmul	ST(0), ST(5)
	faddp	ST(1), ST(0)
	fsub	ST(0), ST(3)
	fst	QWORD PTR _dbr$89959[ebp+ecx*8]

; 1590 :        if ( dbr[jj] > minarea ) bpos++;

	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@separating@2
	inc	DWORD PTR _bpos$[ebp]
$LN4@separating@2:

; 1591 :        if ( dbr[jj] < -minarea ) bneg++;

	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@separating@2
	inc	edi
$LN6@separating@2:
	inc	ecx

; 1587 :      }
; 1588 :      for ( jj = 0 ; jj < na ; jj++ )

	cmp	ecx, edx
	jl	SHORT $LC7@separating@2

; 1591 :        if ( dbr[jj] < -minarea ) bneg++;

	fstp	ST(3)
	fstp	ST(3)
	fstp	ST(2)
	fstp	ST(1)
$LN316@separating@2:

; 1592 :      }
; 1593 : 
; 1594 :      /* test opposite sidedness */
; 1595 :      if ( apos == (nb-2) && bneg == na ) return DISJOINT;

	mov	eax, DWORD PTR _nb$[ebp]
	fstp	ST(0)
	add	eax, -2					; fffffffeH
	cmp	esi, eax
	jne	SHORT $LN125@separating@2
	cmp	edi, DWORD PTR _na$[ebp]
	je	$LN60@separating@2
$LN125@separating@2:

; 1596 :      if ( aneg == (nb-2) && bpos == na ) return DISJOINT;

	cmp	ebx, eax
	jne	SHORT $LN21@separating@2
	mov	ecx, DWORD PTR _na$[ebp]
	cmp	DWORD PTR _bpos$[ebp], ecx
	je	$LN60@separating@2
	jmp	SHORT $LN21@separating@2
$LN301@separating@2:

; 1587 :      }
; 1588 :      for ( jj = 0 ; jj < na ; jj++ )

	fstp	ST(2)
	fstp	ST(2)
	fstp	ST(0)
	jmp	SHORT $LN316@separating@2
$LN223@separating@2:

; 1596 :      if ( aneg == (nb-2) && bpos == na ) return DISJOINT;

	fstp	ST(0)
$LN21@separating@2:

; 1559 :   }
; 1560 : 
; 1561 :   /* Try using edges of tb */
; 1562 :   for ( i = 0 ; i < nnb ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _nnb$[ebp]
	jl	$LL124@separating@2
$LN20@separating@2:

; 1597 :   }
; 1598 : 
; 1599 :   return NOTKNOWN;
; 1600 : } // end separating_line(

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	mov	eax, 32					; 00000020H
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_separating_line ENDP
_TEXT	ENDS
PUBLIC	_plane_test
; Function compile flags: /Ogtp
;	COMDAT _plane_test
_TEXT	SEGMENT
tv402 = -52						; size = 8
_da$ = -52						; size = 8
tv385 = -44						; size = 8
_db$ = -44						; size = 8
_area$90009 = -36					; size = 8
tv302 = -32						; size = 4
_afar$ = -28						; size = 4
_anear$ = -24						; size = 4
_aeq$ = -20						; size = 4
_bnear$ = -16						; size = 4
_bfar$ = -12						; size = 4
_beq$ = -8						; size = 4
_retval$ = -4						; size = 4
tv196 = 8						; size = 4
tv171 = 8						; size = 4
_ta$ = 8						; size = 4
_tb$ = 12						; size = 4
_plane_test PROC					; COMDAT

; 1617 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 1618 :   REAL da,db;
; 1619 :   int k,n;
; 1620 :   int afar=0,aeq=0,anear=0;  /* count of ta vertices relative to tb plane */

	xor	eax, eax
	push	ebx

; 1621 :   int bfar=0,beq=0,bnear=0;  /* count of tb vertices relative to ta plane */
; 1622 :   REAL d;
; 1623 :   int retval = NOTKNOWN;
; 1624 : 
; 1625 :   /* if two edges */
; 1626 :   if ( ((ta->flag & 0xF) == EDGE) && ((tb->flag & 0xF) == EDGE) )

	mov	ebx, DWORD PTR _tb$[ebp]
	push	esi
	mov	esi, DWORD PTR _ta$[ebp]
	mov	DWORD PTR _afar$[ebp], eax
	mov	DWORD PTR _aeq$[ebp], eax
	mov	DWORD PTR _anear$[ebp], eax
	mov	DWORD PTR _bfar$[ebp], eax
	mov	DWORD PTR _beq$[ebp], eax
	mov	DWORD PTR _bnear$[ebp], eax
	mov	eax, DWORD PTR [esi+28]
	and	al, 15					; 0000000fH
	mov	DWORD PTR _retval$[ebp], 32		; 00000020H
	cmp	al, 1
	jne	$LN24@plane_test
	mov	ecx, DWORD PTR [ebx+28]
	and	cl, 15					; 0000000fH
	cmp	cl, al
	jne	$LN24@plane_test

; 1627 :   { REAL ab1x = tb->x[0][0] - ta->x[0][0];

	fld	DWORD PTR [ebx+32]
	fsub	DWORD PTR [esi+32]

; 1628 :     REAL ab1y = tb->x[0][1] - ta->x[0][1];

	fld	DWORD PTR [ebx+36]
	fsub	DWORD PTR [esi+36]

; 1629 :     REAL ab1z = tb->x[0][2] - ta->x[0][2];

	fld	DWORD PTR [ebx+40]
	fsub	DWORD PTR [esi+40]

; 1630 :     REAL ab2x = tb->x[1][0] - ta->x[0][0];

	fld	DWORD PTR [ebx+44]
	fsub	DWORD PTR [esi+32]

; 1631 :     REAL ab2y = tb->x[1][1] - ta->x[0][1];

	fld	DWORD PTR [ebx+48]
	fsub	DWORD PTR [esi+36]

; 1632 :     REAL ab2z = tb->x[1][2] - ta->x[0][2];

	fld	DWORD PTR [ebx+52]
	fsub	DWORD PTR [esi+40]

; 1633 :     REAL aax  = ta->x[1][0] - ta->x[0][0];
; 1634 :     REAL aay  = ta->x[1][1] - ta->x[0][1];
; 1635 :     REAL aaz  = ta->x[1][2] - ta->x[0][2];
; 1636 :     REAL area = ab1x*ab2y - ab1y*ab2x;

	fld	ST(1)
	fmul	ST(0), ST(6)
	fld	ST(3)
	fmul	ST(0), ST(6)
	fsubp	ST(1), ST(0)
	fst	QWORD PTR _area$90009[ebp]

; 1637 :     REAL vol = (ab1x*ab2y - ab1y*ab2x)*aaz + (ab1y*ab2z - ab1z*ab2y)*aax
; 1638 :               + (ab1z*ab2x - ab1x*ab2z)*aay;

	fld	ST(1)
	fmulp	ST(6), ST(0)
	fxch	ST(2)
	fmul	ST(0), ST(4)
	fsubp	ST(5), ST(0)
	fld	DWORD PTR [esi+44]
	fsub	DWORD PTR [esi+32]
	fmulp	ST(5), ST(0)
	fld	DWORD PTR [esi+52]
	fsub	DWORD PTR [esi+40]
	fmulp	ST(2), ST(0)
	fxch	ST(4)
	faddp	ST(1), ST(0)
	fxch	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(2)
	fmulp	ST(3), ST(0)
	fsubrp	ST(2), ST(0)
	fld	DWORD PTR [esi+48]
	fsub	DWORD PTR [esi+36]
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)

; 1639 :     if ( vol == 0.0 ) return COPLANAR;

	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@plane_test
	fstp	ST(1)
	pop	esi
	fstp	ST(0)
	mov	eax, 64					; 00000040H
	pop	ebx

; 1685 : 
; 1686 : } /* end plane_test() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@plane_test:

; 1640 :     if ( area == 0.0 ) return DISJOINT;

	fld	QWORD PTR _area$90009[ebp]
	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN22@plane_test
	fstp	ST(2)
	pop	esi
	fstp	ST(0)
	mov	eax, 1
	fstp	ST(0)
	pop	ebx

; 1685 : 
; 1686 : } /* end plane_test() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@plane_test:

; 1641 :     if ( area*vol > 0 ) return SECOND_BACK;

	fmulp	ST(2), ST(0)
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN21@plane_test
	pop	esi
	mov	eax, 4
	pop	ebx

; 1685 : 
; 1686 : } /* end plane_test() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@plane_test:
	pop	esi

; 1642 :     return FIRST_BACK;

	mov	eax, 2
	pop	ebx

; 1685 : 
; 1686 : } /* end plane_test() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@plane_test:

; 1643 :   }
; 1644 : 
; 1645 :   /* see where tb is with respect to ta plane */
; 1646 :   da = dotf(ta->normal,ta->x[0],gdim);

	mov	edx, DWORD PTR _gdim
	push	edi
	lea	eax, DWORD PTR [esi+32]
	push	edx
	lea	ecx, DWORD PTR [esi+68]
	push	eax
	push	ecx
	mov	DWORD PTR tv302[ebp], eax
	call	_dotf
	fst	QWORD PTR _da$[ebp]

; 1647 :   n = ((tb->flag & 0xF) == FACET) ? 3 : 2;

	mov	eax, DWORD PTR [ebx+28]
	xor	ecx, ecx
	and	al, 15					; 0000000fH
	add	esp, 12					; 0000000cH
	cmp	al, 2
	sete	cl
	lea	edi, DWORD PTR [ecx+2]

; 1648 :   for ( k = 0 ; k < n ; k++ )

	test	edi, edi
	jle	SHORT $LN41@plane_test

; 1643 :   }
; 1644 : 
; 1645 :   /* see where tb is with respect to ta plane */
; 1646 :   da = dotf(ta->normal,ta->x[0],gdim);

	fsub	QWORD PTR __real@3f1a36e2eb1c432d
	add	ebx, 32					; 00000020H
	mov	DWORD PTR tv196[ebp], edi

; 1648 :   for ( k = 0 ; k < n ; k++ )

	fstp	QWORD PTR tv385[ebp]
	npad	7
$LL20@plane_test:

; 1649 :   {
; 1650 :     d = dotf(ta->normal,tb->x[k],gdim); 

	mov	edx, DWORD PTR _gdim
	push	edx
	lea	eax, DWORD PTR [esi+68]
	push	ebx
	push	eax
	call	_dotf

; 1651 :     if ( d < da - 0.0001 ) { bnear++; continue; }

	fld	QWORD PTR tv385[ebp]
	fcomp	ST(1)
	add	esp, 12					; 0000000cH
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN17@plane_test
	inc	DWORD PTR _bnear$[ebp]
	fstp	ST(0)
	jmp	SHORT $LN19@plane_test
$LN17@plane_test:

; 1652 :     if ( d < da + 0.0001 ) { beq++; continue; }

	fld	QWORD PTR _da$[ebp]
	fadd	QWORD PTR __real@3f1a36e2eb1c432d
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN16@plane_test
	inc	DWORD PTR _beq$[ebp]
	jmp	SHORT $LN19@plane_test
$LN16@plane_test:

; 1653 :     bfar++;

	inc	DWORD PTR _bfar$[ebp]
$LN19@plane_test:

; 1648 :   for ( k = 0 ; k < n ; k++ )

	add	ebx, 12					; 0000000cH
	dec	DWORD PTR tv196[ebp]
	jne	SHORT $LL20@plane_test
	mov	ebx, DWORD PTR _tb$[ebp]
	jmp	SHORT $LN18@plane_test
$LN41@plane_test:
	fstp	ST(0)
$LN18@plane_test:

; 1654 :   }
; 1655 :   if ( beq == n ) return COPLANAR; /* both in same plane */

	cmp	DWORD PTR _beq$[ebp], edi
	je	$LN53@plane_test

; 1656 :   if ( bfar == 0 ) return FIRST_BACK; 

	cmp	DWORD PTR _bfar$[ebp], 0
	je	$LN52@plane_test

; 1657 :   if ( bnear > 0 ) 

	cmp	DWORD PTR _bnear$[ebp], 0
	jle	SHORT $LN13@plane_test

; 1658 :   { if ( (ta->flag & 0xF) == FACET ) retval = ASPLITTINGB; }

	mov	eax, DWORD PTR [esi+28]
	and	al, 15					; 0000000fH
	cmp	al, 2
	jne	SHORT $LN11@plane_test
	mov	DWORD PTR _retval$[ebp], 8

; 1659 :   else retval = SECOND_BACK;

	jmp	SHORT $LN11@plane_test
$LN13@plane_test:
	mov	DWORD PTR _retval$[ebp], 4
$LN11@plane_test:

; 1660 :   
; 1661 :   /* see where ta is with respect to tb plane */
; 1662 : 
; 1663 :   db = dotf(tb->normal,tb->x[0],gdim);

	mov	ecx, DWORD PTR _gdim
	push	ecx
	lea	edx, DWORD PTR [ebx+32]
	lea	eax, DWORD PTR [ebx+68]
	push	edx
	push	eax
	call	_dotf
	fst	QWORD PTR _db$[ebp]

; 1664 :   n = ((ta->flag & 0xF) == FACET) ? 3 : 2;

	mov	eax, DWORD PTR [esi+28]
	xor	ecx, ecx
	and	al, 15					; 0000000fH
	add	esp, 12					; 0000000cH
	cmp	al, 2
	sete	cl
	lea	edi, DWORD PTR [ecx+2]

; 1665 :   for ( k = 0 ; k < n ; k++ )

	test	edi, edi
	jle	SHORT $LN47@plane_test

; 1660 :   
; 1661 :   /* see where ta is with respect to tb plane */
; 1662 : 
; 1663 :   db = dotf(tb->normal,tb->x[0],gdim);

	fsub	QWORD PTR __real@3f1a36e2eb1c432d
	mov	esi, DWORD PTR tv302[ebp]
	mov	DWORD PTR tv171[ebp], edi

; 1665 :   for ( k = 0 ; k < n ; k++ )

	fstp	QWORD PTR tv402[ebp]
	npad	2
$LL10@plane_test:

; 1666 :   {
; 1667 :     d = dotf(tb->normal,ta->x[k],gdim); 

	mov	edx, DWORD PTR _gdim
	push	edx
	lea	eax, DWORD PTR [ebx+68]
	push	esi
	push	eax
	call	_dotf

; 1668 :     if ( d < db - 0.0001 ) { anear++; continue; }

	fld	QWORD PTR tv402[ebp]
	fcomp	ST(1)
	add	esp, 12					; 0000000cH
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN7@plane_test
	inc	DWORD PTR _anear$[ebp]
	fstp	ST(0)
	jmp	SHORT $LN9@plane_test
$LN7@plane_test:

; 1669 :     if ( d < db + 0.0001 ) { aeq++; continue; }

	fld	QWORD PTR _db$[ebp]
	fadd	QWORD PTR __real@3f1a36e2eb1c432d
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN6@plane_test
	inc	DWORD PTR _aeq$[ebp]
	jmp	SHORT $LN9@plane_test
$LN6@plane_test:

; 1670 :     afar++;

	inc	DWORD PTR _afar$[ebp]
$LN9@plane_test:

; 1665 :   for ( k = 0 ; k < n ; k++ )

	add	esi, 12					; 0000000cH
	dec	DWORD PTR tv171[ebp]
	jne	SHORT $LL10@plane_test
	jmp	SHORT $LN8@plane_test
$LN47@plane_test:
	fstp	ST(0)
$LN8@plane_test:

; 1671 :   }
; 1672 :   if ( aeq == n ) return COPLANAR; /* both in same plane */

	cmp	DWORD PTR _aeq$[ebp], edi
	jne	SHORT $LN5@plane_test
$LN53@plane_test:
	pop	edi
	pop	esi
	mov	eax, 64					; 00000040H
	pop	ebx

; 1685 : 
; 1686 : } /* end plane_test() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@plane_test:

; 1673 :   if ( anear == 0 ) return FIRST_BACK;

	cmp	DWORD PTR _anear$[ebp], 0
	jne	SHORT $LN4@plane_test
$LN52@plane_test:
	pop	edi
	pop	esi
	mov	eax, 2
	pop	ebx

; 1685 : 
; 1686 : } /* end plane_test() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@plane_test:

; 1674 :   if ( afar > 0 )  

	cmp	DWORD PTR _afar$[ebp], 0
	jle	SHORT $LN3@plane_test

; 1675 :   { if ( (tb->flag & 0xf) == FACET ) retval |= BSPLITTINGA;   }

	mov	eax, DWORD PTR [ebx+28]
	and	al, 15					; 0000000fH
	cmp	al, 2
	jne	SHORT $LN32@plane_test
	or	DWORD PTR _retval$[ebp], 16		; 00000010H

; 1677 :   
; 1678 :   /* might still not have properly detected order, so try this */
; 1679 :   /*
; 1680 :   if ( !(retval & (FIRST_BACK|SECOND_BACK)) )
; 1681 :     retval = separating_plane(ta,tb,0);
; 1682 :     */
; 1683 :     
; 1684 :   return retval;

	mov	eax, DWORD PTR _retval$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 1685 : 
; 1686 : } /* end plane_test() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@plane_test:

; 1676 :   else retval |= SECOND_BACK;

	or	DWORD PTR _retval$[ebp], 4
$LN32@plane_test:

; 1677 :   
; 1678 :   /* might still not have properly detected order, so try this */
; 1679 :   /*
; 1680 :   if ( !(retval & (FIRST_BACK|SECOND_BACK)) )
; 1681 :     retval = separating_plane(ta,tb,0);
; 1682 :     */
; 1683 :     
; 1684 :   return retval;

	mov	eax, DWORD PTR _retval$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 1685 : 
; 1686 : } /* end plane_test() */

	mov	esp, ebp
	pop	ebp
	ret	0
_plane_test ENDP
_TEXT	ENDS
PUBLIC	_visibility_stage
EXTRN	_display_edge:DWORD
EXTRN	_display_facet:DWORD
EXTRN	_visibility_test:DWORD
; Function compile flags: /Ogtp
;	COMDAT _visibility_stage
_TEXT	SEGMENT
_t$ = 8							; size = 4
_visibility_stage PROC					; COMDAT

; 1836 : {

	push	ebp
	mov	ebp, esp

; 1837 : 
; 1838 :   if ( !visibility_test )

	cmp	DWORD PTR _visibility_test, 0
	jne	SHORT $LN6@visibility

; 1839 :   { if ( (t->flag & 0xF) == FACET )

	mov	eax, DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	cl, 15					; 0000000fH

; 1840 :      (*display_facet)(t);

	push	eax
	cmp	cl, 2
	jne	SHORT $LN5@visibility
	call	DWORD PTR _display_facet
	add	esp, 4

; 1857 : 
; 1858 : } // end visibility_stage()

	pop	ebp
	ret	0
$LN5@visibility:

; 1841 :     else (*display_edge)(t);

	call	DWORD PTR _display_edge
	add	esp, 4

; 1857 : 
; 1858 : } // end visibility_stage()

	pop	ebp
	ret	0
$LN6@visibility:

; 1842 :     return;
; 1843 :   }
; 1844 : 
; 1845 :   /* accumulate */
; 1846 :   if ( vis_list == NULL )

	mov	eax, DWORD PTR _vis_list
	test	eax, eax
	jne	SHORT $LN3@visibility

; 1847 :   { vis_max = maxcount;

	mov	eax, DWORD PTR _maxcount

; 1848 :     vis_list = (struct tsort *)temp_calloc(vis_max,sizeof(struct tsort));

	push	1848					; 00000738H
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	push	140					; 0000008cH
	push	eax
	mov	DWORD PTR _vis_max, eax
	call	_kb_temp_calloc
	jmp	SHORT $LN9@visibility
$LN3@visibility:

; 1849 :   }
; 1850 :   else if ( vis_count >= vis_max - 1 )

	mov	ecx, DWORD PTR _vis_max
	lea	edx, DWORD PTR [ecx-1]
	cmp	DWORD PTR _vis_count, edx
	jb	SHORT $LN1@visibility

; 1851 :   { vis_list = (struct tsort *)temp_realloc((char*)vis_list,
; 1852 :         2*vis_max*sizeof(struct tsort));

	imul	ecx, 280				; 00000118H
	push	1852					; 0000073cH
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	push	ecx
	push	eax
	call	_kb_temp_realloc

; 1853 :     vis_max *= 2;

	mov	ecx, DWORD PTR _vis_max
	lea	edx, DWORD PTR [ecx+ecx]
	mov	DWORD PTR _vis_max, edx
$LN9@visibility:

; 1851 :   { vis_list = (struct tsort *)temp_realloc((char*)vis_list,
; 1852 :         2*vis_max*sizeof(struct tsort));

	mov	DWORD PTR _vis_list, eax
	add	esp, 16					; 00000010H
$LN1@visibility:

; 1854 :   }
; 1855 : 
; 1856 :   vis_list[vis_count++] = *t;

	push	esi
	mov	esi, DWORD PTR _t$[ebp]
	push	edi
	mov	edi, DWORD PTR _vis_count
	imul	edi, 140				; 0000008cH
	add	edi, eax
	mov	ecx, 35					; 00000023H
	rep movsd
	inc	DWORD PTR _vis_count
	pop	edi
	pop	esi

; 1857 : 
; 1858 : } // end visibility_stage()

	pop	ebp
	ret	0
_visibility_stage ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@FOIBAJPK@Visibility?5edge?5active?5list?5bad?4@ ; `string'
PUBLIC	_active_list_check
;	COMDAT ??_C@_0CC@FOIBAJPK@Visibility?5edge?5active?5list?5bad?4@
CONST	SEGMENT
??_C@_0CC@FOIBAJPK@Visibility?5edge?5active?5list?5bad?4@ DB 'Visibility '
	DB	'edge active list bad.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _active_list_check
_TEXT	SEGMENT
_active_list_check PROC					; COMDAT

; 1866 : { struct vis_conedge *e;

	push	esi

; 1867 :   
; 1868 :   for ( e = active_edge_first ; e != &sentinel ; e = e->next_active )

	mov	esi, DWORD PTR _active_edge_first
	cmp	esi, OFFSET _sentinel
	je	SHORT $LN2@active_lis
	npad	1
$LL4@active_lis:

; 1869 :   { if ( e->next_active->prev_active != e )

	mov	eax, DWORD PTR [esi+36]
	cmp	DWORD PTR [eax+32], esi
	je	SHORT $LN3@active_lis

; 1870 :       kb_error(2418,"Visibility edge active list bad.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CC@FOIBAJPK@Visibility?5edge?5active?5list?5bad?4@
	push	2418					; 00000972H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN3@active_lis:

; 1867 :   
; 1868 :   for ( e = active_edge_first ; e != &sentinel ; e = e->next_active )

	mov	esi, DWORD PTR [esi+36]
	cmp	esi, OFFSET _sentinel
	jne	SHORT $LL4@active_lis
$LN2@active_lis:
	pop	esi

; 1871 :   }
; 1872 : } // end active_list_check())

	ret	0
_active_list_check ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_03JDANDILB@?$CFd?5?$AA@			; `string'
PUBLIC	??_C@_0BE@PCBKHPFG@?6?5?5?5?5?9?9?9?9?5?$CFd?5?9?9?9?9?5?6?$AA@ ; `string'
PUBLIC	_print_active
EXTRN	_printf:PROC
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JDANDILB@?$CFd?5?$AA@
CONST	SEGMENT
??_C@_03JDANDILB@?$CFd?5?$AA@ DB '%d ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PCBKHPFG@?6?5?5?5?5?9?9?9?9?5?$CFd?5?9?9?9?9?5?6?$AA@
CONST	SEGMENT
??_C@_0BE@PCBKHPFG@?6?5?5?5?5?9?9?9?9?5?$CFd?5?9?9?9?9?5?6?$AA@ DB 0aH, ' '
	DB	'   ---- %d ---- ', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _print_active
_TEXT	SEGMENT
_id$ = 8						; size = 4
_print_active PROC					; COMDAT

; 1875 : { struct vis_conedge *ee;

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 1876 :   int inrow = 0;
; 1877 :   for ( ee = active_edge_first ; ee != &sentinel ; ee = ee->next_active )

	mov	edi, DWORD PTR _active_edge_first
	xor	esi, esi
	cmp	edi, OFFSET _sentinel
	je	SHORT $LN4@print_acti
	push	ebx
	mov	ebx, DWORD PTR _id$[ebp]
	npad	7
$LL6@print_acti:

; 1878 :   { if ( ee->id == id )

	mov	eax, DWORD PTR [edi]

; 1879 :     { printf("\n    ---- %d ---- \n",ee->id);

	push	eax
	cmp	eax, ebx
	jne	SHORT $LN3@print_acti
	push	OFFSET ??_C@_0BE@PCBKHPFG@?6?5?5?5?5?9?9?9?9?5?$CFd?5?9?9?9?9?5?6?$AA@
	call	_printf
	add	esp, 8

; 1880 :       inrow = 0;

	xor	esi, esi

; 1881 :     }
; 1882 :     else

	jmp	SHORT $LN2@print_acti
$LN3@print_acti:

; 1883 :       printf("%d ",ee->id);

	push	OFFSET ??_C@_03JDANDILB@?$CFd?5?$AA@
	call	_printf
	add	esp, 8
$LN2@print_acti:

; 1884 :     inrow++;

	inc	esi

; 1885 :     if ( inrow==10 )

	cmp	esi, 10					; 0000000aH
	jne	SHORT $LN5@print_acti

; 1886 :     { printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	add	esp, 4

; 1887 :       inrow = 0;

	xor	esi, esi
$LN5@print_acti:

; 1876 :   int inrow = 0;
; 1877 :   for ( ee = active_edge_first ; ee != &sentinel ; ee = ee->next_active )

	mov	edi, DWORD PTR [edi+36]
	cmp	edi, OFFSET _sentinel
	jne	SHORT $LL6@print_acti
	pop	ebx
$LN4@print_acti:
	pop	edi
	pop	esi

; 1888 :     }
; 1889 :   }
; 1890 : }

	pop	ebp
	ret	0
_print_active ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@BKOHLMIH@?5?9?9?5?$CFd?5?9?9?5?$AA@	; `string'
PUBLIC	_print_part_list
;	COMDAT ??_C@_0L@BKOHLMIH@?5?9?9?5?$CFd?5?9?9?5?$AA@
CONST	SEGMENT
??_C@_0L@BKOHLMIH@?5?9?9?5?$CFd?5?9?9?5?$AA@ DB ' -- %d -- ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _print_part_list
_TEXT	SEGMENT
_e$ = 8							; size = 4
_print_part_list PROC					; COMDAT

; 1894 : { int k;

	push	ebp
	mov	ebp, esp
	push	ebx

; 1895 :   struct vis_conedge *ee;
; 1896 :   for ( ee = e, k = 0 ; ee && k < 20 ; k++, ee = ee->prev_active ) ;

	mov	ebx, DWORD PTR _e$[ebp]
	push	esi
	xor	eax, eax
	push	edi
	mov	esi, ebx
	test	ebx, ebx
	je	SHORT $LN16@print_part
$LL9@print_part:
	cmp	eax, 20					; 00000014H
	jge	SHORT $LN7@print_part
	mov	esi, DWORD PTR [esi+32]
	inc	eax
	test	esi, esi
	jne	SHORT $LL9@print_part

; 1897 :   if ( ee == NULL ) ee = active_edge_first;

	jmp	SHORT $LN16@print_part
$LN7@print_part:
	test	esi, esi
	jne	SHORT $LN6@print_part
$LN16@print_part:
	mov	esi, DWORD PTR _active_edge_first
$LN6@print_part:

; 1898 :   for ( k = 0 ; ee && k <= 40 ; k++, ee=ee->next_active )

	xor	edi, edi
	test	esi, esi
	je	SHORT $LN3@print_part
$LL5@print_part:
	cmp	edi, 40					; 00000028H
	jg	SHORT $LN3@print_part

; 1899 :   { if ( ee == e ) printf(" -- %d -- ",ee->id);

	cmp	esi, ebx
	jne	SHORT $LN2@print_part
	mov	eax, DWORD PTR [esi]
	push	eax
	push	OFFSET ??_C@_0L@BKOHLMIH@?5?9?9?5?$CFd?5?9?9?5?$AA@
	jmp	SHORT $LN17@print_part
$LN2@print_part:

; 1900 :     else printf("%d ",ee->id);

	mov	ecx, DWORD PTR [esi]
	push	ecx
	push	OFFSET ??_C@_03JDANDILB@?$CFd?5?$AA@
$LN17@print_part:
	call	_printf
	mov	esi, DWORD PTR [esi+36]
	add	esp, 8
	inc	edi
	test	esi, esi
	jne	SHORT $LL5@print_part
$LN3@print_part:

; 1901 :   }
; 1902 :   printf("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_printf
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 1903 : }

	pop	ebp
	ret	0
_print_part_list ENDP
_TEXT	ENDS
PUBLIC	_vvcomp
; Function compile flags: /Ogtp
;	COMDAT _vvcomp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_vvcomp	PROC						; COMDAT

; 1915 : {

	push	ebp
	mov	ebp, esp

; 1916 :   if ( a->x[0] < b->x[0] ) return -1;

	mov	ecx, DWORD PTR _b$[ebp]
	fld	QWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@vvcomp
$LN7@vvcomp:
	or	eax, -1

; 1921 : } // end int vvcomp()

	pop	ebp
	ret	0
$LN4@vvcomp:

; 1917 :   if ( a->x[0] > b->x[0] ) return  1;

	fld	QWORD PTR [ecx]
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@vvcomp
$LN8@vvcomp:
	mov	eax, 1

; 1921 : } // end int vvcomp()

	pop	ebp
	ret	0
$LN3@vvcomp:

; 1918 :   if ( a->x[1] < b->x[1] ) return -1;

	fld	QWORD PTR [ecx+8]
	fcomp	QWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN7@vvcomp

; 1919 :   if ( a->x[1] > b->x[1] ) return  1;

	fld	QWORD PTR [ecx+8]
	fcomp	QWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN8@vvcomp

; 1920 :   return 0;

	xor	eax, eax

; 1921 : } // end int vvcomp()

	pop	ebp
	ret	0
_vvcomp	ENDP
_TEXT	ENDS
PUBLIC	_vecomp
; Function compile flags: /Ogtp
;	COMDAT _vecomp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_vecomp	PROC						; COMDAT

; 1934 : {

	push	ebp
	mov	ebp, esp

; 1935 :   if ( a[0]->v[0] < b[0]->v[0] ) return -1;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [ecx]
	cmp	edx, esi
	jae	SHORT $LN7@vecomp
$LN9@vecomp:
	or	eax, -1
	pop	esi

; 1939 :   return 0;
; 1940 : } // end int vecomp()

	pop	ebp
	ret	0
$LN7@vecomp:

; 1936 :   if ( a[0]->v[0] > b[0]->v[0] ) return  1;

	jbe	SHORT $LN3@vecomp
	mov	eax, 1
	pop	esi

; 1939 :   return 0;
; 1940 : } // end int vecomp()

	pop	ebp
	ret	0
$LN3@vecomp:

; 1937 :   if ( a[0]->v[1] < b[0]->v[1] ) return -1;

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, eax
	ja	SHORT $LN9@vecomp

; 1938 :   if ( a[0]->v[1] > b[0]->v[1] ) return  1;

	sbb	eax, eax
	neg	eax
	pop	esi

; 1939 :   return 0;
; 1940 : } // end int vecomp()

	pop	ebp
	ret	0
_vecomp	ENDP
_TEXT	ENDS
PUBLIC	__real@3d06849b86a12b9b
PUBLIC	_visibility_lists
;	COMDAT __real@3d06849b86a12b9b
CONST	SEGMENT
__real@3d06849b86a12b9b DQ 03d06849b86a12b9br	; 1e-014
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _visibility_lists
_TEXT	SEGMENT
_k$ = -32						; size = 4
_rights$ = -28						; size = 4
_lefts$ = -24						; size = 4
_bottoms$ = -20						; size = 4
_tops$ = -16						; size = 4
tv1147 = -12						; size = 4
_t$ = -8						; size = 4
_vv$ = -4						; size = 4
_visibility_lists PROC					; COMDAT

; 1950 : { int tops,bottoms,lefts,rights;

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1951 :   struct vis_vertex *vv;
; 1952 :   struct vis_rawedge *ve;
; 1953 :   struct tsort *t;
; 1954 :   int i,ii,iii;
; 1955 :   size_t k;
; 1956 : 
; 1957 :   /* Populate raw edge and vertex lists */
; 1958 :   vis_vertex_max = 3*vis_count;

	mov	eax, DWORD PTR _vis_count
	push	ebx
	push	esi

; 1959 :   vis_vertices = (struct vis_vertex *)temp_calloc(vis_vertex_max,
; 1960 :                                               sizeof(struct vis_vertex));

	push	1960					; 000007a8H
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	lea	eax, DWORD PTR [eax+eax*2]
	push	32					; 00000020H
	push	eax
	mov	DWORD PTR _vis_vertex_max, eax
	call	_kb_temp_calloc

; 1961 :   vv = vis_vertices;

	mov	esi, eax

; 1962 :   vis_vertex_count = 0;
; 1963 :   
; 1964 :   vis_rawedges = (struct vis_rawedge *)temp_calloc(3*vis_count,
; 1965 :                                               sizeof(struct vis_rawedge));

	push	1965					; 000007adH
	mov	DWORD PTR _vis_vertices, eax
	mov	eax, DWORD PTR _vis_count
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	lea	eax, DWORD PTR [eax+eax*2]
	push	20					; 00000014H
	xor	ebx, ebx
	push	eax
	mov	DWORD PTR _vv$[ebp], esi
	mov	DWORD PTR _vis_vertex_count, ebx
	call	_kb_temp_calloc

; 1966 :   ve = vis_rawedges;
; 1967 :   vecount = 0;
; 1968 : 
; 1969 :   for ( k = 0, t = vis_list ; k < vis_count ; k++,t++ )

	mov	edx, DWORD PTR _vis_list
	add	esp, 32					; 00000020H
	mov	DWORD PTR _vis_rawedges, eax
	mov	ecx, eax
	mov	DWORD PTR _vecount, ebx
	mov	DWORD PTR _k$[ebp], ebx
	mov	DWORD PTR _t$[ebp], edx
	cmp	DWORD PTR _vis_count, ebx
	jbe	$LN21@visibility@2
	fld	QWORD PTR __real@46293e5939a08cea
	push	edi
	fld	QWORD PTR __real@c6293e5939a08cea
	fld	QWORD PTR __real@3d06849b86a12b9b
$LN23@visibility@2:

; 1970 :   { if ( (t->flag & 0xF) == FACET )

	mov	edi, DWORD PTR [edx+28]
	mov	eax, edi
	and	al, 15					; 0000000fH
	cmp	al, 2
	jne	SHORT $LN20@visibility@2

; 1971 :     {
; 1972 :       REAL minu = 1e30, maxu = -1e30;
; 1973 : 
; 1974 :       if ( t->color == CLEAR )

	cmp	DWORD PTR [edx+4], -1
	fld	ST(2)
	fld	ST(2)
	jne	SHORT $LN19@visibility@2
	fstp	ST(0)
	fstp	ST(0)
$LN20@visibility@2:

; 1975 :       { t->flag |= VISIBLE; continue; }  /* kludge for now */

	or	edi, 16384				; 00004000H
	mov	DWORD PTR [edx+28], edi
	jmp	$LN22@visibility@2
$LN19@visibility@2:

; 1976 : 
; 1977 :       /* rotate coordinates for general position and get x bounding box */
; 1978 : 
; 1979 :       for ( i = 0 ; i < FACET_VERTS ; i++ )
; 1980 :       { 
; 1981 :         vv[i].x[0] = vis_va*t->x[i][0] + vis_vb*t->x[i][1];

	fld	DWORD PTR [edx+36]
	fmul	QWORD PTR _vis_vb
	fld	DWORD PTR [edx+32]
	fmul	QWORD PTR _vis_va
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi]

; 1982 :         vv[i].x[1] = -vis_vb*t->x[i][0] + vis_va*t->x[i][1];

	fld	DWORD PTR [edx+36]
	fmul	QWORD PTR _vis_va
	fld	DWORD PTR [edx+32]
	fmul	QWORD PTR _vis_vb
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [esi+8]

; 1983 :         if ( vv[i].x[0] < minu ) minu = vv[i].x[0];

	fxch	ST(4)
	fcom	QWORD PTR [esi]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN15@visibility@2
	fstp	ST(1)
	fld	QWORD PTR [esi]
	fxch	ST(1)
$LN15@visibility@2:

; 1984 :         if ( vv[i].x[0] > maxu ) maxu = vv[i].x[0];

	fxch	ST(3)
	fcom	QWORD PTR [esi]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN17@visibility@2
	fstp	ST(4)
	fld	QWORD PTR [esi]
	fxch	ST(4)
$LN17@visibility@2:

; 1976 : 
; 1977 :       /* rotate coordinates for general position and get x bounding box */
; 1978 : 
; 1979 :       for ( i = 0 ; i < FACET_VERTS ; i++ )
; 1980 :       { 
; 1981 :         vv[i].x[0] = vis_va*t->x[i][0] + vis_vb*t->x[i][1];

	fld	DWORD PTR [edx+48]
	fmul	QWORD PTR _vis_vb
	fld	DWORD PTR [edx+44]
	fmul	QWORD PTR _vis_va
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+32]

; 1982 :         vv[i].x[1] = -vis_vb*t->x[i][0] + vis_va*t->x[i][1];

	fld	DWORD PTR [edx+48]
	fmul	QWORD PTR _vis_va
	fld	DWORD PTR [edx+44]
	fmul	QWORD PTR _vis_vb
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [esi+40]

; 1983 :         if ( vv[i].x[0] < minu ) minu = vv[i].x[0];

	fxch	ST(1)
	fcom	QWORD PTR [esi+32]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN42@visibility@2
	fstp	ST(0)
	fld	QWORD PTR [esi+32]
$LN42@visibility@2:

; 1984 :         if ( vv[i].x[0] > maxu ) maxu = vv[i].x[0];

	fxch	ST(4)
	fcom	QWORD PTR [esi+32]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN43@visibility@2
	fstp	ST(0)
	fld	QWORD PTR [esi+32]
$LN43@visibility@2:

; 1976 : 
; 1977 :       /* rotate coordinates for general position and get x bounding box */
; 1978 : 
; 1979 :       for ( i = 0 ; i < FACET_VERTS ; i++ )
; 1980 :       { 
; 1981 :         vv[i].x[0] = vis_va*t->x[i][0] + vis_vb*t->x[i][1];

	fld	DWORD PTR [edx+60]
	fmul	QWORD PTR _vis_vb
	fld	DWORD PTR [edx+56]
	fmul	QWORD PTR _vis_va
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+64]

; 1982 :         vv[i].x[1] = -vis_vb*t->x[i][0] + vis_va*t->x[i][1];

	fld	DWORD PTR [edx+60]
	fmul	QWORD PTR _vis_va
	fld	DWORD PTR [edx+56]
	fmul	QWORD PTR _vis_vb
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [esi+72]

; 1983 :         if ( vv[i].x[0] < minu ) minu = vv[i].x[0];

	fxch	ST(4)
	fcom	QWORD PTR [esi+64]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN45@visibility@2
	fstp	ST(0)
	fld	QWORD PTR [esi+64]
$LN45@visibility@2:

; 1984 :         if ( vv[i].x[0] > maxu ) maxu = vv[i].x[0];

	fxch	ST(4)
	fcom	QWORD PTR [esi+64]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN46@visibility@2
	fstp	ST(0)
	fld	QWORD PTR [esi+64]
$LN46@visibility@2:

; 1985 :       }
; 1986 : 
; 1987 :       /* now, the edges */
; 1988 :       tops = 0; bottoms = 0; lefts = 0; rights = 0;

	mov	eax, 1
	mov	DWORD PTR _tops$[ebp], ebx
	mov	DWORD PTR _bottoms$[ebp], ebx
	mov	DWORD PTR _lefts$[ebp], ebx
	mov	DWORD PTR _rights$[ebp], ebx
	mov	DWORD PTR tv1147[ebp], eax
	mov	edi, esi
	jmp	SHORT $LN13@visibility@2
$LN47@visibility@2:
	mov	esi, DWORD PTR _vv$[ebp]
	mov	eax, DWORD PTR tv1147[ebp]
$LN13@visibility@2:

; 1990 :       { REAL area;
; 1991 :         ii = (i+1 >= FACET_VERTS) ? 0 : i+1;

	xor	ebx, ebx
	cmp	eax, 3
	setge	bl
	dec	ebx
	and	ebx, eax

; 1992 :         if ( vv[i].x[0] <= vv[ii].x[0] )  /* leftmost vertex first */

	mov	edx, ebx
	shl	edx, 5
	fld	QWORD PTR [edx+esi]
	add	edx, esi
	fcomp	QWORD PTR [edi]
	lea	esi, DWORD PTR [ecx+4]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN10@visibility@2

; 1993 :         { ve->v[0] = vv+i;

	mov	DWORD PTR [ecx], edi

; 1994 :           ve->v[1] = vv+ii;

	mov	DWORD PTR [esi], edx

; 1995 :           vv[i].fixup[0] = &ve->v[0];  /* so can adjust edges after sorting vertices */

	mov	DWORD PTR [edi+16], ecx

; 1996 :           vv[ii].fixup[1] = &ve->v[1];

	mov	DWORD PTR [edx+20], esi

; 1997 :         } else

	jmp	SHORT $LN9@visibility@2
$LN10@visibility@2:

; 1998 :         { ve->v[0] = vv+ii;

	mov	DWORD PTR [ecx], edx

; 1999 :           ve->v[1] = vv+i;

	mov	DWORD PTR [esi], edi

; 2000 :           vv[i].fixup[0] = &ve->v[1];  /* so can adjust edges after sorting vertices */

	mov	DWORD PTR [edi+16], esi

; 2001 :           vv[ii].fixup[1] = &ve->v[0];

	mov	DWORD PTR [edx+20], ecx
$LN9@visibility@2:

; 2002 :         }
; 2003 : 
; 2004 :         iii = (ii+1 >= FACET_VERTS) ? 0 : ii+1;  /* third vertex */
; 2005 :         area = (ve->v[1]->x[0]-ve->v[0]->x[0])*(vv[iii].x[1]-ve->v[0]->x[1])
; 2006 :           -(vv[iii].x[0]-ve->v[0]->x[0])*(ve->v[1]->x[1]-ve->v[0]->x[1]); 

	mov	esi, DWORD PTR [esi]
	xor	edx, edx
	lea	eax, DWORD PTR [ebx+1]
	cmp	eax, 3
	setge	dl
	dec	edx
	and	eax, edx
	mov	edx, DWORD PTR [ecx]
	shl	eax, 5
	add	eax, DWORD PTR _vv$[ebp]
	fld	QWORD PTR [eax+8]
	fsub	QWORD PTR [edx+8]
	fld	QWORD PTR [esi]
	fsub	QWORD PTR [edx]
	fmulp	ST(1), ST(0)
	fld	QWORD PTR [esi+8]
	fsub	QWORD PTR [edx+8]
	fld	QWORD PTR [eax]
	fsub	QWORD PTR [edx]
	fmulp	ST(1), ST(0)
	fsubp	ST(1), ST(0)

; 2007 :         if ( fabs(area) < 1e-14 ) break;

	fld	ST(0)
	fabs
	fcomp	ST(4)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN85@visibility@2

; 2008 : 
; 2009 :         if ( area > 0 )

	fldz

; 2010 :         { ve->flags |= V_FACET_BOTTOM; bottoms++; }

	mov	ebx, 1
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN7@visibility@2
	or	DWORD PTR [ecx+16], ebx
	add	DWORD PTR _bottoms$[ebp], ebx
	jmp	SHORT $LN6@visibility@2
$LN7@visibility@2:

; 2011 :         else { ve->flags |= V_FACET_TOP; tops++; }

	or	DWORD PTR [ecx+16], 2
	inc	DWORD PTR _tops$[ebp]
$LN6@visibility@2:

; 2012 : 
; 2013 :         if ( ve->v[0]->x[0] == minu )

	fld	QWORD PTR [edx]
	fld	ST(5)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@visibility@2

; 2014 :         { ve->flags |= V_FACET_LEFT; lefts++; }

	or	DWORD PTR [ecx+16], 4
	add	DWORD PTR _lefts$[ebp], ebx
$LN5@visibility@2:

; 2015 : 
; 2016 :         if ( ve->v[1]->x[0] == maxu )

	fld	QWORD PTR [esi]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@visibility@2

; 2017 :         { ve->flags |= V_FACET_RIGHT; rights++; }

	or	DWORD PTR [ecx+16], 8
	add	DWORD PTR _rights$[ebp], ebx
$LN4@visibility@2:

; 2018 : 
; 2019 :         ve->tsrt = t;

	mov	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR tv1147[ebp]

; 2020 :         ve++; vecount++;

	add	DWORD PTR _vecount, ebx
	add	eax, ebx
	mov	DWORD PTR tv1147[ebp], eax
	dec	eax
	add	ecx, 20					; 00000014H
	add	edi, 32					; 00000020H
	cmp	eax, 3
	jl	$LN47@visibility@2

; 1989 :       for ( i = 0 ; i < FACET_VERTS ; i++ )

	jmp	SHORT $LN97@visibility@2
$LN85@visibility@2:
	fstp	ST(0)
$LN97@visibility@2:

; 2021 :       }
; 2022 : 
; 2023 :       /* check we successfully found things, and skip edge-on facets */
; 2024 :       if ( (tops==0) || (bottoms==0) || (lefts!=2) || (rights!=2) )

	cmp	DWORD PTR _tops$[ebp], 0
	fstp	ST(0)
	fstp	ST(3)
	je	SHORT $LN48@visibility@2
	cmp	DWORD PTR _bottoms$[ebp], 0
	je	SHORT $LN48@visibility@2
	mov	eax, 2
	cmp	DWORD PTR _lefts$[ebp], eax
	jne	SHORT $LN48@visibility@2
	cmp	DWORD PTR _rights$[ebp], eax
	jne	SHORT $LN48@visibility@2

; 2025 :         continue;
; 2026 : 
; 2027 :       vv += FACET_VERTS; vis_vertex_count += FACET_VERTS;

	add	DWORD PTR _vv$[ebp], 96			; 00000060H
	add	DWORD PTR _vis_vertex_count, 3
$LN48@visibility@2:

; 2028 :     } 
; 2029 :     else  /* lone edge */

	mov	edx, DWORD PTR _t$[ebp]
	fxch	ST(1)
	mov	esi, DWORD PTR _vv$[ebp]
	fxch	ST(2)
	xor	ebx, ebx
	fxch	ST(1)
$LN22@visibility@2:

; 1966 :   ve = vis_rawedges;
; 1967 :   vecount = 0;
; 1968 : 
; 1969 :   for ( k = 0, t = vis_list ; k < vis_count ; k++,t++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	add	edx, 140				; 0000008cH
	mov	DWORD PTR _k$[ebp], eax
	mov	DWORD PTR _t$[ebp], edx
	cmp	eax, DWORD PTR _vis_count
	jb	$LN23@visibility@2
	fstp	ST(2)
	pop	edi
	fstp	ST(0)
	fstp	ST(0)
$LN21@visibility@2:
	pop	esi
	pop	ebx

; 2030 :     { 
; 2031 :       /* for now, make all lone edges visible */
; 2032 :       t->flag |= VISIBLE;
; 2033 :     }
; 2034 :   }
; 2035 : 
; 2036 : }  // end visibility_lists()

	mov	esp, ebp
	pop	ebp
	ret	0
_visibility_lists ENDP
_TEXT	ENDS
PUBLIC	_visibility_vertex_consolidate
EXTRN	_qsort:PROC
; Function compile flags: /Ogtp
;	COMDAT _visibility_vertex_consolidate
_TEXT	SEGMENT
tv314 = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
tv258 = -4						; size = 4
_visibility_vertex_consolidate PROC			; COMDAT

; 2046 : {int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2047 :   qsort(vis_vertices,vis_vertex_count,sizeof(struct vis_vertex),FCAST vvcomp);

	mov	eax, DWORD PTR _vis_vertex_count
	mov	ecx, DWORD PTR _vis_vertices
	push	OFFSET _vvcomp
	push	32					; 00000020H
	push	eax
	push	ecx
	call	_qsort

; 2048 :   for ( i = -1, j = 0 ; j < vis_vertex_count ; j++ )

	xor	ecx, ecx
	or	eax, -1
	add	esp, 16					; 00000010H
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR _j$[ebp], ecx
	cmp	DWORD PTR _vis_vertex_count, ecx
	jle	$LN18@visibility@3

; 2047 :   qsort(vis_vertices,vis_vertex_count,sizeof(struct vis_vertex),FCAST vvcomp);

	push	ebx
	push	esi
	mov	esi, 20					; 00000014H
	push	edi

; 2048 :   for ( i = -1, j = 0 ; j < vis_vertex_count ; j++ )

	lea	ebx, DWORD PTR [eax-31]
	mov	DWORD PTR tv258[ebp], ecx
	mov	DWORD PTR tv314[ebp], esi
	npad	6
$LL8@visibility@3:

; 2049 :   { int m;
; 2050 :     if ( (i < 0) || (vvcomp(vis_vertices+i,vis_vertices+j) != 0) ) 

	mov	edi, DWORD PTR _vis_vertices
	test	eax, eax
	js	SHORT $LN4@visibility@3
	mov	edx, DWORD PTR tv258[ebp]
	add	edx, edi
	push	edx
	lea	eax, DWORD PTR [ebx+edi]
	push	eax
	call	_vvcomp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN19@visibility@3
$LN4@visibility@3:

; 2051 :     { vis_vertices[++i] = vis_vertices[j];

	mov	ebx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR tv258[ebp]
	inc	ebx
	add	esi, edi
	mov	DWORD PTR _i$[ebp], ebx
	shl	ebx, 5
	add	edi, ebx
	mov	ecx, 8
	rep movsd
	mov	edi, DWORD PTR _vis_vertices
	mov	esi, DWORD PTR tv314[ebp]
$LN19@visibility@3:

; 2052 :     }
; 2053 :     /* use reverse pointers to fix up edges */
; 2054 :     for ( m = 0 ; m < 2 ; m++ )
; 2055 :      *(vis_vertices[j].fixup[m]) = vis_vertices+i;

	mov	eax, DWORD PTR [esi+edi-4]
	add	DWORD PTR tv258[ebp], 32		; 00000020H
	lea	edx, DWORD PTR [ebx+edi]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _vis_vertices
	mov	edx, DWORD PTR [esi+eax]
	lea	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	add	esi, 32					; 00000020H
	mov	DWORD PTR [edx], ecx
	cmp	eax, DWORD PTR _vis_vertex_count
	mov	DWORD PTR _j$[ebp], eax

; 2056 :   }
; 2057 :   vis_vertex_count = i+1;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv314[ebp], esi
	jl	SHORT $LL8@visibility@3
	pop	edi
	pop	esi
	pop	ebx
$LN18@visibility@3:
	inc	eax
	mov	DWORD PTR _vis_vertex_count, eax

; 2058 : } // end visibility_vertex_consolidate()

	mov	esp, ebp
	pop	ebp
	ret	0
_visibility_vertex_consolidate ENDP
_TEXT	ENDS
PUBLIC	_visibility_edge_consolidate
; Function compile flags: /Ogtp
;	COMDAT _visibility_edge_consolidate
_TEXT	SEGMENT
_visibility_edge_consolidate PROC			; COMDAT

; 2069 : 
; 2070 :   rawplist = (struct vis_rawedge **)temp_calloc(vecount,
; 2071 :                   sizeof(struct vis_rawedge *));

	mov	eax, DWORD PTR _vecount
	push	esi
	push	2071					; 00000817H
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	push	4
	push	eax
	call	_kb_temp_calloc

; 2072 :   for ( i = 0 ; i < vecount ; i++ ) rawplist[i] = vis_rawedges+i;

	mov	ecx, DWORD PTR _vecount
	mov	DWORD PTR _rawplist, eax
	add	esp, 16					; 00000010H
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN7@visibility@4

; 2069 : 
; 2070 :   rawplist = (struct vis_rawedge **)temp_calloc(vecount,
; 2071 :                   sizeof(struct vis_rawedge *));

	xor	edx, edx
	npad	2
$LL16@visibility@4:

; 2072 :   for ( i = 0 ; i < vecount ; i++ ) rawplist[i] = vis_rawedges+i;

	mov	ecx, DWORD PTR _vis_rawedges
	mov	esi, DWORD PTR _rawplist
	add	ecx, edx
	mov	DWORD PTR [esi+eax*4], ecx
	mov	ecx, DWORD PTR _vecount
	inc	eax
	add	edx, 20					; 00000014H
	cmp	eax, ecx
	jl	SHORT $LL16@visibility@4
$LN7@visibility@4:

; 2073 :   qsort(rawplist,vecount,sizeof(struct vis_rawedge*),FCAST vecomp);

	mov	edx, DWORD PTR _rawplist
	push	OFFSET _vecomp
	push	4
	push	ecx
	push	edx
	call	_qsort

; 2074 :   vis_conedge_max = vecount;

	mov	eax, DWORD PTR _vecount

; 2075 :   vis_conedges = (struct vis_conedge *) temp_calloc(vis_conedge_max,
; 2076 :                      sizeof(struct vis_conedge) );

	push	2076					; 0000081cH
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	push	72					; 00000048H
	push	eax
	mov	DWORD PTR _vis_conedge_max, eax
	call	_kb_temp_calloc

; 2077 :   for ( i = -1, j = 0 ; j < vecount ; j++ )

	xor	edx, edx
	add	esp, 32					; 00000020H
	or	esi, -1
	mov	DWORD PTR _vis_conedges, eax
	cmp	DWORD PTR _vecount, edx
	jle	$LN4@visibility@4
	push	ebx
	push	edi
	lea	ecx, DWORD PTR [esi-71]
	npad	3
$LL6@visibility@4:

; 2078 :   { if ( (j==0) || (vis_conedges[i].v[0] != rawplist[j]->v[0]) || 
; 2079 :          (vis_conedges[i].v[1] != rawplist[j]->v[1]) )

	test	edx, edx
	je	SHORT $LN18@visibility@4
	mov	edi, DWORD PTR _rawplist
	mov	edi, DWORD PTR [edi+edx*4]
	mov	ebx, DWORD PTR [ecx+eax+4]
	cmp	ebx, DWORD PTR [edi]
	jne	SHORT $LN18@visibility@4
	mov	ebx, DWORD PTR [ecx+eax+8]
	cmp	ebx, DWORD PTR [edi+4]
	jne	SHORT $LN18@visibility@4

; 2087 :     }
; 2088 :     else // same consolidated edge
; 2089 :       vis_conedges[i].rawend++;

	inc	DWORD PTR [ecx+eax+28]
	lea	eax, DWORD PTR [ecx+eax+28]
	jmp	SHORT $LN1@visibility@4
$LN18@visibility@4:

; 2080 :     { // new consolidated edge
; 2081 :       i++;

	inc	esi

; 2082 :       vis_conedges[i].id = i;

	lea	ecx, DWORD PTR [esi+esi*8]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR [ecx+eax], esi

; 2083 :       vis_conedges[i].v[0] = rawplist[j]->v[0];

	mov	eax, DWORD PTR _rawplist
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR _vis_conedges
	mov	DWORD PTR [ecx+edi+4], eax

; 2084 :       vis_conedges[i].v[1] = rawplist[j]->v[1];

	mov	eax, DWORD PTR _rawplist
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+4]
	mov	edi, DWORD PTR _vis_conedges
	mov	DWORD PTR [ecx+edi+8], eax

; 2085 :       vis_conedges[i].rawstart = j;

	mov	eax, DWORD PTR _vis_conedges
	mov	DWORD PTR [ecx+eax+24], edx

; 2086 :       vis_conedges[i].rawend = j;

	mov	eax, DWORD PTR _vis_conedges
	mov	DWORD PTR [ecx+eax+28], edx
$LN1@visibility@4:

; 2090 :     rawplist[j]->conedge = vis_conedges+i;

	mov	eax, DWORD PTR _vis_conedges
	mov	edi, DWORD PTR _rawplist
	mov	edi, DWORD PTR [edi+edx*4]
	add	eax, ecx
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR _vis_conedges
	inc	edx
	cmp	edx, DWORD PTR _vecount
	jl	$LL6@visibility@4
	pop	edi
	pop	ebx
$LN4@visibility@4:

; 2091 :   }
; 2092 :   i++;

	inc	esi

; 2093 :   vis_conedges = (struct vis_conedge*)temp_realloc((char*)vis_conedges,
; 2094 :      i*sizeof(struct vis_conedge));

	lea	ecx, DWORD PTR [esi+esi*8]
	add	ecx, ecx
	push	2094					; 0000082eH
	add	ecx, ecx
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	add	ecx, ecx
	push	ecx
	push	eax
	call	_kb_temp_realloc
	add	esp, 16					; 00000010H

; 2095 :   vis_conedge_max = vis_conedge_count = i;

	mov	DWORD PTR _vis_conedge_count, esi
	mov	DWORD PTR _vis_conedge_max, esi
	mov	DWORD PTR _vis_conedges, eax
	pop	esi

; 2096 : 
; 2097 : } // end visibility_edge_consolidate()

	ret	0
_visibility_edge_consolidate ENDP
_TEXT	ENDS
PUBLIC	_visibility_edge_sort
; Function compile flags: /Ogtp
;	COMDAT _visibility_edge_sort
_TEXT	SEGMENT
_visibility_edge_sort PROC				; COMDAT

; 2108 :   struct vis_conedge *vc,*ee,*prev_ee;
; 2109 : 
; 2110 :   /* Initialize edge slopes */
; 2111 :   for ( i = 0, vc = vis_conedges; i < vis_conedge_count; i++, vc++ )

	mov	edx, DWORD PTR _vis_conedges
	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR _vis_conedge_count, ebx
	jle	$LN13@visibility@5
	push	esi
	push	edi
$LL26@visibility@5:

; 2112 :   { REAL du = vc->v[1]->x[0] - vc->v[0]->x[0];
; 2113 :     REAL dv = vc->v[1]->x[1] - vc->v[0]->x[1];

	mov	eax, DWORD PTR [edx+8]
	mov	esi, DWORD PTR [edx+4]
	fld	QWORD PTR [eax+8]
	fsub	QWORD PTR [esi+8]

; 2114 :     vc->m = dv/du;
; 2115 : 
; 2116 :     // Install in left vertex right edges, by increasing slope
; 2117 :     prev_ee = NULL;

	xor	edi, edi
	fld	QWORD PTR [eax]
	fsub	QWORD PTR [esi]
	fdivp	ST(1), ST(0)
	fst	QWORD PTR [edx+16]

; 2118 :     for ( ee = vc->v[0]->right_edge_head ; ee ; ee = ee->right_edge_next )

	mov	ecx, DWORD PTR [esi+28]
	test	ecx, ecx
	je	SHORT $LN34@visibility@5
$LN12@visibility@5:

; 2119 :     { if ( vc->m < ee->m )

	fcom	QWORD PTR [ecx+16]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN34@visibility@5

; 2120 :         break;
; 2121 :       prev_ee = ee;

	mov	edi, ecx
	mov	ecx, DWORD PTR [ecx+44]
	test	ecx, ecx
	jne	SHORT $LN12@visibility@5
$LN34@visibility@5:

; 2119 :     { if ( vc->m < ee->m )

	fstp	ST(0)

; 2122 :     }
; 2123 :     vc->right_edge_next = ee;

	mov	DWORD PTR [edx+44], ecx

; 2124 :     if ( prev_ee )

	test	edi, edi
	je	SHORT $LN8@visibility@5

; 2125 :       prev_ee->right_edge_next = vc;

	mov	DWORD PTR [edi+44], edx

; 2126 :     else 

	jmp	SHORT $LN7@visibility@5
$LN8@visibility@5:

; 2127 :       vc->v[0]->right_edge_head = vc;

	mov	DWORD PTR [esi+28], edx
$LN7@visibility@5:

; 2128 : 
; 2129 :     // Install in right vertex left edges, by decreasing slope
; 2130 :     prev_ee = NULL;
; 2131 :     for ( ee = vc->v[1]->left_edge_head ; ee ; ee = ee->left_edge_next )

	mov	edi, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [edi+24]
	xor	esi, esi
	test	ecx, ecx
	je	SHORT $LN28@visibility@5
$LL6@visibility@5:

; 2132 :     { if ( vc->m > ee->m )

	fld	QWORD PTR [ecx+16]
	fcomp	QWORD PTR [edx+16]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN28@visibility@5

; 2133 :         break;
; 2134 :       prev_ee = ee;

	mov	esi, ecx
	mov	ecx, DWORD PTR [ecx+40]
	test	ecx, ecx
	jne	SHORT $LL6@visibility@5
$LN28@visibility@5:

; 2135 :     }
; 2136 :     vc->left_edge_next = ee;

	mov	DWORD PTR [edx+40], ecx

; 2137 :     if ( prev_ee )

	test	esi, esi
	je	SHORT $LN2@visibility@5

; 2138 :       prev_ee->left_edge_next = vc;

	mov	DWORD PTR [esi+40], edx

; 2139 :     else 

	jmp	SHORT $LN14@visibility@5
$LN2@visibility@5:

; 2140 :       vc->v[1]->left_edge_head = vc;

	mov	DWORD PTR [edi+24], edx
$LN14@visibility@5:

; 2108 :   struct vis_conedge *vc,*ee,*prev_ee;
; 2109 : 
; 2110 :   /* Initialize edge slopes */
; 2111 :   for ( i = 0, vc = vis_conedges; i < vis_conedge_count; i++, vc++ )

	inc	ebx
	add	edx, 72					; 00000048H
	cmp	ebx, DWORD PTR _vis_conedge_count
	jl	SHORT $LL26@visibility@5
	pop	edi
	pop	esi
$LN13@visibility@5:
	pop	ebx

; 2141 :   }
; 2142 : 
; 2143 : } // end visibility_edge_sort()

	ret	0
_visibility_edge_sort ENDP
_TEXT	ENDS
PUBLIC	_vis_event_comp
; Function compile flags: /Ogtp
;	COMDAT _vis_event_comp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_vis_event_comp PROC					; COMDAT

; 2297 : { REAL ma,mb;

	push	ebp
	mov	ebp, esp

; 2298 :   if ( a->time < b->time ) return -1;

	mov	edx, DWORD PTR _b$[ebp]
	fld	QWORD PTR [edx]
	mov	ecx, DWORD PTR _a$[ebp]
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN8@vis_event_
	or	eax, -1

; 2308 :   return 0;
; 2309 : } // end vis_event_comp()

	pop	ebp
	ret	0
$LN8@vis_event_:

; 2299 :   if ( a->time > b->time ) return  1;

	fld	QWORD PTR [edx]
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN7@vis_event_
	mov	eax, 1

; 2308 :   return 0;
; 2309 : } // end vis_event_comp()

	pop	ebp
	ret	0
$LN7@vis_event_:
	push	esi

; 2300 :   ma = (a->e1->m+a->e2->m);

	mov	esi, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+8]
	fld	QWORD PTR [ecx+16]
	push	edi

; 2301 :   mb = (b->e1->m+b->e2->m);

	mov	edi, DWORD PTR [edx+12]
	fadd	QWORD PTR [esi+16]
	mov	edx, DWORD PTR [edx+8]
	fld	QWORD PTR [edx+16]
	fadd	QWORD PTR [edi+16]

; 2302 :   if ( ma < mb ) return -1;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN6@vis_event_
	fstp	ST(1)
	fstp	ST(0)
$LN18@vis_event_:
	pop	edi
	or	eax, -1
	pop	esi

; 2308 :   return 0;
; 2309 : } // end vis_event_comp()

	pop	ebp
	ret	0
$LN6@vis_event_:

; 2303 :   if ( ma > mb ) return  1;

	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN19@vis_event_

; 2304 :   if ( a->e1 < b->e1 ) return -1;

	cmp	ecx, edx
	jb	SHORT $LN18@vis_event_

; 2305 :   if ( a->e1 > b->e1 ) return  1;

	jbe	SHORT $LN3@vis_event_
$LN19@vis_event_:
	pop	edi
	mov	eax, 1
	pop	esi

; 2308 :   return 0;
; 2309 : } // end vis_event_comp()

	pop	ebp
	ret	0
$LN3@vis_event_:

; 2306 :   if ( a->e2 < b->e2 ) return -1;

	cmp	edi, esi
	ja	SHORT $LN18@vis_event_

; 2307 :   if ( a->e2 > b->e2 ) return  1;

	sbb	eax, eax
	pop	edi
	neg	eax
	pop	esi

; 2308 :   return 0;
; 2309 : } // end vis_event_comp()

	pop	ebp
	ret	0
_vis_event_comp ENDP
_TEXT	ENDS
PUBLIC	_vis_insert_heap
EXTRN	_KB_realloc:PROC
; Function compile flags: /Ogtp
;	COMDAT _vis_insert_heap
_TEXT	SEGMENT
_e$ = 8							; size = 4
_vis_insert_heap PROC					; COMDAT

; 2321 : { int k,kk;

	push	ebp
	mov	ebp, esp

; 2322 :   int result;
; 2323 : 
; 2324 :   if ( vis_heap_count >= vis_heap_max-1 )

	mov	eax, DWORD PTR _vis_heap_max
	lea	ecx, DWORD PTR [eax-1]
	cmp	DWORD PTR _vis_heap_count, ecx
	jl	SHORT $LN11@vis_insert

; 2325 :   { vis_heap = (struct vis_event *)kb_realloc((char*)vis_heap,
; 2326 :                  2*vis_heap_max*sizeof(struct vis_event));

	mov	edx, DWORD PTR _vis_heap
	push	2326					; 00000916H
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	shl	eax, 5
	push	eax
	push	edx
	call	_KB_realloc
	mov	DWORD PTR _vis_heap, eax

; 2327 :     vis_heap_max *= 2;

	mov	eax, DWORD PTR _vis_heap_max
	lea	ecx, DWORD PTR [eax+eax]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vis_heap_max, ecx
$LN11@vis_insert:

; 2328 :   }
; 2329 : 
; 2330 :   for ( k = vis_heap_count ; k > 0 ; k = kk )

	push	ebx
	mov	ebx, DWORD PTR _vis_heap_count
	test	ebx, ebx
	jle	SHORT $LN13@vis_insert
	push	esi
	push	edi
$LL12@vis_insert:

; 2331 :   { 
; 2332 :     kk = (k-1)/2;
; 2333 :     result = vis_event_comp(e,&vis_heap[kk]); 

	mov	ecx, DWORD PTR _e$[ebp]
	lea	eax, DWORD PTR [ebx-1]
	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	mov	esi, edi
	shl	esi, 4
	add	esi, DWORD PTR _vis_heap
	push	esi
	push	ecx
	call	_vis_event_comp
	add	esp, 8

; 2334 :     if ( result < 0 )

	test	eax, eax
	jns	SHORT $LN14@vis_insert

; 2335 :     { 
; 2336 :       vis_heap[k] = vis_heap[kk];

	mov	edx, DWORD PTR [esi]
	mov	eax, ebx
	shl	eax, 4
	add	eax, DWORD PTR _vis_heap
	mov	ebx, edi
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], ecx
	test	edi, edi
	jg	SHORT $LL12@vis_insert
$LN14@vis_insert:
	pop	edi
	pop	esi
$LN13@vis_insert:

; 2337 :     }
; 2338 :     else break;
; 2339 :   }
; 2340 :   vis_heap[k] = *e;

	mov	eax, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [eax]
	shl	ebx, 4
	add	ebx, DWORD PTR _vis_heap
	mov	DWORD PTR [ebx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ebx+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ebx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ebx+12], eax

; 2341 :   vis_heap_count++;

	inc	DWORD PTR _vis_heap_count
	pop	ebx

; 2342 : 
; 2343 : } // end vis_insert_heap()

	pop	ebp
	ret	0
_vis_insert_heap ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@NJAEONAF@vis_delete_heap?5trying?5to?5delete@ ; `string'
PUBLIC	_vis_delete_heap
;	COMDAT ??_C@_0CM@NJAEONAF@vis_delete_heap?5trying?5to?5delete@
CONST	SEGMENT
??_C@_0CM@NJAEONAF@vis_delete_heap?5trying?5to?5delete@ DB 'vis_delete_he'
	DB	'ap trying to delete sentinel.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _vis_delete_heap
_TEXT	SEGMENT
_e$ = -16						; size = 16
tv237 = 8						; size = 4
_kk$ = 8						; size = 4
_n$ = 8							; size = 4
_vis_delete_heap PROC					; COMDAT

; 2353 : { int k,kk;

	push	ebp
	mov	ebp, esp

; 2354 :   int result;
; 2355 :   struct vis_event e;
; 2356 : 
; 2357 :   if ( n == vis_heap_count-1 ) 

	mov	eax, DWORD PTR _vis_heap_count
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, DWORD PTR _n$[ebp]
	lea	ecx, DWORD PTR [eax-1]
	cmp	ebx, ecx
	jne	SHORT $LN19@vis_delete

; 2358 :   { vis_heap_count--;

	mov	DWORD PTR _vis_heap_count, ecx
	pop	ebx

; 2425 :   }
; 2426 : vis_delete_heap_exit: ;
; 2427 : 
; 2428 : } // end vis_delete_heap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@vis_delete:

; 2359 :     goto vis_delete_heap_exit;
; 2360 :   }
; 2361 : 
; 2362 :   if ( vis_heap_count == 1 )

	cmp	eax, 1
	jne	SHORT $LN18@vis_delete

; 2363 :    kb_error(2421,"vis_delete_heap trying to delete sentinel.\n",RECOVERABLE);

	push	eax
	push	OFFSET ??_C@_0CM@NJAEONAF@vis_delete_heap?5trying?5to?5delete@
	push	2421					; 00000975H
	call	_kb_error
	mov	eax, DWORD PTR _vis_heap_count
	add	esp, 12					; 0000000cH
$LN18@vis_delete:

; 2364 : 
; 2365 :   /* replace with top event */
; 2366 :   e = vis_heap[--vis_heap_count]; 

	dec	eax
	mov	DWORD PTR _vis_heap_count, eax
	push	esi
	push	edi
	mov	edi, DWORD PTR _vis_heap
	shl	eax, 4
	mov	ecx, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [eax+edi+4]
	add	eax, edi
	mov	DWORD PTR _e$[ebp], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _e$[ebp+4], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _e$[ebp+8], ecx
	mov	DWORD PTR _e$[ebp+12], edx

; 2367 : 
; 2368 :   /* check direction to percolate */
; 2369 :   result = (n==0) ? 1 : vis_event_comp(&e,vis_heap+(n-1)/2);

	test	ebx, ebx
	je	$LN17@vis_delete
	lea	eax, DWORD PTR [ebx-1]
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	mov	eax, esi
	shl	eax, 4
	add	eax, edi
	push	eax
	lea	ecx, DWORD PTR _e$[ebp]
	push	ecx
	call	_vis_event_comp
	add	esp, 8

; 2370 :   if ( result < 0 )

	test	eax, eax
	jns	$LN17@vis_delete

; 2371 :   { /* downward */
; 2372 :     k = n;
; 2373 :     kk = (n-1)/2;
; 2374 :     vis_heap[k] = vis_heap[kk];

	mov	eax, esi
	shl	eax, 4
	mov	edx, DWORD PTR [eax+edi]
	add	eax, edi
	shl	ebx, 4
	add	ebx, edi
	mov	DWORD PTR [ebx], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ebx+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ebx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ebx+12], eax

; 2375 :     for ( k = kk ; k > 0 ; k = kk )

	mov	ebx, esi
	test	esi, esi
	jle	SHORT $LN32@vis_delete
$LL16@vis_delete:

; 2376 :     { kk = (k-1)/2;

	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax

; 2377 :       result = vis_event_comp(&e,vis_heap+kk);

	mov	edi, esi
	shl	edi, 4
	add	edi, DWORD PTR _vis_heap
	lea	eax, DWORD PTR _e$[ebp]
	push	edi
	push	eax
	call	_vis_event_comp
	add	esp, 8

; 2378 :       if ( result < 0 )

	test	eax, eax
	jns	SHORT $LN32@vis_delete

; 2379 :       { vis_heap[k] = vis_heap[kk];

	mov	ecx, DWORD PTR [edi]
	mov	eax, ebx
	shl	eax, 4
	add	eax, DWORD PTR _vis_heap
	mov	ebx, esi
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [eax+12], edx
	test	esi, esi
	jg	SHORT $LL16@vis_delete
$LN32@vis_delete:

; 2380 :         continue;
; 2381 :       }
; 2382 :       else 
; 2383 :       { break;
; 2384 :       }
; 2385 :     }
; 2386 :     vis_heap[k] = e;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _e$[ebp+4]
	mov	edx, DWORD PTR _e$[ebp+8]
	shl	ebx, 4
	add	ebx, DWORD PTR _vis_heap
	pop	edi
	mov	DWORD PTR [ebx], eax
	mov	eax, DWORD PTR _e$[ebp+12]
	mov	DWORD PTR [ebx+4], ecx
	mov	DWORD PTR [ebx+8], edx
	pop	esi
	mov	DWORD PTR [ebx+12], eax
	pop	ebx

; 2425 :   }
; 2426 : vis_delete_heap_exit: ;
; 2427 : 
; 2428 : } // end vis_delete_heap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@vis_delete:

; 2387 :     goto vis_delete_heap_exit; 
; 2388 :   }
; 2389 :   else
; 2390 :   { /* upward */
; 2391 :     for ( k = n; 2*k+1 < vis_heap_count ; k = kk )

	lea	ecx, DWORD PTR [ebx+ebx+1]
	mov	esi, ebx
	cmp	ecx, DWORD PTR _vis_heap_count
	jge	$LN8@vis_delete
	npad	9
$LL33@vis_delete:

; 2392 :     { 
; 2393 :       if ( 2*k+2 >= vis_heap_count )

	lea	ebx, DWORD PTR [esi+esi+2]
	cmp	ebx, DWORD PTR _vis_heap_count
	jge	$LN28@vis_delete

; 2404 :           goto vis_delete_heap_exit;
; 2405 :         }
; 2406 :       }
; 2407 :       else
; 2408 :       { /* two parents */
; 2409 :         result = vis_event_comp(&vis_heap[2*k+1],&vis_heap[2*k+2]);

	mov	eax, esi
	shl	eax, 5
	add	eax, edi
	lea	ecx, DWORD PTR [eax+32]
	push	ecx
	add	eax, 16					; 00000010H
	push	eax
	call	_vis_event_comp
	add	esp, 8

; 2410 :         kk = (result < 0) ? 2*k+1 : 2*k+2;

	test	eax, eax
	jns	SHORT $LN24@vis_delete
	lea	edx, DWORD PTR [esi+esi+1]
	mov	DWORD PTR _kk$[ebp], edx
	jmp	SHORT $LN25@vis_delete
$LN24@vis_delete:
	mov	DWORD PTR _kk$[ebp], ebx
$LN25@vis_delete:

; 2411 :         result = vis_event_comp(&e,vis_heap+kk);

	mov	ebx, DWORD PTR _kk$[ebp]
	shl	ebx, 4
	add	ebx, edi
	lea	ecx, DWORD PTR _e$[ebp]
	push	ebx
	push	ecx
	call	_vis_event_comp
	add	esp, 8

; 2412 :         if ( result < 0 )

	test	eax, eax
	js	$LN29@vis_delete

; 2415 :           goto vis_delete_heap_exit;
; 2416 :         }
; 2417 :         else if ( result > 0 )

	jle	SHORT $LN9@vis_delete

; 2418 :         { /* keep going up */
; 2419 :           vis_heap[k] = vis_heap[kk];

	mov	edx, DWORD PTR [ebx]
	shl	esi, 4
	add	esi, edi
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], eax
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [esi+8], ecx
	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+12], edx
	mov	edi, DWORD PTR _vis_heap
$LN9@vis_delete:

; 2387 :     goto vis_delete_heap_exit; 
; 2388 :   }
; 2389 :   else
; 2390 :   { /* upward */
; 2391 :     for ( k = n; 2*k+1 < vis_heap_count ; k = kk )

	mov	esi, DWORD PTR _kk$[ebp]
	lea	eax, DWORD PTR [esi+esi+1]
	cmp	eax, DWORD PTR _vis_heap_count
	jl	$LL33@vis_delete
$LN8@vis_delete:

; 2420 :           continue;
; 2421 :         }
; 2422 :       }
; 2423 :     }
; 2424 :     vis_heap[k] = e;   /* in case at top of heap */

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR _e$[ebp+4]
	mov	eax, DWORD PTR _e$[ebp+8]
	shl	esi, 4
	add	esi, edi
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR _e$[ebp+12]
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], ecx
	pop	esi
$vis_delete_heap_exit$90404:
	pop	ebx

; 2425 :   }
; 2426 : vis_delete_heap_exit: ;
; 2427 : 
; 2428 : } // end vis_delete_heap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@vis_delete:

; 2394 :       { /* only one parent */
; 2395 :         kk = 2*k+1;

	lea	eax, DWORD PTR [esi+esi+1]

; 2396 :         result = vis_event_comp(&e,vis_heap+kk);

	shl	eax, 4
	lea	ebx, DWORD PTR [eax+edi]
	lea	ecx, DWORD PTR _e$[ebp]
	push	ebx
	push	ecx
	mov	DWORD PTR tv237[ebp], eax
	call	_vis_event_comp

; 2397 :         if ( result > 0 )
; 2398 :         { vis_heap[k] = vis_heap[kk]; 

	shl	esi, 4
	add	esp, 8
	add	esi, edi
	test	eax, eax
	jle	SHORT $LN6@vis_delete
	mov	edx, DWORD PTR [ebx]
	mov	DWORD PTR [esi], edx
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+4], eax
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [esi+8], ecx
	mov	edx, DWORD PTR [ebx+12]

; 2399 :           vis_heap[kk] = e;

	mov	ecx, DWORD PTR _e$[ebp+4]
	mov	DWORD PTR [esi+12], edx
	mov	eax, DWORD PTR _vis_heap
	add	eax, DWORD PTR tv237[ebp]
	mov	edx, DWORD PTR _e$[ebp]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR _e$[ebp+8]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR _e$[ebp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], ecx
	pop	ebx

; 2425 :   }
; 2426 : vis_delete_heap_exit: ;
; 2427 : 
; 2428 : } // end vis_delete_heap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@vis_delete:

; 2400 :           goto vis_delete_heap_exit;
; 2401 :         }
; 2402 :         else 
; 2403 :         { vis_heap[k] = e;

	mov	edx, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR _e$[ebp+4]
	mov	ecx, DWORD PTR _e$[ebp+8]
	mov	DWORD PTR [esi], edx
	mov	edx, DWORD PTR _e$[ebp+12]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ecx
	pop	edi
	mov	DWORD PTR [esi+12], edx
	pop	esi
	pop	ebx

; 2425 :   }
; 2426 : vis_delete_heap_exit: ;
; 2427 : 
; 2428 : } // end vis_delete_heap()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@vis_delete:

; 2413 :         { /* done */
; 2414 :           vis_heap[k] = e;

	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _e$[ebp+4]
	mov	edx, DWORD PTR _e$[ebp+8]
	shl	esi, 4
	add	esi, edi
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _e$[ebp+12]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], edx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	pop	esi
	pop	ebx

; 2425 :   }
; 2426 : vis_delete_heap_exit: ;
; 2427 : 
; 2428 : } // end vis_delete_heap()

	mov	esp, ebp
	pop	ebp
	ret	0
_vis_delete_heap ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@CIALLIIK@Adding?5facet?5?$CFd?5to?5edge?5?$CFd?5layer@ ; `string'
PUBLIC	_add_layer
EXTRN	_fprintf:PROC
EXTRN	___iob_func:PROC
;	COMDAT ??_C@_0CE@CIALLIIK@Adding?5facet?5?$CFd?5to?5edge?5?$CFd?5layer@
CONST	SEGMENT
??_C@_0CE@CIALLIIK@Adding?5facet?5?$CFd?5to?5edge?5?$CFd?5layer@ DB 'Addi'
	DB	'ng facet %d to edge %d layers.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _add_layer
_TEXT	SEGMENT
_ee$ = 8						; size = 4
_newcount$90436 = 12					; size = 4
_f$ = 12						; size = 4
_add_layer PROC						; COMDAT

; 2443 : { int i;

	push	ebp
	mov	ebp, esp

; 2444 :   int retval;
; 2445 : 
; 2446 :   debug_seq++;

	inc	DWORD PTR _debug_seq
	push	ebx

; 2447 : 
; 2448 :   f->flag |= VISIBILITY_LIVE;

	mov	ebx, DWORD PTR _f$[ebp]
	or	DWORD PTR [ebx+28], 131072		; 00020000H
	push	esi

; 2449 :   for ( i = 0 ; i < ee->layers ; i++ )

	mov	esi, DWORD PTR _ee$[ebp]
	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+52], edi
	jle	SHORT $LN16@add_layer

; 2444 :   int retval;
; 2445 : 
; 2446 :   debug_seq++;

	mov	eax, DWORD PTR [esi+56]
$LL10@add_layer:

; 2450 :     if ( ee->layer[i] == f ) break;

	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN16@add_layer

; 2449 :   for ( i = 0 ; i < ee->layers ; i++ )

	inc	edi
	add	eax, 4
	cmp	edi, DWORD PTR [esi+52]
	jl	SHORT $LL10@add_layer
$LN16@add_layer:

; 2451 :   if ( i == ee->maxlayers )

	mov	eax, DWORD PTR [esi+60]
	cmp	edi, eax
	jne	SHORT $LN6@add_layer

; 2452 :   { int newcount = (ee->maxlayers > 10) ? 2*ee->maxlayers : ee->maxlayers + 10;

	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN13@add_layer
	add	eax, eax
	jmp	SHORT $LN20@add_layer
$LN13@add_layer:
	add	eax, 10					; 0000000aH
$LN20@add_layer:

; 2453 :     ee->layer = (struct tsort **)temp_realloc((char*)(ee->layer),
; 2454 :         newcount*sizeof(struct tsort*));

	push	2454					; 00000996H
	mov	ecx, eax
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	lea	edx, DWORD PTR [ecx*4]
	mov	DWORD PTR _newcount$90436[ebp], eax
	mov	eax, DWORD PTR [esi+56]
	push	edx
	push	eax
	call	_kb_temp_realloc

; 2455 :     ee->maxlayers = newcount;

	mov	ecx, DWORD PTR _newcount$90436[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+60], ecx
$LN6@add_layer:

; 2456 :   }
; 2457 :   if ( i == ee->layers )

	mov	eax, DWORD PTR [esi+52]
	cmp	edi, eax
	jne	$LN5@add_layer

; 2458 :   { /* not already found in layer list */
; 2459 :     ee->layer[ee->layers++] = f;

	mov	edx, DWORD PTR [esi+56]
	mov	DWORD PTR [edx+eax*4], ebx
	inc	DWORD PTR [esi+52]

; 2460 :     if ( visdebuglevel >= VIS_EVENTDUMP )

	cmp	DWORD PTR _visdebuglevel, 3
	jl	SHORT $LN4@add_layer

; 2461 :       fprintf(stderr,"Adding facet %d to edge %d layers.\n",
; 2462 :          (int)(f->f_id & 0xFFFFFF)+1,(int)(ee-vis_conedges));

	mov	ecx, esi
	sub	ecx, DWORD PTR _vis_conedges
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	mov	ecx, DWORD PTR [ebx]
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	and	ecx, 16777215				; 00ffffffH
	push	eax
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_0CE@CIALLIIK@Adding?5facet?5?$CFd?5to?5edge?5?$CFd?5layer@
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H
$LN4@add_layer:

; 2463 :     if ( !(ee->flags & V_LAYER_CHECK) )

	mov	ebx, 16					; 00000010H
	test	BYTE PTR [esi+48], bl
	jne	SHORT $LN19@add_layer

; 2464 :     { 
; 2465 :       if ( check_list_count >= check_list_max )

	mov	eax, DWORD PTR _check_list_max
	cmp	DWORD PTR _check_list_count, eax
	jl	SHORT $LN18@add_layer

; 2466 :       { check_list = (struct vis_conedge **)temp_realloc((char*)check_list,
; 2467 :           2*check_list_max*sizeof(struct vis_conedge *));

	push	2467					; 000009a3H
	lea	edx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR _check_list
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	push	edx
	push	eax
	call	_kb_temp_realloc

; 2468 :         check_list_max *= 2;

	mov	ecx, DWORD PTR _check_list_max
	lea	edx, DWORD PTR [ecx+ecx]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _check_list, eax
	mov	DWORD PTR _check_list_max, edx
$LN18@add_layer:

; 2469 :       }
; 2470 :       check_list[check_list_count++] = ee;

	mov	ecx, DWORD PTR _check_list_count
	mov	eax, DWORD PTR _check_list
	mov	DWORD PTR [eax+ecx*4], esi
	inc	DWORD PTR _check_list_count

; 2471 :       ee->flags |= V_LAYER_CHECK;

	or	DWORD PTR [esi+48], ebx
$LN19@add_layer:

; 2472 :     }
; 2473 :     retval = 1;

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 2476 : 
; 2477 :   return retval;
; 2478 : } // end add_layer()

	pop	ebp
	ret	0
$LN5@add_layer:
	pop	edi
	pop	esi

; 2474 :   }
; 2475 :   else retval = 0;

	xor	eax, eax
	pop	ebx

; 2476 : 
; 2477 :   return retval;
; 2478 : } // end add_layer()

	pop	ebp
	ret	0
_add_layer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@DBJMCPJE@Deleting?5facet?5?$CFd?5from?5edge?5?$CFd?5l@ ; `string'
PUBLIC	_delete_layer
;	COMDAT ??_C@_0CI@DBJMCPJE@Deleting?5facet?5?$CFd?5from?5edge?5?$CFd?5l@
CONST	SEGMENT
??_C@_0CI@DBJMCPJE@Deleting?5facet?5?$CFd?5from?5edge?5?$CFd?5l@ DB 'Dele'
	DB	'ting facet %d from edge %d layers.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _delete_layer
_TEXT	SEGMENT
_ee$ = 8						; size = 4
_f$ = 12						; size = 4
_delete_layer PROC					; COMDAT

; 2494 : { int i;

	push	ebp
	mov	ebp, esp
	push	esi

; 2496 : 
; 2497 :   for ( i = 0 ; i < ee->layers ; i++ )

	mov	esi, DWORD PTR _ee$[ebp]
	mov	eax, DWORD PTR [esi+52]
	xor	edx, edx
	xor	ecx, ecx
	test	eax, eax
	jle	$LN13@delete_lay

; 2495 :   int retval = 0;

	push	ebx
	mov	ebx, DWORD PTR _f$[ebp]
	push	edi
	mov	edi, DWORD PTR [esi+56]
	mov	edx, edi
$LL7@delete_lay:

; 2498 :     if ( ee->layer[i] == f )

	cmp	DWORD PTR [edx], ebx
	je	SHORT $LN11@delete_lay

; 2496 : 
; 2497 :   for ( i = 0 ; i < ee->layers ; i++ )

	inc	ecx
	add	edx, 4
	cmp	ecx, eax
	jl	SHORT $LL7@delete_lay

; 2513 :       break;
; 2514 :     }
; 2515 : 
; 2516 :   return retval;

	pop	edi
	pop	ebx
	xor	eax, eax
	pop	esi

; 2517 : } // end delete_layer()

	pop	ebp
	ret	0
$LN11@delete_lay:

; 2499 :     { ee->layer[i] = ee->layer[--ee->layers];

	dec	eax
	mov	DWORD PTR [esi+52], eax
	mov	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [edi+ecx*4], eax

; 2500 :       if ( visdebuglevel >= VIS_EVENTDUMP )

	cmp	DWORD PTR _visdebuglevel, 3
	jl	SHORT $LN15@delete_lay

; 2501 :         fprintf(stderr,"Deleting facet %d from edge %d layers.\n",
; 2502 :           (int)(f->f_id & 0xFFFFF)+1,(int)(ee-vis_conedges));

	mov	ecx, esi
	sub	ecx, DWORD PTR _vis_conedges
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	edx, DWORD PTR [ebx]
	and	edx, 1048575				; 000fffffH
	push	ecx
	inc	edx
	push	edx
	push	OFFSET ??_C@_0CI@DBJMCPJE@Deleting?5facet?5?$CFd?5from?5edge?5?$CFd?5l@
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 16					; 00000010H
$LN15@delete_lay:

; 2503 :       if ( !(ee->flags & V_LAYER_CHECK) )

	mov	ebx, 16					; 00000010H
	test	BYTE PTR [esi+48], bl
	jne	SHORT $LN16@delete_lay

; 2504 :       { if ( check_list_count >= check_list_max )

	mov	eax, DWORD PTR _check_list_max
	cmp	DWORD PTR _check_list_count, eax
	jl	SHORT $LN14@delete_lay

; 2505 :         { check_list = (struct vis_conedge **)temp_realloc((char*)check_list,
; 2506 :             2*check_list_max*sizeof(struct vis_conedge *));

	mov	ecx, DWORD PTR _check_list
	add	eax, eax
	push	2506					; 000009caH
	add	eax, eax
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	add	eax, eax
	push	eax
	push	ecx
	call	_kb_temp_realloc

; 2507 :           check_list_max *= 2;

	mov	edx, DWORD PTR _check_list_max
	mov	DWORD PTR _check_list, eax
	lea	eax, DWORD PTR [edx+edx]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _check_list_max, eax
$LN14@delete_lay:

; 2508 :         }
; 2509 :         check_list[check_list_count++] = ee;

	mov	edx, DWORD PTR _check_list_count
	mov	ecx, DWORD PTR _check_list
	mov	DWORD PTR [ecx+edx*4], esi
	inc	DWORD PTR _check_list_count

; 2510 :         ee->flags |= V_LAYER_CHECK;

	or	DWORD PTR [esi+48], ebx
$LN16@delete_lay:

; 2511 :       }
; 2512 :       retval = 1;

	pop	edi
	pop	ebx
	mov	eax, 1
	pop	esi

; 2517 : } // end delete_layer()

	pop	ebp
	ret	0
$LN13@delete_lay:

; 2513 :       break;
; 2514 :     }
; 2515 : 
; 2516 :   return retval;

	mov	eax, edx
	pop	esi

; 2517 : } // end delete_layer()

	pop	ebp
	ret	0
_delete_layer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@LFKIKPOC@next?5crossing?5?$CFd?5?$CFd?5at?5?$CF20?415f?6?$AA@ ; `string'
PUBLIC	__real@3e45798ee2308c3a
PUBLIC	__real@3ddb7cdfd9d7bdbb
PUBLIC	_find_next_event
;	COMDAT ??_C@_0CA@LFKIKPOC@next?5crossing?5?$CFd?5?$CFd?5at?5?$CF20?415f?6?$AA@
CONST	SEGMENT
??_C@_0CA@LFKIKPOC@next?5crossing?5?$CFd?5?$CFd?5at?5?$CF20?415f?6?$AA@ DB 'n'
	DB	'ext crossing %d %d at %20.15f', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@3e45798ee2308c3a
CONST	SEGMENT
__real@3e45798ee2308c3a DQ 03e45798ee2308c3ar	; 1e-008
CONST	ENDS
;	COMDAT __real@3ddb7cdfd9d7bdbb
CONST	SEGMENT
__real@3ddb7cdfd9d7bdbb DQ 03ddb7cdfd9d7bdbbr	; 1e-010
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _find_next_event
_TEXT	SEGMENT
_ev$ = -16						; size = 16
_e$ = 8							; size = 4
_find_next_event PROC					; COMDAT

; 2532 : { struct vis_event ev;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2533 :   ev.time = 1e30;

	fld	QWORD PTR __real@46293e5939a08cea

; 2534 :  
; 2535 :   /* Above */
; 2536 :   if ( (e->m > e->next_active->m ) && (e->v[1] != e->next_active->v[1]) )

	mov	ecx, DWORD PTR _e$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	fld	ST(0)
	fst	QWORD PTR _ev$[ebp]
	push	ebx
	fld	QWORD PTR [edx+16]
	push	esi
	fcomp	QWORD PTR [ecx+16]
	push	edi
	fnstsw	ax
	fld	QWORD PTR __real@3ddb7cdfd9d7bdbb
	test	ah, 5
	jp	SHORT $LN26@find_next_
	mov	ebx, DWORD PTR [ecx+8]
	cmp	ebx, DWORD PTR [edx+8]
	je	SHORT $LN26@find_next_

; 2537 :   { REAL u;
; 2538 : 
; 2539 :     u = e->v[0]->x[0] + (e->v[0]->x[1]-e->next_active->v[0]->x[1] +
; 2540 :          e->next_active->m*(e->next_active->v[0]->x[0]-e->v[0]->x[0]))/
; 2541 :               (e->next_active->m - e->m);

	mov	eax, DWORD PTR [ecx+4]
	fld	QWORD PTR [eax+8]
	mov	esi, edx
	mov	edi, DWORD PTR [esi+4]
	fsub	QWORD PTR [edi+8]
	fld	QWORD PTR [edi]
	fsub	QWORD PTR [eax]
	fmul	QWORD PTR [esi+16]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [esi+16]
	fsub	QWORD PTR [ecx+16]
	fdivp	ST(1), ST(0)
	fadd	QWORD PTR [eax]

; 2542 :     if ( (u > e->v[0]->x[0]-1e-10) && (u < ev.time) && (u < e->v[1]->x[0] - 1e-10)
; 2543 :              && (u < e->next_active->v[1]->x[0] - 1e-10) )

	fld	QWORD PTR [eax]
	fsub	ST(0), ST(2)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN17@find_next_
	fcom	ST(3)
	fnstsw	ax
	fstp	ST(3)
	test	ah, 5
	jp	SHORT $LN26@find_next_
	fld	QWORD PTR [ebx]
	fsub	ST(0), ST(1)
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN26@find_next_
	mov	eax, DWORD PTR [edx+8]
	fld	QWORD PTR [eax]
	fsub	ST(0), ST(1)
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN26@find_next_
	fstp	ST(1)

; 2544 :     { ev.e1 = e;

	mov	esi, ecx

; 2545 :       ev.e2 = e->next_active; 
; 2546 :       ev.time = u;

	fxch	ST(1)
	mov	DWORD PTR _ev$[ebp+8], esi
	fst	QWORD PTR _ev$[ebp]
	mov	DWORD PTR _ev$[ebp+12], edx
	jmp	SHORT $LN5@find_next_
$LN17@find_next_:

; 2542 :     if ( (u > e->v[0]->x[0]-1e-10) && (u < ev.time) && (u < e->v[1]->x[0] - 1e-10)
; 2543 :              && (u < e->next_active->v[1]->x[0] - 1e-10) )

	fstp	ST(0)
$LN26@find_next_:

; 2545 :       ev.e2 = e->next_active; 
; 2546 :       ev.time = u;

	mov	edx, DWORD PTR _ev$[ebp+12]
	fstp	ST(2)
	mov	esi, DWORD PTR _ev$[ebp+8]
$LN5@find_next_:

; 2547 :     }
; 2548 :   }
; 2549 :  
; 2550 :   /* Below */
; 2551 :   if ( e->prev_active && (e->m < e->prev_active->m) && (e->v[1] != e->prev_active->v[1]))

	mov	edi, DWORD PTR [ecx+32]
	test	edi, edi
	je	$LN48@find_next_
	fld	QWORD PTR [edi+16]
	fcomp	QWORD PTR [ecx+16]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN48@find_next_
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN48@find_next_

; 2552 :   { REAL u;
; 2553 :     u = e->v[0]->x[0] + (e->v[0]->x[1]-e->prev_active->v[0]->x[1] +
; 2554 :          e->prev_active->m*(e->prev_active->v[0]->x[0]-e->v[0]->x[0]))/
; 2555 :               (e->prev_active->m - e->m);

	mov	eax, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [edi+4]
	fld	QWORD PTR [eax+8]
	fsub	QWORD PTR [ebx+8]
	fld	QWORD PTR [ebx]
	fsub	QWORD PTR [eax]
	fmul	QWORD PTR [edi+16]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+16]
	fsub	QWORD PTR [ecx+16]
	fdivp	ST(1), ST(0)
	fadd	QWORD PTR [eax]

; 2556 :     if ( (u > e->v[0]->x[0]-1e-8) && (u < ev.time) && (u < e->v[1]->x[0] - 1e-10)
; 2557 :              && (u < e->prev_active->v[1]->x[0] - 1e-10) ) 

	fld	QWORD PTR [eax]
	fsub	QWORD PTR __real@3e45798ee2308c3a
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN45@find_next_
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN45@find_next_
	mov	eax, DWORD PTR [ecx+8]
	fld	QWORD PTR [eax]
	fsub	ST(0), ST(3)
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN45@find_next_
	mov	eax, DWORD PTR [edi+8]
	fld	QWORD PTR [eax]
	fsubrp	ST(3), ST(0)
	fcom	ST(2)
	fnstsw	ax
	fstp	ST(2)
	test	ah, 5
	jp	SHORT $LN48@find_next_
	fstp	ST(0)

; 2558 :     { ev.e1 = e->prev_active;

	mov	esi, edi

; 2559 :       ev.e2 = e; 

	mov	edx, ecx

; 2560 :       ev.time = u;

	fst	QWORD PTR _ev$[ebp]
	mov	DWORD PTR _ev$[ebp+8], esi
	mov	DWORD PTR _ev$[ebp+12], edx
	jmp	SHORT $LN3@find_next_
$LN45@find_next_:

; 2556 :     if ( (u > e->v[0]->x[0]-1e-8) && (u < ev.time) && (u < e->v[1]->x[0] - 1e-10)
; 2557 :              && (u < e->prev_active->v[1]->x[0] - 1e-10) ) 

	fstp	ST(0)
$LN48@find_next_:
	fstp	ST(1)
$LN3@find_next_:

; 2561 :     }
; 2562 :   }
; 2563 : 
; 2564 :   if ( ev.time < 1e20 )

	fld	QWORD PTR __real@4415af1d78b58c40
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN51@find_next_

; 2565 :   { 
; 2566 :     if ( visdebuglevel >= VIS_EVENTDUMP )

	cmp	DWORD PTR _visdebuglevel, 3
	jl	SHORT $LN54@find_next_

; 2567 :       printf("next crossing %d %d at %20.15f\n",
; 2568 :         (int)(ev.e1-vis_conedges),(int)(ev.e2-vis_conedges), (DOUBLE)ev.time);

	mov	ecx, DWORD PTR _vis_conedges
	sub	edx, ecx
	mov	eax, 954437177				; 38e38e39H
	imul	edx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	sub	esp, 8
	add	eax, edx
	sub	esi, ecx
	fstp	QWORD PTR [esp]
	push	eax
	mov	eax, 954437177				; 38e38e39H
	imul	esi
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	push	ecx
	push	OFFSET ??_C@_0CA@LFKIKPOC@next?5crossing?5?$CFd?5?$CFd?5at?5?$CF20?415f?6?$AA@
	call	_printf

; 2569 :     vis_insert_heap(&ev);

	lea	edx, DWORD PTR _ev$[ebp]
	add	esp, 20					; 00000014H
	push	edx
	call	_vis_insert_heap
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2570 :   }
; 2571 : 
; 2572 : } // end find_next_event()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@find_next_:

; 2569 :     vis_insert_heap(&ev);

	lea	edx, DWORD PTR _ev$[ebp]
	fstp	ST(0)
	push	edx
	call	_vis_insert_heap
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2570 :   }
; 2571 : 
; 2572 : } // end find_next_event()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@find_next_:
	pop	edi

; 2561 :     }
; 2562 :   }
; 2563 : 
; 2564 :   if ( ev.time < 1e20 )

	fstp	ST(0)
	pop	esi
	pop	ebx

; 2570 :   }
; 2571 : 
; 2572 : } // end find_next_event()

	mov	esp, ebp
	pop	ebp
	ret	0
_find_next_event ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@KFFPCGMJ@NULL?5next_active?4?6?$AA@	; `string'
PUBLIC	??_C@_04EIEMINIA@?5?$CF3d?$AA@			; `string'
PUBLIC	??_C@_0BN@JBCKAPGD@?$CF3d?5?5?5?$CF5d?5v?3?5?$CF18?415f?5layers?3?$AA@ ; `string'
PUBLIC	??_C@_0DO@BCJEGAML@Visibility?5edge?5list?5debug?5dump?5@ ; `string'
PUBLIC	_dump_vislist
;	COMDAT ??_C@_0BD@KFFPCGMJ@NULL?5next_active?4?6?$AA@
CONST	SEGMENT
??_C@_0BD@KFFPCGMJ@NULL?5next_active?4?6?$AA@ DB 'NULL next_active.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04EIEMINIA@?5?$CF3d?$AA@
CONST	SEGMENT
??_C@_04EIEMINIA@?5?$CF3d?$AA@ DB ' %3d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JBCKAPGD@?$CF3d?5?5?5?$CF5d?5v?3?5?$CF18?415f?5layers?3?$AA@
CONST	SEGMENT
??_C@_0BN@JBCKAPGD@?$CF3d?5?5?5?$CF5d?5v?3?5?$CF18?415f?5layers?3?$AA@ DB '%'
	DB	'3d   %5d v: %18.15f layers:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@BCJEGAML@Visibility?5edge?5list?5debug?5dump?5@
CONST	SEGMENT
??_C@_0DO@BCJEGAML@Visibility?5edge?5list?5debug?5dump?5@ DB 'Visibility '
	DB	'edge list debug dump at u = %18.15f; debug_seq %d', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _dump_vislist
_TEXT	SEGMENT
_dump_vislist PROC					; COMDAT

; 2584 :   REAL v;
; 2585 :   int i;
; 2586 : 
; 2587 :   fprintf(stderr,"Visibility edge list debug dump at u = %18.15f; debug_seq %d\n",
; 2588 :       sweep_u,debug_seq);

	mov	eax, DWORD PTR _debug_seq
	fld	QWORD PTR _sweep_u
	push	esi
	push	eax
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0DO@BCJEGAML@Visibility?5edge?5list?5debug?5dump?5@
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf

; 2589 :   for ( e = active_edge_first ; e != &sentinel ; e = e->next_active )

	mov	esi, DWORD PTR _active_edge_first
	add	esp, 20					; 00000014H
	cmp	esi, OFFSET _sentinel
	je	$LN5@dump_visli
	push	edi
	npad	4
$LL7@dump_visli:

; 2590 :   { if ( e == NULL ) { fprintf(stderr,"NULL next_active.\n"); break; }

	test	esi, esi
	je	$LN14@dump_visli

; 2591 :     v = e->m*(sweep_u-e->v[0]->x[0]) + e->v[0]->x[1]; 

	mov	eax, DWORD PTR [esi+4]
	fld	QWORD PTR _sweep_u
	fsub	QWORD PTR [eax]

; 2592 :     fprintf(stderr,"%3d   %5d v: %18.15f layers:",e->seqno,e->id,v);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+64]
	sub	esp, 8
	fmul	QWORD PTR [esi+16]
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [esp]
	push	ecx
	push	edx
	push	OFFSET ??_C@_0BN@JBCKAPGD@?$CF3d?5?5?5?$CF5d?5v?3?5?$CF18?415f?5layers?3?$AA@
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf

; 2593 :     for ( i = 0 ; i < e->layers ; i++ ) 

	xor	edi, edi
	add	esp, 24					; 00000018H
	cmp	DWORD PTR [esi+52], edi
	jle	SHORT $LN1@dump_visli
$LL3@dump_visli:

; 2594 :       fprintf(stderr," %3d",ordinal(e->layer[i]->f_id)+1);

	mov	eax, DWORD PTR [esi+56]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN10@dump_visli
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN11@dump_visli
$LN10@dump_visli:
	or	eax, -1
$LN11@dump_visli:
	inc	eax
	push	eax
	push	OFFSET ??_C@_04EIEMINIA@?5?$CF3d?$AA@
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, DWORD PTR [esi+52]
	jl	SHORT $LL3@dump_visli
$LN1@dump_visli:

; 2595 :     fprintf(stderr,"\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	mov	esi, DWORD PTR [esi+36]
	add	esp, 8
	cmp	esi, OFFSET _sentinel
	jne	$LL7@dump_visli

; 2590 :   { if ( e == NULL ) { fprintf(stderr,"NULL next_active.\n"); break; }

	jmp	SHORT $LN17@dump_visli
$LN14@dump_visli:
	push	OFFSET ??_C@_0BD@KFFPCGMJ@NULL?5next_active?4?6?$AA@
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 8
$LN17@dump_visli:
	pop	edi
$LN5@dump_visli:

; 2596 :  }
; 2597 :  fprintf(stderr,"\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 8
	pop	esi

; 2598 : }

	ret	0
_dump_vislist ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@DNBHNNA@Bad?5vislist?5at?5debug_seq?5?$CFd?6?$AA@ ; `string'
PUBLIC	__real@3d719799812dea11
PUBLIC	_check_vislist
;	COMDAT ??_C@_0BN@DNBHNNA@Bad?5vislist?5at?5debug_seq?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BN@DNBHNNA@Bad?5vislist?5at?5debug_seq?5?$CFd?6?$AA@ DB 'Bad visli'
	DB	'st at debug_seq %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@3d719799812dea11
CONST	SEGMENT
__real@3d719799812dea11 DQ 03d719799812dea11r	; 1e-012
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _check_vislist
_TEXT	SEGMENT
_v$ = -8						; size = 8
_u$ = 8							; size = 8
_check_vislist PROC					; COMDAT

; 2601 : { struct vis_conedge *e;

	push	ebp
	mov	ebp, esp

; 2602 :   REAL v,prev = -1e30;

	fld	QWORD PTR __real@c6293e5939a08cea
	sub	esp, 8
	push	esi

; 2603 : 
; 2604 :   for ( e = active_edge_first ; e != &sentinel ; e = e->next_active )

	mov	esi, DWORD PTR _active_edge_first
	cmp	esi, OFFSET _sentinel
	je	SHORT $LN11@check_visl
$LN5@check_visl:

; 2605 :   { if ( e == NULL ) { fprintf(stderr,"NULL next_active.\n"); break; }

	test	esi, esi
	je	SHORT $LN14@check_visl

; 2606 :     v = e->m*(u-e->v[0]->x[0]) + e->v[0]->x[1]; 

	mov	eax, DWORD PTR [esi+4]
	fld	QWORD PTR _u$[ebp]
	fsub	QWORD PTR [eax]
	fmul	QWORD PTR [esi+16]
	fadd	QWORD PTR [eax+8]
	fst	QWORD PTR _v$[ebp]

; 2607 :     if ( prev > v+1e-12 )

	fld	QWORD PTR __real@3d719799812dea11
	fadd	ST(0), ST(1)
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN1@check_visl
	fstp	ST(0)

; 2608 :     {  dump_vislist();

	call	_dump_vislist

; 2609 :        printf("Bad vislist at debug_seq %d\n",debug_seq);

	mov	eax, DWORD PTR _debug_seq
	push	eax
	push	OFFSET ??_C@_0BN@DNBHNNA@Bad?5vislist?5at?5debug_seq?5?$CFd?6?$AA@
	call	_printf
	fld	QWORD PTR _v$[ebp]
	add	esp, 8
$LN1@check_visl:

; 2603 : 
; 2604 :   for ( e = active_edge_first ; e != &sentinel ; e = e->next_active )

	mov	esi, DWORD PTR [esi+36]
	cmp	esi, OFFSET _sentinel
	jne	SHORT $LN5@check_visl
$LN11@check_visl:
	fstp	ST(0)
	pop	esi

; 2610 :     }
; 2611 :     prev = v;
; 2612 :  }
; 2613 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@check_visl:

; 2605 :   { if ( e == NULL ) { fprintf(stderr,"NULL next_active.\n"); break; }

	push	OFFSET ??_C@_0BD@KFFPCGMJ@NULL?5next_active?4?6?$AA@
	fstp	ST(0)
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 8
	pop	esi

; 2610 :     }
; 2611 :     prev = v;
; 2612 :  }
; 2613 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_check_vislist ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@CBJGDLHL@Internal?5error?3?5visibility?5list?5@ ; `string'
PUBLIC	_activate_edge
EXTRN	_errmsg:BYTE
;	COMDAT ??_C@_0DF@CBJGDLHL@Internal?5error?3?5visibility?5list?5@
CONST	SEGMENT
??_C@_0DF@CBJGDLHL@Internal?5error?3?5visibility?5list?5@ DB 'Internal er'
	DB	'ror: visibility list out of order by %f.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _activate_edge
_TEXT	SEGMENT
_spotv$90533 = -16					; size = 8
_v$ = -8						; size = 8
_e$ = 8							; size = 4
_activate_edge PROC					; COMDAT

; 2629 : { struct vis_conedge *spot;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2630 :   REAL v,vprev;
; 2631 :   int seq = 0;
; 2632 : 
; 2633 :   v = e->m*(sweep_u-e->v[0]->x[0]) + e->v[0]->x[1]; 

	fld	QWORD PTR _sweep_u
	push	ebx
	push	esi
	mov	esi, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [esi+4]
	fsub	QWORD PTR [eax]
	xor	ebx, ebx
	fmul	QWORD PTR [esi+16]
	fadd	QWORD PTR [eax+8]
	fst	QWORD PTR _v$[ebp]

; 2634 :   if ( e->next_active ) return v; /* already active */

	cmp	DWORD PTR [esi+36], ebx
	jne	$LN15@activate_e

; 2635 : 
; 2636 :   vprev = -1e30;

	fld	QWORD PTR __real@c6293e5939a08cea
	push	edi

; 2637 :   for ( spot = active_edge_first ; spot != NULL ; spot = spot->next_active )

	mov	edi, DWORD PTR _active_edge_first
	test	edi, edi
	je	$LN30@activate_e
$LN24@activate_e:

; 2638 :   { REAL spotv = spot->m*(sweep_u-spot->v[0]->x[0]) + spot->v[0]->x[1];

	mov	eax, DWORD PTR [edi+4]
	fld	QWORD PTR _sweep_u
	fsub	QWORD PTR [eax]
	fmul	QWORD PTR [edi+16]
	fadd	QWORD PTR [eax+8]
	fst	QWORD PTR _spotv$90533[ebp]

; 2639 :     if ( spotv < vprev-1e-10 )

	fld	ST(1)
	fsub	QWORD PTR __real@3ddb7cdfd9d7bdbb
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN33@activate_e

; 2640 :     { sprintf(errmsg,"Internal error: visibility list out of order by %f.\n",
; 2641 :         (DOUBLE)(vprev-spotv));
; 2642 :       kb_error(3509,errmsg,WARNING);

	fstp	ST(2)
	sub	esp, 8
	fsubrp	ST(1), ST(0)
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0DF@CBJGDLHL@Internal?5error?3?5visibility?5list?5@
	push	OFFSET _errmsg
	call	_sprintf
	push	2
	push	OFFSET _errmsg
	push	3509					; 00000db5H
	call	_kb_error
	fld	QWORD PTR _spotv$90533[ebp]
	fld	QWORD PTR _v$[ebp]
	add	esp, 28					; 0000001cH
	fxch	ST(1)
$LN10@activate_e:

; 2643 :     }
; 2644 :     vprev = spotv; /* debugging */

	fld	ST(0)

; 2645 :     spot->seqno = seq++;

	mov	DWORD PTR [edi+64], ebx

; 2646 :     if ( spotv > v+vis_eps ) 

	fld	QWORD PTR _vis_eps
	inc	ebx
	fld	ST(0)
	fadd	ST(0), ST(4)
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN37@activate_e

; 2647 :       break;
; 2648 :     if ( (spotv > v-vis_eps) && (spot->m > e->m) ) 

	fsubr	ST(0), ST(3)
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	SHORT $LN12@activate_e
	fld	QWORD PTR [esi+16]
	fcomp	QWORD PTR [edi+16]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN43@activate_e
$LN12@activate_e:

; 2637 :   for ( spot = active_edge_first ; spot != NULL ; spot = spot->next_active )

	mov	edi, DWORD PTR [edi+36]
	test	edi, edi
	jne	$LN24@activate_e
	jmp	SHORT $LN43@activate_e
$LN33@activate_e:

; 2640 :     { sprintf(errmsg,"Internal error: visibility list out of order by %f.\n",
; 2641 :         (DOUBLE)(vprev-spotv));
; 2642 :       kb_error(3509,errmsg,WARNING);

	fstp	ST(1)

; 2639 :     if ( spotv < vprev-1e-10 )

	jmp	SHORT $LN10@activate_e
$LN37@activate_e:

; 2637 :   for ( spot = active_edge_first ; spot != NULL ; spot = spot->next_active )

	fstp	ST(2)
	fstp	ST(0)
$LN43@activate_e:

; 2647 :       break;
; 2648 :     if ( (spotv > v-vis_eps) && (spot->m > e->m) ) 

	fstp	ST(0)
	fstp	ST(0)

; 2649 :        break;
; 2650 :   } 
; 2651 :   vprev = v;
; 2652 :   /* Have now located insertion spot; "spot" comes after e */
; 2653 :   if ( active_edge_first == spot ) active_edge_first = e;

	cmp	DWORD PTR _active_edge_first, edi
	jne	SHORT $LN26@activate_e
	jmp	SHORT $LN23@activate_e
$LN30@activate_e:
	fstp	ST(0)
	fstp	ST(0)
$LN23@activate_e:
	mov	DWORD PTR _active_edge_first, esi
$LN26@activate_e:

; 2654 :   if ( spot->prev_active ) spot->prev_active->next_active = e;

	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	SHORT $LN6@activate_e
	mov	DWORD PTR [eax+36], esi
$LN6@activate_e:

; 2655 :   e->prev_active = spot->prev_active;

	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+32], eax

; 2656 :   spot->prev_active = e;

	mov	DWORD PTR [edi+32], esi

; 2657 :   e->next_active = spot;
; 2658 :   if ( e->prev_active )

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [esi+36], edi
	test	eax, eax
	je	SHORT $LN5@activate_e

; 2659 :   { int i;
; 2660 :     e->layer = (struct tsort**)temp_calloc(
; 2661 :        e->prev_active->layers+4, sizeof(struct tsort*));

	mov	ecx, DWORD PTR [eax+52]
	push	2661					; 00000a65H
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	add	ecx, 4
	push	4
	push	ecx
	call	_kb_temp_calloc
	mov	DWORD PTR [esi+56], eax

; 2662 :     e->maxlayers = e->prev_active->layers+4;

	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [eax+52]
	add	edx, 4

; 2663 :     for ( i = 0 ; i < e->prev_active->layers ; i++ )

	xor	edi, edi
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+60], edx
	cmp	DWORD PTR [eax+52], edi
	jle	SHORT $LN1@activate_e
$LL4@activate_e:

; 2664 :     {
; 2665 :       add_layer(e,e->prev_active->layer[i]);

	mov	eax, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+edi*4]
	push	edx
	push	esi
	call	_add_layer
	mov	eax, DWORD PTR [esi+32]
	inc	edi
	add	esp, 8
	cmp	edi, DWORD PTR [eax+52]
	jl	SHORT $LL4@activate_e

; 2671 :   }
; 2672 : 
; 2673 :   return v;

	fld	QWORD PTR _v$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 2674 : } // end activate_edge()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@activate_e:

; 2666 :     }
; 2667 :   }
; 2668 :   else
; 2669 :   { e->layer = (struct tsort**)temp_calloc(10, sizeof(struct tsort*));

	push	2669					; 00000a6dH
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	push	4
	push	10					; 0000000aH
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+56], eax

; 2670 :     e->maxlayers = 10;

	mov	DWORD PTR [esi+60], 10			; 0000000aH
$LN1@activate_e:

; 2671 :   }
; 2672 : 
; 2673 :   return v;

	fld	QWORD PTR _v$[ebp]
	pop	edi
$LN15@activate_e:
	pop	esi
	pop	ebx

; 2674 : } // end activate_edge()

	mov	esp, ebp
	pop	ebp
	ret	0
_activate_edge ENDP
_TEXT	ENDS
PUBLIC	_deactivate_edge
EXTRN	_temp_free:PROC
; Function compile flags: /Ogtp
;	COMDAT _deactivate_edge
_TEXT	SEGMENT
_e$ = 8							; size = 4
_deactivate_edge PROC					; COMDAT

; 2683 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 2684 :   if ( e->prev_active )

	mov	esi, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR [esi+32]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN2@deactivate

; 2685 :     e->prev_active->next_active = e->next_active;

	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR [eax+36], ecx
	jmp	SHORT $LN1@deactivate
$LN2@deactivate:

; 2686 :   else active_edge_first = e->next_active;

	mov	edx, DWORD PTR [esi+36]
	mov	DWORD PTR _active_edge_first, edx
$LN1@deactivate:

; 2687 :   e->next_active->prev_active = e->prev_active;

	mov	eax, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR [eax+32], ecx

; 2688 :   e->next_active = e->prev_active = NULL;
; 2689 :   temp_free((char*)e->layer);

	mov	edx, DWORD PTR [esi+56]
	push	edx
	mov	DWORD PTR [esi+32], edi
	mov	DWORD PTR [esi+36], edi
	call	_temp_free
	add	esp, 4

; 2690 :   e->layer = NULL;

	mov	DWORD PTR [esi+56], edi

; 2691 :   e->layers = 0;

	mov	DWORD PTR [esi+52], edi
	pop	edi
	pop	esi

; 2692 : 
; 2693 : } // end check_deactivate()

	pop	ebp
	ret	0
_deactivate_edge ENDP
_TEXT	ENDS
PUBLIC	_vis_edge_comp
; Function compile flags: /Ogtp
;	COMDAT _vis_edge_comp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_u$ = 16						; size = 8
_vis_edge_comp PROC					; COMDAT

; 2704 : { REAL va,vb;

	push	ebp
	mov	ebp, esp

; 2705 : 
; 2706 :   if ( a->v[0] == b->v[0] ) 

	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN10@vis_edge_c

; 2707 :   { // compare slopes
; 2708 :     if ( a->m < b->m ) return -1;

	fld	QWORD PTR [edx+16]
	fcomp	QWORD PTR [ecx+16]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN17@vis_edge_c

; 2709 :     if ( a->m > b->m ) return  1;

	fld	QWORD PTR [edx+16]
	fcomp	QWORD PTR [ecx+16]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN8@vis_edge_c
$LN18@vis_edge_c:
	mov	eax, 1

; 2727 :   return 0;
; 2728 : }

	pop	ebp
	ret	0
$LN8@vis_edge_c:

; 2710 :     return 0;

	xor	eax, eax

; 2727 :   return 0;
; 2728 : }

	pop	ebp
	ret	0
$LN10@vis_edge_c:

; 2711 :   }
; 2712 :   if ( a->v[1] == b->v[1] ) 

	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN7@vis_edge_c

; 2713 :   { // compare slopes
; 2714 :     if ( a->m < b->m ) return  1;

	fld	QWORD PTR [edx+16]
	fcomp	QWORD PTR [ecx+16]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN18@vis_edge_c

; 2715 :     if ( a->m > b->m ) return -1;

	fld	QWORD PTR [edx+16]
	fcomp	QWORD PTR [ecx+16]
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN8@vis_edge_c

; 2721 :   if ( va < vb ) return -1;

	or	eax, -1

; 2727 :   return 0;
; 2728 : }

	pop	ebp
	ret	0
$LN7@vis_edge_c:

; 2716 :     return 0;
; 2717 :   }
; 2718 :   // now compare vertical position
; 2719 :   va = a->v[0]->x[1] + a->m*(u-a->v[0]->x[0]);

	mov	eax, DWORD PTR [ecx+4]
	fld	QWORD PTR _u$[ebp]
	fld	ST(0)
	fsub	QWORD PTR [eax]
	fmul	QWORD PTR [ecx+16]
	fadd	QWORD PTR [eax+8]

; 2720 :   vb = b->v[0]->x[1] + b->m*(u-b->v[0]->x[0]);

	mov	eax, DWORD PTR [edx+4]
	fxch	ST(1)
	fsub	QWORD PTR [eax]
	fmul	QWORD PTR [edx+16]
	fadd	QWORD PTR [eax+8]

; 2721 :   if ( va < vb ) return -1;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@vis_edge_c
	fstp	ST(1)
	fstp	ST(0)
$LN17@vis_edge_c:
	or	eax, -1

; 2727 :   return 0;
; 2728 : }

	pop	ebp
	ret	0
$LN4@vis_edge_c:

; 2722 :   if ( va > vb ) return  1;

	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN18@vis_edge_c

; 2723 : 
; 2724 :   // Geometric tie, so some arbitrary ordering
; 2725 :   if ( a < b ) return -1;

	cmp	edx, ecx
	ja	SHORT $LN17@vis_edge_c

; 2726 :   if ( a > b ) return  1;

	sbb	eax, eax
	neg	eax

; 2727 :   return 0;
; 2728 : }

	pop	ebp
	ret	0
_vis_edge_comp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@HPJIHNCB@visibility_test?5INTERNAL?5ERROR?3?5@ ; `string'
PUBLIC	??_C@_0CK@LOHMBDHK@Vertex?5event?5at?5u?5?$DN?5?$CF18?415f?5?5v?5?$DN@ ; `string'
PUBLIC	_handle_vertex_event
;	COMDAT ??_C@_0DD@HPJIHNCB@visibility_test?5INTERNAL?5ERROR?3?5@
CONST	SEGMENT
??_C@_0DD@HPJIHNCB@visibility_test?5INTERNAL?5ERROR?3?5@ DB 'visibility_t'
	DB	'est INTERNAL ERROR: loop in edge list', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LOHMBDHK@Vertex?5event?5at?5u?5?$DN?5?$CF18?415f?5?5v?5?$DN@
CONST	SEGMENT
??_C@_0CK@LOHMBDHK@Vertex?5event?5at?5u?5?$DN?5?$CF18?415f?5?5v?5?$DN@ DB 'V'
	DB	'ertex event at u = %18.15f  v = %18.15f', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _handle_vertex_event
_TEXT	SEGMENT
_last_e$ = -24						; size = 4
_re$90704 = -20						; size = 4
_retval$ = -16						; size = 4
_i$ = -12						; size = 4
_e$ = -12						; size = 4
_after$ = -12						; size = 4
_j$ = -8						; size = 4
_before$ = -4						; size = 4
_v$ = 8							; size = 4
_handle_vertex_event PROC				; COMDAT

; 2848 : {  struct vis_conedge *before; // active edge below our vertex

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2849 :    struct vis_conedge *after;  // active edge above our vertex
; 2850 :    struct vis_conedge *spot,*ee,*e,*last_e;
; 2851 :    int i,j,m;
; 2852 :    int retval = 1;  // exit code
; 2853 : 
; 2854 :    static int this_seq = 0;  // for detecting loops in linked list
; 2855 : 
; 2856 :    if ( visdebuglevel >= VIS_EVENTDUMP )

	cmp	DWORD PTR _visdebuglevel, 3
	push	ebx
	push	esi

; 2857 :        printf("Vertex event at u = %18.15f  v = %18.15f\n",sweep_u,v->x[1]);

	mov	esi, DWORD PTR _v$[ebp]
	push	edi
	mov	DWORD PTR _retval$[ebp], 1
	jl	SHORT $LN57@handle_ver
	fld	QWORD PTR [esi+8]
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _sweep_u
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CK@LOHMBDHK@Vertex?5event?5at?5u?5?$DN?5?$CF18?415f?5?5v?5?$DN@
	call	_printf
	add	esp, 20					; 00000014H
$LN57@handle_ver:

; 2858 : 
; 2859 :    // First, delete left edges and associated facets.
; 2860 :    if ( v->left_edge_head )

	mov	ebx, DWORD PTR [esi+24]
	test	ebx, ebx
	je	SHORT $LN56@handle_ver
$LL100@handle_ver:

; 2861 :    {  // left edges in vislist might be out of order, if coincident
; 2862 :       // so delete them individually
; 2863 :       for ( spot = v->left_edge_head ; spot != NULL ; 
; 2864 :              spot = spot->left_edge_next )
; 2865 :       { 
; 2866 :         // Delete facets
; 2867 :         for ( j = spot->rawstart ; j <= spot->rawend ; j++ )

	mov	ecx, DWORD PTR [ebx+24]
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR [ebx+28]
	jg	SHORT $LN50@handle_ver
	npad	2
$LL52@handle_ver:

; 2868 :         { struct vis_rawedge *re = rawplist[j];

	mov	eax, DWORD PTR _rawplist
	mov	edi, DWORD PTR [eax+ecx*4]

; 2869 :           struct vis_conedge *ee = spot->next_active;
; 2870 :           if ( re->flags & V_FACET_BOTTOM )

	test	BYTE PTR [edi+16], 1
	mov	esi, DWORD PTR [ebx+36]
	je	SHORT $LN51@handle_ver

; 2871 :           { re->tsrt->flag &= ~VISIBILITY_LIVE;

	mov	eax, DWORD PTR [edi+8]
	and	DWORD PTR [eax+28], -131073		; fffdffffH

; 2872 :             while ( ee )

	test	esi, esi
	je	SHORT $LN51@handle_ver
	npad	1
$LL48@handle_ver:

; 2873 :             { if ( !delete_layer(ee,re->tsrt) )

	mov	ecx, DWORD PTR [edi+8]
	push	ecx
	push	esi
	call	_delete_layer
	add	esp, 8
	test	eax, eax
	je	SHORT $LN94@handle_ver

; 2874 :                 break;
; 2875 :               ee = ee->next_active;

	mov	esi, DWORD PTR [esi+36]
	test	esi, esi
	jne	SHORT $LL48@handle_ver
$LN94@handle_ver:

; 2872 :             while ( ee )

	mov	ecx, DWORD PTR _j$[ebp]
$LN51@handle_ver:

; 2861 :    {  // left edges in vislist might be out of order, if coincident
; 2862 :       // so delete them individually
; 2863 :       for ( spot = v->left_edge_head ; spot != NULL ; 
; 2864 :              spot = spot->left_edge_next )
; 2865 :       { 
; 2866 :         // Delete facets
; 2867 :         for ( j = spot->rawstart ; j <= spot->rawend ; j++ )

	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR [ebx+28]
	jle	SHORT $LL52@handle_ver
	mov	esi, DWORD PTR _v$[ebp]
$LN50@handle_ver:

; 2876 :             }
; 2877 :           }
; 2878 :         }
; 2879 : 
; 2880 :         // save insertion spot when get to last deletion
; 2881 :         if ( spot->left_edge_next == NULL )

	cmp	DWORD PTR [ebx+40], 0
	jne	SHORT $LN45@handle_ver

; 2882 :         { before = spot->prev_active;

	mov	edx, DWORD PTR [ebx+32]

; 2883 :           after = spot->next_active;

	mov	eax, DWORD PTR [ebx+36]
	mov	DWORD PTR _before$[ebp], edx
	mov	DWORD PTR _after$[ebp], eax
$LN45@handle_ver:

; 2884 :         }
; 2885 : 
; 2886 :         // delete from linked list of edges
; 2887 :         deactivate_edge(spot);        

	push	ebx
	call	_deactivate_edge
	mov	ebx, DWORD PTR [ebx+40]
	add	esp, 4
	test	ebx, ebx
	jne	SHORT $LL100@handle_ver

; 2888 :       }
; 2889 :    }
; 2890 :    else // have to do linear search through active edges

	mov	ecx, DWORD PTR _after$[ebp]
	mov	edi, DWORD PTR _before$[ebp]
	jmp	SHORT $LN44@handle_ver
$LN56@handle_ver:

; 2891 :    { this_seq++;

	mov	edx, DWORD PTR ?this_seq@?1??handle_vertex_event@@9@9

; 2892 :      for ( spot = active_edge_first ; spot ; spot = spot->next_active )

	mov	ecx, DWORD PTR _active_edge_first
	inc	edx
	mov	DWORD PTR ?this_seq@?1??handle_vertex_event@@9@9, edx
	test	ecx, ecx
	je	SHORT $LN41@handle_ver
	npad	8
$LL43@handle_ver:

; 2893 :      { REAL spoty = spot->m*(sweep_u-spot->v[0]->x[0]) + spot->v[0]->x[1];

	mov	eax, DWORD PTR [ecx+4]
	fld	QWORD PTR _sweep_u
	fsub	QWORD PTR [eax]
	fmul	QWORD PTR [ecx+16]
	fadd	QWORD PTR [eax+8]

; 2894 :        if ( spoty > v->x[1] )

	fcomp	QWORD PTR [esi+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN41@handle_ver

; 2895 :            break;
; 2896 :        if ( spot->seqno == this_seq )

	cmp	DWORD PTR [ecx+64], edx
	je	SHORT $LN74@handle_ver

; 2899 :        }
; 2900 :        spot->seqno = this_seq;     

	mov	DWORD PTR [ecx+64], edx
	mov	ecx, DWORD PTR [ecx+36]
	test	ecx, ecx
	jne	SHORT $LL43@handle_ver
$LN41@handle_ver:

; 2901 :      }
; 2902 :      before = spot->prev_active;

	mov	edi, DWORD PTR [ecx+32]
	mov	DWORD PTR _before$[ebp], edi
$LN44@handle_ver:

; 2903 :      after  = spot;
; 2904 :    }
; 2905 : 
; 2906 :    // Now insert right edges in place of left edges
; 2907 :    if ( v->right_edge_head )

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN38@handle_ver

; 2908 :    { if ( before )

	test	edi, edi
	je	SHORT $LN37@handle_ver

; 2909 :        before->next_active = v->right_edge_head;

	mov	DWORD PTR [edi+36], eax

; 2910 :      else

	jmp	SHORT $LN36@handle_ver
$LN74@handle_ver:

; 2897 :        {  kb_error(6542,"visibility_test INTERNAL ERROR: loop in edge list\n",WARNING);

	push	2
	push	OFFSET ??_C@_0DD@HPJIHNCB@visibility_test?5INTERNAL?5ERROR?3?5@
	push	6542					; 0000198eH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 2898 :           return -1;

	or	eax, -1
	pop	ebx

; 2986 : 
; 2987 : }  // end handle_vertex_event

	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@handle_ver:

; 2911 :        active_edge_first = v->right_edge_head;

	mov	DWORD PTR _active_edge_first, eax
$LN36@handle_ver:

; 2912 :      v->right_edge_head->prev_active = before;

	mov	edx, DWORD PTR [esi+28]
	mov	DWORD PTR [edx+32], edi

; 2913 :      for ( ee = v->right_edge_head ; ee->right_edge_next != NULL ;
; 2914 :                  ee = ee->right_edge_next )

	mov	eax, DWORD PTR [esi+28]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN33@handle_ver
$LL35@handle_ver:

; 2915 :      {  ee->next_active = ee->right_edge_next;

	mov	edx, DWORD PTR [eax+44]
	mov	DWORD PTR [eax+36], edx

; 2916 :         ee->right_edge_next->prev_active = ee;

	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR [eax+44]
	cmp	DWORD PTR [eax+44], 0
	jne	SHORT $LL35@handle_ver
$LN33@handle_ver:

; 2917 :      }
; 2918 :      ee->next_active = after;

	mov	DWORD PTR [eax+36], ecx

; 2919 :      after->prev_active = ee;

	mov	DWORD PTR [ecx+32], eax

; 2920 :    }
; 2921 :    else

	jmp	SHORT $LN32@handle_ver
$LN38@handle_ver:

; 2922 :    { if ( before )

	test	edi, edi
	je	SHORT $LN31@handle_ver

; 2923 :        before->next_active = after;

	mov	DWORD PTR [edi+36], ecx

; 2924 :      else

	jmp	SHORT $LN30@handle_ver
$LN31@handle_ver:

; 2925 :        active_edge_first = after;

	mov	DWORD PTR _active_edge_first, ecx
$LN30@handle_ver:

; 2926 :      after->prev_active = before;

	mov	DWORD PTR [ecx+32], edi
$LN32@handle_ver:

; 2927 :    }
; 2928 : 
; 2929 :    if ( v->right_edge_head == NULL )

	mov	esi, DWORD PTR [esi+28]
	test	esi, esi
	jne	SHORT $LN29@handle_ver

; 2930 :      return 1;

	pop	edi
	lea	eax, DWORD PTR [esi+1]
	pop	esi
	pop	ebx

; 2986 : 
; 2987 : }  // end handle_vertex_event

	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@handle_ver:

; 2931 : 
; 2932 :    /* Fix up layers */
; 2933 :    // Add own facets of right edges
; 2934 :    for ( e = v->right_edge_head ; e != NULL ; e = e->right_edge_next )

	mov	ebx, DWORD PTR _rawplist
	mov	DWORD PTR _e$[ebp], esi
	jmp	SHORT $LN28@handle_ver
	npad	6
$LL97@handle_ver:
	mov	esi, DWORD PTR _e$[ebp]
$LN28@handle_ver:

; 2935 :    {
; 2936 :      for ( j = e->rawstart ; j <= e->rawend ; j++ )

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR [esi+28]
	jg	SHORT $LN23@handle_ver
	npad	2
$LL25@handle_ver:

; 2937 :      { struct vis_rawedge *re = rawplist[j];

	mov	edi, DWORD PTR [ebx+eax*4]

; 2938 :        if ( re->flags & V_FACET_BOTTOM )

	test	BYTE PTR [edi+16], 1
	mov	DWORD PTR _re$90704[ebp], edi
	je	SHORT $own_layer_end$90715

; 2939 :        { struct vis_conedge *ee;
; 2940 :          // install going up until reach top edge of facet
; 2941 :          add_layer(e,re->tsrt);

	mov	eax, DWORD PTR [edi+8]
	push	eax
$LN101@handle_ver:
	push	esi
	call	_add_layer

; 2942 :          // and go up until hit top edge of facet
; 2943 :          ee = e;
; 2944 :          while ( ee )
; 2945 :          { ee = ee->next_active;

	mov	esi, DWORD PTR [esi+36]
	add	esp, 8

; 2946 :            if ( ee == &sentinel ) break;

	cmp	esi, OFFSET _sentinel
	je	SHORT $LN90@handle_ver

; 2947 :            for ( m = ee->rawstart ; m <= ee->rawend ; m++ )

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi+28]
	cmp	eax, ecx
	jg	SHORT $LN16@handle_ver
	mov	edx, DWORD PTR [edi+8]
	mov	ebx, DWORD PTR _rawplist
$LL18@handle_ver:

; 2948 :              if ( rawplist[m]->tsrt == re->tsrt )

	mov	edi, DWORD PTR [ebx+eax*4]
	cmp	DWORD PTR [edi+8], edx
	je	SHORT $LN95@handle_ver

; 2947 :            for ( m = ee->rawstart ; m <= ee->rawend ; m++ )

	inc	eax
	cmp	eax, ecx
	jle	SHORT $LL18@handle_ver
	mov	edi, DWORD PTR _re$90704[ebp]
$LN16@handle_ver:

; 2949 :              { // have top, so stop adding as layer
; 2950 :                goto own_layer_end;
; 2951 :              }
; 2952 :            add_layer(ee,re->tsrt);

	mov	ecx, DWORD PTR [edi+8]
	push	ecx
	jmp	SHORT $LN101@handle_ver
$LN90@handle_ver:

; 2953 :          }
; 2954 :          if ( ee == &sentinel )
; 2955 :          {
; 2956 :             retval = -1;

	mov	ebx, DWORD PTR _rawplist
	mov	DWORD PTR _retval$[ebp], -1
$LN95@handle_ver:
	mov	esi, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
$own_layer_end$90715:

; 2935 :    {
; 2936 :      for ( j = e->rawstart ; j <= e->rawend ; j++ )

	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR [esi+28]
	jle	SHORT $LL25@handle_ver
	mov	edi, DWORD PTR _before$[ebp]
$LN23@handle_ver:

; 2957 :          }
; 2958 :        }
; 2959 : own_layer_end: continue;
; 2960 :      }
; 2961 :      if ( e->right_edge_next == NULL )

	mov	eax, DWORD PTR [esi+44]
	test	eax, eax
	jne	SHORT $LN27@handle_ver

; 2962 :        last_e = e;

	mov	DWORD PTR _last_e$[ebp], esi
$LN27@handle_ver:

; 2931 : 
; 2932 :    /* Fix up layers */
; 2933 :    // Add own facets of right edges
; 2934 :    for ( e = v->right_edge_head ; e != NULL ; e = e->right_edge_next )

	mov	DWORD PTR _e$[ebp], eax
	test	eax, eax
	jne	$LL97@handle_ver

; 2963 :    }
; 2964 :    // Add continuing layers from below
; 2965 :    if ( before )

	test	edi, edi
	je	SHORT $LN99@handle_ver

; 2966 :    { for ( i = 0 ; i < before->layers ; i++ )

	mov	edx, DWORD PTR _before$[ebp]
	xor	edi, edi
	mov	DWORD PTR _i$[ebp], edi
	cmp	DWORD PTR [edx+52], edi
	jle	SHORT $LN99@handle_ver
$LL98@handle_ver:

; 2967 :      { for ( ee = v->right_edge_head ; ee != NULL ; ee = ee->right_edge_next )

	mov	eax, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR [eax+28]
	test	esi, esi
	je	SHORT $prev_layer_end$90731
	npad	4
$LL8@handle_ver:

; 2968 :        { // first see if this is the top of the facet
; 2969 :          for ( m = ee->rawstart ; m <= ee->rawend ; m++ )

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi+28]
	cmp	eax, ecx
	jg	SHORT $LN3@handle_ver

; 2970 :            if ( rawplist[m]->tsrt == before->layer[i] )

	mov	edx, DWORD PTR _before$[ebp]
	mov	edx, DWORD PTR [edx+56]
	mov	edx, DWORD PTR [edx+edi*4]
$LL5@handle_ver:
	mov	edi, DWORD PTR [ebx+eax*4]
	cmp	DWORD PTR [edi+8], edx
	je	SHORT $LN96@handle_ver

; 2968 :        { // first see if this is the top of the facet
; 2969 :          for ( m = ee->rawstart ; m <= ee->rawend ; m++ )

	inc	eax
	cmp	eax, ecx
	jle	SHORT $LL5@handle_ver
	mov	edi, DWORD PTR _i$[ebp]
$LN3@handle_ver:

; 2971 :            { // have top, so stop adding as layer
; 2972 :              goto prev_layer_end;
; 2973 :            }
; 2974 :          add_layer(ee,before->layer[i]);

	mov	eax, DWORD PTR _before$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	edx, DWORD PTR [ecx+edi*4]
	push	edx
	push	esi
	call	_add_layer
	mov	esi, DWORD PTR [esi+44]
	mov	ebx, DWORD PTR _rawplist
	add	esp, 8
	test	esi, esi
	jne	SHORT $LL8@handle_ver

; 2967 :      { for ( ee = v->right_edge_head ; ee != NULL ; ee = ee->right_edge_next )

	jmp	SHORT $prev_layer_end$90731
$LN96@handle_ver:
	mov	edi, DWORD PTR _i$[ebp]
$prev_layer_end$90731:

; 2966 :    { for ( i = 0 ; i < before->layers ; i++ )

	mov	eax, DWORD PTR _before$[ebp]
	inc	edi
	mov	DWORD PTR _i$[ebp], edi
	cmp	edi, DWORD PTR [eax+52]
	jl	SHORT $LL98@handle_ver
$LN99@handle_ver:

; 2975 :        }
; 2976 : prev_layer_end: continue;
; 2977 :      }
; 2978 :    }
; 2979 : 
; 2980 :   // Look for upcoming crossing events
; 2981 :   find_next_event(v->right_edge_head);

	mov	esi, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [esi+28]
	push	ecx
	call	_find_next_event

; 2982 :   if ( last_e != v->right_edge_head )

	mov	eax, DWORD PTR _last_e$[ebp]
	add	esp, 4
	cmp	eax, DWORD PTR [esi+28]
	je	SHORT $LN1@handle_ver

; 2983 :     find_next_event(last_e);

	push	eax
	call	_find_next_event
	add	esp, 4
$LN1@handle_ver:

; 2984 : 
; 2985 :   return retval;

	mov	eax, DWORD PTR _retval$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 2986 : 
; 2987 : }  // end handle_vertex_event

	mov	esp, ebp
	pop	ebp
	ret	0
_handle_vertex_event ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@CGJIKCGI@Inconsistent?5active?5list?4?6?$AA@ ; `string'
PUBLIC	_vis_crossing
;	COMDAT ??_C@_0BL@CGJIKCGI@Inconsistent?5active?5list?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@CGJIKCGI@Inconsistent?5active?5list?4?6?$AA@ DB 'Inconsistent a'
	DB	'ctive list.', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _vis_crossing
_TEXT	SEGMENT
_i$ = 8							; size = 4
_ea$ = 8						; size = 4
_eb$ = 12						; size = 4
_vis_crossing PROC					; COMDAT

; 3004 : { struct vis_conedge *te;

	push	ebp
	mov	ebp, esp
	push	ebx

; 3005 :   struct vis_rawedge *ra,*rb;
; 3006 :   int i;
; 3007 : 
; 3008 :   if ( ea->next_active != eb ) goto vis_crossing_exit; /* not adjacent */

	mov	ebx, DWORD PTR _eb$[ebp]
	push	esi
	mov	esi, DWORD PTR _ea$[ebp]
	cmp	DWORD PTR [esi+36], ebx
	jne	$vis_crossing_exit$90743

; 3009 :   if ( ea != eb->prev_active )

	cmp	esi, DWORD PTR [ebx+32]
	je	SHORT $LN22@vis_crossi

; 3010 :      kb_error(2547,"Inconsistent active list.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BL@CGJIKCGI@Inconsistent?5active?5list?4?6?$AA@
	push	2547					; 000009f3H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN22@vis_crossi:

; 3011 :   vis_crossing_count++;

	inc	DWORD PTR _vis_crossing_count

; 3012 : 
; 3013 :   /* fix up layer lists, using info back in raw edge list */
; 3014 :   for ( i = ea->rawstart; i <= ea->rawend ; i++ )

	mov	eax, DWORD PTR [esi+24]
	push	edi
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [esi+28]
	jg	SHORT $LN21@vis_crossi
	npad	1
$LL12@vis_crossi:

; 3015 :   { ra = rawplist[i];

	mov	ecx, DWORD PTR _rawplist
	mov	edi, DWORD PTR [ecx+eax*4]

; 3016 :     if ( ra->flags & V_FACET_BOTTOM )

	test	BYTE PTR [edi+16], 1
	je	SHORT $LN9@vis_crossi

; 3017 :       delete_layer(eb,ra->tsrt);

	mov	edx, DWORD PTR [edi+8]
	push	edx
	push	ebx
	call	_delete_layer
	mov	eax, DWORD PTR _i$[ebp]
	add	esp, 8
$LN9@vis_crossi:

; 3018 :     if ( ra->flags & V_FACET_TOP )

	test	BYTE PTR [edi+16], 2
	je	SHORT $LN11@vis_crossi

; 3019 :       add_layer(eb,ra->tsrt);

	mov	eax, DWORD PTR [edi+8]
	push	eax
	push	ebx
	call	_add_layer
	mov	eax, DWORD PTR _i$[ebp]
	add	esp, 8
$LN11@vis_crossi:

; 3012 : 
; 3013 :   /* fix up layer lists, using info back in raw edge list */
; 3014 :   for ( i = ea->rawstart; i <= ea->rawend ; i++ )

	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [esi+28]
	jle	SHORT $LL12@vis_crossi
$LN21@vis_crossi:

; 3020 :   }
; 3021 :   for ( i = eb->rawstart; i <= eb->rawend ; i++ )

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [ebx+28]
	jg	SHORT $LN5@vis_crossi
	npad	7
$LL7@vis_crossi:

; 3022 :   { rb = rawplist[i];

	mov	ecx, DWORD PTR _rawplist
	mov	edi, DWORD PTR [ecx+eax*4]

; 3023 :     if ( rb->flags & V_FACET_BOTTOM )

	test	BYTE PTR [edi+16], 1
	je	SHORT $LN4@vis_crossi

; 3024 :       add_layer(ea,rb->tsrt);

	mov	edx, DWORD PTR [edi+8]
	push	edx
	push	esi
	call	_add_layer
	mov	eax, DWORD PTR _i$[ebp]
	add	esp, 8
$LN4@vis_crossi:

; 3025 :     if ( rb->flags & V_FACET_TOP )

	test	BYTE PTR [edi+16], 2
	je	SHORT $LN6@vis_crossi

; 3026 :       delete_layer(ea,rb->tsrt);

	mov	eax, DWORD PTR [edi+8]
	push	eax
	push	esi
	call	_delete_layer
	mov	eax, DWORD PTR _i$[ebp]
	add	esp, 8
$LN6@vis_crossi:

; 3020 :   }
; 3021 :   for ( i = eb->rawstart; i <= eb->rawend ; i++ )

	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [ebx+28]
	jle	SHORT $LL7@vis_crossi
$LN5@vis_crossi:

; 3027 :   }
; 3028 : 
; 3029 :   /* switch order in active list */
; 3030 :   eb->next_active->prev_active = ea;

	mov	ecx, DWORD PTR [ebx+36]
	mov	DWORD PTR [ecx+32], esi

; 3031 :   if ( ea->prev_active ) ea->prev_active->next_active = eb;

	mov	eax, DWORD PTR [esi+32]
	pop	edi
	test	eax, eax
	je	SHORT $LN2@vis_crossi
	mov	DWORD PTR [eax+36], ebx
	jmp	SHORT $LN1@vis_crossi
$LN2@vis_crossi:

; 3032 :   else active_edge_first = eb;

	mov	DWORD PTR _active_edge_first, ebx
$LN1@vis_crossi:

; 3033 :   te = ea->prev_active;

	mov	eax, DWORD PTR [esi+32]

; 3034 :   ea->prev_active = eb;

	mov	DWORD PTR [esi+32], ebx

; 3035 :   eb->prev_active = te;

	mov	DWORD PTR [ebx+32], eax

; 3036 :   te = eb->next_active;

	mov	eax, DWORD PTR [ebx+36]

; 3037 :   eb->next_active = ea;

	mov	DWORD PTR [ebx+36], esi

; 3038 :   ea->next_active = te;
; 3039 : 
; 3040 :   /* Test for next events */ 
; 3041 :   find_next_event(ea);

	push	esi
	mov	DWORD PTR [esi+36], eax
	call	_find_next_event

; 3042 :   find_next_event(eb);

	push	ebx
	call	_find_next_event
	add	esp, 8
$vis_crossing_exit$90743:
	pop	esi
	pop	ebx

; 3043 :   
; 3044 : vis_crossing_exit: ;
; 3045 : 
; 3046 : }  // end vis_crossing()

	pop	ebp
	ret	0
_vis_crossing ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@FLPMAGME@Marking?5facet?5?$CFd?5visible?5at?5edge@ ; `string'
PUBLIC	_check_one_visible
;	COMDAT ??_C@_0CG@FLPMAGME@Marking?5facet?5?$CFd?5visible?5at?5edge@
CONST	SEGMENT
??_C@_0CG@FLPMAGME@Marking?5facet?5?$CFd?5visible?5at?5edge@ DB 'Marking '
	DB	'facet %d visible at edge %d.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _check_one_visible
_TEXT	SEGMENT
_e$ = 8							; size = 4
_check_one_visible PROC					; COMDAT

; 3056 : { struct tsort *topf;

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 3061 :   for ( j = 0 ; j < e->layers ; j++ )

	mov	edi, DWORD PTR _e$[ebp]
	xor	esi, esi
	cmp	DWORD PTR [edi+52], esi
	jle	SHORT $LN14@check_one_

; 3057 :   int j;
; 3058 : 
; 3059 :   // using tsort order from painter's algorithm to see which is on top
; 3060 :   topf = NULL;

	mov	ecx, DWORD PTR [edi+56]
	mov	edx, DWORD PTR [edi+52]
$LL7@check_one_:

; 3062 :   { 
; 3063 :     struct tsort *f = e->layer[j];

	mov	eax, DWORD PTR [ecx]

; 3064 :     if ( (topf==NULL || (f > topf)) && (f->flag & VISIBILITY_LIVE) )    /* using painter facet order */

	test	esi, esi
	je	SHORT $LN3@check_one_
	cmp	eax, esi
	jbe	SHORT $LN6@check_one_
$LN3@check_one_:
	test	DWORD PTR [eax+28], 131072		; 00020000H
	je	SHORT $LN6@check_one_

; 3065 :     { topf = f; }

	mov	esi, eax
$LN6@check_one_:

; 3061 :   for ( j = 0 ; j < e->layers ; j++ )

	add	ecx, 4
	dec	edx
	jne	SHORT $LL7@check_one_

; 3066 :   }
; 3067 :   if ( topf ) 

	test	esi, esi
	je	SHORT $LN14@check_one_

; 3068 :   { topf->flag |= VISIBLE;

	or	DWORD PTR [esi+28], 16384		; 00004000H

; 3069 :     if ( visdebuglevel >= VIS_EVENTDUMP )

	cmp	DWORD PTR _visdebuglevel, 3
	jl	SHORT $LN14@check_one_

; 3070 :         printf("Marking facet %d visible at edge %d.\n",(int)(topf->f_id & 0xFFFFF)+1,(int)(e-vis_conedges));

	mov	ecx, edi
	sub	ecx, DWORD PTR _vis_conedges
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	mov	ecx, DWORD PTR [esi]
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	and	ecx, 1048575				; 000fffffH
	push	eax
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_0CG@FLPMAGME@Marking?5facet?5?$CFd?5visible?5at?5edge@
	call	_printf
	add	esp, 12					; 0000000cH
$LN14@check_one_:

; 3071 :   }
; 3072 :   e->flags &= ~V_LAYER_CHECK;

	and	DWORD PTR [edi+48], -17			; ffffffefH
	pop	edi
	pop	esi

; 3073 : }

	pop	ebp
	ret	0
_check_one_visible ENDP
_TEXT	ENDS
PUBLIC	_check_visible
; Function compile flags: /Ogtp
;	COMDAT _check_visible
_TEXT	SEGMENT
_check_visible PROC					; COMDAT

; 3087 : {

	push	esi

; 3088 :   int i;
; 3089 : 
; 3090 :   for ( i = 0 ; i < check_list_count ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _check_list_count, esi
	jle	SHORT $LN9@check_visi
	npad	5
$LL4@check_visi:

; 3091 :   { struct vis_conedge *e = check_list[i];

	mov	eax, DWORD PTR _check_list
	mov	eax, DWORD PTR [eax+esi*4]

; 3092 : 
; 3093 :     if ( e->layers )

	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN3@check_visi

; 3094 :       check_one_visible(e);

	push	eax
	call	_check_one_visible
	add	esp, 4
$LN3@check_visi:

; 3088 :   int i;
; 3089 : 
; 3090 :   for ( i = 0 ; i < check_list_count ; i++ )

	inc	esi
	cmp	esi, DWORD PTR _check_list_count
	jl	SHORT $LL4@check_visi

; 3095 :   }
; 3096 :   check_list_count = 0;

	mov	DWORD PTR _check_list_count, 0
	pop	esi

; 3097 : 
; 3098 : } // end check_visible()

	ret	0
$LN9@check_visi:

; 3095 :   }
; 3096 :   check_list_count = 0;

	mov	DWORD PTR _check_list_count, esi
	pop	esi

; 3097 : 
; 3098 : } // end check_visible()

	ret	0
_check_visible ENDP
_TEXT	ENDS
PUBLIC	_in_back
EXTRN	_verbose_flag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _in_back
_TEXT	SEGMENT
_ta$ = 8						; size = 4
tv396 = 12						; size = 4
_tb$ = 12						; size = 4
_in_back PROC						; COMDAT

; 1000 : {

	push	ebp
	mov	ebp, esp

; 1001 :   int n;
; 1002 :   
; 1003 :   int retval;
; 1004 :    
; 1005 :   if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	fld1
	push	ebx
	mov	ebx, DWORD PTR _ta$[ebp]
	push	esi
	mov	esi, DWORD PTR _tb$[ebp]
	je	SHORT $LN10@in_back

; 1006 :   {
; 1007 :     in_back_calls++;

	fld	QWORD PTR _in_back_calls
	fadd	ST(0), ST(1)
	fstp	QWORD PTR _in_back_calls

; 1008 :     if ( (ta->flag & 0xF) == FACET  )

	mov	eax, DWORD PTR [ebx+28]
	and	al, 15					; 0000000fH
	cmp	al, 2
	jne	SHORT $LN15@in_back

; 1009 :     { if ( (tb->flag & 0xF) == FACET  )          

	mov	ecx, DWORD PTR [esi+28]
	and	cl, 15					; 0000000fH
	cmp	cl, al
	jne	SHORT $LN14@in_back

; 1010 :         facetfacet++;

	fld	QWORD PTR _facetfacet
	fadd	ST(0), ST(1)
	fstp	QWORD PTR _facetfacet
	jmp	SHORT $LN10@in_back
$LN15@in_back:

; 1011 :       else facetedge++;
; 1012 :     }
; 1013 :     else  
; 1014 :     { if ( (tb->flag & 0xF) == FACET  )          

	mov	edx, DWORD PTR [esi+28]
	and	dl, 15					; 0000000fH
	cmp	dl, 2
	jne	SHORT $LN11@in_back
$LN14@in_back:

; 1015 :         facetedge++;

	fld	QWORD PTR _facetedge
	fadd	ST(0), ST(1)
	fstp	QWORD PTR _facetedge
	jmp	SHORT $LN10@in_back
$LN11@in_back:

; 1016 :       else edgeedge++;

	fld	QWORD PTR _edgeedge
	fadd	ST(0), ST(1)
	fstp	QWORD PTR _edgeedge
$LN10@in_back:

; 1017 :     }
; 1018 :   }
; 1019 : 
; 1020 :   /* quick test with quadcodes */
; 1021 :   if ( ((ta->quadcode & tb->quadcode) != ta->quadcode) &&
; 1022 :        ((ta->quadcode & tb->quadcode) != tb->quadcode) )

	mov	eax, DWORD PTR [ebx+120]
	mov	ecx, eax
	and	ecx, DWORD PTR [esi+120]
	cmp	ecx, eax
	je	SHORT $LN9@in_back
	mov	eax, DWORD PTR [esi+120]
	mov	edx, DWORD PTR [ebx+120]
	and	edx, eax
	cmp	edx, eax
	je	SHORT $LN9@in_back
	pop	esi
	fstp	ST(0)

; 1023 :     return DISJOINT;

	mov	eax, 1
	pop	ebx

; 1036 :   if ( retval & (FIRST_BACK|COPLANAR|DISJOINT) ) return retval;
; 1037 : 
; 1038 :   return retval;
; 1039 : } // end in_back()

	pop	ebp
	ret	0
$LN9@in_back:

; 1024 : 
; 1025 :   /* test x and y extent overlap */
; 1026 :   for ( n = 0 ; n < 2 ; n++ )

	mov	eax, ebx
	xor	edx, edx
	sub	eax, esi
	push	edi
	lea	edi, DWORD PTR [ebx+92]
	lea	ecx, DWORD PTR [esi+80]
	mov	DWORD PTR tv396[ebp], eax
	jmp	SHORT $LN8@in_back
$LN22@in_back:
	mov	eax, DWORD PTR tv396[ebp]
$LN8@in_back:

; 1027 :      if ( (tb->maxs[n] <= ta->mins[n]) || (tb->mins[n] >= ta->maxs[n]) )

	fld	DWORD PTR [ecx+12]
	fld	DWORD PTR [eax+ecx]
	fcompp
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN46@in_back
	fld	DWORD PTR [ecx]
	fld	DWORD PTR [edi]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $LN46@in_back

; 1024 : 
; 1025 :   /* test x and y extent overlap */
; 1026 :   for ( n = 0 ; n < 2 ; n++ )

	inc	edx
	add	ecx, 4
	add	edi, 4
	cmp	edx, 2
	jl	SHORT $LN22@in_back

; 1029 :   if ( ta->maxs[2] <= tb->mins[2] ) return FIRST_BACK;

	fld	DWORD PTR [ebx+100]
	fld	DWORD PTR [esi+88]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN3@in_back
	pop	edi
	fstp	ST(0)
	pop	esi
	mov	eax, 2
	pop	ebx

; 1036 :   if ( retval & (FIRST_BACK|COPLANAR|DISJOINT) ) return retval;
; 1037 : 
; 1038 :   return retval;
; 1039 : } // end in_back()

	pop	ebp
	ret	0
$LN46@in_back:

; 1027 :      if ( (tb->maxs[n] <= ta->mins[n]) || (tb->mins[n] >= ta->maxs[n]) )

	fstp	ST(0)
$LN55@in_back:
	pop	edi
	pop	esi

; 1028 :         return DISJOINT;  

	mov	eax, 1
	pop	ebx

; 1036 :   if ( retval & (FIRST_BACK|COPLANAR|DISJOINT) ) return retval;
; 1037 : 
; 1038 :   return retval;
; 1039 : } // end in_back()

	pop	ebp
	ret	0
$LN3@in_back:

; 1030 : 
; 1031 :   box_overlaps++;   /* for verbose stats */

	fadd	QWORD PTR _box_overlaps

; 1032 : 
; 1033 :   if ( separating_line(ta,tb) == DISJOINT ) return DISJOINT;  

	push	esi
	push	ebx
	fstp	QWORD PTR _box_overlaps
	call	_separating_line
	add	esp, 8
	cmp	eax, 1
	je	SHORT $LN55@in_back

; 1034 : 
; 1035 :   retval = plane_test(ta,tb);

	push	esi
	push	ebx
	call	_plane_test
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1036 :   if ( retval & (FIRST_BACK|COPLANAR|DISJOINT) ) return retval;
; 1037 : 
; 1038 :   return retval;
; 1039 : } // end in_back()

	pop	ebp
	ret	0
_in_back ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@NINPGCBI@tsrt?5at?5spot?5?$CFd?5?5flag?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0DM@MGMDMHDN@visibility_test?5INTERNAL?5ERROR?3?5@ ; `string'
PUBLIC	_visibility_recover
;	COMDAT ??_C@_0BK@NINPGCBI@tsrt?5at?5spot?5?$CFd?5?5flag?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BK@NINPGCBI@tsrt?5at?5spot?5?$CFd?5?5flag?5?$CFd?6?$AA@ DB 'tsrt a'
	DB	't spot %d  flag %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@MGMDMHDN@visibility_test?5INTERNAL?5ERROR?3?5@
CONST	SEGMENT
??_C@_0DM@MGMDMHDN@visibility_test?5INTERNAL?5ERROR?3?5@ DB 'visibility_t'
	DB	'est INTERNAL ERROR: can''t find facet top edge.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _visibility_recover
_TEXT	SEGMENT
_u$ = -16						; size = 8
_re$90610 = -12						; size = 4
_e$ = -8						; size = 4
tv305 = -4						; size = 4
_n$90626 = -4						; size = 4
_j$ = -4						; size = 4
_visibility_recover PROC				; COMDAT

; 2741 : { struct vis_conedge *e,*prev_e,*e_next;

	push	ebp
	mov	ebp, esp

; 2742 :   int j;
; 2743 :   REAL uv = vis_vertices[vertex_event_spot+1].x[0];  // next vertex after this one

	mov	eax, DWORD PTR _vertex_event_spot
	mov	ecx, DWORD PTR _vis_vertices

; 2744 :   REAL ux = vis_heap[0].time;  // next crossing time

	mov	edx, DWORD PTR _vis_heap
	inc	eax
	shl	eax, 5
	fld	QWORD PTR [eax+ecx]
	sub	esp, 16					; 00000010H
	fld	QWORD PTR [edx]

; 2745 :   REAL u = (sweep_u + (uv < ux ? uv : ux))/2;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN78@visibility@6
	fstp	ST(0)
	jmp	SHORT $LN44@visibility@6
$LN78@visibility@6:
	fstp	ST(1)
$LN44@visibility@6:
	fadd	QWORD PTR _sweep_u

; 2746 : 
; 2747 :   // Make sure edge list in order, using insertion sort
; 2748 :   for ( e = active_edge_first->next_active ; e ; e = e_next )

	mov	eax, DWORD PTR _active_edge_first
	push	ebx
	push	esi
	fmul	QWORD PTR __real@3fe0000000000000
	mov	esi, DWORD PTR [eax+36]
	push	edi
	fstp	QWORD PTR _u$[ebp]
	test	esi, esi
	je	$LN38@visibility@6
$LL72@visibility@6:

; 2749 :   { e_next = e->next_active;
; 2750 : 
; 2751 :     prev_e = e->prev_active;

	mov	ebx, DWORD PTR [esi+32]

; 2752 :     while ( vis_edge_comp(e,prev_e,u) < 0 )

	fld	QWORD PTR _u$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	edi, ebx
	push	edi
	push	esi
	call	_vis_edge_comp
	add	esp, 16					; 00000010H
	test	eax, eax
	jns	SHORT $LN74@visibility@6
	npad	3
$LL37@visibility@6:

; 2753 :     { 
; 2754 :       prev_e = prev_e->prev_active;

	mov	edi, DWORD PTR [edi+32]

; 2755 :       if ( prev_e == NULL ) 

	test	edi, edi
	je	SHORT $LN74@visibility@6

; 2752 :     while ( vis_edge_comp(e,prev_e,u) < 0 )

	fld	QWORD PTR _u$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	push	esi
	call	_vis_edge_comp
	add	esp, 16					; 00000010H
	test	eax, eax
	js	SHORT $LL37@visibility@6
$LN74@visibility@6:

; 2756 :         break;
; 2757 :     }
; 2758 :     if ( prev_e == e->prev_active )
; 2759 :         continue;  // all ok
; 2760 : 
; 2761 :     // excise from current spot
; 2762 :     e->next_active->prev_active = e->prev_active;

	mov	eax, DWORD PTR [esi+36]
	cmp	edi, ebx
	je	SHORT $LN39@visibility@6
	mov	DWORD PTR [eax+32], ebx

; 2763 :     e->prev_active->next_active = e->next_active;

	mov	edx, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR [edx+36], ecx

; 2764 : 
; 2765 :     // insert in new spot
; 2766 :     e->prev_active = prev_e;

	mov	DWORD PTR [esi+32], edi

; 2767 :     if ( prev_e )

	test	edi, edi
	je	SHORT $LN33@visibility@6

; 2768 :     { e->next_active = prev_e->next_active;

	mov	edx, DWORD PTR [edi+36]
	mov	DWORD PTR [esi+36], edx

; 2769 :       prev_e->next_active->prev_active = e;

	mov	ecx, DWORD PTR [edi+36]
	mov	DWORD PTR [ecx+32], esi

; 2770 :       prev_e->next_active = e;

	mov	DWORD PTR [edi+36], esi

; 2771 :     }
; 2772 :     else

	jmp	SHORT $LN39@visibility@6
$LN33@visibility@6:

; 2773 :     { e->next_active = active_edge_first;

	mov	edx, DWORD PTR _active_edge_first
	mov	DWORD PTR [esi+36], edx

; 2774 :       active_edge_first->prev_active = e;

	mov	ecx, DWORD PTR _active_edge_first
	mov	DWORD PTR [ecx+32], esi

; 2775 :       active_edge_first = e;

	mov	DWORD PTR _active_edge_first, esi
$LN39@visibility@6:

; 2746 : 
; 2747 :   // Make sure edge list in order, using insertion sort
; 2748 :   for ( e = active_edge_first->next_active ; e ; e = e_next )

	mov	esi, eax
	test	eax, eax
	jne	$LL72@visibility@6
$LN38@visibility@6:

; 2776 :     }
; 2777 :   } // end active list ordering
; 2778 : 
; 2779 :   // Now layers
; 2780 :   // First, clear old stuff.
; 2781 :   for ( e = active_edge_first ; e != NULL ; e = e->next_active )

	mov	esi, DWORD PTR _active_edge_first
	test	esi, esi
	je	SHORT $LN29@visibility@6
$LL31@visibility@6:

; 2782 :   { e->layers = 0;
; 2783 :     memset(e->layer,0,e->maxlayers*sizeof(struct tsort*));

	mov	edx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR [esi+56]
	add	edx, edx
	add	edx, edx
	push	edx
	push	0
	push	eax
	mov	DWORD PTR [esi+52], 0
	call	_memset
	mov	esi, DWORD PTR [esi+36]
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $LL31@visibility@6
$LN29@visibility@6:

; 2784 :   }
; 2785 :   // Then restore layers
; 2786 :   for ( e = active_edge_first ; e != NULL ; e = e->next_active )

	mov	esi, DWORD PTR _active_edge_first
	mov	DWORD PTR _e$[ebp], esi
	test	esi, esi
	je	$LN26@visibility@6
	mov	edi, DWORD PTR _rawplist
$LL28@visibility@6:

; 2787 :   { for ( j = e->rawstart ; j <= e->rawend ; j++ )

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR [esi+28]
	jg	SHORT $LN27@visibility@6
	npad	5
$LL25@visibility@6:

; 2788 :      { struct vis_rawedge *re = rawplist[j];

	mov	ebx, DWORD PTR [edi+eax*4]

; 2789 :        if ( re->flags & V_FACET_BOTTOM )

	test	BYTE PTR [ebx+16], 1
	mov	DWORD PTR _re$90610[ebp], ebx
	je	SHORT $layer_end$90623

; 2790 :        { struct vis_conedge *ee;
; 2791 :          // install going up until reach top edge of facet
; 2792 :          add_layer(e,re->tsrt);

	mov	ecx, DWORD PTR [ebx+8]
	push	ecx
$LN81@visibility@6:
	push	esi
	call	_add_layer

; 2796 :          { int m;
; 2797 :            ee = ee->next_active;

	mov	esi, DWORD PTR [esi+36]
	add	esp, 8

; 2798 :            if ( ee == NULL ) break;

	test	esi, esi
	je	$LN59@visibility@6

; 2799 :            for ( m = ee->rawstart ; m <= ee->rawend ; m++ )

	mov	eax, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi+28]
	cmp	eax, ecx
	jg	SHORT $LN16@visibility@6
	mov	edx, DWORD PTR [ebx+8]
	mov	edi, DWORD PTR _rawplist
$LL18@visibility@6:

; 2800 :              if ( rawplist[m]->tsrt == re->tsrt )

	mov	ebx, DWORD PTR [edi+eax*4]
	cmp	DWORD PTR [ebx+8], edx
	je	SHORT $LN73@visibility@6

; 2799 :            for ( m = ee->rawstart ; m <= ee->rawend ; m++ )

	inc	eax
	cmp	eax, ecx
	jle	SHORT $LL18@visibility@6
	mov	ebx, DWORD PTR _re$90610[ebp]
$LN16@visibility@6:

; 2801 :              { // have top, so stop adding as layer
; 2802 :                goto layer_end;
; 2803 :              }
; 2804 :            add_layer(ee,re->tsrt);

	mov	edx, DWORD PTR [ebx+8]
	push	edx
	jmp	SHORT $LN81@visibility@6
$LN73@visibility@6:

; 2793 :          // and go up until hit top edge of facet
; 2794 :          ee = e;
; 2795 :          while ( ee )

	mov	esi, DWORD PTR _e$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
$layer_end$90623:

; 2787 :   { for ( j = e->rawstart ; j <= e->rawend ; j++ )

	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR [esi+28]
	jle	SHORT $LL25@visibility@6
$LN27@visibility@6:

; 2784 :   }
; 2785 :   // Then restore layers
; 2786 :   for ( e = active_edge_first ; e != NULL ; e = e->next_active )

	mov	esi, DWORD PTR [esi+36]
	mov	DWORD PTR _e$[ebp], esi
	test	esi, esi
	jne	SHORT $LL28@visibility@6
$LN26@visibility@6:

; 2819 :          }
; 2820 :        }
; 2821 :        layer_end: continue;
; 2822 :     }
; 2823 :   } // end layer restore
; 2824 : 
; 2825 :   // Rebuild crossing event heap
; 2826 :   vis_heap_count = 0;
; 2827 :   for ( e = active_edge_first ; e != &sentinel ; e = e->next_active )

	mov	esi, DWORD PTR _active_edge_first
	mov	DWORD PTR _vis_heap_count, 0
	cmp	esi, OFFSET _sentinel
	je	SHORT $LN4@visibility@6
	npad	2
$LL6@visibility@6:

; 2828 :     find_next_event(e);

	push	esi
	call	_find_next_event
	mov	esi, DWORD PTR [esi+36]
	add	esp, 4
	cmp	esi, OFFSET _sentinel
	jne	SHORT $LL6@visibility@6
$LN4@visibility@6:

; 2829 : 
; 2830 :   // Mark visible facets
; 2831 :   for ( e = active_edge_first ; e != &sentinel ; e = e->next_active )

	mov	esi, DWORD PTR _active_edge_first
	cmp	esi, OFFSET _sentinel
	je	SHORT $LN1@visibility@6
$LL3@visibility@6:

; 2832 :     check_one_visible(e);

	push	esi
	call	_check_one_visible
	mov	esi, DWORD PTR [esi+36]
	add	esp, 4
	cmp	esi, OFFSET _sentinel
	jne	SHORT $LL3@visibility@6
$LN1@visibility@6:
	pop	edi
	pop	esi

; 2833 : 
; 2834 :   return 1;

	mov	eax, 1
	pop	ebx

; 2835 : 
; 2836 : } // end visibility_recover

	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@visibility@6:

; 2805 :          }
; 2806 :          if ( ee == NULL )
; 2807 :          { int n,m;
; 2808 : 
; 2809 :            kb_error(3038,"visibility_test INTERNAL ERROR: can't find facet top edge.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0DM@MGMDMHDN@visibility_test?5INTERNAL?5ERROR?3?5@
	push	3038					; 00000bdeH
	call	_kb_error

; 2810 : 
; 2811 :            for ( ee = active_edge_first, n = 0 ; ee ; ee = ee->next_active, n++ )

	mov	edi, DWORD PTR _active_edge_first
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _n$90626[ebp], 0
	test	edi, edi
	je	SHORT $LN11@visibility@6
$LL13@visibility@6:

; 2812 :            { for ( m = ee->rawstart ; m <= ee->rawend ; m++ )

	mov	esi, DWORD PTR [edi+24]
	cmp	esi, DWORD PTR [edi+28]
	jg	SHORT $LN12@visibility@6
	npad	1
$LL76@visibility@6:

; 2813 :                if ( rawplist[m]->tsrt == re->tsrt )

	mov	eax, DWORD PTR _rawplist
	mov	eax, DWORD PTR [eax+esi*4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR [ebx+8]
	jne	SHORT $LN9@visibility@6

; 2814 :                {  printf ("tsrt at spot %d  flag %d\n",n,rawplist[m]->flags);

	mov	edx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR _n$90626[ebp]
	push	edx
	push	eax
	push	OFFSET ??_C@_0BK@NINPGCBI@tsrt?5at?5spot?5?$CFd?5?5flag?5?$CFd?6?$AA@
	call	_printf
	add	esp, 12					; 0000000cH
$LN9@visibility@6:

; 2812 :            { for ( m = ee->rawstart ; m <= ee->rawend ; m++ )

	inc	esi
	cmp	esi, DWORD PTR [edi+28]
	jle	SHORT $LL76@visibility@6
$LN12@visibility@6:

; 2810 : 
; 2811 :            for ( ee = active_edge_first, n = 0 ; ee ; ee = ee->next_active, n++ )

	mov	edi, DWORD PTR [edi+36]
	inc	DWORD PTR _n$90626[ebp]
	test	edi, edi
	jne	SHORT $LL13@visibility@6
$LN11@visibility@6:
	pop	edi
	pop	esi

; 2815 :                }
; 2816 :                 
; 2817 :             }
; 2818 :             return -1;

	or	eax, -1
	pop	ebx

; 2835 : 
; 2836 : } // end visibility_recover

	mov	esp, ebp
	pop	ebp
	ret	0
_visibility_recover ENDP
_TEXT	ENDS
PUBLIC	_search_subtree
; Function compile flags: /Ogtp
;	COMDAT _search_subtree
_TEXT	SEGMENT
_qinx$ = 8						; size = 4
_tk$ = 12						; size = 4
_retval$ = 16						; size = 4
_search_subtree PROC					; COMDAT

; 711  : { struct tsort *tj;

	push	ebp
	mov	ebp, esp

; 712  :  
; 713  :   *retval = 0;
; 714  : 
; 715  :   /* check overall subtree max depth */
; 716  :   if ( tk->maxs[2] <= qtree[qinx].maxdepth )

	mov	ecx, DWORD PTR _qinx$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _retval$[ebp]
	mov	DWORD PTR [ebx], 0
	mov	eax, DWORD PTR _qtree
	push	esi
	push	edi
	mov	edi, DWORD PTR _tk$[ebp]
	fld	DWORD PTR [edi+100]
	lea	ecx, DWORD PTR [eax+ecx*8]
	fld	DWORD PTR [ecx+4]
	fcompp
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN16@search_sub
	npad	4
$LL20@search_sub:

; 718  : 
; 719  :   /* the node itself */
; 720  :   for ( tj = qtree[qinx].depthhead ; tj != NULL ; tj = tj->next )

	mov	esi, DWORD PTR [ecx]
	test	esi, esi
	je	SHORT $LN15@search_sub
$LL7@search_sub:

; 721  :   { 
; 722  :     if ( tj == tk ) continue;

	cmp	esi, edi
	je	SHORT $LN6@search_sub

; 723  :     if ( tk->maxs[2] <= tj->mins[2] ) 

	fld	DWORD PTR [edi+100]
	fld	DWORD PTR [esi+88]
	fcompp
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN15@search_sub

; 724  :       break; 
; 725  :     *retval = in_back(tk,tj);  

	push	esi
	push	edi
	call	_in_back
	add	esp, 8
	mov	DWORD PTR [ebx], eax

; 726  :     if ( *retval & (FIRST_BACK|COPLANAR|DISJOINT) ) continue;

	test	al, 67					; 00000043H
	je	SHORT $LN2@search_sub
$LN6@search_sub:

; 718  : 
; 719  :   /* the node itself */
; 720  :   for ( tj = qtree[qinx].depthhead ; tj != NULL ; tj = tj->next )

	mov	esi, DWORD PTR [esi+132]
	test	esi, esi
	jne	SHORT $LL7@search_sub
$LN15@search_sub:

; 728  :   }
; 729  : 
; 730  :   /* one child */
; 731  :   tj = search_subtree(2*qinx,tk,retval);

	mov	esi, DWORD PTR _qinx$[ebp]
	push	ebx
	add	esi, esi
	push	edi
	push	esi
	call	_search_subtree
	add	esp, 12					; 0000000cH

; 732  :   if ( tj ) return tj;

	test	eax, eax
	jne	SHORT $LN9@search_sub

; 712  :  
; 713  :   *retval = 0;
; 714  : 
; 715  :   /* check overall subtree max depth */
; 716  :   if ( tk->maxs[2] <= qtree[qinx].maxdepth )

	mov	DWORD PTR [ebx], eax
	fld	DWORD PTR [edi+100]
	mov	edx, DWORD PTR _qtree

; 733  :   
; 734  :   /* other child */
; 735  :   return search_subtree(2*qinx+1,tk,retval);

	inc	esi
	fld	DWORD PTR [edx+esi*8+4]
	lea	ecx, DWORD PTR [edx+esi*8]
	fcompp
	mov	DWORD PTR _qinx$[ebp], esi
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LL20@search_sub
$LN16@search_sub:
	pop	edi
	pop	esi

; 717  :     return NULL;

	xor	eax, eax
	pop	ebx

; 736  : } // end search_subtree()

	pop	ebp
	ret	0
$LN2@search_sub:

; 727  :     return tj;

	mov	eax, esi
$LN9@search_sub:
	pop	edi
	pop	esi
	pop	ebx

; 736  : } // end search_subtree()

	pop	ebp
	ret	0
_search_subtree ENDP
_TEXT	ENDS
PUBLIC	_painter_process_trilist
EXTRN	_breakflag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _painter_process_trilist
_TEXT	SEGMENT
_retval$89502 = -24					; size = 4
tv1254 = -20						; size = 4
_more$89527 = -20					; size = 4
_qinx$89501 = -20					; size = 4
_loopcount$ = -16					; size = 4
_maxd$89552 = -12					; size = 4
_newsize$89525 = -12					; size = 4
_sinx$89500 = -12					; size = 4
_k_top$ = -8						; size = 4
_k$ = -4						; size = 4
_painter_process_trilist PROC				; COMDAT

; 747  : { size_t k;

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 748  :   size_t loopcount; /* for emergency loop bailout */
; 749  :   struct tsort **ll,*tt;
; 750  :   size_t quadalloc;
; 751  :   size_t k_top;  /* top of tlist */
; 752  : 
; 753  : 
; 754  :   if ( SDIM == 2 )  /* don't bother with depth */

	cmp	DWORD PTR _web+616, 2
	push	esi
	push	edi
	jne	SHORT $LN63@painter_pr

; 755  :   { for ( k = 0 ; k < count ; k++ )

	xor	edi, edi
	cmp	DWORD PTR _count, edi
	jbe	$LN1@painter_pr
	xor	esi, esi
$LL62@painter_pr:

; 756  :       visibility_stage(trilist+k);

	mov	eax, DWORD PTR _trilist
	lea	ecx, DWORD PTR [esi+eax]
	push	ecx
	call	_visibility_stage
	inc	edi
	add	esp, 4
	add	esi, 140				; 0000008cH
	cmp	edi, DWORD PTR _count
	jb	SHORT $LL62@painter_pr
	pop	edi
	pop	esi

; 918  : 
; 919  : }  // end painter_process_trilist()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@painter_pr:

; 757  :     return;
; 758  :   } 
; 759  : 
; 760  :   /* now sort on min z, moving pointers instead of structures */
; 761  :   /* leaving room at front of list for extra fragments */
; 762  :   tlist = (struct tsort **)temp_calloc(count+TEXTRA,sizeof(struct tsort *));

	mov	edx, DWORD PTR _count
	push	762					; 000002faH
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	add	edx, 100				; 00000064H
	push	4
	push	edx
	call	_kb_temp_calloc

; 763  :   for ( k = 0, ll=tlist+TEXTRA, tt=trilist ; k < count ; k++ ) *(ll++) = tt++;

	mov	esi, DWORD PTR _count
	mov	edx, DWORD PTR _trilist
	xor	edi, edi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _tlist, eax
	lea	ecx, DWORD PTR [eax+400]
	cmp	esi, edi
	jbe	SHORT $LN57@painter_pr

; 757  :     return;
; 758  :   } 
; 759  : 
; 760  :   /* now sort on min z, moving pointers instead of structures */
; 761  :   /* leaving room at front of list for extra fragments */
; 762  :   tlist = (struct tsort **)temp_calloc(count+TEXTRA,sizeof(struct tsort *));

	mov	eax, esi
$LL59@painter_pr:

; 763  :   for ( k = 0, ll=tlist+TEXTRA, tt=trilist ; k < count ; k++ ) *(ll++) = tt++;

	mov	DWORD PTR [ecx], edx
	add	ecx, 4
	add	edx, 140				; 0000008cH
	dec	eax
	jne	SHORT $LL59@painter_pr
	mov	eax, DWORD PTR _tlist
$LN57@painter_pr:

; 764  :   qsort((char *)(tlist+TEXTRA),count,sizeof(struct tsort *),FCAST ttcompare); 

	push	OFFSET _ttcompare
	push	4
	add	eax, 400				; 00000190H
	push	esi
	push	eax
	call	_qsort
	add	esp, 16					; 00000010H
	mov	ecx, 2
	lea	eax, DWORD PTR [ecx+10]
	mov	edx, OFFSET _textra+140
	push	ebx
	npad	5
$LL56@painter_pr:

; 765  :   for ( k = 0 ; k < TEXTRA ; k++ ) 
; 766  :   { tlist[k] = textra+k; tlist[k]->spot = k; tlist[k]->flag = 0; }

	mov	ebx, DWORD PTR _tlist
	lea	esi, DWORD PTR [edx-140]
	mov	DWORD PTR [eax+ebx-12], esi
	mov	ebx, DWORD PTR _tlist
	mov	ebx, DWORD PTR [eax+ebx-12]
	lea	esi, DWORD PTR [ecx-2]
	mov	DWORD PTR [ebx+136], esi
	mov	esi, DWORD PTR _tlist
	mov	esi, DWORD PTR [eax+esi-12]
	mov	DWORD PTR [esi+28], edi
	mov	esi, DWORD PTR _tlist
	mov	DWORD PTR [eax+esi-8], edx
	mov	ebx, DWORD PTR _tlist
	mov	ebx, DWORD PTR [eax+ebx-8]
	lea	esi, DWORD PTR [ecx-1]
	mov	DWORD PTR [ebx+136], esi
	mov	esi, DWORD PTR _tlist
	mov	esi, DWORD PTR [eax+esi-8]
	mov	DWORD PTR [esi+28], edi
	mov	ebx, DWORD PTR _tlist
	lea	esi, DWORD PTR [edx+140]
	mov	DWORD PTR [eax+ebx-4], esi
	mov	esi, DWORD PTR _tlist
	mov	esi, DWORD PTR [eax+esi-4]
	mov	DWORD PTR [esi+136], ecx
	mov	esi, DWORD PTR _tlist
	mov	esi, DWORD PTR [eax+esi-4]
	mov	DWORD PTR [esi+28], edi
	mov	ebx, DWORD PTR _tlist
	lea	esi, DWORD PTR [edx+280]
	mov	DWORD PTR [ebx+eax], esi
	mov	ebx, DWORD PTR _tlist
	mov	ebx, DWORD PTR [ebx+eax]
	lea	esi, DWORD PTR [ecx+1]
	mov	DWORD PTR [ebx+136], esi
	mov	esi, DWORD PTR _tlist
	mov	esi, DWORD PTR [esi+eax]
	mov	DWORD PTR [esi+28], edi
	mov	ebx, DWORD PTR _tlist
	lea	esi, DWORD PTR [edx+420]
	mov	DWORD PTR [eax+ebx+4], esi
	mov	ebx, DWORD PTR _tlist
	mov	ebx, DWORD PTR [eax+ebx+4]
	lea	esi, DWORD PTR [ecx+2]
	mov	DWORD PTR [ebx+136], esi
	mov	esi, DWORD PTR _tlist
	mov	esi, DWORD PTR [eax+esi+4]
	add	ecx, 5
	mov	DWORD PTR [esi+28], edi
	lea	esi, DWORD PTR [ecx-2]
	add	eax, 20					; 00000014H
	add	edx, 700				; 000002bcH
	cmp	esi, 100				; 00000064H
	jb	$LL56@painter_pr

; 767  :   for ( k = TEXTRA ; k < TEXTRA+count ; k++ )

	mov	ecx, DWORD PTR _count
	mov	eax, 100				; 00000064H
	add	ecx, eax
	cmp	ecx, eax
	jbe	SHORT $LN51@painter_pr
	npad	3
$LL53@painter_pr:

; 768  :     tlist[k]->spot = k;

	mov	edx, DWORD PTR _tlist
	mov	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+136], eax
	inc	eax
	cmp	eax, ecx
	jb	SHORT $LL53@painter_pr
$LN51@painter_pr:

; 769  : 
; 770  :   /* quadtree of depth lists */
; 771  :   maxquaddepth = 8; /* maybe make this adjustable later */
; 772  :   quadalloc = 2 << (2*maxquaddepth + 1);
; 773  :   qtree = (struct qtree_t *)temp_calloc(quadalloc,sizeof(struct qtree_t));

	push	773					; 00000305H
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	push	8
	push	262144					; 00040000H
	mov	DWORD PTR _maxquaddepth, 8
	call	_kb_temp_calloc
	fld	DWORD PTR __real@7149f2ca
	add	esp, 16					; 00000010H
	mov	DWORD PTR _qtree, eax
	xor	eax, eax
$LN94@painter_pr:

; 774  :   for ( k = 0 ; k < quadalloc ; k++ )
; 775  :     qtree[k].maxdepth = 1e30f;

	mov	ecx, DWORD PTR _qtree
	fst	DWORD PTR [eax+ecx+4]
	add	eax, 8
	cmp	eax, 2097152				; 00200000H
	jb	SHORT $LN94@painter_pr

; 776  :   for ( k = count+TEXTRA-1 ; k >= TEXTRA ; k-- )

	mov	edi, DWORD PTR _count
	fstp	ST(0)
	lea	esi, DWORD PTR [edi+99]
	cmp	esi, 100				; 00000064H
	jb	SHORT $LN105@painter_pr
	npad	8
$LL47@painter_pr:

; 777  :     qdepth_insert(tlist[k]);

	mov	edx, DWORD PTR _tlist
	mov	eax, DWORD PTR [edx+esi*4]
	push	eax
	call	_qdepth_insert
	dec	esi
	add	esp, 4
	cmp	esi, 100				; 00000064H
	jae	SHORT $LL47@painter_pr
$LN105@painter_pr:

; 778  : 
; 779  :   /* display */
; 780  :   loopcount = 0;
; 781  :   k_top = count+TEXTRA;

	lea	eax, DWORD PTR [edi+100]

; 782  :   for ( k = TEXTRA ; k < k_top ;  )

	mov	ebx, 100				; 00000064H
	mov	DWORD PTR _loopcount$[ebp], 0
	mov	DWORD PTR _k_top$[ebp], eax
	mov	DWORD PTR _k$[ebp], ebx
	cmp	eax, ebx
	jbe	$LN103@painter_pr
	jmp	SHORT $LN44@painter_pr
	npad	9
$LL106@painter_pr:
	mov	ebx, DWORD PTR _k$[ebp]
$LN44@painter_pr:

; 783  :   { struct tsort *tk = tlist[k];
; 784  :     struct tsort *tj;
; 785  :     int sinx,qinx=0;
; 786  :     int retval;
; 787  : 
; 788  :     if ( breakflag ) break;

	cmp	DWORD PTR _breakflag, 0
	mov	ecx, DWORD PTR _tlist
	mov	edi, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR _qinx$89501[ebp], 0
	jne	$LN103@painter_pr

; 789  :     if ( !tk->flag ) { k++; continue; }

	cmp	DWORD PTR [edi+28], 0
	jne	SHORT $LN41@painter_pr
	inc	ebx

; 851  :           {
; 852  :             k -= ret;

	mov	DWORD PTR _k$[ebp], ebx

; 853  :             goto repeat_tests;  /* might not have split */

	jmp	$repeat_tests$89541
$LN41@painter_pr:

; 790  : 
; 791  :     if ( painter_multiple_sweep_flag && tk->maxs[2] > sweep_top )

	cmp	DWORD PTR _painter_multiple_sweep_flag, 0
	je	SHORT $LN40@painter_pr
	fld	DWORD PTR [edi+100]
	fcomp	QWORD PTR _sweep_top
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN113@painter_pr
$LN40@painter_pr:

; 792  :        return;  // time to get the next sweep
; 793  : 
; 794  :     /* for debugging and testing */
; 795  :     if ( k > debug_k )

	cmp	ebx, DWORD PTR _debug_k
	ja	$draw_it$89507

; 796  :        goto draw_it;
; 797  : 
; 798  :     /* tk is current candidate back facet */
; 799  : 
; 800  :     /* search quadtree list for any z overlap */
; 801  :     /* First, node to root  */
; 802  :     qinx = get_quadindex(tk->quadcode);

	mov	edx, DWORD PTR [edi+120]
	push	edx
	call	_get_quadindex
	add	esp, 4
	mov	DWORD PTR _qinx$89501[ebp], eax

; 803  :     for ( sinx = qinx >> 1 ; sinx != 0 ; sinx >>= 1 )

	sar	eax, 1
	mov	DWORD PTR _sinx$89500[ebp], eax
	je	SHORT $LN36@painter_pr
	npad	2
$LL38@painter_pr:

; 804  :     { for ( tj = qtree[sinx].depthhead ; tj != NULL ; tj = tj->next )

	mov	eax, DWORD PTR _qtree
	mov	ecx, DWORD PTR _sinx$89500[ebp]
	mov	esi, DWORD PTR [eax+ecx*8]
	test	esi, esi
	je	SHORT $LN37@painter_pr
	npad	1
$LL111@painter_pr:

; 805  :       { 
; 806  :         if ( tj == tk ) continue;

	cmp	esi, edi
	je	SHORT $LN34@painter_pr

; 807  :         if ( tk->maxs[2] <= tj->mins[2] ) 

	fld	DWORD PTR [edi+100]
	fld	DWORD PTR [esi+88]
	fcompp
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN37@painter_pr

; 808  :           break; 
; 809  :         retval = in_back(tk,tj);  

	push	esi
	push	edi
	call	_in_back
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR _retval$89502[ebp], ecx

; 810  :         if ( retval & (FIRST_BACK|COPLANAR|DISJOINT) ) continue;

	test	cl, 67					; 00000043H
	je	SHORT $have_conflict$89518
$LN34@painter_pr:

; 804  :     { for ( tj = qtree[sinx].depthhead ; tj != NULL ; tj = tj->next )

	mov	esi, DWORD PTR [esi+132]
	test	esi, esi
	jne	SHORT $LL111@painter_pr
$LN37@painter_pr:

; 803  :     for ( sinx = qinx >> 1 ; sinx != 0 ; sinx >>= 1 )

	sar	DWORD PTR _sinx$89500[ebp], 1
	jne	SHORT $LL38@painter_pr
$LN36@painter_pr:

; 811  :         goto have_conflict;
; 812  :       }
; 813  :     }
; 814  : 
; 815  :     /* now search subtree for conflicts */ 
; 816  :     tj = search_subtree(qinx,tk,&retval);

	mov	eax, DWORD PTR _qinx$89501[ebp]
	lea	edx, DWORD PTR _retval$89502[ebp]
	push	edx
	push	edi
	push	eax
	call	_search_subtree
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 817  :     if ( tj==NULL ) goto draw_it;

	test	esi, esi
	je	SHORT $draw_it$89507
	mov	ecx, DWORD PTR _retval$89502[ebp]
$have_conflict$89518:

; 818  : 
; 819  : have_conflict:
; 820  :     /* Now have conflict, tk obscuring tj */
; 821  : 
; 822  :       /* test for possible looping, and if found, split tk */
; 823  :       if ( tj->backstamp == backstamp )

	mov	edx, DWORD PTR [esi+124]
	cmp	edx, DWORD PTR _backstamp
	jne	$LN101@painter_pr

; 824  :       { int ret;
; 825  : 
; 826  :         crossings++;

	fld	QWORD PTR _crossings

; 827  :         if ( ++loopcount > count ) 

	mov	eax, DWORD PTR _loopcount$[ebp]
	fld1
	inc	eax
	fadd	ST(1), ST(0)
	mov	DWORD PTR _loopcount$[ebp], eax
	fxch	ST(1)
	fstp	QWORD PTR _crossings
	cmp	eax, DWORD PTR _count
	jbe	$LN118@painter_pr

; 828  :         { loopbailouts++; goto draw_it; }

	fadd	QWORD PTR _loopbailouts
	fstp	QWORD PTR _loopbailouts
$draw_it$89507:

; 883  :       goto repeat_tests;
; 884  : 
; 885  : draw_it:
; 886  :     visibility_stage(tk);

	push	edi
	call	_visibility_stage

; 887  :     loopcount = 0;
; 888  :     tk->flag = 0;   /* to indicate empty structure */
; 889  : 
; 890  :     /* remove from depth list */
; 891  :     if ( tk == qtree[qinx].depthhead ) 

	mov	edx, DWORD PTR _qinx$89501[ebp]
	xor	ecx, ecx
	mov	DWORD PTR [edi+28], ecx
	mov	eax, DWORD PTR _qtree
	add	esp, 4
	mov	DWORD PTR _loopcount$[ebp], ecx
	cmp	edi, DWORD PTR [eax+edx*8]
	jne	SHORT $LN11@painter_pr

; 892  :       qtree[qinx].depthhead = tk->next;

	mov	esi, DWORD PTR [edi+132]
	mov	DWORD PTR [eax+edx*8], esi
$LN11@painter_pr:

; 893  :     sinx = qinx;
; 894  :     /* fix up subtree maxdepths */
; 895  :     while ( sinx && ( tk->mins[2] <= qtree[sinx].maxdepth ) )

	cmp	edx, ecx
	je	$LN9@painter_pr
	fld	DWORD PTR __real@7149f2ca
$LN10@painter_pr:
	mov	eax, DWORD PTR _qtree
	fld	DWORD PTR [edi+88]
	fld	DWORD PTR [eax+edx*8+4]
	lea	ebx, DWORD PTR [eax+edx*8+4]
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN135@painter_pr

; 896  :     { float maxd = 1e30f;
; 897  :       if ( qtree[sinx].depthhead )

	mov	esi, DWORD PTR _qtree
	fst	DWORD PTR _maxd$89552[ebp]
	mov	eax, DWORD PTR [esi+edx*8]
	test	eax, eax
	je	SHORT $LN8@painter_pr

; 898  :          maxd = qtree[sinx].depthhead->mins[2];

	fld	DWORD PTR [eax+88]
	fstp	DWORD PTR _maxd$89552[ebp]
$LN8@painter_pr:

; 899  :       if ( sinx < (1 << (2*maxquaddepth)) )

	mov	ecx, DWORD PTR _maxquaddepth
	add	ecx, ecx
	mov	eax, 1
	shl	eax, cl
	cmp	edx, eax
	jge	SHORT $LN97@painter_pr

; 900  :       { if ( maxd > qtree[2*sinx].maxdepth )

	fld	DWORD PTR _maxd$89552[ebp]
	mov	ecx, edx
	shl	ecx, 4
	fld	DWORD PTR [ecx+esi+4]
	add	ecx, esi
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@painter_pr

; 901  :           maxd = qtree[2*sinx].maxdepth;

	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR _maxd$89552[ebp]
$LN6@painter_pr:

; 902  :         if ( maxd > qtree[2*sinx+1].maxdepth )

	fld	DWORD PTR _maxd$89552[ebp]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN97@painter_pr

; 903  :           maxd = qtree[2*sinx+1].maxdepth;

	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR _maxd$89552[ebp]
$LN97@painter_pr:

; 904  :       }
; 905  :       qtree[sinx].maxdepth = maxd;
; 906  :       sinx >>= 1;

	sar	edx, 1
	fld	DWORD PTR _maxd$89552[ebp]
	fstp	DWORD PTR [ebx]
	jne	SHORT $LN10@painter_pr
$LN135@painter_pr:

; 893  :     sinx = qinx;
; 894  :     /* fix up subtree maxdepths */
; 895  :     while ( sinx && ( tk->mins[2] <= qtree[sinx].maxdepth ) )

	fstp	ST(0)
$LN9@painter_pr:

; 907  :     }
; 908  :     if ( tk->prev ) tk->prev->next = tk->next;

	mov	eax, DWORD PTR [edi+128]
	test	eax, eax
	je	SHORT $LN4@painter_pr
	mov	edx, DWORD PTR [edi+132]
	mov	DWORD PTR [eax+132], edx
$LN4@painter_pr:

; 909  :     if ( tk->next ) tk->next->prev = tk->prev;

	mov	eax, DWORD PTR [edi+132]
	test	eax, eax
	je	$repeat_tests$89541
	mov	ecx, DWORD PTR [edi+128]
	mov	DWORD PTR [eax+128], ecx
	jmp	$repeat_tests$89541
$LN118@painter_pr:

; 827  :         if ( ++loopcount > count ) 

	fstp	ST(0)

; 829  : 
; 830  :         /* need to split */ 
; 831  :                
; 832  :         if ( k < 2 ) 

	cmp	ebx, 2
	jae	$LN100@painter_pr

; 833  :         { /* not enough room, so expand tlist allocation, with free at start */
; 834  :           size_t newsize = 2*k_top;

	mov	eax, DWORD PTR _k_top$[ebp]

; 835  :           size_t n;
; 836  :           struct tsort *more = (struct tsort*)temp_calloc(k_top,sizeof(struct tsort));

	push	836					; 00000344H
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	lea	ebx, DWORD PTR [eax+eax]
	push	140					; 0000008cH
	push	eax
	mov	DWORD PTR _newsize$89525[ebp], ebx
	call	_kb_temp_calloc

; 837  :           tlist = (struct tsort**)temp_realloc((char*)tlist,newsize*sizeof(struct tsort*));

	push	837					; 00000345H
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	lea	edx, DWORD PTR [ebx*4]
	mov	DWORD PTR _more$89527[ebp], eax
	mov	eax, DWORD PTR _tlist
	push	edx
	push	eax
	call	_kb_temp_realloc

; 838  :           for ( n = 0 ; n < k_top ; n++ )

	xor	ecx, ecx
	add	esp, 32					; 00000020H
	mov	DWORD PTR _tlist, eax
	cmp	DWORD PTR _k_top$[ebp], ecx
	jbe	SHORT $LN107@painter_pr

; 833  :         { /* not enough room, so expand tlist allocation, with free at start */
; 834  :           size_t newsize = 2*k_top;

	mov	edx, DWORD PTR _more$89527[ebp]
	mov	DWORD PTR tv1254[ebp], edx
	mov	edx, DWORD PTR _k_top$[ebp]
	add	edx, edx
	add	edx, edx
	npad	2
$LL98@painter_pr:

; 839  :           { tlist[n+k_top] = tlist[n];

	mov	ebx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx+eax], ebx

; 840  :             tlist[n] = more+n;

	mov	eax, DWORD PTR tv1254[ebp]
	mov	ebx, DWORD PTR _tlist
	mov	DWORD PTR [ebx+ecx*4], eax
	add	eax, 140				; 0000008cH
	inc	ecx
	add	edx, 4
	mov	DWORD PTR tv1254[ebp], eax
	mov	eax, DWORD PTR _tlist
	cmp	ecx, DWORD PTR _k_top$[ebp]
	jb	SHORT $LL98@painter_pr

; 838  :           for ( n = 0 ; n < k_top ; n++ )

	mov	ebx, DWORD PTR _newsize$89525[ebp]
$LN107@painter_pr:

; 841  :           }
; 842  :           for ( n = 0 ; n < newsize ; n++ )

	xor	ecx, ecx
	test	ebx, ebx
	je	SHORT $LN20@painter_pr
$LL99@painter_pr:

; 843  :             tlist[n]->spot = n;

	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [eax+136], ecx
	mov	eax, DWORD PTR _tlist
	inc	ecx
	cmp	ecx, ebx
	jb	SHORT $LL99@painter_pr
$LN20@painter_pr:

; 844  :           k += k_top;

	mov	ecx, DWORD PTR _k_top$[ebp]
	add	DWORD PTR _k$[ebp], ecx

; 845  :           k_top = newsize;

	mov	ecx, DWORD PTR _retval$89502[ebp]
	mov	DWORD PTR _k_top$[ebp], ebx
	mov	ebx, DWORD PTR _k$[ebp]
	jmp	SHORT $LN26@painter_pr
$LN100@painter_pr:
	mov	eax, DWORD PTR _tlist
$LN26@painter_pr:

; 846  :         }
; 847  :         if( retval & BSPLITTINGA )

	test	cl, 16					; 00000010H
	je	SHORT $LN19@painter_pr

; 848  :         {
; 849  :           ret = newell_split(tk,tj,tlist[k-1],tlist[k-2]);

	mov	edx, DWORD PTR [eax+ebx*4-8]
	mov	eax, DWORD PTR [eax+ebx*4-4]
	push	edx
	push	eax
$LN137@painter_pr:
	push	esi
	push	edi
$LN136@painter_pr:
	call	_newell_split
	add	esp, 16					; 00000010H

; 850  :           if ( ret )

	test	eax, eax
	je	SHORT $LN101@painter_pr

; 851  :           {
; 852  :             k -= ret;

	sub	ebx, eax
	mov	DWORD PTR _k$[ebp], ebx

; 853  :             goto repeat_tests;  /* might not have split */

	jmp	$repeat_tests$89541
$LN19@painter_pr:

; 854  :           }
; 855  :         }
; 856  :         else if ( retval & ASPLITTINGB )

	test	cl, 8
	je	SHORT $LN16@painter_pr

; 857  :         {
; 858  :           /* try splitting the other way */
; 859  :           ret = newell_split(tj,tk,tlist[k-1],tlist[k-2]);

	mov	ecx, DWORD PTR [eax+ebx*4-8]
	mov	edx, DWORD PTR [eax+ebx*4-4]
	push	ecx
	push	edx
	push	edi
	push	esi

; 860  :           if ( ret )
; 861  :           { k -= ret;
; 862  :             goto repeat_tests;

	jmp	SHORT $LN136@painter_pr
$LN16@painter_pr:

; 863  :           }
; 864  :         }
; 865  :         else if ( ((tk->flag & 0xF) == EDGE) && ((tj->flag & 0xF) == EDGE) )

	mov	ecx, DWORD PTR [edi+28]
	and	cl, 15					; 0000000fH
	cmp	cl, 1
	jne	SHORT $LN101@painter_pr
	mov	edx, DWORD PTR [esi+28]
	and	dl, 15					; 0000000fH
	cmp	dl, cl
	jne	SHORT $LN101@painter_pr

; 866  :         {
; 867  :           ret = newell_split(tk,tj,tlist[k-1],tlist[k-2]);

	mov	ecx, DWORD PTR [eax+ebx*4-8]
	mov	edx, DWORD PTR [eax+ebx*4-4]
	push	ecx
	push	edx

; 868  :           if ( ret )
; 869  :           {
; 870  :             k -= ret;
; 871  :             goto repeat_tests;  /* might not have split */

	jmp	SHORT $LN137@painter_pr
$LN101@painter_pr:

; 872  :           }
; 873  :         }
; 874  :       }
; 875  : 
; 876  :       tk->backstamp = backstamp;

	mov	eax, DWORD PTR _backstamp
	mov	DWORD PTR [edi+124], eax

; 877  :       /* swap tj and tk */
; 878  :       tlist[k] = tj; 

	mov	ecx, DWORD PTR _tlist
	mov	DWORD PTR [ecx+ebx*4], esi

; 879  :       tlist[tj->spot] = tk; 

	mov	edx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR _tlist
	mov	DWORD PTR [eax+edx*4], edi

; 880  :       tk->spot = tj->spot;

	mov	ecx, DWORD PTR [esi+136]
	mov	DWORD PTR [edi+136], ecx

; 881  :       tj->spot = k;  

	mov	DWORD PTR [esi+136], ebx

; 882  :       swaps++;

	fld	QWORD PTR _swaps
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR _swaps
$repeat_tests$89541:

; 782  :   for ( k = TEXTRA ; k < k_top ;  )

	mov	edx, DWORD PTR _k_top$[ebp]
	cmp	DWORD PTR _k$[ebp], edx
	jb	$LL106@painter_pr
$LN103@painter_pr:

; 910  : 
; 911  : repeat_tests: 
; 912  :   
; 913  :     continue;
; 914  :   }
; 915  : 
; 916  :   if ( tlist ) temp_free((char *)tlist);

	mov	eax, DWORD PTR _tlist
	test	eax, eax
	je	SHORT $LN110@painter_pr
	push	eax
	call	_temp_free
	add	esp, 4
$LN110@painter_pr:

; 917  :   if ( qtree ) temp_free((char *)qtree);

	mov	eax, DWORD PTR _qtree
	test	eax, eax
	je	SHORT $LN113@painter_pr
	push	eax
	call	_temp_free
	add	esp, 4
$LN113@painter_pr:
	pop	ebx
$LN1@painter_pr:
	pop	edi
	pop	esi

; 918  : 
; 919  : }  // end painter_process_trilist()

	mov	esp, ebp
	pop	ebp
	ret	0
_painter_process_trilist ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@DIMENMIB@Wrong?5middles?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@GGNLOPMM@Crossing?5count?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@FNFBHPOP@Visible?3?5?$CFd?5facets?5out?5of?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0DE@GGHBJACC@Abandoning?5visibility?5test?5and?5d@ ; `string'
PUBLIC	??_C@_0BM@CFILCGJA@crossing?5?$CFd?5?$CFd?5?5at?5?$CF20?415f?6?$AA@ ; `string'
PUBLIC	_visibility_end
;	COMDAT ??_C@_0BD@DIMENMIB@Wrong?5middles?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BD@DIMENMIB@Wrong?5middles?3?5?$CFd?6?$AA@ DB 'Wrong middles: %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GGNLOPMM@Crossing?5count?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BE@GGNLOPMM@Crossing?5count?3?5?$CFd?6?$AA@ DB 'Crossing count: %d'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FNFBHPOP@Visible?3?5?$CFd?5facets?5out?5of?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BO@FNFBHPOP@Visible?3?5?$CFd?5facets?5out?5of?5?$CFd?6?$AA@ DB 'Vi'
	DB	'sible: %d facets out of %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@GGHBJACC@Abandoning?5visibility?5test?5and?5d@
CONST	SEGMENT
??_C@_0DE@GGHBJACC@Abandoning?5visibility?5test?5and?5d@ DB 'Abandoning v'
	DB	'isibility test and drawing all facets.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CFILCGJA@crossing?5?$CFd?5?$CFd?5?5at?5?$CF20?415f?6?$AA@
CONST	SEGMENT
??_C@_0BM@CFILCGJA@crossing?5?$CFd?5?$CFd?5?5at?5?$CF20?415f?6?$AA@ DB 'c'
	DB	'rossing %d %d  at %20.15f', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _visibility_end
_TEXT	SEGMENT
_next_u$ = -8						; size = 8
_visibility_end PROC					; COMDAT

; 2155 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 2156 :   size_t k;
; 2157 :   struct tsort *t;
; 2158 : 
; 2159 :   REAL next_u;
; 2160 :   int vis_display_count;
; 2161 : 
; 2162 :   int badflag = 0;
; 2163 : 
; 2164 :   debug_seq = 0;
; 2165 : 
; 2166 :   /* List of edges to check top facet for */
; 2167 :   check_list_max = 1000;
; 2168 :   check_list = (struct vis_conedge **)temp_calloc(check_list_max,
; 2169 :                    sizeof(struct vis_conedge *));

	push	2169					; 00000879H
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	push	4
	xor	esi, esi
	push	1000					; 000003e8H
	mov	DWORD PTR _debug_seq, esi
	mov	DWORD PTR _check_list_max, 1000		; 000003e8H
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _check_list, eax

; 2170 :   check_list_count = 0;

	mov	DWORD PTR _check_list_count, esi

; 2171 : 
; 2172 :   /* populate raw vertex and edge lists */
; 2173 :   visibility_lists();

	call	_visibility_lists

; 2174 : 
; 2175 :   if ( vis_vertex_count == 0 ) 

	cmp	DWORD PTR _vis_vertex_count, esi
	je	$draw_visible$90318

; 2176 :     goto draw_visible;
; 2177 : 
; 2178 :   /* Consolidation of vertices and edges */
; 2179 :   visibility_vertex_consolidate();  

	call	_visibility_vertex_consolidate

; 2180 :   visibility_edge_consolidate();

	call	_visibility_edge_consolidate

; 2181 : 
; 2182 :   if ( badflag ) goto bail_out;
; 2183 : 
; 2184 :   visibility_edge_sort();

	call	_visibility_edge_sort

; 2185 : 
; 2186 :   /* Initialize crossing event heap with sentinel */
; 2187 :   vis_heap_max = vecount > 100 ? vecount : 100;

	mov	eax, DWORD PTR _vecount
	cmp	eax, 100				; 00000064H
	jg	SHORT $LN52@visibility@7
	mov	eax, 100				; 00000064H
$LN52@visibility@7:

; 2188 :   vis_heap = (struct vis_event *)temp_calloc(vis_heap_max,
; 2189 :                                           sizeof(struct vis_event));

	push	2189					; 0000088dH
	push	OFFSET ??_C@_09MBOBPMLK@PAINTER?4C?$AA@
	push	16					; 00000010H
	push	eax
	mov	DWORD PTR _vis_heap_max, eax
	call	_kb_temp_calloc

; 2190 :   vis_heap[0].time = 1e30;

	fld	QWORD PTR __real@46293e5939a08cea
	mov	DWORD PTR _vis_heap, eax
	fstp	QWORD PTR [eax]

; 2191 :   vis_heap_count = 1;
; 2192 :   vis_crossing_count = 0;
; 2193 : 
; 2194 :   /* Initialize active edge list with sentinel vertex at the top */
; 2195 :   sentinel.v[0] = sentinelv;
; 2196 :   sentinel.v[1] = sentinelv+1;
; 2197 :   sentinelv[0].x[0] = -1e20;

	fld	QWORD PTR __real@c415af1d78b58c40

; 2198 :   sentinelv[0].x[1] = 1e20;
; 2199 :   sentinelv[1].x[0] = 1e20;
; 2200 :   sentinelv[1].x[1] = 1e20;
; 2201 :   sentinel.m = 0;
; 2202 :   sentinel.maxlayers = 0;
; 2203 :   sentinel.layers = 0;
; 2204 :   sentinel.layer = NULL;
; 2205 :   sentinel.prev_active = NULL;
; 2206 :   sentinel.next_active = NULL;
; 2207 :   sentinel.rawend = -1;  // no facets
; 2208 :   active_edge_first = &sentinel;
; 2209 : 
; 2210 : 
; 2211 :   /* Sweep */
; 2212 :   vertex_event_spot = 0;

	xor	ecx, ecx
	fst	QWORD PTR _sentinelv
	add	esp, 16					; 00000010H
	fld	QWORD PTR __real@4415af1d78b58c40
	mov	DWORD PTR _vis_heap_count, 1
	fst	QWORD PTR _sentinelv+8
	mov	DWORD PTR _vis_crossing_count, esi
	fst	QWORD PTR _sentinelv+32
	mov	DWORD PTR _sentinel+4, OFFSET _sentinelv
	fstp	QWORD PTR _sentinelv+40
	mov	DWORD PTR _sentinel+8, OFFSET _sentinelv+32
	fldz
	mov	DWORD PTR _sentinel+60, esi
	fstp	QWORD PTR _sentinel+16
	mov	DWORD PTR _sentinel+52, esi
	mov	DWORD PTR _sentinel+56, esi
	mov	DWORD PTR _sentinel+32, esi

; 2213 :   sweep_u = -1e20;

	fst	QWORD PTR _sweep_u
	mov	DWORD PTR _sentinel+36, esi
	mov	DWORD PTR _sentinel+28, -1
	mov	DWORD PTR _active_edge_first, OFFSET _sentinel
	mov	DWORD PTR _vertex_event_spot, ecx

; 2214 :   while ( vertex_event_spot < vis_vertex_count )

	cmp	DWORD PTR _vis_vertex_count, esi
	jg	SHORT $LN53@visibility@7

; 2257 :   for ( k = 0, t = vis_list, vis_display_count = 0 ; k < vis_count ; k++,t++ )

	fstp	ST(0)
$draw_visible$90318:

; 2259 : 
; 2260 : draw_visible:
; 2261 :   /* Display elements marked visible */
; 2262 :   for ( k = 0, t = vis_list, vis_display_count = 0 ; k < vis_count ; k++,t++ )

	mov	edi, DWORD PTR _vis_list
	xor	ebx, ebx
	cmp	DWORD PTR _vis_count, ebx
	jbe	$LN5@visibility@7
	npad	13
$LL7@visibility@7:

; 2263 :   if ( t->flag & VISIBLE )

	mov	eax, DWORD PTR [edi+28]
	test	eax, 16384				; 00004000H
	je	$LN6@visibility@7

; 2264 :   { if ( (t->flag & 0xF) == FACET )

	and	al, 15					; 0000000fH

; 2265 :      (*display_facet)(t);

	push	edi
	cmp	al, 2
	jne	$LN3@visibility@7
	call	DWORD PTR _display_facet
	jmp	$LN54@visibility@7
$LL33@visibility@7:

; 2214 :   while ( vertex_event_spot < vis_vertex_count )

	fld	QWORD PTR _sweep_u
$LN53@visibility@7:

; 2215 :   {
; 2216 :     int retval; /* return code from event handlers; < 0 for error */
; 2217 : 
; 2218 :     debug_seq++;  // for debugging 

	inc	DWORD PTR _debug_seq
	fld	QWORD PTR __real@3ddb7cdfd9d7bdbb
	fld	QWORD PTR __real@3fe0000000000000

; 2219 : 
; 2220 :     /* find which is next event and process */
; 2221 :     if ( (vis_heap_count <= 0) || (vis_vertices[vertex_event_spot].x[0] < vis_heap[0].time) )

	mov	edi, DWORD PTR _vis_vertices
	cmp	DWORD PTR _vis_heap_count, esi
	jle	$LN17@visibility@7
	mov	edx, DWORD PTR _vis_heap
	fld	QWORD PTR [edx]
	mov	eax, ecx
	shl	eax, 5
	fcomp	QWORD PTR [eax+edi]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN17@visibility@7

; 2234 :     }
; 2235 :     else /* do crossing event */
; 2236 :     { struct vis_conedge *e1,*e2;
; 2237 :       next_u = vis_heap[0].time;

	fld	QWORD PTR [edx]
	fst	QWORD PTR _next_u$[ebp]

; 2238 : 
; 2239 :       if ( (next_u - sweep_u) > 1e-10 )

	fld	ST(0)
	fsub	ST(0), ST(4)
	fcomp	ST(3)
	fnstsw	ax
	fstp	ST(2)
	test	ah, 65					; 00000041H
	jne	SHORT $LN47@visibility@7

; 2240 :          check_visible((next_u+sweep_u)/2); 

	fxch	ST(2)
	sub	esp, 8
	faddp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR [esp]
	call	_check_visible
	mov	edx, DWORD PTR _vis_heap
	add	esp, 8
	jmp	SHORT $LN12@visibility@7
$LN47@visibility@7:
	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(0)
$LN12@visibility@7:

; 2241 :       e1 = vis_heap[0].e1; 

	mov	edi, DWORD PTR [edx+8]

; 2242 :       e2 = vis_heap[0].e2;

	mov	ebx, DWORD PTR [edx+12]

; 2243 :       vis_delete_heap(0);

	push	esi
	call	_vis_delete_heap
	add	esp, 4

; 2244 :       if ( visdebuglevel >= VIS_EVENTDUMP )

	cmp	DWORD PTR _visdebuglevel, 3
	jl	SHORT $LN11@visibility@7

; 2245 :         printf("crossing %d %d  at %20.15f\n",(int)(e1-vis_conedges),  
; 2246 :               (int)(e2-vis_conedges),(DOUBLE)next_u);

	mov	esi, DWORD PTR _vis_conedges
	fld	QWORD PTR _next_u$[ebp]
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	sub	esp, 8
	mov	eax, 954437177				; 38e38e39H
	fstp	QWORD PTR [esp]
	push	ecx
	mov	ecx, edi
	sub	ecx, esi
	imul	ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	OFFSET ??_C@_0BM@CFILCGJA@crossing?5?$CFd?5?$CFd?5?5at?5?$CF20?415f?6?$AA@
	call	_printf
	add	esp, 20					; 00000014H
	xor	esi, esi
$LN11@visibility@7:

; 2247 :       sweep_u = next_u;   

	fld	QWORD PTR _next_u$[ebp]

; 2248 :       vis_crossing(e1,e2);

	push	ebx
	push	edi
	fstp	QWORD PTR _sweep_u
	call	_vis_crossing
	mov	ecx, DWORD PTR _vertex_event_spot
	add	esp, 8
	jmp	SHORT $LN13@visibility@7
$LN17@visibility@7:

; 2222 :     { /* do vertex event */
; 2223 :       next_u = vis_vertices[vertex_event_spot].x[0];

	mov	edx, ecx
	shl	edx, 5
	fld	QWORD PTR [edx+edi]
	fst	QWORD PTR _next_u$[ebp]

; 2224 :       if ( (next_u - sweep_u) > 1e-10 )

	fld	ST(0)
	fsub	ST(0), ST(4)
	fcomp	ST(3)
	fnstsw	ax
	fstp	ST(2)
	test	ah, 65					; 00000041H
	jne	SHORT $LN50@visibility@7

; 2225 :          check_visible((next_u+sweep_u)/2); 

	fxch	ST(2)
	sub	esp, 8
	faddp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	fstp	QWORD PTR [esp]
	call	_check_visible
	mov	ecx, DWORD PTR _vertex_event_spot
	fld	QWORD PTR _next_u$[ebp]
	mov	edi, DWORD PTR _vis_vertices
	add	esp, 8
	jmp	SHORT $LN16@visibility@7
$LN50@visibility@7:
	fstp	ST(2)
	fstp	ST(1)
$LN16@visibility@7:

; 2226 :       sweep_u = next_u;
; 2227 :       retval = handle_vertex_event(vis_vertices+vertex_event_spot);

	shl	ecx, 5
	fstp	QWORD PTR _sweep_u
	add	ecx, edi
	push	ecx
	call	_handle_vertex_event
	add	esp, 4

; 2228 :       if ( retval < 0 )

	test	eax, eax
	jns	SHORT $LN14@visibility@7

; 2229 :       { retval = visibility_recover();

	call	_visibility_recover

; 2230 :         if ( retval < 0 )

	test	eax, eax
	js	SHORT $bail_out$90320
$LN14@visibility@7:

; 2231 :           goto bail_out;
; 2232 :       }
; 2233 :       vertex_event_spot++;

	mov	ecx, DWORD PTR _vertex_event_spot
	inc	ecx
	mov	DWORD PTR _vertex_event_spot, ecx
$LN13@visibility@7:

; 2214 :   while ( vertex_event_spot < vis_vertex_count )

	cmp	ecx, DWORD PTR _vis_vertex_count
	jl	$LL33@visibility@7

; 2230 :         if ( retval < 0 )

	jmp	$draw_visible$90318
$bail_out$90320:

; 2249 :     }
; 2250 :   } // end while
; 2251 : 
; 2252 : 
; 2253 :   goto draw_visible;
; 2254 : 
; 2255 : bail_out: /* error handling: mark all as visible */
; 2256 :   kb_error(5555,"Abandoning visibility test and drawing all facets.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0DE@GGHBJACC@Abandoning?5visibility?5test?5and?5d@
	push	5555					; 000015b3H
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2257 :   for ( k = 0, t = vis_list, vis_display_count = 0 ; k < vis_count ; k++,t++ )

	xor	ecx, ecx
	cmp	DWORD PTR _vis_count, esi
	jbe	$draw_visible$90318

; 2249 :     }
; 2250 :   } // end while
; 2251 : 
; 2252 : 
; 2253 :   goto draw_visible;
; 2254 : 
; 2255 : bail_out: /* error handling: mark all as visible */
; 2256 :   kb_error(5555,"Abandoning visibility test and drawing all facets.\n",WARNING);

	mov	eax, DWORD PTR _vis_list
	add	eax, 28					; 0000001cH
	npad	8
$LL10@visibility@7:

; 2258 :     t->flag |= VISIBLE;

	or	DWORD PTR [eax], 16384			; 00004000H
	inc	ecx
	add	eax, 140				; 0000008cH
	cmp	ecx, DWORD PTR _vis_count
	jb	SHORT $LL10@visibility@7

; 2257 :   for ( k = 0, t = vis_list, vis_display_count = 0 ; k < vis_count ; k++,t++ )

	jmp	$draw_visible$90318
$LN3@visibility@7:

; 2266 :     else (*display_edge)(t);

	call	DWORD PTR _display_edge
$LN54@visibility@7:
	add	esp, 4

; 2267 :     vis_display_count++;

	inc	esi
$LN6@visibility@7:

; 2259 : 
; 2260 : draw_visible:
; 2261 :   /* Display elements marked visible */
; 2262 :   for ( k = 0, t = vis_list, vis_display_count = 0 ; k < vis_count ; k++,t++ )

	inc	ebx
	add	edi, 140				; 0000008cH
	cmp	ebx, DWORD PTR _vis_count
	jb	$LL7@visibility@7
$LN5@visibility@7:

; 2268 :   }
; 2269 :   temp_free((char*)vis_heap);  vis_heap = 0;

	mov	eax, DWORD PTR _vis_heap
	push	eax
	call	_temp_free

; 2270 :   temp_free((char*)vis_conedges); vis_conedges = 0;

	mov	ecx, DWORD PTR _vis_conedges
	xor	edi, edi
	push	ecx
	mov	DWORD PTR _vis_heap, edi
	call	_temp_free

; 2271 :   temp_free((char*)vis_rawedges); vis_rawedges = 0;

	mov	edx, DWORD PTR _vis_rawedges
	push	edx
	mov	DWORD PTR _vis_conedges, edi
	call	_temp_free

; 2272 :   temp_free((char*)vis_vertices); vis_vertices = 0;

	mov	eax, DWORD PTR _vis_vertices
	push	eax
	mov	DWORD PTR _vis_rawedges, edi
	call	_temp_free

; 2273 :   temp_free((char*)check_list);  check_list = 0;

	mov	ecx, DWORD PTR _check_list
	push	ecx
	mov	DWORD PTR _vis_vertices, edi
	call	_temp_free

; 2274 :   temp_free((char*)rawplist);  rawplist = 0;

	mov	edx, DWORD PTR _rawplist
	push	edx
	mov	DWORD PTR _check_list, edi
	call	_temp_free

; 2275 :   temp_free((char*)vis_list);  vis_list = 0;

	mov	eax, DWORD PTR _vis_list
	push	eax
	mov	DWORD PTR _rawplist, edi
	call	_temp_free
	add	esp, 28					; 0000001cH

; 2276 : 
; 2277 : if (visdebuglevel >= VIS_TIMING)

	cmp	DWORD PTR _visdebuglevel, 1
	mov	DWORD PTR _vis_list, edi
	jl	SHORT $LN1@visibility@7

; 2278 : {
; 2279 : fprintf(stderr,"Visible: %d facets out of %d\n",vis_display_count,(int)vis_count);

	mov	ecx, DWORD PTR _vis_count
	push	ecx
	push	esi
	push	OFFSET ??_C@_0BO@FNFBHPOP@Visible?3?5?$CFd?5facets?5out?5of?5?$CFd?6?$AA@
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf

; 2280 : fprintf(stderr,"Crossing count: %d\n",vis_crossing_count);

	mov	edx, DWORD PTR _vis_crossing_count
	add	esp, 16					; 00000010H
	push	edx
	push	OFFSET ??_C@_0BE@GGNLOPMM@Crossing?5count?3?5?$CFd?6?$AA@
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf

; 2281 : fprintf(stderr,"Wrong middles: %d\n",wrong_middles); wrong_middles = 0;

	mov	eax, DWORD PTR _wrong_middles
	add	esp, 12					; 0000000cH
	push	eax
	push	OFFSET ??_C@_0BD@DIMENMIB@Wrong?5middles?3?5?$CFd?6?$AA@
	call	___iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _wrong_middles, edi
$LN1@visibility@7:
	pop	edi
	pop	esi
	pop	ebx

; 2282 : }
; 2283 : } // end visibility_end()

	mov	esp, ebp
	pop	ebp
	ret	0
_visibility_end ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@FLAFLBMN@loop?5bailouts?3?5?5?5?$CFg?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@PBMOBINJ@swaps?3?5?5?5?5?5?5?5?5?5?5?5?$CFg?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@FPFJANFD@crossings?3?5?5?5?5?5?5?5?$CFg?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@LLGFEALB@sep_plane_calls?3?5?$CFg?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@PBHGENG@sep_line_calls?3?5?5?$CFg?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@JFFLKLCE@box_overlaps?3?5?5?5?5?$CFg?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@GKCIIJNH@?5?5edgeedge?3?5?5?5?5?5?5?$CFg?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@LECBCGBF@?5?5facetedge?3?5?5?5?5?5?$CFg?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@GPPEHEFO@?5?5facetfacet?3?5?5?5?5?$CFg?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@MCOAAHGA@in_back_calls?3?5?5?5?$CFg?6?$AA@ ; `string'
PUBLIC	_painter_end
EXTRN	_finish_graphics:DWORD
;	COMDAT ??_C@_0BF@FLAFLBMN@loop?5bailouts?3?5?5?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BF@FLAFLBMN@loop?5bailouts?3?5?5?5?$CFg?6?$AA@ DB 'loop bailouts: '
	DB	'  %g', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PBMOBINJ@swaps?3?5?5?5?5?5?5?5?5?5?5?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BF@PBMOBINJ@swaps?3?5?5?5?5?5?5?5?5?5?5?5?$CFg?6?$AA@ DB 'swaps:  '
	DB	'         %g', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FPFJANFD@crossings?3?5?5?5?5?5?5?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BF@FPFJANFD@crossings?3?5?5?5?5?5?5?5?$CFg?6?$AA@ DB 'crossings:  '
	DB	'     %g', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LLGFEALB@sep_plane_calls?3?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BF@LLGFEALB@sep_plane_calls?3?5?$CFg?6?$AA@ DB 'sep_plane_calls: %'
	DB	'g', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PBHGENG@sep_line_calls?3?5?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BF@PBHGENG@sep_line_calls?3?5?5?$CFg?6?$AA@ DB 'sep_line_calls:  %'
	DB	'g', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JFFLKLCE@box_overlaps?3?5?5?5?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BF@JFFLKLCE@box_overlaps?3?5?5?5?5?$CFg?6?$AA@ DB 'box_overlaps:  '
	DB	'  %g', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GKCIIJNH@?5?5edgeedge?3?5?5?5?5?5?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BF@GKCIIJNH@?5?5edgeedge?3?5?5?5?5?5?5?$CFg?6?$AA@ DB '  edgeedge:'
	DB	'      %g', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LECBCGBF@?5?5facetedge?3?5?5?5?5?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BF@LECBCGBF@?5?5facetedge?3?5?5?5?5?5?$CFg?6?$AA@ DB '  facetedge:'
	DB	'     %g', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GPPEHEFO@?5?5facetfacet?3?5?5?5?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BF@GPPEHEFO@?5?5facetfacet?3?5?5?5?5?$CFg?6?$AA@ DB '  facetfacet:'
	DB	'    %g', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MCOAAHGA@in_back_calls?3?5?5?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BF@MCOAAHGA@in_back_calls?3?5?5?5?$CFg?6?$AA@ DB 'in_back_calls:  '
	DB	' %g', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _painter_end
_TEXT	SEGMENT
_painter_end PROC					; COMDAT

; 931  :   size_t k;
; 932  :  
; 933  :   in_back_calls = box_overlaps = facetfacet = facetedge = edgeedge = 
; 934  :    crossings = sep_plane_calls = sep_line_calls = 0;

	fldz

; 935  :   loopbailouts = 0;
; 936  : 
; 937  :   if ( count > maxcount ) count = maxcount;    /* in case there was excess */

	mov	edx, DWORD PTR _count
	mov	eax, DWORD PTR _maxcount
	fst	QWORD PTR _sep_line_calls
	fst	QWORD PTR _sep_plane_calls
	fst	QWORD PTR _crossings
	fst	QWORD PTR _edgeedge
	fst	QWORD PTR _facetedge
	fst	QWORD PTR _facetfacet
	fst	QWORD PTR _box_overlaps
	fst	QWORD PTR _in_back_calls
	fstp	QWORD PTR _loopbailouts
	cmp	edx, eax
	jbe	SHORT $LN15@painter_en
	mov	edx, eax
	mov	DWORD PTR _count, edx
$LN15@painter_en:

; 938  : 
; 939  :   /* find bounding box */
; 940  :   if ( need_bounding_box && !painter_multiple_sweep_flag )

	cmp	DWORD PTR _need_bounding_box, 0
	push	edi
	je	$LN23@painter_en
	cmp	DWORD PTR _painter_multiple_sweep_flag, 0
	jne	$LN6@painter_en

; 941  :   { struct tsort *t;
; 942  :     bbox_minx = bbox_miny = 1e20;

	fld	QWORD PTR __real@4415af1d78b58c40

; 943  :     bbox_maxx = bbox_maxy = -1e20;
; 944  :     for ( k = 0, t = trilist ; k < count ; k++,t++ )

	mov	ecx, DWORD PTR _trilist
	fld	ST(0)
	xor	edi, edi
	fst	QWORD PTR _bbox_miny
	fxch	ST(1)
	fst	QWORD PTR _bbox_minx
	fld	QWORD PTR __real@c415af1d78b58c40
	fld	ST(0)
	fst	QWORD PTR _bbox_maxy
	fxch	ST(1)
	fst	QWORD PTR _bbox_maxx
	cmp	edx, 4
	jl	$LC24@painter_en

; 941  :   { struct tsort *t;
; 942  :     bbox_minx = bbox_miny = 1e20;

	push	esi
	lea	esi, DWORD PTR [edx-4]
	shr	esi, 2
	inc	esi
	lea	edi, DWORD PTR [esi*4]

; 943  :     bbox_maxx = bbox_maxy = -1e20;
; 944  :     for ( k = 0, t = trilist ; k < count ; k++,t++ )

$LN41@painter_en:

; 945  :     { if ( t->mins[0] < bbox_minx ) bbox_minx = (REAL)t->mins[0];

	fld	DWORD PTR [ecx+80]
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN25@painter_en
	fstp	ST(2)
	fld	DWORD PTR [ecx+80]
	fst	QWORD PTR _bbox_minx
	fxch	ST(2)
$LN25@painter_en:

; 946  :       if ( t->mins[1] < bbox_miny ) bbox_miny = (REAL)t->mins[1];

	fld	DWORD PTR [ecx+84]
	fcomp	ST(4)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN26@painter_en
	fstp	ST(3)
	fld	DWORD PTR [ecx+84]
	fst	QWORD PTR _bbox_miny
	fxch	ST(3)
$LN26@painter_en:

; 947  :       if ( t->maxs[0] > bbox_maxx ) bbox_maxx = (REAL)t->maxs[0];

	fld	DWORD PTR [ecx+92]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN27@painter_en
	fstp	ST(0)
	fld	DWORD PTR [ecx+92]
	fst	QWORD PTR _bbox_maxx
$LN27@painter_en:

; 948  :       if ( t->maxs[1] > bbox_maxy ) bbox_maxy = (REAL)t->maxs[1];

	fld	DWORD PTR [ecx+96]
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN28@painter_en
	fstp	ST(1)
	fld	DWORD PTR [ecx+96]
	fst	QWORD PTR _bbox_maxy
	fxch	ST(1)
$LN28@painter_en:

; 945  :     { if ( t->mins[0] < bbox_minx ) bbox_minx = (REAL)t->mins[0];

	fld	DWORD PTR [ecx+220]
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN29@painter_en
	fstp	ST(2)
	fld	DWORD PTR [ecx+220]
	fst	QWORD PTR _bbox_minx
	fxch	ST(2)
$LN29@painter_en:

; 946  :       if ( t->mins[1] < bbox_miny ) bbox_miny = (REAL)t->mins[1];

	fld	DWORD PTR [ecx+224]
	fcomp	ST(4)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN30@painter_en
	fstp	ST(3)
	fld	DWORD PTR [ecx+224]
	fst	QWORD PTR _bbox_miny
	fxch	ST(3)
$LN30@painter_en:

; 947  :       if ( t->maxs[0] > bbox_maxx ) bbox_maxx = (REAL)t->maxs[0];

	fld	DWORD PTR [ecx+232]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN31@painter_en
	fstp	ST(0)
	fld	DWORD PTR [ecx+232]
	fst	QWORD PTR _bbox_maxx
$LN31@painter_en:

; 948  :       if ( t->maxs[1] > bbox_maxy ) bbox_maxy = (REAL)t->maxs[1];

	fld	DWORD PTR [ecx+236]
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN32@painter_en
	fstp	ST(1)
	fld	DWORD PTR [ecx+236]
	fst	QWORD PTR _bbox_maxy
	fxch	ST(1)
$LN32@painter_en:

; 945  :     { if ( t->mins[0] < bbox_minx ) bbox_minx = (REAL)t->mins[0];

	fld	DWORD PTR [ecx+360]
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN33@painter_en
	fstp	ST(2)
	fld	DWORD PTR [ecx+360]
	fst	QWORD PTR _bbox_minx
	fxch	ST(2)
$LN33@painter_en:

; 946  :       if ( t->mins[1] < bbox_miny ) bbox_miny = (REAL)t->mins[1];

	fld	DWORD PTR [ecx+364]
	fcomp	ST(4)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN34@painter_en
	fstp	ST(3)
	fld	DWORD PTR [ecx+364]
	fst	QWORD PTR _bbox_miny
	fxch	ST(3)
$LN34@painter_en:

; 947  :       if ( t->maxs[0] > bbox_maxx ) bbox_maxx = (REAL)t->maxs[0];

	fld	DWORD PTR [ecx+372]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN35@painter_en
	fstp	ST(0)
	fld	DWORD PTR [ecx+372]
	fst	QWORD PTR _bbox_maxx
$LN35@painter_en:

; 948  :       if ( t->maxs[1] > bbox_maxy ) bbox_maxy = (REAL)t->maxs[1];

	fld	DWORD PTR [ecx+376]
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN36@painter_en
	fstp	ST(1)
	fld	DWORD PTR [ecx+376]
	fst	QWORD PTR _bbox_maxy
	fxch	ST(1)
$LN36@painter_en:

; 945  :     { if ( t->mins[0] < bbox_minx ) bbox_minx = (REAL)t->mins[0];

	fld	DWORD PTR [ecx+500]
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN37@painter_en
	fstp	ST(2)
	fld	DWORD PTR [ecx+500]
	fst	QWORD PTR _bbox_minx
	fxch	ST(2)
$LN37@painter_en:

; 946  :       if ( t->mins[1] < bbox_miny ) bbox_miny = (REAL)t->mins[1];

	fld	DWORD PTR [ecx+504]
	fcomp	ST(4)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN38@painter_en
	fstp	ST(3)
	fld	DWORD PTR [ecx+504]
	fst	QWORD PTR _bbox_miny
	fxch	ST(3)
$LN38@painter_en:

; 947  :       if ( t->maxs[0] > bbox_maxx ) bbox_maxx = (REAL)t->maxs[0];

	fld	DWORD PTR [ecx+512]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN39@painter_en
	fstp	ST(0)
	fld	DWORD PTR [ecx+512]
	fst	QWORD PTR _bbox_maxx
$LN39@painter_en:

; 948  :       if ( t->maxs[1] > bbox_maxy ) bbox_maxy = (REAL)t->maxs[1];

	fld	DWORD PTR [ecx+516]
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN40@painter_en
	fstp	ST(1)
	fld	DWORD PTR [ecx+516]
	fst	QWORD PTR _bbox_maxy
	fxch	ST(1)
$LN40@painter_en:

; 941  :   { struct tsort *t;
; 942  :     bbox_minx = bbox_miny = 1e20;

	add	ecx, 560				; 00000230H
	dec	esi
	jne	$LN41@painter_en
	pop	esi
$LC24@painter_en:

; 943  :     bbox_maxx = bbox_maxy = -1e20;
; 944  :     for ( k = 0, t = trilist ; k < count ; k++,t++ )

	cmp	edi, edx
	jae	SHORT $LN111@painter_en
	add	ecx, 84					; 00000054H
	sub	edx, edi
$LC13@painter_en:

; 945  :     { if ( t->mins[0] < bbox_minx ) bbox_minx = (REAL)t->mins[0];

	fld	DWORD PTR [ecx-4]
	fcomp	ST(3)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN10@painter_en
	fstp	ST(2)
	fld	DWORD PTR [ecx-4]
	fst	QWORD PTR _bbox_minx
	fxch	ST(2)
$LN10@painter_en:

; 946  :       if ( t->mins[1] < bbox_miny ) bbox_miny = (REAL)t->mins[1];

	fld	DWORD PTR [ecx]
	fcomp	ST(4)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN9@painter_en
	fstp	ST(3)
	fld	DWORD PTR [ecx]
	fst	QWORD PTR _bbox_miny
	fxch	ST(3)
$LN9@painter_en:

; 947  :       if ( t->maxs[0] > bbox_maxx ) bbox_maxx = (REAL)t->maxs[0];

	fld	DWORD PTR [ecx+8]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN8@painter_en
	fstp	ST(0)
	fld	DWORD PTR [ecx+8]
	fst	QWORD PTR _bbox_maxx
$LN8@painter_en:

; 948  :       if ( t->maxs[1] > bbox_maxy ) bbox_maxy = (REAL)t->maxs[1];

	fld	DWORD PTR [ecx+12]
	fcomp	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN12@painter_en
	fstp	ST(1)
	fld	DWORD PTR [ecx+12]
	fst	QWORD PTR _bbox_maxy
	fxch	ST(1)
$LN12@painter_en:

; 943  :     bbox_maxx = bbox_maxy = -1e20;
; 944  :     for ( k = 0, t = trilist ; k < count ; k++,t++ )

	add	ecx, 140				; 0000008cH
	dec	edx
	jne	SHORT $LC13@painter_en
$LN111@painter_en:

; 949  :     }
; 950  :   }
; 951  : 
; 952  :   if ( !painter_multiple_sweep_flag )

	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(1)
	fstp	ST(0)
$LN43@painter_en:

; 953  :     (*init_graphics)();  // print out postscript header

	call	DWORD PTR _init_graphics
$LN6@painter_en:

; 954  : 
; 955  :   painter_process_trilist();

	call	_painter_process_trilist

; 956  : 
; 957  :   while ( painter_multiple_sweep_flag )

	cmp	DWORD PTR _painter_multiple_sweep_flag, 0
	pop	edi
	je	SHORT $LN20@painter_en
$LL5@painter_en:

; 958  :   { reset_multiple_sweep();

	call	_reset_multiple_sweep

; 959  :     if ( painter_multiple_sweep_flag == MULTIPLE_SWEEP_DONE )

	cmp	DWORD PTR _painter_multiple_sweep_flag, 4
	je	SHORT $LN20@painter_en

; 960  :       break;
; 961  :     raw_generate();

	call	_raw_generate

; 962  :     painter_process_trilist();

	call	_painter_process_trilist
	cmp	DWORD PTR _painter_multiple_sweep_flag, 0
	jne	SHORT $LL5@painter_en
$LN20@painter_en:

; 963  :   }
; 964  : 
; 965  :   if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN2@painter_en

; 966  :   {
; 967  :     printf("in_back_calls:   %g\n",(DOUBLE)in_back_calls);

	fld	QWORD PTR _in_back_calls
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BF@MCOAAHGA@in_back_calls?3?5?5?5?$CFg?6?$AA@
	call	_printf

; 968  :     printf("  facetfacet:    %g\n",(DOUBLE)facetfacet);

	fld	QWORD PTR _facetfacet
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BF@GPPEHEFO@?5?5facetfacet?3?5?5?5?5?$CFg?6?$AA@
	call	_printf

; 969  :     printf("  facetedge:     %g\n",(DOUBLE)facetedge);

	fld	QWORD PTR _facetedge
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BF@LECBCGBF@?5?5facetedge?3?5?5?5?5?5?$CFg?6?$AA@
	call	_printf

; 970  :     printf("  edgeedge:      %g\n",(DOUBLE)edgeedge);

	fld	QWORD PTR _edgeedge
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BF@GKCIIJNH@?5?5edgeedge?3?5?5?5?5?5?5?$CFg?6?$AA@
	call	_printf

; 971  :     printf("box_overlaps:    %g\n",(DOUBLE)box_overlaps);

	fld	QWORD PTR _box_overlaps
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BF@JFFLKLCE@box_overlaps?3?5?5?5?5?$CFg?6?$AA@
	call	_printf

; 972  :     printf("sep_line_calls:  %g\n",(DOUBLE)sep_line_calls);

	fld	QWORD PTR _sep_line_calls
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BF@PBHGENG@sep_line_calls?3?5?5?$CFg?6?$AA@
	call	_printf

; 973  :     printf("sep_plane_calls: %g\n",(DOUBLE)sep_plane_calls);

	fld	QWORD PTR _sep_plane_calls
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BF@LLGFEALB@sep_plane_calls?3?5?$CFg?6?$AA@
	call	_printf

; 974  :     printf("crossings:       %g\n",(DOUBLE)crossings);

	fld	QWORD PTR _crossings
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BF@FPFJANFD@crossings?3?5?5?5?5?5?5?5?$CFg?6?$AA@
	call	_printf

; 975  :     printf("swaps:           %g\n",(DOUBLE)swaps);

	fld	QWORD PTR _swaps
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BF@PBMOBINJ@swaps?3?5?5?5?5?5?5?5?5?5?5?5?$CFg?6?$AA@
	call	_printf

; 976  :     printf("loop bailouts:   %g\n",(DOUBLE)loopbailouts);

	fld	QWORD PTR _loopbailouts
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BF@FLAFLBMN@loop?5bailouts?3?5?5?5?$CFg?6?$AA@
	call	_printf
	add	esp, 12					; 0000000cH
$LN2@painter_en:

; 977  :   }
; 978  : 
; 979  :   temp_free((char *)trilist); trilist = NULL;

	mov	eax, DWORD PTR _trilist
	push	eax
	call	_temp_free
	add	esp, 4

; 980  : 
; 981  :   if ( visibility_test )

	cmp	DWORD PTR _visibility_test, 0
	mov	DWORD PTR _trilist, 0
	je	SHORT $LN1@painter_en

; 982  :     visibility_end();

	call	_visibility_end
$LN1@painter_en:

; 983  : 
; 984  :   (*finish_graphics)();

	jmp	DWORD PTR _finish_graphics
$LN23@painter_en:

; 949  :     }
; 950  :   }
; 951  : 
; 952  :   if ( !painter_multiple_sweep_flag )

	cmp	DWORD PTR _painter_multiple_sweep_flag, 0
	jne	$LN6@painter_en
	jmp	$LN43@painter_en
_painter_end ENDP
_TEXT	ENDS
END
