; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\VERAVG.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_get_fe_edge
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _get_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_edge PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp

; 70   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[1]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H

; 72   : }

	pop	ebp
	ret	0
$LN2@get_prev_e:

; 71   :   else return feptr(fe_id)->nextedge[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 72   : }

	pop	ebp
	ret	0
_get_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _get_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_facet PROC					; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp

; 84   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 85   :     return inverse_id(feptr(fe_id)->nextfacet[1]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]
	xor	eax, 134217728				; 08000000H

; 88   : }

	pop	ebp
	ret	0
$LN2@get_prev_f:

; 86   :   else 
; 87   :     return feptr(fe_id)->nextfacet[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]

; 88   : }

	pop	ebp
	ret	0
_get_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
EXTRN	_dymem:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_tail_edge PROC				; COMDAT

; 270  : { return eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4+32]
	pop	ebp
	ret	0
_get_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	_get_vertex_fe
; Function compile flags: /Ogtp
;	COMDAT _get_vertex_fe
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_get_vertex_fe PROC					; COMDAT

; 287  : { facet_id fe;

	push	ebp
	mov	ebp, esp

; 288  :   edge_id start_e, xx_id=vptr(v_id)->e_id;

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 289  :   // might be bare edge, so seek along edge loop
; 290  :   if ( !valid_id(xx_id) ) return NULLID;

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN4@get_vertex
	xor	eax, eax

; 299  : }

	pop	ebp
	ret	0
$LN4@get_vertex:
	push	esi

; 291  :   fe = eptr(xx_id)->fe_id;

	mov	esi, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	edx, DWORD PTR [ecx+28]
	push	edi

; 292  :   start_e = xx_id;
; 293  :   while ( !valid_id(fe) )

	test	edx, 268435456				; 10000000H
	jne	SHORT $LN2@get_vertex
	mov	edi, eax
	or	edi, 134217728				; 08000000H
	npad	8
$LL3@get_vertex:

; 294  :   { xx_id = get_next_tail_edge(xx_id);

	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	eax, DWORD PTR [ecx+eax*4+32]

; 295  :     if ( equal_element(xx_id,start_e) ) return NULLID;

	mov	edx, eax
	or	edx, 134217728				; 08000000H
	cmp	edx, edi
	je	SHORT $LN10@get_vertex

; 296  :     fe = eptr(xx_id)->fe_id;

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	edx, DWORD PTR [ecx+28]
	test	edx, 268435456				; 10000000H
	je	SHORT $LL3@get_vertex
$LN2@get_vertex:

; 297  :   }
; 298  :   return  same_sign(fe,xx_id);

	and	eax, 134217728				; 08000000H
	pop	edi
	xor	eax, edx
	pop	esi

; 299  : }

	pop	ebp
	ret	0
$LN10@get_vertex:
	pop	edi

; 295  :     if ( equal_element(xx_id,start_e) ) return NULLID;

	xor	eax, eax
	pop	esi

; 299  : }

	pop	ebp
	ret	0
_get_vertex_fe ENDP
_TEXT	ENDS
PUBLIC	__real@4008000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	_f_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_facet_average
EXTRN	_V_BOUNDARY_ATTR:DWORD
EXTRN	_E_BOUNDARY_ATTR:DWORD
EXTRN	_nullcon:QWORD
EXTRN	_recalc_facet_area:PROC
EXTRN	_cross_prod:PROC
EXTRN	_get_edge_side:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	@__security_check_cookie@4:PROC
_BSS	SEGMENT
_average DD	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\veravg.c
CONST	ENDS
;	COMDAT _facet_average
_TEXT	SEGMENT
_area$ = -404						; size = 8
_x$ = -396						; size = 12
_vconmap$89335 = -384					; size = 4
_tailv$89320 = -380					; size = 4
_ii$ = -376						; size = 4
_attr$89328 = -372					; size = 8
tv2008 = -368						; size = 4
tv1893 = -368						; size = 4
tv1778 = -368						; size = 4
$T90204 = -368						; size = 4
tv1107 = -364						; size = 4
_f_id$GSCopy$ = -364					; size = 4
tv1110 = -360						; size = 4
tv1089 = -360						; size = 4
_sign$ = -360						; size = 4
_k$ = -356						; size = 4
tv1187 = -352						; size = 4
tv1648 = -348						; size = 4
_fe_id$ = -348						; size = 4
_j$ = -344						; size = 4
_i$ = -344						; size = 4
_side$ = -340						; size = 288
_normal$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_f_id$ = 8						; size = 4
_mode$ = 12						; size = 4
_facet_average PROC					; COMDAT

; 225  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 404				; 00000194H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, DWORD PTR _f_id$[ebp]

; 226  :   int i,j,k,ii;
; 227  :   REAL side[FACET_EDGES][2][MAXCOORD];
; 228  :   REAL normal[MAXCOORD];
; 229  :   REAL area;
; 230  :   facetedge_id fe_id;
; 231  :   int sign;
; 232  :   REAL *x[3];
; 233  : 
; 234  :   /* get side vectors */
; 235  :   fe_id = get_facet_fe(f_id);

	mov	eax, ecx
	push	ebx
	shr	eax, 28					; 0000001cH
	push	esi
	and	eax, 1
	push	edi
	mov	DWORD PTR _f_id$GSCopy$[ebp], ecx
	mov	DWORD PTR tv1089[ebp], eax
	jne	SHORT $LN80@facet_aver
	xor	edi, edi
	jmp	SHORT $LN79@facet_aver
$LN80@facet_aver:
	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN79@facet_aver
	xor	edi, 134217728				; 08000000H
$LN79@facet_aver:

; 236  :   for ( i = 0 ; i < FACET_EDGES ; i++ )

	mov	edx, DWORD PTR _web+460
	lea	ecx, DWORD PTR _side$[ebp+48]
	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR tv1648[ebp], ecx
$LL64@facet_aver:

; 237  :   { 
; 238  :     get_fe_side(fe_id,side[i][0]);

	mov	eax, DWORD PTR tv1648[ebp]
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+edx]
	mov	edx, DWORD PTR [ecx+20]
	mov	ebx, edi
	add	eax, -48				; ffffffd0H
	and	ebx, 134217728				; 08000000H
	push	eax
	xor	edx, ebx
	push	edx
	call	_get_edge_side

; 239  :     get_fe_side(inverse_id(fe_id),side[i][1]); /* in case of wraps */

	mov	ecx, DWORD PTR tv1648[ebp]
	mov	eax, edi
	xor	eax, 134217728				; 08000000H
	mov	edx, eax
	push	ecx
	mov	ecx, DWORD PTR _web+460
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	push	eax
	call	_get_edge_side

; 240  :     x[i] = get_coord(get_fe_tailv(fe_id));

	mov	edx, DWORD PTR _web+460
	mov	esi, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR _web+124
	xor	eax, ebx
	mov	ebx, DWORD PTR _web+216
	add	esp, 16					; 00000010H
	test	eax, 134217728				; 08000000H
	je	SHORT $LN90@facet_aver
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [ebx+ecx+304]
	mov	ebx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ebx*4]
	jmp	SHORT $LN89@facet_aver
$LN90@facet_aver:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ebx+ecx+304]
	mov	eax, DWORD PTR [eax+ebx]
$LN89@facet_aver:
	mov	ebx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	ebx, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _x$[ebp+eax*4], ebx

; 241  :     fe_id = get_next_edge(fe_id);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN94@facet_aver
	mov	edi, DWORD PTR [esi+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN63@facet_aver
$LN94@facet_aver:
	mov	edi, DWORD PTR [esi+32]
$LN63@facet_aver:

; 236  :   for ( i = 0 ; i < FACET_EDGES ; i++ )

	add	DWORD PTR tv1648[ebp], 96		; 00000060H
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, 3
	jl	$LL64@facet_aver

; 242  :   }
; 243  :      
; 244  :   /* calculate normal */ 
; 245  :   cross_prod(side[0][0],side[1][0],normal);

	lea	ecx, DWORD PTR _normal$[ebp]
	push	ecx
	lea	edx, DWORD PTR _side$[ebp+96]
	push	edx
	lea	eax, DWORD PTR _side$[ebp]
	push	eax
	call	_cross_prod

; 246  :   for ( i = 3 ; i < SDIM ; i++ ) normal[i] = 0.0 ; /* kludge */

	mov	eax, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	cmp	eax, 3
	jle	SHORT $LN61@facet_aver

; 242  :   }
; 243  :      
; 244  :   /* calculate normal */ 
; 245  :   cross_prod(side[0][0],side[1][0],normal);

	lea	ecx, DWORD PTR [eax-3]
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	lea	edi, DWORD PTR _normal$[ebp+24]
	rep stosd
$LN61@facet_aver:

; 247  :      
; 248  :   area = get_facet_area(f_id);  /* in case of metric or wraps */

	mov	esi, DWORD PTR _f_id$GSCopy$[ebp]
	push	esi
	call	_recalc_facet_area
	mov	edx, DWORD PTR _web+236
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	fld	QWORD PTR [eax+40]
	add	esp, 4

; 249  : 
; 250  :   k = -1;
; 251  :   fe_id = get_facet_fe(f_id);

	cmp	DWORD PTR tv1089[ebp], 0
	fstp	QWORD PTR _area$[ebp]
	mov	DWORD PTR _k$[ebp], -1
	jne	SHORT $LN98@facet_aver
	xor	eax, eax
	jmp	SHORT $LN97@facet_aver
$LN98@facet_aver:
	mov	eax, DWORD PTR [eax+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN97@facet_aver
	xor	eax, 134217728				; 08000000H
$LN97@facet_aver:

; 252  :   for ( ii = 0 ; ii < FACET_EDGES ; ii++, fe_id = get_next_edge(fe_id) )

	fld1
	mov	edi, DWORD PTR _web+460
	fld	QWORD PTR __real@4000000000000000
	mov	DWORD PTR _fe_id$[ebp], eax
	mov	DWORD PTR _ii$[ebp], 0
	jmp	SHORT $LN327@facet_aver
$LN178@facet_aver:
	mov	eax, DWORD PTR _fe_id$[ebp]
$LN327@facet_aver:
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216

; 253  :     { edge_id e_id = get_fe_edge(fe_id);
; 254  :       vertex_id headv = get_fe_headv(fe_id);

	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	edx, DWORD PTR _web+124
	mov	ebx, eax
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	esi, eax
	mov	eax, DWORD PTR [ebx+edi]
	mov	eax, DWORD PTR [eax+20]
	and	esi, 134217728				; 08000000H
	xor	eax, esi
	mov	DWORD PTR tv1107[ebp], ebx
	mov	DWORD PTR tv1187[ebp], eax
	test	eax, 134217728				; 08000000H
	je	SHORT $LN110@facet_aver
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+eax]
	jmp	SHORT $LN109@facet_aver
$LN110@facet_aver:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [eax+ecx]
$LN109@facet_aver:

; 255  :       vertex_id tailv = get_fe_tailv(fe_id);

	mov	eax, DWORD PTR [ebx+edi]
	mov	DWORD PTR tv1110[ebp], eax
	mov	eax, DWORD PTR [eax+20]
	xor	eax, esi
	mov	esi, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN116@facet_aver
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+636
	lea	eax, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN328@facet_aver
$LN116@facet_aver:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN328@facet_aver:

; 256  :       struct averages *head,*tail;
; 257  : 
; 258  :       k++; /* instead of maybe being skipped by continue at end of loop */

	inc	DWORD PTR _k$[ebp]
	mov	DWORD PTR _tailv$89320[ebp], eax

; 259  :       head = average + loc_ordinal(headv);

	test	edx, 268435456				; 10000000H
	je	SHORT $LN67@facet_aver
	and	edx, 134217727				; 07ffffffH
	jmp	SHORT $LN68@facet_aver
$LN67@facet_aver:
	or	edx, -1
$LN68@facet_aver:
	mov	esi, DWORD PTR _average
	mov	ecx, edx
	shl	ecx, 4
	sub	ecx, edx
	lea	ecx, DWORD PTR [esi+ecx*8]

; 260  :       tail = average + loc_ordinal(tailv);

	test	eax, 268435456				; 10000000H
	je	SHORT $LN69@facet_aver
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN70@facet_aver
$LN69@facet_aver:
	or	eax, -1
$LN70@facet_aver:
	mov	edx, eax
	shl	edx, 4
	sub	edx, eax

; 261  : 
; 262  :       if ( mode != RAWEST )

	cmp	DWORD PTR _mode$[ebp], 2
	lea	esi, DWORD PTR [esi+edx*8]
	je	$LN180@facet_aver

; 263  :       { /* check constraint compatibility */
; 264  :          ATTR attr = get_vattr(tailv);

	mov	eax, DWORD PTR _tailv$89320[ebp]
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+8]
	mov	DWORD PTR _attr$89328[ebp+4], eax

; 265  :          int found,kk,bad;
; 266  : 
; 267  :          if ( (attr & CONSTRAINT) )

	mov	eax, edx
	and	eax, 1024				; 00000400H
	xor	ebx, ebx
	or	eax, ebx
	je	$LN54@facet_aver

; 268  :           { conmap_t * vconmap = get_v_constraint_map(tailv);

	mov	eax, DWORD PTR _web+104
	mov	ebx, DWORD PTR _dymem
	cmp	DWORD PTR [eax+ebx+1288], 0
	je	SHORT $LN71@facet_aver
	mov	edx, DWORD PTR [eax+ebx+1264]
	add	edx, edi
	jmp	SHORT $LN329@facet_aver
$LN71@facet_aver:
	mov	edx, OFFSET _nullcon
$LN329@facet_aver:

; 269  :              conmap_t * econmap = get_e_constraint_map(e_id);

	mov	eax, DWORD PTR _web+216
	cmp	DWORD PTR [eax+ebx+1048], 0
	mov	DWORD PTR _vconmap$89335[ebp], edx
	je	SHORT $LN73@facet_aver
	mov	eax, DWORD PTR tv1187[ebp]
	mov	edi, DWORD PTR _web+124
	mov	ebx, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+eax*4]
	mov	eax, DWORD PTR _web+216
	add	edi, DWORD PTR [eax+ebx+1024]
	jmp	SHORT $LN330@facet_aver
$LN73@facet_aver:
	mov	edi, OFFSET _nullcon
$LN330@facet_aver:
	mov	eax, DWORD PTR [edx]
	mov	ebx, DWORD PTR tv1187[ebp]

; 270  : 
; 271  :              bad = 0;
; 272  :              for ( j = 1 ; j <= (int)vconmap[0] ; j++ )

	mov	DWORD PTR _j$[ebp], 1
	mov	DWORD PTR $T90204[ebp], eax
	cmp	eax, 1
	jl	$LN42@facet_aver
$LN53@facet_aver:

; 273  :              { for ( kk = 1, found = 0 ; kk <= (int)econmap[0] ; kk++ )

	mov	eax, 1
	cmp	DWORD PTR [edi], eax
	jl	SHORT $LN177@facet_aver
	mov	ebx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]
	and	edx, 2147483647				; 7fffffffH
$LN50@facet_aver:

; 274  :                   if ( econmap[kk] == (vconmap[j] & ~CON_HIT_BIT) )

	cmp	DWORD PTR [edi+eax*4], edx
	je	SHORT $LN147@facet_aver

; 273  :              { for ( kk = 1, found = 0 ; kk <= (int)econmap[0] ; kk++ )

	inc	eax
	cmp	eax, DWORD PTR [edi]
	jle	SHORT $LN50@facet_aver
$LN177@facet_aver:

; 376  :              }
; 377  :             tail->status++;

	mov	edi, DWORD PTR _web+460
$LN57@facet_aver:

; 252  :   for ( ii = 0 ; ii < FACET_EDGES ; ii++, fe_id = get_next_edge(fe_id) )

	inc	DWORD PTR _ii$[ebp]
	test	DWORD PTR _fe_id$[ebp], 134217728	; 08000000H
	je	$LN102@facet_aver
	mov	ecx, DWORD PTR tv1107[ebp]
	mov	edx, DWORD PTR [ecx+edi]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _fe_id$[ebp], eax
	jmp	$LN146@facet_aver
$LN147@facet_aver:

; 270  : 
; 271  :              bad = 0;
; 272  :              for ( j = 1 ; j <= (int)vconmap[0] ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR $T90204[ebp]
	jg	$LN176@facet_aver
	mov	edx, DWORD PTR _vconmap$89335[ebp]
	jmp	SHORT $LN53@facet_aver
$LN54@facet_aver:

; 275  :                   { found = 1; break; }
; 276  :                 if ( !found ) {bad = 1; break;}
; 277  :              }
; 278  :              if ( bad ) continue; /* with next edge */
; 279  :           }
; 280  :          else if ( attr & BOUNDARY )

	and	edx, 128				; 00000080H
	xor	eax, eax
	or	edx, eax
	je	$LN176@facet_aver

; 281  :          { 
; 282  :             if ( get_edge_boundary(e_id) != get_boundary(tailv) ) continue;

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN75@facet_aver
	mov	edx, DWORD PTR tv1187[ebp]
	mov	ebx, DWORD PTR _web+124
	shl	eax, 4
	sub	eax, DWORD PTR _E_BOUNDARY_ATTR
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _dymem
	shl	eax, 4
	add	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	eax, DWORD PTR [edx+eax]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN76@facet_aver
$LN75@facet_aver:
	xor	eax, eax
$LN76@facet_aver:
	mov	edx, DWORD PTR _V_BOUNDARY_ATTR
	test	edx, edx
	je	SHORT $LN77@facet_aver
	mov	ebx, DWORD PTR _dymem
	shl	edx, 4
	sub	edx, DWORD PTR _V_BOUNDARY_ATTR
	shl	edx, 4
	add	edx, DWORD PTR _web+104
	mov	edx, DWORD PTR [edx+ebx+64]
	mov	edx, DWORD PTR [edx+edi]
	imul	edx, 136				; 00000088H
	add	edx, DWORD PTR _web+776
	jmp	SHORT $LN78@facet_aver
$LN77@facet_aver:
	xor	edx, edx
$LN78@facet_aver:
	cmp	eax, edx
	jne	$LN177@facet_aver
$LN176@facet_aver:
	mov	ebx, DWORD PTR tv1187[ebp]
$LN42@facet_aver:

; 283  :          } 
; 284  :       }
; 285  :       if ( mode != RAWEST )
; 286  :          if ( !equal_id(get_prev_facet(fe_id),get_next_facet(fe_id)) )

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	edx, DWORD PTR tv1110[ebp]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	je	SHORT $LN120@facet_aver
	mov	edi, DWORD PTR [edx+40]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN119@facet_aver
$LN120@facet_aver:
	mov	edi, DWORD PTR [edx+36]
$LN119@facet_aver:
	test	eax, eax
	je	SHORT $LN124@facet_aver
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN123@facet_aver
$LN124@facet_aver:
	mov	eax, DWORD PTR [edx+40]
$LN123@facet_aver:
	cmp	edi, eax
	je	$LN173@facet_aver

; 287  :           { /* triple edge, just move by edge */
; 288  :              if ( head->status < 0 ) {}

	xor	edx, edx
	cmp	DWORD PTR [ecx+104], edx
	jl	$LN179@facet_aver

; 289  :              else if ( head->triples == 0 )

	mov	eax, DWORD PTR [ecx+108]
	cmp	eax, edx
	jne	$LN37@facet_aver

; 290  :              { /* first detection */
; 291  :                 for ( i = 0 ; i < SDIM ; i++ ) 

	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN167@facet_aver
	mov	eax, DWORD PTR _k$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	shl	edx, 5
	lea	edx, DWORD PTR _side$[ebp+edx]
	mov	DWORD PTR tv1778[ebp], edx
	inc	eax
	cdq
	mov	ebx, 3
	idiv	ebx
	mov	eax, DWORD PTR tv1778[ebp]
	mov	ebx, DWORD PTR _i$[ebp]
	mov	edi, ecx
	mov	edx, DWORD PTR _x$[ebp+edx*4]
	sub	edx, ecx
$LN36@facet_aver:

; 292  :                   { head->x[i] = x[(k+1)%3][i] - side[k][0][i]; 

	fld	QWORD PTR [edx+edi]
	inc	ebx
	fsub	QWORD PTR [eax]
	add	edi, 8
	add	eax, 8
	fstp	QWORD PTR [edi-8]

; 293  :                      head->normal[i] = -side[k][0][i]; 

	fld	QWORD PTR [eax-8]
	fchs
	fstp	QWORD PTR [edi+40]
	cmp	ebx, DWORD PTR _web+616
	jl	SHORT $LN36@facet_aver

; 290  :              { /* first detection */
; 291  :                 for ( i = 0 ; i < SDIM ; i++ ) 

	mov	ebx, DWORD PTR tv1187[ebp]
$LN167@facet_aver:

; 294  :                   }
; 295  :                 head->status = 1;

	mov	eax, 1

; 296  :                 head->area = 1.0;

	fxch	ST(1)

; 297  :                 head->triples++;

	add	DWORD PTR [ecx+108], eax
	fst	QWORD PTR [ecx+96]
	mov	DWORD PTR [ecx+104], eax

; 298  :                 head->trip_e[0] = e_id;

	mov	DWORD PTR [ecx+112], ebx
	jmp	$LN333@facet_aver
$LN37@facet_aver:

; 299  :              }
; 300  :              else if ( head->triples == 1 )

	cmp	eax, 1
	jne	$LN32@facet_aver

; 301  :              { /* second detection */
; 302  :                 if ( !equal_element(e_id,head->trip_e[0]) )

	mov	eax, DWORD PTR [ecx+112]
	mov	edi, ebx
	or	eax, 134217728				; 08000000H
	or	edi, 134217728				; 08000000H
	cmp	edi, eax
	je	$LN179@facet_aver

; 303  :                 { for ( i = 0 ; i < SDIM ; i++ ) 

	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN168@facet_aver
	mov	eax, DWORD PTR _k$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	shl	edx, 5
	lea	edx, DWORD PTR _side$[ebp+edx]
	mov	DWORD PTR tv1893[ebp], edx
	inc	eax
	cdq
	mov	ebx, 3
	idiv	ebx
	mov	ebx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR tv1893[ebp]
	mov	edi, ecx
	mov	edx, DWORD PTR _x$[ebp+edx*4]
	sub	edx, ecx
$LN30@facet_aver:

; 304  :                   { head->x[i] += x[(k+1)%3][i] - side[k][0][i]; 

	fld	QWORD PTR [edi+edx]
	inc	ebx
	fsub	QWORD PTR [eax]
	add	edi, 8
	add	eax, 8
	fadd	QWORD PTR [edi-8]
	fstp	QWORD PTR [edi-8]

; 305  :                      head->normal[i] += side[k][0][i]; 

	fld	QWORD PTR [eax-8]
	fadd	QWORD PTR [edi+40]
	fstp	QWORD PTR [edi+40]
	cmp	ebx, DWORD PTR _web+616
	jl	SHORT $LN30@facet_aver

; 303  :                 { for ( i = 0 ; i < SDIM ; i++ ) 

	mov	ebx, DWORD PTR tv1187[ebp]
$LN168@facet_aver:

; 306  :                   }
; 307  :                   head->status = 2;
; 308  :                   head->area = 2.0;
; 309  :                   head->triples++;

	inc	DWORD PTR [ecx+108]
	fst	QWORD PTR [ecx+96]
	mov	DWORD PTR [ecx+104], 2

; 310  :                   head->trip_e[1] = e_id;

	mov	DWORD PTR [ecx+116], ebx

; 311  :                 }
; 312  :              }
; 313  :              else

	jmp	SHORT $LN179@facet_aver
$LN32@facet_aver:

; 314  :                 if ( !equal_element(e_id,head->trip_e[0]) &&
; 315  :                       !equal_element(e_id,head->trip_e[1]) )

	mov	edx, DWORD PTR [ecx+112]
	mov	eax, ebx
	or	eax, 134217728				; 08000000H
	or	edx, 134217728				; 08000000H
	cmp	eax, edx
	je	SHORT $LN179@facet_aver
	mov	edx, DWORD PTR [ecx+116]
	or	edx, 134217728				; 08000000H
	cmp	eax, edx
	je	SHORT $LN179@facet_aver

; 316  :                 { head->status = -10; /* don't move */

	mov	DWORD PTR [ecx+104], -10		; fffffff6H

; 317  :                   head->triples = 3;

	mov	DWORD PTR [ecx+108], 3
$LN179@facet_aver:

; 314  :                 if ( !equal_element(e_id,head->trip_e[0]) &&
; 315  :                       !equal_element(e_id,head->trip_e[1]) )

	fxch	ST(1)
$LN333@facet_aver:

; 318  :                 }
; 319  : 
; 320  :              if ( tail->status < 0 ) {}

	cmp	DWORD PTR [esi+104], 0
	mov	edi, DWORD PTR _web+460
	jl	$LN285@facet_aver

; 321  :              else if ( tail->triples == 0 )

	mov	eax, DWORD PTR [esi+108]
	test	eax, eax
	jne	SHORT $LN23@facet_aver

; 322  :              { /* first detection */
; 323  :                 for ( i = 0 ; i < SDIM ; i++ ) 

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN20@facet_aver
	mov	edi, DWORD PTR _k$[ebp]
	lea	ecx, DWORD PTR [edi+edi*2]
	mov	edi, DWORD PTR _x$[ebp+edi*4]
	shl	ecx, 5
	mov	eax, esi
	lea	ecx, DWORD PTR _side$[ebp+ecx]
	sub	edi, esi
$LN22@facet_aver:

; 324  :                 { tail->x[i] = x[k][i] + side[k][0][i]; 

	fld	QWORD PTR [edi+eax]
	inc	edx
	fadd	QWORD PTR [ecx]
	add	eax, 8
	add	ecx, 8
	fstp	QWORD PTR [eax-8]

; 325  :                   tail->normal[i] = side[k][0][i]; 

	fld	QWORD PTR [ecx-8]
	fstp	QWORD PTR [eax+40]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LN22@facet_aver
$LN20@facet_aver:

; 326  :                 }
; 327  :                 tail->status = 1;

	mov	eax, 1

; 328  :                 tail->area = 1.0;

	fst	QWORD PTR [esi+96]

; 329  :                 tail->triples++;

	add	DWORD PTR [esi+108], eax
	mov	DWORD PTR [esi+104], eax

; 330  :                 tail->trip_e[0] = e_id;

	mov	DWORD PTR [esi+112], ebx
	jmp	$LN332@facet_aver
$LN23@facet_aver:

; 331  :              }
; 332  :              else if ( tail->triples == 1 )

	cmp	eax, 1
	jne	SHORT $LN18@facet_aver

; 333  :              { /* second detection */
; 334  :                 if ( !equal_element(e_id,tail->trip_e[0]) )

	mov	eax, DWORD PTR [esi+112]
	mov	ecx, ebx
	or	eax, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	ecx, eax
	je	$LN285@facet_aver

; 335  :                 { for ( i = 0 ; i < SDIM ; i++ ) 

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN14@facet_aver
	mov	edi, DWORD PTR _k$[ebp]
	lea	ecx, DWORD PTR [edi+edi*2]
	mov	edi, DWORD PTR _x$[ebp+edi*4]
	shl	ecx, 5
	mov	eax, esi
	lea	ecx, DWORD PTR _side$[ebp+ecx]
	sub	edi, esi
$LN16@facet_aver:

; 336  :                   { tail->x[i] += x[k][i] + side[k][0][i]; 

	fld	QWORD PTR [edi+eax]
	inc	edx
	fadd	QWORD PTR [ecx]
	add	eax, 8
	add	ecx, 8
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]

; 337  :                     tail->normal[i] -= side[k][0][i]; 

	fld	QWORD PTR [eax+40]
	fsub	QWORD PTR [ecx-8]
	fstp	QWORD PTR [eax+40]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LN16@facet_aver
$LN14@facet_aver:

; 338  :                   }
; 339  :                   tail->status = 2;
; 340  :                   tail->area = 2.0;
; 341  :                   tail->triples++;

	inc	DWORD PTR [esi+108]
	fxch	ST(1)
	fst	QWORD PTR [esi+96]
	mov	DWORD PTR [esi+104], 2

; 342  :                   tail->trip_e[1] = e_id;

	mov	DWORD PTR [esi+116], ebx
$LN173@facet_aver:

; 343  :                 }
; 344  :              }
; 345  :              else

	mov	edi, DWORD PTR _web+460
	jmp	SHORT $LN180@facet_aver
$LN18@facet_aver:

; 346  :                 if ( !equal_element(e_id,tail->trip_e[0]) &&
; 347  :                       !equal_element(e_id,tail->trip_e[1]) )

	mov	edx, DWORD PTR [esi+112]
	mov	eax, ebx
	or	eax, 134217728				; 08000000H
	or	edx, 134217728				; 08000000H
	cmp	eax, edx
	je	SHORT $LN285@facet_aver
	mov	ecx, DWORD PTR [esi+116]
	or	ecx, 134217728				; 08000000H
	cmp	eax, ecx
	je	SHORT $LN285@facet_aver

; 348  :                 { tail->status = -10; /* don't move */

	mov	DWORD PTR [esi+104], -10		; fffffff6H

; 349  :                   tail->triples = 3;

	mov	DWORD PTR [esi+108], 3
$LN332@facet_aver:

; 330  :                 tail->trip_e[0] = e_id;

	mov	edi, DWORD PTR _web+460
$LN285@facet_aver:

; 346  :                 if ( !equal_element(e_id,tail->trip_e[0]) &&
; 347  :                       !equal_element(e_id,tail->trip_e[1]) )

	fxch	ST(1)
$LN180@facet_aver:

; 350  :                 }
; 351  :           }
; 352  :       if ( tail->triples > 0 ) continue;

	cmp	DWORD PTR [esi+108], 0
	jg	$LN57@facet_aver

; 353  : 
; 354  :       if ( (tail->status >= 0) || (mode == RAWEST) )

	cmp	DWORD PTR [esi+104], 0
	fstp	ST(1)
	fstp	ST(0)
	jge	SHORT $LN9@facet_aver
	cmp	DWORD PTR _mode$[ebp], 2
	jne	$afterlost$89415
$LN9@facet_aver:

; 355  :          {
; 356  :             /* make sure signs consistent around vertex */
; 357  :             facetedge_id vfe = get_vertex_fe(tailv);  /* reference orientation */

	mov	edx, DWORD PTR _tailv$89320[ebp]
	push	edx
	call	_get_vertex_fe

; 358  :             facetedge_id thisfe = fe_id;

	mov	edx, DWORD PTR _fe_id$[ebp]
	add	esp, 4
	mov	ecx, edx

; 359  : 
; 360  :             for(;;) 
; 361  :              { if ( equal_id(vfe,thisfe) ) { sign = 1; break; }

	cmp	eax, edx
	je	SHORT $LN149@facet_aver
$LL8@facet_aver:

; 362  :                 thisfe = get_next_facet(thisfe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN128@facet_aver
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN127@facet_aver
$LN128@facet_aver:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+40]
$LN127@facet_aver:

; 363  :                 if ( equal_id(vfe,thisfe) ) { sign = -1; break; }

	cmp	eax, ecx
	je	SHORT $LN150@facet_aver

; 364  :                 thisfe = inverse_id(get_prev_edge(thisfe));

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN132@facet_aver
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+32]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN131@facet_aver
$LN132@facet_aver:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+28]
$LN131@facet_aver:
	xor	ecx, 134217728				; 08000000H

; 365  :                 if ( equal_id(fe_id,thisfe) )

	cmp	edx, ecx
	je	$afterlost$89415

; 359  : 
; 360  :             for(;;) 
; 361  :              { if ( equal_id(vfe,thisfe) ) { sign = 1; break; }

	cmp	eax, ecx
	jne	SHORT $LL8@facet_aver
$LN149@facet_aver:
	mov	DWORD PTR _sign$[ebp], 1
	jmp	SHORT $LN7@facet_aver
$LN150@facet_aver:

; 363  :                 if ( equal_id(vfe,thisfe) ) { sign = -1; break; }

	mov	DWORD PTR _sign$[ebp], -1
$LN7@facet_aver:

; 366  :                   { sign = 0; 
; 367  :                      goto afterlost; /* lost */ 
; 368  :                   } 
; 369  :              } 
; 370  :                 
; 371  :             tail->area += area;

	fld	QWORD PTR [esi+96]

; 372  :             for ( i = 0 ; i < SDIM ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	fld	QWORD PTR _area$[ebp]
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [esi+96]
	cmp	DWORD PTR _web+616, 0
	jle	$LN322@facet_aver
	mov	eax, DWORD PTR _k$[ebp]
	fild	DWORD PTR _sign$[ebp]
	lea	edi, DWORD PTR [eax+eax*2]
	fld	QWORD PTR __real@4008000000000000
	add	eax, 2
	cdq
	mov	ebx, 3
	idiv	ebx
	mov	eax, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _x$[ebp+eax*4]
	lea	ebx, DWORD PTR _normal$[ebp]
	shl	edi, 5
	sub	ebx, eax
	mov	ecx, esi
	lea	edi, DWORD PTR _side$[ebp+edi]
	lea	edx, DWORD PTR [edx+edx*2]
	shl	edx, 5
	sub	eax, esi
	lea	edx, DWORD PTR _side$[ebp+edx+48]
	mov	DWORD PTR tv2008[ebp], eax
	jmp	SHORT $LN3@facet_aver
$LN166@facet_aver:
	mov	eax, DWORD PTR tv2008[ebp]
$LN3@facet_aver:

; 373  :              { 
; 374  :                 tail->normal[i] += sign*normal[i];

	add	eax, ecx
	fld	QWORD PTR [eax+ebx]
	add	edx, 8
	fmul	ST(0), ST(2)
	add	edi, 8
	add	ecx, 8
	fadd	QWORD PTR [ecx+40]
	fstp	QWORD PTR [ecx+40]

; 375  :                 tail->x[i] += (x[k][i]+(side[k][0][i]+side[(k+2)%3][1][i])/3)*area;

	fld	QWORD PTR [edi-8]
	fadd	QWORD PTR [edx-8]
	fdiv	ST(0), ST(1)
	fadd	QWORD PTR [eax]
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	fmul	ST(0), ST(3)
	fadd	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN166@facet_aver

; 372  :             for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(1)
	fstp	ST(0)
$LN322@facet_aver:

; 376  :              }
; 377  :             tail->status++;

	inc	DWORD PTR [esi+104]
	fstp	ST(0)
	mov	edi, DWORD PTR _web+460
$afterlost$89415:
	fld1
	fld	QWORD PTR __real@4000000000000000
	jmp	$LN57@facet_aver

; 252  :   for ( ii = 0 ; ii < FACET_EDGES ; ii++, fe_id = get_next_edge(fe_id) )

$LN102@facet_aver:
	mov	eax, DWORD PTR tv1107[ebp]
	mov	ecx, DWORD PTR [eax+edi]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _fe_id$[ebp], edx
$LN146@facet_aver:
	cmp	DWORD PTR _ii$[ebp], 3
	jl	$LN178@facet_aver

; 378  :          }
; 379  : 
; 380  : afterlost: ;
; 381  :     } 
; 382  : } // end facet_average()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(1)
	pop	edi
	fstp	ST(0)
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_facet_average ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_edge_average
; Function compile flags: /Ogtp
;	COMDAT _edge_average
_TEXT	SEGMENT
_head$ = -76						; size = 4
tv260 = -72						; size = 8
tv93 = -72						; size = 8
_attr$ = -72						; size = 8
tv1047 = -68						; size = 4
$T90450 = -68						; size = 4
tv580 = -64						; size = 4
_vconmap$89518 = -60					; size = 4
_tailv$ = -60						; size = 4
tv1049 = -56						; size = 4
_tail$ = -56						; size = 4
_vconmap$89458 = -56					; size = 4
_side$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_mode$ = 12						; size = 4
_edge_average PROC					; COMDAT

; 396  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, DWORD PTR _e_id$[ebp]
	push	ebx

; 397  :   int i,j,k;
; 398  :   struct averages *head,*tail;
; 399  :   vertex_id headv = get_edge_headv(e_id);

	mov	ebx, DWORD PTR _dymem
	mov	edx, ecx
	push	esi
	mov	esi, DWORD PTR _web+124
	shr	edx, 27					; 0000001bH
	and	edx, 1
	push	edi
	mov	edi, DWORD PTR _web+636
	mov	eax, ecx
	je	SHORT $LN78@edge_avera
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv580[ebp], eax
	mov	eax, DWORD PTR [eax+esi]
	mov	esi, DWORD PTR _web+216
	mov	esi, DWORD PTR [esi+ebx+304]
	add	eax, esi
	mov	esi, DWORD PTR [eax]
	jmp	SHORT $LN77@edge_avera
$LN78@edge_avera:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv580[ebp], eax
	mov	eax, DWORD PTR [eax+esi]
	mov	esi, DWORD PTR _web+216
	mov	esi, DWORD PTR [esi+ebx+304]
	add	eax, esi
	mov	esi, DWORD PTR [eax+edi*4]
$LN77@edge_avera:

; 400  :   vertex_id tailv = get_edge_tailv(e_id);

	test	edx, edx
	je	SHORT $LN82@edge_avera
	mov	edx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR _tailv$[ebp], edx
	jmp	SHORT $LN81@edge_avera
$LN82@edge_avera:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _tailv$[ebp], eax
$LN81@edge_avera:

; 401  :   REAL side[MAXCOORD];
; 402  :   ATTR attr;
; 403  : 
; 404  :   get_edge_side(e_id,side);  /* in case of wraps */

	lea	edx, DWORD PTR _side$[ebp]
	push	edx
	push	ecx
	call	_get_edge_side
	add	esp, 8

; 405  : 
; 406  :   /* head */
; 407  :   head = average + loc_ordinal(headv);

	test	esi, 268435456				; 10000000H
	je	SHORT $LN53@edge_avera
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN54@edge_avera
$LN53@edge_avera:
	or	eax, -1
$LN54@edge_avera:
	mov	edx, DWORD PTR _average
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	lea	eax, DWORD PTR [edx+ecx*8]

; 408  :   attr = get_vattr(headv);

	mov	ecx, DWORD PTR _web+12
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR _head$[ebp], eax

; 409  :   if ( attr & FIXED ) goto dotail;

	mov	eax, ecx
	mov	DWORD PTR _attr$[ebp+4], edx
	and	eax, 64					; 00000040H
	xor	edx, edx
	or	eax, edx
	jne	$LN115@edge_avera

; 410  :   if (  mode != RAWEST )

	cmp	DWORD PTR _mode$[ebp], 2
	je	$LN117@edge_avera

; 411  :   { if ( attr & BOUNDARY )

	mov	ebx, DWORD PTR _dymem
	mov	eax, ecx
	and	eax, 128				; 00000080H
	or	eax, edx
	je	$LN116@edge_avera

; 412  :      { if ( !get_eattr(e_id) & BOUNDARY ) goto dotail;

	mov	eax, DWORD PTR _web+124
	mov	edx, DWORD PTR tv580[ebp]
	mov	edi, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [edi+8]
	or	eax, DWORD PTR [edi+12]
	jne	SHORT $LN55@edge_avera
	mov	eax, 1
	mov	DWORD PTR tv93[ebp+4], 0
	jmp	SHORT $LN56@edge_avera
$LN55@edge_avera:
	xor	eax, eax
	mov	DWORD PTR tv93[ebp+4], eax
$LN56@edge_avera:
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	jne	$dotail$89438

; 413  :         if ( get_boundary(headv) != get_edge_boundary(e_id) )

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN57@edge_avera
	mov	edx, eax
	shl	edx, 4
	sub	edx, eax
	shl	edx, 4
	add	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR [edx+ebx+64]
	mov	edx, DWORD PTR [eax+esi]
	imul	edx, 136				; 00000088H
	add	edx, DWORD PTR _web+776
	jmp	SHORT $LN58@edge_avera
$LN57@edge_avera:
	xor	edx, edx
$LN58@edge_avera:
	cmp	DWORD PTR _E_BOUNDARY_ATTR, 0
	je	SHORT $LN59@edge_avera
	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	mov	ebx, eax
	shl	ebx, 4
	sub	ebx, eax
	shl	ebx, 4
	add	ebx, DWORD PTR _web+216
	mov	eax, ebx
	mov	ebx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	eax, DWORD PTR [eax+edi]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN60@edge_avera
$LN59@edge_avera:
	xor	eax, eax
$LN60@edge_avera:
	cmp	edx, eax
	jne	$dotail$89438
$LN116@edge_avera:

; 414  :           goto dotail;
; 415  :      }
; 416  :      /* check constraint compatibility */
; 417  :      if ( (attr & CONSTRAINT) )

	and	ecx, 1024				; 00000400H
	xor	eax, eax
	or	ecx, eax
	je	$LN117@edge_avera

; 418  :           { conmap_t * vconmap = get_v_constraint_map(headv);

	mov	eax, DWORD PTR _web+104
	cmp	DWORD PTR [eax+ebx+1288], 0
	je	SHORT $LN61@edge_avera
	mov	eax, DWORD PTR [eax+ebx+1264]
	add	eax, esi
	jmp	SHORT $LN123@edge_avera
$LN61@edge_avera:
	mov	eax, OFFSET _nullcon
$LN123@edge_avera:

; 419  :              conmap_t * econmap = get_e_constraint_map(e_id);

	mov	ecx, DWORD PTR _web+216
	cmp	DWORD PTR [ecx+ebx+1048], 0
	mov	DWORD PTR _vconmap$89458[ebp], eax
	je	SHORT $LN63@edge_avera
	mov	edx, DWORD PTR tv580[ebp]
	mov	esi, DWORD PTR _web+124
	mov	edx, DWORD PTR [edx+esi]
	add	edx, DWORD PTR [ecx+ebx+1024]
	jmp	SHORT $LN64@edge_avera
$LN63@edge_avera:
	mov	edx, OFFSET _nullcon
$LN64@edge_avera:
	mov	eax, DWORD PTR [eax]

; 420  :              int found;
; 421  : 
; 422  :              for ( j = 1 ; j <= (int)vconmap[0] ; j++ )

	mov	esi, 1
	mov	DWORD PTR $T90450[ebp], eax
	cmp	eax, esi
	jl	SHORT $LN117@edge_avera
	mov	edi, DWORD PTR [edx]
	npad	8
$LL44@edge_avera:

; 423  :              { for ( k = 1, found = 0 ; k <= (int)econmap[0] ; k++ )

	mov	eax, 1
	cmp	edi, eax
	jl	$dotail$89438
	mov	ecx, DWORD PTR _vconmap$89458[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	and	ecx, 2147483647				; 7fffffffH
	npad	7
$LL41@edge_avera:

; 424  :                   if ( econmap[k] == (vconmap[j] & ~CON_HIT_BIT) )

	cmp	DWORD PTR [edx+eax*4], ecx
	je	SHORT $LN95@edge_avera

; 423  :              { for ( k = 1, found = 0 ; k <= (int)econmap[0] ; k++ )

	inc	eax
	cmp	eax, edi
	jle	SHORT $LL41@edge_avera
	jmp	$dotail$89438
$LN95@edge_avera:

; 420  :              int found;
; 421  : 
; 422  :              for ( j = 1 ; j <= (int)vconmap[0] ; j++ )

	inc	esi
	cmp	esi, DWORD PTR $T90450[ebp]
	jle	SHORT $LL44@edge_avera
$LN117@edge_avera:

; 425  :                   { found = 1; break; }
; 426  :                 if ( !found ) goto dotail;
; 427  :              }
; 428  :           }
; 429  :   }
; 430  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	mov	edi, DWORD PTR _head$[ebp]
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN34@edge_avera
	lea	esi, DWORD PTR _side$[ebp]
	mov	eax, edi
	sub	esi, edi
	npad	5
$LL36@edge_avera:

; 431  :      head->x[i] -= side[i];

	fld	QWORD PTR [eax]
	inc	ecx
	fsub	QWORD PTR [esi+eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+616
	cmp	ecx, edx
	jl	SHORT $LL36@edge_avera
$LN34@edge_avera:

; 432  :     
; 433  :   if ( head->status )
; 434  :      for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	cmp	DWORD PTR [edi+104], eax
	je	SHORT $LN33@edge_avera
	test	edx, edx
	jle	SHORT $LN26@edge_avera
	lea	ecx, DWORD PTR [edi+48]
$LL32@edge_avera:

; 435  :         head->normal[i] += side[i];

	fld	QWORD PTR _side$[ebp+eax*8]
	inc	eax
	fadd	QWORD PTR [ecx]
	add	ecx, 8
	fstp	QWORD PTR [ecx-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL32@edge_avera

; 436  :   else

	jmp	SHORT $LN26@edge_avera
$LN33@edge_avera:

; 437  :      for ( i = 0 ; i < SDIM ; i++ )

	test	edx, edx
	jle	SHORT $LN26@edge_avera
	lea	ecx, DWORD PTR [edi+48]
$LL28@edge_avera:

; 438  :         head->normal[i] -= side[i];

	fld	QWORD PTR [ecx]
	inc	eax
	fsub	QWORD PTR _side$[ebp+eax*8-8]
	add	ecx, 8
	fstp	QWORD PTR [ecx-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL28@edge_avera
$LN26@edge_avera:

; 439  :      
; 440  :   head->status++;  /* mark one more edge done */

	mov	eax, DWORD PTR _head$[ebp]
	inc	DWORD PTR [eax+104]
$LN115@edge_avera:
	mov	ebx, DWORD PTR _dymem
$dotail$89438:

; 441  : 
; 442  : dotail:
; 443  :   tail = average + loc_ordinal(tailv);

	mov	ecx, DWORD PTR _tailv$[ebp]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN65@edge_avera
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN66@edge_avera
$LN65@edge_avera:
	or	eax, -1
$LN66@edge_avera:
	mov	edx, eax
	shl	edx, 4
	sub	edx, eax
	mov	eax, DWORD PTR _average
	lea	edx, DWORD PTR [eax+edx*8]

; 444  : 
; 445  :   attr = get_vattr(tailv);

	mov	eax, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR _tail$[ebp], edx
	mov	edx, DWORD PTR [esi+8]

; 446  :   if ( attr & FIXED ) return;

	mov	eax, edx
	mov	DWORD PTR _attr$[ebp+4], ecx
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN51@edge_avera

; 447  :   if (  mode != RAWEST )

	cmp	DWORD PTR _mode$[ebp], 2
	je	$LN17@edge_avera

; 448  :   { if ( attr & BOUNDARY )

	mov	eax, edx
	and	eax, 128				; 00000080H
	or	eax, ecx
	je	$LN21@edge_avera

; 449  :      { if ( !get_eattr(e_id) & BOUNDARY ) return;

	mov	eax, DWORD PTR tv580[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	edi, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edi+8]
	or	eax, DWORD PTR [edi+12]
	jne	SHORT $LN67@edge_avera
	mov	eax, 1
	mov	DWORD PTR tv260[ebp+4], 0
	jmp	SHORT $LN68@edge_avera
$LN67@edge_avera:
	xor	eax, eax
	mov	DWORD PTR tv260[ebp+4], eax
$LN68@edge_avera:
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN51@edge_avera

; 450  :         if ( get_boundary(tailv) != get_edge_boundary(e_id) )

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN69@edge_avera
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	shl	ecx, 4
	add	ecx, DWORD PTR _web+104
	mov	eax, DWORD PTR [ecx+ebx+64]
	mov	ecx, DWORD PTR [eax+esi]
	imul	ecx, 136				; 00000088H
	add	ecx, DWORD PTR _web+776
	jmp	SHORT $LN70@edge_avera
$LN69@edge_avera:
	xor	ecx, ecx
$LN70@edge_avera:
	cmp	DWORD PTR _E_BOUNDARY_ATTR, 0
	je	SHORT $LN71@edge_avera
	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	mov	ebx, eax
	shl	ebx, 4
	sub	ebx, eax
	shl	ebx, 4
	add	ebx, DWORD PTR _web+216
	mov	eax, ebx
	mov	ebx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	eax, DWORD PTR [eax+edi]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN72@edge_avera
$LN71@edge_avera:
	xor	eax, eax
$LN72@edge_avera:
	cmp	ecx, eax
	jne	$LN51@edge_avera
$LN21@edge_avera:

; 451  :           return;
; 452  :      }
; 453  :      /* check constraint compatibility */
; 454  :      if ( (attr & CONSTRAINT) )

	and	edx, 1024				; 00000400H
	xor	eax, eax
	or	edx, eax
	je	$LN17@edge_avera

; 455  :           { conmap_t * vconmap = get_v_constraint_map(tailv);

	mov	eax, DWORD PTR _web+104
	cmp	DWORD PTR [eax+ebx+1288], 0
	je	SHORT $LN73@edge_avera
	mov	eax, DWORD PTR [eax+ebx+1264]
	add	eax, esi
	jmp	SHORT $LN124@edge_avera
$LN73@edge_avera:
	mov	eax, OFFSET _nullcon
$LN124@edge_avera:

; 456  :              conmap_t * econmap = get_e_constraint_map(e_id);

	mov	ecx, DWORD PTR _web+216
	cmp	DWORD PTR [ecx+ebx+1048], 0
	mov	DWORD PTR _vconmap$89518[ebp], eax
	je	SHORT $LN75@edge_avera
	mov	edx, DWORD PTR _web+124
	mov	esi, DWORD PTR tv580[ebp]
	mov	edx, DWORD PTR [esi+edx]
	add	edx, DWORD PTR [ecx+ebx+1024]
	jmp	SHORT $LN76@edge_avera
$LN75@edge_avera:
	mov	edx, OFFSET _nullcon
$LN76@edge_avera:
	mov	ebx, DWORD PTR [eax]

; 457  :              int found;
; 458  : 
; 459  :              for ( j = 1 ; j <= (int)vconmap[0] ; j++ )

	mov	esi, 1
	cmp	ebx, esi
	jl	SHORT $LN17@edge_avera
	mov	edi, DWORD PTR [edx]
	npad	1
$LL19@edge_avera:

; 460  :              { for ( k = 1, found = 0 ; k <= (int)econmap[0] ; k++ )

	mov	eax, 1
	cmp	edi, eax
	jl	$LN51@edge_avera
	mov	ecx, DWORD PTR _vconmap$89518[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	and	ecx, 2147483647				; 7fffffffH
	npad	7
$LL16@edge_avera:

; 461  :                   if ( econmap[k] == (vconmap[j] & ~CON_HIT_BIT) )

	cmp	DWORD PTR [edx+eax*4], ecx
	je	SHORT $LN97@edge_avera

; 460  :              { for ( k = 1, found = 0 ; k <= (int)econmap[0] ; k++ )

	inc	eax
	cmp	eax, edi
	jle	SHORT $LL16@edge_avera
	pop	edi
	pop	esi
	pop	ebx

; 480  :      
; 481  :   
; 482  : } // end edge_average()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN97@edge_avera:

; 457  :              int found;
; 458  : 
; 459  :              for ( j = 1 ; j <= (int)vconmap[0] ; j++ )

	inc	esi
	cmp	esi, ebx
	jle	SHORT $LL19@edge_avera
$LN17@edge_avera:

; 462  :                   { found = 1; break; }
; 463  :                 if ( !found ) return;
; 464  :              }
; 465  :           }
; 466  :   }
; 467  : 
; 468  : 
; 469  :   for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	mov	edi, DWORD PTR _tail$[ebp]
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN9@edge_avera
	lea	esi, DWORD PTR _side$[ebp]
	mov	eax, edi
	sub	esi, edi
$LL11@edge_avera:

; 470  :      tail->x[i] += side[i];

	fld	QWORD PTR [esi+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	edx, DWORD PTR _web+616
	cmp	ecx, edx
	jl	SHORT $LL11@edge_avera
$LN9@edge_avera:

; 471  :     
; 472  :   if ( tail->status )
; 473  :      for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	cmp	DWORD PTR [edi+104], eax
	je	SHORT $LN8@edge_avera
	test	edx, edx
	jle	SHORT $LN122@edge_avera
	lea	ecx, DWORD PTR [edi+48]
	npad	6
$LL7@edge_avera:

; 474  :         tail->normal[i] -= side[i];

	fld	QWORD PTR [ecx]
	inc	eax
	fsub	QWORD PTR _side$[ebp+eax*8-8]
	add	ecx, 8
	fstp	QWORD PTR [ecx-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL7@edge_avera

; 478  :      
; 479  :   tail->status++;  /* mark one more edge done */

	inc	DWORD PTR [edi+104]
	pop	edi
	pop	esi
	pop	ebx

; 480  :      
; 481  :   
; 482  : } // end edge_average()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@edge_avera:

; 475  :   else
; 476  :      for ( i = 0 ; i < SDIM ; i++ )

	test	edx, edx
	jle	SHORT $LN122@edge_avera
	lea	ecx, DWORD PTR [edi+48]
$LL3@edge_avera:

; 477  :         tail->normal[i] += side[i];

	fld	QWORD PTR _side$[ebp+eax*8]
	inc	eax
	fadd	QWORD PTR [ecx]
	add	ecx, 8
	fstp	QWORD PTR [ecx-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL3@edge_avera
$LN122@edge_avera:

; 478  :      
; 479  :   tail->status++;  /* mark one more edge done */

	inc	DWORD PTR [edi+104]
$LN51@edge_avera:

; 480  :      
; 481  :   
; 482  : } // end edge_average()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_edge_average ENDP
_TEXT	ENDS
PUBLIC	_simplex_facet_average
EXTRN	_v_on_constraint:PROC
; Function compile flags: /Ogtp
;	COMDAT _simplex_facet_average
_TEXT	SEGMENT
_x$89572 = -16						; size = 4
_i$ = -12						; size = 4
_v$ = -8						; size = 4
_j$ = -4						; size = 4
tv489 = 8						; size = 4
_f_id$ = 8						; size = 4
_mode$ = 12						; size = 4
_simplex_facet_average PROC				; COMDAT

; 495  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 496  :   struct averages *head;
; 497  :   vertex_id *v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+328
	push	esi
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]

; 498  :   int i,j,n;
; 499  :   unsigned int k;
; 500  : 
; 501  :   for ( i = 0 ; i <= web.dimension ; i++ )

	mov	eax, DWORD PTR _web+620
	push	edi
	mov	edi, DWORD PTR _dymem
	add	esi, DWORD PTR [edx+edi+304]
	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _v$[ebp], esi
	test	eax, eax
	js	$LN13@simplex_fa

; 496  :   struct averages *head;
; 497  :   vertex_id *v = get_facet_vertices(f_id);

	mov	edx, DWORD PTR _web+104
	push	ebx
	mov	DWORD PTR tv489[ebp], esi
	npad	3
$LL36@simplex_fa:

; 502  :   { REAL *x = get_coord(v[i]);

	mov	ecx, DWORD PTR tv489[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	ebx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	add	ecx, DWORD PTR [edx+edi+64]
	mov	DWORD PTR _x$89572[ebp], ecx

; 503  : 
; 504  :     for ( j = 0 ; j <= web.dimension ; j++ )

	xor	ecx, ecx
	mov	DWORD PTR _j$[ebp], ecx
	test	eax, eax
	js	$LN14@simplex_fa
	npad	8
$LL12@simplex_fa:

; 505  :     { head = average + loc_ordinal(v[j]);

	mov	eax, DWORD PTR [esi+ecx*4]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN18@simplex_fa
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN19@simplex_fa
$LN18@simplex_fa:
	or	ecx, -1
$LN19@simplex_fa:
	mov	esi, ecx
	shl	esi, 4
	sub	esi, ecx

; 506  :       if ( mode != RAWEST )

	cmp	DWORD PTR _mode$[ebp], 2
	mov	ecx, DWORD PTR _average
	lea	ebx, DWORD PTR [ecx+esi*8]
	je	SHORT $LN32@simplex_fa

; 507  :       { conmap_t *conmapj = get_v_constraint_map(v[j]);

	cmp	DWORD PTR [edx+edi+1288], 0
	je	SHORT $LN20@simplex_fa
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+eax*4]
	add	esi, DWORD PTR [edx+edi+1264]
	jmp	SHORT $LN21@simplex_fa
$LN20@simplex_fa:
	mov	esi, OFFSET _nullcon
$LN21@simplex_fa:

; 508  :         for ( k = 1 ; k <= conmapj[0] ; k++ )

	mov	edi, 1
	cmp	edi, DWORD PTR [esi]
	ja	SHORT $LN32@simplex_fa
	npad	4
$LL8@simplex_fa:

; 509  :           if ( !v_on_constraint(v[i],conmapj[k]) ) break;

	mov	edx, DWORD PTR [esi+edi*4]
	mov	eax, DWORD PTR tv489[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	ecx
	call	_v_on_constraint
	add	esp, 8
	test	eax, eax
	je	SHORT $LN31@simplex_fa

; 508  :         for ( k = 1 ; k <= conmapj[0] ; k++ )

	inc	edi
	cmp	edi, DWORD PTR [esi]
	jbe	SHORT $LL8@simplex_fa
$LN31@simplex_fa:
	mov	edx, DWORD PTR _web+104

; 510  :         if ( k <= conmapj[0] ) continue;

	cmp	edi, DWORD PTR [esi]
	jbe	SHORT $LN11@simplex_fa
$LN32@simplex_fa:

; 511  :       }
; 512  :       for ( n = 0 ; n < SDIM ; n++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN1@simplex_fa
	mov	edx, DWORD PTR _x$89572[ebp]
	mov	eax, ebx
	sub	edx, ebx
$LL3@simplex_fa:

; 513  :       head->x[n] += x[n];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL3@simplex_fa
$LN1@simplex_fa:

; 514  :       head->area += 1.0;

	fld	QWORD PTR [ebx+96]

; 515  :       head->status++;

	inc	DWORD PTR [ebx+104]
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR [ebx+96]
	mov	edx, DWORD PTR _web+104
$LN11@simplex_fa:

; 503  : 
; 504  :     for ( j = 0 ; j <= web.dimension ; j++ )

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edi, DWORD PTR _dymem
	mov	esi, DWORD PTR _v$[ebp]
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR _web+620
	jle	$LL12@simplex_fa
	mov	eax, DWORD PTR _web+620
$LN14@simplex_fa:

; 498  :   int i,j,n;
; 499  :   unsigned int k;
; 500  : 
; 501  :   for ( i = 0 ; i <= web.dimension ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	add	DWORD PTR tv489[ebp], 4
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, eax
	jle	$LL36@simplex_fa
	pop	ebx
$LN13@simplex_fa:
	pop	edi
	pop	esi

; 516  :     }
; 517  :   }
; 518  : } // end simplex_facet_average()

	mov	esp, ebp
	pop	ebp
	ret	0
_simplex_facet_average ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	__real@4018000000000000
PUBLIC	??_C@_0EP@OLEJLABA@Internal?5error?3lagrange_vertex_a@ ; `string'
PUBLIC	__real@3fe0000000000000
PUBLIC	??_C@_0EO@KDDFKBPF@Internal?5error?3lagrange_vertex_a@ ; `string'
PUBLIC	_newx$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_lagrange_vertex_average
EXTRN	_lagrange_eval_2d:PROC
EXTRN	_matvec_mul:PROC
EXTRN	_mat_inv:PROC
EXTRN	_tr_mat_mul:PROC
EXTRN	_mat_mult:PROC
EXTRN	_mat2d_setup:PROC
EXTRN	_lagrange_eval_1d:PROC
EXTRN	_dot:PROC
EXTRN	_kb_error:PROC
EXTRN	_gauss_lagrange:BYTE
EXTRN	_memset:PROC
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT ??_C@_0EP@OLEJLABA@Internal?5error?3lagrange_vertex_a@
CONST	SEGMENT
??_C@_0EP@OLEJLABA@Internal?5error?3lagrange_vertex_a@ DB 'Internal error'
	DB	':lagrange_vertex_average() couldn''t find vertex index in fac'
	DB	'et.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT ??_C@_0EO@KDDFKBPF@Internal?5error?3lagrange_vertex_a@
CONST	SEGMENT
??_C@_0EO@KDDFKBPF@Internal?5error?3lagrange_vertex_a@ DB 'Internal error'
	DB	':lagrange_vertex_average() couldn''t find vertex index in edg'
	DB	'e.', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _lagrange_vertex_average
_TEXT	SEGMENT
_xx$89940 = -1352					; size = 924
_aaqXvS$89941 = -428					; size = 8
_rhs$89949 = -420					; size = 16
_du$89948 = -404					; size = 16
_u$89947 = -388						; size = 16
_r$89950 = -372						; size = 4
tv3015 = -368						; size = 4
_p$89946 = -364						; size = 4
_g$89952 = -360						; size = 4
tv3439 = -356						; size = 4
tv3019 = -356						; size = 4
_rhs$89877 = -352					; size = 8
_vv$89872 = -352					; size = 8
_attr$ = -352						; size = 8
_aa$89943 = -348					; size = 4
_knx$89934 = -344					; size = 4
_ctrl$89880 = -344					; size = 4
tv2930 = -340						; size = 4
tv2459 = -340						; size = 4
_v$89866 = -340						; size = 4
tv2209 = -336						; size = 4
tv1903 = -336						; size = 4
_ctrl$89953 = -336					; size = 4
tv1895 = -332						; size = 4
_dxdu$89938 = -332					; size = 4
tv1878 = -328						; size = 4
_inx$89932 = -328					; size = 4
_v$89927 = -324						; size = 4
_knx$89871 = -324					; size = 4
tv3011 = -320						; size = 4
_k$ = -320						; size = 4
_i$ = -320						; size = 4
tv2330 = -316						; size = 4
tv2298 = -316						; size = 4
tv2215 = -316						; size = 4
tv1899 = -316						; size = 4
_jnx$89933 = -316					; size = 4
_newx$GSCopy$ = -312					; size = 4
tv1089 = -308						; size = 4
_j$ = -308						; size = 4
_dxduxJ$89937 = -304					; size = 96
_xx$89882 = -208					; size = 84
_perturb$89945 = -172					; size = 48
_perturb$89873 = -124					; size = 48
_dxduqXvS$89936 = -100					; size = 24
_vv$89935 = -76						; size = 24
_dxdu$89874 = -52					; size = 48
_aaxJ$89942 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_newx$ = 12						; size = 4
_lagrange_vertex_average PROC				; COMDAT

; 797  : { ATTR attr = get_vattr(v_id);

	push	ebp
	mov	ebp, esp
	sub	esp, 1352				; 00000548H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	edx, DWORD PTR _v_id$[ebp]

; 867  : 
; 868  :     /* find which vertex it is in the facet */
; 869  :     for ( jnx = 0, knx = 0 ; jnx <= web.lagrange_order ; jnx++ )

	mov	eax, DWORD PTR _newx$[ebp]
	mov	ecx, DWORD PTR _web+12
	push	ebx
	push	esi
	push	edi
	mov	edi, edx
	and	edi, 134217727				; 07ffffffH
	mov	DWORD PTR _newx$GSCopy$[ebp], eax
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+ecx]
	mov	esi, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _attr$[ebp+4], eax
	mov	eax, esi
	and	eax, 4194304				; 00400000H
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv1089[ebp], edi
	je	$LN54@lagrange_v

; 798  :   int i,j,k;
; 799  :   
; 800  :   if ( attr & Q_MIDEDGE )
; 801  :   { /* average with neighbors on edge */
; 802  :     edge_id e_id = get_vertex_edge(v_id);
; 803  :     vertex_id *v = get_edge_vertices(e_id);

	mov	ecx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR _web+124

; 804  :     int knx; /* index of vertex */
; 805  :     vertex_id vv[2];  /* the two neighbors to average with */
; 806  :     REAL perturb[MAXCOORD];
; 807  :     REAL dxdu[MAXCOORD],u,du,rhs,*x;
; 808  :     struct gauss_lag *g = &gauss_lagrange[1][web.gauss1D_order];

	mov	ebx, DWORD PTR _web+1592
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edi, DWORD PTR [eax+ecx+304]

; 809  :     int ctrl = web.lagrange_order+1;

	mov	eax, DWORD PTR _web+632
	shl	ebx, 5
	add	ebx, DWORD PTR _gauss_lagrange+4

; 810  :     REAL aa;
; 811  :     REAL *xx[MAXLAGRANGE+1];
; 812  : 
; 813  :     /* find which vertex it is in the edge */
; 814  :     for ( knx = 0 ; knx <= web.lagrange_order ; knx++ )

	xor	esi, esi
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _v$89866[ebp], edi
	mov	DWORD PTR _ctrl$89880[ebp], ecx
	mov	DWORD PTR _knx$89871[ebp], esi
	test	eax, eax
	js	SHORT $LN51@lagrange_v
	npad	1
$LL53@lagrange_v:

; 815  :       if ( equal_id(v_id,v[knx]) )

	cmp	edx, DWORD PTR [edi+esi*4]
	je	SHORT $LN100@lagrange_v

; 810  :     REAL aa;
; 811  :     REAL *xx[MAXLAGRANGE+1];
; 812  : 
; 813  :     /* find which vertex it is in the edge */
; 814  :     for ( knx = 0 ; knx <= web.lagrange_order ; knx++ )

	inc	esi
	cmp	esi, eax
	jle	SHORT $LL53@lagrange_v
	mov	DWORD PTR _knx$89871[ebp], esi
$LN51@lagrange_v:

; 816  :         goto edge_found_knx;
; 817  :     kb_error(3789,"Internal error:lagrange_vertex_average() couldn't find vertex index in edge.\n",
; 818  :       RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EO@KDDFKBPF@Internal?5error?3lagrange_vertex_a@
	push	3789					; 00000ecdH
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $edge_found_knx$89887
$LN100@lagrange_v:

; 810  :     REAL aa;
; 811  :     REAL *xx[MAXLAGRANGE+1];
; 812  : 
; 813  :     /* find which vertex it is in the edge */
; 814  :     for ( knx = 0 ; knx <= web.lagrange_order ; knx++ )

	mov	DWORD PTR _knx$89871[ebp], esi
$edge_found_knx$89887:

; 819  :          
; 820  :  edge_found_knx:
; 821  :     /* the two neighbors */
; 822  :     vv[0] = v[knx-1] ;

	mov	edx, DWORD PTR [edi+esi*4-4]

; 823  :     vv[1] = v[knx+1];
; 824  : 
; 825  :     /* find perturbation in u,v so can calculate new position exactly on 
; 826  :        the surface */
; 827  :     /* first, the xyz perturbation */
; 828  :     memset((char*)newx,0,SDIM*sizeof(REAL));

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [edi+esi*4+4]
	mov	DWORD PTR _vv$89872[ebp], edx
	lea	edx, DWORD PTR [ecx*8]
	push	edx
	mov	DWORD PTR _vv$89872[ebp+4], eax
	mov	eax, DWORD PTR _newx$GSCopy$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 829  :     for ( i = 0 ; i < 2 ; i++ )

	xor	eax, eax
	mov	DWORD PTR _i$[ebp], eax
	npad	9
$LL109@lagrange_v:

; 830  :     { REAL *xx = get_coord(vv[i]);

	mov	ecx, DWORD PTR _vv$89872[ebp+eax*4]
	mov	edx, DWORD PTR _web+12
	mov	edi, DWORD PTR _dymem
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+104
	add	ecx, DWORD PTR [edx+edi+64]

; 831  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _web+616
	xor	edx, edx
	test	edi, edi
	jle	SHORT $LN48@lagrange_v
	mov	eax, DWORD PTR _newx$GSCopy$[ebp]
	sub	ecx, eax
	npad	6
$LL46@lagrange_v:

; 832  :         newx[j] += xx[j];

	fld	QWORD PTR [ecx+eax]
	inc	edx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL46@lagrange_v

; 831  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _web+616
	mov	eax, DWORD PTR _i$[ebp]
$LN48@lagrange_v:

; 829  :     for ( i = 0 ; i < 2 ; i++ )

	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, 2
	jl	SHORT $LL109@lagrange_v

; 833  :     }
; 834  :     x = get_coord(v_id);

	mov	eax, DWORD PTR tv1089[ebp]

; 835  :     for ( j = 0 ; j < SDIM ; j++ )

	fld	QWORD PTR __real@3fe0000000000000
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+64]
	xor	eax, eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	edi, 4
	jl	$LC92@lagrange_v

; 833  :     }
; 834  :     x = get_coord(v_id);

	mov	edi, DWORD PTR _newx$GSCopy$[ebp]
	lea	ecx, DWORD PTR [edi+24]

; 836  :       perturb[j] = newx[j]/2 - x[j];

	sub	edi, edx
	mov	DWORD PTR tv1878[ebp], edi
	lea	edi, DWORD PTR _perturb$89873[ebp]
	sub	edi, edx
	mov	DWORD PTR tv1895[ebp], edi
	lea	edi, DWORD PTR _perturb$89873[ebp+8]
	sub	edi, edx
	mov	DWORD PTR tv1899[ebp], edi
	lea	edi, DWORD PTR _perturb$89873[ebp+16]
	sub	edi, edx
	lea	eax, DWORD PTR [edx+8]
	mov	DWORD PTR tv1903[ebp], edi
$LN105@lagrange_v:
	fld	QWORD PTR [ecx-24]
	mov	edi, DWORD PTR _j$[ebp]
	fmul	ST(0), ST(1)
	add	DWORD PTR _j$[ebp], 4
	add	eax, 32					; 00000020H
	add	ecx, 32					; 00000020H
	fsub	QWORD PTR [eax-40]
	fstp	QWORD PTR _perturb$89873[ebp+edi*8]
	mov	edi, DWORD PTR tv1878[ebp]
	fld	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv1895[ebp]
	fmul	ST(0), ST(1)
	fsub	QWORD PTR [eax-32]
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv1899[ebp]
	fld	QWORD PTR [ecx-40]
	fmul	ST(0), ST(1)
	fsub	QWORD PTR [eax-24]
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv1903[ebp]
	fld	QWORD PTR [ecx-32]
	fmul	ST(0), ST(1)
	fsub	QWORD PTR [eax-16]
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR _web+616
	add	edi, -3					; fffffffdH
	cmp	DWORD PTR _j$[ebp], edi
	jl	SHORT $LN105@lagrange_v
	mov	edi, DWORD PTR _web+616
	mov	eax, DWORD PTR _j$[ebp]
$LC92@lagrange_v:

; 835  :     for ( j = 0 ; j < SDIM ; j++ )

	cmp	eax, edi
	jge	SHORT $LN126@lagrange_v
	mov	ecx, DWORD PTR _newx$GSCopy$[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv1878[ebp], ecx
	lea	ecx, DWORD PTR _perturb$89873[ebp]
	sub	ecx, edx
	mov	DWORD PTR tv1895[ebp], ecx
	mov	ecx, edi
	sub	ecx, DWORD PTR _j$[ebp]
	lea	eax, DWORD PTR [edx+eax*8]
$LC43@lagrange_v:

; 836  :       perturb[j] = newx[j]/2 - x[j];

	mov	edx, DWORD PTR tv1878[ebp]
	fld	QWORD PTR [eax+edx]
	mov	edx, DWORD PTR tv1895[ebp]
	fmul	ST(0), ST(1)
	add	eax, 8
	dec	ecx
	fsub	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax+edx-8]
	jne	SHORT $LC43@lagrange_v
$LN126@lagrange_v:

; 835  :     for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)

; 837  : 
; 838  :     /* get partials matrix */
; 839  :     for(j=0;j<SDIM;j++) dxdu[j] = 0.0;

	test	edi, edi
	jle	SHORT $LN40@lagrange_v
	mov	ecx, edi
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	lea	edi, DWORD PTR _dxdu$89874[ebp]
	rep stosd
$LN40@lagrange_v:

; 840  :     for ( k = 0 ; k < ctrl ; k++ )

	xor	edx, edx
	cmp	DWORD PTR _ctrl$89880[ebp], edx
	jle	$LN103@lagrange_v
	mov	eax, DWORD PTR _v$89866[ebp]
	lea	ecx, DWORD PTR _xx$89882[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv2459[ebp], eax
	jmp	SHORT $LN37@lagrange_v
$LL101@lagrange_v:
	mov	eax, DWORD PTR tv2459[ebp]
$LN37@lagrange_v:

; 841  :     { xx[k] = get_coord(v[k]);

	mov	edi, DWORD PTR _dymem
	lea	eax, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR _xx$89882[ebp+eax]
	mov	eax, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edi+64]
	lea	edi, DWORD PTR [ecx+eax]

; 842  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, 4
	mov	DWORD PTR _xx$89882[ebp+edx*4], edi
	jl	$LC95@lagrange_v

; 843  :       { dxdu[j] += g->lpolypart[knx][0][k]*xx[k][j];

	lea	eax, DWORD PTR [edi+16]
	neg	edi
	mov	DWORD PTR tv2330[ebp], edi
	lea	edi, DWORD PTR _dxdu$89874[ebp+edi]
	mov	DWORD PTR tv2209[ebp], edi
	mov	edi, DWORD PTR tv2330[ebp]
	lea	edi, DWORD PTR _dxdu$89874[ebp+edi+8]
	mov	DWORD PTR tv2215[ebp], edi
	npad	5
$LL96@lagrange_v:
	mov	edi, DWORD PTR [ebx+28]
	mov	edi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+edx*8]
	add	ecx, 4
	fmul	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	fadd	QWORD PTR _dxdu$89874[ebp+ecx*8-32]
	fstp	QWORD PTR _dxdu$89874[ebp+ecx*8-32]
	mov	edi, DWORD PTR [ebx+28]
	mov	edi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+edx*8]
	fmul	QWORD PTR [eax-40]
	fadd	QWORD PTR _dxdu$89874[ebp+ecx*8-24]
	fstp	QWORD PTR _dxdu$89874[ebp+ecx*8-24]
	mov	edi, DWORD PTR [ebx+28]
	mov	edi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR tv2209[ebp]
	fmul	QWORD PTR [eax-32]
	fadd	QWORD PTR [edi+eax-32]
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR [ebx+28]
	mov	edi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR tv2215[ebp]
	fmul	QWORD PTR [eax-24]
	fadd	QWORD PTR [edi+eax-32]
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR _web+616
	add	edi, -3					; fffffffdH
	cmp	ecx, edi
	jl	SHORT $LL96@lagrange_v
$LC95@lagrange_v:

; 842  :       for ( j = 0 ; j < SDIM ; j++ )

	cmp	ecx, DWORD PTR _web+616
	jge	SHORT $LN36@lagrange_v
	mov	eax, DWORD PTR _xx$89882[ebp+edx*4]
	lea	edi, DWORD PTR _dxdu$89874[ebp]
	sub	eax, edi
	mov	DWORD PTR tv2298[ebp], eax
	jmp	SHORT $LC34@lagrange_v
$LL102@lagrange_v:
	mov	eax, DWORD PTR tv2298[ebp]
$LC34@lagrange_v:

; 843  :       { dxdu[j] += g->lpolypart[knx][0][k]*xx[k][j];

	mov	edi, DWORD PTR [ebx+28]
	mov	edi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR [edi]
	fld	QWORD PTR [edi+edx*8]
	lea	eax, DWORD PTR [eax+ecx*8]
	fmul	QWORD PTR _dxdu$89874[ebp+eax]
	inc	ecx
	fadd	QWORD PTR _dxdu$89874[ebp+ecx*8-8]
	fstp	QWORD PTR _dxdu$89874[ebp+ecx*8-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL102@lagrange_v
$LN36@lagrange_v:

; 840  :     for ( k = 0 ; k < ctrl ; k++ )

	inc	edx
	cmp	edx, DWORD PTR _ctrl$89880[ebp]
	jl	$LL101@lagrange_v
$LN103@lagrange_v:

; 844  :       }
; 845  :     }
; 846  :     rhs = dot(perturb,dxdu,SDIM);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _dxdu$89874[ebp]
	push	edx
	lea	eax, DWORD PTR _perturb$89873[ebp]
	push	eax
	call	_dot
	fstp	QWORD PTR _rhs$89877[ebp]

; 847  :     aa =  dot(dxdu,dxdu,SDIM);

	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _dxdu$89874[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot

; 848  :     du = rhs/aa;

	fdivr	QWORD PTR _rhs$89877[ebp]

; 849  :     u = (knx + du)/web.lagrange_order;
; 850  :     lagrange_eval_1d(web.lagrange_order,SDIM,u,xx,newx);

	mov	ecx, DWORD PTR _newx$GSCopy$[ebp]
	mov	eax, DWORD PTR _web+616
	add	esp, 24					; 00000018H
	push	ecx
	mov	ecx, DWORD PTR _web+632
	lea	edx, DWORD PTR _xx$89882[ebp]
	push	edx
	sub	esp, 8
	fiadd	DWORD PTR _knx$89871[ebp]
	fidiv	DWORD PTR _web+632
	fstp	QWORD PTR [esp]
	push	eax
	push	ecx
	call	_lagrange_eval_1d
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 851  :     /* newx holds return value */
; 852  :      
; 853  :     return 1;

	mov	eax, 1
	pop	ebx

; 923  :   }
; 924  :   else /* corner */
; 925  :   { /* not doing anything yet */
; 926  :     return 0;
; 927  :   }
; 928  : 
; 929  : } // end lagrange_vertex_average()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@lagrange_v:

; 854  :   }
; 855  :   else if ( attr & Q_MIDFACET )

	and	esi, 2097152				; 00200000H
	xor	eax, eax
	or	esi, eax
	je	$LN30@lagrange_v

; 856  :   { facet_id f_id = get_vertex_facet(v_id);
; 857  :     vertex_id *v = get_facet_vertices(f_id);

	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ecx+304]

; 858  :     int inx=0,jnx,knx; /* col, row, index of vertex */
; 859  :     vertex_id vv[6];  /* the six neighbors to average with */
; 860  :     MAT2D(dxdu,MAXCOORD,2);

	push	2
	push	6
	lea	edx, DWORD PTR _dxduxJ$89937[ebp]
	mov	DWORD PTR _v$89927[ebp], eax
	push	edx
	lea	eax, DWORD PTR _dxduqXvS$89936[ebp]
	push	eax
	mov	DWORD PTR _inx$89932[ebp], ebx
	call	_mat2d_setup

; 861  :     REAL *xx[(MAXLAGRANGE+1)*(MAXLAGRANGE+2)/2];
; 862  :     MAT2D(aa,2,2);

	push	2
	push	2
	lea	ecx, DWORD PTR _aaxJ$89942[ebp]
	push	ecx
	lea	edx, DWORD PTR _aaqXvS$89941[ebp]
	push	edx
	mov	DWORD PTR _dxdu$89938[ebp], eax
	call	_mat2d_setup
	mov	DWORD PTR _aa$89943[ebp], eax

; 863  :     REAL perturb[MAXCOORD], *p=perturb;

	lea	eax, DWORD PTR _perturb$89945[ebp]
	mov	DWORD PTR _p$89946[ebp], eax

; 864  :     REAL u[2],du[2],rhs[2],*r=rhs,*x;
; 865  :     struct gauss_lag *g = &gauss_lagrange[2][web.gauss2D_order];

	mov	eax, DWORD PTR _web+1596
	shl	eax, 5
	add	eax, DWORD PTR _gauss_lagrange+8
	lea	ecx, DWORD PTR _rhs$89949[ebp]
	mov	DWORD PTR _g$89952[ebp], eax
	mov	DWORD PTR _r$89950[ebp], ecx

; 866  :     int ctrl = (web.lagrange_order+1)*(web.lagrange_order+2)/2;

	mov	ecx, DWORD PTR _web+632
	lea	edx, DWORD PTR [ecx+1]
	lea	eax, DWORD PTR [ecx+2]
	imul	eax, edx
	cdq
	sub	eax, edx
	sar	eax, 1

; 867  : 
; 868  :     /* find which vertex it is in the facet */
; 869  :     for ( jnx = 0, knx = 0 ; jnx <= web.lagrange_order ; jnx++ )

	xor	esi, esi
	xor	ebx, ebx
	add	esp, 32					; 00000020H
	mov	DWORD PTR _ctrl$89953[ebp], eax
	mov	DWORD PTR _jnx$89933[ebp], esi
	mov	DWORD PTR _knx$89934[ebp], ebx
	test	ecx, ecx
	js	SHORT $LN27@lagrange_v
	npad	2
$LL114@lagrange_v:

; 870  :       for ( inx = 0 ; inx+jnx <= web.lagrange_order ; inx++,knx++ )

	mov	DWORD PTR _inx$89932[ebp], 0
	cmp	esi, ecx
	jg	SHORT $LN28@lagrange_v
	mov	eax, esi
$LL26@lagrange_v:

; 871  :         if ( equal_id(v_id,v[knx]) )

	mov	edx, DWORD PTR _v_id$[ebp]
	mov	edi, DWORD PTR _v$89927[ebp]
	cmp	edx, DWORD PTR [edi+ebx*4]
	je	SHORT $LN104@lagrange_v

; 870  :       for ( inx = 0 ; inx+jnx <= web.lagrange_order ; inx++,knx++ )

	inc	DWORD PTR _inx$89932[ebp]
	inc	eax
	inc	ebx
	mov	DWORD PTR _knx$89934[ebp], ebx
	cmp	eax, ecx
	jle	SHORT $LL26@lagrange_v
	mov	edi, DWORD PTR tv1089[ebp]
$LN28@lagrange_v:

; 867  : 
; 868  :     /* find which vertex it is in the facet */
; 869  :     for ( jnx = 0, knx = 0 ; jnx <= web.lagrange_order ; jnx++ )

	inc	esi
	mov	DWORD PTR _jnx$89933[ebp], esi
	cmp	esi, ecx
	jle	SHORT $LL114@lagrange_v
$LN27@lagrange_v:

; 872  :           goto found_knx;
; 873  :     kb_error(2664,"Internal error:lagrange_vertex_average() couldn't find vertex index in facet.\n",
; 874  :       RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EP@OLEJLABA@Internal?5error?3lagrange_vertex_a@
	push	2664					; 00000a68H
	call	_kb_error
	mov	ecx, DWORD PTR _web+632
	add	esp, 12					; 0000000cH
	jmp	SHORT $found_knx$89961
$LN104@lagrange_v:
	mov	edi, DWORD PTR tv1089[ebp]
$found_knx$89961:

; 875  :          
; 876  :  found_knx:
; 877  :     /* the six neighbors */
; 878  :     vv[0] = v[knx - web.lagrange_order + jnx - 2];

	mov	eax, DWORD PTR _v$89927[ebp]
	mov	edx, ebx
	sub	edx, ecx
	add	edx, esi
	mov	eax, DWORD PTR [eax+edx*4-8]
	mov	DWORD PTR _vv$89935[ebp], eax

; 879  :     vv[1] = v[knx - web.lagrange_order + jnx - 1];

	mov	eax, DWORD PTR _v$89927[ebp]
	mov	edx, DWORD PTR [eax+edx*4-4]
	mov	DWORD PTR _vv$89935[ebp+4], edx

; 880  :     vv[2] = v[knx - 1];

	mov	edx, DWORD PTR [eax+ebx*4-4]
	mov	DWORD PTR _vv$89935[ebp+8], edx

; 881  :     vv[3] = v[knx + 1];

	mov	edx, DWORD PTR [eax+ebx*4+4]

; 882  :     vv[4] = v[knx + web.lagrange_order - jnx];

	sub	ebx, esi
	add	ebx, ecx
	mov	ecx, DWORD PTR [eax+ebx*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _vv$89935[ebp+12], edx

; 883  :     vv[5] = v[knx + web.lagrange_order - jnx + 1];

	mov	edx, DWORD PTR [eax+4]

; 884  : 
; 885  :     /* find perturbation in u,v so can calculate new position exactly on 
; 886  :        the surface */
; 887  :     /* first, the xyz perturbation */
; 888  :     memset((char*)newx,0,SDIM*sizeof(REAL));

	mov	eax, DWORD PTR _web+616
	mov	DWORD PTR _vv$89935[ebp+16], ecx
	lea	ecx, DWORD PTR [eax*8]
	push	ecx
	mov	DWORD PTR _vv$89935[ebp+20], edx
	mov	edx, DWORD PTR _newx$GSCopy$[ebp]
	push	0
	push	edx
	call	_memset

; 889  :     for ( i = 0 ; i < 6 ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	xor	ebx, ebx
	npad	6
$LL22@lagrange_v:

; 890  :     { REAL *xx = get_coord(vv[i]);

	mov	eax, DWORD PTR _vv$89935[ebp+ebx*4]
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	add	esi, DWORD PTR [edx+eax+64]

; 891  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN21@lagrange_v
	mov	eax, DWORD PTR _newx$GSCopy$[ebp]
	sub	esi, eax
	npad	1
$LL19@lagrange_v:

; 892  :         newx[j] += xx[j];

	fld	QWORD PTR [esi+eax]
	inc	edx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LL19@lagrange_v
$LN21@lagrange_v:

; 889  :     for ( i = 0 ; i < 6 ; i++ )

	inc	ebx
	cmp	ebx, 6
	jl	SHORT $LL22@lagrange_v

; 893  :     }
; 894  :     x = get_coord(v_id);

	mov	eax, DWORD PTR _web+12

; 895  :     for ( j = 0 ; j < SDIM ; j++ )

	fld	QWORD PTR __real@4018000000000000
	mov	esi, DWORD PTR [edi+eax]
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	add	esi, DWORD PTR [edx+eax+64]
	xor	ebx, ebx
	cmp	ecx, 4
	jl	$LC98@lagrange_v

; 893  :     }
; 894  :     x = get_coord(v_id);

	mov	edi, DWORD PTR _newx$GSCopy$[ebp]
	lea	edx, DWORD PTR [edi+24]

; 896  :       perturb[j] = newx[j]/6 - x[j];

	sub	edi, esi
	mov	DWORD PTR tv2930[ebp], edi
	lea	edi, DWORD PTR _perturb$89945[ebp]
	sub	edi, esi
	mov	DWORD PTR tv3011[ebp], edi
	lea	edi, DWORD PTR _perturb$89945[ebp+8]
	sub	edi, esi
	mov	DWORD PTR tv3015[ebp], edi
	lea	edi, DWORD PTR _perturb$89945[ebp+16]
	sub	edi, esi
	lea	eax, DWORD PTR [esi+8]
	mov	DWORD PTR tv3019[ebp], edi
$LN106@lagrange_v:
	fld	QWORD PTR [edx-24]
	mov	edi, DWORD PTR tv2930[ebp]
	fdiv	ST(0), ST(1)
	add	ebx, 4
	add	eax, 32					; 00000020H
	add	edx, 32					; 00000020H
	mov	DWORD PTR _j$[ebp], ebx
	fsub	QWORD PTR [eax-40]
	fstp	QWORD PTR _perturb$89945[ebp+ebx*8-32]
	fld	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv3011[ebp]
	fdiv	ST(0), ST(1)
	fsub	QWORD PTR [eax-32]
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv3015[ebp]
	fld	QWORD PTR [edx-40]
	fdiv	ST(0), ST(1)
	fsub	QWORD PTR [eax-24]
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv3019[ebp]
	fld	QWORD PTR [edx-32]
	fdiv	ST(0), ST(1)
	fsub	QWORD PTR [eax-16]
	fstp	QWORD PTR [edi+eax-32]
	lea	edi, DWORD PTR [ecx-3]
	cmp	ebx, edi
	jl	SHORT $LN106@lagrange_v
$LC98@lagrange_v:

; 895  :     for ( j = 0 ; j < SDIM ; j++ )

	cmp	ebx, ecx
	jge	SHORT $LN138@lagrange_v
	mov	edi, DWORD PTR _newx$GSCopy$[ebp]
	lea	edx, DWORD PTR _perturb$89945[ebp]
	sub	edx, esi
	mov	DWORD PTR tv3011[ebp], edx
	mov	edx, ecx
	sub	edi, esi
	lea	eax, DWORD PTR [esi+ebx*8]
	sub	edx, ebx
$LC16@lagrange_v:

; 896  :       perturb[j] = newx[j]/6 - x[j];

	fld	QWORD PTR [edi+eax]
	mov	esi, DWORD PTR tv3011[ebp]
	fdiv	ST(0), ST(1)
	add	eax, 8
	dec	edx
	fsub	QWORD PTR [eax-8]
	fstp	QWORD PTR [esi+eax-8]
	jne	SHORT $LC16@lagrange_v
$LN138@lagrange_v:

; 897  : 
; 898  :     /* get partials matrix */
; 899  :     for(j=0;j<SDIM;j++) dxdu[j][0] = dxdu[j][1] = 0.0;

	xor	eax, eax
	fstp	ST(0)
	test	ecx, ecx
	jle	SHORT $LN11@lagrange_v
	fldz
$LN13@lagrange_v:
	mov	ecx, DWORD PTR _dxdu$89938[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	fst	QWORD PTR [ecx+8]
	inc	eax
	fst	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN13@lagrange_v
	fstp	ST(0)
$LN11@lagrange_v:

; 900  :     for ( k = 0 ; k < ctrl ; k++ )

	xor	ebx, ebx
	mov	DWORD PTR _k$[ebp], ebx
	cmp	DWORD PTR _ctrl$89953[ebp], ebx
	jle	$LN112@lagrange_v
	mov	eax, DWORD PTR _v$89927[ebp]
	lea	edx, DWORD PTR _xx$89940[ebp]
	mov	esi, edx
	sub	eax, esi
	mov	DWORD PTR tv3439[ebp], eax
	jmp	SHORT $LN10@lagrange_v
	npad	2
$LL110@lagrange_v:
	mov	eax, DWORD PTR tv3439[ebp]
$LN10@lagrange_v:

; 901  :     { xx[k] = get_coord(v[k]);

	mov	eax, DWORD PTR [eax+edx]
	mov	esi, DWORD PTR _web+12
	mov	edi, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+104
	add	eax, DWORD PTR [esi+edi+64]
	mov	DWORD PTR [edx], eax

; 902  :       for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN9@lagrange_v

; 900  :     for ( k = 0 ; k < ctrl ; k++ )

	mov	ecx, DWORD PTR _g$89952[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	mov	esi, DWORD PTR _knx$89934[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	esi, DWORD PTR [esi+ebx*8]
	lea	ebx, DWORD PTR [ecx+ebx*8]
	npad	4
$LL107@lagrange_v:

; 903  :       { dxdu[j][0] += g->lpolypart[knx][0][k]*xx[k][j];

	mov	edi, DWORD PTR [edx]
	fld	QWORD PTR [edi+eax*8]
	mov	ecx, DWORD PTR _dxdu$89938[ebp]
	fmul	QWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+eax*4]
	inc	eax
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]

; 904  :         dxdu[j][1] += g->lpolypart[knx][1][k]*xx[k][j];

	mov	edi, DWORD PTR [edx]
	fld	QWORD PTR [edi+eax*8-8]
	fmul	QWORD PTR [ebx]
	fadd	QWORD PTR [ecx+8]
	fstp	QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LL107@lagrange_v

; 902  :       for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _k$[ebp]
$LN9@lagrange_v:

; 900  :     for ( k = 0 ; k < ctrl ; k++ )

	inc	ebx
	add	edx, 4
	mov	DWORD PTR _k$[ebp], ebx
	cmp	ebx, DWORD PTR _ctrl$89953[ebp]
	jl	$LL110@lagrange_v
$LN112@lagrange_v:

; 905  :       }
; 906  :     }
; 907  :     /* kludging due to way lpolypart defined in terms of barycentric */
; 908  :     for ( j = 0  ; j < SDIM  ; j++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN115@lagrange_v
	npad	1
$LL4@lagrange_v:

; 909  :     { dxdu[j][0] -= dxdu[j][1];

	mov	eax, DWORD PTR _dxdu$89938[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	fld	QWORD PTR [eax]
	inc	edx
	fsub	QWORD PTR [eax+8]
	fst	QWORD PTR [eax]

; 910  :       dxdu[j][1] += dxdu[j][0];

	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LL4@lagrange_v
$LN115@lagrange_v:

; 911  :     }
; 912  :     /* Least squares solve for du */
; 913  :     mat_mult(&p,dxdu,&r,1,SDIM,2);

	mov	esi, DWORD PTR _dxdu$89938[ebp]
	push	2
	push	ecx
	push	1
	lea	ecx, DWORD PTR _r$89950[ebp]
	push	ecx
	lea	edx, DWORD PTR _p$89946[ebp]
	push	esi
	push	edx
	call	_mat_mult

; 914  :     tr_mat_mul(dxdu,dxdu,aa,SDIM,2,2);

	mov	eax, DWORD PTR _web+616
	mov	edi, DWORD PTR _aa$89943[ebp]
	push	2
	push	2
	push	eax
	push	edi
	push	esi
	push	esi
	call	_tr_mat_mul

; 915  :     mat_inv(aa,2);

	push	2
	push	edi
	call	_mat_inv

; 916  :     matvec_mul(aa,rhs,du,2,2);

	push	2
	push	2
	lea	ecx, DWORD PTR _du$89948[ebp]
	push	ecx
	lea	edx, DWORD PTR _rhs$89949[ebp]
	push	edx
	push	edi
	call	_matvec_mul

; 917  :     u[0] = (inx + du[0])/web.lagrange_order;

	fild	DWORD PTR _web+632
	fild	DWORD PTR _inx$89932[ebp]

; 918  :     u[1] = (jnx + du[1])/web.lagrange_order;
; 919  :     lagrange_eval_2d(web.lagrange_order,SDIM,u,xx,newx);

	mov	eax, DWORD PTR _newx$GSCopy$[ebp]
	add	esp, 76					; 0000004cH
	push	eax
	fadd	QWORD PTR _du$89948[ebp]
	mov	eax, DWORD PTR _web+616
	lea	ecx, DWORD PTR _xx$89940[ebp]
	push	ecx
	fdiv	ST(0), ST(1)
	mov	ecx, DWORD PTR _web+632
	lea	edx, DWORD PTR _u$89947[ebp]
	push	edx
	push	eax
	push	ecx
	fstp	QWORD PTR _u$89947[ebp]
	fild	DWORD PTR _jnx$89933[ebp]
	fadd	QWORD PTR _du$89948[ebp+8]
	fdivrp	ST(1), ST(0)
	fstp	QWORD PTR _u$89947[ebp+8]
	call	_lagrange_eval_2d
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi

; 920  :     /* newx holds return value */
; 921  :      
; 922  :     return 1;

	mov	eax, 1
	pop	ebx

; 923  :   }
; 924  :   else /* corner */
; 925  :   { /* not doing anything yet */
; 926  :     return 0;
; 927  :   }
; 928  : 
; 929  : } // end lagrange_vertex_average()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@lagrange_v:
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	xor	eax, eax
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_lagrange_vertex_average ENDP
_TEXT	ENDS
PUBLIC	__real@3fd0000000000000
PUBLIC	_vx$GSCopy$
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_find_vertex_average
EXTRN	_constr_proj:PROC
EXTRN	_gram_schmidt:PROC
EXTRN	_new_calc_vertex_normal:PROC
EXTRN	_calc_facet_energy:DWORD
EXTRN	_get_facet_normal:PROC
;	COMDAT __real@3fd0000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\veravg.c
CONST	ENDS
;	COMDAT _find_vertex_average
_TEXT	SEGMENT
_normqXvS$ = -580					; size = 24
_con$89816 = -556					; size = 28
_start_e$ = -528					; size = 4
_total_weight$ = -524					; size = 8
_weight$ = -516						; size = 8
_norm$ = -508						; size = 4
_triple_flag$ = -504					; size = 4
_k$ = -500						; size = 4
tv1537 = -496						; size = 4
_oncount$89815 = -496					; size = 4
tv4609 = -492						; size = 8
tv4593 = -492						; size = 8
tv3827 = -492						; size = 8
tv3825 = -492						; size = 8
_attr$ = -492						; size = 8
_v_id$GSCopy$ = -484					; size = 4
_e_id$ = -480						; size = 4
tv945 = -476						; size = 4
tv73 = -476						; size = 4
_start_fe$89712 = -476					; size = 4
tv2941 = -472						; size = 4
_single_flag$ = -472					; size = 4
_vx$GSCopy$ = -468					; size = 4
_normxJ$ = -464						; size = 288
_conlist$89817 = -176					; size = 28
_x$ = -148						; size = 48
_perp$89818 = -100					; size = 48
_side$89680 = -100					; size = 48
_xsum$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_vx$ = 12						; size = 4
_mode$ = 16						; size = 4
_find_vertex_average PROC				; COMDAT

; 576  : { ATTR attr = get_vattr(v_id);

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 577  :   REAL xsum[MAXCOORD];  
; 578  :   REAL *oldx;
; 579  :   REAL x[MAXCOORD];
; 580  :   edge_id e_id,start_e;
; 581  :   int i,j,k,n;
; 582  :   REAL weight,total_weight;
; 583  :   MAT2D(norm,MAXCOORD,MAXCOORD);
; 584  :   int dm;
; 585  :   int triple_flag = 0; /* whether any triple (or more) edges found */

	mov	eax, DWORD PTR _vx$[ebp]
	mov	ecx, DWORD PTR _web+12
	push	ebx
	push	esi
	mov	esi, DWORD PTR _v_id$[ebp]
	mov	DWORD PTR _v_id$GSCopy$[ebp], esi
	and	esi, 134217727				; 07ffffffH
	push	edi
	add	esi, esi
	mov	DWORD PTR _vx$GSCopy$[ebp], eax
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	mov	ebx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax+12]
	push	6
	push	6
	lea	eax, DWORD PTR _normxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _normqXvS$[ebp]
	push	ecx
	mov	DWORD PTR tv1537[ebp], esi
	mov	DWORD PTR _attr$[ebp], ebx
	mov	DWORD PTR _attr$[ebp+4], edx
	call	_mat2d_setup

; 586  :   int single_flag = 0; /* whether any single edges found */
; 587  : 
; 588  : 
; 589  :   oldx = get_coord(v_id);

	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR _web+104
	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR _norm$[ebp], eax
	xor	eax, eax
	mov	DWORD PTR _triple_flag$[ebp], eax
	mov	DWORD PTR _single_flag$[ebp], eax
	mov	eax, DWORD PTR [esi+edx]
	add	eax, DWORD PTR [ecx+edi+64]

; 590  :   for ( i = 0 ; i < SDIM ; i++ ) vx[i] = oldx[i];

	xor	ecx, ecx
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN237@find_verte
	mov	edx, DWORD PTR _vx$GSCopy$[ebp]
	sub	eax, edx
	npad	4
$LL106@find_verte:
	fld	QWORD PTR [eax+edx]
	inc	ecx
	fstp	QWORD PTR [edx]
	add	edx, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL106@find_verte
	mov	edi, DWORD PTR _dymem
$LN237@find_verte:

; 591  : 
; 592  :   if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	jne	SHORT $LN103@find_verte

; 593  :      return lagrange_vertex_average(v_id,vx);

	mov	edx, DWORD PTR _vx$GSCopy$[ebp]
	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	edx
	push	eax
	call	_lagrange_vertex_average
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 779  :   }
; 780  : 
; 781  : new_avg_exit:
; 782  : 
; 783  :   return 1;
; 784  : } // end find_vertex_average()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN103@find_verte:

; 594  : 
; 595  :   if ( attr & (FIXED|AXIAL_POINT) ) return 0;

	mov	eax, ebx
	and	eax, 8388672				; 00800040H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN411@find_verte

; 596  : 
; 597  :   for ( i = 0 ; i < SDIM ; i++ ) xsum[i] = 0.0;

	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN238@find_verte
	mov	ecx, DWORD PTR _web+616
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	lea	edi, DWORD PTR _xsum$[ebp]
	rep stosd
	mov	edi, DWORD PTR _dymem
$LN238@find_verte:

; 598  : 
; 599  :   if ( attr & Q_MIDPOINT )

	mov	eax, ebx
	and	eax, 131072				; 00020000H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN98@find_verte

; 600  :   { /* quadratic model midpoint of edge */
; 601  :     facetedge_id fe;
; 602  :     facet_id f_id;
; 603  :     REAL *xt,side[MAXCOORD],coeff;
; 604  :     e_id = get_vertex_edge(v_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR [edx+28]

; 605  :     xt = get_coord(get_edge_tailv(e_id));

	mov	esi, DWORD PTR _dymem
	mov	edi, ecx
	and	edi, 134217727				; 07ffffffH
	mov	ebx, ecx
	add	edi, edi
	shr	ebx, 27					; 0000001bH
	add	edi, edi
	and	ebx, 1
	je	SHORT $LN120@find_verte
	mov	eax, DWORD PTR _web+124
	mov	edx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR _web+216
	add	edx, DWORD PTR [eax+esi+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN119@find_verte
$LN120@find_verte:
	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [edi+edx]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+esi+304]
	mov	eax, DWORD PTR [eax+edx]
$LN119@find_verte:
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	add	esi, DWORD PTR [eax+edx+64]

; 606  :     get_edge_side(e_id,side);

	lea	eax, DWORD PTR _side$89680[ebp]
	push	eax
	push	ecx
	call	_get_edge_side

; 607  :     fe = get_edge_fe(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	edi, DWORD PTR [edi+ecx]
	add	esp, 8
	test	edi, edi
	jne	SHORT $LN124@find_verte
	xor	ecx, ecx
	jmp	SHORT $LN125@find_verte
$LN124@find_verte:
	mov	edi, DWORD PTR [edi+28]
	test	ebx, ebx
	je	SHORT $LN123@find_verte
	xor	edi, 134217728				; 08000000H
$LN123@find_verte:
	mov	ecx, edi
$LN125@find_verte:

; 608  :     /* for soapfilm, keep height above midpoint */
; 609  :     if ( (web.representation == SOAPFILM) && valid_id(fe) )

	cmp	DWORD PTR _web+624, 2
	jne	$LN96@find_verte
	test	ecx, 268435456				; 10000000H
	je	$LN96@find_verte

; 610  :     { f_id = get_fe_facet(fe);

	mov	eax, DWORD PTR _web+460
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edx+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN127@find_verte
	xor	eax, 134217728				; 08000000H
$LN127@find_verte:

; 611  :       if ( valid_id(f_id) )

	test	eax, 268435456				; 10000000H
	je	$LN96@find_verte

; 612  :       { get_facet_normal(f_id,norm[0]); 

	mov	edi, DWORD PTR _norm$[ebp]
	mov	ecx, DWORD PTR [edi]
	push	ecx
	push	eax
	call	_get_facet_normal

; 613  :         coeff = (SDIM_dot(vx,norm[0])-SDIM_dot(xt,norm[0]))/
; 614  :                       SDIM_dot(norm[0],norm[0]);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _vx$GSCopy$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_dot
	fstp	QWORD PTR tv3825[ebp]
	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [edi]
	push	edx
	push	eax
	push	esi
	call	_dot
	fsubr	QWORD PTR tv3825[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	edi, DWORD PTR [edi]
	push	ecx
	fstp	QWORD PTR tv4609[ebp]
	push	edi
	push	edi
	call	_dot
	fdivr	QWORD PTR tv4609[ebp]

; 615  :         for ( i = 0 ; i < SDIM ; i++ ) 

	xor	ecx, ecx
	add	esp, 44					; 0000002cH
	cmp	DWORD PTR _web+616, ecx
	jle	$LN408@find_verte
	mov	edi, DWORD PTR _norm$[ebp]
	fld	QWORD PTR __real@3fe0000000000000
	mov	edi, DWORD PTR [edi]
	mov	ebx, DWORD PTR _vx$GSCopy$[ebp]
	lea	edx, DWORD PTR _side$89680[ebp]
	sub	edx, esi
	sub	edi, esi
	mov	eax, esi
	sub	ebx, esi
$LN95@find_verte:

; 616  :            vx[i] = xt[i] + 0.5*side[i] + coeff*norm[0][i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fadd	QWORD PTR [eax-8]
	fld	QWORD PTR [edi+eax-8]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ebx+eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN95@find_verte

; 617  :         goto new_avg_exit;

	jmp	$LN407@find_verte
$LN96@find_verte:

; 618  :       }
; 619  :     }
; 620  :     /* if didn't work, just center midpoints a little */
; 621  :     coeff = 0.5 - (SDIM_dot(vx,side)-SDIM_dot(xt,side))/
; 622  :                      SDIM_dot(side,side);

	mov	edx, DWORD PTR _web+616
	mov	ecx, DWORD PTR _vx$GSCopy$[ebp]
	push	edx
	lea	eax, DWORD PTR _side$89680[ebp]
	push	eax
	push	ecx
	call	_dot
	fstp	QWORD PTR tv3827[ebp]
	mov	edx, DWORD PTR _web+616
	push	edx
	lea	eax, DWORD PTR _side$89680[ebp]
	push	eax
	push	esi
	call	_dot
	fsubr	QWORD PTR tv3827[ebp]
	mov	ecx, DWORD PTR _web+616
	push	ecx
	lea	edx, DWORD PTR _side$89680[ebp]
	fstp	QWORD PTR tv4593[ebp]
	push	edx
	mov	eax, edx
	push	eax
	call	_dot
	fdivr	QWORD PTR tv4593[ebp]

; 623  :     for ( i = 0 ; i < SDIM ; i++ ) vx[i] += coeff*side[i];

	xor	ecx, ecx
	add	esp, 36					; 00000024H
	fsubr	QWORD PTR __real@3fe0000000000000
	cmp	DWORD PTR _web+616, ecx
	jle	$LN408@find_verte
	mov	eax, DWORD PTR _vx$GSCopy$[ebp]
	lea	edx, DWORD PTR _side$89680[ebp]
	sub	edx, eax
$LN92@find_verte:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN92@find_verte

; 624  :   }
; 625  :   else if ( attr & Q_MIDFACET )

	jmp	$LN408@find_verte
$LN98@find_verte:
	mov	eax, ebx
	and	eax, 2097152				; 00200000H
	or	eax, ecx
	je	SHORT $LN88@find_verte

; 626  :   { /* Lagrange model middle of facet */
; 627  :      return lagrange_vertex_average(v_id,vx);

	mov	ecx, DWORD PTR _vx$GSCopy$[ebp]
	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
	push	ecx
	push	edx
	call	_lagrange_vertex_average
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 779  :   }
; 780  : 
; 781  : new_avg_exit:
; 782  : 
; 783  :   return 1;
; 784  : } // end find_vertex_average()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN88@find_verte:

; 628  :   }
; 629  :   else if ( attr & Q_MIDEDGE )

	mov	eax, ebx
	and	eax, 4194304				; 00400000H
	or	eax, ecx
	je	SHORT $LN86@find_verte

; 630  :   { /* Lagrange model middle of edge */
; 631  :      return lagrange_vertex_average(v_id,vx);

	mov	eax, DWORD PTR _vx$GSCopy$[ebp]
	mov	ecx, DWORD PTR _v_id$GSCopy$[ebp]
	push	eax
	push	ecx
	call	_lagrange_vertex_average
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 779  :   }
; 780  : 
; 781  : new_avg_exit:
; 782  : 
; 783  :   return 1;
; 784  : } // end find_vertex_average()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN86@find_verte:

; 632  :   }
; 633  :   else
; 634  :   { /* corner vertex, average with neighbors */
; 635  :     e_id = start_e = get_vertex_edge(v_id);

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+28]
	mov	DWORD PTR _start_e$[ebp], eax
	mov	DWORD PTR _e_id$[ebp], eax

; 636  :     if ( !valid_id(e_id) ) return 0;

	test	eax, 268435456				; 10000000H
	je	$LN411@find_verte

; 637  :     k = 0; total_weight = 0.0;

	fldz
	mov	DWORD PTR _k$[ebp], ecx
	fst	QWORD PTR _total_weight$[ebp]
$LN410@find_verte:

; 638  :     /* get weighted sum of neighbors */
; 639  :     do
; 640  :     { facetedge_id fe,start_fe;
; 641  : 
; 642  :       if ( mode != RAWEST )

	cmp	DWORD PTR _mode$[ebp], 2
	mov	edx, DWORD PTR _web+776
	je	$LN53@find_verte

; 643  :       { /* check constraint compatibility */
; 644  :         int m;
; 645  : 
; 646  :         if ( (attr & CONSTRAINT) )

	mov	eax, ebx
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN79@find_verte

; 647  :         { conmap_t * vconmap = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _web+104
	cmp	DWORD PTR [eax+edi+1288], ecx
	je	SHORT $LN109@find_verte
	mov	ecx, DWORD PTR _web+12
	mov	esi, DWORD PTR [esi+ecx]
	add	esi, DWORD PTR [eax+edi+1264]
	jmp	SHORT $LN110@find_verte
$LN109@find_verte:
	mov	esi, OFFSET _nullcon
$LN110@find_verte:

; 648  :           conmap_t * econmap = get_e_constraint_map(e_id);

	mov	edx, DWORD PTR _web+216
	cmp	DWORD PTR [edx+edi+1048], 0
	je	SHORT $LN111@find_verte
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	add	edx, DWORD PTR [eax+edi+1024]
	jmp	SHORT $LN112@find_verte
$LN111@find_verte:
	mov	edx, OFFSET _nullcon
$LN112@find_verte:

; 649  : 
; 650  :           for ( j = 1 ; j <= (int)vconmap[0] ; j++ )

	mov	edi, 1
	cmp	DWORD PTR [esi], edi
	jl	$LN230@find_verte
	mov	ebx, DWORD PTR [edx]
$LN78@find_verte:

; 651  :           { int found;
; 652  :             for ( m = 1, found = 0 ; m <= (int)econmap[0] ; m++ )

	mov	eax, 1
	cmp	ebx, eax
	jl	$loopend$89742
	mov	ecx, DWORD PTR [esi+edi*4]
	and	ecx, 2147483647				; 7fffffffH
$LN75@find_verte:

; 653  :               if ( econmap[m] == (vconmap[j] & ~CON_HIT_BIT) )

	cmp	DWORD PTR [edx+eax*4], ecx
	je	SHORT $LN182@find_verte

; 651  :           { int found;
; 652  :             for ( m = 1, found = 0 ; m <= (int)econmap[0] ; m++ )

	inc	eax
	cmp	eax, ebx
	jg	$loopend$89742
	jmp	SHORT $LN75@find_verte
$LN182@find_verte:

; 649  : 
; 650  :           for ( j = 1 ; j <= (int)vconmap[0] ; j++ )

	inc	edi
	cmp	edi, DWORD PTR [esi]
	jg	$LN230@find_verte
	jmp	SHORT $LN78@find_verte
$LN79@find_verte:

; 654  :               { found = 1; break; }
; 655  :             if ( !found ) goto loopend;
; 656  :           }
; 657  :         }
; 658  :         else if ( attr & BOUNDARY )

	mov	eax, ebx
	and	eax, 128				; 00000080H
	xor	ebx, ebx
	or	eax, ebx
	je	SHORT $LN230@find_verte

; 659  :         { 
; 660  :           if ( get_edge_boundary(e_id) != get_boundary(v_id) ) goto loopend;

	cmp	DWORD PTR _E_BOUNDARY_ATTR, ecx
	je	SHORT $LN113@find_verte
	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	mov	ecx, DWORD PTR _e_id$[ebp]
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	mov	ebx, DWORD PTR _web+124
	mov	eax, DWORD PTR [eax+edi+64]
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [ecx+eax]
	imul	ecx, 136				; 00000088H
	add	ecx, edx
	jmp	SHORT $LN114@find_verte
$LN113@find_verte:
	xor	ecx, ecx
$LN114@find_verte:
	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN115@find_verte
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edi+64]
	mov	edi, DWORD PTR _web+12
	mov	esi, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [eax+esi]
	imul	eax, 136				; 00000088H
	add	eax, edx
	jmp	SHORT $LN116@find_verte
$LN115@find_verte:
	xor	eax, eax
$LN116@find_verte:
	cmp	ecx, eax
	jne	$loopend$89742
$LN230@find_verte:

; 661  :         } 
; 662  :       }
; 663  : 
; 664  :       /* check valence */
; 665  :       if ( (mode != RAWEST) && (web.representation == SOAPFILM) )

	cmp	DWORD PTR _web+624, 2
	jne	$LN53@find_verte

; 666  :       { fe = get_edge_fe(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	eax, DWORD PTR _web+124
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	xor	edi, edi
	cmp	eax, edi
	jne	SHORT $LN132@find_verte
	xor	edx, edx
	jmp	SHORT $LN133@find_verte
$LN132@find_verte:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN131@find_verte
	xor	eax, 134217728				; 08000000H
$LN131@find_verte:
	mov	edx, eax
$LN133@find_verte:

; 667  :          if ( equal_id(fe,get_next_facet(fe)) )

	mov	eax, DWORD PTR _web+460
	mov	esi, edx
	mov	ecx, edx
	shr	esi, 27					; 0000001bH
	and	ecx, 134217727				; 07ffffffH
	and	esi, 1
	mov	eax, DWORD PTR [eax+ecx*4]
	je	SHORT $LN136@find_verte
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN135@find_verte
$LN136@find_verte:
	mov	ecx, DWORD PTR [eax+40]
$LN135@find_verte:
	cmp	edx, ecx
	jne	SHORT $LN66@find_verte

; 668  :          { /* edge edge */
; 669  :            if ( !single_flag )

	cmp	DWORD PTR _single_flag$[ebp], edi
	jne	SHORT $LN239@find_verte

; 670  :            { /* first, so reset */
; 671  :               total_weight = 0.0;

	fst	QWORD PTR _total_weight$[ebp]

; 672  :               k = 0;

	mov	DWORD PTR _k$[ebp], edi

; 673  :               for ( i = 0 ; i < SDIM ; i++ ) xsum[i] = 0.0;

	cmp	DWORD PTR _web+616, edi
	jle	SHORT $LN239@find_verte

; 670  :            { /* first, so reset */
; 671  :               total_weight = 0.0;

	mov	ecx, DWORD PTR _web+616
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	lea	edi, DWORD PTR _xsum$[ebp]
	rep stosd
$LN239@find_verte:

; 674  :             }
; 675  :             single_flag++;

	inc	DWORD PTR _single_flag$[ebp]
	jmp	$LN221@find_verte
$LN66@find_verte:

; 676  :           }
; 677  :          else if ( !equal_id(get_next_facet(fe),get_prev_facet(fe)) )

	cmp	esi, edi
	je	SHORT $LN140@find_verte
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN139@find_verte
$LN140@find_verte:
	mov	ecx, DWORD PTR [eax+40]
$LN139@find_verte:
	cmp	esi, edi
	je	SHORT $LN144@find_verte
	mov	eax, DWORD PTR [eax+40]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN143@find_verte
$LN144@find_verte:
	mov	eax, DWORD PTR [eax+36]
$LN143@find_verte:
	cmp	ecx, eax
	je	SHORT $LN60@find_verte

; 678  :          { /* triple, at least */
; 679  :             if ( !triple_flag )

	cmp	DWORD PTR _triple_flag$[ebp], edi
	jne	SHORT $LN240@find_verte

; 680  :             { /* first, so reset */
; 681  :               total_weight = 0.0;

	fst	QWORD PTR _total_weight$[ebp]

; 682  :               k = 0;

	mov	DWORD PTR _k$[ebp], edi

; 683  :               for ( i = 0 ; i < SDIM ; i++ ) xsum[i] = 0.0;

	cmp	DWORD PTR _web+616, edi
	jle	SHORT $LN240@find_verte

; 680  :             { /* first, so reset */
; 681  :               total_weight = 0.0;

	mov	ecx, DWORD PTR _web+616
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	lea	edi, DWORD PTR _xsum$[ebp]
	rep stosd
$LN240@find_verte:

; 684  :             }
; 685  :             triple_flag++;

	mov	eax, DWORD PTR _triple_flag$[ebp]
	inc	eax
	mov	DWORD PTR _triple_flag$[ebp], eax

; 686  :             if ( triple_flag >= 3 ) return 0; /* too many triple lines */

	cmp	eax, 3
	jl	SHORT $LN221@find_verte
	fstp	ST(0)
$LN411@find_verte:
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 779  :   }
; 780  : 
; 781  : new_avg_exit:
; 782  : 
; 783  :   return 1;
; 784  : } // end find_vertex_average()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN60@find_verte:

; 687  :          }
; 688  :          else
; 689  :          { if ( triple_flag ) goto loopend; 

	cmp	DWORD PTR _triple_flag$[ebp], edi
	jne	$loopend$89742

; 690  :          }
; 691  :       }
; 692  : 
; 693  :       if ( (web.representation == STRING) || (get_eattr(e_id) & BARE_NAKED)
; 694  :                || single_flag || triple_flag )

	jmp	SHORT $LN221@find_verte
$LN53@find_verte:
	cmp	DWORD PTR _web+624, 1
	je	$LN365@find_verte
$LN221@find_verte:
	mov	esi, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 65536				; 00010000H
	xor	edx, edx
	or	eax, edx
	jne	$LN365@find_verte
	cmp	DWORD PTR _single_flag$[ebp], edx
	jne	$LN365@find_verte
	cmp	DWORD PTR _triple_flag$[ebp], edx
	jne	$LN365@find_verte

; 696  :       else
; 697  :       { fe = start_fe = get_edge_fe(e_id);

	test	ecx, ecx
	jne	SHORT $LN148@find_verte
	xor	edi, edi
	mov	DWORD PTR _start_fe$89712[ebp], edi
	jmp	SHORT $LN149@find_verte
$LN148@find_verte:
	mov	ecx, DWORD PTR [ecx+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN147@find_verte
	xor	ecx, 134217728				; 08000000H
$LN147@find_verte:
	mov	edi, ecx
	mov	DWORD PTR _start_fe$89712[ebp], ecx
$LN149@find_verte:

; 698  :         weight = 0.0;

	fst	QWORD PTR _weight$[ebp]

; 699  :         if ( valid_id(fe) )

	test	edi, 268435456				; 10000000H
	je	$loopend$89742
	jmp	SHORT $LN409@find_verte
$LN374@find_verte:

; 708  :              } while ( !equal_id(fe,start_fe) );

	fstp	ST(0)
$LN409@find_verte:
	fstp	ST(0)
	test	edi, 268435456				; 10000000H
	jne	SHORT $LN152@find_verte

; 700  :           do { facet_id f_id = get_fe_facet(fe);

	mov	ebx, DWORD PTR _NULLFACET
	jmp	SHORT $LN151@find_verte
$LN152@find_verte:
	mov	ecx, DWORD PTR _web+460
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ebx, DWORD PTR [edx+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN151@find_verte
	xor	ebx, 134217728				; 08000000H
$LN151@find_verte:

; 701  : 		       REAL a = get_facet_area(f_id);

	push	ebx
	call	_recalc_facet_area
	mov	eax, DWORD PTR _web+236
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	fld	QWORD PTR [ecx+40]
	add	esp, 4

; 702  : 		       if ( a == 0.0 ) 

	fld	ST(0)
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN45@find_verte

; 703  : 			   { (*calc_facet_energy)(f_id,AREA_ONLY);

	push	1
	fstp	ST(1)
	push	ebx
	fstp	ST(0)
	call	DWORD PTR _calc_facet_energy

; 704  : 			      a = get_facet_area(f_id);

	push	ebx
	call	_recalc_facet_area
	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR [esi+edx]
	fld	QWORD PTR [eax+40]
	add	esp, 12					; 0000000cH
	fldz
$LN45@find_verte:

; 705  : 			   }
; 706  : 		       weight += a;

	fxch	ST(1)
	fadd	QWORD PTR _weight$[ebp]
	fst	QWORD PTR _weight$[ebp]

; 707  :                fe = get_next_facet(fe);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN156@find_verte
	mov	ecx, DWORD PTR _web+460
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR [edx+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN47@find_verte
$LN156@find_verte:
	mov	eax, DWORD PTR _web+460
	and	edi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR [ecx+40]
$LN47@find_verte:

; 708  :              } while ( !equal_id(fe,start_fe) );

	cmp	edi, DWORD PTR _start_fe$89712[ebp]
	jne	$LN374@find_verte

; 709  :       }
; 710  :       if ( weight == 0.0 ) goto loopend;

	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$loopend$89742
	fstp	ST(0)
$LN222@find_verte:

; 711  :       get_edge_side(e_id,x);

	mov	eax, DWORD PTR _e_id$[ebp]
	lea	edx, DWORD PTR _x$[ebp]
	push	edx
	push	eax
	call	_get_edge_side

; 712  :       for ( i = 0 ; i < SDIM ; i++ ) xsum[i] += weight*weight*x[i];

	fld	QWORD PTR _weight$[ebp]
	mov	edx, DWORD PTR _web+616
	add	esp, 8
	xor	eax, eax
	cmp	edx, 4
	jl	SHORT $LC206@find_verte
	fld	ST(0)
	lea	ecx, DWORD PTR [edx-3]
	fmul	ST(0), ST(1)
$LN207@find_verte:
	fld	QWORD PTR _x$[ebp+eax*8]
	add	eax, 4
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _xsum$[ebp+eax*8-32]
	fstp	QWORD PTR _xsum$[ebp+eax*8-32]
	fld	QWORD PTR _x$[ebp+eax*8-24]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _xsum$[ebp+eax*8-24]
	fstp	QWORD PTR _xsum$[ebp+eax*8-24]
	fld	QWORD PTR _x$[ebp+eax*8-16]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _xsum$[ebp+eax*8-16]
	fstp	QWORD PTR _xsum$[ebp+eax*8-16]
	fld	QWORD PTR _x$[ebp+eax*8-8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _xsum$[ebp+eax*8-8]
	fstp	QWORD PTR _xsum$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LN207@find_verte
	fstp	ST(0)
$LC206@find_verte:
	cmp	eax, edx
	jge	SHORT $LN232@find_verte
	fld	ST(0)
	fmul	ST(0), ST(1)
$LC43@find_verte:
	fld	QWORD PTR _x$[ebp+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _xsum$[ebp+eax*8-8]
	fstp	QWORD PTR _xsum$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC43@find_verte
	fstp	ST(0)
$LN232@find_verte:

; 713  :       total_weight += weight*weight;
; 714  :       k++;

	inc	DWORD PTR _k$[ebp]
	fmul	ST(0), ST(0)
	fadd	QWORD PTR _total_weight$[ebp]
	fstp	QWORD PTR _total_weight$[ebp]
	fldz
$loopend$89742:

; 715  : loopend:
; 716  :       e_id = get_next_tail_edge(e_id);

	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	eax, DWORD PTR [eax+ecx*4+32]
	mov	DWORD PTR _e_id$[ebp], eax

; 717  :     } while ( !equal_id(e_id,start_e) );

	cmp	eax, DWORD PTR _start_e$[ebp]
	je	SHORT $LN293@find_verte
	mov	esi, DWORD PTR tv1537[ebp]
	mov	ebx, DWORD PTR _attr$[ebp]
	mov	edi, DWORD PTR _dymem
	jmp	$LN410@find_verte
$LN365@find_verte:

; 659  :         { 
; 660  :           if ( get_edge_boundary(e_id) != get_boundary(v_id) ) goto loopend;

	fstp	ST(0)

; 695  :           weight = 1.0;

	fld1
	fstp	QWORD PTR _weight$[ebp]

; 709  :       }
; 710  :       if ( weight == 0.0 ) goto loopend;

	jmp	$LN222@find_verte
$LN293@find_verte:

; 718  : 
; 719  :     if ( k <= 1 ) return 0;  /* only found at most one edge */

	cmp	DWORD PTR _k$[ebp], 1
	fstp	ST(0)
	jle	$LN411@find_verte

; 720  : 
; 721  :     if ( mode == VOLKEEP && !(attr & CONSTRAINT) )

	cmp	DWORD PTR _mode$[ebp], 1
	jne	$LN226@find_verte
	mov	eax, DWORD PTR _attr$[ebp]
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN226@find_verte

; 722  :      { /* project motion tangentially */
; 723  :         dm = new_calc_vertex_normal(v_id,norm);

	mov	edi, DWORD PTR _norm$[ebp]
	mov	ecx, DWORD PTR _v_id$GSCopy$[ebp]
	push	edi
	push	ecx
	call	_new_calc_vertex_normal

; 724  :         if ( dm < SDIM )

	mov	ecx, DWORD PTR _web+616
	add	esp, 8
	cmp	eax, ecx
	jge	$LN38@find_verte

; 725  :         { dm = gram_schmidt(norm,dm,SDIM);

	push	ecx
	push	eax
	push	edi
	call	_gram_schmidt
	add	esp, 12					; 0000000cH

; 726  :           for ( n = 0 ; n < dm ; n++ )

	test	eax, eax
	jle	$LN226@find_verte

; 725  :         { dm = gram_schmidt(norm,dm,SDIM);

	mov	DWORD PTR tv945[ebp], eax
	npad	6
$LL247@find_verte:

; 727  :           { REAL c = SDIM_dot(xsum,norm[n]);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [edi]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _xsum$[ebp]
	push	ecx
	call	_dot
	add	esp, 12					; 0000000cH

; 728  :              for ( i = 0 ; i < SDIM ; i++ ) 

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, 4
	jl	SHORT $LN236@find_verte

; 729  :                  xsum[i] -= c*norm[n][i];

	lea	eax, DWORD PTR _xsum$[ebp+8]
	mov	edx, 16					; 00000010H
	sub	edx, eax
	mov	eax, 24					; 00000018H
	lea	esi, DWORD PTR _xsum$[ebp+8]
	sub	eax, esi
	mov	DWORD PTR tv2941[ebp], eax
$LN210@find_verte:
	mov	esi, DWORD PTR [edi]
	fld	QWORD PTR [esi+ecx*8]
	lea	eax, DWORD PTR _xsum$[ebp+ecx*8+8]
	fmul	ST(0), ST(1)
	add	ecx, 4
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	esi, DWORD PTR [edi]
	fld	QWORD PTR [esi+ecx*8-24]
	lea	esi, DWORD PTR [edx+eax]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	ebx, DWORD PTR [edi]
	fld	QWORD PTR [esi+ebx]
	mov	esi, DWORD PTR tv2941[ebp]
	fmul	ST(0), ST(1)
	add	esi, eax
	fsubr	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	mov	ebx, DWORD PTR [edi]
	fld	QWORD PTR [esi+ebx]
	mov	ebx, DWORD PTR _web+616
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+16]
	lea	eax, DWORD PTR [ebx-3]
	cmp	ecx, eax
	jl	SHORT $LN210@find_verte
	jmp	SHORT $LC209@find_verte
$LN236@find_verte:
	mov	ebx, DWORD PTR _web+616
$LC209@find_verte:

; 728  :              for ( i = 0 ; i < SDIM ; i++ ) 

	cmp	ecx, ebx
	jge	SHORT $LN396@find_verte
$LC34@find_verte:

; 729  :                  xsum[i] -= c*norm[n][i];

	mov	edx, DWORD PTR [edi]
	fld	QWORD PTR [edx+ecx*8]
	inc	ecx
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR _xsum$[ebp+ecx*8-8]
	fstp	QWORD PTR _xsum$[ebp+ecx*8-8]
	cmp	ecx, ebx
	jl	SHORT $LC34@find_verte
$LN396@find_verte:

; 726  :           for ( n = 0 ; n < dm ; n++ )

	add	edi, 4

; 728  :              for ( i = 0 ; i < SDIM ; i++ ) 

	fstp	ST(0)
	dec	DWORD PTR tv945[ebp]
	jne	$LL247@find_verte

; 730  :           }
; 731  :         }
; 732  :         else for ( i = 0 ; i < SDIM ; i++ ) xsum[i] = 0.0; /* triple pt fixed */

	jmp	SHORT $LN226@find_verte
$LN38@find_verte:
	test	ecx, ecx
	jle	SHORT $LN226@find_verte
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	lea	edi, DWORD PTR _xsum$[ebp]
	rep stosd
$LN226@find_verte:

; 733  :      }
; 734  : 
; 735  :      if ( (attr & CONSTRAINT) )

	mov	eax, DWORD PTR _attr$[ebp]
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN229@find_verte

; 736  :      { unsigned int jj;
; 737  :        conmap_t * conmap = get_v_constraint_map(v_id);

	mov	eax, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	cmp	DWORD PTR [eax+edx+1288], ecx
	je	SHORT $LN117@find_verte
	mov	ecx, DWORD PTR tv1537[ebp]
	mov	esi, DWORD PTR _web+12
	mov	ecx, DWORD PTR [ecx+esi]
	add	ecx, DWORD PTR [eax+edx+1264]
	jmp	SHORT $LN118@find_verte
$LN117@find_verte:
	mov	ecx, OFFSET _nullcon
$LN118@find_verte:

; 738  :        int oncount = 0;

	xor	ebx, ebx

; 739  :        struct constraint *con[MAXCONHIT];
; 740  :        int conlist[MAXCONHIT];
; 741  :        REAL perp[MAXCOORD];
; 742  : 
; 743  :        for ( jj = 1 ; jj <= conmap[0] ; jj++ )

	mov	edx, 1
	mov	DWORD PTR _oncount$89815[ebp], ebx
	cmp	DWORD PTR [ecx], edx
	jb	SHORT $LN244@find_verte
	mov	esi, DWORD PTR _web+652
$LL26@find_verte:

; 744  :        { if ( (conmap[jj] & CON_HIT_BIT) && (oncount < web.sdim) )

	test	DWORD PTR [ecx+edx*4], -2147483648	; 80000000H
	je	SHORT $LN25@find_verte
	cmp	ebx, DWORD PTR _web+616
	jge	SHORT $LN25@find_verte

; 745  :          { conlist[oncount] = conmap[jj] & CONMASK;

	mov	eax, DWORD PTR [ecx+edx*4]
	and	eax, 1073741823				; 3fffffffH
	mov	DWORD PTR _conlist$89817[ebp+ebx*4], eax

; 746  :            con[oncount] = get_constraint(conmap[jj]);

	mov	eax, DWORD PTR [ecx+edx*4]
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, esi
	mov	DWORD PTR _con$89816[ebp+ebx*4], eax

; 747  :            if ( !(con[oncount]->attr & (NONNEGATIVE|NONPOSITIVE) ) )

	mov	eax, DWORD PTR [eax+32]
	and	eax, 3
	xor	edi, edi
	or	eax, edi
	jne	SHORT $LN25@find_verte

; 748  :               oncount++;  

	inc	ebx
$LN25@find_verte:

; 739  :        struct constraint *con[MAXCONHIT];
; 740  :        int conlist[MAXCONHIT];
; 741  :        REAL perp[MAXCOORD];
; 742  : 
; 743  :        for ( jj = 1 ; jj <= conmap[0] ; jj++ )

	inc	edx
	cmp	edx, DWORD PTR [ecx]
	jbe	SHORT $LL26@find_verte

; 748  :               oncount++;  

	mov	DWORD PTR _oncount$89815[ebp], ebx
$LN244@find_verte:

; 749  :          }
; 750  :        }
; 751  :        
; 752  :        constr_proj(TANGPROJ,oncount,con,vx,
; 753  :                         xsum,perp,conlist,NO_DETECT,v_id);

	mov	edi, DWORD PTR _v_id$GSCopy$[ebp]
	push	edi
	push	0
	lea	ecx, DWORD PTR _conlist$89817[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vx$GSCopy$[ebp]
	lea	edx, DWORD PTR _perp$89818[ebp]
	push	edx
	lea	eax, DWORD PTR _xsum$[ebp]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _con$89816[ebp]
	push	edx
	push	ebx
	push	2
	call	_constr_proj

; 754  :        for ( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR _web+616
	add	esp, 36					; 00000024H
	xor	eax, eax
	cmp	edx, 4
	jl	SHORT $LC212@find_verte
	lea	ecx, DWORD PTR [edx-3]
$LL213@find_verte:

; 755  :            xsum[j] -= perp[j];

	fld	QWORD PTR _xsum$[ebp+eax*8]
	add	eax, 4
	fsub	QWORD PTR _perp$89818[ebp+eax*8-32]
	fstp	QWORD PTR _xsum$[ebp+eax*8-32]
	fld	QWORD PTR _xsum$[ebp+eax*8-24]
	fsub	QWORD PTR _perp$89818[ebp+eax*8-24]
	fstp	QWORD PTR _xsum$[ebp+eax*8-24]
	fld	QWORD PTR _xsum$[ebp+eax*8-16]
	fsub	QWORD PTR _perp$89818[ebp+eax*8-16]
	fstp	QWORD PTR _xsum$[ebp+eax*8-16]
	fld	QWORD PTR _xsum$[ebp+eax*8-8]
	fsub	QWORD PTR _perp$89818[ebp+eax*8-8]
	fstp	QWORD PTR _xsum$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LL213@find_verte
$LC212@find_verte:

; 754  :        for ( j = 0 ; j < SDIM ; j++ )

	cmp	eax, edx
	jge	SHORT $LN249@find_verte
	npad	2
$LC21@find_verte:

; 755  :            xsum[j] -= perp[j];

	fld	QWORD PTR _xsum$[ebp+eax*8]
	inc	eax
	fsub	QWORD PTR _perp$89818[ebp+eax*8-8]
	fstp	QWORD PTR _xsum$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC21@find_verte
$LN249@find_verte:

; 756  : 
; 757  :        if ( mode == VOLKEEP)

	cmp	DWORD PTR _mode$[ebp], 1
	jne	$LN229@find_verte

; 758  :        { /* project motion tangentially */
; 759  :          dm = new_calc_vertex_normal(v_id,norm);

	mov	esi, DWORD PTR _norm$[ebp]
	push	esi
	push	edi
	call	_new_calc_vertex_normal

; 760  :          if ( dm < SDIM )

	mov	ecx, DWORD PTR _web+616
	add	esp, 8
	cmp	eax, ecx
	jge	$LN17@find_verte

; 761  :          { dm = gram_schmidt(norm,dm,SDIM);

	push	ecx
	push	eax
	push	esi
	call	_gram_schmidt
	add	esp, 12					; 0000000cH

; 762  :            for ( n = 0 ; n < dm ; n++ )

	test	eax, eax
	jle	$LN245@find_verte

; 761  :          { dm = gram_schmidt(norm,dm,SDIM);

	mov	edi, DWORD PTR _web+616
	mov	DWORD PTR tv73[ebp], eax
$LL16@find_verte:

; 763  :            { REAL c = SDIM_dot(xsum,norm[n]);

	mov	eax, DWORD PTR [esi]
	push	edi
	push	eax
	lea	ecx, DWORD PTR _xsum$[ebp]
	push	ecx
	call	_dot

; 764  :              for ( i = 0 ; i < SDIM ; i++ ) 

	mov	edi, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	xor	ecx, ecx
	cmp	edi, 4
	jl	SHORT $LN242@find_verte

; 765  :                  xsum[i] -= c*norm[n][i];

	lea	eax, DWORD PTR _xsum$[ebp+8]
	mov	edx, 16					; 00000010H
	sub	edx, eax
	mov	eax, 24					; 00000018H
	lea	edi, DWORD PTR _xsum$[ebp+8]
	sub	eax, edi
	mov	DWORD PTR tv2941[ebp], eax
$LN216@find_verte:
	mov	edi, DWORD PTR [esi]
	fld	QWORD PTR [edi+ecx*8]
	lea	eax, DWORD PTR _xsum$[ebp+ecx*8+8]
	fmul	ST(0), ST(1)
	add	ecx, 4
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	edi, DWORD PTR [esi]
	fld	QWORD PTR [edi+ecx*8-24]
	lea	edi, DWORD PTR [edx+eax]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	ebx, DWORD PTR [esi]
	fld	QWORD PTR [edi+ebx]
	mov	edi, DWORD PTR tv2941[ebp]
	fmul	ST(0), ST(1)
	add	edi, eax
	fsubr	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	mov	ebx, DWORD PTR [esi]
	fld	QWORD PTR [edi+ebx]
	mov	edi, DWORD PTR _web+616
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+16]
	lea	eax, DWORD PTR [edi-3]
	cmp	ecx, eax
	jl	SHORT $LN216@find_verte
	mov	ebx, DWORD PTR _oncount$89815[ebp]
$LN242@find_verte:

; 764  :              for ( i = 0 ; i < SDIM ; i++ ) 

	cmp	ecx, edi
	jge	SHORT $LN405@find_verte
$LC13@find_verte:

; 765  :                  xsum[i] -= c*norm[n][i];

	mov	edx, DWORD PTR [esi]
	fld	QWORD PTR [edx+ecx*8]
	inc	ecx
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR _xsum$[ebp+ecx*8-8]
	fstp	QWORD PTR _xsum$[ebp+ecx*8-8]
	cmp	ecx, edi
	jl	SHORT $LC13@find_verte
$LN405@find_verte:

; 762  :            for ( n = 0 ; n < dm ; n++ )

	add	esi, 4

; 764  :              for ( i = 0 ; i < SDIM ; i++ ) 

	fstp	ST(0)
	dec	DWORD PTR tv73[ebp]
	jne	$LL16@find_verte

; 766  :            }
; 767  :          }
; 768  :          else for ( i = 0 ; i < SDIM ; i++ ) xsum[i] = 0.0; /* triple pt fixed */

	jmp	SHORT $LN245@find_verte
$LN17@find_verte:
	test	ecx, ecx
	jle	SHORT $LN245@find_verte
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	lea	edi, DWORD PTR _xsum$[ebp]
	rep stosd
$LN245@find_verte:

; 769  :                 
; 770  :          constr_proj(TANGPROJ,oncount,con,vx,
; 771  :                         xsum,perp,conlist,NO_DETECT,v_id);

	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _conlist$89817[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vx$GSCopy$[ebp]
	lea	edx, DWORD PTR _perp$89818[ebp]
	push	edx
	lea	eax, DWORD PTR _xsum$[ebp]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _con$89816[ebp]
	push	edx
	push	ebx
	push	2
	call	_constr_proj

; 772  :          for ( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR _web+616
	add	esp, 36					; 00000024H
	xor	eax, eax
	cmp	edx, 4
	jl	SHORT $LC218@find_verte
	lea	ecx, DWORD PTR [edx-3]
	npad	10
$LL219@find_verte:

; 773  :            xsum[j] -= perp[j];

	fld	QWORD PTR _xsum$[ebp+eax*8]
	add	eax, 4
	fsub	QWORD PTR _perp$89818[ebp+eax*8-32]
	fstp	QWORD PTR _xsum$[ebp+eax*8-32]
	fld	QWORD PTR _xsum$[ebp+eax*8-24]
	fsub	QWORD PTR _perp$89818[ebp+eax*8-24]
	fstp	QWORD PTR _xsum$[ebp+eax*8-24]
	fld	QWORD PTR _xsum$[ebp+eax*8-16]
	fsub	QWORD PTR _perp$89818[ebp+eax*8-16]
	fstp	QWORD PTR _xsum$[ebp+eax*8-16]
	fld	QWORD PTR _xsum$[ebp+eax*8-8]
	fsub	QWORD PTR _perp$89818[ebp+eax*8-8]
	fstp	QWORD PTR _xsum$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LL219@find_verte
$LC218@find_verte:

; 772  :          for ( j = 0 ; j < SDIM ; j++ )

	cmp	eax, edx
	jge	SHORT $LN229@find_verte
	npad	2
$LC6@find_verte:

; 773  :            xsum[j] -= perp[j];

	fld	QWORD PTR _xsum$[ebp+eax*8]
	inc	eax
	fsub	QWORD PTR _perp$89818[ebp+eax*8-8]
	fstp	QWORD PTR _xsum$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC6@find_verte
$LN229@find_verte:

; 774  :        }  
; 775  :      }
; 776  : 
; 777  :      for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $new_avg_exit$89694
	mov	eax, DWORD PTR _vx$GSCopy$[ebp]
	fld	QWORD PTR __real@3fd0000000000000
	fld	QWORD PTR _total_weight$[ebp]
	lea	edx, DWORD PTR _xsum$[ebp]
	sub	edx, eax
$LN3@find_verte:

; 778  :          vx[i] += 0.25*xsum[i]/total_weight;

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(2)
	add	eax, 8
	fdiv	ST(0), ST(1)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN3@find_verte
$LN407@find_verte:

; 774  :        }  
; 775  :      }
; 776  : 
; 777  :      for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(1)
$LN408@find_verte:
	fstp	ST(0)
$new_avg_exit$89694:

; 779  :   }
; 780  : 
; 781  : new_avg_exit:
; 782  : 
; 783  :   return 1;
; 784  : } // end find_vertex_average()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	mov	eax, 1
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_find_vertex_average ENDP
_TEXT	ENDS
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_new_vertex_average
EXTRN	_project_v_constr:PROC
EXTRN	_b_extrapolate:PROC
; Function compile flags: /Ogtp
;	COMDAT _new_vertex_average
_TEXT	SEGMENT
_attr$ = -64						; size = 8
_v_id$GSCopy$ = -56					; size = 4
_newx$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_mode$ = 12						; size = 4
_new_vertex_average PROC				; COMDAT

; 537  : { REAL newx[MAXCOORD];

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _v_id$[ebp]

; 538  :   REAL *x;
; 539  :   int i;
; 540  :   ATTR attr = get_vattr(v_id);

	mov	ecx, DWORD PTR _web+12
	push	ebx
	push	esi
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+ecx]
	mov	edx, DWORD PTR [ecx+12]
	mov	ebx, DWORD PTR [ecx+8]

; 541  :   int retval;
; 542  : 
; 543  :   retval = find_vertex_average(v_id,newx,mode);

	mov	ecx, DWORD PTR _mode$[ebp]
	mov	DWORD PTR _attr$[ebp+4], edx
	push	ecx
	lea	edx, DWORD PTR _newx$[ebp]
	push	edx
	push	eax
	mov	DWORD PTR _v_id$GSCopy$[ebp], eax
	mov	DWORD PTR _attr$[ebp], ebx
	call	_find_vertex_average
	add	esp, 12					; 0000000cH

; 544  :   if ( retval == 0 ) return 0;

	test	eax, eax
	jne	SHORT $LN7@new_vertex
	pop	esi
	pop	ebx

; 555  :   }
; 556  :   return 1;
; 557  : } // end new_vertex_average()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@new_vertex:

; 545  :   x = get_coord(v_id);

	mov	eax, DWORD PTR _web+12
	mov	edx, DWORD PTR [esi+eax]
	mov	ecx, DWORD PTR _dymem
	push	edi
	mov	edi, DWORD PTR _web+104
	mov	ecx, DWORD PTR [edi+ecx+64]

; 546  :   if (attr & BOUNDARY )

	mov	eax, ebx
	and	eax, 128				; 00000080H
	xor	ebx, ebx
	add	ecx, edx
	or	eax, ebx
	je	SHORT $LN6@new_vertex

; 547  :   { /* update boundary parameter to agree with coordinates */
; 548  :     b_extrapolate(get_boundary(v_id),x,newx,newx,get_param(v_id),
; 549  :      get_param(v_id),v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN10@new_vertex
	mov	ebx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, edi
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	eax, DWORD PTR [eax+edx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN11@new_vertex
$LN10@new_vertex:
	xor	eax, eax
$LN11@new_vertex:
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edi+edx+544]
	mov	edi, DWORD PTR _web+12
	mov	esi, DWORD PTR [esi+edi]
	add	edx, esi
	mov	esi, DWORD PTR _v_id$GSCopy$[ebp]
	push	esi
	push	edx
	push	edx
	lea	edx, DWORD PTR _newx$[ebp]
	push	edx
	push	edx
	push	ecx
	push	eax
	call	_b_extrapolate
	add	esp, 28					; 0000001cH

; 550  :   }
; 551  :   else

	jmp	SHORT $LN1@new_vertex
$LN6@new_vertex:

; 552  :   { for ( i = 0 ; i < SDIM ; i++ ) x[i] = newx[i];

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN2@new_vertex
	lea	esi, DWORD PTR _newx$[ebp]
	mov	eax, ecx
	sub	esi, ecx
$LL4@new_vertex:
	fld	QWORD PTR [esi+eax]
	inc	edx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL4@new_vertex
$LN2@new_vertex:

; 553  :       if (attr & CONSTRAINT )

	mov	eax, DWORD PTR _attr$[ebp]
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN1@new_vertex

; 554  :         project_v_constr(v_id,ACTUAL_MOVE,RESET_ONESIDEDNESS);

	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	1
	push	1
	push	eax
	call	_project_v_constr
	add	esp, 12					; 0000000cH
$LN1@new_vertex:

; 555  :   }
; 556  :   return 1;
; 557  : } // end new_vertex_average()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	mov	eax, 1
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_new_vertex_average ENDP
_TEXT	ENDS
PUBLIC	__real@c008000000000000
PUBLIC	??_C@_0EG@FGAGAFNF@Vertex?5averaging?5mode?5V?5not?5impl@ ; `string'
PUBLIC	??_C@_08FBJKBDLA@VERAVG?4C?$AA@			; `string'
PUBLIC	??_C@_0CM@FKAKICBC@No?5vertex?5averaging?5in?5Lagrange?5@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_old_vertex_average
EXTRN	_temp_free:PROC
EXTRN	_kb_temp_calloc:PROC
;	COMDAT __real@c008000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@c008000000000000 DQ 0c008000000000000r	; -3
CONST	ENDS
;	COMDAT ??_C@_0EG@FGAGAFNF@Vertex?5averaging?5mode?5V?5not?5impl@
CONST	SEGMENT
??_C@_0EG@FGAGAFNF@Vertex?5averaging?5mode?5V?5not?5impl@ DB 'Vertex aver'
	DB	'aging mode V not implemented for simplex model. Use rawv.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08FBJKBDLA@VERAVG?4C?$AA@
CONST	SEGMENT
??_C@_08FBJKBDLA@VERAVG?4C?$AA@ DB 'VERAVG.C', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FKAKICBC@No?5vertex?5averaging?5in?5Lagrange?5@
CONST	SEGMENT
??_C@_0CM@FKAKICBC@No?5vertex?5averaging?5in?5Lagrange?5@ DB 'No vertex a'
	DB	'veraging in Lagrange model yet.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\veravg.c
CONST	ENDS
;	COMDAT _old_vertex_average
_TEXT	SEGMENT
tv2748 = -80						; size = 4
tv2651 = -80						; size = 4
_v_id$ = -76						; size = 4
tv3048 = -72						; size = 8
tv2695 = -72						; size = 8
tv909 = -72						; size = 8
_numer$89214 = -72					; size = 8
tv1120 = -68						; size = 4
tv961 = -68						; size = 4
_x$ = -64						; size = 4
tv902 = -60						; size = 4
tv2750 = -56						; size = 4
tv2747 = -56						; size = 4
tv2745 = -56						; size = 4
tv900 = -56						; size = 4
_next_e$89227 = -56					; size = 4
_xbar$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_mode$ = 8						; size = 4
_old_vertex_average PROC				; COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 92   :   facet_id f_id;
; 93   :   edge_id e_id;
; 94   :   vertex_id v_id;
; 95   :   REAL *x;
; 96   :   struct averages *ave;
; 97   :   int i;
; 98   :   REAL xbar[MAXCOORD];
; 99   :   REAL lambda;
; 100  : 
; 101  :   if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	jne	SHORT $LN85@old_vertex

; 102  :      kb_error(1379,"No vertex averaging in Lagrange model yet.\n",RECOVERABLE );

	push	1
	push	OFFSET ??_C@_0CM@FKAKICBC@No?5vertex?5averaging?5in?5Lagrange?5@
	push	1379					; 00000563H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN85@old_vertex:

; 103  : 
; 104  : 
; 105  :   if ( web.skel[VERTEX].count == 0 ) return;

	cmp	DWORD PTR _web+64, 0
	je	$LN86@old_vertex

; 106  : 
; 107  :   average = (struct averages *)temp_calloc(web.skel[VERTEX].max_ord+1,
; 108  :                                                   sizeof(struct averages));

	mov	eax, DWORD PTR _web+68
	push	ebx
	push	esi
	push	edi
	push	108					; 0000006cH
	push	OFFSET ??_C@_08FBJKBDLA@VERAVG?4C?$AA@
	inc	eax
	push	120					; 00000078H
	push	eax
	call	_kb_temp_calloc

; 109  :   FOR_ALL_VERTICES(v_id)

	mov	esi, DWORD PTR _web+48
	mov	edx, esi
	shr	edx, 28					; 0000001cH
	add	esp, 16					; 00000010H
	and	edx, 1
	mov	DWORD PTR _average, eax
	je	SHORT $LN135@old_vertex
	mov	ebx, DWORD PTR _web+12
$LL83@old_vertex:
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+esi*4]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv909[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN82@old_vertex

; 110  :       if ( get_vattr(v_id) & (FIXED|BOUNDARY) ) average[loc_ordinal(v_id)].status = -10;

	and	ecx, 192				; 000000c0H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN82@old_vertex
	test	edx, edx
	je	SHORT $LN88@old_vertex
	mov	eax, esi
	jmp	SHORT $LN89@old_vertex
$LN88@old_vertex:
	or	eax, -1
$LN89@old_vertex:
	mov	edx, DWORD PTR _average
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	mov	DWORD PTR [edx+ecx*8+104], -10		; fffffff6H
	mov	ebx, DWORD PTR _web+12
$LN82@old_vertex:

; 109  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [ebx+esi*4]
	mov	esi, DWORD PTR [eax]
	mov	edx, esi
	shr	edx, 28					; 0000001cH
	and	edx, 1
	jne	SHORT $LL83@old_vertex
$LN135@old_vertex:

; 111  : 
; 112  :   /* accumulate data on neighbors and weights */
; 113  :   if ( web.representation == SIMPLEX )

	mov	eax, DWORD PTR _web+624
	mov	ebx, DWORD PTR _mode$[ebp]
	cmp	eax, 3
	jne	SHORT $LN77@old_vertex

; 114  :   { if ( mode == VOLKEEP )

	cmp	ebx, 1
	jne	SHORT $LN76@old_vertex

; 115  :       kb_error(1380,
; 116  :       "Vertex averaging mode V not implemented for simplex model. Use rawv.\n",
; 117  :                  RECOVERABLE);

	push	ebx
	push	OFFSET ??_C@_0EG@FGAGAFNF@Vertex?5averaging?5mode?5V?5not?5impl@
	push	1380					; 00000564H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN76@old_vertex:

; 118  :     FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR _web+272
	test	ecx, 268435456				; 10000000H
	je	$LN136@old_vertex
	mov	edi, DWORD PTR _web+236
	npad	5
$LL75@old_vertex:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN74@old_vertex

; 119  :       simplex_facet_average(f_id,mode);

	push	ebx
	push	ecx
	call	_simplex_facet_average
	mov	edi, DWORD PTR _web+236
	add	esp, 8
$LN74@old_vertex:

; 118  :     FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR [esi+edi]
	mov	ecx, DWORD PTR [ecx]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL75@old_vertex

; 120  :   } 
; 121  :   else if ( web.representation == SOAPFILM )

	jmp	$LN136@old_vertex
$LN77@old_vertex:
	cmp	eax, 2
	jne	SHORT $LN69@old_vertex

; 122  :   { FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR _web+272
	test	ecx, 268435456				; 10000000H
	je	$LN151@old_vertex
	mov	edi, DWORD PTR _web+236
	npad	6
$LL68@old_vertex:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN67@old_vertex

; 123  :       facet_average(f_id,mode);

	push	ebx
	push	ecx
	call	_facet_average
	mov	edi, DWORD PTR _web+236
	add	esp, 8
$LN67@old_vertex:

; 122  :   { FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR [esi+edi]
	mov	ecx, DWORD PTR [edx]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL68@old_vertex

; 124  :   } 
; 125  :   else if ( web.representation == STRING )

	jmp	SHORT $LN136@old_vertex
$LN69@old_vertex:
	cmp	eax, 1
	jne	SHORT $LN151@old_vertex

; 126  :   { FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+160
	test	ecx, 268435456				; 10000000H
	je	$LN139@old_vertex
$LL61@old_vertex:
	mov	eax, DWORD PTR _web+124
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN60@old_vertex

; 127  :      edge_average(e_id,mode);

	push	ebx
	push	ecx
	call	_edge_average
	add	esp, 8
$LN60@old_vertex:

; 126  :   { FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR [edx]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL61@old_vertex
$LN136@old_vertex:

; 128  :   } 
; 129  : 
; 130  :   /* move vertices */
; 131  :   if ( web.representation != STRING )

	cmp	DWORD PTR _web+624, 1
	je	$LN139@old_vertex
$LN151@old_vertex:

; 132  :   { FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	DWORD PTR _v_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv900[ebp], eax
	je	$LN142@old_vertex
	mov	edi, DWORD PTR _web+616
	mov	esi, DWORD PTR _v_id$[ebp]
	npad	5
$LL144@old_vertex:
	mov	eax, DWORD PTR _web+12
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv909[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv902[ebp], esi
	je	$LN54@old_vertex

; 133  :     {
; 134  :       if ( get_vattr(v_id) & (FIXED|BOUNDARY) ) continue;

	and	ecx, 192				; 000000c0H
	xor	eax, eax
	or	ecx, eax
	jne	$LN54@old_vertex

; 135  :       ave = average + loc_ordinal(v_id);

	cmp	DWORD PTR tv900[ebp], eax
	jne	SHORT $LN91@old_vertex
	or	esi, -1
$LN91@old_vertex:
	mov	eax, DWORD PTR _average
	mov	ecx, esi
	shl	ecx, 4
	sub	ecx, esi

; 136  :       if (ave->status <= 0 ) continue;

	cmp	DWORD PTR [eax+ecx*8+104], ebx
	lea	esi, DWORD PTR [eax+ecx*8]
	jle	$LN54@old_vertex

; 137  :       if (ave->area == 0.0 ) continue;

	fld	QWORD PTR [esi+96]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN54@old_vertex

; 138  :       if (ave->triples == 1 ) continue;

	cmp	DWORD PTR [esi+108], 1
	je	$LN54@old_vertex

; 139  :       x = get_coord(v_id);

	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ecx+64]
	add	eax, edx

; 140  :       for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	mov	DWORD PTR _x$[ebp], eax
	cmp	edi, 4
	jl	SHORT $LN145@old_vertex

; 141  :           xbar[i] = ave->x[i]/ave->area;

	mov	edx, esi
	neg	edx
	lea	ebx, DWORD PTR _xbar$[ebp+edx]
	lea	edx, DWORD PTR _xbar$[ebp+edx+8]
	lea	eax, DWORD PTR [esi+16]
	mov	DWORD PTR tv2745[ebp], edx
$LL147@old_vertex:
	fld	QWORD PTR [eax-16]
	mov	edx, DWORD PTR tv2745[ebp]
	fdiv	QWORD PTR [esi+96]
	add	ecx, 4
	add	eax, 32					; 00000020H
	fstp	QWORD PTR _xbar$[ebp+ecx*8-32]
	fld	QWORD PTR [eax-40]
	fdiv	QWORD PTR [esi+96]
	fstp	QWORD PTR _xbar$[ebp+ecx*8-24]
	fld	QWORD PTR [eax-32]
	fdiv	QWORD PTR [esi+96]
	fstp	QWORD PTR [ebx+eax-32]
	fld	QWORD PTR [eax-24]
	fdiv	QWORD PTR [esi+96]
	fstp	QWORD PTR [edx+eax-32]
	lea	edx, DWORD PTR [edi-3]
	cmp	ecx, edx
	jl	SHORT $LL147@old_vertex
$LN145@old_vertex:

; 140  :       for ( i = 0 ; i < SDIM ; i++ )

	cmp	ecx, edi
	jge	SHORT $LN152@old_vertex
	mov	eax, esi
	lea	edx, DWORD PTR _xbar$[ebp]
	sub	eax, edx
$LC46@old_vertex:
	lea	edx, DWORD PTR [eax+ecx*8]

; 141  :           xbar[i] = ave->x[i]/ave->area;

	fld	QWORD PTR _xbar$[ebp+edx]
	inc	ecx
	fdiv	QWORD PTR [esi+96]
	fstp	QWORD PTR _xbar$[ebp+ecx*8-8]
	cmp	ecx, edi
	jl	SHORT $LC46@old_vertex
$LN152@old_vertex:

; 142  : 
; 143  :       if ( mode == VOLKEEP )

	cmp	DWORD PTR _mode$[ebp], 1
	jne	$LN138@old_vertex

; 144  :       { REAL numer;
; 145  :         /* volume preserving projection */
; 146  :         numer = SDIM_dot(ave->normal,xbar) 
; 147  :                     - SDIM_dot(ave->normal,x);

	push	edi
	lea	eax, DWORD PTR _xbar$[ebp]
	push	eax
	lea	ebx, DWORD PTR [esi+48]
	push	ebx
	call	_dot
	fstp	QWORD PTR tv2695[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _x$[ebp]
	push	ecx
	push	edx
	push	ebx
	call	_dot
	fsubr	QWORD PTR tv2695[ebp]
	add	esp, 24					; 00000018H
	fst	QWORD PTR _numer$89214[ebp]

; 148  :         if ( numer != 0.0 ) /* in case ave->normal == 0 */

	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jnp	SHORT $LN41@old_vertex

; 149  :            lambda = numer/SDIM_dot(ave->normal,ave->normal);

	mov	eax, DWORD PTR _web+616
	fstp	ST(0)
	push	eax
	push	ebx
	push	ebx
	call	_dot
	fdivr	QWORD PTR _numer$89214[ebp]
	add	esp, 12					; 0000000cH
$LN41@old_vertex:

; 150  :         else lambda = 0.0;
; 151  :         if  ( ave->triples > 0 ) /* along edge */

	cmp	DWORD PTR [esi+108], 0

; 152  :            for ( i = 0 ; i < SDIM ; i++ )

	mov	edi, DWORD PTR _web+616
	jle	$LN40@old_vertex
	xor	ecx, ecx
	cmp	edi, 4
	jl	SHORT $LC129@old_vertex
	mov	ebx, DWORD PTR _x$[ebp]
	lea	eax, DWORD PTR [ebx+16]

; 153  :              xbar[i] = x[i] + lambda*ave->normal[i];

	neg	ebx
	mov	DWORD PTR tv2747[ebp], ebx
	lea	ebx, DWORD PTR _xbar$[ebp+ebx]
	mov	DWORD PTR tv2748[ebp], ebx
	mov	ebx, DWORD PTR tv2747[ebp]
	lea	ebx, DWORD PTR _xbar$[ebp+ebx+8]
	lea	edx, DWORD PTR [esi+56]
	mov	DWORD PTR tv2750[ebp], ebx
$LN130@old_vertex:
	fld	QWORD PTR [edx-8]
	mov	ebx, DWORD PTR tv2748[ebp]
	fmul	ST(0), ST(1)
	add	ecx, 4
	add	edx, 32					; 00000020H
	add	eax, 32					; 00000020H
	fadd	QWORD PTR [eax-48]
	fstp	QWORD PTR _xbar$[ebp+ecx*8-32]
	fld	QWORD PTR [edx-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR _xbar$[ebp+ecx*8-24]
	fld	QWORD PTR [edx-24]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv2750[ebp]
	fld	QWORD PTR [edx-16]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [ebx+eax-32]
	lea	ebx, DWORD PTR [edi-3]
	cmp	ecx, ebx
	jl	SHORT $LN130@old_vertex
$LC129@old_vertex:

; 152  :            for ( i = 0 ; i < SDIM ; i++ )

	cmp	ecx, edi
	jge	$LN178@old_vertex
	mov	eax, DWORD PTR _x$[ebp]
	lea	edx, DWORD PTR _xbar$[ebp]
	lea	esi, DWORD PTR [esi+ecx*8+48]
	sub	eax, edx
$LC39@old_vertex:

; 153  :              xbar[i] = x[i] + lambda*ave->normal[i];

	fld	QWORD PTR [esi]
	lea	edx, DWORD PTR [eax+ecx*8]
	fmul	ST(0), ST(1)
	inc	ecx
	add	esi, 8
	fadd	QWORD PTR _xbar$[ebp+edx]
	fstp	QWORD PTR _xbar$[ebp+ecx*8-8]
	cmp	ecx, edi
	jl	SHORT $LC39@old_vertex

; 154  :         else /* subtract normal component */

	jmp	SHORT $LN178@old_vertex
$LN40@old_vertex:

; 155  :            for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	cmp	edi, 4
	jl	SHORT $LC132@old_vertex
	lea	edx, DWORD PTR [edi-3]
	lea	ecx, DWORD PTR [esi+56]
$LN133@old_vertex:

; 156  :              xbar[i] -= lambda*ave->normal[i];

	fld	QWORD PTR [ecx-8]
	add	eax, 4
	fmul	ST(0), ST(1)
	add	ecx, 32					; 00000020H
	fsubr	QWORD PTR _xbar$[ebp+eax*8-32]
	fstp	QWORD PTR _xbar$[ebp+eax*8-32]
	fld	QWORD PTR [ecx-32]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR _xbar$[ebp+eax*8-24]
	fstp	QWORD PTR _xbar$[ebp+eax*8-24]
	fld	QWORD PTR [ecx-24]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR _xbar$[ebp+eax*8-16]
	fstp	QWORD PTR _xbar$[ebp+eax*8-16]
	fld	QWORD PTR [ecx-16]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR _xbar$[ebp+eax*8-8]
	fstp	QWORD PTR _xbar$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LN133@old_vertex
$LC132@old_vertex:

; 155  :            for ( i = 0 ; i < SDIM ; i++ )

	cmp	eax, edi
	jge	SHORT $LN178@old_vertex
	lea	esi, DWORD PTR [esi+eax*8+48]
$LC35@old_vertex:

; 156  :              xbar[i] -= lambda*ave->normal[i];

	fld	ST(0)
	inc	eax
	fmul	QWORD PTR [esi]
	add	esi, 8
	fsubr	QWORD PTR _xbar$[ebp+eax*8-8]
	fstp	QWORD PTR _xbar$[ebp+eax*8-8]
	cmp	eax, edi
	jl	SHORT $LC35@old_vertex
$LN178@old_vertex:

; 155  :            for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN138@old_vertex:

; 157  :       }
; 158  :       /* tends to round off sharp vertices, I hope */
; 159  :       if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	$LN29@old_vertex

; 160  :       { REAL *xm;
; 161  :         edge_id next_e;
; 162  :         { next_e = e_id = get_vertex_edge(v_id);

	mov	eax, DWORD PTR tv902[ebp]
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _next_e$89227[ebp], eax
	or	eax, 134217728				; 08000000H

; 166  :                xm[i] += (xbar[i]-x[i])/2;

	mov	DWORD PTR tv1120[ebp], eax
	npad	5
$LL31@old_vertex:

; 163  :           do
; 164  :           { xm = get_coord(get_edge_midv(next_e));

	mov	ecx, DWORD PTR _next_e$89227[ebp]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+124
	mov	esi, DWORD PTR _web+216
	mov	esi, DWORD PTR [esi+edx+304]
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [eax+esi+8]
	mov	esi, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+104
	add	eax, DWORD PTR [esi+edx+64]

; 165  :             for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN150@old_vertex
	mov	edx, DWORD PTR _x$[ebp]
	lea	ebx, DWORD PTR _xbar$[ebp]
	sub	ebx, edx
	sub	edx, eax
	mov	DWORD PTR tv2651[ebp], edx
$LL28@old_vertex:

; 166  :                xm[i] += (xbar[i]-x[i])/2;

	mov	edx, DWORD PTR tv2651[ebp]
	add	edx, eax
	fld	QWORD PTR [ebx+edx]
	inc	esi
	fsub	QWORD PTR [edx]
	add	eax, 8
	fmul	QWORD PTR __real@3fe0000000000000
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	edi, DWORD PTR _web+616
	cmp	esi, edi
	jl	SHORT $LL28@old_vertex
$LN150@old_vertex:

; 167  :             next_e = get_next_tail_edge(next_e);

	mov	eax, DWORD PTR _next_e$89227[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ecx+edx]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	eax, DWORD PTR [ecx+eax*4+32]
	mov	DWORD PTR _next_e$89227[ebp], eax

; 168  :           }
; 169  :           while ( !equal_element(next_e,e_id) );

	or	eax, 134217728				; 08000000H
	cmp	eax, DWORD PTR tv1120[ebp]
	jne	$LL31@old_vertex
$LN29@old_vertex:

; 170  :         }
; 171  :       }
; 172  :       for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN148@old_vertex
	mov	eax, DWORD PTR _x$[ebp]
	lea	edx, DWORD PTR _xbar$[ebp]
	sub	edx, eax
$LL25@old_vertex:

; 173  :          x[i] = xbar[i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	mov	edi, DWORD PTR _web+616
	add	eax, 8
	cmp	ecx, edi
	jl	SHORT $LL25@old_vertex
$LN148@old_vertex:

; 174  : 
; 175  :       if ( get_vattr(v_id) & CONSTRAINT )

	mov	edx, DWORD PTR tv902[ebp]
	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN54@old_vertex

; 176  :         project_v_constr(v_id,ACTUAL_MOVE,RESET_ONESIDEDNESS);

	mov	ecx, DWORD PTR _v_id$[ebp]
	push	1
	push	1
	push	ecx
	call	_project_v_constr
	mov	edi, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
$LN54@old_vertex:

; 132  :   { FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	edx, DWORD PTR tv902[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	esi, DWORD PTR [ecx]
	mov	eax, esi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _v_id$[ebp], esi
	mov	DWORD PTR tv900[ebp], eax
	jne	$LL144@old_vertex

; 177  :     }
; 178  : 
; 179  :   }
; 180  :   else /* string */

	jmp	$LN142@old_vertex
$LN139@old_vertex:

; 181  :   { FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	je	$LN142@old_vertex
	mov	ebx, DWORD PTR _web+616
$LL20@old_vertex:
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv902[ebp], eax
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN19@old_vertex

; 182  :     {
; 183  :       ave = average + loc_ordinal(v_id);

	test	ecx, ecx
	je	SHORT $LN92@old_vertex
	mov	eax, DWORD PTR tv902[ebp]
	jmp	SHORT $LN93@old_vertex
$LN92@old_vertex:
	or	eax, -1
$LN93@old_vertex:
	mov	edx, DWORD PTR _average
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	lea	edx, DWORD PTR [edx+ecx*8]

; 184  :       if (ave->status != 2 ) continue; /* too many edges or something */

	cmp	DWORD PTR [edx+104], 2
	lea	eax, DWORD PTR [edx+104]
	mov	DWORD PTR tv961[ebp], eax
	jne	SHORT $LN19@old_vertex

; 185  :       x = get_coord(v_id);

	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+ecx+64]
	add	esi, edi

; 186  : 
; 187  :       if ( mode == VOLKEEP )

	cmp	DWORD PTR _mode$[ebp], 1
	jne	$LN14@old_vertex

; 188  :       { /* ave->normal really tangent */
; 189  :          /* area preserving projection */
; 190  :          lambda = - SDIM_dot(ave->normal,ave->x)/3 /* prevent overshoot */
; 191  :                         /SDIM_dot(ave->normal,ave->normal);

	push	ebx
	lea	edi, DWORD PTR [edx+48]
	push	edx
	push	edi
	call	_dot
	fdiv	QWORD PTR __real@c008000000000000
	mov	edx, DWORD PTR _web+616
	push	edx
	push	edi
	push	edi
	fstp	QWORD PTR tv3048[ebp]
	call	_dot
	fdivr	QWORD PTR tv3048[ebp]

; 192  :          for ( i = 0 ; i < SDIM ; i++ )

	mov	ebx, DWORD PTR _web+616
	add	esp, 24					; 00000018H
	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN180@old_vertex

; 188  :       { /* ave->normal really tangent */
; 189  :          /* area preserving projection */
; 190  :          lambda = - SDIM_dot(ave->normal,ave->x)/3 /* prevent overshoot */
; 191  :                         /SDIM_dot(ave->normal,ave->normal);

	mov	ecx, edi
$LN13@old_vertex:

; 193  :             x[i] -=  lambda*ave->normal[i];

	fld	QWORD PTR [ecx]
	inc	eax
	fmul	ST(0), ST(1)
	add	ecx, 8
	fsubr	QWORD PTR [esi+eax*8-8]
	fstp	QWORD PTR [esi+eax*8-8]
	mov	ebx, DWORD PTR _web+616
	cmp	eax, ebx
	jl	SHORT $LN13@old_vertex
$LN180@old_vertex:

; 194  :       }
; 195  :       else
; 196  :       {
; 197  :          for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN19@old_vertex:

; 181  :   { FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR tv902[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx]
	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LL20@old_vertex
$LN142@old_vertex:

; 199  :       }
; 200  :     }
; 201  :   }
; 202  : 
; 203  :   if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	SHORT $LN3@old_vertex

; 204  :   { FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+160
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@old_vertex
	mov	ecx, DWORD PTR _web+124
	npad	3
$LL5@old_vertex:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN4@old_vertex

; 205  :        new_vertex_average(get_edge_midv(e_id),VOLKEEP);

	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	eax, DWORD PTR [edx+eax+304]
	mov	ecx, DWORD PTR [eax+ecx+8]
	push	1
	push	ecx
	call	_new_vertex_average
	add	esp, 8
$LN4@old_vertex:

; 204  :   { FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL5@old_vertex
$LN3@old_vertex:

; 206  :   }
; 207  : 
; 208  :   temp_free((char *)average);

	mov	eax, DWORD PTR _average
	push	eax
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
$LN86@old_vertex:

; 209  : 
; 210  :   /* recalculation responsibility of caller */
; 211  : } /* end old_vertex_average() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@old_vertex:

; 194  :       }
; 195  :       else
; 196  :       {
; 197  :          for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	test	ebx, ebx
	jle	$LN19@old_vertex
	mov	eax, esi
	sub	edx, esi
	mov	esi, DWORD PTR tv961[ebp]
	npad	4
$LL9@old_vertex:

; 198  :             x[i] +=  ave->x[i]/ave->status/2;  /* avoid overshoot */

	fild	DWORD PTR [esi]
	inc	ecx
	add	eax, 8
	fdivr	QWORD PTR [edx+eax-8]
	fmul	QWORD PTR __real@3fe0000000000000
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	ebx, DWORD PTR _web+616
	cmp	ecx, ebx
	jl	SHORT $LL9@old_vertex

; 194  :       }
; 195  :       else
; 196  :       {
; 197  :          for ( i = 0 ; i < SDIM ; i++ )

	jmp	$LN19@old_vertex
_old_vertex_average ENDP
_TEXT	ENDS
PUBLIC	_vertex_average
; Function compile flags: /Ogtp
;	COMDAT _vertex_average
_TEXT	SEGMENT
tv428 = -20						; size = 8
_attr$89091 = -20					; size = 8
tv419 = -12						; size = 4
_v_id$ = -8						; size = 4
tv421 = -4						; size = 4
_mode$ = 8						; size = 4
_vertex_average PROC					; COMDAT

; 34   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 35   :   REAL *x;
; 36   :   vertex_id v_id;
; 37   :   int i;
; 38   :  
; 39   :   #ifdef MPI_EVOLVER
; 40   :   if ( this_task == 0 )
; 41   :     mpi_vertex_average(mode);
; 42   :   #endif
; 43   : 
; 44   :   if ( web.skel[VERTEX].count == 0 ) return;

	cmp	DWORD PTR _web+64, 0
	je	$LN25@vertex_ave

; 45   : 
; 46   :   average = (struct averages *)temp_calloc(web.skel[VERTEX].max_ord+1,
; 47   :                                                   sizeof(struct averages));

	mov	eax, DWORD PTR _web+68
	push	ebx
	push	esi
	push	edi
	push	47					; 0000002fH
	push	OFFSET ??_C@_08FBJKBDLA@VERAVG?4C?$AA@
	inc	eax
	push	120					; 00000078H
	push	eax
	call	_kb_temp_calloc

; 48   :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+48
	mov	edi, DWORD PTR _web+12
	mov	ebx, edx
	shr	ebx, 28					; 0000001cH
	add	esp, 16					; 00000010H
	and	ebx, 1
	mov	DWORD PTR _average, eax
	je	SHORT $LN21@vertex_ave
	npad	7
$LL48@vertex_ave:
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+edx*4]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv428[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN22@vertex_ave

; 49   :    if ( get_vattr(v_id) & (FIXED|BOUNDARY) ) 

	and	ecx, 192				; 000000c0H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN22@vertex_ave

; 50   :      average[loc_ordinal(v_id)].status = -10;

	test	ebx, ebx
	je	SHORT $LN27@vertex_ave
	mov	eax, edx
	jmp	SHORT $LN28@vertex_ave
$LN27@vertex_ave:
	or	eax, -1
$LN28@vertex_ave:
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	mov	eax, DWORD PTR _average
	mov	DWORD PTR [eax+ecx*8+104], -10		; fffffff6H
	mov	edi, DWORD PTR _web+12
$LN22@vertex_ave:

; 48   :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [ecx]
	mov	ebx, edx
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	jne	SHORT $LL48@vertex_ave
$LN21@vertex_ave:

; 51   : 
; 52   :   if ( web.representation == SIMPLEX ) 

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN17@vertex_ave

; 53   :     { old_vertex_average(mode); return; }

	mov	edx, DWORD PTR _mode$[ebp]
	push	edx
	call	_old_vertex_average

; 73   :      }
; 74   :   }
; 75   : 
; 76   :   temp_free((char*)average);

	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 77   : } // end vertex_average()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@vertex_ave:

; 54   : 
; 55   :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+48
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	je	SHORT $LN14@vertex_ave
	npad	7
$LL52@vertex_ave:
	mov	ebx, edx
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	SHORT $LN15@vertex_ave

; 56   :      average[loc_ordinal(v_id)].status = 
; 57   :               find_vertex_average(v_id,average[loc_ordinal(v_id)].x,mode);

	test	ecx, ecx
	je	SHORT $LN31@vertex_ave
	mov	eax, ebx
	mov	esi, ebx
	jmp	SHORT $LN30@vertex_ave
$LN31@vertex_ave:
	or	eax, -1
	or	esi, eax
$LN30@vertex_ave:
	mov	ecx, DWORD PTR _mode$[ebp]
	push	ecx
	mov	ecx, eax
	shl	ecx, 4
	sub	ecx, eax
	mov	eax, DWORD PTR _average
	lea	ecx, DWORD PTR [eax+ecx*8]
	push	ecx
	push	edx
	call	_find_vertex_average
	mov	ecx, DWORD PTR _average
	mov	edx, esi
	shl	edx, 4
	add	esp, 12					; 0000000cH
	sub	edx, esi
	mov	DWORD PTR [ecx+edx*8+104], eax
	mov	edi, DWORD PTR _web+12
$LN15@vertex_ave:

; 54   : 
; 55   :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR [edi+ebx*4]
	mov	edx, DWORD PTR [edx]
	mov	ecx, edx
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	SHORT $LL52@vertex_ave
$LN14@vertex_ave:

; 58   : 
; 59   :   FOR_ALL_VERTICES(v_id)

	mov	ebx, DWORD PTR _web+48
	mov	eax, ebx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _v_id$[ebp], ebx
	mov	DWORD PTR tv419[ebp], eax
	je	$LN9@vertex_ave
$LL54@vertex_ave:
	and	ebx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ebx*4]
	mov	ecx, DWORD PTR [edx+8]
	mov	eax, ecx
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv421[ebp], ebx
	je	$LN10@vertex_ave

; 60   :   {
; 61   :      ATTR attr = get_vattr(v_id);

	mov	eax, ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _attr$89091[ebp], eax
	mov	DWORD PTR _attr$89091[ebp+4], ecx

; 62   :      REAL *newx = average[loc_ordinal(v_id)].x;

	cmp	DWORD PTR tv419[ebp], esi
	jne	SHORT $LN34@vertex_ave
	or	ebx, -1
$LN34@vertex_ave:
	mov	esi, DWORD PTR _average
	mov	ecx, ebx
	shl	ecx, 4
	sub	ecx, ebx

; 63   :      x = get_coord(v_id);

	mov	ebx, DWORD PTR _web+104
	lea	esi, DWORD PTR [esi+ecx*8]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ebx+ecx+64]

; 64   :      if (attr & BOUNDARY )

	and	eax, 128				; 00000080H
	xor	ebx, ebx
	add	ecx, edx
	or	eax, ebx
	je	SHORT $LN6@vertex_ave

; 65   :      { /* update boundary parameter to agree with coordinates */
; 66   :         b_extrapolate(get_boundary(v_id),x,newx,newx,get_param(v_id),get_param(v_id),v_id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN35@vertex_ave
	mov	ebx, eax
	shl	ebx, 4
	sub	ebx, eax
	mov	eax, DWORD PTR _dymem
	shl	ebx, 4
	add	ebx, DWORD PTR _web+104
	mov	eax, DWORD PTR [ebx+eax+64]
	mov	edx, DWORD PTR [eax+edx]
	imul	edx, 136				; 00000088H
	add	edx, DWORD PTR _web+776
	jmp	SHORT $LN36@vertex_ave
$LN35@vertex_ave:
	xor	edx, edx
$LN36@vertex_ave:
	mov	ebx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ebx+544]
	mov	ebx, DWORD PTR tv421[ebp]
	mov	edi, DWORD PTR [edi+ebx*4]
	add	eax, edi
	mov	edi, DWORD PTR _v_id$[ebp]
	push	edi
	push	eax
	push	eax
	push	esi
	push	esi
	push	ecx
	push	edx
	call	_b_extrapolate

; 67   :      }
; 68   :      else

	mov	edi, DWORD PTR _web+12
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN10@vertex_ave
$LN6@vertex_ave:

; 69   :      {
; 70   :         for ( i = 0 ; i < SDIM ; i++ ) x[i] = newx[i];

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN46@vertex_ave
	mov	eax, ecx
	sub	esi, ecx
$LL4@vertex_ave:
	fld	QWORD PTR [esi+eax]
	inc	edx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL4@vertex_ave
	mov	edi, DWORD PTR _web+12
$LN46@vertex_ave:

; 71   :           if (attr & CONSTRAINT )

	mov	eax, DWORD PTR _attr$89091[ebp]
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN47@vertex_ave

; 72   :              project_v_constr(v_id,ACTUAL_MOVE,RESET_ONESIDEDNESS);

	mov	ecx, DWORD PTR _v_id$[ebp]
	push	1
	push	1
	push	ecx
	call	_project_v_constr
	mov	edi, DWORD PTR _web+12
	add	esp, 12					; 0000000cH
$LN47@vertex_ave:
	mov	ebx, DWORD PTR tv421[ebp]
$LN10@vertex_ave:

; 58   : 
; 59   :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR [edi+ebx*4]
	mov	ebx, DWORD PTR [edx]
	mov	eax, ebx
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _v_id$[ebp], ebx
	mov	DWORD PTR tv419[ebp], eax
	jne	$LL54@vertex_ave
$LN9@vertex_ave:

; 73   :      }
; 74   :   }
; 75   : 
; 76   :   temp_free((char*)average);

	mov	eax, DWORD PTR _average
	push	eax
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
$LN25@vertex_ave:

; 77   : } // end vertex_average()

	mov	esp, ebp
	pop	ebp
	ret	0
_vertex_average ENDP
_TEXT	ENDS
END
