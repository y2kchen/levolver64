; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\UTILITY.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_dy_minfrag
PUBLIC	_dy_overhead
PUBLIC	_quad_tang_coeffs
PUBLIC	_qlconvert
PUBLIC	_lqconvert
_DATA	SEGMENT
COMM	_eternal_block_head:DWORD
COMM	_graph_block_head:DWORD
COMM	_dy_lastblock:DWORD
COMM	_temp_block_head:DWORD
COMM	_dy_firstblock:DWORD
COMM	_perm_block_head:DWORD
_DATA	ENDS
_BSS	SEGMENT
_rfactor DQ	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_dy_minfrag DD	030H
_dy_overhead DD	018H
_quad_tang_coeffs DQ 0bff8000000000000r		; -1.5
	DQ	04000000000000000r		; 2
	DQ	0bfe0000000000000r		; -0.5
	DQ	0bfe0000000000000r		; -0.5
	DQ	00000000000000000r		; 0
	DQ	03fe0000000000000r		; 0.5
	DQ	03fe0000000000000r		; 0.5
	DQ	0c000000000000000r		; -2
	DQ	03ff8000000000000r		; 1.5
_qlconvert DD	00H
	DD	01H
	DD	02H
	DD	04H
	DD	05H
	DD	03H
_lqconvert DD	00H
	DD	01H
	DD	02H
	DD	05H
	DD	03H
	DD	04H
_k	DD	0270H
_kr	DD	0138H
_mag01	DD	00H
	DD	09908b0dfH
_DATA	ENDS
PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_get_fe_edge
; Function compile flags: /Ogtp
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _get_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_edge PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp

; 70   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[1]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H

; 72   : }

	pop	ebp
	ret	0
$LN2@get_prev_e:

; 71   :   else return feptr(fe_id)->nextedge[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 72   : }

	pop	ebp
	ret	0
_get_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _get_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_facet PROC					; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp

; 84   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 85   :     return inverse_id(feptr(fe_id)->nextfacet[1]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]
	xor	eax, 134217728				; 08000000H

; 88   : }

	pop	ebp
	ret	0
$LN2@get_prev_f:

; 86   :   else 
; 87   :     return feptr(fe_id)->nextfacet[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]

; 88   : }

	pop	ebp
	ret	0
_get_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_edge_wrap
EXTRN	_dymem:DWORD
EXTRN	_sym_inverse:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_edge_wrap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_wrap$ = 12						; size = 4
_set_edge_wrap PROC					; COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp

; 158  :  *EINT(e_id,E_WRAP_ATTR) =  inverted(e_id)  ? (*sym_inverse)(wrap) : wrap ;

	mov	eax, DWORD PTR _wrap$[ebp]
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN4@set_edge_w
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN4@set_edge_w:
	mov	ecx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+esi+784]
	mov	DWORD PTR [edx+ecx], eax
	pop	esi

; 159  : }

	pop	ebp
	ret	0
_set_edge_wrap ENDP
_TEXT	ENDS
PUBLIC	_get_edge_wrap
; Function compile flags: /Ogtp
;	COMDAT _get_edge_wrap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_wrap PROC					; COMDAT

; 163  : {

	push	ebp
	mov	ebp, esp

; 164  :   WRAPTYPE wrap = *EINT(e_id,E_WRAP_ATTR) ;

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+784]
	mov	eax, DWORD PTR [eax+edx]
	pop	esi

; 165  :   return    ( inverted(e_id) ? (*sym_inverse)(wrap) : wrap );

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN4@get_edge_w
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN4@get_edge_w:

; 166  : }

	pop	ebp
	ret	0
_get_edge_wrap ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_@2
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_@2:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_@2
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_@2:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_next_tail_edge PROC				; COMDAT

; 270  : { return eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4+32]
	pop	ebp
	ret	0
_get_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	_set_next_tail_edge
; Function compile flags: /Ogtp
;	COMDAT _set_next_tail_edge
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_ee_id$ = 12						; size = 4
_set_next_tail_edge PROC				; COMDAT

; 276  : { eptr(e_id)->next_vedge[inverted(e_id) ?1: 0] = (ee_id); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _ee_id$[ebp]
	mov	DWORD PTR [eax+ecx*4+32], edx
	pop	ebp
	ret	0
_set_next_tail_edge ENDP
_TEXT	ENDS
PUBLIC	_get_body_facet
; Function compile flags: /Ogtp
;	COMDAT _get_body_facet
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_facet PROC					; COMDAT

; 279  : { return ( valid_id(b_id) ? bptr(b_id)->f_id : NULLID ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_f
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+400]
	pop	ebp
	ret	0
$LN3@get_body_f:
	xor	eax, eax
	pop	ebp
	ret	0
_get_body_facet ENDP
_TEXT	ENDS
PUBLIC	_get_vertex_fe
; Function compile flags: /Ogtp
;	COMDAT _get_vertex_fe
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_get_vertex_fe PROC					; COMDAT

; 287  : { facet_id fe;

	push	ebp
	mov	ebp, esp

; 288  :   edge_id start_e, xx_id=vptr(v_id)->e_id;

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 289  :   // might be bare edge, so seek along edge loop
; 290  :   if ( !valid_id(xx_id) ) return NULLID;

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN4@get_vertex
	xor	eax, eax

; 299  : }

	pop	ebp
	ret	0
$LN4@get_vertex:
	push	esi

; 291  :   fe = eptr(xx_id)->fe_id;

	mov	esi, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	edx, DWORD PTR [ecx+28]
	push	edi

; 292  :   start_e = xx_id;
; 293  :   while ( !valid_id(fe) )

	test	edx, 268435456				; 10000000H
	jne	SHORT $LN2@get_vertex
	mov	edi, eax
	or	edi, 134217728				; 08000000H
	npad	8
$LL3@get_vertex:

; 294  :   { xx_id = get_next_tail_edge(xx_id);

	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	eax, DWORD PTR [ecx+eax*4+32]

; 295  :     if ( equal_element(xx_id,start_e) ) return NULLID;

	mov	edx, eax
	or	edx, 134217728				; 08000000H
	cmp	edx, edi
	je	SHORT $LN10@get_vertex

; 296  :     fe = eptr(xx_id)->fe_id;

	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	edx, DWORD PTR [ecx+28]
	test	edx, 268435456				; 10000000H
	je	SHORT $LL3@get_vertex
$LN2@get_vertex:

; 297  :   }
; 298  :   return  same_sign(fe,xx_id);

	and	eax, 134217728				; 08000000H
	pop	edi
	xor	eax, edx
	pop	esi

; 299  : }

	pop	ebp
	ret	0
$LN10@get_vertex:
	pop	edi

; 295  :     if ( equal_element(xx_id,start_e) ) return NULLID;

	xor	eax, eax
	pop	esi

; 299  : }

	pop	ebp
	ret	0
_get_vertex_fe ENDP
_TEXT	ENDS
PUBLIC	_set_body_facet
; Function compile flags: /Ogtp
;	COMDAT _set_body_facet
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_f_id$ = 12						; size = 4
_set_body_facet PROC					; COMDAT

; 302  : {  if ( valid_id(b_id) )  bptr(b_id)->f_id = (f_id); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_body_f
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _f_id$[ebp]
	mov	DWORD PTR [edx+400], eax
$LN1@set_body_f:
	pop	ebp
	ret	0
_set_body_facet ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_get_body_volume
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_body_volume
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_volume PROC					; COMDAT

; 308  :     { return    ( valid_id(b_id) ?  bptr(b_id)->volume : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_v
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+40]
	pop	ebp
	ret	0
$LN3@get_body_v:
	fldz
	pop	ebp
	ret	0
_get_body_volume ENDP
_TEXT	ENDS
PUBLIC	_get_body_fixvol
; Function compile flags: /Ogtp
;	COMDAT _get_body_fixvol
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_fixvol PROC					; COMDAT

; 311  :      { return ( valid_id(b_id) ?  bptr(b_id)->fixvol : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_f@2
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+32]
	pop	ebp
	ret	0
$LN3@get_body_f@2:
	fldz
	pop	ebp
	ret	0
_get_body_fixvol ENDP
_TEXT	ENDS
PUBLIC	_get_body_volconst
; Function compile flags: /Ogtp
;	COMDAT _get_body_volconst
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_volconst PROC					; COMDAT

; 320  :   { return    ( valid_id(b_id) ?  bptr(b_id)->volconst : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_v@2
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+328]
	pop	ebp
	ret	0
$LN3@get_body_v@2:
	fldz
	pop	ebp
	ret	0
_get_body_volconst ENDP
_TEXT	ENDS
PUBLIC	_set_body_volconst
EXTRN	_gen_quant_list:DWORD
EXTRN	_everything_quantities_flag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_body_volconst
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_set_body_volconst PROC					; COMDAT

; 329  : { if ( !valid_id(b_id) ) return;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_body_v

; 330  :   bptr(b_id)->volconst = v;

	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	fst	QWORD PTR [edx+328]

; 331  :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN6@set_body_v

; 332  :   { struct gen_quant *q = GEN_QUANT(get_body_volquant(b_id));

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx+404]

; 333  :     q->volconst = v;

	mov	ecx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H
	fstp	QWORD PTR [eax+ecx+208]

; 334  :   }
; 335  : }

	pop	ebp
	ret	0
$LN6@set_body_v:

; 333  :     q->volconst = v;

	fstp	ST(0)
$LN1@set_body_v:

; 334  :   }
; 335  : }

	pop	ebp
	ret	0
_set_body_volconst ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@PHGHPLDN@Caught?5SIGTERM?4?5proc?5?$CFd?5?$AA@ ; `string'
PUBLIC	??_C@_0DK@DAHEJIGN@use?5Task?5Manager?5to?5kill?5Evolver@ ; `string'
PUBLIC	??_C@_0DJ@KJEKCBJM@Can?8t?5nicely?5abort?5command?5in?5WI@ ; `string'
PUBLIC	??_C@_0DK@OKEGMBGO@In?5GRAPH_MUTEX?4?5?5May?5be?5deadlock@ ; `string'
PUBLIC	??_C@_0BG@MCHLCPJJ@?6Aborting?5operation?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@NPOOMMID@?6Will?5abort?5operation?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@NIEHBECC@?6Will?5break?5after?5iteration?4?6?$AA@ ; `string'
PUBLIC	_catcher
EXTRN	_my_exit:PROC
EXTRN	_do_dump:PROC
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
EXTRN	_getpid:PROC
EXTRN	_quiet_flag:DWORD
EXTRN	_pop_commandfd:PROC
EXTRN	___iob_func:PROC
EXTRN	_commandfd:DWORD
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	_locking_thread:DWORD
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__MsgWaitForMultipleObjects@20:PROC
EXTRN	_graphmutex:DWORD
EXTRN	_hessian_iterate_flag:DWORD
EXTRN	_breakflag:DWORD
EXTRN	_erroutstring:PROC
EXTRN	_iterate_flag:DWORD
EXTRN	_signal:PROC
;	COMDAT ??_C@_0BJ@PHGHPLDN@Caught?5SIGTERM?4?5proc?5?$CFd?5?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\utility.c
CONST	SEGMENT
??_C@_0BJ@PHGHPLDN@Caught?5SIGTERM?4?5proc?5?$CFd?5?$AA@ DB 'Caught SIGTE'
	DB	'RM. proc %d ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@DAHEJIGN@use?5Task?5Manager?5to?5kill?5Evolver@
CONST	SEGMENT
??_C@_0DK@DAHEJIGN@use?5Task?5Manager?5to?5kill?5Evolver@ DB 'use Task Ma'
	DB	'nager to kill Evolver if you think it''s hung.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@KJEKCBJM@Can?8t?5nicely?5abort?5command?5in?5WI@
CONST	SEGMENT
??_C@_0DJ@KJEKCBJM@Can?8t?5nicely?5abort?5command?5in?5WI@ DB 'Can''t nic'
	DB	'ely abort command in WIN32.  Hang in there, or', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@OKEGMBGO@In?5GRAPH_MUTEX?4?5?5May?5be?5deadlock@
CONST	SEGMENT
??_C@_0DK@OKEGMBGO@In?5GRAPH_MUTEX?4?5?5May?5be?5deadlock@ DB 'In GRAPH_M'
	DB	'UTEX.  May be deadlocked with graphics thread.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MCHLCPJJ@?6Aborting?5operation?4?6?$AA@
CONST	SEGMENT
??_C@_0BG@MCHLCPJJ@?6Aborting?5operation?4?6?$AA@ DB 0aH, 'Aborting opera'
	DB	'tion.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NPOOMMID@?6Will?5abort?5operation?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@NPOOMMID@?6Will?5abort?5operation?4?6?$AA@ DB 0aH, 'Will abort '
	DB	'operation.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NIEHBECC@?6Will?5break?5after?5iteration?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@NIEHBECC@?6Will?5break?5after?5iteration?4?6?$AA@ DB 0aH, 'Will'
	DB	' break after iteration.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _catcher
_TEXT	SEGMENT
_sig$ = 8						; size = 4
_catcher PROC						; COMDAT

; 29   : {

	push	ebp
	mov	ebp, esp

; 30   : #ifdef SIGALRM
; 31   :   if ( sig == SIGALRM ) 
; 32   :       signal(SIGALRM,catcher);
; 33   : #endif
; 34   : 
; 35   :   if ( sig == SIGINT ) 

	mov	eax, DWORD PTR _sig$[ebp]
	cmp	eax, 2
	jne	$LN14@catcher

; 36   :      { signal(SIGINT,catcher);

	push	esi
	push	edi
	push	OFFSET _catcher
	push	eax
	call	_signal

; 37   : 
; 38   : #ifdef SGI_MULTI 
; 39   :     if ( mpflag == M_ACTIVE )
; 40   :       { if ( m_breakflag[GET_THREAD_ID] )
; 41   :         longjmp(m_jumpbuf[GET_THREAD_ID],1);
; 42   :          else m_breakflag[GET_THREAD_ID] = BREAKFULL;
; 43   :          if ( GET_THREAD_ID == 0 ) 
; 44   :         write(2,"\nWill break after iteration.\n",29);
; 45   :          breakflag = BREAKFULL;
; 46   :          iterate_flag = 0;
; 47   :       }
; 48   :     else
; 49   :       if ( GET_THREAD_ID > 0 ) {}
; 50   :     else
; 51   : #endif
; 52   :     if ( iterate_flag == 1 )

	mov	eax, DWORD PTR _iterate_flag
	mov	esi, 1
	add	esp, 8
	xor	edi, edi
	cmp	eax, esi
	jne	SHORT $LN13@catcher

; 53   :     { write(2,"\nWill break after iteration.\n",29);

	push	OFFSET ??_C@_0BO@NIEHBECC@?6Will?5break?5after?5iteration?4?6?$AA@
	call	_erroutstring
	add	esp, 4

; 54   :       breakflag = BREAKFULL;

	mov	DWORD PTR _breakflag, esi

; 55   :       iterate_flag = 0;

	mov	DWORD PTR _iterate_flag, edi
	jmp	$LN17@catcher
$LN13@catcher:

; 56   :     }
; 57   :     else if ( iterate_flag == 2 ) /* graphing or something */

	cmp	eax, 2
	jne	SHORT $LN11@catcher

; 58   :     { write(2,"\nWill abort operation.\n",24);

	push	OFFSET ??_C@_0BI@NPOOMMID@?6Will?5abort?5operation?4?6?$AA@
	call	_erroutstring
	add	esp, 4

; 59   :       breakflag = BREAKFULL;

	mov	DWORD PTR _breakflag, esi

; 60   :       iterate_flag = 0;

	mov	DWORD PTR _iterate_flag, edi
	jmp	$LN17@catcher
$LN11@catcher:

; 61   :     }
; 62   :     else if ( hessian_iterate_flag == 1 )

	cmp	DWORD PTR _hessian_iterate_flag, esi
	jne	SHORT $LN9@catcher

; 63   :     { write(2,"\nWill break after iteration.\n",29);

	push	OFFSET ??_C@_0BO@NIEHBECC@?6Will?5break?5after?5iteration?4?6?$AA@
	call	_erroutstring
	add	esp, 4

; 64   :       breakflag = BREAKFULL;

	mov	DWORD PTR _breakflag, esi

; 65   :     }
; 66   :     else

	jmp	SHORT $LN17@catcher
$LN9@catcher:

; 67   :     { write(2,"\nAborting operation.\n",22);

	push	OFFSET ??_C@_0BG@MCHLCPJJ@?6Aborting?5operation?4?6?$AA@
	call	_erroutstring
	add	esp, 4

; 68   :       if ( TRY_GRAPH_MUTEX(IMMEDIATE_TIMEOUT) )

	push	edi
	push	edi
	push	edi
	push	OFFSET _graphmutex
	push	esi
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	cmp	eax, 258				; 00000102H
	je	SHORT $LN7@catcher
	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	mov	DWORD PTR _locking_thread, eax
	cmp	eax, edi
	je	SHORT $LN7@catcher

; 69   :            ABORT_GRAPH_MUTEX

	call	esi
	cmp	eax, DWORD PTR _locking_thread
	jne	SHORT $LN4@catcher
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, edi
	call	DWORD PTR __imp__ReleaseMutex@4

; 70   :         else

	jmp	SHORT $LN4@catcher
$LN7@catcher:

; 71   :            erroutstring("In GRAPH_MUTEX.  May be deadlocked with graphics thread.\n");

	push	OFFSET ??_C@_0DK@OKEGMBGO@In?5GRAPH_MUTEX?4?5?5May?5be?5deadlock@
	call	_erroutstring
	add	esp, 4
$LN4@catcher:

; 72   : #ifdef WIN32
; 73   : /* separate thread for signal handler, so can't longjmp out of error */
; 74   :   erroutstring("Can't nicely abort command in WIN32.  Hang in there, or\n");

	push	OFFSET ??_C@_0DJ@KJEKCBJM@Can?8t?5nicely?5abort?5command?5in?5WI@
	call	_erroutstring

; 75   :   erroutstring("use Task Manager to kill Evolver if you think it's hung.\n");

	push	OFFSET ??_C@_0DK@DAHEJIGN@use?5Task?5Manager?5to?5kill?5Evolver@
	call	_erroutstring
	add	esp, 8
$LN17@catcher:

; 76   : #elif defined(MAC_OS_X)
; 77   :   if ( iterate_flag > 2 )
; 78   :     erroutstring("Haven't figured out how to handle this yet.\n");
; 79   : #else
; 80   :   kb_error(1357,"",RECOVERABLE_QUIET);
; 81   : #endif
; 82   :     }
; 83   :     while ( commandfd && (commandfd  != stdin) )

	cmp	DWORD PTR _commandfd, edi
	je	SHORT $LN2@catcher
	npad	5
$LL3@catcher:
	call	___iob_func
	cmp	DWORD PTR _commandfd, eax
	je	SHORT $LN2@catcher

; 84   :          pop_commandfd();

	call	_pop_commandfd
	cmp	DWORD PTR _commandfd, edi
	jne	SHORT $LL3@catcher
$LN2@catcher:

; 85   :     quiet_flag = 0; 

	mov	DWORD PTR _quiet_flag, edi
	pop	edi
	pop	esi

; 94   :     }
; 95   : #endif
; 96   : 
; 97   : #ifdef SIGHUP
; 98   :   if ( sig == SIGHUP )  /* for outside kill and dump */
; 99   :     {
; 100  :       do_dump(NULL); /* dump to default */
; 101  :       my_exit(1);
; 102  :     }
; 103  : #endif
; 104  : 
; 105  : #ifdef SIGPIPE
; 106  :   else if ( sig == SIGPIPE )
; 107  :      { signal(SIGPIPE,catcher);
; 108  :     write(2,"Broken pipe signal.\n",20);
; 109  :     broken_pipe_flag = 1;
; 110  :      }
; 111  : #endif
; 112  : } // end catcher()

	pop	ebp
	ret	0
$LN14@catcher:

; 86   :    }
; 87   :     
; 88   : #ifdef SIGTERM
; 89   :   if ( sig == SIGTERM )  /* for outside kill and dump */

	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN1@catcher

; 90   :     { sprintf(errmsg,"Caught SIGTERM. proc %d ",getpid());

	call	_getpid
	push	eax
	push	OFFSET ??_C@_0BJ@PHGHPLDN@Caught?5SIGTERM?4?5proc?5?$CFd?5?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 91   :       erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 92   :       do_dump(NULL); /* dump to default */

	push	0
	call	_do_dump

; 93   :       my_exit(1);

	push	1
	call	_my_exit
	add	esp, 24					; 00000018H
$LN1@catcher:

; 94   :     }
; 95   : #endif
; 96   : 
; 97   : #ifdef SIGHUP
; 98   :   if ( sig == SIGHUP )  /* for outside kill and dump */
; 99   :     {
; 100  :       do_dump(NULL); /* dump to default */
; 101  :       my_exit(1);
; 102  :     }
; 103  : #endif
; 104  : 
; 105  : #ifdef SIGPIPE
; 106  :   else if ( sig == SIGPIPE )
; 107  :      { signal(SIGPIPE,catcher);
; 108  :     write(2,"Broken pipe signal.\n",20);
; 109  :     broken_pipe_flag = 1;
; 110  :      }
; 111  : #endif
; 112  : } // end catcher()

	pop	ebp
	ret	0
_catcher ENDP
_TEXT	ENDS
PUBLIC	_kb_checksum
; Function compile flags: /Ogtp
;	COMDAT _kb_checksum
_TEXT	SEGMENT
_mem$ = 8						; size = 4
_size$ = 12						; size = 4
_kb_checksum PROC					; COMDAT

; 135  : {

	push	ebp
	mov	ebp, esp

; 136  :   int sum = 0;
; 137  :   int *a,*b;
; 138  :   b = (int *)mem;
; 139  :   a = b + size/sizeof(int);

	mov	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR _mem$[ebp]
	xor	eax, eax
	shr	ecx, 2
	lea	ecx, DWORD PTR [edx+ecx*4]
$LL3@kb_checksu:

; 140  :   do { sum += *a; } while ( --a != b);

	add	eax, DWORD PTR [ecx]
	sub	ecx, 4
	cmp	ecx, edx
	jne	SHORT $LL3@kb_checksu

; 141  :   return sum;
; 142  : } // end kb_checksum()

	pop	ebp
	ret	0
_kb_checksum ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@FFMPGLPH@Bad?5graphics?5memory?5block?5chain?$CB@ ; `string'
PUBLIC	??_C@_0CD@ILHGHODK@Bad?5temporary?5memory?5block?5chain@ ; `string'
PUBLIC	??_C@_0CD@HEHGFICE@Bad?5permanent?5memory?5block?5chain@ ; `string'
PUBLIC	??_C@_0CB@CINIEFGP@Bad?5eternal?5memory?5block?5chain?$CB?6@ ; `string'
PUBLIC	??_C@_0DC@LMNNJEJE@Internal?5error?3?5Corrupt?5heap?$CB?5Me@ ; `string'
PUBLIC	_mem_sanity_check
EXTRN	_kb_error:PROC
EXTRN	__heapchk:PROC
EXTRN	_draw_thread_id:DWORD
;	COMDAT ??_C@_0CC@FFMPGLPH@Bad?5graphics?5memory?5block?5chain?$CB@
CONST	SEGMENT
??_C@_0CC@FFMPGLPH@Bad?5graphics?5memory?5block?5chain?$CB@ DB 'Bad graph'
	DB	'ics memory block chain!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@ILHGHODK@Bad?5temporary?5memory?5block?5chain@
CONST	SEGMENT
??_C@_0CD@ILHGHODK@Bad?5temporary?5memory?5block?5chain@ DB 'Bad temporar'
	DB	'y memory block chain!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HEHGFICE@Bad?5permanent?5memory?5block?5chain@
CONST	SEGMENT
??_C@_0CD@HEHGFICE@Bad?5permanent?5memory?5block?5chain@ DB 'Bad permanen'
	DB	't memory block chain!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CINIEFGP@Bad?5eternal?5memory?5block?5chain?$CB?6@
CONST	SEGMENT
??_C@_0CB@CINIEFGP@Bad?5eternal?5memory?5block?5chain?$CB?6@ DB 'Bad eter'
	DB	'nal memory block chain!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LMNNJEJE@Internal?5error?3?5Corrupt?5heap?$CB?5Me@
CONST	SEGMENT
??_C@_0DC@LMNNJEJE@Internal?5error?3?5Corrupt?5heap?$CB?5Me@ DB 'Internal'
	DB	' error: Corrupt heap! Memory is trashed.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _mem_sanity_check
_TEXT	SEGMENT
_mem_sanity_check PROC					; COMDAT

; 163  : { struct memhead *head;

	push	ebx
	push	esi
	push	edi

; 164  :   int blocktype;
; 165  : 
; 166  :   THREADBLOCK(blocktype);

	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	edi, DWORD PTR _draw_thread_id
	sub	edi, eax
	neg	edi
	sbb	edi, edi
	and	edi, 4369				; 00001111H
	add	edi, 52171				; 0000cbcbH

; 167  : 
; 168  : #if defined(_WIN32) && defined(_HEAPOK)
; 169  : #ifndef _HEAPINFO
; 170  : #define _HEAPINFO _heapinfo
; 171  : #endif
; 172  : 
; 173  :   if ( _heapchk() != _HEAPOK )

	call	__heapchk
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN30@mem_sanity

; 174  :     kb_error(2580,"Internal error: Corrupt heap! Memory is trashed.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DC@LMNNJEJE@Internal?5error?3?5Corrupt?5heap?$CB?5Me@
	push	2580					; 00000a14H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN30@mem_sanity:

; 175  : #endif
; 176  : 
; 177  :   for ( head = eternal_block_head; head ; head = head->next )

	mov	esi, DWORD PTR _eternal_block_head
	test	esi, esi
	je	SHORT $LN16@mem_sanity
	mov	ebx, 60138				; 0000eaeaH
	npad	2
$LL18@mem_sanity:

; 178  :   { if ( head->type != ETERNAL_BLOCK )

	cmp	DWORD PTR [esi+12], ebx
	je	SHORT $LN17@mem_sanity

; 179  :       kb_error(2581,"Bad eternal memory block chain!\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CB@CINIEFGP@Bad?5eternal?5memory?5block?5chain?$CB?6@
	push	2581					; 00000a15H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN17@mem_sanity:

; 175  : #endif
; 176  : 
; 177  :   for ( head = eternal_block_head; head ; head = head->next )

	mov	esi, DWORD PTR [esi+4]
	test	esi, esi
	jne	SHORT $LL18@mem_sanity
$LN16@mem_sanity:

; 180  :   }
; 181  : 
; 182  :   for ( head = perm_block_head ; head ; head = head->next )

	mov	esi, DWORD PTR _perm_block_head
	test	esi, esi
	je	SHORT $LN12@mem_sanity
	mov	ebx, 43947				; 0000ababH
	npad	1
$LL14@mem_sanity:

; 183  :   { if ( head->type != PERM_BLOCK )

	cmp	DWORD PTR [esi+12], ebx
	je	SHORT $LN13@mem_sanity

; 184  :       kb_error(2460,"Bad permanent memory block chain!\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CD@HEHGFICE@Bad?5permanent?5memory?5block?5chain@
	push	2460					; 0000099cH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN13@mem_sanity:

; 180  :   }
; 181  : 
; 182  :   for ( head = perm_block_head ; head ; head = head->next )

	mov	esi, DWORD PTR [esi+4]
	test	esi, esi
	jne	SHORT $LL14@mem_sanity
$LN12@mem_sanity:

; 185  :   }
; 186  : 
; 187  :   if ( blocktype == TEMP_BLOCK )

	mov	ebx, 56540				; 0000dcdcH
	cmp	edi, ebx
	jne	SHORT $LN7@mem_sanity

; 188  :   for ( head = temp_block_head ; head ; head = head->next )

	mov	esi, DWORD PTR _temp_block_head
	test	esi, esi
	je	SHORT $LN2@mem_sanity
$LL9@mem_sanity:

; 189  :   { if ( head->type != TEMP_BLOCK )

	cmp	DWORD PTR [esi+12], ebx
	je	SHORT $LN8@mem_sanity

; 190  :       kb_error(3208,"Bad temporary memory block chain!\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CD@ILHGHODK@Bad?5temporary?5memory?5block?5chain@
	push	3208					; 00000c88H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN8@mem_sanity:

; 188  :   for ( head = temp_block_head ; head ; head = head->next )

	mov	esi, DWORD PTR [esi+4]
	test	esi, esi
	jne	SHORT $LL9@mem_sanity
	pop	edi
	pop	esi
	pop	ebx

; 197  :   }
; 198  : } // end mem_sanity_check()

	ret	0
$LN7@mem_sanity:

; 191  :   }
; 192  : 
; 193  :   if ( blocktype == GRAPH_BLOCK )

	mov	ebx, 52171				; 0000cbcbH
	cmp	edi, ebx
	jne	SHORT $LN2@mem_sanity

; 194  :   for ( head = graph_block_head ; head ; head = head->next )

	mov	esi, DWORD PTR _graph_block_head
	test	esi, esi
	je	SHORT $LN2@mem_sanity
	npad	6
$LL4@mem_sanity:

; 195  :   { if ( head->type != GRAPH_BLOCK )

	cmp	DWORD PTR [esi+12], ebx
	je	SHORT $LN3@mem_sanity

; 196  :       kb_error(2461,"Bad graphics memory block chain!\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CC@FFMPGLPH@Bad?5graphics?5memory?5block?5chain?$CB@
	push	2461					; 0000099dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN3@mem_sanity:

; 194  :   for ( head = graph_block_head ; head ; head = head->next )

	mov	esi, DWORD PTR [esi+4]
	test	esi, esi
	jne	SHORT $LL4@mem_sanity
$LN2@mem_sanity:
	pop	edi
	pop	esi
	pop	ebx

; 197  :   }
; 198  : } // end mem_sanity_check()

	ret	0
_mem_sanity_check ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@NCBAEBPN@Total?5data?5memory?3?5?$CFlu?5KB?0?5or?5?$CFl@ ; `string'
PUBLIC	??_C@_0DD@FLDOJPAM@Total?5data?5memory?3?5?$CFlu?5blocks?0?5?$CF@ ; `string'
PUBLIC	??_C@_0CN@FHDJLIAC@Temporary?3?5?$CF5lu?5blocks?0?5?$CF10lu?5KB@ ; `string'
PUBLIC	??_C@_0CO@ILMCLGBJ@Permanent?3?5?$CF5lu?5blocks?0?5?$CF10lu?5KB@ ; `string'
PUBLIC	??_C@_0CM@DAHJKDPH@Session?3?5?$CF7lu?5blocks?0?5?$CF10lu?5KB?0?5@ ; `string'
PUBLIC	_mem_list_summary
EXTRN	_outstring:PROC
EXTRN	_verbose_flag:DWORD
;	COMDAT ??_C@_0CH@NCBAEBPN@Total?5data?5memory?3?5?$CFlu?5KB?0?5or?5?$CFl@
CONST	SEGMENT
??_C@_0CH@NCBAEBPN@Total?5data?5memory?3?5?$CFlu?5KB?0?5or?5?$CFl@ DB 'To'
	DB	'tal data memory: %lu KB, or %lu MB.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@FLDOJPAM@Total?5data?5memory?3?5?$CFlu?5blocks?0?5?$CF@
CONST	SEGMENT
??_C@_0DD@FLDOJPAM@Total?5data?5memory?3?5?$CFlu?5blocks?0?5?$CF@ DB 'Tot'
	DB	'al data memory: %lu blocks, %lu KB, or %lu MB.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FHDJLIAC@Temporary?3?5?$CF5lu?5blocks?0?5?$CF10lu?5KB@
CONST	SEGMENT
??_C@_0CN@FHDJLIAC@Temporary?3?5?$CF5lu?5blocks?0?5?$CF10lu?5KB@ DB 'Temp'
	DB	'orary: %5lu blocks, %10lu KB, or %lu MB', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@ILMCLGBJ@Permanent?3?5?$CF5lu?5blocks?0?5?$CF10lu?5KB@
CONST	SEGMENT
??_C@_0CO@ILMCLGBJ@Permanent?3?5?$CF5lu?5blocks?0?5?$CF10lu?5KB@ DB 'Perm'
	DB	'anent: %5lu blocks, %10lu KB, or %lu MB ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DAHJKDPH@Session?3?5?$CF7lu?5blocks?0?5?$CF10lu?5KB?0?5@
CONST	SEGMENT
??_C@_0CM@DAHJKDPH@Session?3?5?$CF7lu?5blocks?0?5?$CF10lu?5KB?0?5@ DB 'Se'
	DB	'ssion: %7lu blocks, %10lu KB, or %lu MB ', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _mem_list_summary
_TEXT	SEGMENT
_count$ = -8						; size = 4
_total$ = -4						; size = 4
_mem_list_summary PROC					; COMDAT

; 208  : { struct memhead *head;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi

; 209  :   size_t total=0,subtotal;
; 210  :   size_t count=0,subcount;
; 211  : 
; 212  :   for ( head = eternal_block_head, subcount=subtotal=0 ; head ; head = head->next )

	mov	esi, DWORD PTR _eternal_block_head
	push	edi
	xor	edi, edi
	xor	ebx, ebx
	test	esi, esi
	je	SHORT $LN23@mem_list_s
$LL25@mem_list_s:

; 213  :   { if ( head->type != ETERNAL_BLOCK )

	cmp	DWORD PTR [esi+12], 60138		; 0000eaeaH
	je	SHORT $LN22@mem_list_s

; 214  :       kb_error(2462,"Bad eternal memory block chain!\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CB@CINIEFGP@Bad?5eternal?5memory?5block?5chain?$CB?6@
	push	2462					; 0000099eH
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN24@mem_list_s
$LN22@mem_list_s:

; 215  :     else { subtotal += head->size; subcount++; }

	add	edi, DWORD PTR [esi+8]
	inc	ebx
$LN24@mem_list_s:

; 209  :   size_t total=0,subtotal;
; 210  :   size_t count=0,subcount;
; 211  : 
; 212  :   for ( head = eternal_block_head, subcount=subtotal=0 ; head ; head = head->next )

	mov	esi, DWORD PTR [esi+4]
	test	esi, esi
	jne	SHORT $LL25@mem_list_s
$LN23@mem_list_s:

; 216  :   }
; 217  :   if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN20@mem_list_s

; 218  :   { sprintf(errmsg,"Session: %7lu blocks, %10lu KB, or %lu MB \n",
; 219  :       (unsigned long)subcount,(unsigned long)subtotal>>10,
; 220  :       (unsigned long)subtotal>>20);

	mov	eax, edi
	shr	eax, 20					; 00000014H
	push	eax
	mov	ecx, edi
	shr	ecx, 10					; 0000000aH
	push	ecx
	push	ebx
	push	OFFSET ??_C@_0CM@DAHJKDPH@Session?3?5?$CF7lu?5blocks?0?5?$CF10lu?5KB?0?5@
	push	OFFSET _errmsg
	call	_sprintf

; 221  :     outstring(errmsg);

	push	OFFSET _errmsg
	call	_outstring
	add	esp, 24					; 00000018H
$LN20@mem_list_s:

; 222  :   }
; 223  :   total += subtotal; count += subcount;
; 224  : 
; 225  :   for ( head = perm_block_head, subcount=subtotal=0 ; head ; head = head->next )

	mov	esi, DWORD PTR _perm_block_head
	mov	eax, edi
	mov	DWORD PTR _count$[ebp], ebx
	xor	edi, edi
	xor	ebx, ebx
	mov	DWORD PTR _total$[ebp], eax
	test	esi, esi
	je	SHORT $LN17@mem_list_s
	npad	7
$LL19@mem_list_s:

; 226  :   { if ( head->type != PERM_BLOCK )

	cmp	DWORD PTR [esi+12], 43947		; 0000ababH
	je	SHORT $LN16@mem_list_s

; 227  :       kb_error(2463,"Bad permanent memory block chain!\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CD@HEHGFICE@Bad?5permanent?5memory?5block?5chain@
	push	2463					; 0000099fH
	call	_kb_error
	mov	eax, DWORD PTR _total$[ebp]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN18@mem_list_s
$LN16@mem_list_s:

; 228  :     else { subtotal += head->size; subcount++; }

	add	edi, DWORD PTR [esi+8]
	inc	ebx
$LN18@mem_list_s:

; 222  :   }
; 223  :   total += subtotal; count += subcount;
; 224  : 
; 225  :   for ( head = perm_block_head, subcount=subtotal=0 ; head ; head = head->next )

	mov	esi, DWORD PTR [esi+4]
	test	esi, esi
	jne	SHORT $LL19@mem_list_s
$LN17@mem_list_s:

; 229  :   }
; 230  :   if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN14@mem_list_s

; 231  :   { sprintf(errmsg,"Permanent: %5lu blocks, %10lu KB, or %lu MB \n",
; 232  :        (unsigned long)subcount,(unsigned long)(subtotal>>10),
; 233  :        (unsigned long)(subtotal>>20));

	mov	edx, edi
	shr	edx, 20					; 00000014H
	push	edx
	mov	eax, edi
	shr	eax, 10					; 0000000aH
	push	eax
	push	ebx
	push	OFFSET ??_C@_0CO@ILMCLGBJ@Permanent?3?5?$CF5lu?5blocks?0?5?$CF10lu?5KB@
	push	OFFSET _errmsg
	call	_sprintf

; 234  :     outstring(errmsg);

	push	OFFSET _errmsg
	call	_outstring
	mov	eax, DWORD PTR _total$[ebp]
	add	esp, 24					; 00000018H
$LN14@mem_list_s:

; 235  :   }
; 236  :   total += subtotal; count += subcount;

	add	DWORD PTR _count$[ebp], ebx

; 237  : 
; 238  :   for ( head = temp_block_head, subcount=subtotal=0 ; head ; head = head->next )

	mov	esi, DWORD PTR _temp_block_head
	add	eax, edi
	xor	edi, edi
	xor	ebx, ebx
	mov	DWORD PTR _total$[ebp], eax
	test	esi, esi
	je	SHORT $LN11@mem_list_s
	npad	8
$LL13@mem_list_s:

; 239  :   { if ( head->type != TEMP_BLOCK )

	cmp	DWORD PTR [esi+12], 56540		; 0000dcdcH
	je	SHORT $LN10@mem_list_s

; 240  :       kb_error(2464,"Bad temporary memory block chain!\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CD@ILHGHODK@Bad?5temporary?5memory?5block?5chain@
	push	2464					; 000009a0H
	call	_kb_error
	mov	eax, DWORD PTR _total$[ebp]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN12@mem_list_s
$LN10@mem_list_s:

; 241  :     else { subtotal += head->size; subcount++; }

	add	edi, DWORD PTR [esi+8]
	inc	ebx
$LN12@mem_list_s:

; 237  : 
; 238  :   for ( head = temp_block_head, subcount=subtotal=0 ; head ; head = head->next )

	mov	esi, DWORD PTR [esi+4]
	test	esi, esi
	jne	SHORT $LL13@mem_list_s
$LN11@mem_list_s:

; 242  :   }
; 243  : 
; 244  :   for ( head = graph_block_head ; head ; head = head->next )

	mov	esi, DWORD PTR _graph_block_head
	test	esi, esi
	je	SHORT $LN6@mem_list_s
$LL8@mem_list_s:

; 245  :   { if ( head->type != GRAPH_BLOCK )

	cmp	DWORD PTR [esi+12], 52171		; 0000cbcbH
	je	SHORT $LN5@mem_list_s

; 246  :       kb_error(3210,"Bad graphics memory block chain!\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CC@FFMPGLPH@Bad?5graphics?5memory?5block?5chain?$CB@
	push	3210					; 00000c8aH
	call	_kb_error
	mov	eax, DWORD PTR _total$[ebp]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@mem_list_s
$LN5@mem_list_s:

; 247  :     else { subtotal += head->size; subcount++; }

	add	edi, DWORD PTR [esi+8]
	inc	ebx
$LN7@mem_list_s:

; 242  :   }
; 243  : 
; 244  :   for ( head = graph_block_head ; head ; head = head->next )

	mov	esi, DWORD PTR [esi+4]
	test	esi, esi
	jne	SHORT $LL8@mem_list_s
$LN6@mem_list_s:

; 248  :   }
; 249  : 
; 250  :   if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	SHORT $LN36@mem_list_s

; 251  :   { sprintf(errmsg,"Temporary: %5lu blocks, %10lu KB, or %lu MB\n",
; 252  :        (unsigned long)subcount,(unsigned long)(subtotal>>10),
; 253  :        (unsigned long)(subtotal>>20));

	mov	ecx, edi
	shr	ecx, 20					; 00000014H
	push	ecx
	mov	edx, edi
	shr	edx, 10					; 0000000aH
	push	edx
	push	ebx
	push	OFFSET ??_C@_0CN@FHDJLIAC@Temporary?3?5?$CF5lu?5blocks?0?5?$CF10lu?5KB@
	push	OFFSET _errmsg
	call	_sprintf

; 254  :     outstring(errmsg);

	push	OFFSET _errmsg
	call	_outstring
	mov	eax, DWORD PTR _total$[ebp]
	add	esp, 24					; 00000018H
$LN36@mem_list_s:

; 255  :   }
; 256  :   total += subtotal; count += subcount;

	add	eax, edi

; 257  : 
; 258  :   if ( verbose_flag )
; 259  :     sprintf(errmsg,"Total data memory: %lu blocks, %lu KB, or %lu MB.\n",
; 260  :       (unsigned long)count,(unsigned long)(total>>10),(unsigned long)(total>>20));

	mov	ecx, eax
	shr	ecx, 20					; 00000014H
	shr	eax, 10					; 0000000aH
	cmp	DWORD PTR _verbose_flag, 0
	push	ecx
	push	eax
	je	SHORT $LN2@mem_list_s
	add	ebx, DWORD PTR _count$[ebp]
	push	ebx
	push	OFFSET ??_C@_0DD@FLDOJPAM@Total?5data?5memory?3?5?$CFlu?5blocks?0?5?$CF@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 20					; 00000014H

; 264  :   outstring(errmsg);

	push	OFFSET _errmsg
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 265  : 
; 266  :   // See if we can get video memory
; 267  : #ifdef LINUX
; 268  :   if ( verbose_flag )
; 269  :   { FILE *fd;
; 270  :     int i,vmem=0,mempages=0;
; 271  :     char procname[100];
; 272  :     sprintf(procname,"/proc/%d/stat",getpid()); 
; 273  :     fd = fopen(procname,"r");
; 274  : if ( fd == NULL ) perror(procname);
; 275  :     for ( i = 0 ; i < 22 ; i++ ) fscanf(fd,"%s",msg);
; 276  :     fscanf(fd,"%d",&vmem);
; 277  :     sprintf(errmsg,"Virtual memory: %d\n",vmem);
; 278  :     outstring(errmsg);
; 279  :     fscanf(fd,"%d",&mempages);
; 280  :     sprintf(errmsg,"Resident memory: %d\n",mempages*getpagesize());
; 281  :     outstring(errmsg);
; 282  :   }
; 283  : #endif
; 284  : } // end mem_list_summary()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@mem_list_s:

; 261  :   else
; 262  :     sprintf(errmsg,"Total data memory: %lu KB, or %lu MB.\n",
; 263  :         (unsigned long)(total>>10), (unsigned long)(total>>20));

	push	OFFSET ??_C@_0CH@NCBAEBPN@Total?5data?5memory?3?5?$CFlu?5KB?0?5or?5?$CFl@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 16					; 00000010H

; 264  :   outstring(errmsg);

	push	OFFSET _errmsg
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 265  : 
; 266  :   // See if we can get video memory
; 267  : #ifdef LINUX
; 268  :   if ( verbose_flag )
; 269  :   { FILE *fd;
; 270  :     int i,vmem=0,mempages=0;
; 271  :     char procname[100];
; 272  :     sprintf(procname,"/proc/%d/stat",getpid()); 
; 273  :     fd = fopen(procname,"r");
; 274  : if ( fd == NULL ) perror(procname);
; 275  :     for ( i = 0 ; i < 22 ; i++ ) fscanf(fd,"%s",msg);
; 276  :     fscanf(fd,"%d",&vmem);
; 277  :     sprintf(errmsg,"Virtual memory: %d\n",vmem);
; 278  :     outstring(errmsg);
; 279  :     fscanf(fd,"%d",&mempages);
; 280  :     sprintf(errmsg,"Resident memory: %d\n",mempages*getpagesize());
; 281  :     outstring(errmsg);
; 282  :   }
; 283  : #endif
; 284  : } // end mem_list_summary()

	mov	esp, ebp
	pop	ebp
	ret	0
_mem_list_summary ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@PMBLDLCO@?6Graph?5memory?5blocks?3?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@BHLNJAGN@?6Temporary?5memory?5blocks?3?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@MCCDJABE@?6Permanent?5memory?5blocks?3?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@NKPJALID@?$CF5d?4?5?$CF12?40f?5bytes?5at?5?$CFp?$DL?5?$CF18s?5li@ ; `string'
PUBLIC	__real@41f0000000000000
PUBLIC	??_C@_0BJ@OLJAEAEM@?6Eternal?5memory?5blocks?3?6?$AA@ ; `string'
PUBLIC	_mem_list_dump
EXTRN	_msg:DWORD
;	COMDAT ??_C@_0BH@PMBLDLCO@?6Graph?5memory?5blocks?3?6?$AA@
CONST	SEGMENT
??_C@_0BH@PMBLDLCO@?6Graph?5memory?5blocks?3?6?$AA@ DB 0aH, 'Graph memory'
	DB	' blocks:', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BHLNJAGN@?6Temporary?5memory?5blocks?3?6?$AA@
CONST	SEGMENT
??_C@_0BL@BHLNJAGN@?6Temporary?5memory?5blocks?3?6?$AA@ DB 0aH, 'Temporar'
	DB	'y memory blocks:', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MCCDJABE@?6Permanent?5memory?5blocks?3?6?$AA@
CONST	SEGMENT
??_C@_0BL@MCCDJABE@?6Permanent?5memory?5blocks?3?6?$AA@ DB 0aH, 'Permanen'
	DB	't memory blocks:', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NKPJALID@?$CF5d?4?5?$CF12?40f?5bytes?5at?5?$CFp?$DL?5?$CF18s?5li@
CONST	SEGMENT
??_C@_0CI@NKPJALID@?$CF5d?4?5?$CF12?40f?5bytes?5at?5?$CFp?$DL?5?$CF18s?5li@ DB '%'
	DB	'5d. %12.0f bytes at %p; %18s line %4d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
CONST	ENDS
;	COMDAT ??_C@_0BJ@OLJAEAEM@?6Eternal?5memory?5blocks?3?6?$AA@
CONST	SEGMENT
??_C@_0BJ@OLJAEAEM@?6Eternal?5memory?5blocks?3?6?$AA@ DB 0aH, 'Eternal me'
	DB	'mory blocks:', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _mem_list_dump
_TEXT	SEGMENT
tv208 = -4						; size = 4
tv203 = -4						; size = 4
tv198 = -4						; size = 4
tv193 = -4						; size = 4
_mem_list_dump PROC					; COMDAT

; 295  : { struct memhead *head;

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi

; 296  :   size_t subcount;
; 297  : 
; 298  : #ifdef MEMSTRINGS
; 299  :   outstring("\nEternal memory blocks:\n");

	push	OFFSET ??_C@_0BJ@OLJAEAEM@?6Eternal?5memory?5blocks?3?6?$AA@
	call	_outstring

; 300  :   for ( head = eternal_block_head, subcount=0 ; head ; head = head->next )

	mov	esi, DWORD PTR _eternal_block_head
	add	esp, 4
	xor	edi, edi
	test	esi, esi
	je	SHORT $LN10@mem_list_d
	npad	1
$LL12@mem_list_d:

; 301  :   { subcount++;
; 302  :     sprintf(msg,"%5d. %12.0f bytes at %p; %18s line %4d\n", 
; 303  :       subcount,(double)head->size,head,head->file,head->line);

	mov	eax, DWORD PTR [esi+44]
	fild	DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+8]
	push	eax
	lea	ecx, DWORD PTR [esi+16]
	inc	edi
	push	ecx
	push	esi
	test	edx, edx
	jns	SHORT $LN23@mem_list_d
	fadd	QWORD PTR __real@41f0000000000000
$LN23@mem_list_d:
	mov	eax, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	push	OFFSET ??_C@_0CI@NKPJALID@?$CF5d?4?5?$CF12?40f?5bytes?5at?5?$CFp?$DL?5?$CF18s?5li@
	push	eax
	call	_sprintf

; 304  :     outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	mov	esi, DWORD PTR [esi+4]
	add	esp, 36					; 00000024H
	test	esi, esi
	jne	SHORT $LL12@mem_list_d
$LN10@mem_list_d:

; 305  :   }
; 306  : 
; 307  :   outstring("\nPermanent memory blocks:\n");

	push	OFFSET ??_C@_0BL@MCCDJABE@?6Permanent?5memory?5blocks?3?6?$AA@
	call	_outstring

; 308  :   for ( head = perm_block_head, subcount=0 ; head ; head = head->next )

	mov	esi, DWORD PTR _perm_block_head
	add	esp, 4
	xor	edi, edi
	test	esi, esi
	je	SHORT $LN7@mem_list_d
$LL9@mem_list_d:

; 309  :   { subcount++;
; 310  :     sprintf(msg,"%5d. %12.0f bytes at %p; %18s line %4d\n", 
; 311  :       subcount,(double)head->size,head,head->file,head->line);

	mov	edx, DWORD PTR [esi+44]
	fild	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+8]
	push	edx
	lea	eax, DWORD PTR [esi+16]
	inc	edi
	push	eax
	push	esi
	test	ecx, ecx
	jns	SHORT $LN24@mem_list_d
	fadd	QWORD PTR __real@41f0000000000000
$LN24@mem_list_d:
	mov	edx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	push	OFFSET ??_C@_0CI@NKPJALID@?$CF5d?4?5?$CF12?40f?5bytes?5at?5?$CFp?$DL?5?$CF18s?5li@
	push	edx
	call	_sprintf

; 312  :     outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	mov	esi, DWORD PTR [esi+4]
	add	esp, 36					; 00000024H
	test	esi, esi
	jne	SHORT $LL9@mem_list_d
$LN7@mem_list_d:

; 313  :   }
; 314  : 
; 315  :   outstring("\nTemporary memory blocks:\n");

	push	OFFSET ??_C@_0BL@BHLNJAGN@?6Temporary?5memory?5blocks?3?6?$AA@
	call	_outstring

; 316  :   for ( head = temp_block_head, subcount=0 ; head ; head = head->next )

	mov	esi, DWORD PTR _temp_block_head
	add	esp, 4
	xor	edi, edi
	test	esi, esi
	je	SHORT $LN4@mem_list_d
$LL6@mem_list_d:

; 317  :   { subcount++;
; 318  :     sprintf(msg,"%5d. %12.0f bytes at %p; %18s line %4d\n", 
; 319  :       subcount,(double)head->size,head,head->file,head->line);

	mov	ecx, DWORD PTR [esi+44]
	fild	DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+8]
	push	ecx
	lea	edx, DWORD PTR [esi+16]
	inc	edi
	push	edx
	push	esi
	test	eax, eax
	jns	SHORT $LN25@mem_list_d
	fadd	QWORD PTR __real@41f0000000000000
$LN25@mem_list_d:
	mov	ecx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	push	OFFSET ??_C@_0CI@NKPJALID@?$CF5d?4?5?$CF12?40f?5bytes?5at?5?$CFp?$DL?5?$CF18s?5li@
	push	ecx
	call	_sprintf

; 320  :     outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	mov	esi, DWORD PTR [esi+4]
	add	esp, 36					; 00000024H
	test	esi, esi
	jne	SHORT $LL6@mem_list_d
$LN4@mem_list_d:

; 321  :   }
; 322  : 
; 323  :   outstring("\nGraph memory blocks:\n");

	push	OFFSET ??_C@_0BH@PMBLDLCO@?6Graph?5memory?5blocks?3?6?$AA@
	call	_outstring

; 324  :   for ( head = graph_block_head, subcount=0 ; head ; head = head->next )

	mov	esi, DWORD PTR _graph_block_head
	add	esp, 4
	xor	edi, edi
	test	esi, esi
	je	SHORT $LN1@mem_list_d
$LL3@mem_list_d:

; 325  :   { subcount++;
; 326  :     sprintf(msg,"%5d. %12.0f bytes at %p; %18s line %4d\n", 
; 327  :       subcount,(double)head->size,head,head->file,head->line);

	mov	eax, DWORD PTR [esi+44]
	fild	DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+8]
	push	eax
	lea	ecx, DWORD PTR [esi+16]
	inc	edi
	push	ecx
	push	esi
	test	edx, edx
	jns	SHORT $LN26@mem_list_d
	fadd	QWORD PTR __real@41f0000000000000
$LN26@mem_list_d:
	mov	eax, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	push	OFFSET ??_C@_0CI@NKPJALID@?$CF5d?4?5?$CF12?40f?5bytes?5at?5?$CFp?$DL?5?$CF18s?5li@
	push	eax
	call	_sprintf

; 328  :     outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	mov	esi, DWORD PTR [esi+4]
	add	esp, 36					; 00000024H
	test	esi, esi
	jne	SHORT $LL3@mem_list_d
$LN1@mem_list_d:
	pop	edi
	pop	esi

; 329  :   }
; 330  : #else
; 331  :   outstring("\nEternal memory blocks:\n");
; 332  :   for ( head = eternal_block_head, subcount=0 ; head ; head = head->next )
; 333  :   { subcount++;
; 334  :     sprintf(msg,"%5ld. %12.0f bytes at %p\n", 
; 335  :       (long)subcount,(double)head->size,head);
; 336  :     outstring(msg);
; 337  :   }
; 338  : 
; 339  :   outstring("\nPermanent memory blocks:\n");
; 340  :   for ( head = perm_block_head, subcount=0 ; head ; head = head->next )
; 341  :   { subcount++;
; 342  :     sprintf(msg,"%5ld. %12.0f bytes at %p\n", 
; 343  :       (long)subcount,(double)head->size,head);
; 344  :     outstring(msg);
; 345  :   }
; 346  : 
; 347  :   outstring("\nTemporary memory blocks:\n");
; 348  :   for ( head = temp_block_head, subcount=0 ; head ; head = head->next )
; 349  :   { subcount++;
; 350  :     sprintf(msg,"%5ld. %12.0f bytes at %p\n", 
; 351  :       (long)subcount,(double)head->size,head);
; 352  :     outstring(msg);
; 353  :   }
; 354  : 
; 355  :   outstring("\nGraph memory blocks:\n");
; 356  :   for ( head = graph_block_head, subcount=0 ; head ; head = head->next )
; 357  :   { subcount++;
; 358  :     sprintf(msg,"%5ld. %12.0f bytes at %p\n", 
; 359  :       (long)subcount,(double)head->size,head);
; 360  :     outstring(msg);
; 361  :   }
; 362  : #endif
; 363  : } // end mem_list_dump()

	mov	esp, ebp
	pop	ebp
	ret	0
_mem_list_dump ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@PLPPKDKC@Requested?5from?5?$CFs?5line?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0DM@LHKGINJM@Internal?5error?3?5Cannot?5allocate?5@ ; `string'
PUBLIC	??_C@_0CM@IBJBBOIG@Internal?5error?3?5illegal?5memory?5b@ ; `string'
PUBLIC	_list_calloc
EXTRN	_memdebug:DWORD
EXTRN	_strncpy:PROC
EXTRN	_mem_mutex:DWORD
EXTRN	_calloc:PROC
;	COMDAT ??_C@_0BL@PLPPKDKC@Requested?5from?5?$CFs?5line?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BL@PLPPKDKC@Requested?5from?5?$CFs?5line?5?$CFd?6?$AA@ DB 'Request'
	DB	'ed from %s line %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@LHKGINJM@Internal?5error?3?5Cannot?5allocate?5@
CONST	SEGMENT
??_C@_0DM@LHKGINJM@Internal?5error?3?5Cannot?5allocate?5@ DB 'Internal er'
	DB	'ror: Cannot allocate memory size %lu*%lu = %lu.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IBJBBOIG@Internal?5error?3?5illegal?5memory?5b@
CONST	SEGMENT
??_C@_0CM@IBJBBOIG@Internal?5error?3?5illegal?5memory?5b@ DB 'Internal er'
	DB	'ror: illegal memory block type.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _list_calloc
_TEXT	SEGMENT
_listhead$ = -4						; size = 4
_num$ = 8						; size = 4
_size$ = 12						; size = 4
_type$ = 16						; size = 4
_file$ = 20						; size = 4
_line$ = 24						; size = 4
_list_calloc PROC					; COMDAT

; 391  : { struct memhead **listhead=NULL;

	push	ebp
	mov	ebp, esp
	push	ecx

; 392  :   struct memhead *ptr;
; 393  : 
; 394  :   switch(type)

	mov	eax, DWORD PTR _type$[ebp]
	mov	DWORD PTR _listhead$[ebp], 0
	cmp	eax, 56540				; 0000dcdcH
	jg	SHORT $LN13@list_callo
	je	SHORT $LN7@list_callo
	cmp	eax, 43947				; 0000ababH
	je	SHORT $LN8@list_callo
	cmp	eax, 52171				; 0000cbcbH
	jne	SHORT $LN4@list_callo

; 397  :     case GRAPH_BLOCK: listhead = &graph_block_head; break;

	mov	DWORD PTR _listhead$[ebp], OFFSET _graph_block_head
	jmp	SHORT $LN9@list_callo
$LN8@list_callo:

; 395  :   { case PERM_BLOCK: listhead = &perm_block_head; break;

	mov	DWORD PTR _listhead$[ebp], OFFSET _perm_block_head
	jmp	SHORT $LN9@list_callo
$LN7@list_callo:

; 396  :     case TEMP_BLOCK: listhead = &temp_block_head; break;

	mov	DWORD PTR _listhead$[ebp], OFFSET _temp_block_head
	jmp	SHORT $LN9@list_callo
$LN13@list_callo:

; 392  :   struct memhead *ptr;
; 393  : 
; 394  :   switch(type)

	cmp	eax, 60138				; 0000eaeaH
	je	SHORT $LN5@list_callo
$LN4@list_callo:

; 399  :     default: kb_error(2452,"Internal error: illegal memory block type.\n",
; 400  :        RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CM@IBJBBOIG@Internal?5error?3?5illegal?5memory?5b@
	push	2452					; 00000994H
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN9@list_callo
$LN5@list_callo:

; 398  :     case ETERNAL_BLOCK: listhead = &eternal_block_head; break;

	mov	DWORD PTR _listhead$[ebp], OFFSET _eternal_block_head
$LN9@list_callo:
	push	ebx

; 401  :   }
; 402  :   
; 403  :   ptr = (struct memhead *)calloc(sizeof(struct memhead)+num*size,1);

	mov	ebx, DWORD PTR _num$[ebp]
	push	esi
	push	edi
	mov	edi, ebx
	imul	edi, DWORD PTR _size$[ebp]
	lea	eax, DWORD PTR [edi+48]
	push	1
	push	eax
	call	_calloc
	mov	esi, eax
	add	esp, 8

; 404  :   if ( ptr == NULL )

	test	esi, esi
	jne	SHORT $LN16@list_callo

; 405  :   { 
; 406  :     mem_sanity_check(); 

	call	_mem_sanity_check

; 407  :     sprintf(errmsg,"Internal error: Cannot allocate memory size %lu*%lu = %lu.\n",
; 408  :       (unsigned long)num,(unsigned long)size,
; 409  :           (unsigned long)num*(unsigned long)size);

	mov	ecx, DWORD PTR _size$[ebp]
	push	edi
	push	ecx
	push	ebx
	push	OFFSET ??_C@_0DM@LHKGINJM@Internal?5error?3?5Cannot?5allocate?5@
	push	OFFSET _errmsg
	call	_sprintf

; 410  : #ifdef MEMSTRINGS
; 411  :     sprintf(msg+strlen(msg),"Requested from %s line %d\n",file,line);

	mov	edx, DWORD PTR _msg
	mov	eax, edx
	add	esp, 20					; 00000014H
	lea	ebx, DWORD PTR [eax+1]
	npad	4
$LL14@list_callo:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL14@list_callo
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	sub	eax, ebx
	add	eax, edx
	push	OFFSET ??_C@_0BL@PLPPKDKC@Requested?5from?5?$CFs?5line?5?$CFd?6?$AA@
	push	eax
	call	_sprintf

; 412  : #endif
; 413  :     kb_error(2550,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2550					; 000009f6H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN16@list_callo:

; 414  :   }
; 415  : 
; 416  :   /* fill in header */
; 417  :   ENTER_MEM_MUTEX

	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _mem_mutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20

; 418  :   ptr->next = *listhead;

	mov	eax, DWORD PTR _listhead$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [esi+4], edx

; 419  :   if ( *listhead )

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@list_callo

; 420  :     (*listhead)->prev = ptr;

	mov	DWORD PTR [ecx], esi
$LN2@list_callo:

; 421  :   *listhead = ptr;

	mov	DWORD PTR [eax], esi

; 422  :   LEAVE_MEM_MUTEX

	mov	eax, DWORD PTR _mem_mutex
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 423  :   ptr->size = num*size;
; 424  :   ptr->type = type;
; 425  : #ifdef MEMSTRINGS
; 426  :   strncpy(ptr->file,file,sizeof(ptr->file)-1);

	mov	edx, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	push	27					; 0000001bH
	push	edx
	lea	eax, DWORD PTR [esi+16]
	push	eax
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], ecx
	call	_strncpy

; 427  :   ptr->line = (int)line;

	mov	ecx, DWORD PTR _line$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+44], ecx

; 428  : #endif
; 429  :   
; 430  :   if ( memdebug ) 

	cmp	DWORD PTR _memdebug, 0
	je	SHORT $LN15@list_callo

; 431  :     mem_sanity_check();

	call	_mem_sanity_check
$LN15@list_callo:
	pop	edi

; 432  : 
; 433  :   return (char*)(ptr+1);

	lea	eax, DWORD PTR [esi+48]
	pop	esi
	pop	ebx

; 434  : } // end list_calloc()

	mov	esp, ebp
	pop	ebp
	ret	0
_list_calloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EI@CMBOIPEL@Internal?5error?3?5Cannot?5reallocat@ ; `string'
PUBLIC	??_C@_0CI@JPMALGNI@File?5?$CFs?0?5line?5?$CFd?$DL?5original?5alloc@ ; `string'
PUBLIC	??_C@_0ED@HKIJMNAF@Internal?5error?3?5Trying?5to?5reallo@ ; `string'
PUBLIC	_list_realloc
EXTRN	_realloc:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0EI@CMBOIPEL@Internal?5error?3?5Cannot?5reallocat@
CONST	SEGMENT
??_C@_0EI@CMBOIPEL@Internal?5error?3?5Cannot?5reallocat@ DB 'Internal err'
	DB	'or: Cannot reallocate memory from old size %lu to new %lu.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JPMALGNI@File?5?$CFs?0?5line?5?$CFd?$DL?5original?5alloc@
CONST	SEGMENT
??_C@_0CI@JPMALGNI@File?5?$CFs?0?5line?5?$CFd?$DL?5original?5alloc@ DB 'F'
	DB	'ile %s, line %d; original alloc %s:%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@HKIJMNAF@Internal?5error?3?5Trying?5to?5reallo@
CONST	SEGMENT
??_C@_0ED@HKIJMNAF@Internal?5error?3?5Trying?5to?5reallo@ DB 'Internal er'
	DB	'ror: Trying to realloc memory block to different list.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _list_realloc
_TEXT	SEGMENT
_listhead$ = -4						; size = 4
_oldsize$ = 8						; size = 4
_ptr$ = 8						; size = 4
_size$ = 12						; size = 4
_type$ = 16						; size = 4
_file$ = 20						; size = 4
_line$ = 24						; size = 4
_list_realloc PROC					; COMDAT

; 459  : { struct memhead **listhead=NULL;

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi

; 460  :   struct memhead *newhead;
; 461  :   struct memhead *oldhead;
; 462  :   char *newptr;
; 463  :   size_t oldsize;
; 464  : 
; 465  :   switch(type)

	mov	edi, DWORD PTR _type$[ebp]
	mov	DWORD PTR _listhead$[ebp], 0
	cmp	edi, 56540				; 0000dcdcH
	jg	SHORT $LN19@list_reall
	je	SHORT $LN13@list_reall
	cmp	edi, 43947				; 0000ababH
	je	SHORT $LN14@list_reall
	cmp	edi, 52171				; 0000cbcbH
	jne	SHORT $LN10@list_reall

; 468  :     case GRAPH_BLOCK: listhead = &graph_block_head; break;

	mov	DWORD PTR _listhead$[ebp], OFFSET _graph_block_head
	jmp	SHORT $LN15@list_reall
$LN14@list_reall:

; 466  :   { case PERM_BLOCK: listhead = &perm_block_head; break;

	mov	DWORD PTR _listhead$[ebp], OFFSET _perm_block_head
	jmp	SHORT $LN15@list_reall
$LN13@list_reall:

; 467  :     case TEMP_BLOCK: listhead = &temp_block_head; break;

	mov	DWORD PTR _listhead$[ebp], OFFSET _temp_block_head
	jmp	SHORT $LN15@list_reall
$LN19@list_reall:

; 460  :   struct memhead *newhead;
; 461  :   struct memhead *oldhead;
; 462  :   char *newptr;
; 463  :   size_t oldsize;
; 464  : 
; 465  :   switch(type)

	cmp	edi, 60138				; 0000eaeaH
	je	SHORT $LN11@list_reall
$LN10@list_reall:

; 470  :     default: kb_error(2453,"Internal error: illegal memory block type.\n",
; 471  :        RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CM@IBJBBOIG@Internal?5error?3?5illegal?5memory?5b@
	push	2453					; 00000995H
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN15@list_reall
$LN11@list_reall:

; 469  :     case ETERNAL_BLOCK: listhead = &eternal_block_head; break;

	mov	DWORD PTR _listhead$[ebp], OFFSET _eternal_block_head
$LN15@list_reall:

; 472  :   }
; 473  : 
; 474  : #ifdef MEMSTRINGS
; 475  :   if ( ptr == NULL ) return list_calloc(size,1,type,file,line);

	mov	esi, DWORD PTR _ptr$[ebp]
	test	esi, esi
	jne	SHORT $LN9@list_reall
	mov	eax, DWORD PTR _line$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR _size$[ebp]
	push	eax
	push	ecx
	push	edi
	push	1
	push	edx
	call	_list_calloc
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi

; 531  : 
; 532  : } /* end of list_realloc() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@list_reall:

; 476  : #else
; 477  :   if ( ptr == NULL ) return list_calloc(size,1,type);
; 478  : #endif
; 479  : 
; 480  :   oldhead = (struct memhead *)ptr - 1;

	add	esi, -48				; ffffffd0H

; 481  :   if ( oldhead->type != type )

	cmp	DWORD PTR [esi+12], edi
	je	SHORT $LN22@list_reall

; 482  :   { sprintf(errmsg,"Internal error: Trying to realloc memory block to different list.\n");

	push	OFFSET ??_C@_0ED@HKIJMNAF@Internal?5error?3?5Trying?5to?5reallo@
	push	OFFSET _errmsg
	call	_sprintf

; 483  :   #ifdef MEMSTRINGS
; 484  :     sprintf(errmsg+strlen(errmsg),"File %s, line %d; original alloc %s:%d\n",
; 485  :         file,line,oldhead->file,oldhead->line);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL20@list_reall:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL20@list_reall
	mov	ecx, DWORD PTR [esi+44]
	push	ecx
	mov	ecx, DWORD PTR _line$[ebp]
	sub	eax, edx
	lea	edx, DWORD PTR [esi+16]
	push	edx
	mov	edx, DWORD PTR _file$[ebp]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0CI@JPMALGNI@File?5?$CFs?0?5line?5?$CFd?$DL?5original?5alloc@
	push	eax
	call	_sprintf

; 486  :   #endif
; 487  :     kb_error(2448,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2448					; 00000990H
	call	_kb_error
	add	esp, 36					; 00000024H
$LN22@list_reall:

; 488  :   }
; 489  :   oldsize = oldhead->size;

	push	ebx
	mov	ebx, DWORD PTR [esi+8]

; 490  :  
; 491  :   ENTER_MEM_MUTEX  /* since manipulating shared variables */

	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _mem_mutex
	push	1
	mov	DWORD PTR _oldsize$[ebp], ebx
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20

; 492  :   /* delete from my list */
; 493  :   if ( oldhead->next ) oldhead->next->prev = oldhead->prev;

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN7@list_reall
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
$LN7@list_reall:

; 494  :   if ( oldhead->prev ) oldhead->prev->next = oldhead->next;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@list_reall
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN5@list_reall
$LN6@list_reall:

; 495  :   else *listhead = oldhead->next;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _listhead$[ebp]
	mov	DWORD PTR [ecx], eax
$LN5@list_reall:

; 496  : 
; 497  :   newhead = 
; 498  :      (struct memhead *)realloc((char*)oldhead,sizeof(struct memhead)+size);

	mov	edi, DWORD PTR _size$[ebp]
	lea	edx, DWORD PTR [edi+48]
	push	edx
	push	esi
	call	_realloc
	mov	esi, eax
	add	esp, 8

; 499  :   if ( newhead == NULL )

	test	esi, esi
	jne	SHORT $LN4@list_reall

; 500  :   { sprintf(errmsg,
; 501  :      "Internal error: Cannot reallocate memory from old size %lu to new %lu.\n",
; 502  :        (unsigned long)oldsize,(unsigned long)size);

	push	edi
	push	ebx
	push	OFFSET ??_C@_0EI@CMBOIPEL@Internal?5error?3?5Cannot?5reallocat@
	push	OFFSET _errmsg
	call	_sprintf

; 503  : #ifdef MEMSTRINGS
; 504  :     sprintf(msg+strlen(msg),"Requested from %s line %d\n",file,line);

	mov	edx, DWORD PTR _msg
	mov	eax, edx
	add	esp, 16					; 00000010H
	lea	ebx, DWORD PTR [eax+1]
$LL21@list_reall:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL21@list_reall
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	sub	eax, ebx
	add	eax, edx
	push	OFFSET ??_C@_0BL@PLPPKDKC@Requested?5from?5?$CFs?5line?5?$CFd?6?$AA@
	push	eax
	call	_sprintf

; 505  : #endif
; 506  :     kb_error(1360,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1360					; 00000550H
	call	_kb_error
	mov	ebx, DWORD PTR _oldsize$[ebp]
	add	esp, 28					; 0000001cH
$LN4@list_reall:

; 507  :   }
; 508  : 
; 509  :   /* fill in header */
; 510  :   newhead->next = *listhead;

	mov	eax, DWORD PTR _listhead$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [esi+4], edx

; 511  :   newhead->prev = NULL;

	mov	DWORD PTR [esi], 0

; 512  :   if ( *listhead )

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@list_reall

; 513  :     (*listhead)->prev = newhead;

	mov	DWORD PTR [ecx], esi
$LN3@list_reall:

; 514  :   *listhead = newhead;

	mov	DWORD PTR [eax], esi

; 515  :   LEAVE_MEM_MUTEX

	mov	eax, DWORD PTR _mem_mutex
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 516  :   newhead->size = size;
; 517  :   newhead->type = type;
; 518  : #ifdef MEMSTRINGS
; 519  :   strncpy(newhead->file,file,sizeof(newhead->file)-1);

	mov	edx, DWORD PTR _file$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	push	27					; 0000001bH
	push	edx
	lea	eax, DWORD PTR [esi+16]
	push	eax
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], ecx
	call	_strncpy

; 520  :   newhead->line = (int)line;

	mov	ecx, DWORD PTR _line$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+44], ecx

; 521  : #endif
; 522  :   
; 523  :   newptr = (char*)(newhead+1);
; 524  :   if (oldsize < size )  memset(newptr+oldsize,0,size-oldsize);

	cmp	ebx, edi
	jae	SHORT $LN23@list_reall
	sub	edi, ebx
	push	edi
	lea	edx, DWORD PTR [esi+ebx+48]
	push	0
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN23@list_reall:

; 525  : 
; 526  : 
; 527  :   if ( memdebug ) 

	cmp	DWORD PTR _memdebug, 0
	pop	ebx
	je	SHORT $LN1@list_reall

; 528  :     mem_sanity_check();

	call	_mem_sanity_check
$LN1@list_reall:
	pop	edi

; 529  : 
; 530  :   return newptr;

	lea	eax, DWORD PTR [esi+48]
	pop	esi

; 531  : 
; 532  : } /* end of list_realloc() */

	mov	esp, ebp
	pop	ebp
	ret	0
_list_realloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FL@DCDPCNAE@Internal?5error?3?5Trying?5to?5free?5m@ ; `string'
PUBLIC	??_C@_0O@DFPPHLPO@ETERNAL_BLOCK?$AA@		; `string'
PUBLIC	??_C@_07DPPMCAKL@corrupt?$AA@			; `string'
PUBLIC	??_C@_0L@PGFPFBIK@TEMP_BLOCK?$AA@		; `string'
PUBLIC	??_C@_0L@NCEBILFC@PERM_BLOCK?$AA@		; `string'
PUBLIC	??_C@_0M@LBHJJNPH@GRAPH_BLOCK?$AA@		; `string'
PUBLIC	??_C@_0BI@BMPABENM@?5?5allocated?5from?5?$CFs?3?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_list_free
EXTRN	_free:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0FL@DCDPCNAE@Internal?5error?3?5Trying?5to?5free?5m@
CONST	SEGMENT
??_C@_0FL@DCDPCNAE@Internal?5error?3?5Trying?5to?5free?5m@ DB 'Internal e'
	DB	'rror: Trying to free memory block of type %s from %s list.', 0aH
	DB	'Allocated from %s:%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DFPPHLPO@ETERNAL_BLOCK?$AA@
CONST	SEGMENT
??_C@_0O@DFPPHLPO@ETERNAL_BLOCK?$AA@ DB 'ETERNAL_BLOCK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DPPMCAKL@corrupt?$AA@
CONST	SEGMENT
??_C@_07DPPMCAKL@corrupt?$AA@ DB 'corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PGFPFBIK@TEMP_BLOCK?$AA@
CONST	SEGMENT
??_C@_0L@PGFPFBIK@TEMP_BLOCK?$AA@ DB 'TEMP_BLOCK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NCEBILFC@PERM_BLOCK?$AA@
CONST	SEGMENT
??_C@_0L@NCEBILFC@PERM_BLOCK?$AA@ DB 'PERM_BLOCK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LBHJJNPH@GRAPH_BLOCK?$AA@
CONST	SEGMENT
??_C@_0M@LBHJJNPH@GRAPH_BLOCK?$AA@ DB 'GRAPH_BLOCK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BMPABENM@?5?5allocated?5from?5?$CFs?3?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BI@BMPABENM@?5?5allocated?5from?5?$CFs?3?$CFd?6?$AA@ DB '  allocat'
	DB	'ed from %s:%d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _list_free
_TEXT	SEGMENT
_typename$89283 = -1008					; size = 4
_memmsg$89279 = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_ptr$ = 8						; size = 4
_type$ = 12						; size = 4
_list_free PROC						; COMDAT

; 545  : { struct memhead *head;

	push	ebp
	mov	ebp, esp
	sub	esp, 1008				; 000003f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _ptr$[ebp]

; 546  :   struct memhead **listhead=NULL;

	xor	ebx, ebx

; 547  : 
; 548  :   if ( !ptr )

	test	esi, esi
	jne	SHORT $LN30@list_free

; 549  :   { if ( memdebug ) erroutstring("\n");

	cmp	DWORD PTR _memdebug, ebx
	je	$LN1@list_free
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_erroutstring
	add	esp, 4
	pop	esi
	pop	ebx

; 615  : 
; 616  : } // end list_free()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@list_free:

; 550  :     return;
; 551  :   }
; 552  :   
; 553  :   if ( memdebug ) 

	cmp	DWORD PTR _memdebug, ebx
	je	SHORT $LN28@list_free

; 554  :     mem_sanity_check();

	call	_mem_sanity_check
$LN28@list_free:
	push	edi

; 555  :  
; 556  :   switch(type)

	mov	edi, DWORD PTR _type$[ebp]
	cmp	edi, 56540				; 0000dcdcH
	jg	SHORT $LN33@list_free
	je	SHORT $LN24@list_free
	cmp	edi, 43947				; 0000ababH
	je	SHORT $LN25@list_free
	cmp	edi, 52171				; 0000cbcbH
	jne	SHORT $LN21@list_free

; 559  :     case GRAPH_BLOCK: listhead = &graph_block_head; break;

	mov	ebx, OFFSET _graph_block_head
	jmp	SHORT $LN26@list_free
$LN25@list_free:

; 557  :   { case PERM_BLOCK: listhead = &perm_block_head; break;

	mov	ebx, OFFSET _perm_block_head
	jmp	SHORT $LN26@list_free
$LN24@list_free:

; 558  :     case TEMP_BLOCK: listhead = &temp_block_head; break;

	mov	ebx, OFFSET _temp_block_head
	jmp	SHORT $LN26@list_free
$LN33@list_free:

; 555  :  
; 556  :   switch(type)

	cmp	edi, 60138				; 0000eaeaH
	je	SHORT $LN22@list_free
$LN21@list_free:

; 561  :     default: kb_error(2454,"Internal error: illegal memory block type.\n",
; 562  :        RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CM@IBJBBOIG@Internal?5error?3?5illegal?5memory?5b@
	push	2454					; 00000996H
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN26@list_free
$LN22@list_free:

; 560  :     case ETERNAL_BLOCK: listhead = &eternal_block_head; break;

	mov	ebx, OFFSET _eternal_block_head
$LN26@list_free:

; 563  :   }
; 564  : 
; 565  :   head = (struct memhead *)ptr - 1;

	add	esi, -48				; ffffffd0H

; 566  : 
; 567  :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	je	SHORT $LN20@list_free

; 568  :   { char memmsg[1000];
; 569  : #ifdef MEMSTRINGS
; 570  :     sprintf(memmsg,"  allocated from %s:%d\n",head->file,head->line);

	mov	eax, DWORD PTR [esi+44]
	push	eax
	lea	ecx, DWORD PTR [esi+16]
	push	ecx
	lea	edx, DWORD PTR _memmsg$89279[ebp]
	push	OFFSET ??_C@_0BI@BMPABENM@?5?5allocated?5from?5?$CFs?3?$CFd?6?$AA@
	push	edx
	call	_sprintf

; 571  : #else
; 572  :     sprintf(memmsg,"\n");
; 573  : #endif
; 574  :     erroutstring(memmsg);

	lea	eax, DWORD PTR _memmsg$89279[ebp]
	push	eax
	call	_erroutstring
	add	esp, 20					; 00000014H
$LN20@list_free:

; 575  :   }
; 576  : 
; 577  :   if ( head->type != type )

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, edi
	je	$LN36@list_free

; 578  :   { char *headtypename,*typename;
; 579  :     switch ( head->type )

	cmp	eax, 56540				; 0000dcdcH
	jg	SHORT $LN34@list_free
	je	SHORT $LN15@list_free
	cmp	eax, 43947				; 0000ababH
	je	SHORT $LN14@list_free
	cmp	eax, 52171				; 0000cbcbH
	jne	SHORT $LN37@list_free

; 583  :       case GRAPH_BLOCK: headtypename = "GRAPH_BLOCK"; break;

	mov	ecx, OFFSET ??_C@_0M@LBHJJNPH@GRAPH_BLOCK?$AA@
	jmp	SHORT $LN17@list_free
$LN14@list_free:

; 582  :       case PERM_BLOCK: headtypename = "PERM_BLOCK"; break;

	mov	ecx, OFFSET ??_C@_0L@NCEBILFC@PERM_BLOCK?$AA@
	jmp	SHORT $LN17@list_free
$LN15@list_free:

; 581  :       case TEMP_BLOCK: headtypename = "TEMP_BLOCK"; break;

	mov	ecx, OFFSET ??_C@_0L@PGFPFBIK@TEMP_BLOCK?$AA@
	jmp	SHORT $LN17@list_free
$LN34@list_free:

; 578  :   { char *headtypename,*typename;
; 579  :     switch ( head->type )

	cmp	eax, 60138				; 0000eaeaH
	je	SHORT $LN16@list_free
$LN37@list_free:

; 584  :       default: headtypename = "corrupt";

	mov	ecx, OFFSET ??_C@_07DPPMCAKL@corrupt?$AA@
	jmp	SHORT $LN17@list_free
$LN16@list_free:

; 580  :     { case ETERNAL_BLOCK: headtypename = "ETERNAL_BLOCK"; break;

	mov	ecx, OFFSET ??_C@_0O@DFPPHLPO@ETERNAL_BLOCK?$AA@
$LN17@list_free:

; 585  :     }
; 586  :     switch ( type )

	cmp	edi, 56540				; 0000dcdcH
	jg	SHORT $LN35@list_free
	je	SHORT $LN8@list_free
	cmp	edi, 43947				; 0000ababH
	je	SHORT $LN7@list_free
	cmp	edi, 52171				; 0000cbcbH
	jne	SHORT $LN5@list_free

; 590  :       case GRAPH_BLOCK: typename = "GRAPH_BLOCK"; break;

	mov	eax, OFFSET ??_C@_0M@LBHJJNPH@GRAPH_BLOCK?$AA@
	jmp	SHORT $LN10@list_free
$LN7@list_free:

; 589  :       case PERM_BLOCK: typename = "PERM_BLOCK"; break;

	mov	eax, OFFSET ??_C@_0L@NCEBILFC@PERM_BLOCK?$AA@
	jmp	SHORT $LN10@list_free
$LN8@list_free:

; 588  :       case TEMP_BLOCK: typename = "TEMP_BLOCK"; break;

	mov	eax, OFFSET ??_C@_0L@PGFPFBIK@TEMP_BLOCK?$AA@
	jmp	SHORT $LN10@list_free
$LN35@list_free:

; 585  :     }
; 586  :     switch ( type )

	cmp	edi, 60138				; 0000eaeaH
	je	SHORT $LN9@list_free
$LN5@list_free:

; 591  :       default: headtypename = "corrupt";

	mov	eax, DWORD PTR _typename$89283[ebp]
	mov	ecx, OFFSET ??_C@_07DPPMCAKL@corrupt?$AA@
	jmp	SHORT $LN10@list_free
$LN9@list_free:

; 587  :     { case ETERNAL_BLOCK: typename = "ETERNAL_BLOCK"; break;

	mov	eax, OFFSET ??_C@_0O@DFPPHLPO@ETERNAL_BLOCK?$AA@
$LN10@list_free:

; 592  :     }
; 593  : #ifdef MEMSTRINGS
; 594  :     sprintf(errmsg,"Internal error: Trying to free memory block of type %s from %s list.\nAllocated from %s:%d\n",
; 595  :        headtypename,typename,head->file,head->line);

	mov	edx, DWORD PTR [esi+44]
	push	edx
	lea	edx, DWORD PTR [esi+16]
	push	edx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0FL@DCDPCNAE@Internal?5error?3?5Trying?5to?5free?5m@
	push	OFFSET _errmsg
	call	_sprintf

; 596  : #else
; 597  :     sprintf(errmsg,"Internal error: Trying to free memory block of type %s from %s list.\n",
; 598  :         headtypename,typename);
; 599  : 
; 600  : #endif
; 601  :     kb_error(2465,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2465					; 000009a1H
	call	_kb_error
	add	esp, 36					; 00000024H
$LN36@list_free:

; 602  : 
; 603  :    }
; 604  : 
; 605  :   /* delete from my list */
; 606  :   ENTER_MEM_MUTEX

	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _mem_mutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20

; 607  :   if ( head->next ) head->next->prev = head->prev;

	mov	eax, DWORD PTR [esi+4]
	pop	edi
	test	eax, eax
	je	SHORT $LN4@list_free
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
$LN4@list_free:

; 608  :   if ( head->prev ) head->prev->next = head->next;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@list_free
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@list_free
$LN3@list_free:

; 609  :   else *listhead = head->next;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ebx], eax
$LN2@list_free:

; 610  :   LEAVE_MEM_MUTEX

	mov	ecx, DWORD PTR _mem_mutex
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 611  :   free((char*)head);

	push	esi
	call	_free
	add	esp, 4

; 612  : 
; 613  :   if ( memdebug ) 

	cmp	DWORD PTR _memdebug, 0
	je	SHORT $LN1@list_free

; 614  :     mem_sanity_check();

	call	_mem_sanity_check
$LN1@list_free:

; 615  : 
; 616  : } // end list_free()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_list_free ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@LNODAPOO@Freeing?5?$CFp?0?5?$CFd?5bytes?0?5allocated?5@ ; `string'
PUBLIC	??_C@_0CG@LEBINADL@Internal?5error?3?5corrupt?5memory?5l@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_list_free_all
;	COMDAT ??_C@_0CK@LNODAPOO@Freeing?5?$CFp?0?5?$CFd?5bytes?0?5allocated?5@
CONST	SEGMENT
??_C@_0CK@LNODAPOO@Freeing?5?$CFp?0?5?$CFd?5bytes?0?5allocated?5@ DB 'Fre'
	DB	'eing %p, %d bytes, allocated at %s:%d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@LEBINADL@Internal?5error?3?5corrupt?5memory?5l@
CONST	SEGMENT
??_C@_0CG@LEBINADL@Internal?5error?3?5corrupt?5memory?5l@ DB 'Internal er'
	DB	'ror: corrupt memory list.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _list_free_all
_TEXT	SEGMENT
_memmsg$89335 = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_type$ = 8						; size = 4
_list_free_all PROC					; COMDAT

; 626  : { struct memhead **listhead=NULL;

	push	ebp
	mov	ebp, esp
	sub	esp, 1004				; 000003ecH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi

; 627  :   struct memhead *head,*nexthead;
; 628  : 
; 629  :   switch(type)

	mov	edi, DWORD PTR _type$[ebp]
	xor	ebx, ebx
	cmp	edi, 56540				; 0000dcdcH
	jg	SHORT $LN15@list_free_
	je	SHORT $LN9@list_free_
	cmp	edi, 43947				; 0000ababH
	je	SHORT $LN10@list_free_
	cmp	edi, 52171				; 0000cbcbH
	jne	SHORT $LN6@list_free_

; 632  :     case GRAPH_BLOCK: listhead = &graph_block_head; break;

	mov	ebx, OFFSET _graph_block_head
	jmp	SHORT $LN11@list_free_
$LN10@list_free_:

; 630  :   { case PERM_BLOCK: listhead = &perm_block_head; break;

	mov	ebx, OFFSET _perm_block_head
	jmp	SHORT $LN11@list_free_
$LN9@list_free_:

; 631  :     case TEMP_BLOCK: listhead = &temp_block_head; break;

	mov	ebx, OFFSET _temp_block_head
	jmp	SHORT $LN11@list_free_
$LN15@list_free_:

; 627  :   struct memhead *head,*nexthead;
; 628  : 
; 629  :   switch(type)

	cmp	edi, 60138				; 0000eaeaH
	je	SHORT $LN7@list_free_
$LN6@list_free_:

; 634  :     default: kb_error(2455,"Internal error: illegal memory block type.\n",
; 635  :        RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CM@IBJBBOIG@Internal?5error?3?5illegal?5memory?5b@
	push	2455					; 00000997H
	call	_kb_error
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN11@list_free_
$LN7@list_free_:

; 633  :     case ETERNAL_BLOCK: listhead = &eternal_block_head; break;

	mov	ebx, OFFSET _eternal_block_head
$LN11@list_free_:

; 636  :   }
; 637  : 
; 638  :   ENTER_MEM_MUTEX

	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _mem_mutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20

; 639  :   for ( head = *listhead; head ; head = nexthead )

	mov	esi, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN3@list_free_
	jmp	SHORT $LN5@list_free_
	npad	5
$LL18@list_free_:
	mov	edi, DWORD PTR _type$[ebp]
$LN5@list_free_:

; 640  :   { if ( head->type != type )

	cmp	DWORD PTR [esi+12], edi
	je	SHORT $LN2@list_free_

; 641  :       kb_error(3905,"Internal error: corrupt memory list.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CG@LEBINADL@Internal?5error?3?5corrupt?5memory?5l@
	push	3905					; 00000f41H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN2@list_free_:

; 642  :     if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	je	SHORT $LN1@list_free_

; 643  :     { char memmsg[1000];
; 644  : #ifdef MEMSTRINGS
; 645  :        sprintf(memmsg,"Freeing %p, %d bytes, allocated at %s:%d\n",head+1,
; 646  :            head->size,head->file,head->line);

	mov	eax, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [esi+8]
	push	eax
	lea	ecx, DWORD PTR [esi+16]
	push	ecx
	push	edx
	lea	eax, DWORD PTR [esi+48]
	push	eax
	lea	ecx, DWORD PTR _memmsg$89335[ebp]
	push	OFFSET ??_C@_0CK@LNODAPOO@Freeing?5?$CFp?0?5?$CFd?5bytes?0?5allocated?5@
	push	ecx
	call	_sprintf

; 647  : #else
; 648  :        sprintf(memmsg,"Freeing %p, %ld bytes\n",head+1,(long)head->size);
; 649  : #endif
; 650  :        erroutstring(memmsg);

	lea	edx, DWORD PTR _memmsg$89335[ebp]
	push	edx
	call	_erroutstring
	add	esp, 28					; 0000001cH
$LN1@list_free_:

; 651  :     }
; 652  :     nexthead = head->next;

	mov	edi, DWORD PTR [esi+4]

; 653  :     free((char*)head);

	push	esi
	call	_free
	add	esp, 4
	mov	esi, edi
	test	edi, edi
	jne	SHORT $LL18@list_free_
$LN3@list_free_:

; 654  :   }
; 655  :   *listhead = NULL;
; 656  :   LEAVE_MEM_MUTEX

	mov	eax, DWORD PTR _mem_mutex
	push	eax
	mov	DWORD PTR [ebx], 0
	call	DWORD PTR __imp__ReleaseMutex@4

; 657  : } /* end list_free_all */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_list_free_all ENDP
_TEXT	ENDS
PUBLIC	??_C@_06CHNCNINF@at?5?$CFp?6?$AA@		; `string'
PUBLIC	??_C@_0BM@IJHHPNJO@mycalloc?5?$CF30?430s?5?$CF5d?3?5?$CF10d?5?$AA@ ; `string'
PUBLIC	_kb_calloc
;	COMDAT ??_C@_06CHNCNINF@at?5?$CFp?6?$AA@
CONST	SEGMENT
??_C@_06CHNCNINF@at?5?$CFp?6?$AA@ DB 'at %p', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IJHHPNJO@mycalloc?5?$CF30?430s?5?$CF5d?3?5?$CF10d?5?$AA@
CONST	SEGMENT
??_C@_0BM@IJHHPNJO@mycalloc?5?$CF30?430s?5?$CF5d?3?5?$CF10d?5?$AA@ DB 'my'
	DB	'calloc %30.30s %5d: %10d ', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _kb_calloc
_TEXT	SEGMENT
_num$ = 8						; size = 4
_size$ = 12						; size = 4
_file$ = 16						; size = 4
_line$ = 20						; size = 4
_kb_calloc PROC						; COMDAT

; 688  : { char *ptr;

	push	ebp
	mov	ebp, esp

; 689  : 
; 690  :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	push	ebx
	mov	ebx, DWORD PTR _size$[ebp]
	push	esi
	mov	esi, DWORD PTR _line$[ebp]
	push	edi
	mov	edi, DWORD PTR _file$[ebp]
	je	SHORT $LN2@kb_calloc

; 691  :   {
; 692  : #ifdef MEMSTRINGS
; 693  :     sprintf(errmsg,"mycalloc %30.30s %5d: %10d ",file,line,num*size);

	mov	eax, DWORD PTR _num$[ebp]
	imul	eax, ebx
	push	eax
	push	esi
	push	edi
	push	OFFSET ??_C@_0BM@IJHHPNJO@mycalloc?5?$CF30?430s?5?$CF5d?3?5?$CF10d?5?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 694  :     erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 24					; 00000018H
$LN2@kb_calloc:

; 695  : #else
; 696  :     sprintf(errmsg,"mycalloc %lu*%lu = %lu bytes ",(unsigned long)num,
; 697  :        (unsigned long)size,(unsigned long)num*size);
; 698  :     erroutstring(errmsg); 
; 699  : #endif
; 700  :   }
; 701  : 
; 702  : #ifdef MEMSTRINGS
; 703  :   ptr = list_calloc(num,size,PERM_BLOCK,file,line);

	mov	ecx, DWORD PTR _num$[ebp]
	push	esi
	push	edi
	push	43947					; 0000ababH
	push	ebx
	push	ecx
	call	_list_calloc
	add	esp, 20					; 00000014H

; 704  : #else
; 705  :   ptr = list_calloc(num,size,PERM_BLOCK);
; 706  : #endif
; 707  : 
; 708  :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	mov	esi, eax
	je	SHORT $LN5@kb_calloc

; 709  :   { sprintf(errmsg,"at %p\n",ptr); erroutstring(errmsg);

	push	esi
	push	OFFSET ??_C@_06CHNCNINF@at?5?$CFp?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf
	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 16					; 00000010H

; 710  :     mem_sanity_check();

	call	_mem_sanity_check
$LN5@kb_calloc:

; 711  :   }
; 712  : 
; 713  :   return ptr;

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 714  : }  /* end kb_calloc */

	pop	ebp
	ret	0
_kb_calloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@JHBCEEKN@?$CF30?430s?5?$CF4d?3?5realloc?5old?5?$CFp?5size@ ; `string'
PUBLIC	_KB_realloc
;	COMDAT ??_C@_0DB@JHBCEEKN@?$CF30?430s?5?$CF4d?3?5realloc?5old?5?$CFp?5size@
CONST	SEGMENT
??_C@_0DB@JHBCEEKN@?$CF30?430s?5?$CF4d?3?5realloc?5old?5?$CFp?5size@ DB '%'
	DB	'30.30s %4d: realloc old %p size %d to size %d ', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _KB_realloc
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_size$ = 12						; size = 4
_file$ = 16						; size = 4
_line$ = 20						; size = 4
_KB_realloc PROC					; COMDAT

; 738  : { char *newptr;

	push	ebp
	mov	ebp, esp

; 739  : 
; 740  :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	push	ebx
	mov	ebx, DWORD PTR _file$[ebp]
	push	esi
	mov	esi, DWORD PTR _ptr$[ebp]
	push	edi
	mov	edi, DWORD PTR _line$[ebp]
	je	SHORT $LN4@KB_realloc

; 741  :   { 
; 742  : #ifdef MEMSTRINGS
; 743  :      sprintf(errmsg,"%30.30s %4d: realloc old %p size %d to size %d \n",
; 744  :          file,line,ptr, (ptr ? ((struct memhead *)ptr)[-1].size:0) ,size);

	test	esi, esi
	je	SHORT $LN7@KB_realloc
	mov	eax, DWORD PTR [esi-40]
	jmp	SHORT $LN8@KB_realloc
$LN7@KB_realloc:
	xor	eax, eax
$LN8@KB_realloc:
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	eax
	push	esi
	push	edi
	push	ebx
	push	OFFSET ??_C@_0DB@JHBCEEKN@?$CF30?430s?5?$CF4d?3?5realloc?5old?5?$CFp?5size@
	push	OFFSET _errmsg
	call	_sprintf

; 745  : #else
; 746  :      sprintf(errmsg,"realloc old %p size %ld to size %ld \n",ptr,
; 747  :          (long) (ptr ? ((struct memhead *)ptr)[-1].size:0 ) ,(long)size);
; 748  : #endif
; 749  :      erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 32					; 00000020H
$LN4@KB_realloc:

; 750  :   }
; 751  : 
; 752  : #ifdef MEMSTRINGS
; 753  :   if ( ptr == NULL ) newptr = kb_calloc(size,1,file,line);

	push	edi
	push	ebx
	test	esi, esi
	jne	SHORT $LN3@KB_realloc
	mov	edx, DWORD PTR _size$[ebp]
	push	1
	push	edx
	call	_kb_calloc
	add	esp, 16					; 00000010H
	jmp	SHORT $LN10@KB_realloc
$LN3@KB_realloc:

; 754  :   else newptr = list_realloc(ptr,size,PERM_BLOCK,file,line);

	mov	eax, DWORD PTR _size$[ebp]
	push	43947					; 0000ababH
	push	eax
	push	esi
	call	_list_realloc
	add	esp, 20					; 00000014H
$LN10@KB_realloc:

; 755  : #else
; 756  :   if ( ptr == NULL ) newptr = mycalloc(size,1);
; 757  :   else newptr = list_realloc(ptr,size,PERM_BLOCK);
; 758  : #endif
; 759  : 
; 760  :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	mov	esi, eax
	je	SHORT $LN9@KB_realloc

; 761  :   { sprintf(errmsg,"at %p\n",newptr); erroutstring(errmsg);

	push	esi
	push	OFFSET ??_C@_06CHNCNINF@at?5?$CFp?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf
	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 16					; 00000010H

; 762  :     mem_sanity_check();

	call	_mem_sanity_check
$LN9@KB_realloc:

; 763  :   }
; 764  : 
; 765  :   return newptr;

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 766  : } /* end KB_realloc() */

	pop	ebp
	ret	0
_KB_realloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_08MOBFEEMD@free?5?$CFp?5?$AA@		; `string'
PUBLIC	_myfree
;	COMDAT ??_C@_08MOBFEEMD@free?5?$CFp?5?$AA@
CONST	SEGMENT
??_C@_08MOBFEEMD@free?5?$CFp?5?$AA@ DB 'free %p ', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _myfree
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_myfree	PROC						; COMDAT

; 777  : { 

	push	ebp
	mov	ebp, esp

; 778  :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	push	esi
	mov	esi, DWORD PTR _ptr$[ebp]
	je	SHORT $LN1@myfree

; 779  :   { 
; 780  :      sprintf(errmsg,"free %p ",ptr);

	push	esi
	push	OFFSET ??_C@_08MOBFEEMD@free?5?$CFp?5?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 781  :      erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 16					; 00000010H
$LN1@myfree:

; 782  :   }
; 783  : 
; 784  :   list_free(ptr,PERM_BLOCK);

	push	43947					; 0000ababH
	push	esi
	call	_list_free
	add	esp, 8
	pop	esi

; 785  : } // end myfree()

	pop	ebp
	ret	0
_myfree	ENDP
_TEXT	ENDS
PUBLIC	??_C@_07DJKLNPDP@at?5?$CFp?5?6?$AA@		; `string'
PUBLIC	??_C@_0BI@MBINLGOC@temp_calloc?5?$CF9ld?5bytes?5?$AA@ ; `string'
PUBLIC	??_C@_0O@FGJIHLMM@?$CF30?430s?5?$CF4d?3?5?$AA@	; `string'
PUBLIC	_kb_temp_calloc
;	COMDAT ??_C@_07DJKLNPDP@at?5?$CFp?5?6?$AA@
CONST	SEGMENT
??_C@_07DJKLNPDP@at?5?$CFp?5?6?$AA@ DB 'at %p ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MBINLGOC@temp_calloc?5?$CF9ld?5bytes?5?$AA@
CONST	SEGMENT
??_C@_0BI@MBINLGOC@temp_calloc?5?$CF9ld?5bytes?5?$AA@ DB 'temp_calloc %9l'
	DB	'd bytes ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FGJIHLMM@?$CF30?430s?5?$CF4d?3?5?$AA@
CONST	SEGMENT
??_C@_0O@FGJIHLMM@?$CF30?430s?5?$CF4d?3?5?$AA@ DB '%30.30s %4d: ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _kb_temp_calloc
_TEXT	SEGMENT
_num$ = 8						; size = 4
_size$ = 12						; size = 4
_file$ = 16						; size = 4
_line$ = 20						; size = 4
_kb_temp_calloc PROC					; COMDAT

; 817  : { char *ptr;

	push	ebp
	mov	ebp, esp

; 818  :   int blocktype = TEMP_BLOCK;
; 819  :  
; 820  :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	push	ebx
	mov	ebx, DWORD PTR _size$[ebp]
	push	esi
	mov	esi, DWORD PTR _line$[ebp]
	push	edi
	mov	edi, DWORD PTR _file$[ebp]
	je	SHORT $LN2@kb_temp_ca

; 821  :   {
; 822  : #ifdef MEMSTRINGS
; 823  :     sprintf(errmsg,"%30.30s %4d: ",file,line);

	push	esi
	push	edi
	push	OFFSET ??_C@_0O@FGJIHLMM@?$CF30?430s?5?$CF4d?3?5?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 824  :     erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 825  : #endif
; 826  :     sprintf(errmsg,"temp_calloc %9ld bytes ",(long)num*size);

	mov	eax, DWORD PTR _num$[ebp]
	imul	eax, ebx
	push	eax
	push	OFFSET ??_C@_0BI@MBINLGOC@temp_calloc?5?$CF9ld?5bytes?5?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 827  :     erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 36					; 00000024H
$LN2@kb_temp_ca:

; 828  :   }
; 829  : 
; 830  :   THREADBLOCK(blocktype);  // set GRAPH_BLOCK or TEMP_BLOCK

	call	DWORD PTR __imp__GetCurrentThreadId@0

; 831  : 
; 832  : #ifdef MEMSTRINGS
; 833  :   ptr = list_calloc(num,size,blocktype,file,line);

	mov	edx, DWORD PTR _num$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR _draw_thread_id
	sub	eax, ecx
	neg	eax
	sbb	eax, eax
	push	esi
	and	eax, 4369				; 00001111H
	push	edi
	add	eax, 52171				; 0000cbcbH
	push	eax
	push	ebx
	push	edx
	call	_list_calloc
	add	esp, 20					; 00000014H

; 834  : #else
; 835  :   ptr = list_calloc(num,size,blocktype);
; 836  : #endif
; 837  : 
; 838  :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	mov	esi, eax
	je	SHORT $LN5@kb_temp_ca

; 839  :   { sprintf(errmsg,"at %p \n",ptr); erroutstring(errmsg);

	push	esi
	push	OFFSET ??_C@_07DJKLNPDP@at?5?$CFp?5?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf
	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 16					; 00000010H

; 840  :     mem_sanity_check();

	call	_mem_sanity_check
$LN5@kb_temp_ca:

; 841  :   }
; 842  : 
; 843  :   return ptr;

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 844  : } // end kb_temp_calloc()

	pop	ebp
	ret	0
_kb_temp_calloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_08DIHBJGFL@?5at?5?$CFp?5?6?$AA@		; `string'
PUBLIC	??_C@_0DK@NJKNAEBD@?$CF30?430s?5?$CF4d?3?5temp_realloc?6?5old?5s@ ; `string'
PUBLIC	_kb_temp_realloc
;	COMDAT ??_C@_08DIHBJGFL@?5at?5?$CFp?5?6?$AA@
CONST	SEGMENT
??_C@_08DIHBJGFL@?5at?5?$CFp?5?6?$AA@ DB ' at %p ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@NJKNAEBD@?$CF30?430s?5?$CF4d?3?5temp_realloc?6?5old?5s@
CONST	SEGMENT
??_C@_0DK@NJKNAEBD@?$CF30?430s?5?$CF4d?3?5temp_realloc?6?5old?5s@ DB '%30'
	DB	'.30s %4d: temp_realloc', 0aH, ' old size %9d at %p to size %9'
	DB	'd', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _kb_temp_realloc
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_size$ = 12						; size = 4
_file$ = 16						; size = 4
_line$ = 20						; size = 4
_kb_temp_realloc PROC					; COMDAT

; 867  : {

	push	ebp
	mov	ebp, esp

; 868  :   char *newptr;
; 869  :   int blocktype = TEMP_BLOCK;
; 870  : 
; 871  :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	push	ebx
	mov	ebx, DWORD PTR _file$[ebp]
	push	esi
	mov	esi, DWORD PTR _ptr$[ebp]
	push	edi
	mov	edi, DWORD PTR _line$[ebp]
	je	SHORT $LN2@kb_temp_re

; 872  :   { 
; 873  : #ifdef MEMSTRINGS
; 874  :     sprintf(errmsg,"%30.30s %4d: temp_realloc\n old size %9d at %p to size %9d",
; 875  :          file,line, (ptr ? ((struct memhead *)ptr)[-1].size:0),ptr ,size);

	test	esi, esi
	je	SHORT $LN5@kb_temp_re
	mov	eax, DWORD PTR [esi-40]
	jmp	SHORT $LN6@kb_temp_re
$LN5@kb_temp_re:
	xor	eax, eax
$LN6@kb_temp_re:
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	push	esi
	push	eax
	push	edi
	push	ebx
	push	OFFSET ??_C@_0DK@NJKNAEBD@?$CF30?430s?5?$CF4d?3?5temp_realloc?6?5old?5s@
	push	OFFSET _errmsg
	call	_sprintf

; 876  : #else
; 877  :     sprintf(errmsg,"temp_realloc old %p size %9ld to size %9ld",ptr,
; 878  :           (long)(ptr ? ((struct memhead *)ptr)[-1].size:0 ) ,(long)size);
; 879  : #endif
; 880  :     erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 32					; 00000020H
$LN2@kb_temp_re:

; 881  :   }
; 882  : 
; 883  :   THREADBLOCK(blocktype);

	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	edx, eax
	mov	eax, DWORD PTR _draw_thread_id
	sub	eax, edx
	neg	eax
	sbb	eax, eax

; 884  : 
; 885  : #ifdef MEMSTRINGS
; 886  :   newptr = list_realloc(ptr,size,blocktype,file,line);

	push	edi
	and	eax, 4369				; 00001111H
	add	eax, 52171				; 0000cbcbH
	push	ebx
	push	eax
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	push	esi
	call	_list_realloc
	add	esp, 20					; 00000014H

; 887  : #else
; 888  :   newptr = list_realloc(ptr,size,blocktype);
; 889  : #endif
; 890  : 
; 891  :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	mov	esi, eax
	je	SHORT $LN7@kb_temp_re

; 892  :   { sprintf(errmsg," at %p \n",newptr); erroutstring(errmsg);

	push	esi
	push	OFFSET ??_C@_08DIHBJGFL@?5at?5?$CFp?5?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf
	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 16					; 00000010H

; 893  :     mem_sanity_check();

	call	_mem_sanity_check
$LN7@kb_temp_re:

; 894  :   }
; 895  : 
; 896  :   return newptr;

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 897  : } // end kb_temp_realloc()

	pop	ebp
	ret	0
_kb_temp_realloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@BJHIJOGJ@temp_free?5?$CFp?5?$AA@	; `string'
PUBLIC	_temp_free
;	COMDAT ??_C@_0O@BJHIJOGJ@temp_free?5?$CFp?5?$AA@
CONST	SEGMENT
??_C@_0O@BJHIJOGJ@temp_free?5?$CFp?5?$AA@ DB 'temp_free %p ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _temp_free
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_temp_free PROC						; COMDAT

; 909  : {

	push	ebp
	mov	ebp, esp

; 910  :   int blocktype = TEMP_BLOCK;
; 911  :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	push	esi
	mov	esi, DWORD PTR _ptr$[ebp]
	je	SHORT $LN1@temp_free

; 912  :   { 
; 913  :      sprintf(errmsg,"temp_free %p ",ptr);

	push	esi
	push	OFFSET ??_C@_0O@BJHIJOGJ@temp_free?5?$CFp?5?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 914  :      erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 16					; 00000010H
$LN1@temp_free:

; 915  :   }
; 916  :   THREADBLOCK(blocktype);

	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	ecx, eax
	mov	eax, DWORD PTR _draw_thread_id
	sub	eax, ecx
	neg	eax
	sbb	eax, eax
	and	eax, 4369				; 00001111H
	add	eax, 52171				; 0000cbcbH

; 917  : 
; 918  :   list_free(ptr,blocktype);

	push	eax
	push	esi
	call	_list_free
	add	esp, 8
	pop	esi

; 919  : 
; 920  : } /* end temp_free */

	pop	ebp
	ret	0
_temp_free ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@PJIBFPPF@Entering?5temp_free_all?6?$AA@ ; `string'
PUBLIC	_temp_free_all
EXTRN	_v_curve:DWORD
EXTRN	_e_curve:DWORD
EXTRN	_vpressures:DWORD
EXTRN	_rightside:DWORD
EXTRN	_vgradbase:DWORD
EXTRN	_conrhs:DWORD
EXTRN	_pressures:DWORD
EXTRN	_vhead:DWORD
EXTRN	_saved:BYTE
;	COMDAT ??_C@_0BI@PJIBFPPF@Entering?5temp_free_all?6?$AA@
CONST	SEGMENT
??_C@_0BI@PJIBFPPF@Entering?5temp_free_all?6?$AA@ DB 'Entering temp_free_'
	DB	'all', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _temp_free_all
_TEXT	SEGMENT
_temp_free_all PROC					; COMDAT

; 931  : {

	push	edi

; 932  :   int blocktype = 0;
; 933  : 
; 934  :   #ifdef _DEBUGXX
; 935  :   int oldmemdebug = memdebug;
; 936  :   memdebug=1;
; 937  :   #endif
; 938  :   
; 939  :  if ( memdebug )

	xor	edi, edi
	cmp	DWORD PTR _memdebug, edi
	je	SHORT $LN2@temp_free_

; 940  :     erroutstring("Entering temp_free_all\n");

	push	OFFSET ??_C@_0BI@PJIBFPPF@Entering?5temp_free_all?6?$AA@
	call	_erroutstring
	add	esp, 4
$LN2@temp_free_:

; 941  :     
; 942  :   THREADBLOCK(blocktype);

	push	esi
	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	esi, DWORD PTR _draw_thread_id
	sub	esi, eax
	neg	esi
	sbb	esi, esi
	and	esi, 4369				; 00001111H
	add	esi, 52171				; 0000cbcbH

; 943  :   list_free_all(blocktype);

	push	esi
	call	_list_free_all
	add	esp, 4

; 944  : 
; 945  :   #ifdef MPI_EVOLVER
; 946  :   if ( this_task == 0 && blocktype != GRAPH_BLOCK )
; 947  :     mpi_temp_free_all();
; 948  :   #endif
; 949  :   
; 950  :   #ifdef _DEBUGXX
; 951  :   memdebug = oldmemdebug;
; 952  :   #endif
; 953  : 
; 954  :   /* pointers to be annulled in main thread */
; 955  :   if ( blocktype == TEMP_BLOCK )

	cmp	esi, 56540				; 0000dcdcH
	pop	esi
	jne	SHORT $LN1@temp_free_

; 956  :   {
; 957  :     saved.coord = NULL;

	mov	DWORD PTR _saved, edi

; 958  :     vhead = NULL;

	mov	DWORD PTR _vhead, edi

; 959  :     pressures = NULL;

	mov	DWORD PTR _pressures, edi

; 960  :     conrhs = NULL;

	mov	DWORD PTR _conrhs, edi

; 961  :     vgradbase = NULL;

	mov	DWORD PTR _vgradbase, edi

; 962  :     rightside = NULL;

	mov	DWORD PTR _rightside, edi

; 963  :     vpressures = NULL;

	mov	DWORD PTR _vpressures, edi

; 964  :     e_curve = NULL;

	mov	DWORD PTR _e_curve, edi

; 965  :     v_curve = NULL;

	mov	DWORD PTR _v_curve, edi
$LN1@temp_free_:
	pop	edi

; 966  :   }
; 967  : } // end temp_free_all()

	ret	0
_temp_free_all ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@HLNEFKCI@expanding?5dymem?4?6?$AA@	; `string'
PUBLIC	??_C@_0BM@JFBAMDME@dy_alloc?5?$CFd?$CK?$CFd?5?$DN?5?$CFd?5bytes?4?6?$AA@ ; `string'
PUBLIC	??_C@_06BJONIOEN@DY_MEM?$AA@			; `string'
PUBLIC	??_C@_09GDMJAJJP@UTILITY?4C?$AA@		; `string'
PUBLIC	_dy_calloc
EXTRN	_Extras:BYTE
EXTRN	_Globals:DWORD
EXTRN	_dymemsize:DWORD
;	COMDAT ??_C@_0BC@HLNEFKCI@expanding?5dymem?4?6?$AA@
CONST	SEGMENT
??_C@_0BC@HLNEFKCI@expanding?5dymem?4?6?$AA@ DB 'expanding dymem.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JFBAMDME@dy_alloc?5?$CFd?$CK?$CFd?5?$DN?5?$CFd?5bytes?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@JFBAMDME@dy_alloc?5?$CFd?$CK?$CFd?5?$DN?5?$CFd?5bytes?4?6?$AA@ DB 'd'
	DB	'y_alloc %d*%d = %d bytes.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06BJONIOEN@DY_MEM?$AA@
CONST	SEGMENT
??_C@_06BJONIOEN@DY_MEM?$AA@ DB 'DY_MEM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GDMJAJJP@UTILITY?4C?$AA@
CONST	SEGMENT
??_C@_09GDMJAJJP@UTILITY?4C?$AA@ DB 'UTILITY.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _dy_calloc
_TEXT	SEGMENT
_needed$ = 8						; size = 4
_num$ = 8						; size = 4
_size$ = 12						; size = 4
_dy_calloc PROC						; COMDAT

; 1001 : { struct dy_head *ptr,*newptr,*lastptr;

	push	ebp
	mov	ebp, esp
	push	ebx

; 1002 :   DY_OFFSET off;
; 1003 :   int needed;
; 1004 :   int surplus;
; 1005 :   int asize;
; 1006 :   int i;
; 1007 :   
; 1008 :   if ( dymemsize == 0 )  /* initial allocation */

	xor	ebx, ebx
	push	esi
	push	edi
	cmp	DWORD PTR _dymemsize, ebx
	jne	$LN31@dy_calloc

; 1009 :   { if ( sizeof(struct dy_head) % ALIGNSIZE )
; 1010 :     { sprintf(errmsg,
; 1011 :    "Internal error: sizeof(struct dy_head) %ld not multiple of ALIGNSIZE %d\n",
; 1012 :         (long)sizeof(struct dy_head),ALIGNSIZE);
; 1013 :       kb_error(1364,errmsg,UNRECOVERABLE);
; 1014 :     }
; 1015 :     dymem = mycalloc(DY_STARTSIZE,1);

	push	1015					; 000003f7H
	push	OFFSET ??_C@_09GDMJAJJP@UTILITY?4C?$AA@
	push	1
	push	4096					; 00001000H
	call	_kb_calloc

; 1016 :     dymemsize = DY_STARTSIZE;
; 1017 :     strcpy(dymem,"DY_MEM"); /* so looks pretty in debugger */

	mov	ecx, DWORD PTR ??_C@_06BJONIOEN@DY_MEM?$AA@
	mov	DWORD PTR _dymem, eax
	mov	DWORD PTR _dymemsize, 4096		; 00001000H
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR ??_C@_06BJONIOEN@DY_MEM?$AA@+4
	mov	eax, DWORD PTR _dymem
	mov	WORD PTR [eax+4], dx
	mov	cl, BYTE PTR ??_C@_06BJONIOEN@DY_MEM?$AA@+6
	mov	edx, DWORD PTR _dymem
	mov	BYTE PTR [edx+6], cl

; 1018 :     dy_firstblock = sizeof(struct dy_head);
; 1019 :     ptr = (struct dy_head *)dymem+1; /* so offset 0 not used */

	mov	eax, DWORD PTR _dymem
	mov	ecx, 24					; 00000018H
	mov	DWORD PTR _dy_firstblock, ecx

; 1020 :     ptr->size = DY_STARTSIZE-sizeof(struct dy_head);

	mov	DWORD PTR [eax+24], 4072		; 00000fe8H

; 1021 :     ptr->state = DY_FREE;

	mov	DWORD PTR [eax+28], 52394		; 0000ccaaH

; 1022 :     ptr->next = 0;

	mov	DWORD PTR [eax+36], ebx

; 1023 :     ptr->prev = 0;

	mov	DWORD PTR [eax+32], ebx

; 1024 :     dy_lastblock = sizeof(struct dy_head);

	mov	DWORD PTR _dy_lastblock, ecx

; 1025 : 
; 1026 :     dy_freestart = sizeof(struct dy_head);

	mov	DWORD PTR _web+5648, ecx
	add	esp, 16					; 00000010H

; 1027 :     ptr->prevfree = 0; /* first in list */

	mov	DWORD PTR [eax+40], ebx

; 1028 :     ptr->nextfree = 0; /* last in list */

	mov	DWORD PTR [eax+44], ebx
$LN31@dy_calloc:

; 1029 :   }
; 1030 : 
; 1031 :   /* size of needed block */
; 1032 :   asize = ((num*size + ALIGNSIZE - 1)/ALIGNSIZE)*ALIGNSIZE;

	mov	ecx, DWORD PTR _num$[ebp]
	mov	esi, DWORD PTR _size$[ebp]
	mov	eax, ecx
	imul	eax, esi
	add	eax, 7
	cdq
	and	edx, 7
	add	eax, edx

; 1033 :   if ( asize <= dy_minfrag ) asize = dy_minfrag;

	mov	edx, DWORD PTR _dy_minfrag
	sar	eax, 3
	add	eax, eax
	add	eax, eax
	add	eax, eax
	cmp	eax, edx
	jg	SHORT $LN29@dy_calloc
	mov	eax, edx
$LN29@dy_calloc:

; 1034 :   needed = sizeof(struct dy_head) + asize;

	lea	edi, DWORD PTR [eax+24]
	mov	DWORD PTR _needed$[ebp], edi

; 1035 : 
; 1036 :   if ( memdebug )

	cmp	DWORD PTR _memdebug, ebx
	je	SHORT $LN51@dy_calloc

; 1037 :   { sprintf(errmsg,"dy_alloc %d*%d = %d bytes.\n",num,size,asize);

	push	eax
	push	esi
	push	ecx
	push	OFFSET ??_C@_0BM@JFBAMDME@dy_alloc?5?$CFd?$CK?$CFd?5?$DN?5?$CFd?5bytes?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1038 :     erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 24					; 00000018H
$LN51@dy_calloc:
	mov	edx, DWORD PTR _web+5648
$retry_alloc$89471:

; 1039 :   }
; 1040 : 
; 1041 : retry_alloc: 
; 1042 : 
; 1043 :   /* look for first fit in free block list */
; 1044 :   if ( dy_freestart )

	cmp	edx, ebx

; 1045 :     for ( off = dy_freestart ; off > 0 ; off = ptr->nextfree )

	jle	SHORT $LN38@dy_calloc
	mov	ecx, DWORD PTR _dymem
	npad	1
$LL26@dy_calloc:

; 1046 :     { 
; 1047 :       ptr = (struct dy_head *)(dymem + off);
; 1048 :       /* check size */
; 1049 :       if ( needed > ptr->size )

	cmp	edi, DWORD PTR [ecx+edx]
	lea	eax, DWORD PTR [ecx+edx]
	jle	$LN21@dy_calloc

; 1050 :       { if ( ptr->nextfree == 0 ) break;

	mov	eax, DWORD PTR [eax+20]
	cmp	eax, ebx
	je	SHORT $LN38@dy_calloc

; 1045 :     for ( off = dy_freestart ; off > 0 ; off = ptr->nextfree )

	mov	edx, eax
	cmp	edx, ebx
	jg	SHORT $LL26@dy_calloc
$LN38@dy_calloc:

; 1098 :     }
; 1099 : 
; 1100 :   /* if here, then no block big enough */
; 1101 :   if ( memdebug ) erroutstring ("expanding dymem.\n");

	cmp	DWORD PTR _memdebug, ebx
	je	SHORT $LN7@dy_calloc
	push	OFFSET ??_C@_0BC@HLNEFKCI@expanding?5dymem?4?6?$AA@
	call	_erroutstring
	add	esp, 4
$LN7@dy_calloc:

; 1102 :   ENTER_GRAPH_MUTEX

	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN6@dy_calloc
	push	ebx
	push	100000					; 000186a0H
	push	ebx
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	esi, 1
	jmp	SHORT $LN5@dy_calloc
$LN6@dy_calloc:
	xor	esi, esi
$LN5@dy_calloc:

; 1103 :   dymem = kb_realloc(dymem,2*dymemsize);

	mov	eax, DWORD PTR _dymemsize
	mov	edx, DWORD PTR _dymem
	push	1103					; 0000044fH
	push	OFFSET ??_C@_09GDMJAJJP@UTILITY?4C?$AA@
	lea	ecx, DWORD PTR [eax+eax]
	push	ecx
	push	edx
	call	_KB_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _dymem, eax

; 1104 :   LEAVE_GRAPH_MUTEX

	cmp	esi, ebx
	je	SHORT $LN4@dy_calloc
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, ebx
	call	DWORD PTR __imp__ReleaseMutex@4
	mov	eax, DWORD PTR _dymem
$LN4@dy_calloc:

; 1105 :   lastptr = (struct dy_head *)(dymem + dy_lastblock);

	mov	ecx, DWORD PTR _dy_lastblock

; 1106 : 
; 1107 :   if ( lastptr->state == DY_FREE )

	mov	edx, 52394				; 0000ccaaH
	cmp	DWORD PTR [ecx+eax+4], edx
	jne	SHORT $LN3@dy_calloc

; 1108 :     { /* combine with last block */
; 1109 :       lastptr->size += dymemsize;

	mov	edx, DWORD PTR _dymemsize
	add	DWORD PTR [ecx+eax], edx

; 1126 :     }
; 1127 :       
; 1128 :   dymemsize = 2*dymemsize;

	mov	eax, DWORD PTR _dymemsize
	mov	edx, DWORD PTR _web+5648
	lea	ecx, DWORD PTR [eax+eax]
	mov	DWORD PTR _dymemsize, ecx

; 1129 :   goto retry_alloc;

	jmp	$retry_alloc$89471
$LN3@dy_calloc:

; 1110 :     }
; 1111 :   else 
; 1112 :     { /* put in free block list at head */
; 1113 :       ptr = (struct dy_head *)(dymem + dymemsize);

	mov	ecx, DWORD PTR _dymemsize
	add	eax, ecx

; 1114 :       ptr->size = dymemsize;

	mov	DWORD PTR [eax], ecx

; 1115 :       ptr->state = DY_FREE;

	mov	DWORD PTR [eax+4], edx

; 1116 :       ptr->prev = dy_lastblock;

	mov	ecx, DWORD PTR _dy_lastblock
	mov	DWORD PTR [eax+8], ecx

; 1117 :       ptr->next = 0;

	mov	DWORD PTR [eax+12], ebx

; 1118 :       lastptr = (struct dy_head *)(dymem + dy_lastblock);

	mov	ecx, DWORD PTR _dy_lastblock

; 1119 :       dy_lastblock = dymemsize;

	mov	edx, DWORD PTR _dymemsize
	add	ecx, DWORD PTR _dymem
	mov	DWORD PTR _dy_lastblock, edx

; 1120 :       lastptr->next = dymemsize;

	mov	DWORD PTR [ecx+12], edx

; 1121 :       ptr->prevfree = 0;

	mov	DWORD PTR [eax+16], ebx

; 1122 :       ptr->nextfree = dy_freestart;

	mov	edx, DWORD PTR _web+5648
	mov	DWORD PTR [eax+20], edx

; 1123 :       if ( dy_freestart )

	mov	eax, DWORD PTR _web+5648
	cmp	eax, ebx
	je	SHORT $LN1@dy_calloc

; 1124 :          ((struct dy_head *)(dymem+dy_freestart))->prevfree = dymemsize;

	mov	ecx, DWORD PTR _dymemsize
	mov	edx, DWORD PTR _dymem
	mov	DWORD PTR [eax+edx+16], ecx
$LN1@dy_calloc:

; 1125 :       dy_freestart = dymemsize;

	mov	edx, DWORD PTR _dymemsize

; 1126 :     }
; 1127 :       
; 1128 :   dymemsize = 2*dymemsize;

	mov	eax, edx
	lea	ecx, DWORD PTR [eax+eax]
	mov	DWORD PTR _web+5648, edx
	mov	DWORD PTR _dymemsize, ecx

; 1129 :   goto retry_alloc;

	jmp	$retry_alloc$89471
$LN21@dy_calloc:

; 1051 :         else continue;
; 1052 :       }
; 1053 :       surplus = ptr->size - needed;

	mov	esi, DWORD PTR [eax]
	sub	esi, edi

; 1054 :       if ( surplus > dy_minfrag )

	cmp	esi, DWORD PTR _dy_minfrag
	jle	SHORT $LN20@dy_calloc

; 1055 :       { /* divide block */
; 1056 :         newptr = (struct dy_head *)(dymem + off + needed);

	add	ecx, edx
	add	ecx, edi

; 1057 :         newptr->size = ptr->size - needed;

	mov	DWORD PTR [ecx], esi

; 1058 :         newptr->state = DY_FREE;

	mov	DWORD PTR [ecx+4], 52394		; 0000ccaaH

; 1059 :         newptr->next = ptr->next;

	mov	esi, DWORD PTR [eax+12]

; 1060 :         newptr->prev = off;
; 1061 :         if ( newptr->next )

	mov	edi, esi
	mov	DWORD PTR [ecx+12], esi

; 1062 :            ((struct dy_head *)(dymem + newptr->next))->prev = 
; 1063 :                 off + needed; 

	mov	esi, DWORD PTR _needed$[ebp]
	add	esi, edx
	mov	DWORD PTR [ecx+8], edx
	cmp	edi, ebx
	je	SHORT $LN19@dy_calloc
	mov	ebx, DWORD PTR _dymem
	mov	DWORD PTR [edi+ebx+8], esi

; 1064 :         else 

	xor	ebx, ebx
	jmp	SHORT $LN18@dy_calloc
$LN19@dy_calloc:

; 1065 :            dy_lastblock = off + needed;

	mov	DWORD PTR _dy_lastblock, esi
$LN18@dy_calloc:

; 1066 :         newptr->nextfree = ptr->nextfree;

	mov	edi, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], edi

; 1067 :         newptr->prevfree = ptr->prevfree;

	mov	edi, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edi

; 1068 : 
; 1069 :         ptr->size = needed;

	mov	ecx, DWORD PTR _needed$[ebp]
	mov	DWORD PTR [eax], ecx

; 1070 :         ptr->next = off + needed;
; 1071 :         if (ptr->prevfree )

	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [eax+12], esi
	cmp	ecx, ebx
	je	SHORT $LN17@dy_calloc

; 1072 :          ((struct dy_head *)(dymem + ptr->prevfree))->nextfree = off + needed;

	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR [ecx+edi+20], esi
	jmp	SHORT $LN16@dy_calloc
$LN17@dy_calloc:

; 1073 :         else dy_freestart = off + needed;

	mov	DWORD PTR _web+5648, esi
$LN16@dy_calloc:

; 1074 :         if ( ptr->nextfree )

	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, ebx
	je	SHORT $LN14@dy_calloc

; 1075 :          ((struct dy_head *)(dymem + ptr->nextfree))->prevfree = off + needed;

	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR [ecx+edi+16], esi

; 1076 :       }
; 1077 :       else

	jmp	SHORT $LN14@dy_calloc
$LN20@dy_calloc:

; 1078 :       { /* remove from freelist */
; 1079 :         if ( ptr->prevfree )

	mov	esi, DWORD PTR [eax+16]
	cmp	esi, ebx
	je	SHORT $LN13@dy_calloc

; 1080 :            ((struct dy_head *)(dymem + ptr->prevfree))->nextfree 
; 1081 :                 = ptr->nextfree;

	mov	edi, DWORD PTR [eax+20]
	mov	DWORD PTR [esi+ecx+20], edi
	mov	ecx, DWORD PTR _dymem
	jmp	SHORT $LN12@dy_calloc
$LN13@dy_calloc:

; 1082 :         else dy_freestart = ptr->nextfree;

	mov	esi, DWORD PTR [eax+20]
	mov	DWORD PTR _web+5648, esi
$LN12@dy_calloc:

; 1083 :         if ( ptr->nextfree )

	mov	esi, DWORD PTR [eax+20]
	cmp	esi, ebx
	je	SHORT $LN11@dy_calloc

; 1084 :            ((struct dy_head *)(dymem + ptr->nextfree))->prevfree 
; 1085 :                 = ptr->prevfree;

	mov	edi, DWORD PTR [eax+16]
	mov	DWORD PTR [esi+ecx+16], edi
$LN11@dy_calloc:

; 1086 :         ptr->nextfree = 0;     

	mov	DWORD PTR [eax+20], ebx

; 1087 :         ptr->prevfree = 0;

	mov	DWORD PTR [eax+16], ebx
$LN14@dy_calloc:

; 1088 :       }
; 1089 :       ptr->state = DY_USED;

	mov	DWORD PTR [eax+4], 56763		; 0000ddbbH

; 1090 : #ifdef _DEBUG
; 1091 : dy_check();
; 1092 : #endif
; 1093 :       /* some handy debugging equivalences */
; 1094 :       Globals = (struct global **)(dymem + dy_globals);

	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+5652
	add	ecx, eax
	mov	DWORD PTR _Globals, ecx

; 1095 :       for ( i = 0 ; i < NUMELEMENTS ; i++ )
; 1096 :        Extras[i] = EXTRAS(i);

	mov	ecx, DWORD PTR _web+104
	add	ecx, eax
	mov	DWORD PTR _Extras, ecx
	mov	ecx, DWORD PTR _web+216
	add	ecx, eax
	mov	DWORD PTR _Extras+4, ecx
	mov	ecx, DWORD PTR _web+328
	add	ecx, eax
	mov	DWORD PTR _Extras+8, ecx
	mov	ecx, DWORD PTR _web+440
	add	ecx, eax
	mov	DWORD PTR _Extras+12, ecx
	mov	ecx, DWORD PTR _web+552
	pop	edi
	add	ecx, eax
	pop	esi
	mov	DWORD PTR _Extras+16, ecx

; 1097 :       return off + sizeof(struct dy_head);

	lea	eax, DWORD PTR [edx+24]
	pop	ebx

; 1130 : 
; 1131 : } // end dy_calloc()

	pop	ebp
	ret	0
_dy_calloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@JAJGHDAM@Internal?5error?3?5Trying?5to?5dy_fre@ ; `string'
PUBLIC	_dy_free
;	COMDAT ??_C@_0DG@JAJGHDAM@Internal?5error?3?5Trying?5to?5dy_fre@
CONST	SEGMENT
??_C@_0DG@JAJGHDAM@Internal?5error?3?5Trying?5to?5dy_fre@ DB 'Internal er'
	DB	'ror: Trying to dy_free unallocated block.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _dy_free
_TEXT	SEGMENT
_spot$ = 8						; size = 4
_dy_free PROC						; COMDAT

; 1168 : { DY_OFFSET off = spot - sizeof(struct dy_head);

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 1169 :   struct dy_head *ptr = (struct dy_head *)(dymem + off);

	mov	esi, DWORD PTR _dymem
	push	edi
	mov	edi, DWORD PTR _spot$[ebp]
	lea	ebx, DWORD PTR [edi-24]
	add	esi, ebx

; 1170 :   struct dy_head *prevhead,*nexthead;
; 1171 : 
; 1172 :   if ( ptr->state != DY_USED )

	cmp	DWORD PTR [esi+4], 56763		; 0000ddbbH
	je	SHORT $LN16@dy_free

; 1173 :      kb_error(1366,"Internal error: Trying to dy_free unallocated block.\n",
; 1174 :        RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DG@JAJGHDAM@Internal?5error?3?5Trying?5to?5dy_fre@
	push	1366					; 00000556H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN16@dy_free:

; 1175 : 
; 1176 :   memset(dymem+spot,0,ptr->size - dy_overhead);

	mov	ecx, DWORD PTR [esi]
	sub	ecx, DWORD PTR _dy_overhead
	mov	edx, DWORD PTR _dymem
	push	ecx
	add	edx, edi
	push	0
	push	edx
	call	_memset

; 1177 :   ptr->nextfree = dy_freestart;

	mov	eax, DWORD PTR _web+5648
	mov	DWORD PTR [esi+20], eax

; 1178 :   ptr->prevfree = 0;

	mov	DWORD PTR [esi+16], 0

; 1179 :   if ( dy_freestart )

	mov	eax, DWORD PTR _web+5648
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN15@dy_free

; 1180 :      ((struct dy_head *)(dymem + dy_freestart))->prevfree = off;

	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR [eax+ecx+16], ebx
$LN15@dy_free:

; 1181 :   dy_freestart = off;

	mov	DWORD PTR _web+5648, ebx

; 1182 :   ptr->state = DY_FREE;
; 1183 :  
; 1184 :   /* see if can combine with nbrs */
; 1185 :   /* check preceding block */
; 1186 :   if ( ptr->prev )

	mov	eax, DWORD PTR [esi+8]
	mov	edx, 52394				; 0000ccaaH
	mov	DWORD PTR [esi+4], edx
	test	eax, eax
	je	$LN19@dy_free

; 1187 :     { prevhead = (struct dy_head *)(dymem + ptr->prev);

	mov	ecx, DWORD PTR _dymem
	add	ecx, eax

; 1188 :       if ( prevhead->state == DY_FREE )

	cmp	DWORD PTR [ecx+4], edx
	jne	SHORT $LN19@dy_free

; 1189 :       { /* combine */
; 1190 :         prevhead->size += ptr->size;

	mov	eax, DWORD PTR [esi]
	add	DWORD PTR [ecx], eax

; 1191 :         prevhead->next = ptr->next;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], eax

; 1192 :         if ( ptr->next )

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN12@dy_free

; 1193 :         { nexthead = (struct dy_head *)(dymem + ptr->next);
; 1194 :           nexthead->prev = ptr->prev;

	mov	edx, DWORD PTR [esi+8]
	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR [eax+edi+8], edx
	mov	edx, 52394				; 0000ccaaH
$LN12@dy_free:

; 1195 :         }
; 1196 :         if ( off == dy_lastblock ) 

	cmp	ebx, DWORD PTR _dy_lastblock
	jne	SHORT $LN11@dy_free

; 1197 :           dy_lastblock = ptr->prev;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _dy_lastblock, eax
$LN11@dy_free:

; 1198 :         /* remove from freelist */
; 1199 :         if ( ptr->nextfree )

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN10@dy_free

; 1200 :           ((struct dy_head*)(dymem+ptr->nextfree))->prevfree = ptr->prevfree; 

	mov	edi, DWORD PTR [esi+16]
	mov	ebx, DWORD PTR _dymem
	mov	DWORD PTR [eax+ebx+16], edi
$LN10@dy_free:

; 1201 :         if ( ptr->prevfree )

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN9@dy_free

; 1202 :           ((struct dy_head*)(dymem+ptr->prevfree))->nextfree = ptr->nextfree; 

	mov	edi, DWORD PTR [esi+20]
	mov	ebx, DWORD PTR _dymem
	mov	DWORD PTR [eax+ebx+20], edi
	jmp	SHORT $LN8@dy_free
$LN9@dy_free:

; 1203 :         else dy_freestart = ptr->nextfree;

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR _web+5648, eax
$LN8@dy_free:

; 1204 :         memset((char*)ptr,0,sizeof(struct dy_head));

	xor	eax, eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax

; 1205 :         ptr = prevhead;  /* ready for next stage of combining */

	mov	esi, ecx
$LN19@dy_free:

; 1206 :         
; 1207 :       }
; 1208 :     } 
; 1209 :   /* check following block */
; 1210 :   if ( ptr->next )

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	$LN6@dy_free

; 1211 :     { nexthead = (struct dy_head *)(dymem + ptr->next);

	mov	eax, DWORD PTR _dymem
	add	eax, ecx

; 1212 :       if ( nexthead->state == DY_FREE )

	cmp	DWORD PTR [eax+4], edx
	jne	SHORT $LN6@dy_free

; 1213 :       { /* combine */
; 1214 :         if ( ptr->next == dy_lastblock )

	cmp	ecx, DWORD PTR _dy_lastblock
	jne	SHORT $LN5@dy_free

; 1215 :            dy_lastblock = nexthead->prev;

	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _dy_lastblock, ecx
$LN5@dy_free:

; 1216 :         prevhead = ptr; ptr = nexthead;
; 1217 :         prevhead->size += ptr->size;

	mov	edx, DWORD PTR [eax]
	add	DWORD PTR [esi], edx

; 1218 :         prevhead->next = ptr->next;

	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [esi+12], ecx

; 1219 :         if ( ptr->next )

	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN4@dy_free

; 1220 :         { nexthead = (struct dy_head *)(dymem + ptr->next);
; 1221 :           nexthead->prev = ptr->prev;

	mov	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, DWORD PTR _dymem
	mov	DWORD PTR [esi+edx+8], ecx
$LN4@dy_free:

; 1222 :         }
; 1223 :         /* remove from freelist */
; 1224 :         if ( ptr->nextfree )

	mov	ecx, DWORD PTR [eax+20]
	test	ecx, ecx
	je	SHORT $LN3@dy_free

; 1225 :           ((struct dy_head*)(dymem+ptr->nextfree))->prevfree = ptr->prevfree; 

	mov	edx, DWORD PTR [eax+16]
	mov	esi, DWORD PTR _dymem
	mov	DWORD PTR [ecx+esi+16], edx
$LN3@dy_free:

; 1226 :         if ( ptr->prevfree )

	mov	ecx, DWORD PTR [eax+16]
	test	ecx, ecx
	je	SHORT $LN2@dy_free

; 1227 :           ((struct dy_head*)(dymem+ptr->prevfree))->nextfree = ptr->nextfree; 

	mov	edx, DWORD PTR [eax+20]
	mov	esi, DWORD PTR _dymem
	mov	DWORD PTR [ecx+esi+20], edx
	jmp	SHORT $LN1@dy_free
$LN2@dy_free:

; 1228 :         else dy_freestart = ptr->nextfree;

	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _web+5648, ecx
$LN1@dy_free:

; 1229 :         memset((char*)ptr,0,sizeof(struct dy_head));

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
$LN6@dy_free:
	pop	edi
	pop	esi
	pop	ebx

; 1230 :       }
; 1231 :     } 
; 1232 : #ifdef _DEBUG
; 1233 : dy_check();
; 1234 : #endif
; 1235 : } // end dy_free()

	pop	ebp
	ret	0
_dy_free ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@DMCICLJE@Internal?5error?3?5Corrupt?5dy_mem?$DL?5@ ; `string'
PUBLIC	??_C@_0CL@EODFGNKG@Internal?5error?3?5Corrupt?5dy_mem?5f@ ; `string'
PUBLIC	??_C@_0CK@FLAKKPJG@Internal?5error?3?5Corrupt?5dy_mem?5p@ ; `string'
PUBLIC	??_C@_0CK@HNFCHIJB@Internal?5error?3?5Corrupt?5dy_mem?5n@ ; `string'
PUBLIC	??_C@_0CH@KAEKLJAB@Dymem?5used?5blocks?3?5?$CFd?5?5used?5byte@ ; `string'
PUBLIC	??_C@_0CH@EEKOGFAF@Dymem?5free?5blocks?3?5?$CFd?5?5free?5byte@ ; `string'
PUBLIC	??_C@_0BB@CGKMLEBG@Dymem?5arena?3?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0CL@POAFLIHG@Internal?5error?3?5Corrupt?5dy_mem?$DL?5@ ; `string'
PUBLIC	_dy_check
;	COMDAT ??_C@_0CM@DMCICLJE@Internal?5error?3?5Corrupt?5dy_mem?$DL?5@
CONST	SEGMENT
??_C@_0CM@DMCICLJE@Internal?5error?3?5Corrupt?5dy_mem?$DL?5@ DB 'Internal'
	DB	' error: Corrupt dy_mem; bad state.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EODFGNKG@Internal?5error?3?5Corrupt?5dy_mem?5f@
CONST	SEGMENT
??_C@_0CL@EODFGNKG@Internal?5error?3?5Corrupt?5dy_mem?5f@ DB 'Internal er'
	DB	'ror: Corrupt dy_mem free list.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FLAKKPJG@Internal?5error?3?5Corrupt?5dy_mem?5p@
CONST	SEGMENT
??_C@_0CK@FLAKKPJG@Internal?5error?3?5Corrupt?5dy_mem?5p@ DB 'Internal er'
	DB	'ror: Corrupt dy_mem prevfree.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@HNFCHIJB@Internal?5error?3?5Corrupt?5dy_mem?5n@
CONST	SEGMENT
??_C@_0CK@HNFCHIJB@Internal?5error?3?5Corrupt?5dy_mem?5n@ DB 'Internal er'
	DB	'ror: Corrupt dy_mem nextfree.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KAEKLJAB@Dymem?5used?5blocks?3?5?$CFd?5?5used?5byte@
CONST	SEGMENT
??_C@_0CH@KAEKLJAB@Dymem?5used?5blocks?3?5?$CFd?5?5used?5byte@ DB 'Dymem '
	DB	'used blocks: %d  used bytes: %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EEKOGFAF@Dymem?5free?5blocks?3?5?$CFd?5?5free?5byte@
CONST	SEGMENT
??_C@_0CH@EEKOGFAF@Dymem?5free?5blocks?3?5?$CFd?5?5free?5byte@ DB 'Dymem '
	DB	'free blocks: %d  free bytes: %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CGKMLEBG@Dymem?5arena?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BB@CGKMLEBG@Dymem?5arena?3?5?$CFd?6?$AA@ DB 'Dymem arena: %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@POAFLIHG@Internal?5error?3?5Corrupt?5dy_mem?$DL?5@
CONST	SEGMENT
??_C@_0CL@POAFLIHG@Internal?5error?3?5Corrupt?5dy_mem?$DL?5@ DB 'Internal'
	DB	' error: Corrupt dy_mem; bad prev.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _dy_check
_TEXT	SEGMENT
_usedblocks$ = -8					; size = 4
_freeblocks$ = -4					; size = 4
_dy_check PROC						; COMDAT

; 1238 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1239 :   struct dy_head *head,*nexthead;
; 1240 :   int freeblocks = 0;
; 1241 :   int usedblocks = 0;
; 1242 :   int freebytes = 0;
; 1243 :   int usedbytes = 0;
; 1244 :   DY_OFFSET off;
; 1245 : 
; 1246 :   for ( off = dy_firstblock ; off != 0 ; off = head->next )

	mov	eax, DWORD PTR _dy_firstblock
	mov	ecx, DWORD PTR _dymem
	push	ebx
	push	esi
	push	edi
	xor	edi, edi
	xor	ebx, ebx
	mov	DWORD PTR _freeblocks$[ebp], edi
	mov	DWORD PTR _usedblocks$[ebp], edi
	cmp	eax, edi
	je	SHORT $LN17@dy_check
$LL29@dy_check:

; 1247 :   { head = (struct dy_head *)(dymem + off);
; 1248 :     switch ( head->state )

	mov	edx, DWORD PTR [ecx+eax+4]
	cmp	edx, 52394				; 0000ccaaH
	je	SHORT $LN14@dy_check
	cmp	edx, 56763				; 0000ddbbH
	jne	$LN24@dy_check

; 1250 :       case DY_USED: usedblocks++; usedbytes += head->size; break;

	inc	DWORD PTR _usedblocks$[ebp]
	add	ebx, DWORD PTR [ecx+eax]
	jmp	SHORT $LN15@dy_check
$LN14@dy_check:

; 1249 :     { case DY_FREE: freeblocks++; freebytes += head->size; break;

	inc	DWORD PTR _freeblocks$[ebp]
	add	edi, DWORD PTR [ecx+eax]
$LN15@dy_check:

; 1253 :          return;
; 1254 :     }
; 1255 :     if ( head->next )

	mov	edx, DWORD PTR [ecx+eax+12]
	lea	esi, DWORD PTR [ecx+eax+12]
	test	edx, edx
	je	SHORT $LN18@dy_check

; 1256 :     { nexthead = (struct dy_head *)(dymem + head->next);
; 1257 :       if ( off != nexthead->prev )

	cmp	eax, DWORD PTR [edx+ecx+8]
	je	SHORT $LN18@dy_check

; 1258 :         kb_error(2469,"Internal error: Corrupt dy_mem; bad prev.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CL@POAFLIHG@Internal?5error?3?5Corrupt?5dy_mem?$DL?5@
	push	2469					; 000009a5H
	call	_kb_error
	mov	ecx, DWORD PTR _dymem
	add	esp, 12					; 0000000cH
$LN18@dy_check:

; 1239 :   struct dy_head *head,*nexthead;
; 1240 :   int freeblocks = 0;
; 1241 :   int usedblocks = 0;
; 1242 :   int freebytes = 0;
; 1243 :   int usedbytes = 0;
; 1244 :   DY_OFFSET off;
; 1245 : 
; 1246 :   for ( off = dy_firstblock ; off != 0 ; off = head->next )

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LL29@dy_check
$LN17@dy_check:

; 1259 :     }
; 1260 :   }
; 1261 : 
; 1262 :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	je	SHORT $LN9@dy_check

; 1263 :   { sprintf(errmsg,"Dymem arena: %d\n",dymemsize);

	mov	eax, DWORD PTR _dymemsize
	push	eax
	push	OFFSET ??_C@_0BB@CGKMLEBG@Dymem?5arena?3?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1264 :     erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 1265 :     sprintf(errmsg,"Dymem free blocks: %d  free bytes: %d\n",freeblocks,freebytes);

	mov	ecx, DWORD PTR _freeblocks$[ebp]
	push	edi
	push	ecx
	push	OFFSET ??_C@_0CH@EEKOGFAF@Dymem?5free?5blocks?3?5?$CFd?5?5free?5byte@
	push	OFFSET _errmsg
	call	_sprintf

; 1266 :     erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring

; 1267 :     sprintf(errmsg,"Dymem used blocks: %d  used bytes: %d\n",usedblocks,usedbytes);

	mov	edx, DWORD PTR _usedblocks$[ebp]
	push	ebx
	push	edx
	push	OFFSET ??_C@_0CH@KAEKLJAB@Dymem?5used?5blocks?3?5?$CFd?5?5used?5byte@
	push	OFFSET _errmsg
	call	_sprintf

; 1268 :     erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	mov	ecx, DWORD PTR _dymem
	add	esp, 56					; 00000038H
$LN9@dy_check:

; 1269 :   }
; 1270 : 
; 1271 :   /* check freelist integrity */
; 1272 :   for ( off = dy_freestart ; (off != 0) && freeblocks ; off = head->nextfree )

	mov	esi, DWORD PTR _web+5648
	test	esi, esi
	je	SHORT $LN31@dy_check
$LL8@dy_check:
	cmp	DWORD PTR _freeblocks$[ebp], 0
	je	SHORT $LN27@dy_check

; 1273 :   { head = (struct dy_head *)(dymem + off);
; 1274 :     if ( head->state != DY_FREE )

	cmp	DWORD PTR [ecx+esi+4], 52394		; 0000ccaaH
	lea	edi, DWORD PTR [ecx+esi]
	je	SHORT $LN30@dy_check

; 1275 :        kb_error(2555,"Internal error: Corrupt dy_mem nextfree.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CK@HNFCHIJB@Internal?5error?3?5Corrupt?5dy_mem?5n@
	push	2555					; 000009fbH
	call	_kb_error
	mov	ecx, DWORD PTR _dymem
	add	esp, 12					; 0000000cH
$LN30@dy_check:

; 1276 :     if ( head->nextfree )

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN32@dy_check

; 1277 :     { nexthead = (struct dy_head *)(dymem + head->nextfree);
; 1278 :       if ( off != nexthead->prevfree )

	cmp	esi, DWORD PTR [eax+ecx+16]
	je	SHORT $LN32@dy_check

; 1279 :         kb_error(2470,"Internal error: Corrupt dy_mem prevfree.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CK@FLAKKPJG@Internal?5error?3?5Corrupt?5dy_mem?5p@
	push	2470					; 000009a6H
	call	_kb_error
	mov	ecx, DWORD PTR _dymem
	add	esp, 12					; 0000000cH
$LN32@dy_check:

; 1280 :     }
; 1281 :     freeblocks--;

	mov	esi, DWORD PTR [edi+20]
	dec	DWORD PTR _freeblocks$[ebp]
	test	esi, esi
	jne	SHORT $LL8@dy_check
$LN31@dy_check:

; 1282 :   }
; 1283 :   if ( freeblocks || (off != 0) )

	cmp	DWORD PTR _freeblocks$[ebp], 0
	jne	SHORT $LN1@dy_check
$LN27@dy_check:
	test	esi, esi
	je	SHORT $LN2@dy_check
$LN1@dy_check:

; 1284 :         kb_error(2471,"Internal error: Corrupt dy_mem free list.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CL@EODFGNKG@Internal?5error?3?5Corrupt?5dy_mem?5f@
	push	2471					; 000009a7H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN2@dy_check:
	pop	edi
	pop	esi
	pop	ebx

; 1285 : 
; 1286 : } /* end dy_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@dy_check:

; 1251 :       default: kb_error(2468,"Internal error: Corrupt dy_mem; bad state.\n",
; 1252 :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CM@DMCICLJE@Internal?5error?3?5Corrupt?5dy_mem?$DL?5@
	push	2468					; 000009a4H

; 1284 :         kb_error(2471,"Internal error: Corrupt dy_mem free list.\n",RECOVERABLE);

	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 1285 : 
; 1286 : } /* end dy_check() */

	mov	esp, ebp
	pop	ebp
	ret	0
_dy_check ENDP
_TEXT	ENDS
PUBLIC	_x$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_get_edge_side
EXTRN	_sym_wrap:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_edge_side
_TEXT	SEGMENT
tv289 = -64						; size = 4
_x$GSCopy$ = -60					; size = 4
tv315 = -56						; size = 4
_w$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_x$ = 12						; size = 4
_get_edge_side PROC					; COMDAT

; 1400 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _e_id$[ebp]

; 1401 :   REAL *y,*z;
; 1402 :   int i;
; 1403 :   REAL w[MAXCOORD];
; 1404 :   
; 1405 :   y = get_coord(get_edge_tailv(e_id));

	mov	DWORD PTR _x$GSCopy$[ebp], ecx
	mov	ecx, eax
	push	ebx
	shr	ecx, 27					; 0000001bH
	push	esi
	mov	esi, DWORD PTR _dymem
	and	ecx, 1
	push	edi
	mov	edi, DWORD PTR _web+216
	mov	DWORD PTR tv289[ebp], ecx
	mov	ecx, DWORD PTR _web+124
	je	SHORT $LN8@get_edge_s
	mov	edx, DWORD PTR [edi+esi+304]
	add	edi, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+636
	add	edx, eax
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN7@get_edge_s
$LN8@get_edge_s:
	mov	edx, DWORD PTR [edi+esi+304]
	add	edi, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [edx+eax]
	add	edx, eax
$LN7@get_edge_s:
	mov	ebx, DWORD PTR _web+104
	mov	ebx, DWORD PTR [ebx+esi+64]
	mov	esi, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [esi+ecx*4]

; 1406 :   z = get_coord(get_edge_headv(e_id));

	mov	ecx, DWORD PTR tv289[ebp]
	add	esi, ebx
	mov	DWORD PTR tv315[ebp], ebx
	test	ecx, ecx
	je	SHORT $LN12@get_edge_s
	mov	edx, DWORD PTR [edx]
	jmp	SHORT $LN11@get_edge_s
$LN12@get_edge_s:
	mov	ebx, DWORD PTR _web+636
	mov	edx, DWORD PTR [edx+ebx*4]
$LN11@get_edge_s:
	mov	ebx, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ebx+edx*4]
	add	ebx, DWORD PTR tv315[ebp]

; 1407 :   if ( web.symmetry_flag ) 

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN4@get_edge_s

; 1408 :   {
; 1409 :     (*sym_wrap)(z,w,get_edge_wrap(e_id));

	mov	edx, DWORD PTR [edi+784]
	mov	eax, DWORD PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN17@get_edge_s
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN17@get_edge_s:
	push	eax
	lea	eax, DWORD PTR _w$[ebp]
	push	eax
	push	ebx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH

; 1410 :     z = w;

	lea	ebx, DWORD PTR _w$[ebp]
$LN4@get_edge_s:

; 1411 :   }
; 1412 :   for ( i = 0 ; i < SDIM ; i++ ) 

	xor	edi, edi
	cmp	DWORD PTR _web+616, edi
	jle	SHORT $LN1@get_edge_s
	mov	edx, DWORD PTR _x$GSCopy$[ebp]
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, esi
	sub	edx, esi
	npad	6
$LL3@get_edge_s:

; 1413 :       x[i] = z[i] - y[i];

	fld	QWORD PTR [ecx+eax]
	inc	edi
	fsub	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [edx+eax-8]
	cmp	edi, DWORD PTR _web+616
	jl	SHORT $LL3@get_edge_s
$LN1@get_edge_s:

; 1414 : } // end get_edge_side()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_get_edge_side ENDP
_TEXT	ENDS
PUBLIC	__real@4008000000000000
PUBLIC	__real@4010000000000000
PUBLIC	_x$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_get_edge_tail_tangent
EXTRN	_gauss_lagrange:BYTE
EXTRN	_circular_arc_flag:DWORD
EXTRN	__CIatan2:PROC
EXTRN	__CIsqrt:PROC
;	COMDAT __real@4008000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\utility.c
CONST	ENDS
;	COMDAT _get_edge_tail_tangent
_TEXT	SEGMENT
_xx$89793 = -264					; size = 84
tv814 = -180						; size = 8
_chord$89773 = -172					; size = 8
_sinth$89774 = -164					; size = 8
_denom2$89772 = -164					; size = 8
_xx$89745 = -156					; size = 12
tv811 = -152						; size = 8
_dy1$89769 = -144					; size = 8
_spot$89790 = -140					; size = 4
_dx2$89768 = -136					; size = 8
_gl$89788 = -132					; size = 4
_costh$89775 = -128					; size = 8
_dy2$89770 = -128					; size = 8
_ctrl$89789 = -124					; size = 4
_dx1$89767 = -120					; size = 8
tv735 = -116						; size = 4
tv713 = -116						; size = 4
_denom1$89771 = -112					; size = 8
tv726 = -108						; size = 4
_wrap$89763 = -108					; size = 4
_x$GSCopy$ = -104					; size = 4
_ww$ = -100						; size = 48
_w$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_x$ = 12						; size = 4
_get_edge_tail_tangent PROC				; COMDAT

; 1433 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1434 :   int i,n;
; 1435 :   REAL w[MAXCOORD],ww[MAXCOORD];
; 1436 :   
; 1437 :   if ( web.lagrange_order == 1 )

	cmp	DWORD PTR _web+632, 1

; 1504 :     int spot = inverted(e_id) ? ctrl-1 : 0;

	mov	eax, DWORD PTR _x$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	push	edi
	mov	DWORD PTR _x$GSCopy$[ebp], eax
	jne	$LN30@get_edge_t@2

; 1438 :   { 
; 1439 :     REAL *y,*z;
; 1440 :     y = get_coord(get_edge_tailv(e_id));

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [ecx+edx+64]
	push	esi
	mov	DWORD PTR tv713[ebp], eax
	call	_get_edge_tailv
	mov	ebx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+eax*4]
	add	edi, DWORD PTR tv713[ebp]

; 1441 :     z = get_coord(get_edge_headv(e_id));

	push	esi
	call	_get_edge_headv
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ebx+eax*4]
	add	ebx, DWORD PTR tv713[ebp]
	add	esp, 8

; 1442 :     if ( web.symmetry_flag ) 

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN29@get_edge_t@2

; 1443 :     {
; 1444 :       (*sym_wrap)(z,w,get_edge_wrap(e_id));

	mov	edx, DWORD PTR _web+124
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	eax, DWORD PTR [eax+ecx]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN37@get_edge_t@2
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN37@get_edge_t@2:
	push	eax
	lea	edx, DWORD PTR _w$[ebp]
	push	edx
	push	ebx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH

; 1445 :       z = w;

	lea	ebx, DWORD PTR _w$[ebp]
$LN29@get_edge_t@2:

; 1446 :     }
; 1447 :     for ( i = 0 ; i < SDIM ; i++ ) 

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	$LN5@get_edge_t@2
	mov	ecx, DWORD PTR _x$GSCopy$[ebp]
	sub	ebx, edi
	mov	eax, edi
	sub	ecx, edi
$LL28@get_edge_t@2:

; 1448 :       x[i] = z[i] - y[i];

	fld	QWORD PTR [ebx+eax]
	inc	edx
	fsub	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [ecx+eax-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL28@get_edge_t@2
	pop	edi
	pop	esi
	pop	ebx

; 1523 :     }
; 1524 :   }
; 1525 : } // end get_edge_tail_tangent()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@get_edge_t@2:

; 1449 :     return;
; 1450 :   }
; 1451 : 
; 1452 :   if ( web.modeltype == QUADRATIC )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	jne	$LN25@get_edge_t@2

; 1453 :   { vertex_id v[3];
; 1454 :     REAL *xx[3];
; 1455 :     v[0] = get_edge_tailv(e_id);

	push	esi
	call	_get_edge_tailv

; 1456 :     v[1] = get_edge_midv(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR _web+216
	mov	edi, eax
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ecx+304]
	mov	ebx, DWORD PTR [edx+eax+8]

; 1457 :     v[2] = get_edge_headv(e_id);

	push	esi
	mov	DWORD PTR tv726[ebp], eax
	call	_get_edge_headv

; 1458 :     xx[0] = get_coord(v[0]);

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [ecx+edx+64]
	mov	ecx, DWORD PTR _web+12

; 1459 :     xx[1] = get_coord(v[1]);

	and	ebx, 134217727				; 07ffffffH
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [ecx+ebx*4]

; 1460 :     xx[2] = get_coord(v[2]);

	mov	ebx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ebx+eax*4]
	add	ecx, edx
	add	esp, 8
	add	edi, edx
	add	ebx, edx

; 1461 :     if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	mov	DWORD PTR _xx$89745[ebp+4], ecx
	je	SHORT $LN63@get_edge_t@2

; 1462 :     { WRAPTYPE wrap = get_edge_wrap(e_id);

	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR tv726[ebp]
	mov	eax, DWORD PTR [eax+edx]
	shr	esi, 27					; 0000001bH
	and	esi, 1
	je	SHORT $LN41@get_edge_t@2
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN41@get_edge_t@2:

; 1463 :       (*sym_wrap)(xx[2],w,wrap);

	mov	ecx, eax
	push	ecx
	lea	edx, DWORD PTR _w$[ebp]
	push	edx
	push	ebx
	mov	DWORD PTR _wrap$89763[ebp], eax
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH

; 1464 :       xx[2] = w;

	lea	ebx, DWORD PTR _w$[ebp]

; 1465 :       if ( inverted(e_id) )

	test	esi, esi
	je	SHORT $LN62@get_edge_t@2

; 1466 :       { (*sym_wrap)(xx[1],ww,wrap);

	mov	eax, DWORD PTR _wrap$89763[ebp]
	mov	edx, DWORD PTR _xx$89745[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _ww$[ebp]
	push	ecx
	push	edx
	call	DWORD PTR _sym_wrap

; 1467 :         xx[1] = ww;

	lea	eax, DWORD PTR _ww$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xx$89745[ebp+4], eax
$LN62@get_edge_t@2:
	mov	ecx, DWORD PTR _xx$89745[ebp+4]
$LN63@get_edge_t@2:

; 1468 :       }
; 1469 :     }
; 1470 :     if ( circular_arc_flag )

	cmp	DWORD PTR _circular_arc_flag, 0
	je	$LN22@get_edge_t@2

; 1471 :     { REAL dx1 = xx[1][0] - xx[0][0];

	fld	QWORD PTR [ecx]
	fsub	QWORD PTR [edi]
	fst	QWORD PTR _dx1$89767[ebp]

; 1472 :       REAL dx2 = xx[2][0] - xx[1][0];

	fld	QWORD PTR [ebx]
	fsub	QWORD PTR [ecx]
	fstp	QWORD PTR _dx2$89768[ebp]

; 1473 :       REAL dy1 = xx[1][1] - xx[0][1];

	fld	QWORD PTR [ecx+8]
	fsub	QWORD PTR [edi+8]
	fst	QWORD PTR _dy1$89769[ebp]

; 1474 :       REAL dy2 = xx[2][1] - xx[1][1];

	fld	QWORD PTR [ebx+8]
	fsub	QWORD PTR [ecx+8]
	fstp	QWORD PTR _dy2$89770[ebp]

; 1475 :       REAL denom1 = sqrt(dx1*dx1+dy1*dy1);

	fmul	ST(0), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR _denom1$89771[ebp]

; 1476 :       REAL denom2 = sqrt(dx2*dx2+dy2*dy2);

	fld	QWORD PTR _dy2$89770[ebp]
	fmul	ST(0), ST(0)
	fld	QWORD PTR _dx2$89768[ebp]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fst	QWORD PTR _denom2$89772[ebp]

; 1477 :       REAL chord,sinth,costh,angle,length;
; 1478 :       if (denom1*denom2 == 0.0) {x[0] = x[1] = 0.0; return ;}

	fmul	QWORD PTR _denom1$89771[ebp]
	fldz
	fld	ST(0)
	fucomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 68					; 00000044H
	jp	SHORT $LN67@get_edge_t@2
	mov	eax, DWORD PTR _x$GSCopy$[ebp]
	pop	edi
	fst	QWORD PTR [eax+8]
	pop	esi
	fstp	QWORD PTR [eax]
	pop	ebx

; 1523 :     }
; 1524 :   }
; 1525 : } // end get_edge_tail_tangent()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN67@get_edge_t@2:

; 1477 :       REAL chord,sinth,costh,angle,length;
; 1478 :       if (denom1*denom2 == 0.0) {x[0] = x[1] = 0.0; return ;}

	fstp	ST(0)

; 1479 :       chord = sqrt((dx1+dx2)*(dx1+dx2)+(dy1+dy2)*(dy1+dy2));

	fld	QWORD PTR _dy2$89770[ebp]
	fadd	QWORD PTR _dy1$89769[ebp]
	fst	QWORD PTR tv811[ebp]
	fld	QWORD PTR _dx2$89768[ebp]
	fadd	QWORD PTR _dx1$89767[ebp]
	fst	QWORD PTR tv814[ebp]
	fmul	ST(0), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR _chord$89773[ebp]

; 1480 :       sinth = (dx1*dy2 - dy1*dx2)/denom1/denom2;

	fld	QWORD PTR _dy2$89770[ebp]
	fld	ST(0)
	fld	QWORD PTR _dx1$89767[ebp]
	fmul	ST(1), ST(0)
	fld	QWORD PTR _dy1$89769[ebp]
	fld	ST(0)
	fld	QWORD PTR _dx2$89768[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(4)
	fsubrp	ST(1), ST(0)
	fld	QWORD PTR _denom1$89771[ebp]
	fdiv	ST(1), ST(0)
	fld	QWORD PTR _denom2$89772[ebp]
	fdiv	ST(2), ST(0)
	fxch	ST(2)
	fst	QWORD PTR _sinth$89774[ebp]

; 1481 :       costh = (dx1*dx2 + dy1*dy2)/denom1/denom2;

	fxch	ST(6)
	fmulp	ST(3), ST(0)
	fxch	ST(4)
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fdivrp	ST(2), ST(0)
	fdivp	ST(1), ST(0)
	fst	QWORD PTR _costh$89775[ebp]

; 1482 :       angle = atan2(sinth,costh);

	call	__CIatan2

; 1483 :       if ( sinth == 0.0 )

	fld	QWORD PTR _sinth$89774[ebp]
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN20@get_edge_t@2

; 1484 :       { for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	fstp	ST(0)
	fstp	ST(0)
	cmp	DWORD PTR _web+616, ecx
	jle	$LN5@get_edge_t@2
	mov	eax, DWORD PTR _x$GSCopy$[ebp]
	sub	ebx, edi
	sub	eax, edi
	npad	1
$LL19@get_edge_t@2:

; 1485 :           x[i] = xx[2][i] - xx[0][i];

	fld	QWORD PTR [ebx+edi]
	inc	ecx
	fsub	QWORD PTR [edi]
	add	edi, 8
	fstp	QWORD PTR [eax+edi-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL19@get_edge_t@2
	pop	edi
	pop	esi
	pop	ebx

; 1523 :     }
; 1524 :   }
; 1525 : } // end get_edge_tail_tangent()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@get_edge_t@2:

; 1486 :         return;
; 1487 :       }
; 1488 :       length = chord*angle/sinth;

	fld	QWORD PTR _chord$89773[ebp]

; 1489 :       x[0] = length*(costh*(dx1+dx2) + sinth*(dy1+dy2))/chord;

	mov	eax, DWORD PTR _x$GSCopy$[ebp]
	fmul	ST(2), ST(0)
	pop	edi
	fxch	ST(2)
	pop	esi
	pop	ebx
	fdiv	ST(0), ST(1)
	fld	QWORD PTR tv814[ebp]
	fld	ST(0)
	fld	QWORD PTR _costh$89775[ebp]
	fmul	ST(1), ST(0)
	fld	QWORD PTR tv811[ebp]
	fld	ST(0)
	fmul	ST(0), ST(6)
	faddp	ST(3), ST(0)
	fxch	ST(2)
	fmul	ST(0), ST(4)
	fdiv	ST(0), ST(6)
	fstp	QWORD PTR [eax]

; 1490 :       x[1] = length*(costh*(dy1+dy2) - sinth*(dx1+dx2))/chord;

	fmulp	ST(1), ST(0)
	fxch	ST(1)
	fmulp	ST(3), ST(0)
	fsubrp	ST(2), ST(0)
	fmulp	ST(1), ST(0)
	fdivrp	ST(1), ST(0)
	fstp	QWORD PTR [eax+8]

; 1523 :     }
; 1524 :   }
; 1525 : } // end get_edge_tail_tangent()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@get_edge_t@2:

; 1491 :       return; 
; 1492 :     }
; 1493 :     else 
; 1494 :     { /* regular quadratic */
; 1495 :       for ( i = 0 ; i < SDIM ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _web+616, esi
	jle	$LN5@get_edge_t@2
	mov	edx, DWORD PTR _x$GSCopy$[ebp]
	fld	QWORD PTR __real@4010000000000000
	fld	QWORD PTR __real@4008000000000000
	sub	ecx, edi
	sub	ebx, edi
	mov	eax, edi
	sub	edx, edi
$LN15@get_edge_t@2:

; 1496 :           x[i] = -3*xx[0][i] + 4*xx[1][i] - xx[2][i];

	fld	QWORD PTR [ecx+eax]
	inc	esi
	fmul	ST(0), ST(2)
	add	eax, 8
	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fsub	QWORD PTR [eax+ebx-8]
	fstp	QWORD PTR [eax+edx-8]
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LN15@get_edge_t@2

; 1497 :     }
; 1498 :     return;

	jmp	$LN92@get_edge_t@2
$LN25@get_edge_t@2:

; 1499 :   }
; 1500 : 
; 1501 :   if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	$LN5@get_edge_t@2

; 1502 :   { struct gauss_lag *gl = &gauss_lagrange[1][web.gauss1D_order];

	mov	eax, DWORD PTR _web+1592

; 1503 :     int ctrl = web.skel[EDGE].ctrlpts;

	mov	edi, DWORD PTR _web+120
	shl	eax, 5
	add	eax, DWORD PTR _gauss_lagrange+4

; 1504 :     int spot = inverted(e_id) ? ctrl-1 : 0;

	mov	ebx, esi
	shr	ebx, 27					; 0000001bH
	and	ebx, 1
	mov	DWORD PTR _gl$89788[ebp], eax
	mov	DWORD PTR _ctrl$89789[ebp], edi
	mov	DWORD PTR tv735[ebp], ebx
	je	SHORT $LN33@get_edge_t@2
	lea	ecx, DWORD PTR [edi-1]
	mov	DWORD PTR _spot$89790[ebp], ecx
	jmp	SHORT $LN34@get_edge_t@2
$LN33@get_edge_t@2:
	mov	DWORD PTR _spot$89790[ebp], 0
$LN34@get_edge_t@2:

; 1505 :     vertex_id *v;
; 1506 :     REAL *xx[MAXLAGRANGE+1];
; 1507 : 
; 1508 :     v = get_edge_vertices(e_id);

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR _web+216
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [eax+edx+304]
	add	ecx, esi

; 1509 :     for ( i = 0 ; i < ctrl ; i++ )

	xor	eax, eax
	mov	DWORD PTR tv726[ebp], esi
	test	edi, edi
	jle	SHORT $LN9@get_edge_t@2
	mov	esi, DWORD PTR _web+104
	mov	edx, DWORD PTR [esi+edx+64]
	lea	esi, DWORD PTR _xx$89793[ebp]
	sub	ecx, esi
	mov	esi, DWORD PTR _web+12
	npad	4
$LL64@get_edge_t@2:
	lea	ebx, DWORD PTR [ecx+eax*4]

; 1510 :       xx[i] = get_coord(v[i]);

	mov	ebx, DWORD PTR _xx$89793[ebp+ebx]
	and	ebx, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [esi+ebx*4]
	add	ebx, edx
	mov	DWORD PTR _xx$89793[ebp+eax*4], ebx
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL64@get_edge_t@2

; 1509 :     for ( i = 0 ; i < ctrl ; i++ )

	mov	ebx, DWORD PTR tv735[ebp]
	mov	edx, DWORD PTR _dymem
	mov	esi, DWORD PTR tv726[ebp]
$LN9@get_edge_t@2:

; 1511 :     if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	SHORT $LN8@get_edge_t@2

; 1512 :     { WRAPTYPE wrap = get_edge_wrap(e_id);

	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR [ecx+edx+784]
	mov	esi, DWORD PTR [esi+edx]
	test	ebx, ebx
	je	SHORT $LN45@get_edge_t@2
	push	esi
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN46@get_edge_t@2
$LN45@get_edge_t@2:
	mov	eax, esi
$LN46@get_edge_t@2:

; 1513 :       (*sym_wrap)(xx[ctrl-1],w,wrap);

	mov	ecx, DWORD PTR _xx$89793[ebp+edi*4-4]
	push	eax
	lea	eax, DWORD PTR _w$[ebp]
	push	eax
	push	ecx
	call	DWORD PTR _sym_wrap

; 1514 :       xx[ctrl-1] = w;

	lea	edx, DWORD PTR _w$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _xx$89793[ebp+edi*4-4], edx
$LN8@get_edge_t@2:

; 1515 :     }
; 1516 :     for ( i = 0 ; i < SDIM ; i++ ) 

	xor	esi, esi
	cmp	DWORD PTR _web+616, esi
	jle	$LN5@get_edge_t@2
	fild	DWORD PTR _ctrl$89789[ebp]
	mov	ecx, DWORD PTR _x$GSCopy$[ebp]
	fldz
$LN65@get_edge_t@2:

; 1518 :       for ( n = 0 ; n < ctrl ; n++ )

	xor	eax, eax
	fst	QWORD PTR [ecx]
	cmp	edi, 4
	jl	SHORT $LC60@get_edge_t@2

; 1517 :     { x[i] = 0;

	mov	edx, DWORD PTR _gl$89788[ebp]
	mov	edx, DWORD PTR [edx+28]
	mov	ebx, DWORD PTR _spot$89790[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR [edx]
	add	edx, 16					; 00000010H

; 1518 :       for ( n = 0 ; n < ctrl ; n++ )

$LN61@get_edge_t@2:

; 1519 :         x[i] += gl->lpolypart[spot][0][n]*xx[n][i];

	mov	ebx, DWORD PTR _xx$89793[ebp+eax*4]
	fld	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR _xx$89793[ebp+eax*4+4]
	fmul	QWORD PTR [edx-16]
	add	eax, 4
	add	edx, 32					; 00000020H
	fadd	QWORD PTR [ecx]
	fst	QWORD PTR [ecx]
	fld	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR _xx$89793[ebp+eax*4-8]
	fmul	QWORD PTR [edx-40]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [ecx]
	fld	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR _xx$89793[ebp+eax*4-4]
	fmul	QWORD PTR [edx-32]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [ecx]
	fld	QWORD PTR [ebx+esi*8]
	lea	ebx, DWORD PTR [edi-3]
	fmul	QWORD PTR [edx-24]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx]
	cmp	eax, ebx
	jl	SHORT $LN61@get_edge_t@2
	mov	ebx, DWORD PTR tv735[ebp]
$LC60@get_edge_t@2:

; 1518 :       for ( n = 0 ; n < ctrl ; n++ )

	cmp	eax, edi
	jge	SHORT $LN59@get_edge_t@2
	mov	edx, DWORD PTR _gl$89788[ebp]
	mov	edx, DWORD PTR [edx+28]
	mov	ebx, DWORD PTR _spot$89790[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+eax*8]
$LC4@get_edge_t@2:

; 1519 :         x[i] += gl->lpolypart[spot][0][n]*xx[n][i];

	mov	ebx, DWORD PTR _xx$89793[ebp+eax*4]
	fld	QWORD PTR [ebx+esi*8]
	inc	eax
	fmul	QWORD PTR [edx]
	add	edx, 8
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	cmp	eax, edi
	jl	SHORT $LC4@get_edge_t@2

; 1518 :       for ( n = 0 ; n < ctrl ; n++ )

	mov	ebx, DWORD PTR tv735[ebp]
$LN59@get_edge_t@2:

; 1520 :       x[i] *= ctrl;  /* scaling to length of edge */

	fld	ST(1)
	fmul	QWORD PTR [ecx]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [ecx]

; 1521 :       if ( inverted(e_id) )

	test	ebx, ebx
	je	SHORT $LN89@get_edge_t@2

; 1522 :         x[i] = -x[i];

	fchs
	fstp	QWORD PTR [ecx]
	jmp	SHORT $LN6@get_edge_t@2
$LN89@get_edge_t@2:
	fstp	ST(0)
$LN6@get_edge_t@2:

; 1515 :     }
; 1516 :     for ( i = 0 ; i < SDIM ; i++ ) 

	inc	esi
	add	ecx, 8
	cmp	esi, DWORD PTR _web+616
	jl	$LN65@get_edge_t@2
$LN92@get_edge_t@2:
	fstp	ST(1)
	fstp	ST(0)
$LN5@get_edge_t@2:

; 1523 :     }
; 1524 :   }
; 1525 : } // end get_edge_tail_tangent()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_get_edge_tail_tangent ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_get_edge_adjust
; Function compile flags: /Ogtp
;	COMDAT _get_edge_adjust
_TEXT	SEGMENT
_x$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_w$ = 12						; size = 4
_get_edge_adjust PROC					; COMDAT

; 1539 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1540 :   REAL x[MAXCOORD];
; 1541 :   int i ;
; 1542 : 
; 1543 :   for ( i = 0 ; i < SDIM ; i++ ) x[i] = 0.0;

	mov	ecx, DWORD PTR _web+616
	push	esi
	mov	esi, DWORD PTR _w$[ebp]
	push	edi
	test	ecx, ecx
	jle	SHORT $LN3@get_edge_a
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	lea	edi, DWORD PTR _x$[ebp]
	rep stosd
$LN3@get_edge_a:

; 1544 :   (*sym_wrap)(x,w,get_edge_wrap(e_id));

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	edi, DWORD PTR _dymem
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+edi+784]
	mov	eax, DWORD PTR [eax+edx]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN8@get_edge_a
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN8@get_edge_a:
	push	eax
	lea	eax, DWORD PTR _x$[ebp]
	push	esi
	push	eax
	call	DWORD PTR _sym_wrap

; 1545 : } // end get_edge_adjust()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_get_edge_adjust ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@IBENMFBG@Internal?5error?3?5vertex_evalence?$CI@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	_get_vertex_evalence
EXTRN	_elnames:BYTE
EXTRN	_valid_element:PROC
;	COMDAT ??_C@_0EC@IBENMFBG@Internal?5error?3?5vertex_evalence?$CI@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EC@IBENMFBG@Internal?5error?3?5vertex_evalence?$CI@ DB 'Internal e'
	DB	'rror: vertex_evalence() in infinite loop on vertex %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\utility.c
CONST	ENDS
;	COMDAT _get_vertex_evalence
_TEXT	SEGMENT
_e_id$ = -4						; size = 4
_v_id$ = 8						; size = 4
_get_vertex_evalence PROC				; COMDAT

; 1558 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1559 :   int n = 0;
; 1560 :   edge_id e_id;
; 1561 :   edge_id next_e;
; 1562 :   ATTR attr = get_vattr(v_id);

	mov	eax, DWORD PTR _web+12
	push	ebx
	mov	ebx, DWORD PTR _v_id$[ebp]
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ebx*4]

; 1563 : 
; 1564 :   if ( attr & (Q_MIDPOINT|Q_MIDEDGE) ) return 1;

	mov	eax, DWORD PTR [ecx+8]
	push	edi
	and	eax, 4325376				; 00420000H
	xor	edx, edx
	xor	edi, edi
	or	eax, edx
	je	SHORT $LN6@get_vertex@2
	lea	eax, DWORD PTR [edi+1]
	pop	edi
	pop	ebx

; 1580 : } // end get_vertex_evalence()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@get_vertex@2:
	push	esi

; 1565 :   e_id = get_vertex_edge(v_id);

	mov	esi, DWORD PTR [ecx+28]

; 1566 :   if ( !valid_element(e_id) ) return 0;

	push	esi
	mov	DWORD PTR _e_id$[ebp], esi
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	SHORT $LL5@get_vertex@2
	pop	esi
	pop	edi
	pop	ebx

; 1580 : } // end get_vertex_evalence()

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	5
$LL5@get_vertex@2:

; 1567 :   next_e = e_id;
; 1568 :   do
; 1569 :   { n++;
; 1570 :     next_e = get_next_tail_edge(next_e);

	mov	edx, DWORD PTR _web+124
	mov	ecx, esi
	shr	ecx, 27					; 0000001bH
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	and	ecx, 1
	mov	esi, DWORD PTR [eax+ecx*4+32]

; 1571 :     if ( n > 2*web.skel[EDGE].count )

	mov	ecx, DWORD PTR _web+176
	inc	edi
	lea	edx, DWORD PTR [ecx+ecx]
	cmp	edi, edx
	jle	SHORT $LN3@get_vertex@2

; 1572 :     { sprintf(errmsg,
; 1573 :          "Internal error: vertex_evalence() in infinite loop on vertex %s.\n",
; 1574 :            ELNAME(v_id));

	test	DWORD PTR _v_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN9@get_vertex@2
	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN10@get_vertex@2
$LN9@get_vertex@2:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN10@get_vertex@2:
	push	eax
	push	OFFSET ??_C@_0EC@IBENMFBG@Internal?5error?3?5vertex_evalence?$CI@
	push	OFFSET _errmsg
	call	_sprintf

; 1575 :       kb_error(2482,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2482					; 000009b2H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN3@get_vertex@2:

; 1576 :     }
; 1577 :   }
; 1578 :   while ( !equal_id(next_e,e_id) );

	cmp	esi, DWORD PTR _e_id$[ebp]
	jne	SHORT $LL5@get_vertex@2

; 1579 :   return n;

	pop	esi
	mov	eax, edi
	pop	edi
	pop	ebx

; 1580 : } // end get_vertex_evalence()

	mov	esp, ebp
	pop	ebp
	ret	0
_get_vertex_evalence ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@BMPMCHPP@Internal?5error?3?5edge_valence?$CI?$CJ?5i@ ; `string'
PUBLIC	_get_edge_valence
;	COMDAT ??_C@_0DN@BMPMCHPP@Internal?5error?3?5edge_valence?$CI?$CJ?5i@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DN@BMPMCHPP@Internal?5error?3?5edge_valence?$CI?$CJ?5i@ DB 'Intern'
	DB	'al error: edge_valence() in infinite loop on edge %s.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\utility.c
CONST	ENDS
;	COMDAT _get_edge_valence
_TEXT	SEGMENT
_m$ = -12						; size = 4
_n$ = -8						; size = 4
_fe$ = -4						; size = 4
_e_id$ = 8						; size = 4
_get_edge_valence PROC					; COMDAT

; 1591 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1592 :   int n = 0,m=0;
; 1593 :   facetedge_id fe = get_edge_fe(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	eax, DWORD PTR _web+124
	push	ebx
	mov	ebx, ecx
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ebx*4]
	xor	edx, edx
	push	esi
	mov	DWORD PTR _n$[ebp], edx
	mov	DWORD PTR _m$[ebp], edx
	cmp	eax, edx
	jne	SHORT $LN12@get_edge_v
	xor	eax, eax
	mov	DWORD PTR _fe$[ebp], eax
	jmp	SHORT $LN13@get_edge_v
$LN12@get_edge_v:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN11@get_edge_v
	xor	eax, 134217728				; 08000000H
$LN11@get_edge_v:
	mov	DWORD PTR _fe$[ebp], eax
$LN13@get_edge_v:

; 1594 :   facetedge_id next_fe = fe;

	mov	esi, eax

; 1595 : 
; 1596 :   if ( !valid_id(fe) ) return 0;

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN20@get_edge_v
	pop	esi
	xor	eax, eax
	pop	ebx

; 1610 : } // end get_edge_valence()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@get_edge_v:
	push	edi

; 1595 : 
; 1596 :   if ( !valid_id(fe) ) return 0;

	mov	edi, DWORD PTR _web+460
	jmp	SHORT $LN5@get_edge_v
	npad	5
$LL21@get_edge_v:
	mov	eax, DWORD PTR _fe$[ebp]
$LN5@get_edge_v:

; 1597 :   do
; 1598 :   { if ( valid_id(get_fe_facet(fe)) ) n++;

	push	eax
	call	_get_fe_facet
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN22@get_edge_v
	inc	DWORD PTR _n$[ebp]
$LN22@get_edge_v:

; 1599 :     next_fe = get_next_facet(next_fe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN16@get_edge_v
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+esi*4]
	mov	esi, DWORD PTR [ecx+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN15@get_edge_v
$LN16@get_edge_v:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+esi*4]
	mov	esi, DWORD PTR [edx+40]
$LN15@get_edge_v:

; 1600 :     m++;  /* infinite loop preventer */

	mov	eax, DWORD PTR _m$[ebp]
	inc	eax
	mov	DWORD PTR _m$[ebp], eax

; 1601 :     if ( m > web.skel[FACETEDGE].count )

	cmp	eax, DWORD PTR _web+512
	jle	SHORT $LN4@get_edge_v

; 1602 :     { sprintf(errmsg,
; 1603 :          "Internal error: edge_valence() in infinite loop on edge %s.\n",
; 1604 :            ELNAME(e_id));

	test	DWORD PTR _e_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN9@get_edge_v
	lea	eax, DWORD PTR [ebx+1]
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN10@get_edge_v
$LN9@get_edge_v:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN10@get_edge_v:
	push	eax
	push	OFFSET ??_C@_0DN@BMPMCHPP@Internal?5error?3?5edge_valence?$CI?$CJ?5i@
	push	OFFSET _errmsg
	call	_sprintf

; 1605 :       kb_error(2480,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2480					; 000009b0H
	call	_kb_error
	mov	edi, DWORD PTR _web+460
	add	esp, 24					; 00000018H
$LN4@get_edge_v:

; 1606 :     }
; 1607 :   }
; 1608 :   while ( next_fe != fe );

	cmp	esi, DWORD PTR _fe$[ebp]
	jne	$LL21@get_edge_v

; 1609 :   return n;

	mov	eax, DWORD PTR _n$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 1610 : } // end get_edge_valence()

	mov	esp, ebp
	pop	ebp
	ret	0
_get_edge_valence ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DP@KGEFDPEA@Internal?5error?3?5facet_valence?$CI?$CJ?5@ ; `string'
PUBLIC	_get_facet_valence
;	COMDAT ??_C@_0DP@KGEFDPEA@Internal?5error?3?5facet_valence?$CI?$CJ?5@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DP@KGEFDPEA@Internal?5error?3?5facet_valence?$CI?$CJ?5@ DB 'Intern'
	DB	'al error: facet_valence() in infinite loop on facet %s.', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\utility.c
CONST	ENDS
;	COMDAT _get_facet_valence
_TEXT	SEGMENT
_n$ = -4						; size = 4
_fe$ = 8						; size = 4
_f_id$ = 8						; size = 4
_get_facet_valence PROC					; COMDAT

; 1623 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi

; 1624 :   int n = 0;
; 1625 :   facetedge_id fe = get_facet_fe(f_id);

	mov	edi, DWORD PTR _f_id$[ebp]
	mov	ebx, edi
	shr	ebx, 28					; 0000001cH
	xor	ecx, ecx
	and	ebx, 1
	jne	SHORT $LN12@get_facet_@3
	xor	esi, esi
	mov	DWORD PTR _fe$[ebp], esi
	jmp	SHORT $LN13@get_facet_@3
$LN12@get_facet_@3:
	mov	edx, DWORD PTR _web+236
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN11@get_facet_@3
	xor	eax, 134217728				; 08000000H
$LN11@get_facet_@3:
	mov	DWORD PTR _fe$[ebp], eax
	mov	esi, eax
$LN13@get_facet_@3:

; 1626 :   facetedge_id next_fe = fe;
; 1627 : 
; 1628 :   if ( !valid_id(fe) ) return 0;

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN20@get_facet_@3
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 1641 : } // end get_facet_valence()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@get_facet_@3:

; 1626 :   facetedge_id next_fe = fe;
; 1627 : 
; 1628 :   if ( !valid_id(fe) ) return 0;

	mov	eax, DWORD PTR _web+460
	npad	8
$LL5@get_facet_@3:

; 1629 :   do
; 1630 :   { n++;

	inc	ecx
	mov	DWORD PTR _n$[ebp], ecx

; 1631 :     next_fe = get_next_edge(next_fe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN16@get_facet_@3
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [edx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN15@get_facet_@3
$LN16@get_facet_@3:
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+esi*4]
	mov	esi, DWORD PTR [edx+32]
$LN15@get_facet_@3:

; 1632 :     if ( n > 2*web.skel[EDGE].count )

	mov	edx, DWORD PTR _web+176
	add	edx, edx
	cmp	ecx, edx
	jle	SHORT $LN4@get_facet_@3

; 1633 :     { sprintf(errmsg,
; 1634 :          "Internal error: facet_valence() in infinite loop on facet %s.\n",
; 1635 :            ELNAME(f_id));

	test	ebx, ebx
	je	SHORT $LN9@get_facet_@3
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN10@get_facet_@3
$LN9@get_facet_@3:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN10@get_facet_@3:
	push	eax
	push	OFFSET ??_C@_0DP@KGEFDPEA@Internal?5error?3?5facet_valence?$CI?$CJ?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1636 :       kb_error(2481,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2481					; 000009b1H
	call	_kb_error
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR _n$[ebp]
	add	esp, 24					; 00000018H
$LN4@get_facet_@3:

; 1637 :     }
; 1638 :   }
; 1639 :   while ( valid_id(next_fe) && (next_fe != fe) );

	test	esi, 268435456				; 10000000H
	je	SHORT $LN1@get_facet_@3
	cmp	esi, DWORD PTR _fe$[ebp]
	jne	$LL5@get_facet_@3
$LN1@get_facet_@3:
	pop	edi
	pop	esi

; 1640 :   return n;

	mov	eax, ecx
	pop	ebx

; 1641 : } // end get_facet_valence()

	mov	esp, ebp
	pop	ebp
	ret	0
_get_facet_valence ENDP
_TEXT	ENDS
PUBLIC	_get_body_valence
EXTRN	_get_next_body_facet:PROC
; Function compile flags: /Ogtp
;	COMDAT _get_body_valence
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_valence PROC					; COMDAT

; 1651 : {

	push	ebp
	mov	ebp, esp

; 1652 :   int n = 0;
; 1653 :   facet_id f_id = get_body_facet(b_id);

	mov	eax, DWORD PTR _b_id$[ebp]
	push	esi
	push	edi
	xor	edi, edi
	test	eax, 268435456				; 10000000H
	je	SHORT $LN11@get_body_v@3
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	esi, DWORD PTR [edx+400]
	jmp	SHORT $LN12@get_body_v@3
$LN11@get_body_v@3:
	xor	esi, esi
$LN12@get_body_v@3:

; 1654 :   facet_id next_f = f_id;

	mov	eax, esi

; 1655 : 
; 1656 :   if ( !valid_id(f_id) ) return 0;

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN6@get_body_v@3
	pop	edi
	xor	eax, eax
	pop	esi

; 1670 : } // end get_body_valence()

	pop	ebp
	ret	0
$LN6@get_body_v@3:

; 1657 :   if ( web.representation == STRING ) return get_facet_valence(f_id);

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LL4@get_body_v@3
	push	esi
	call	_get_facet_valence
	add	esp, 4
	pop	edi
	pop	esi

; 1670 : } // end get_body_valence()

	pop	ebp
	ret	0
	npad	1
$LL4@get_body_v@3:

; 1658 : /*
; 1659 :   if ( bfacet_timestamp < top_timestamp )
; 1660 :   { make_bfacet_lists();
; 1661 :     bfacet_timestamp = top_timestamp;
; 1662 :   }
; 1663 : */
; 1664 :   do
; 1665 :   { n++;
; 1666 :     next_f = get_next_body_facet(next_f);

	push	eax
	inc	edi
	call	_get_next_body_facet
	add	esp, 4

; 1667 :   }
; 1668 :   while ( (next_f != f_id) && (n < 3*web.skel[FACET].count) );

	cmp	eax, esi
	je	SHORT $LN1@get_body_v@3
	mov	ecx, DWORD PTR _web+288
	lea	ecx, DWORD PTR [ecx+ecx*2]
	cmp	edi, ecx
	jl	SHORT $LL4@get_body_v@3
$LN1@get_body_v@3:

; 1669 :   return n;

	mov	eax, edi
	pop	edi
	pop	esi

; 1670 : } // end get_body_valence()

	pop	ebp
	ret	0
_get_body_valence ENDP
_TEXT	ENDS
PUBLIC	_set_facet_vertices
; Function compile flags: /Ogtp
;	COMDAT _set_facet_vertices
_TEXT	SEGMENT
_set_facet_vertices PROC				; COMDAT

; 1681 :   /* have to make expandable v list for quadratic mode */
; 1682 : }

	ret	0
_set_facet_vertices ENDP
_TEXT	ENDS
PUBLIC	_end_normal_motion
EXTRN	_normal_motion_flag:DWORD
EXTRN	_vertex_normals:DWORD
; Function compile flags: /Ogtp
;	COMDAT _end_normal_motion
_TEXT	SEGMENT
_end_normal_motion PROC					; COMDAT

; 1729 :   if ( vertex_normals != NULL ) myfree((char*)vertex_normals);

	mov	eax, DWORD PTR _vertex_normals
	push	esi
	xor	esi, esi
	cmp	eax, esi
	je	SHORT $LN4@end_normal
	push	eax
	call	_myfree
	add	esp, 4
$LN4@end_normal:

; 1730 :   vertex_normals = NULL;
; 1731 :   normal_motion_flag = 0;

	mov	DWORD PTR _normal_motion_flag, esi
	mov	DWORD PTR _vertex_normals, esi
	pop	esi

; 1732 : } // end end_normal_motion()

	ret	0
_end_normal_motion ENDP
_TEXT	ENDS
PUBLIC	_norm$GSCopy$
PUBLIC	_fe$GSCopy$
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_calc_vertex_normal
EXTRN	_dot:PROC
EXTRN	_set_v_constraint_status:PROC
EXTRN	_clear_v_constraint_status:PROC
EXTRN	_constr_proj:PROC
EXTRN	_nullcon:QWORD
EXTRN	_cross_prod:PROC
EXTRN	_F_BOUNDARY_ATTR:DWORD
; Function compile flags: /Ogtp
;	COMDAT _calc_vertex_normal
_TEXT	SEGMENT
_con$90104 = -272					; size = 28
tv1090 = -244						; size = 4
_bdry$ = -240						; size = 4
_v_id$GSCopy$ = -236					; size = 4
_fe$GSCopy$ = -232					; size = 4
_norm$GSCopy$ = -228					; size = 4
_perp$90106 = -224					; size = 48
_fnorm$ = -176						; size = 48
_conlist$90105 = -128					; size = 28
_z$ = -100						; size = 48
_y$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_norm$ = 16						; size = 4
_calc_vertex_normal PROC				; COMDAT

; 1876 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1877 :   int i,j;
; 1878 :   REAL y[MAXCOORD],z[MAXCOORD];
; 1879 :   REAL fnorm[MAXCOORD];
; 1880 :   facetedge_id sidea;
; 1881 :   struct boundary *bdry;  /* to check staying on same boundary */
; 1882 :   REAL size;
; 1883 : 
; 1884 : 
; 1885 :   /* check for string */
; 1886 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	mov	edx, DWORD PTR _v_id$[ebp]
	mov	eax, DWORD PTR _fe$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _norm$[ebp]
	push	edi

; 1942 : 
; 1943 :   /* orient */
; 1944 :   onormalize:
; 1945 :   if ( inverted(get_fe_facet(fe)) )

	mov	DWORD PTR _v_id$GSCopy$[ebp], edx
	mov	DWORD PTR _fe$GSCopy$[ebp], eax
	mov	DWORD PTR _norm$GSCopy$[ebp], esi
	jne	$LN48@calc_verte

; 1887 :   { edge_id e_id,ee_id;
; 1888 :     e_id = get_vertex_edge(v_id);

	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edi, DWORD PTR [ecx+28]

; 1889 :     ee_id = get_next_tail_edge(e_id);

	mov	eax, DWORD PTR _web+124
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	esi, edi

; 1890 : 
; 1891 :     get_edge_side(e_id,z);

	lea	edx, DWORD PTR _z$[ebp]
	shr	esi, 27					; 0000001bH
	push	edx
	and	esi, 1
	mov	ebx, DWORD PTR [ecx+esi*4+32]
	push	edi
	call	_get_edge_side

; 1892 :     get_edge_side(ee_id,y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	push	ebx
	call	_get_edge_side

; 1893 :     if ( equal_id(e_id,ee_id) ) { norm[0] = y[1]; norm[1] = -y[0]; }

	fld	QWORD PTR _y$[ebp+8]
	mov	eax, DWORD PTR _norm$GSCopy$[ebp]
	add	esp, 16					; 00000010H
	cmp	edi, ebx
	jne	SHORT $LN47@calc_verte
	fstp	QWORD PTR [eax]
	fld	QWORD PTR _y$[ebp]
	fchs
	jmp	SHORT $LN178@calc_verte
$LN47@calc_verte:

; 1894 :     else { norm[0] = y[1] - z[1]; norm[1] = z[0] - y[0]; }

	fsub	QWORD PTR _z$[ebp+8]
	fstp	QWORD PTR [eax]
	fld	QWORD PTR _z$[ebp]
	fsub	QWORD PTR _y$[ebp]
$LN178@calc_verte:
	fstp	QWORD PTR [eax+8]

; 1895 :     if (inverted(e_id)) { norm[0] = -norm[0]; norm[1] = -norm[1];}

	test	esi, esi
	je	$normalize$90047
	fld	QWORD PTR [eax]
	fchs
	fstp	QWORD PTR [eax]
	fld	QWORD PTR [eax+8]
	fchs
	fstp	QWORD PTR [eax+8]

; 1896 :     goto normalize;

	jmp	$normalize$90047
$LN48@calc_verte:

; 1897 :   }
; 1898 : 
; 1899 :   if ( !valid_id(fe) )

	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	DWORD PTR tv1090[ebp], ecx
	jne	SHORT $LN160@calc_verte

; 1900 :   { fe = get_vertex_fe(v_id);

	push	edx
	call	_get_vertex_fe

; 1901 :     if ( !valid_id(fe) )

	mov	ecx, eax
	shr	ecx, 28					; 0000001cH
	add	esp, 4
	and	ecx, 1
	mov	DWORD PTR _fe$GSCopy$[ebp], eax
	mov	DWORD PTR tv1090[ebp], ecx
	jne	SHORT $LN160@calc_verte

; 1902 :     { for ( i = 0 ; i < SDIM ; i++ ) norm[i] = 0.0;

	fldz
	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	$LN49@calc_verte
$LN42@calc_verte:
	fst	QWORD PTR [esi+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN42@calc_verte
	pop	edi
	pop	esi
	pop	ebx

; 1980 : } // end calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN160@calc_verte:

; 1903 :       return 0.0;
; 1904 :     }
; 1905 :   }
; 1906 : 
; 1907 :   for ( i = 0 ; i < SDIM ; i++ ) norm[i] = 0.0;

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN37@calc_verte
$LL39@calc_verte:
	fldz
	inc	edx
	fstp	QWORD PTR [esi+edx*8-8]
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL39@calc_verte
$LN37@calc_verte:

; 1908 :   bdry = get_facet_boundary(get_fe_facet(fe));  /* original boundary */

	mov	edx, DWORD PTR _F_BOUNDARY_ATTR
	mov	ebx, DWORD PTR _web+460
	test	edx, edx
	je	SHORT $LN51@calc_verte
	test	ecx, ecx
	jne	SHORT $LN62@calc_verte
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN61@calc_verte
$LN62@calc_verte:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN61@calc_verte
	xor	ecx, 134217728				; 08000000H
$LN61@calc_verte:
	mov	esi, DWORD PTR _web+236
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+328
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+esi+64]
	mov	ecx, DWORD PTR [ecx+edx]
	imul	ecx, 136				; 00000088H
	add	ecx, DWORD PTR _web+776
	mov	DWORD PTR _bdry$[ebp], ecx
	jmp	SHORT $LN52@calc_verte
$LN51@calc_verte:
	mov	DWORD PTR _bdry$[ebp], 0
$LN52@calc_verte:

; 1909 : 
; 1910 :   /* go around one way to edge of face */
; 1911 :   sidea = fe;

	mov	esi, eax
$LL36@calc_verte:

; 1912 :   do
; 1913 :   {
; 1914 :     get_fe_side(sidea,z);

	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+ebx]
	mov	edx, esi
	and	edx, 134217728				; 08000000H
	xor	edx, DWORD PTR [ecx+20]
	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	push	edx
	call	_get_edge_side

; 1915 :     get_fe_side(get_prev_edge(sidea),y);

	mov	ecx, DWORD PTR _web+460
	shr	esi, 27					; 0000001bH
	add	esp, 8
	and	esi, 1
	je	SHORT $LN68@calc_verte
	mov	eax, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [eax+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN67@calc_verte
$LN68@calc_verte:
	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edx+28]
$LN67@calc_verte:
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	push	eax
	call	_get_edge_side

; 1916 :     cross_prod(y,z,fnorm);

	lea	edx, DWORD PTR _fnorm$[ebp]
	push	edx
	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	call	_cross_prod

; 1917 :     for ( i = 0 ; i < SDIM ; i++ ) norm[i] += fnorm[i];

	xor	ecx, ecx
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN161@calc_verte
	mov	eax, DWORD PTR _norm$GSCopy$[ebp]
	lea	edx, DWORD PTR _fnorm$[ebp]
	sub	edx, eax
	npad	7
$LL33@calc_verte:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL33@calc_verte
$LN161@calc_verte:

; 1918 : 
; 1919 :     /* go to next facet */
; 1920 :     sidea = get_prev_edge(sidea);

	mov	ebx, DWORD PTR _web+460
	test	esi, esi
	je	SHORT $LN74@calc_verte
	mov	edx, DWORD PTR [edi+ebx]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN73@calc_verte
$LN74@calc_verte:
	mov	eax, DWORD PTR [edi+ebx]
	mov	eax, DWORD PTR [eax+28]
$LN73@calc_verte:

; 1921 :     if ( equal_id(sidea,get_next_facet(sidea)) ) break;  /* edge */

	mov	esi, eax
	shr	esi, 27					; 0000001bH
	and	esi, 1
	je	SHORT $LN78@calc_verte
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [edx+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN77@calc_verte
$LN78@calc_verte:
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ecx, DWORD PTR [edx+40]
$LN77@calc_verte:
	cmp	eax, ecx
	je	$LN34@calc_verte

; 1922 :     sidea = fe_inverse(get_next_facet(sidea));

	test	esi, esi
	je	SHORT $LN82@calc_verte
	mov	esi, DWORD PTR [edx+36]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN81@calc_verte
$LN82@calc_verte:
	mov	esi, DWORD PTR [edx+40]
$LN81@calc_verte:

; 1923 :     if ( bdry != get_facet_boundary(get_fe_facet(sidea)) ) break;

	mov	ecx, DWORD PTR _F_BOUNDARY_ATTR
	xor	esi, 134217728				; 08000000H
	test	ecx, ecx
	je	SHORT $LN53@calc_verte
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN86@calc_verte
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN85@calc_verte
$LN86@calc_verte:
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [edx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN85@calc_verte
	xor	eax, 134217728				; 08000000H
$LN85@calc_verte:
	mov	edx, DWORD PTR _web+236
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN54@calc_verte
$LN53@calc_verte:
	xor	eax, eax
$LN54@calc_verte:
	cmp	DWORD PTR _bdry$[ebp], eax
	jne	SHORT $LN34@calc_verte

; 1924 :     if ( equal_id(sidea,fe) ) goto onormalize; /* went all the way around */

	cmp	esi, DWORD PTR _fe$GSCopy$[ebp]
	je	$onormalize$90075

; 1925 :   }
; 1926 :   while ( equal_id(get_next_facet(sidea),get_prev_facet(sidea)) );

	mov	edx, esi
	shr	edx, 27					; 0000001bH
	and	edx, 1
	je	SHORT $LN90@calc_verte
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN89@calc_verte
$LN90@calc_verte:
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [eax+40]
$LN89@calc_verte:
	test	edx, edx
	je	SHORT $LN94@calc_verte
	mov	eax, DWORD PTR [eax+40]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN93@calc_verte
$LN94@calc_verte:
	mov	eax, DWORD PTR [eax+36]
$LN93@calc_verte:
	cmp	ecx, eax
	je	$LL36@calc_verte
$LN34@calc_verte:

; 1927 : 
; 1928 :   /* go around the other way */
; 1929 :   sidea = fe;

	mov	edi, DWORD PTR _fe$GSCopy$[ebp]

; 1941 :   }

	jmp	SHORT $LL27@calc_verte
	npad	5
$LL158@calc_verte:
	mov	ebx, DWORD PTR _web+460
$LL27@calc_verte:

; 1930 :   while ( equal_id(get_next_facet(sidea),get_prev_facet(sidea)) )

	mov	esi, edi
	shr	esi, 27					; 0000001bH
	and	esi, 1
	je	SHORT $LN98@calc_verte
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+edx*4]
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN97@calc_verte
$LN98@calc_verte:
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ecx, DWORD PTR [eax+40]
$LN97@calc_verte:
	test	esi, esi
	je	SHORT $LN102@calc_verte
	mov	edx, DWORD PTR [eax+40]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN101@calc_verte
$LN102@calc_verte:
	mov	edx, DWORD PTR [eax+36]
$LN101@calc_verte:
	cmp	ecx, edx
	jne	$onormalize$90075

; 1931 :   {
; 1932 :     if ( equal_id(sidea,get_next_facet(sidea)) ) break;  /* edge */

	test	esi, esi
	je	SHORT $LN106@calc_verte
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN105@calc_verte
$LN106@calc_verte:
	mov	ecx, DWORD PTR [eax+40]
$LN105@calc_verte:
	cmp	edi, ecx
	je	$onormalize$90075

; 1933 :     sidea = fe_inverse(get_next_facet(sidea));

	test	esi, esi
	je	SHORT $LN110@calc_verte
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN109@calc_verte
$LN110@calc_verte:
	mov	eax, DWORD PTR [eax+40]
$LN109@calc_verte:
	xor	eax, 134217728				; 08000000H

; 1934 :     sidea = get_next_edge(sidea);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN114@calc_verte
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	edi, DWORD PTR [ecx+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN113@calc_verte
$LN114@calc_verte:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	edi, DWORD PTR [edx+32]
$LN113@calc_verte:

; 1935 :     if ( bdry != get_facet_boundary(get_fe_facet(sidea)) ) break;

	mov	ecx, DWORD PTR _F_BOUNDARY_ATTR
	test	ecx, ecx
	je	SHORT $LN55@calc_verte
	test	edi, 268435456				; 10000000H
	jne	SHORT $LN118@calc_verte
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN117@calc_verte
$LN118@calc_verte:
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [edx+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN117@calc_verte
	xor	eax, 134217728				; 08000000H
$LN117@calc_verte:
	mov	edx, DWORD PTR _web+236
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN56@calc_verte
$LN55@calc_verte:
	xor	eax, eax
$LN56@calc_verte:
	cmp	DWORD PTR _bdry$[ebp], eax
	jne	$onormalize$90075

; 1936 : 
; 1937 :     get_fe_side(sidea,z);

	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ebx]
	mov	ecx, edi
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [eax+20]
	lea	edx, DWORD PTR _z$[ebp]
	push	edx
	push	ecx
	call	_get_edge_side

; 1938 :     get_fe_side(get_prev_edge(sidea),y);

	mov	ecx, DWORD PTR _web+460
	add	esp, 8
	test	edi, 134217728				; 08000000H
	je	SHORT $LN124@calc_verte
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN123@calc_verte
$LN124@calc_verte:
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+28]
$LN123@calc_verte:
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	push	eax
	call	_get_edge_side

; 1939 :     cross_prod(y,z,fnorm);

	lea	edx, DWORD PTR _fnorm$[ebp]
	push	edx
	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	call	_cross_prod

; 1940 :     for ( i = 0 ; i < SDIM ; i++ ) norm[i] += fnorm[i];

	xor	ecx, ecx
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _web+616, ecx
	jle	$LL158@calc_verte
	mov	eax, DWORD PTR _norm$GSCopy$[ebp]
	lea	edx, DWORD PTR _fnorm$[ebp]
	sub	edx, eax
$LL165@calc_verte:
	fld	QWORD PTR [eax+edx]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL165@calc_verte

; 1941 :   }

	jmp	$LL158@calc_verte
$onormalize$90075:

; 1942 : 
; 1943 :   /* orient */
; 1944 :   onormalize:
; 1945 :   if ( inverted(get_fe_facet(fe)) )

	cmp	DWORD PTR tv1090[ebp], 0
	jne	SHORT $LN130@calc_verte
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN129@calc_verte
$LN130@calc_verte:
	mov	ecx, DWORD PTR _fe$GSCopy$[ebp]
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+edx*4]
	mov	eax, DWORD PTR [eax+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN129@calc_verte
	xor	eax, 134217728				; 08000000H
$LN129@calc_verte:
	test	eax, 134217728				; 08000000H
	je	SHORT $normalize$90047

; 1946 :       for ( i = 0 ; i < SDIM ; i++ ) norm[i] = -norm[i];

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $normalize$90047
	mov	ecx, DWORD PTR _norm$GSCopy$[ebp]
$LL166@calc_verte:
	fld	QWORD PTR [ecx+eax*8]
	inc	eax
	fchs
	fstp	QWORD PTR [ecx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL166@calc_verte
$normalize$90047:

; 1947 : 
; 1948 :   normalize:
; 1949 :   if ( get_vattr(v_id) & CONSTRAINT )

	mov	ecx, DWORD PTR _v_id$GSCopy$[ebp]
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	lea	edi, DWORD PTR [edx+ecx*4]
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN162@calc_verte

; 1950 :     {
; 1951 :       conmap_t * conmap = get_v_constraint_map(v_id);

	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	cmp	DWORD PTR [edx+eax+1288], ecx
	je	SHORT $LN57@calc_verte
	mov	eax, DWORD PTR [edx+eax+1264]
	add	eax, DWORD PTR [edi]
	jmp	SHORT $LN58@calc_verte
$LN57@calc_verte:
	mov	eax, OFFSET _nullcon
$LN58@calc_verte:

; 1952 :       int oncount = 0,hitcount;
; 1953 :       struct constraint *con[MAXCONHIT];
; 1954 :       int conlist[MAXCONHIT];
; 1955 :       REAL perp[MAXCOORD];
; 1956 : 
; 1957 :       for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	ecx, 1
	xor	esi, esi
	cmp	DWORD PTR [eax], ecx
	jl	SHORT $LN13@calc_verte
	npad	4
$LL167@calc_verte:

; 1958 :         { 
; 1959 :           if ( (conmap[j] & CON_HIT_BIT) && (oncount < web.sdim) )

	mov	edx, DWORD PTR [eax+ecx*4]
	test	edx, edx
	jns	SHORT $LN14@calc_verte
	cmp	esi, DWORD PTR _web+616
	jge	SHORT $LN14@calc_verte

; 1960 :           { conlist[oncount] = conmap[j];

	mov	DWORD PTR _conlist$90105[ebp+esi*4], edx

; 1961 :             con[oncount++] = get_constraint(conmap[j]);

	mov	edx, DWORD PTR [eax+ecx*4]
	and	edx, 1073741823				; 3fffffffH
	imul	edx, 176				; 000000b0H
	add	edx, DWORD PTR _web+652
	inc	esi
	mov	DWORD PTR _con$90104[ebp+esi*4-4], edx
$LN14@calc_verte:

; 1952 :       int oncount = 0,hitcount;
; 1953 :       struct constraint *con[MAXCONHIT];
; 1954 :       int conlist[MAXCONHIT];
; 1955 :       REAL perp[MAXCOORD];
; 1956 : 
; 1957 :       for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	inc	ecx
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LL167@calc_verte
	mov	edx, DWORD PTR _web+104
$LN13@calc_verte:

; 1962 :           }
; 1963 :         }
; 1964 : 
; 1965 :       hitcount = constr_proj(TANGPROJ,oncount,con,get_coord(v_id),
; 1966 :                  norm,perp,conlist,DETECT,v_id);

	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	mov	ebx, DWORD PTR _norm$GSCopy$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR _conlist$90105[ebp]
	push	ecx
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ecx+64]
	add	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR _perp$90106[ebp]
	push	eax
	push	ebx
	push	edx
	lea	eax, DWORD PTR _con$90104[ebp]
	push	eax
	push	esi
	push	2
	call	_constr_proj
	mov	edi, eax
	add	esp, 36					; 00000024H

; 1967 :       if ( hitcount != oncount )

	cmp	edi, esi
	je	SHORT $LN8@calc_verte

; 1968 :         { clear_v_constraint_status(v_id);

	mov	ecx, DWORD PTR _v_id$GSCopy$[ebp]
	push	ecx
	call	_clear_v_constraint_status
	add	esp, 4

; 1969 :           for ( j = 0 ; j < hitcount ; j++ )

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN8@calc_verte
$LL168@calc_verte:

; 1970 :              set_v_constraint_status(v_id,conlist[j]);

	mov	edx, DWORD PTR _conlist$90105[ebp+esi*4]
	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	edx
	push	eax
	call	_set_v_constraint_status
	inc	esi
	add	esp, 8
	cmp	esi, edi
	jl	SHORT $LL168@calc_verte
$LN8@calc_verte:

; 1971 :         }
; 1972 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN5@calc_verte
	lea	edx, DWORD PTR _perp$90106[ebp]
	mov	eax, ebx
	sub	edx, ebx
	npad	3
$LL169@calc_verte:

; 1973 :         norm[j] -= perp[j];

	fld	QWORD PTR [eax]
	inc	ecx
	fsub	QWORD PTR [edx+eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL169@calc_verte

; 1971 :         }
; 1972 :       for ( j = 0 ; j < SDIM ; j++ )

	jmp	SHORT $LN5@calc_verte
$LN162@calc_verte:
	mov	ebx, DWORD PTR _norm$GSCopy$[ebp]
$LN5@calc_verte:

; 1974 :      }
; 1975 :       
; 1976 :   size = sqrt(SDIM_dot(norm,norm));

	mov	ecx, DWORD PTR _web+616
	push	ecx
	push	ebx
	push	ebx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 1977 :   if ( size <= 0.0 ) return 0.0; 

	fldz
	fcom	ST(1)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN174@calc_verte
	pop	edi
	fstp	ST(1)
	pop	esi
	pop	ebx

; 1980 : } // end calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN174@calc_verte:

; 1978 :   for ( i = 0 ; i < SDIM ; i++ ) norm[i] /= size;

	xor	eax, eax
	fstp	ST(0)
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN1@calc_verte
$LN170@calc_verte:
	fld	QWORD PTR [ebx+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [ebx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN170@calc_verte
$LN1@calc_verte:

; 1979 :   return size/web.simplex_factorial;

	fdiv	QWORD PTR _web+792
$LN49@calc_verte:

; 1980 : } // end calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_calc_vertex_normal ENDP
_TEXT	ENDS
PUBLIC	_normcount$GSCopy$
PUBLIC	_normals$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_project_vertex_normals
EXTRN	_hessian_epsilon:QWORD
EXTRN	_tr_mat_mul:PROC
EXTRN	_mat_mul_tr:PROC
EXTRN	_gram_schmidt:PROC
EXTRN	_eval_all:PROC
EXTRN	_mat2d_setup:PROC
; Function compile flags: /Ogtp
;	COMDAT _project_vertex_normals
_TEXT	SEGMENT
_gradsqXvS$ = -980					; size = 24
_qqqXvS$ = -956						; size = 24
_ppqXvS$ = -932						; size = 24
_dummy$ = -908						; size = 8
_grads$ = -900						; size = 4
_pp$ = -896						; size = 4
_oncount$ = -892					; size = 4
_qq$ = -888						; size = 4
_conmap$ = -884						; size = 4
_normals$GSCopy$ = -880					; size = 4
tv792 = -876						; size = 4
_j$ = -876						; size = 4
_normcount$GSCopy$ = -872				; size = 4
_gradsxJ$ = -868					; size = 288
_qqxJ$ = -580						; size = 288
_ppxJ$ = -292						; size = 288
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_normals$ = 12						; size = 4
_normcount$ = 16					; size = 4
_project_vertex_normals PROC				; COMDAT

; 2598 : { conmap_t *conmap;

	push	ebp
	mov	ebp, esp
	sub	esp, 980				; 000003d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2649 :       }
; 2650 :     }
; 2651 :   }
; 2652 :   return normcount; 

	mov	eax, DWORD PTR _normcount$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _normals$[ebp]
	push	edi
	mov	edi, DWORD PTR _v_id$[ebp]
	push	6
	push	6
	lea	ecx, DWORD PTR _gradsxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _gradsqXvS$[ebp]
	push	edx
	mov	DWORD PTR _normals$GSCopy$[ebp], esi
	mov	DWORD PTR _normcount$GSCopy$[ebp], eax
	call	_mat2d_setup
	push	6
	mov	ebx, eax
	push	6
	lea	eax, DWORD PTR _ppxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ppqXvS$[ebp]
	push	ecx
	mov	DWORD PTR _grads$[ebp], ebx
	call	_mat2d_setup
	push	6
	push	6
	lea	edx, DWORD PTR _qqxJ$[ebp]
	mov	DWORD PTR _pp$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _qqqXvS$[ebp]
	push	eax
	call	_mat2d_setup
	mov	ecx, DWORD PTR _web+104
	mov	DWORD PTR _qq$[ebp], eax
	mov	eax, DWORD PTR _dymem
	add	esp, 48					; 00000030H
	cmp	DWORD PTR [ecx+eax+1288], 0
	je	SHORT $LN32@project_ve

; 2599 :   int oncount;
; 2600 :   MAT2D(grads,MAXCOORD,MAXCOORD);
; 2601 :   MAT2D(pp,MAXCOORD,MAXCOORD);
; 2602 :   MAT2D(qq,MAXCOORD,MAXCOORD);
; 2603 :   REAL dummy;
; 2604 :   int i,j,n;
; 2605 : 
; 2606 :   conmap = get_v_constraint_map(v_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+104
	add	edx, DWORD PTR [ecx+eax+1264]
	jmp	SHORT $LN75@project_ve
$LN32@project_ve:
	mov	edx, OFFSET _nullcon
$LN75@project_ve:

; 2607 :   oncount = 0;

	xor	ecx, ecx
	mov	DWORD PTR _conmap$[ebp], edx
	mov	DWORD PTR _oncount$[ebp], ecx

; 2608 :   if ( conmap[0] )

	cmp	DWORD PTR [edx], ecx
	je	$LN51@project_ve

; 2609 :   { /* calculate projection matrix to fewer degrees of freedom */
; 2610 :     for ( j = 1; j <= (int)conmap[0] ; j++ )

	cmp	DWORD PTR [edx], 1
	mov	DWORD PTR _j$[ebp], 1
	jl	$LN58@project_ve
	npad	6
$LL28@project_ve:

; 2611 :     { struct constraint *constr;
; 2612 :       if ( !(conmap[j] & CON_HIT_BIT) ) continue;

	mov	eax, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	test	eax, eax
	jns	SHORT $LN27@project_ve

; 2613 :       constr = get_constraint(conmap[j]);
; 2614 :       eval_all(constr->formula,get_coord(v_id),SDIM,
; 2615 :             &dummy, grads[oncount],v_id);

	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR _dymem
	push	edi
	push	ecx
	mov	ecx, DWORD PTR _web+616
	lea	edx, DWORD PTR _dummy$[ebp]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _web+12
	and	eax, 1073741823				; 3fffffffH
	mov	edx, edi
	imul	eax, 176				; 000000b0H
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+104
	add	edx, DWORD PTR [ecx+ebx+64]
	push	edx
	mov	edx, DWORD PTR _web+652
	mov	eax, DWORD PTR [eax+edx+40]
	push	eax
	call	_eval_all

; 2616 :       oncount++;

	mov	ecx, DWORD PTR _oncount$[ebp]
	mov	ebx, DWORD PTR _grads$[ebp]
	mov	edx, DWORD PTR _conmap$[ebp]
	add	esp, 24					; 00000018H
	inc	ecx
	mov	DWORD PTR _oncount$[ebp], ecx
$LN27@project_ve:

; 2609 :   { /* calculate projection matrix to fewer degrees of freedom */
; 2610 :     for ( j = 1; j <= (int)conmap[0] ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR [edx]
	jle	$LL28@project_ve

; 2617 :     }
; 2618 :     if ( oncount > 0 )

	test	ecx, ecx
	jle	$LN58@project_ve

; 2619 :     {
; 2620 :       /* project basis to constraints */
; 2621 :       oncount = gram_schmidt(grads,oncount,SDIM);

	mov	edx, DWORD PTR _web+616
	push	edx
	push	ecx
	push	ebx
	call	_gram_schmidt

; 2622 : 
; 2623 :       mat_mul_tr(grads,normals,qq,oncount,SDIM,normcount);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _qq$[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR _normcount$GSCopy$[ebp]
	push	eax
	push	ecx
	push	edi
	push	edx
	push	esi
	push	ebx
	call	_mat_mul_tr

; 2624 :       tr_mat_mul(grads,qq,pp,oncount,SDIM,normcount);

	mov	eax, DWORD PTR _normcount$GSCopy$[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _qq$[ebp]
	push	eax
	push	ecx
	push	edi
	mov	edi, DWORD PTR _pp$[ebp]
	push	edi
	push	edx
	push	ebx
	call	_tr_mat_mul

; 2625 :       for ( j = 0 ; j < normcount ; j++ )

	xor	esi, esi
	add	esp, 60					; 0000003cH
	cmp	DWORD PTR _normcount$GSCopy$[ebp], esi
	jle	SHORT $LN53@project_ve
	mov	ecx, DWORD PTR _web+616
	npad	7
$LL23@project_ve:

; 2626 :         for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN22@project_ve

; 2625 :       for ( j = 0 ; j < normcount ; j++ )

	mov	eax, DWORD PTR _normals$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	npad	1
$LL20@project_ve:

; 2627 :            normals[j][i] -= pp[i][j];

	mov	ecx, DWORD PTR [edi+edx*4]
	fld	QWORD PTR [eax]
	fsub	QWORD PTR [ecx+esi*8]
	inc	edx
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LL20@project_ve
$LN22@project_ve:

; 2625 :       for ( j = 0 ; j < normcount ; j++ )

	inc	esi
	cmp	esi, DWORD PTR _normcount$GSCopy$[ebp]
	jl	SHORT $LL23@project_ve
	mov	esi, DWORD PTR _normals$GSCopy$[ebp]
	jmp	SHORT $LN21@project_ve
$LN53@project_ve:
	mov	esi, DWORD PTR _normals$GSCopy$[ebp]
$LN58@project_ve:
	mov	ecx, DWORD PTR _web+616
$LN21@project_ve:

; 2628 : 
; 2629 :     }
; 2630 :     /* orthonormalize  */
; 2631 :     for ( i = 0 ; i < normcount ; i++ )

	mov	eax, DWORD PTR _normcount$GSCopy$[ebp]
	xor	edi, edi
	test	eax, eax
	jle	$LN15@project_ve
	lea	edx, DWORD PTR [esi+eax*4-4]
	mov	DWORD PTR tv792[ebp], edx
$LL54@project_ve:

; 2632 :     { /* subtract previous components */
; 2633 :       REAL sum;
; 2634 :       for ( j = 0 ; j < i ; j++ )

	xor	ebx, ebx
	test	edi, edi
	jle	SHORT $LN12@project_ve
$LL14@project_ve:

; 2635 :       { sum = dot(normals[i],normals[j],SDIM);

	mov	eax, DWORD PTR [esi+ebx*4]
	push	ecx
	mov	ecx, DWORD PTR [esi+edi*4]
	push	eax
	push	ecx
	call	_dot

; 2636 :         for ( n = 0 ; n < SDIM ; n++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 12					; 0000000cH
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN61@project_ve
	mov	eax, DWORD PTR [esi+edi*4]
	mov	esi, DWORD PTR [esi+ebx*4]
	sub	esi, eax
$LN11@project_ve:

; 2637 :           normals[i][n] -= sum*normals[j][n];

	fld	QWORD PTR [esi+eax]
	inc	edx
	fmul	ST(0), ST(1)
	add	eax, 8
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LN11@project_ve

; 2636 :         for ( n = 0 ; n < SDIM ; n++ )

	mov	esi, DWORD PTR _normals$GSCopy$[ebp]
$LN61@project_ve:

; 2632 :     { /* subtract previous components */
; 2633 :       REAL sum;
; 2634 :       for ( j = 0 ; j < i ; j++ )

	inc	ebx

; 2636 :         for ( n = 0 ; n < SDIM ; n++ )

	fstp	ST(0)
	cmp	ebx, edi
	jl	SHORT $LL14@project_ve
$LN12@project_ve:

; 2638 :       }
; 2639 :       /* normalize */
; 2640 :       sum = dot(normals[i],normals[i],SDIM);

	mov	eax, DWORD PTR [esi+edi*4]
	push	ecx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH

; 2641 :       sum = sqrt(sum);

	call	__CIsqrt

; 2642 :       if ( sum > hessian_epsilon )

	fld	QWORD PTR _hessian_epsilon

; 2643 :          for ( n = 0 ; n < SDIM ; n++ ) normals[i][n] /= sum;

	mov	ecx, DWORD PTR _web+616
	fcomp	ST(1)
	xor	edx, edx
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN67@project_ve
	test	ecx, ecx
	jle	SHORT $LN70@project_ve

; 2628 : 
; 2629 :     }
; 2630 :     /* orthonormalize  */
; 2631 :     for ( i = 0 ; i < normcount ; i++ )

	mov	eax, DWORD PTR [esi+edi*4]
$LN7@project_ve:

; 2643 :          for ( n = 0 ; n < SDIM ; n++ ) normals[i][n] /= sum;

	fld	QWORD PTR [eax]
	inc	edx
	fdiv	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR _web+616
	cmp	edx, ecx
	jl	SHORT $LN7@project_ve
$LN70@project_ve:

; 2648 :         i--;

	fstp	ST(0)
$LN16@project_ve:

; 2628 : 
; 2629 :     }
; 2630 :     /* orthonormalize  */
; 2631 :     for ( i = 0 ; i < normcount ; i++ )

	inc	edi
	cmp	edi, DWORD PTR _normcount$GSCopy$[ebp]
	jl	$LL54@project_ve
$LN51@project_ve:

; 2649 :       }
; 2650 :     }
; 2651 :   }
; 2652 :   return normcount; 

	mov	eax, DWORD PTR _normcount$GSCopy$[ebp]
$LN15@project_ve:

; 2653 : } // end project_vertex_normals()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN67@project_ve:

; 2642 :       if ( sum > hessian_epsilon )

	fstp	ST(0)

; 2644 :       else /* have to skip this direction */
; 2645 :       { for ( n = 0 ; n < SDIM ; n++ )

	test	ecx, ecx
	jle	SHORT $LN55@project_ve
	mov	ecx, DWORD PTR tv792[ebp]
	mov	eax, DWORD PTR [esi+edi*4]
	mov	ebx, DWORD PTR [ecx]
	sub	ebx, eax
$LL3@project_ve:

; 2646 :           normals[i][n] = normals[normcount-1][n];

	fld	QWORD PTR [ebx+eax]
	inc	edx
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR _web+616
	add	eax, 8
	cmp	edx, ecx
	jl	SHORT $LL3@project_ve
$LN55@project_ve:

; 2647 :         normcount--;

	dec	DWORD PTR _normcount$GSCopy$[ebp]
	sub	DWORD PTR tv792[ebp], 4

; 2648 :         i--;

	dec	edi
	jmp	SHORT $LN16@project_ve
_project_vertex_normals ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DM@MGJINCDG@Internal?5error?3?5Can?8t?5do?5get_edg@ ; `string'
PUBLIC	_get_edge_verts
;	COMDAT ??_C@_0DM@MGJINCDG@Internal?5error?3?5Can?8t?5do?5get_edg@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DM@MGJINCDG@Internal?5error?3?5Can?8t?5do?5get_edg@ DB 'Internal e'
	DB	'rror: Can''t do get_edge_verts for simplex model.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\utility.c
CONST	ENDS
;	COMDAT _get_edge_verts
_TEXT	SEGMENT
tv808 = -12						; size = 4
tv564 = -8						; size = 4
_n$90758 = -8						; size = 4
_j$ = -4						; size = 4
_e_id$ = 8						; size = 4
_verts$ = 12						; size = 4
_wraps$ = 16						; size = 4
_get_edge_verts PROC					; COMDAT

; 2768 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 2769 :   int j,k;
; 2770 :   WRAPTYPE wrap = 0;
; 2771 :   REAL *x;
; 2772 : 
; 2773 :   if ( web.representation == SIMPLEX )

	mov	esi, 3
	xor	ebx, ebx
	push	edi
	cmp	DWORD PTR _web+624, esi
	jne	SHORT $LN77@get_edge_v@2

; 2774 :      kb_error(1369,"Internal error: Can't do get_edge_verts for simplex model.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DM@MGJINCDG@Internal?5error?3?5Can?8t?5do?5get_edg@
	push	1369					; 00000559H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN77@get_edge_v@2:

; 2775 : 
; 2776 :   if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, esi
	jne	$LN41@get_edge_v@2

; 2777 :   { vertex_id *v = get_edge_vertices(e_id);

	mov	edx, DWORD PTR _e_id$[ebp]
	mov	esi, DWORD PTR _web+124
	mov	ecx, DWORD PTR _web+216
	mov	eax, edx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _dymem
	mov	edi, DWORD PTR [ecx+esi+304]

; 2778 :      int n = web.skel[EDGE].ctrlpts;

	mov	esi, DWORD PTR _web+120
	add	edi, eax
	mov	DWORD PTR _n$90758[ebp], esi

; 2779 :      if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, ebx
	je	SHORT $LN48@get_edge_v@2

; 2780 :      {
; 2781 :       wrap = get_edge_wrap(e_id);

	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+esi+784]
	mov	eax, DWORD PTR [eax+ecx]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN47@get_edge_v@2
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN47@get_edge_v@2:
	mov	ebx, eax
$LN48@get_edge_v@2:

; 2782 :      }
; 2783 :      for ( j = 0 ; j < n ; j++ )

	xor	eax, eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	DWORD PTR _n$90758[ebp], eax
	jle	$LN1@get_edge_v@2
	mov	esi, DWORD PTR _verts$[ebp]
	sub	edi, esi
	mov	DWORD PTR tv808[ebp], edi
	jmp	SHORT $LN39@get_edge_v@2
	npad	3
$LL80@get_edge_v@2:
	mov	edi, DWORD PTR tv808[ebp]
$LN39@get_edge_v@2:

; 2784 :      { x = get_coord(v[j]);

	mov	edx, DWORD PTR [edi+esi]
	mov	ecx, DWORD PTR _web+12
	mov	edi, DWORD PTR _dymem
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _web+104
	add	ecx, DWORD PTR [edx+edi+64]

; 2785 :        if ( wrap && (j > 0) && (inverted(e_id) || (j==n-1)))

	test	ebx, ebx
	je	SHORT $LN36@get_edge_v@2
	test	eax, eax
	jle	SHORT $LN36@get_edge_v@2
	test	DWORD PTR _e_id$[ebp], 134217728	; 08000000H
	jne	SHORT $LN35@get_edge_v@2
	mov	edx, DWORD PTR _n$90758[ebp]
	dec	edx
	cmp	eax, edx
	jne	SHORT $LN36@get_edge_v@2
$LN35@get_edge_v@2:

; 2786 :          (*sym_wrap)(x,verts[j],wrap);

	mov	eax, DWORD PTR [esi]
	push	ebx
	push	eax
	push	ecx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH

; 2787 :        else

	jmp	SHORT $LN81@get_edge_v@2
$LN36@get_edge_v@2:

; 2788 :        for ( k = 0 ; k < SDIM ; k++ )

	xor	edx, edx
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN38@get_edge_v@2
	mov	eax, DWORD PTR [esi]
	sub	ecx, eax
	npad	4
$LL33@get_edge_v@2:

; 2789 :          verts[j][k] = x[k];

	fld	QWORD PTR [ecx+eax]
	inc	edx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL33@get_edge_v@2
$LN81@get_edge_v@2:

; 2788 :        for ( k = 0 ; k < SDIM ; k++ )

	mov	eax, DWORD PTR _j$[ebp]
$LN38@get_edge_v@2:

; 2782 :      }
; 2783 :      for ( j = 0 ; j < n ; j++ )

	inc	eax
	add	esi, 4
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _n$90758[ebp]
	jl	SHORT $LL80@get_edge_v@2
	pop	edi
	pop	esi
	pop	ebx

; 2830 :     }
; 2831 : } // end get_edge_verts()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@get_edge_v@2:

; 2790 :      }
; 2791 :      return;
; 2792 :   }
; 2793 : 
; 2794 :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, ebx
	je	$LN30@get_edge_v@2

; 2795 :     {
; 2796 :       x = get_coord(get_edge_tailv(e_id));

	mov	ebx, DWORD PTR _e_id$[ebp]
	push	ebx
	call	_get_edge_tailv
	mov	ecx, DWORD PTR _web+12
	mov	edi, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	add	ecx, DWORD PTR [edx+edi+64]

; 2797 :       for ( j = 0 ; j < SDIM ; j++ ) verts[0][j] = x[j];

	xor	eax, eax
	add	esp, 4
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN27@get_edge_v@2
$LL29@get_edge_v@2:
	mov	edx, DWORD PTR _verts$[ebp]
	fld	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR [edx]
	fstp	QWORD PTR [edx+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL29@get_edge_v@2
	mov	edi, DWORD PTR _dymem
$LN27@get_edge_v@2:

; 2798 :       wrap = get_edge_wrap(e_id);

	mov	eax, DWORD PTR _web+124
	mov	edx, DWORD PTR _web+216
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [edx+edi+784]
	mov	ecx, DWORD PTR [ecx+eax]
	mov	eax, ebx
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv564[ebp], eax
	je	SHORT $LN51@get_edge_v@2
	push	ecx
	call	DWORD PTR _sym_inverse
	mov	edi, DWORD PTR _dymem
	mov	ebx, eax
	mov	eax, DWORD PTR tv564[ebp]
	add	esp, 4
	jmp	SHORT $LN52@get_edge_v@2
$LN51@get_edge_v@2:
	mov	ebx, ecx
$LN52@get_edge_v@2:

; 2799 :       if ( (web.modeltype == QUADRATIC) && verts[2] ) 

	cmp	DWORD PTR _web+628, 2
	mov	edx, DWORD PTR _verts$[ebp]
	jne	$LN26@get_edge_v@2
	cmp	DWORD PTR [edx+8], 0
	je	$LN26@get_edge_v@2

; 2800 :       { if ( wraps ){wraps[0] = 0;  wraps[2] = wrap; }

	mov	eax, DWORD PTR _wraps$[ebp]
	test	eax, eax
	je	SHORT $LN25@get_edge_v@2
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+8], ebx
	mov	edi, DWORD PTR _dymem
$LN25@get_edge_v@2:

; 2801 :          x = get_coord(get_edge_headv(e_id));
; 2802 :          (*sym_wrap)(x,verts[2],wrap);

	mov	ecx, DWORD PTR [edx+8]
	mov	edx, DWORD PTR _e_id$[ebp]
	push	ebx
	push	ecx
	push	edx
	call	_get_edge_headv
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	edx, DWORD PTR [eax+edi+64]
	add	esp, 4
	push	edx
	call	DWORD PTR _sym_wrap

; 2803 :          x = get_coord(get_edge_midv(e_id));

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	edx, DWORD PTR [edx+eax+8]
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+104
	add	eax, DWORD PTR [edx+ecx+64]
	add	esp, 12					; 0000000cH

; 2804 :          if ( inverted(e_id) )

	cmp	DWORD PTR tv564[ebp], 0
	je	SHORT $LN24@get_edge_v@2

; 2805 :          { if ( wraps ) wraps[1] = wrap;

	mov	ecx, DWORD PTR _wraps$[ebp]
	test	ecx, ecx
	je	SHORT $LN23@get_edge_v@2
	mov	DWORD PTR [ecx+4], ebx
$LN23@get_edge_v@2:

; 2806 :            (*sym_wrap)(x,verts[1],wrap);

	mov	ecx, DWORD PTR _verts$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	ebx
	push	edx
	push	eax
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2830 :     }
; 2831 : } // end get_edge_verts()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@get_edge_v@2:

; 2807 :          }
; 2808 :          else
; 2809 :          { for ( j = 0 ; j < SDIM ; j++ ) verts[1][j] = x[j];

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN19@get_edge_v@2
$LL21@get_edge_v@2:
	mov	edx, DWORD PTR _verts$[ebp]
	fld	QWORD PTR [eax+ecx*8]
	mov	edx, DWORD PTR [edx+4]
	fstp	QWORD PTR [edx+ecx*8]
	inc	ecx
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL21@get_edge_v@2
$LN19@get_edge_v@2:

; 2810 :            if ( wraps ) wraps[1] = 0;

	mov	eax, DWORD PTR _wraps$[ebp]
	test	eax, eax
	je	$LN1@get_edge_v@2
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+4], 0
	pop	ebx

; 2830 :     }
; 2831 : } // end get_edge_verts()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@get_edge_v@2:

; 2811 :          }
; 2812 :       } 
; 2813 :       else
; 2814 :       { if ( wraps ){wraps[0] = 0;  wraps[1] = wrap; }

	mov	ecx, DWORD PTR _wraps$[ebp]
	test	ecx, ecx
	je	SHORT $LN16@get_edge_v@2
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], ebx
	mov	edi, DWORD PTR _dymem
$LN16@get_edge_v@2:

; 2815 :          x = get_coord(get_edge_headv(e_id));

	test	eax, eax
	je	SHORT $LN54@get_edge_v@2
	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edi+304]
	mov	eax, DWORD PTR [ecx+eax]
	jmp	SHORT $LN53@get_edge_v@2
$LN54@get_edge_v@2:
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR _web+216
	add	eax, DWORD PTR [ecx+edi+304]
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ecx*4]
$LN53@get_edge_v@2:

; 2816 :          (*sym_wrap)(x,verts[1],wrap);

	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _web+12
	push	ebx
	push	edx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	edx, DWORD PTR [eax+edi+64]
	push	edx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2830 :     }
; 2831 : } // end get_edge_verts()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@get_edge_v@2:

; 2817 :       }
; 2818 :     }
; 2819 :   else
; 2820 :     { x = get_coord(get_edge_tailv(e_id));

	mov	esi, DWORD PTR _e_id$[ebp]
	push	esi
	call	_get_edge_tailv
	mov	ecx, DWORD PTR _web+12

; 2821 :       for ( j = 0 ; j < SDIM ; j++ ) verts[0][j] = x[j];

	mov	edi, DWORD PTR _web+616
	mov	ebx, DWORD PTR _verts$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	add	edx, DWORD PTR [ecx+eax+64]
	add	esp, 4
	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN12@get_edge_v@2
	npad	4
$LL14@get_edge_v@2:
	fld	QWORD PTR [edx+ecx*8]
	mov	eax, DWORD PTR [ebx]
	fstp	QWORD PTR [eax+ecx*8]
	mov	edi, DWORD PTR _web+616
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LL14@get_edge_v@2
	mov	eax, DWORD PTR _dymem
$LN12@get_edge_v@2:

; 2822 :       x = get_coord(get_edge_headv(e_id));

	test	esi, 134217728				; 08000000H
	je	SHORT $LN58@get_edge_v@2
	mov	ecx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+eax+304]
	mov	ecx, DWORD PTR [edx+ecx]
	jmp	SHORT $LN57@get_edge_v@2
$LN58@get_edge_v@2:
	mov	edx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+edx]
	mov	edx, DWORD PTR _web+216
	add	ecx, DWORD PTR [edx+eax+304]
	mov	edx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [ecx+edx*4]
$LN57@get_edge_v@2:
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+104
	add	edx, DWORD PTR [ecx+eax+64]

; 2823 :       if ( (web.modeltype == QUADRATIC) && verts[2] ) 

	cmp	DWORD PTR _web+628, 2
	jne	$LN79@get_edge_v@2
	cmp	DWORD PTR [ebx+8], 0
	je	SHORT $LN79@get_edge_v@2

; 2824 :       { for ( j = 0 ; j < SDIM ; j++ ) verts[2][j] = x[j];

	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN8@get_edge_v@2
$LL10@get_edge_v@2:
	fld	QWORD PTR [edx+ecx*8]
	mov	eax, DWORD PTR [ebx+8]
	fstp	QWORD PTR [eax+ecx*8]
	mov	edi, DWORD PTR _web+616
	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LL10@get_edge_v@2
	mov	eax, DWORD PTR _dymem
$LN8@get_edge_v@2:

; 2825 :         x = get_coord(get_edge_midv(e_id));

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+eax+304]
	mov	edx, DWORD PTR [edx+ecx+8]
	mov	ecx, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _web+104
	add	ecx, DWORD PTR [edx+eax+64]

; 2826 :         for ( j = 0 ; j < SDIM ; j++ ) verts[1][j] = x[j];

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN1@get_edge_v@2
$LL7@get_edge_v@2:
	fld	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR [ebx+4]
	fstp	QWORD PTR [edx+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL7@get_edge_v@2
	pop	edi
	pop	esi
	pop	ebx

; 2830 :     }
; 2831 : } // end get_edge_verts()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN79@get_edge_v@2:

; 2827 :       }
; 2828 :       else
; 2829 :        for ( j = 0 ; j < SDIM ; j++ ) verts[1][j] = x[j];

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN1@get_edge_v@2
$LL3@get_edge_v@2:
	fld	QWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR [ebx+4]
	fstp	QWORD PTR [ecx+eax*8]
	inc	eax
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL3@get_edge_v@2
$LN1@get_edge_v@2:
	pop	edi
	pop	esi
	pop	ebx

; 2830 :     }
; 2831 : } // end get_edge_verts()

	mov	esp, ebp
	pop	ebp
	ret	0
_get_edge_verts ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@BEIKMDJG@No?5quadratic?5model?5with?5simplice@ ; `string'
PUBLIC	_get_facet_verts_q
EXTRN	_sym_compose:DWORD
;	COMDAT ??_C@_0CE@BEIKMDJG@No?5quadratic?5model?5with?5simplice@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CE@BEIKMDJG@No?5quadratic?5model?5with?5simplice@ DB 'No quadratic'
	DB	' model with simplices.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\utility.c
CONST	ENDS
;	COMDAT _get_facet_verts_q
_TEXT	SEGMENT
tv636 = -16						; size = 4
_ii$ = -12						; size = 4
_jj$91085 = -8						; size = 4
_wrap$ = -4						; size = 4
_i$ = -4						; size = 4
_fe$ = 8						; size = 4
_f_id$ = 8						; size = 4
_verts$ = 12						; size = 4
_wraps$ = 16						; size = 4
_get_facet_verts_q PROC					; COMDAT

; 3059 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3060 :   facetedge_id fe;
; 3061 :   int i,j,ii;
; 3062 :   WRAPTYPE wrap,fewrap;
; 3063 :   REAL *x;
; 3064 : 
; 3065 :   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN20@get_facet_@4

; 3066 :     { kb_error(1370,"No quadratic model with simplices.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CE@BEIKMDJG@No?5quadratic?5model?5with?5simplice@
	push	1370					; 0000055aH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN20@get_facet_@4:

; 3067 : 
; 3068 :     }
; 3069 : 
; 3070 :   fe = get_facet_fe(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	ebx
	push	esi
	push	edi
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN24@get_facet_@4
	xor	edi, edi
	mov	DWORD PTR _fe$[ebp], edi
	jmp	SHORT $LN25@get_facet_@4
$LN24@get_facet_@4:
	mov	edx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN23@get_facet_@4
	xor	ecx, 134217728				; 08000000H
$LN23@get_facet_@4:
	mov	DWORD PTR _fe$[ebp], ecx
	mov	edi, ecx
$LN25@get_facet_@4:

; 3071 :   if ( web.symmetry_flag )

	xor	eax, eax

; 3072 :   {
; 3073 :     i = 0;
; 3074 :     wrap = 0;

	mov	DWORD PTR _wrap$[ebp], eax
	cmp	DWORD PTR _web+856, eax
	je	$LN19@get_facet_@4

; 3075 :     for ( ii = 0 ; ii < FACET_VERTS ; ii++ )

	mov	ecx, DWORD PTR _web+460
	mov	DWORD PTR _ii$[ebp], eax
	jmp	SHORT $LN18@get_facet_@4
	npad	7
$LL69@get_facet_@4:
	mov	edi, DWORD PTR _fe$[ebp]
$LN18@get_facet_@4:

; 3076 :     { int jj = (i+ii)%FACET_VERTS;

	cdq
	mov	esi, 3
	idiv	esi

; 3077 :       x = get_coord(get_fe_tailv(fe));

	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _web+124
	mov	ebx, edx
	mov	edx, edi
	and	edx, 134217728				; 08000000H
	xor	eax, edx
	mov	DWORD PTR _jj$91085[ebp], ebx
	mov	DWORD PTR tv636[ebp], edx
	test	eax, 134217728				; 08000000H
	je	SHORT $LN30@get_facet_@4
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN29@get_facet_@4
$LN30@get_facet_@4:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]
$LN29@get_facet_@4:
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+104
	add	eax, DWORD PTR [edx+ecx+64]

; 3078 :       if ( wraps ) wraps[2*jj] = wrap;

	mov	ecx, DWORD PTR _wraps$[ebp]
	test	ecx, ecx
	je	SHORT $LN75@get_facet_@4
	mov	edx, DWORD PTR _wrap$[ebp]
	mov	DWORD PTR [ecx+ebx*8], edx
$LN75@get_facet_@4:

; 3079 :       (*sym_wrap)(x,verts[2*jj],wrap);

	mov	ecx, DWORD PTR _wrap$[ebp]
	mov	edx, DWORD PTR _verts$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [edx+ebx*8]
	push	ecx
	push	eax
	call	DWORD PTR _sym_wrap

; 3080 : 
; 3081 :       x = get_coord(get_fe_midv(fe));

	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _web+124
	mov	edi, DWORD PTR _web+216
	mov	ecx, eax

; 3082 : 
; 3083 :       if ( !inverted(get_fe_edge(fe)) )

	xor	eax, DWORD PTR _fe$[ebp]
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	edi, DWORD PTR [edi+ecx+304]
	mov	edx, DWORD PTR [edx+edi+8]
	mov	edi, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR _web+104
	add	edi, DWORD PTR [edx+ecx+64]
	add	esp, 12					; 0000000cH
	test	eax, 134217728				; 08000000H
	jne	SHORT $LN73@get_facet_@4

; 3084 :       { if ( wraps ) wraps[2*jj+1] = wrap;

	mov	eax, DWORD PTR _wraps$[ebp]
	test	eax, eax
	je	SHORT $LN72@get_facet_@4
	mov	ecx, DWORD PTR _wrap$[ebp]
	mov	DWORD PTR [eax+ebx*8+4], ecx
$LN72@get_facet_@4:

; 3085 :          (*sym_wrap)(x,verts[2*jj+1],wrap);

	mov	edx, DWORD PTR _wrap$[ebp]
	mov	eax, DWORD PTR _verts$[ebp]
	mov	ecx, DWORD PTR [eax+ebx*8+4]
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR _sym_wrap
	mov	ecx, DWORD PTR _dymem
	add	esp, 12					; 0000000cH
$LN73@get_facet_@4:

; 3086 :       }
; 3087 : 
; 3088 :       fewrap = get_fe_wrap(fe);

	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+20]
	xor	eax, DWORD PTR tv636[ebp]
	mov	ebx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ebx+ecx+784]
	mov	ecx, DWORD PTR [edx+ecx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN41@get_facet_@4
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN42@get_facet_@4
$LN41@get_facet_@4:
	mov	eax, ecx
$LN42@get_facet_@4:

; 3089 :       wrap = (*sym_compose)(wrap,fewrap);

	mov	edx, DWORD PTR _wrap$[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose

; 3090 : 
; 3091 :       if ( inverted(get_fe_edge(fe)) )

	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [esi+ecx]
	mov	edx, DWORD PTR [edx+20]
	mov	ebx, DWORD PTR _fe$[ebp]
	xor	edx, ebx
	add	esp, 8
	mov	DWORD PTR _wrap$[ebp], eax
	test	edx, 134217728				; 08000000H
	je	SHORT $LN71@get_facet_@4

; 3092 :       { if ( wraps ) wraps[2*jj+1] = wrap;

	mov	ecx, DWORD PTR _wraps$[ebp]
	test	ecx, ecx
	je	SHORT $LN70@get_facet_@4
	mov	edx, DWORD PTR _jj$91085[ebp]
	mov	DWORD PTR [ecx+edx*8+4], eax
$LN70@get_facet_@4:

; 3093 :          (*sym_wrap)(x,verts[2*jj+1],wrap);

	mov	ecx, DWORD PTR _jj$91085[ebp]
	push	eax
	mov	eax, DWORD PTR _verts$[ebp]
	mov	edx, DWORD PTR [eax+ecx*8+4]
	push	edx
	push	edi
	call	DWORD PTR _sym_wrap
	mov	ecx, DWORD PTR _web+460
	add	esp, 12					; 0000000cH
$LN71@get_facet_@4:

; 3094 :       }
; 3095 : 
; 3096 :       fe = get_next_edge(fe);

	test	ebx, 134217728				; 08000000H
	je	SHORT $LN46@get_facet_@4
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN76@get_facet_@4
$LN46@get_facet_@4:
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+32]
$LN76@get_facet_@4:
	mov	DWORD PTR _fe$[ebp], eax
	mov	eax, DWORD PTR _ii$[ebp]
	inc	eax
	mov	DWORD PTR _ii$[ebp], eax
	cmp	eax, 3
	jl	$LL69@get_facet_@4
	pop	edi
	pop	esi
	pop	ebx

; 3107 :     }
; 3108 : } // end get_facet_verts_q()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@get_facet_@4:

; 3097 :     }
; 3098 :   }
; 3099 :   else for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	ebx, DWORD PTR _web+616
	mov	edx, DWORD PTR _dymem
	jmp	SHORT $LN9@get_facet_@4
$LL74@get_facet_@4:
	mov	edi, DWORD PTR _fe$[ebp]
$LN9@get_facet_@4:

; 3100 :     { x = get_coord(get_fe_tailv(fe));

	mov	ecx, DWORD PTR _web+460
	mov	eax, DWORD PTR _fe$[ebp]
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+ecx]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN52@get_facet_@4
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+216
	add	eax, DWORD PTR [ecx+edx+304]
	mov	ecx, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN51@get_facet_@4
$LN52@get_facet_@4:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	eax, DWORD PTR [eax+ecx]
$LN51@get_facet_@4:
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	ecx, DWORD PTR [eax+edx+64]

; 3101 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN4@get_facet_@4

; 3097 :     }
; 3098 :   }
; 3099 :   else for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	edx, DWORD PTR _verts$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [edx+eax*8]

; 3101 :       for ( j = 0 ; j < SDIM ; j++ )

	sub	ecx, eax
$LL6@get_facet_@4:

; 3102 :         verts[2*i][j] = x[j];

	fld	QWORD PTR [ecx+eax]
	inc	esi
	fstp	QWORD PTR [eax]
	mov	ebx, DWORD PTR _web+616
	add	eax, 8
	cmp	esi, ebx
	jl	SHORT $LL6@get_facet_@4

; 3101 :       for ( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR _dymem
$LN4@get_facet_@4:

; 3103 :       x = get_coord(get_fe_midv(fe));

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR [ecx+20]
	mov	esi, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR _web+216
	mov	esi, DWORD PTR [esi+edx+304]
	mov	ecx, DWORD PTR [ecx+esi+8]
	mov	esi, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR _web+104
	add	ecx, DWORD PTR [esi+edx+64]

; 3104 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN1@get_facet_@4

; 3103 :       x = get_coord(get_fe_midv(fe));

	mov	edx, DWORD PTR _verts$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [edx+eax*8+4]

; 3104 :       for ( j = 0 ; j < SDIM ; j++ )

	sub	ecx, eax
$LL3@get_facet_@4:

; 3105 :         verts[2*i+1][j] = x[j];

	fld	QWORD PTR [ecx+eax]
	inc	esi
	fstp	QWORD PTR [eax]
	mov	ebx, DWORD PTR _web+616
	add	eax, 8
	cmp	esi, ebx
	jl	SHORT $LL3@get_facet_@4

; 3104 :       for ( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+460
$LN1@get_facet_@4:

; 3106 :       fe = get_next_edge(fe);

	test	DWORD PTR _fe$[ebp], 134217728		; 08000000H
	je	SHORT $LN58@get_facet_@4
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	mov	DWORD PTR _fe$[ebp], eax
	jmp	SHORT $LN8@get_facet_@4
$LN58@get_facet_@4:
	mov	eax, DWORD PTR [edi+eax]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _fe$[ebp], ecx
$LN8@get_facet_@4:

; 3097 :     }
; 3098 :   }
; 3099 :   else for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, 3
	jl	$LL74@get_facet_@4
	pop	edi
	pop	esi
	pop	ebx

; 3107 :     }
; 3108 : } // end get_facet_verts_q()

	mov	esp, ebp
	pop	ebp
	ret	0
_get_facet_verts_q ENDP
_TEXT	ENDS
PUBLIC	??_C@_03MKIGNAJO@?4fe?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_01ICJEACDI@?$DL?$AA@			; `string'
PUBLIC	_name$GSCopy$
PUBLIC	??_C@_0M@GHGEPILI@EVOLVERPATH?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_path_open
EXTRN	_setvbuf:PROC
EXTRN	_datafilename:BYTE
EXTRN	__findclose:PROC
EXTRN	_fopen:PROC
EXTRN	_strrchr:PROC
EXTRN	_strcspn:PROC
EXTRN	__findfirst64i32:PROC
EXTRN	_getenv:PROC
;	COMDAT ??_C@_03MKIGNAJO@?4fe?$AA@
CONST	SEGMENT
??_C@_03MKIGNAJO@?4fe?$AA@ DB '.fe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01ICJEACDI@?$DL?$AA@
CONST	SEGMENT
??_C@_01ICJEACDI@?$DL?$AA@ DB ';', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GHGEPILI@EVOLVERPATH?$AA@
CONST	SEGMENT
??_C@_0M@GHGEPILI@EVOLVERPATH?$AA@ DB 'EVOLVERPATH', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _path_open
_TEXT	SEGMENT
_name$GSCopy$ = -1604					; size = 4
_fd$ = -1600						; size = 4
_finddata$91165 = -1596					; size = 296
_finddata$91142 = -1300					; size = 296
_path$ = -1004						; size = 1000
__$ArrayPad$ = -4					; size = 4
_name$ = 8						; size = 4
_mode$ = 12						; size = 4
_path_open PROC						; COMDAT

; 3121 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1604				; 00000644H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _name$[ebp]
	push	esi
	push	edi

; 3122 :   char path[PATHSIZE];
; 3123 :   size_t len;
; 3124 :   FILE *fd = NULL;
; 3125 :   char *env;
; 3126 : 
; 3127 : #ifdef MPI_EVOLVER
; 3128 :   /* use filename as format string to generate various file names */
; 3129 :   char taskpath[PATHSIZE];
; 3130 :   sprintf(taskpath,name,this_task);
; 3131 :   name = taskpath;
; 3132 : #endif
; 3133 : 
; 3134 :   env = getenv("EVOLVERPATH");

	push	OFFSET ??_C@_0M@GHGEPILI@EVOLVERPATH?$AA@
	mov	DWORD PTR _name$GSCopy$[ebp], ebx
	mov	DWORD PTR _fd$[ebp], 0
	call	_getenv

; 3135 : 
; 3136 : #if defined(WIN32) && !defined(__BORLANDC__)
; 3137 :   /* Using wildcards! */
; 3138 : 
; 3139 :   /* try given name */
; 3140 :   strncpy(path,name,sizeof(path));

	push	1000					; 000003e8H
	mov	edi, eax
	lea	eax, DWORD PTR _path$[ebp]
	push	ebx
	push	eax
	call	_strncpy

; 3141 :   for(;;)
; 3142 :   { /* try paths in EVOLVERPATH */
; 3143 :     intptr_t ret;
; 3144 :     struct _finddata_t finddata;
; 3145 : 
; 3146 :     ret = _findfirst(path,&finddata);

	lea	ecx, DWORD PTR _finddata$91142[ebp]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	call	__findfirst64i32
	mov	esi, eax
	add	esp, 24					; 00000018H

; 3147 :     if ( ret != -1 )

	cmp	esi, -1
	jne	SHORT $LN44@path_open
$LL35@path_open:

; 3160 :       break;
; 3161 :     }
; 3162 : 
; 3163 :     if ( env == NULL ) break;

	test	edi, edi
	je	$LN65@path_open

; 3164 :     len = strcspn(env,ENVPATHCHAR);

	push	OFFSET ??_C@_01ICJEACDI@?$DL?$AA@
	push	edi
	call	_strcspn
	mov	esi, eax
	add	esp, 8

; 3165 :     if ( len == 0 ) break;

	test	esi, esi
	je	$LN65@path_open

; 3166 :     strncpy(path,env,len);

	push	esi
	lea	eax, DWORD PTR _path$[ebp]
	push	edi
	push	eax
	call	_strncpy

; 3167 :     path[len] = PATHCHAR;
; 3168 :     strncpy(path+len+1,name,sizeof(path)-len-2);

	mov	ecx, 998				; 000003e6H
	sub	ecx, esi
	push	ecx
	lea	edx, DWORD PTR _path$[ebp+esi+1]
	push	ebx
	push	edx
	mov	BYTE PTR _path$[ebp+esi], 92		; 0000005cH
	call	_strncpy
	add	esp, 24					; 00000018H

; 3169 :     if ( env[len] == 0 ) env = NULL; /* end of EVOLVERPATH */

	cmp	BYTE PTR [esi+edi], 0
	jne	SHORT $LN26@path_open
	xor	edi, edi
	jmp	SHORT $LN25@path_open
$LN26@path_open:

; 3170 :     else env += len+1;

	lea	edi, DWORD PTR [esi+edi+1]
$LN25@path_open:

; 3141 :   for(;;)
; 3142 :   { /* try paths in EVOLVERPATH */
; 3143 :     intptr_t ret;
; 3144 :     struct _finddata_t finddata;
; 3145 : 
; 3146 :     ret = _findfirst(path,&finddata);

	lea	eax, DWORD PTR _finddata$91142[ebp]
	push	eax
	lea	ecx, DWORD PTR _path$[ebp]
	push	ecx
	call	__findfirst64i32
	mov	esi, eax
	add	esp, 8

; 3147 :     if ( ret != -1 )

	cmp	esi, -1
	je	SHORT $LL35@path_open
$LN44@path_open:

; 3148 :     { /* finddata.name only has filename, not path stuff */
; 3149 :       char *slash = strrchr(path,'/');

	lea	edx, DWORD PTR _path$[ebp]
	push	47					; 0000002fH
	push	edx
	call	_strrchr
	mov	edi, eax

; 3150 : 	  char *slashb = strrchr(path,'\\');

	lea	eax, DWORD PTR _path$[ebp]
	push	92					; 0000005cH
	push	eax
	call	_strrchr
	add	esp, 16					; 00000010H

; 3151 :       if ( slashb > slash )

	cmp	eax, edi
	jbe	SHORT $LN32@path_open

; 3152 : 		slash = slashb;

	mov	edi, eax
$LN32@path_open:

; 3153 :       if ( !slash && path[1] == ':' ) 

	test	edi, edi
	jne	SHORT $LN54@path_open
	cmp	BYTE PTR _path$[ebp+1], 58		; 0000003aH
	jne	SHORT $LN30@path_open

; 3154 :          slash = path+1;

	lea	edi, DWORD PTR _path$[ebp+1]
$LN54@path_open:

; 3155 :       if ( slash ) slash++;

	inc	edi
	jmp	SHORT $LN29@path_open
$LN30@path_open:

; 3156 :       else slash = path;

	lea	edi, DWORD PTR _path$[ebp]
$LN29@path_open:

; 3157 :       strncpy(slash,finddata.name,sizeof(path)-(slash-path));

	lea	ecx, DWORD PTR _path$[ebp+1000]
	sub	ecx, edi
	push	ecx
	lea	edx, DWORD PTR _finddata$91142[ebp+36]
	push	edx
	push	edi
	call	_strncpy

; 3158 :       fd = fopen(path,"r");

	lea	eax, DWORD PTR _path$[ebp]
	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	push	eax
	call	_fopen
	mov	edi, eax

; 3159 :       _findclose(ret);

	push	esi
	mov	DWORD PTR _fd$[ebp], edi
	call	__findclose
	add	esp, 24					; 00000018H

; 3171 :   } 
; 3172 :   
; 3173 :   /* try .fe extension */
; 3174 :   if ( fd == NULL)

	test	edi, edi
	jne	$LN66@path_open
$LN65@path_open:

; 3175 :   {
; 3176 :     env = getenv("EVOLVERPATH");

	push	OFFSET ??_C@_0M@GHGEPILI@EVOLVERPATH?$AA@
	call	_getenv

; 3177 :     strncpy(path,name,sizeof(path));

	mov	ecx, DWORD PTR _name$GSCopy$[ebp]
	push	1000					; 000003e8H
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	ebx, eax
	call	_strncpy

; 3178 :     strcat(path,".fe");

	lea	edi, DWORD PTR _path$[ebp]
	add	esp, 16					; 00000010H
	dec	edi
	npad	4
$LL56@path_open:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL56@path_open
	mov	eax, DWORD PTR ??_C@_03MKIGNAJO@?4fe?$AA@

; 3179 :     for ( ;; )
; 3180 :     {
; 3181 :       intptr_t ret;
; 3182 :       struct _finddata_t finddata;
; 3183 : 
; 3184 :       ret = _findfirst(path,&finddata);

	lea	ecx, DWORD PTR _finddata$91165[ebp]
	push	ecx
	lea	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	DWORD PTR [edi], eax
	call	__findfirst64i32
	mov	edi, eax
	add	esp, 8

; 3185 :       if ( ret != -1 )

	cmp	edi, -1
	jne	$LN47@path_open
$LL23@path_open:

; 3199 :         break;
; 3200 :       }
; 3201 : 
; 3202 :       /* try paths in EVOLVERPATH */
; 3203 :       if ( env == NULL ) break;

	test	ebx, ebx
	je	$LN64@path_open

; 3204 :       len = strcspn(env,ENVPATHCHAR);

	push	OFFSET ??_C@_01ICJEACDI@?$DL?$AA@
	push	ebx
	call	_strcspn
	mov	esi, eax
	add	esp, 8

; 3205 :       if ( len == 0 ) break;

	test	esi, esi
	je	$LN64@path_open

; 3206 :       strncpy(path,env,len);

	push	esi
	lea	eax, DWORD PTR _path$[ebp]
	push	ebx
	push	eax
	call	_strncpy

; 3207 :       path[len] = PATHCHAR;
; 3208 :       strncpy(path+len+1,name,sizeof(path)-len-2);

	mov	edx, DWORD PTR _name$GSCopy$[ebp]
	mov	ecx, 998				; 000003e6H
	sub	ecx, esi
	push	ecx
	push	edx
	lea	eax, DWORD PTR _path$[ebp+esi+1]
	push	eax
	mov	BYTE PTR _path$[ebp+esi], 92		; 0000005cH
	call	_strncpy

; 3209 :       strcat(path,".fe");

	lea	edi, DWORD PTR _path$[ebp]
	add	esp, 24					; 00000018H
	dec	edi
	npad	4
$LL57@path_open:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL57@path_open
	mov	ecx, DWORD PTR ??_C@_03MKIGNAJO@?4fe?$AA@
	mov	DWORD PTR [edi], ecx

; 3210 :       if ( env[len] == 0 ) env = NULL; /* end of EVOLVERPATH */

	cmp	BYTE PTR [esi+ebx], al
	jne	SHORT $LN14@path_open
	xor	ebx, ebx
	jmp	SHORT $LN13@path_open
$LN14@path_open:

; 3211 :       else env += len+1;

	lea	ebx, DWORD PTR [esi+ebx+1]
$LN13@path_open:

; 3179 :     for ( ;; )
; 3180 :     {
; 3181 :       intptr_t ret;
; 3182 :       struct _finddata_t finddata;
; 3183 : 
; 3184 :       ret = _findfirst(path,&finddata);

	lea	edx, DWORD PTR _finddata$91165[ebp]
	push	edx
	lea	eax, DWORD PTR _path$[ebp]
	push	eax
	call	__findfirst64i32
	mov	edi, eax
	add	esp, 8

; 3185 :       if ( ret != -1 )

	cmp	edi, -1
	je	$LL23@path_open
$LN47@path_open:

; 3186 :       { char *slash = strrchr(path,'/');

	lea	ecx, DWORD PTR _path$[ebp]
	push	47					; 0000002fH
	push	ecx
	call	_strrchr

; 3187 : 	    char *slashb = strrchr(path,'\\');

	lea	edx, DWORD PTR _path$[ebp]
	push	92					; 0000005cH
	push	edx
	mov	esi, eax
	call	_strrchr
	add	esp, 16					; 00000010H

; 3188 : 		if ( slashb > slash )

	cmp	eax, esi
	jbe	SHORT $LN20@path_open

; 3189 : 			slash = slashb;

	mov	esi, eax
$LN20@path_open:

; 3190 :         if ( !slash && path[1] == ':' ) 

	test	esi, esi
	jne	SHORT $LN52@path_open
	cmp	BYTE PTR _path$[ebp+1], 58		; 0000003aH
	jne	SHORT $LN18@path_open

; 3191 :          slash = path+1;

	lea	esi, DWORD PTR _path$[ebp+1]
$LN52@path_open:

; 3192 :         if ( slash ) slash++;

	inc	esi
	jmp	SHORT $LN17@path_open
$LN18@path_open:

; 3193 :         else slash = path;

	lea	esi, DWORD PTR _path$[ebp]
$LN17@path_open:

; 3194 :         strncpy(slash,finddata.name,sizeof(path)-(slash-path));

	lea	eax, DWORD PTR _path$[ebp+1000]
	sub	eax, esi
	push	eax
	lea	ecx, DWORD PTR _finddata$91165[ebp+36]
	push	ecx
	push	esi
	call	_strncpy

; 3195 :         fd = fopen(path,"r");

	lea	edx, DWORD PTR _path$[ebp]
	push	OFFSET ??_C@_01KDCPPGHE@r?$AA@
	push	edx
	call	_fopen
	mov	esi, eax

; 3196 :         _findclose(ret);

	push	edi
	mov	DWORD PTR _fd$[ebp], esi
	call	__findclose

; 3197 :         /* scrape the ".fe" off the end of the path since user didn't give it */
; 3198 :         path[strlen(path)-3] = 0;

	lea	eax, DWORD PTR _path$[ebp]
	add	esp, 24					; 00000018H
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL58@path_open:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL58@path_open
	sub	eax, edx
	mov	BYTE PTR _path$[ebp+eax-3], cl

; 3212 :     } 
; 3213 :   }
; 3214 : #elif defined(_GLOB_H)
; 3215 :   /* Using wildcards! */
; 3216 : 
; 3217 :   /* try given name */
; 3218 :   strncpy(path,name,sizeof(path));
; 3219 :   for(;;)
; 3220 :   { /* try paths in EVOLVERPATH */
; 3221 :     int ret;
; 3222 :     glob_t globdata;
; 3223 : 
; 3224 :     memset(&globdata,0,sizeof(globdata));
; 3225 :     ret = glob(path,0,NULL,&globdata);
; 3226 :     if ( ret == 0 ) /* success */
; 3227 :     { 
; 3228 :       strncpy(path,globdata.gl_pathv[0],sizeof(path));
; 3229 :       fd = fopen(path,"r");
; 3230 :       globfree(&globdata);
; 3231 :       break;
; 3232 :     }
; 3233 : 
; 3234 :     if ( env == NULL ) break;
; 3235 :     len = strcspn(env,ENVPATHCHAR);
; 3236 :     if ( len == 0 ) break;
; 3237 :     strncpy(path,env,len);
; 3238 :     path[len] = PATHCHAR;
; 3239 :     strncpy(path+len+1,name,sizeof(path)-len-2);
; 3240 :     if ( env[len] == 0 ) env = NULL; /* end of EVOLVERPATH */
; 3241 :     else env += len+1;
; 3242 :   } 
; 3243 :   
; 3244 :   /* try .fe extension */
; 3245 :   if ( fd == NULL)
; 3246 :   {
; 3247 :     env = getenv("EVOLVERPATH");
; 3248 :     strncpy(path,name,sizeof(path));
; 3249 :     strcat(path,".fe");
; 3250 :     for ( ;; )
; 3251 :     { glob_t globdata;
; 3252 :       int ret;
; 3253 : 
; 3254 :       ret = glob(path,0,NULL,&globdata);
; 3255 :       if ( ret == 0 ) /* success */
; 3256 :       { 
; 3257 :         strncpy(path,globdata.gl_pathv[0],sizeof(path));
; 3258 :         fd = fopen(path,"r");
; 3259 :         globfree(&globdata);
; 3260 :         /* scrape the ".fe" off the end of the path since user didn't give it */
; 3261 :         path[strlen(path)-3] = 0;
; 3262 :         break;
; 3263 :       }
; 3264 : 
; 3265 :       /* try paths in EVOLVERPATH */
; 3266 :       if ( env == NULL ) break;
; 3267 :       len = strcspn(env,ENVPATHCHAR);
; 3268 :       if ( len == 0 ) break;
; 3269 :       strncpy(path,env,len);
; 3270 :       path[len] = PATHCHAR;
; 3271 :       strncpy(path+len+1,name,sizeof(path)-len-2);
; 3272 :       strcat(path,".fe");
; 3273 :       if ( env[len] == 0 ) env = NULL; /* end of EVOLVERPATH */
; 3274 :       else env += len+1;
; 3275 :     } 
; 3276 :   }
; 3277 : #else
; 3278 :   /* try given name */
; 3279 :   strncpy(path,name,sizeof(path));
; 3280 :   while ( (fd = fopen(path,"r")) == NULL)
; 3281 :   { /* try paths in EVOLVERPATH */
; 3282 :     if ( env == NULL ) break;
; 3283 :     len = strcspn(env,ENVPATHCHAR);
; 3284 :     if ( len == 0 ) break;
; 3285 :     strncpy(path,env,len);
; 3286 :     path[len] = PATHCHAR;
; 3287 :     strncpy(path+len+1,name,sizeof(path)-len-2);
; 3288 :     if ( env[len] == 0 ) env = NULL; /* end of EVOLVERPATH */
; 3289 :     else env += len+1;
; 3290 :   } 
; 3291 :   
; 3292 :   /* try .fe extension */
; 3293 :   if ( fd == NULL)
; 3294 :   {
; 3295 :     env = getenv("EVOLVERPATH");
; 3296 :     strncpy(path,name,sizeof(path));
; 3297 :     strcat(path,".fe");
; 3298 :     while ( (fd = fopen(path,"r")) == NULL)
; 3299 :      { /* try paths in EVOLVERPATH */
; 3300 :         if ( env == NULL ) break;
; 3301 :         len = strcspn(env,ENVPATHCHAR);
; 3302 :         if ( len == 0 ) break;
; 3303 :         strncpy(path,env,len);
; 3304 :         path[len] = PATHCHAR;
; 3305 :         strncpy(path+len+1,name,sizeof(path)-len-2);
; 3306 :         strcat(path,".fe");
; 3307 :         if ( env[len] == 0 ) env = NULL; /* end of EVOLVERPATH */
; 3308 :         else env += len+1;
; 3309 :      } 
; 3310 :   }
; 3311 : #endif
; 3312 :  
; 3313 :   if ( fd && (mode==SETDATAFILENAME) )

	test	esi, esi
	je	$LN61@path_open
	mov	ebx, DWORD PTR _name$GSCopy$[ebp]
$LN53@path_open:
	cmp	DWORD PTR _mode$[ebp], 1
	jne	$LN12@path_open

; 3314 :   { /* has to be set so repeat open works */
; 3315 :     /* copy from end, getting same number of directories */
; 3316 :     char *found; /* from findfile() */
; 3317 :     char *user; /* user input search string */
; 3318 : 
; 3319 :     found = path + strlen(path) - 1;

	lea	eax, DWORD PTR _path$[ebp]
	lea	edx, DWORD PTR [eax+1]
$LL59@path_open:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL59@path_open
	sub	eax, edx
	lea	edx, DWORD PTR _path$[ebp+eax-1]

; 3320 :     user  = name + strlen(name) - 1;

	mov	eax, ebx
	lea	esi, DWORD PTR [eax+1]
$LL60@path_open:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL60@path_open
	sub	eax, esi
	lea	eax, DWORD PTR [eax+ebx-1]

; 3321 :     while ( user >= name )

	cmp	eax, ebx
	jb	SHORT $LN3@path_open
$LL11@path_open:

; 3322 :     { while ( (*user != PATHCHAR) && (*user != '\\') && (user >= name) )

	mov	cl, BYTE PTR [eax]
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN43@path_open
$LN69@path_open:
	cmp	eax, ebx
	jb	SHORT $LN43@path_open
	mov	cl, BYTE PTR [eax-1]

; 3323 :          user--;

	dec	eax
	cmp	cl, 92					; 0000005cH
	jne	SHORT $LN69@path_open
$LN43@path_open:

; 3324 :       while ( (*found != PATHCHAR) && (*found != '\\') && (found >= path) )

	mov	cl, BYTE PTR [edx]
	cmp	cl, 92					; 0000005cH
	je	SHORT $LN6@path_open
$LN71@path_open:
	lea	ecx, DWORD PTR _path$[ebp]
	cmp	edx, ecx
	jb	SHORT $LN6@path_open
	mov	cl, BYTE PTR [edx-1]

; 3325 :          found--;

	dec	edx
	cmp	cl, 92					; 0000005cH
	jne	SHORT $LN71@path_open
$LN6@path_open:

; 3326 :       if ( user >= name ) user--; else break;

	cmp	eax, ebx
	jb	SHORT $LN3@path_open

; 3327 :       if ( found >= path ) found--; else break;

	lea	ecx, DWORD PTR _path$[ebp]
	dec	eax
	cmp	edx, ecx
	jb	SHORT $LN3@path_open
	dec	edx
	cmp	eax, ebx
	jae	SHORT $LL11@path_open
$LN3@path_open:

; 3328 :     } 
; 3329 :     strncpy(datafilename,found+1,PATHSIZE);

	push	1000					; 000003e8H
	inc	edx
	push	edx
	push	OFFSET _datafilename
	call	_strncpy
	mov	esi, DWORD PTR _fd$[ebp]
	add	esp, 12					; 0000000cH
$LN12@path_open:

; 3330 :   }
; 3331 : 
; 3332 :   if ( fd )

	test	esi, esi
	je	SHORT $LN61@path_open

; 3333 :     setvbuf(fd,NULL,_IOFBF,BUFSIZ*100);

	push	51200					; 0000c800H
	push	0
	push	0
	push	esi
	call	_setvbuf
	add	esp, 16					; 00000010H
$LN61@path_open:

; 3334 : 
; 3335 :   return fd;

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 3336 : } // end path_open()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN66@path_open:

; 3212 :     } 
; 3213 :   }
; 3214 : #elif defined(_GLOB_H)
; 3215 :   /* Using wildcards! */
; 3216 : 
; 3217 :   /* try given name */
; 3218 :   strncpy(path,name,sizeof(path));
; 3219 :   for(;;)
; 3220 :   { /* try paths in EVOLVERPATH */
; 3221 :     int ret;
; 3222 :     glob_t globdata;
; 3223 : 
; 3224 :     memset(&globdata,0,sizeof(globdata));
; 3225 :     ret = glob(path,0,NULL,&globdata);
; 3226 :     if ( ret == 0 ) /* success */
; 3227 :     { 
; 3228 :       strncpy(path,globdata.gl_pathv[0],sizeof(path));
; 3229 :       fd = fopen(path,"r");
; 3230 :       globfree(&globdata);
; 3231 :       break;
; 3232 :     }
; 3233 : 
; 3234 :     if ( env == NULL ) break;
; 3235 :     len = strcspn(env,ENVPATHCHAR);
; 3236 :     if ( len == 0 ) break;
; 3237 :     strncpy(path,env,len);
; 3238 :     path[len] = PATHCHAR;
; 3239 :     strncpy(path+len+1,name,sizeof(path)-len-2);
; 3240 :     if ( env[len] == 0 ) env = NULL; /* end of EVOLVERPATH */
; 3241 :     else env += len+1;
; 3242 :   } 
; 3243 :   
; 3244 :   /* try .fe extension */
; 3245 :   if ( fd == NULL)
; 3246 :   {
; 3247 :     env = getenv("EVOLVERPATH");
; 3248 :     strncpy(path,name,sizeof(path));
; 3249 :     strcat(path,".fe");
; 3250 :     for ( ;; )
; 3251 :     { glob_t globdata;
; 3252 :       int ret;
; 3253 : 
; 3254 :       ret = glob(path,0,NULL,&globdata);
; 3255 :       if ( ret == 0 ) /* success */
; 3256 :       { 
; 3257 :         strncpy(path,globdata.gl_pathv[0],sizeof(path));
; 3258 :         fd = fopen(path,"r");
; 3259 :         globfree(&globdata);
; 3260 :         /* scrape the ".fe" off the end of the path since user didn't give it */
; 3261 :         path[strlen(path)-3] = 0;
; 3262 :         break;
; 3263 :       }
; 3264 : 
; 3265 :       /* try paths in EVOLVERPATH */
; 3266 :       if ( env == NULL ) break;
; 3267 :       len = strcspn(env,ENVPATHCHAR);
; 3268 :       if ( len == 0 ) break;
; 3269 :       strncpy(path,env,len);
; 3270 :       path[len] = PATHCHAR;
; 3271 :       strncpy(path+len+1,name,sizeof(path)-len-2);
; 3272 :       strcat(path,".fe");
; 3273 :       if ( env[len] == 0 ) env = NULL; /* end of EVOLVERPATH */
; 3274 :       else env += len+1;
; 3275 :     } 
; 3276 :   }
; 3277 : #else
; 3278 :   /* try given name */
; 3279 :   strncpy(path,name,sizeof(path));
; 3280 :   while ( (fd = fopen(path,"r")) == NULL)
; 3281 :   { /* try paths in EVOLVERPATH */
; 3282 :     if ( env == NULL ) break;
; 3283 :     len = strcspn(env,ENVPATHCHAR);
; 3284 :     if ( len == 0 ) break;
; 3285 :     strncpy(path,env,len);
; 3286 :     path[len] = PATHCHAR;
; 3287 :     strncpy(path+len+1,name,sizeof(path)-len-2);
; 3288 :     if ( env[len] == 0 ) env = NULL; /* end of EVOLVERPATH */
; 3289 :     else env += len+1;
; 3290 :   } 
; 3291 :   
; 3292 :   /* try .fe extension */
; 3293 :   if ( fd == NULL)
; 3294 :   {
; 3295 :     env = getenv("EVOLVERPATH");
; 3296 :     strncpy(path,name,sizeof(path));
; 3297 :     strcat(path,".fe");
; 3298 :     while ( (fd = fopen(path,"r")) == NULL)
; 3299 :      { /* try paths in EVOLVERPATH */
; 3300 :         if ( env == NULL ) break;
; 3301 :         len = strcspn(env,ENVPATHCHAR);
; 3302 :         if ( len == 0 ) break;
; 3303 :         strncpy(path,env,len);
; 3304 :         path[len] = PATHCHAR;
; 3305 :         strncpy(path+len+1,name,sizeof(path)-len-2);
; 3306 :         strcat(path,".fe");
; 3307 :         if ( env[len] == 0 ) env = NULL; /* end of EVOLVERPATH */
; 3308 :         else env += len+1;
; 3309 :      } 
; 3310 :   }
; 3311 : #endif
; 3312 :  
; 3313 :   if ( fd && (mode==SETDATAFILENAME) )

	mov	esi, DWORD PTR _fd$[ebp]
	jmp	$LN53@path_open
$LN64@path_open:

; 3336 : } // end path_open()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, DWORD PTR _fd$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_path_open ENDP
_TEXT	ENDS
PUBLIC	_calc_view_transform_gens
EXTRN	_set_view_transform_generators_global:PROC
EXTRN	_view_transform_gens:DWORD
EXTRN	_eval:PROC
EXTRN	_view_transform_gens_expr:DWORD
EXTRN	_transform_gen_count:DWORD
; Function compile flags: /Ogtp
;	COMDAT _calc_view_transform_gens
_TEXT	SEGMENT
_change$ = -16						; size = 4
_nmax$ = -12						; size = 4
tv262 = -8						; size = 4
_n$ = -4						; size = 4
_calc_view_transform_gens PROC				; COMDAT

; 3348 : { int n,i,j,nmax;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3349 :   REAL value;
; 3350 :   int change = 0;
; 3351 : 
; 3352 :   nmax = web.torus_flag ? transform_gen_count - SDIM : transform_gen_count;

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _transform_gen_count
	xor	edx, edx
	mov	DWORD PTR _change$[ebp], edx
	cmp	DWORD PTR _web+860, edx
	je	SHORT $LN13@calc_view_
	sub	ecx, eax
$LN13@calc_view_:
	mov	DWORD PTR _nmax$[ebp], ecx

; 3353 :   for ( n = 0 ; n < nmax ; n++ )

	mov	DWORD PTR _n$[ebp], edx
	cmp	ecx, edx
	jle	$LN8@calc_view_
	push	ebx
	push	esi
	mov	DWORD PTR tv262[ebp], edx
	push	edi
$LL24@calc_view_:

; 3354 :     for ( i = 0 ; i <= SDIM ; i++ )

	xor	ebx, ebx
	test	eax, eax
	js	SHORT $LN9@calc_view_
	npad	6
$LL23@calc_view_:

; 3355 :       for ( j = 0 ; j <= SDIM ; j++ )

	xor	esi, esi
	test	eax, eax
	js	SHORT $LN6@calc_view_
	mov	edi, DWORD PTR tv262[ebp]
	add	edi, ebx
	imul	edi, 624				; 00000270H
$LL21@calc_view_:

; 3356 :       { value = eval(&view_transform_gens_expr[n][i][j],NULL,NULLID,NULL);

	mov	eax, DWORD PTR _view_transform_gens_expr
	push	0
	push	0
	lea	ecx, DWORD PTR [edi+eax]
	push	0
	push	ecx
	call	_eval

; 3357 :         if ( value != view_transform_gens[n][i][j] ) 

	fld	ST(0)
	mov	edx, DWORD PTR _view_transform_gens
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+ebx*4]
	fld	QWORD PTR [edx+esi*8]
	lea	ecx, DWORD PTR [edx+esi*8]
	fucompp
	add	esp, 16					; 00000010H
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN26@calc_view_

; 3358 :         { view_transform_gens[n][i][j] = value;

	fstp	QWORD PTR [ecx]

; 3359 :           change = 1;

	mov	DWORD PTR _change$[ebp], 1
	jmp	SHORT $LN3@calc_view_
$LN26@calc_view_:
	fstp	ST(0)
$LN3@calc_view_:

; 3355 :       for ( j = 0 ; j <= SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	inc	esi
	add	edi, 104				; 00000068H
	cmp	esi, eax
	jle	SHORT $LL21@calc_view_
$LN6@calc_view_:

; 3354 :     for ( i = 0 ; i <= SDIM ; i++ )

	inc	ebx
	cmp	ebx, eax
	jle	SHORT $LL23@calc_view_
$LN9@calc_view_:

; 3353 :   for ( n = 0 ; n < nmax ; n++ )

	mov	ecx, DWORD PTR _n$[ebp]
	add	DWORD PTR tv262[ebp], 6
	inc	ecx
	mov	DWORD PTR _n$[ebp], ecx
	cmp	ecx, DWORD PTR _nmax$[ebp]
	jl	$LL24@calc_view_
	pop	edi
	pop	esi
	pop	ebx
$LN8@calc_view_:

; 3360 :         }
; 3361 :       } 
; 3362 :  set_view_transform_generators_global();

	call	_set_view_transform_generators_global

; 3363 :  return change;

	mov	eax, DWORD PTR _change$[ebp]

; 3364 : } // end calc_view_transform_gens()

	mov	esp, ebp
	pop	ebp
	ret	0
_calc_view_transform_gens ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@GJIJLJIB@Degenerate?5display?5periods?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@OGBKLKNM@Degenerate?5torus?5unit?5cell?4?6?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_calc_periods
EXTRN	_transform_gen_expr:PROC
EXTRN	_transform_expr:BYTE
EXTRN	_matcopy:PROC
EXTRN	_identmat:DWORD
EXTRN	_transform_gen_swap:DWORD
EXTRN	_kb_dmatrix3:PROC
EXTRN	_set_body_fixvol:PROC
EXTRN	_set_body_volume:PROC
EXTRN	_torus_display_period_expr:BYTE
EXTRN	_det_adjoint:PROC
EXTRN	_torus_period_expr:BYTE
;	COMDAT ??_C@_0BN@GJIJLJIB@Degenerate?5display?5periods?4?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0BN@GJIJLJIB@Degenerate?5display?5periods?4?6?$AA@ DB 'Degenerate d'
	DB	'isplay periods.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OGBKLKNM@Degenerate?5torus?5unit?5cell?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@OGBKLKNM@Degenerate?5torus?5unit?5cell?4?6?$AA@ DB 'Degenerate '
	DB	'torus unit cell.', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\utility.c
CONST	ENDS
;	COMDAT _calc_periods
_TEXT	SEGMENT
_invperqXvS$ = -340					; size = 24
_old_torusv$ = -316					; size = 8
_value$ = -308						; size = 8
_invper$ = -304						; size = 4
_det$91246 = -300					; size = 8
tv1071 = -296						; size = 4
tv969 = -296						; size = 4
tv807 = -296						; size = 4
tv585 = -296						; size = 4
_invperxJ$ = -292					; size = 288
__$ArrayPad$ = -4					; size = 4
_mode$ = 8						; size = 4
_calc_periods PROC					; COMDAT

; 3374 : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3375 :   REAL value;
; 3376 :   REAL old_torusv = web.torusv;

	fld	QWORD PTR _web+1600
	push	ebx
	push	esi
	fstp	QWORD PTR _old_torusv$[ebp]
	push	edi

; 3377 :   MAT2D(invper,MAXCOORD,MAXCOORD); /* so don't have temporary bad values

	push	6
	push	6
	lea	eax, DWORD PTR _invperxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _invperqXvS$[ebp]
	push	ecx
	call	_mat2d_setup
	add	esp, 16					; 00000010H

; 3378 :       in web.inverse_periods since graphgen() may be using it */
; 3379 :   int k;
; 3380 : 
; 3381 :   if ( torus_period_expr[0][0].start )

	cmp	DWORD PTR _torus_period_expr, 0
	mov	ebx, eax
	mov	DWORD PTR _invper$[ebp], ebx
	je	$LN89@calc_perio

; 3382 :   { for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN44@calc_perio
	mov	DWORD PTR tv807[ebp], OFFSET _torus_period_expr
$LL100@calc_perio:

; 3383 :     { for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN45@calc_perio
	mov	ebx, DWORD PTR tv807[ebp]
$LL43@calc_perio:

; 3384 :       { value = eval(&torus_period_expr[i][j],NULL,NULLID,NULL);

	push	0
	push	0
	push	0
	push	ebx
	call	_eval

; 3385 :         invper[j][i] = web.torus_period[i][j] = value;

	mov	edx, DWORD PTR _web+1608
	mov	eax, DWORD PTR [edx+edi*4]
	mov	ecx, DWORD PTR _invper$[ebp]
	fst	QWORD PTR [eax+esi*8]
	mov	edx, DWORD PTR [ecx+esi*4]
	fstp	QWORD PTR [edx+edi*8]
	mov	eax, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	add	ebx, 104				; 00000068H
	cmp	esi, eax
	jl	SHORT $LL43@calc_perio

; 3383 :     { for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, ecx
$LN45@calc_perio:

; 3382 :   { for ( i = 0 ; i < SDIM ; i++ )

	add	DWORD PTR tv807[ebp], 624		; 00000270H
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL100@calc_perio
$LN44@calc_perio:

; 3386 :       }
; 3387 :     }
; 3388 :     web.torusv = det_adjoint(invper,SDIM);

	push	eax
	push	ebx
	call	_det_adjoint
	fst	QWORD PTR _web+1600

; 3389 :     if ( web.torusv == 0.0 )

	fldz
	add	esp, 8
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN97@calc_perio

; 3390 :       kb_error(1377,"Degenerate torus unit cell.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BN@OGBKLKNM@Degenerate?5torus?5unit?5cell?4?6?$AA@
	push	1377					; 00000561H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN97@calc_perio:

; 3391 :     for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN94@calc_perio
$LL103@calc_perio:

; 3392 :      for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN38@calc_perio
	mov	esi, DWORD PTR [ebx+edx*4]
	npad	5
$LL88@calc_perio:

; 3393 :      { web.inverse_periods[i][j] = invper[i][j]/web.torusv;

	fld	QWORD PTR [esi+eax*8]
	mov	ecx, DWORD PTR _web+1612
	fdiv	QWORD PTR _web+1600
	mov	ecx, DWORD PTR [ecx+edx*4]
	inc	eax
	fstp	QWORD PTR [ecx+eax*8-8]

; 3394 :        web.inverse_periods_tr[j][i] = invper[i][j]/web.torusv;

	fld	QWORD PTR [esi+eax*8-8]
	fdiv	QWORD PTR _web+1600
	mov	ecx, DWORD PTR _web+1616
	mov	ecx, DWORD PTR [ecx+eax*4-4]
	fstp	QWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LL88@calc_perio
$LN38@calc_perio:

; 3391 :     for ( i = 0 ; i < SDIM ; i++ )

	inc	edx
	cmp	edx, ecx
	jl	SHORT $LL103@calc_perio
	jmp	SHORT $LN94@calc_perio
$LN89@calc_perio:
	mov	ecx, DWORD PTR _web+616
$LN94@calc_perio:

; 3395 :      }
; 3396 :   }
; 3397 : 
; 3398 :   if ( web.torus_display_period )

	cmp	DWORD PTR _web+1620, 0
	je	$LN90@calc_perio

; 3399 :   { REAL det;
; 3400 :     for ( i = 0 ; i < SDIM ; i++ )

	xor	edi, edi
	test	ecx, ecx
	jle	SHORT $LN30@calc_perio
	mov	DWORD PTR tv969[ebp], OFFSET _torus_display_period_expr
$LL101@calc_perio:

; 3401 :     { for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	ecx, ecx
	jle	SHORT $LN31@calc_perio
	mov	ebx, DWORD PTR tv969[ebp]
	npad	2
$LL29@calc_perio:

; 3402 :       { value = eval(&torus_display_period_expr[i][j],NULL,NULLID,NULL);

	push	0
	push	0
	push	0
	push	ebx
	call	_eval

; 3403 :         invper[j][i] = web.torus_display_period[i][j] = value;

	mov	edx, DWORD PTR _web+1620
	mov	ecx, DWORD PTR _invper$[ebp]
	mov	eax, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR [ecx+esi*4]
	fst	QWORD PTR [eax+esi*8]
	fstp	QWORD PTR [edx+edi*8]
	mov	ecx, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	add	ebx, 104				; 00000068H
	cmp	esi, ecx
	jl	SHORT $LL29@calc_perio

; 3401 :     { for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _invper$[ebp]
$LN31@calc_perio:

; 3399 :   { REAL det;
; 3400 :     for ( i = 0 ; i < SDIM ; i++ )

	add	DWORD PTR tv969[ebp], 624		; 00000270H
	inc	edi
	cmp	edi, ecx
	jl	SHORT $LL101@calc_perio
$LN30@calc_perio:

; 3404 :       }
; 3405 :     }
; 3406 :     det = det_adjoint(invper,SDIM);

	push	ecx
	push	ebx
	call	_det_adjoint
	fst	QWORD PTR _det$91246[ebp]

; 3407 :     if ( det == 0.0 )

	fld	ST(0)
	add	esp, 8
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN102@calc_perio

; 3408 :       kb_error(3377,"Degenerate display periods.\n",RECOVERABLE);

	push	1
	fstp	ST(0)
	push	OFFSET ??_C@_0BN@GJIJLJIB@Degenerate?5display?5periods?4?6?$AA@
	push	3377					; 00000d31H
	call	_kb_error
	fld	QWORD PTR _det$91246[ebp]
	add	esp, 12					; 0000000cH
$LN102@calc_perio:

; 3409 :     for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN116@calc_perio
$LN104@calc_perio:

; 3410 :      for ( j = 0 ; j < SDIM ; j++ )

	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN24@calc_perio
	mov	esi, DWORD PTR [ebx+edx*4]
$LN22@calc_perio:

; 3411 :      { web.inverse_display_periods[i][j] = invper[i][j]/det;

	fld	QWORD PTR [esi+eax*8]
	mov	ecx, DWORD PTR _web+1672
	fdiv	ST(0), ST(1)
	mov	ecx, DWORD PTR [ecx+edx*4]
	inc	eax
	fstp	QWORD PTR [ecx+eax*8-8]
	mov	ecx, DWORD PTR _web+616
	cmp	eax, ecx
	jl	SHORT $LN22@calc_perio
$LN24@calc_perio:

; 3409 :     for ( i = 0 ; i < SDIM ; i++ )

	inc	edx
	cmp	edx, ecx
	jl	SHORT $LN104@calc_perio
$LN116@calc_perio:

; 3410 :      for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
$LN90@calc_perio:

; 3412 :     }
; 3413 :   }
; 3414 : 
; 3415 : 
; 3416 :   /* if change in periods, adjust volumes and volconsts */
; 3417 :   if ( (mode == ADJUST_VOLUMES) && (old_torusv != 0.0) && !web.pressure_flag)

	cmp	DWORD PTR _mode$[ebp], 1
	jne	$LN98@calc_perio
	fld	QWORD PTR _old_torusv$[ebp]
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN124@calc_perio
	cmp	DWORD PTR _web+868, 0
	jne	$LN124@calc_perio

; 3418 :   { body_id b_id;
; 3419 :     value = web.torusv/old_torusv;

	fdivr	QWORD PTR _web+1600

; 3420 :     FOR_ALL_BODIES(b_id)

	mov	edi, DWORD PTR _web+384
	mov	ebx, edi
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	fst	QWORD PTR _value$[ebp]
	je	$LN124@calc_perio
	mov	ecx, DWORD PTR _web+348
$LN96@calc_perio:
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN17@calc_perio

; 3421 :     { set_body_volume(b_id,value*(get_body_volume(b_id)),SETSTAMP);

	test	ebx, ebx
	je	SHORT $LN52@calc_perio
	mov	edx, DWORD PTR [esi+ecx]
	fld	QWORD PTR [edx+40]
	jmp	SHORT $LN53@calc_perio
$LN52@calc_perio:
	fldz
$LN53@calc_perio:
	push	1
	fmulp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	call	_set_body_volume

; 3422 :       save_body_volume(b_id);

	mov	eax, DWORD PTR _web+348
	mov	eax, DWORD PTR [esi+eax]
	fld	QWORD PTR [eax+40]

; 3423 :       if ( get_battr(b_id) & FIXEDVOL )

	xor	edx, edx
	fstp	QWORD PTR [eax+288]
	mov	ecx, DWORD PTR _web+348
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 32					; 00000020H
	add	esp, 16					; 00000010H
	or	eax, edx
	je	SHORT $LN13@calc_perio

; 3424 :           set_body_fixvol(b_id,value*(get_body_fixvol(b_id)));

	test	ebx, ebx
	je	SHORT $LN56@calc_perio
	mov	ecx, DWORD PTR [esi+ecx]
	fld	QWORD PTR [ecx+32]
	jmp	SHORT $LN57@calc_perio
$LN56@calc_perio:
	fldz
$LN57@calc_perio:
	fmul	QWORD PTR _value$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	edi
	call	_set_body_fixvol
	mov	ecx, DWORD PTR _web+348
	add	esp, 12					; 0000000cH
$LN13@calc_perio:

; 3425 :       set_body_volconst(b_id,value*(get_body_volconst(b_id)));

	test	ebx, ebx
	je	SHORT $LN60@calc_perio
	mov	edx, DWORD PTR [esi+ecx]
	fld	QWORD PTR [edx+328]
	jmp	SHORT $LN61@calc_perio
$LN60@calc_perio:
	fldz
$LN61@calc_perio:
	fld	QWORD PTR _value$[ebp]
	fmul	ST(1), ST(0)
	test	ebx, ebx
	je	SHORT $LN139@calc_perio
	mov	eax, DWORD PTR [esi+ecx]
	fxch	ST(1)
	fst	QWORD PTR [eax+328]
	cmp	DWORD PTR _everything_quantities_flag, 0
	mov	ecx, DWORD PTR _web+348
	je	SHORT $LN142@calc_perio
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+404]
	mov	ecx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H
	fstp	QWORD PTR [eax+ecx+208]
	mov	ecx, DWORD PTR _web+348
	jmp	SHORT $LN62@calc_perio
$LN139@calc_perio:
	fstp	ST(1)
$LN62@calc_perio:

; 3426 :       if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN17@calc_perio

; 3427 :       { struct gen_quant *q = GEN_QUANT(get_body_volquant(b_id));

	mov	edx, DWORD PTR [esi+ecx]

; 3428 :         q->value *= value;

	fld	ST(0)
	mov	eax, DWORD PTR [edx+404]
	imul	eax, 368				; 00000170H
	add	eax, DWORD PTR _gen_quant_list
	fmul	QWORD PTR [eax+152]
	fstp	QWORD PTR [eax+152]

; 3429 :         q->target *= value;

	fld	ST(0)
	fmul	QWORD PTR [eax+144]
	fstp	QWORD PTR [eax+144]

; 3430 :         q->volconst *= value;

	fld	ST(0)
	fmul	QWORD PTR [eax+208]
	fstp	QWORD PTR [eax+208]
	mov	ecx, DWORD PTR _web+348
	jmp	SHORT $LN17@calc_perio
$LN142@calc_perio:

; 3425 :       set_body_volconst(b_id,value*(get_body_volconst(b_id)));

	fstp	ST(0)
$LN17@calc_perio:

; 3420 :     FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR [esi+ecx]
	mov	edi, DWORD PTR [eax]
	mov	ebx, edi
	shr	ebx, 28					; 0000001cH
	and	ebx, 1
	jne	$LN96@calc_perio
	mov	ecx, DWORD PTR _web+616
$LN124@calc_perio:
	fstp	ST(0)
$LN98@calc_perio:

; 3431 :       }
; 3432 :     }
; 3433 :   }
; 3434 : 
; 3435 :   /* adjust view transform generators for automatic torus symmetries */
; 3436 :   if ( web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	je	$LN1@calc_perio

; 3437 :   {
; 3438 :     if ( view_transform_gens == NULL )

	cmp	DWORD PTR _view_transform_gens, 0
	jne	SHORT $LN92@calc_perio

; 3439 :     { view_transform_gens = dmatrix3(SDIM,SDIM+1,SDIM+1);

	push	3439					; 00000d6fH
	lea	eax, DWORD PTR [ecx+1]
	push	OFFSET ??_C@_09GDMJAJJP@UTILITY?4C?$AA@
	push	eax
	push	eax
	push	ecx
	call	_kb_dmatrix3

; 3440 :       transform_gen_count = SDIM;

	mov	ecx, DWORD PTR _web+616
	add	esp, 20					; 00000014H
	mov	DWORD PTR _view_transform_gens, eax
	mov	DWORD PTR _transform_gen_count, ecx
$LN92@calc_perio:

; 3441 :     }
; 3442 :     if ( transform_gen_swap == NULL )

	cmp	DWORD PTR _transform_gen_swap, 0
	jne	SHORT $LN9@calc_perio

; 3443 :        transform_gen_swap = (int*)mycalloc(SDIM,sizeof(int));

	push	3443					; 00000d73H
	push	OFFSET ??_C@_09GDMJAJJP@UTILITY?4C?$AA@
	push	4
	push	ecx
	call	_kb_calloc
	mov	ecx, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	mov	DWORD PTR _transform_gen_swap, eax
$LN9@calc_perio:

; 3444 :     for ( j=transform_gen_count-SDIM, k=0 ; j<transform_gen_count ; k++,j++ )

	mov	eax, DWORD PTR _transform_gen_count
	mov	esi, eax
	sub	esi, ecx
	cmp	esi, eax
	jge	SHORT $LN6@calc_perio
	mov	DWORD PTR tv1071[ebp], 0
	npad	8
$LL93@calc_perio:

; 3445 :     { matcopy(view_transform_gens[j],identmat,SDIM+1, SDIM+1);

	mov	edx, DWORD PTR _view_transform_gens
	mov	eax, DWORD PTR [edx+esi*4]
	inc	ecx
	push	ecx
	push	ecx
	mov	ecx, DWORD PTR _identmat
	push	ecx
	push	eax
	call	_matcopy

; 3446 :       for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN7@calc_perio

; 3445 :     { matcopy(view_transform_gens[j],identmat,SDIM+1, SDIM+1);

	mov	edx, DWORD PTR _view_transform_gens
	mov	edx, DWORD PTR [edx+esi*4]
$LL99@calc_perio:

; 3447 :       view_transform_gens[j][i][SDIM] = web.torus_period[k][i];

	mov	edi, DWORD PTR _web+1608
	mov	ebx, DWORD PTR tv1071[ebp]
	mov	edi, DWORD PTR [ebx+edi]
	mov	ebx, DWORD PTR [edx]
	fld	QWORD PTR [edi+eax*8]
	fstp	QWORD PTR [ebx+ecx*8]
	mov	ecx, DWORD PTR _web+616
	inc	eax
	add	edx, 4
	cmp	eax, ecx
	jl	SHORT $LL99@calc_perio
$LN7@calc_perio:

; 3444 :     for ( j=transform_gen_count-SDIM, k=0 ; j<transform_gen_count ; k++,j++ )

	add	DWORD PTR tv1071[ebp], 4
	inc	esi
	cmp	esi, DWORD PTR _transform_gen_count
	jl	SHORT $LL93@calc_perio
$LN6@calc_perio:

; 3448 :     }
; 3449 :     if (transform_expr && *transform_expr)

	cmp	BYTE PTR _transform_expr, 0
	je	SHORT $LN1@calc_perio

; 3450 :       /* re-evaluate expressions */
; 3451 :       if ( calc_view_transform_gens() )  /*  see if changed */

	call	_calc_view_transform_gens
	test	eax, eax
	je	SHORT $LN1@calc_perio

; 3452 :         transform_gen_expr(transform_expr);

	push	OFFSET _transform_expr
	call	_transform_gen_expr
	add	esp, 4
$LN1@calc_perio:

; 3453 :   }
; 3454 : } // end calc_periods()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_calc_periods ENDP
_TEXT	ENDS
PUBLIC	_null_function
; Function compile flags: /Ogtp
;	COMDAT _null_function
_TEXT	SEGMENT
_null_function PROC					; COMDAT

; 3462 : void null_function() {}

	ret	0
_null_function ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DI@INFJDLDL@Internal?5error?3?5?5Using?5uninitial@ ; `string'
PUBLIC	_bad_function
;	COMDAT ??_C@_0DI@INFJDLDL@Internal?5error?3?5?5Using?5uninitial@
CONST	SEGMENT
??_C@_0DI@INFJDLDL@Internal?5error?3?5?5Using?5uninitial@ DB 'Internal er'
	DB	'ror:  Using uninitialized function pointer.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _bad_function
_TEXT	SEGMENT
_bad_function PROC					; COMDAT

; 3472 :      WARNING);

	push	2
	push	OFFSET ??_C@_0DI@INFJDLDL@Internal?5error?3?5?5Using?5uninitial@
	push	1371					; 0000055bH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 3473 : }

	ret	0
_bad_function ENDP
_TEXT	ENDS
PUBLIC	_distance
; Function compile flags: /Ogtp
;	COMDAT _distance
_TEXT	SEGMENT
tv754 = 8						; size = 4
_v1$ = 8						; size = 4
_i$ = 12						; size = 4
_v2$ = 12						; size = 4
_distance PROC						; COMDAT

; 3486 : {

	push	ebp
	mov	ebp, esp

; 3487 :   REAL *c1,*c2;
; 3488 :   REAL sum;
; 3489 :   int i;
; 3490 : 
; 3491 :   c1 = get_coord(v1);

	mov	ecx, DWORD PTR _dymem

; 3492 :   c2 = get_coord(v2);
; 3493 :   sum = 0.0;

	fldz
	mov	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	edx, DWORD PTR _v1$[ebp]
	mov	ecx, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	push	esi
	push	edi
	mov	edi, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _v2$[ebp]
	and	edx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+edx*4]

; 3494 :   for ( i = 0 ; i < SDIM ; i++ )

	mov	edx, DWORD PTR _web+616
	add	edi, eax
	add	esi, eax
	xor	ecx, ecx
	cmp	edx, 4
	jl	SHORT $LC9@distance

; 3487 :   REAL *c1,*c2;
; 3488 :   REAL sum;
; 3489 :   int i;
; 3490 : 
; 3491 :   c1 = get_coord(v1);

	push	ebx
	add	edx, -4					; fffffffcH

; 3495 :      sum += (c1[i] - c2[i])*(c1[i] - c2[i]);

	mov	ebx, edi
	sub	ebx, esi
	shr	edx, 2
	mov	DWORD PTR tv754[ebp], ebx
	inc	edx
	lea	ebx, DWORD PTR [edx*4]
	mov	DWORD PTR _i$[ebp], ebx
	mov	ebx, DWORD PTR tv754[ebp]
	lea	ecx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR [esi+8]
$LN10@distance:
	fld	QWORD PTR [ecx-24]
	add	eax, 32					; 00000020H
	fsub	QWORD PTR [eax-40]
	add	ecx, 32					; 00000020H
	dec	edx
	fld	QWORD PTR [eax+ebx-32]
	fsub	QWORD PTR [eax-32]
	fld	QWORD PTR [ecx-40]
	fsub	QWORD PTR [eax-24]
	fld	QWORD PTR [ecx-32]
	fsub	QWORD PTR [eax-16]
	fld	ST(3)
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	faddp	ST(4), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(3)
	faddp	ST(1), ST(0)
	fld	ST(2)
	fmulp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LN10@distance

; 3487 :   REAL *c1,*c2;
; 3488 :   REAL sum;
; 3489 :   int i;
; 3490 : 
; 3491 :   c1 = get_coord(v1);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _web+616
	pop	ebx
$LC9@distance:

; 3494 :   for ( i = 0 ; i < SDIM ; i++ )

	cmp	ecx, edx
	jge	SHORT $LN8@distance
	sub	edi, esi
	lea	eax, DWORD PTR [esi+ecx*8]
	sub	edx, ecx
$LC3@distance:

; 3495 :      sum += (c1[i] - c2[i])*(c1[i] - c2[i]);

	fld	QWORD PTR [eax+edi]
	add	eax, 8
	dec	edx
	fsub	QWORD PTR [eax-8]
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LC3@distance
$LN8@distance:
	pop	edi
	pop	esi

; 3497 : } // end distance()

	pop	ebp

; 3496 :   return sqrt(sum);

	jmp	__CIsqrt
_distance ENDP
_TEXT	ENDS
PUBLIC	__real@3fc999999999999a
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@4018000000000000
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	_grule
EXTRN	__CIcos:PROC
;	COMDAT __real@3fc999999999999a
CONST	SEGMENT
__real@3fc999999999999a DQ 03fc999999999999ar	; 0.2
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _grule
_TEXT	SEGMENT
_d1$ = -100						; size = 8
_v$ = -92						; size = 8
tv557 = -84						; size = 8
tv549 = -76						; size = 8
tv477 = -68						; size = 8
tv485 = -60						; size = 8
tv474 = -52						; size = 8
tv543 = -44						; size = 8
_d3pn$ = -36						; size = 8
_m$ = -28						; size = 4
tv1059 = -24						; size = 4
tv1065 = -20						; size = 4
tv1049 = -20						; size = 4
tv345 = -20						; size = 4
_d4pn$ = -16						; size = 8
tv988 = -12						; size = 4
tv979 = -12						; size = 4
tv969 = -12						; size = 4
tv960 = -12						; size = 4
tv951 = -12						; size = 4
tv776 = -12						; size = 4
tv449 = -12						; size = 4
_e1$ = -12						; size = 4
tv588 = -8						; size = 8
_u$ = -8						; size = 8
tv1005 = -4						; size = 4
_k$ = -4						; size = 4
tv1039 = 8						; size = 4
tv1034 = 8						; size = 4
tv1030 = 8						; size = 4
tv977 = 8						; size = 4
_n$ = 8							; size = 4
_x$ = 12						; size = 4
_w$ = 16						; size = 4
_grule	PROC						; COMDAT

; 3514 : {

	push	ebp
	mov	ebp, esp

; 3515 :   REAL pkm1,pk,t,t1,pkp1,den,d1,dpn,d2pn,d3pn,d4pn,u,v,h,p,dp,fx,x0;
; 3516 :   int m,e1,i,k;
; 3517 :   
; 3518 :   if ( n < -1 )

	fld1
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	push	edi
	cmp	esi, -1
	jge	SHORT $LN24@grule

; 3519 :   { /* rectangle rule */
; 3520 :     for ( k = 0 ; k < abs(n) ; k++ )

	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	xor	edi, edi
	mov	DWORD PTR _k$[ebp], edi
	mov	DWORD PTR tv449[ebp], eax
	test	eax, eax
	jle	SHORT $LN24@grule

; 3522 :          w[k] = 1/(REAL)abs(n);

	mov	ebx, DWORD PTR _x$[ebp]
	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR tv1065[ebp], ecx
	fild	DWORD PTR tv1065[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	fild	DWORD PTR tv449[ebp]
	mov	edx, ebx
	sub	edx, ecx
	fdivr	ST(0), ST(2)
$LN10@grule:

; 3519 :   { /* rectangle rule */
; 3520 :     for ( k = 0 ; k < abs(n) ; k++ )

	fild	DWORD PTR _k$[ebp]
	inc	edi
	add	ecx, 8
	mov	DWORD PTR _k$[ebp], edi

; 3521 :       { x[k] = k/(REAL)(abs(n)-1);

	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [edx+ecx-8]

; 3522 :          w[k] = 1/(REAL)abs(n);

	fst	QWORD PTR [ecx-8]
	cmp	edi, eax
	jl	SHORT $LN10@grule

; 3519 :   { /* rectangle rule */
; 3520 :     for ( k = 0 ; k < abs(n) ; k++ )

	fstp	ST(1)
	fstp	ST(0)
	jmp	SHORT $LN8@grule
$LN24@grule:
	mov	ebx, DWORD PTR _x$[ebp]
$LN8@grule:

; 3526 :   e1 = n*(n+1);
; 3527 :   for ( i = 1 ; i <= m ; i++ )

	fld	QWORD PTR __real@3fe0000000000000
	lea	ecx, DWORD PTR [esi+1]
	mov	eax, ecx
	imul	ecx, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _m$[ebp], eax
	mov	DWORD PTR _e1$[ebp], ecx
	cmp	eax, 1
	jl	$LN36@grule
	fstp	ST(0)
	lea	edx, DWORD PTR [esi*4+2]
	mov	DWORD PTR tv1049[ebp], edx
	fild	DWORD PTR tv1049[ebp]
	mov	edx, esi
	imul	edx, esi
	fstp	QWORD PTR tv474[ebp]
	fild	DWORD PTR _n$[ebp]
	fst	QWORD PTR tv477[ebp]
	fdivr	ST(0), ST(1)
	add	edx, edx
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR tv1039[ebp], edx
	mov	edx, 2
	sub	edx, ecx
	mov	edi, ebx
	lea	ebx, DWORD PTR [ebx+esi*8-8]
	mov	DWORD PTR tv345[ebp], eax
	fsubr	ST(0), ST(1)
	fild	DWORD PTR tv1039[ebp]
	mov	DWORD PTR tv1034[ebp], edx
	mov	edx, 6
	sub	edx, ecx
	fdivp	ST(1), ST(0)
	mov	ecx, DWORD PTR _w$[ebp]
	sub	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv1059[ebp], ecx
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR tv485[ebp]
	fild	DWORD PTR tv1034[ebp]
	mov	DWORD PTR tv1030[ebp], edx
	fstp	QWORD PTR tv549[ebp]
	fild	DWORD PTR tv1030[ebp]
	mov	DWORD PTR tv977[ebp], 3
	fstp	QWORD PTR tv557[ebp]
	fild	DWORD PTR _e1$[ebp]
	fstp	QWORD PTR tv543[ebp]
	jmp	SHORT $LN23@grule
$LL52@grule:

; 3523 :       }
; 3524 :   }
; 3525 :   m = (n+1)/2;

	fstp	ST(0)
$LN23@grule:

; 3528 :   {
; 3529 :     /* original calculation on [-1,1] */
; 3530 :     t = (4*i - 1)*M_PI/(4*n+2);
; 3531 :     x0 = (1 - (1 - 1.0/n)/(8*n*n))*cos(t);

	fild	DWORD PTR tv977[ebp]
	fmul	QWORD PTR __real@400921fb54442d18
	fdiv	QWORD PTR tv474[ebp]
	call	__CIcos
	fmul	QWORD PTR tv485[ebp]

; 3532 :     pkm1 = 1.0;

	fld1

; 3533 :     pk = x0;
; 3534 :     for ( k = 2 ; k <= n ; k++ )

	mov	ecx, 2
	fld	ST(0)
	mov	DWORD PTR _k$[ebp], ecx
	fld	ST(2)
	cmp	esi, ecx
	jl	$LN25@grule
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, 8
	jl	$LC21@grule

; 3538 :         pkm1 = pk;
; 3539 :         pk = pkp1;

	mov	eax, 4
	mov	DWORD PTR tv776[ebp], eax
$LN22@grule:

; 3537 :         pkp1 = t1 - pkm1 - (t1 - pkm1)/k + t1;

	fld	ST(0)
	lea	edx, DWORD PTR [eax-1]
	fmul	ST(0), ST(4)
	fld	ST(0)
	fsubrp	ST(3), ST(0)
	fild	DWORD PTR _k$[ebp]
	mov	DWORD PTR tv1005[ebp], edx

; 3538 :         pkm1 = pk;
; 3539 :         pk = pkp1;

	lea	edx, DWORD PTR [eax+1]
	fdivr	ST(0), ST(3)
	fsubp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fld	ST(1)
	fxch	ST(2)
	fmul	ST(0), ST(4)
	fld	ST(0)
	fsubrp	ST(2), ST(0)
	fild	DWORD PTR tv1005[ebp]
	fdivr	ST(0), ST(2)
	fsubp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fld	ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(4)
	fld	ST(0)
	fsubrp	ST(3), ST(0)
	fild	DWORD PTR tv776[ebp]
	mov	DWORD PTR tv988[ebp], edx
	lea	edx, DWORD PTR [eax+2]
	fdivr	ST(0), ST(3)
	fsubp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fld	ST(1)
	fxch	ST(2)
	fmul	ST(0), ST(4)
	fld	ST(0)
	fsubrp	ST(2), ST(0)
	fild	DWORD PTR tv988[ebp]
	mov	DWORD PTR tv979[ebp], edx
	lea	edx, DWORD PTR [eax+3]
	fdivr	ST(0), ST(2)
	fsubp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fld	ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(4)
	fld	ST(0)
	fsubrp	ST(3), ST(0)
	fild	DWORD PTR tv979[ebp]
	mov	DWORD PTR tv969[ebp], edx
	lea	edx, DWORD PTR [eax+4]
	fdivr	ST(0), ST(3)
	fsubp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fld	ST(1)
	fxch	ST(2)
	fmul	ST(0), ST(4)
	fld	ST(0)
	fsubrp	ST(2), ST(0)
	fild	DWORD PTR tv969[ebp]
	mov	DWORD PTR tv960[ebp], edx
	lea	edx, DWORD PTR [eax+5]
	fdivr	ST(0), ST(2)
	fsubp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fld	ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(4)
	fld	ST(0)
	fsubrp	ST(3), ST(0)
	fild	DWORD PTR tv960[ebp]
	mov	DWORD PTR tv951[ebp], edx
	fdivr	ST(0), ST(3)
	fsubp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fld	ST(1)
	fxch	ST(2)
	fmul	ST(0), ST(4)
	fld	ST(0)
	fsubrp	ST(2), ST(0)
	fild	DWORD PTR tv951[ebp]
	fdivr	ST(0), ST(2)
	fsubp	ST(2), ST(0)
	add	ecx, 8
	add	eax, 8
	lea	edx, DWORD PTR [esi-7]
	faddp	ST(1), ST(0)
	mov	DWORD PTR _k$[ebp], ecx
	mov	DWORD PTR tv776[ebp], eax
	cmp	ecx, edx
	jle	$LN22@grule
$LC21@grule:

; 3533 :     pk = x0;
; 3534 :     for ( k = 2 ; k <= n ; k++ )

	cmp	ecx, esi
	jg	SHORT $LN25@grule
$LN50@grule:

; 3535 :      {
; 3536 :         t1 = x0*pk;

	fld	ST(0)
	inc	ecx
	fmul	ST(0), ST(4)

; 3537 :         pkp1 = t1 - pkm1 - (t1 - pkm1)/k + t1;

	fld	ST(0)
	fsubrp	ST(3), ST(0)
	fild	DWORD PTR _k$[ebp]
	mov	DWORD PTR _k$[ebp], ecx
	fdivr	ST(0), ST(3)
	fsubp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	cmp	ecx, esi
	jle	SHORT $LN50@grule
$LN25@grule:

; 3540 :      }
; 3541 :     den = 1 - x0*x0;

	fld	ST(3)
	fmul	ST(0), ST(4)
	fsubp	ST(3), ST(0)

; 3542 :     d1 = n*(pkm1 - x0*pk);

	fld	ST(0)
	fmul	ST(0), ST(4)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR tv477[ebp]
	fst	QWORD PTR _d1$[ebp]

; 3543 :     dpn = d1/den;

	fdiv	ST(0), ST(2)

; 3544 :     d2pn = (2*x0*dpn - e1*pk)/den;

	fld	ST(3)
	fadd	ST(0), ST(0)
	fmul	ST(0), ST(1)
	fld	QWORD PTR tv543[ebp]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fdiv	ST(0), ST(3)

; 3545 :     d3pn = (4*x0*d2pn + (2 - e1)*dpn)/den;

	fld	ST(4)
	fmul	QWORD PTR __real@4010000000000000
	fmul	ST(0), ST(1)
	fld	QWORD PTR tv549[ebp]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fdiv	ST(0), ST(4)
	fst	QWORD PTR _d3pn$[ebp]

; 3546 :     d4pn = (6*x0*d3pn + (6 - e1)*d2pn)/den;

	fld	ST(5)
	fmul	QWORD PTR __real@4018000000000000
	fmul	ST(0), ST(1)
	fld	QWORD PTR tv557[ebp]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fdivrp	ST(5), ST(0)
	fxch	ST(4)
	fstp	QWORD PTR _d4pn$[ebp]

; 3547 :     u = pk/dpn;

	fld	ST(2)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _u$[ebp]

; 3548 :     v = d2pn/dpn;

	fld	ST(0)
	fdiv	ST(0), ST(2)
	fst	QWORD PTR _v$[ebp]

; 3549 :     h = -u*(1 + 0.5*u*(v + u*(v*v - d3pn/3/dpn)));

	fmul	ST(0), ST(0)
	fld	ST(4)
	fdiv	QWORD PTR __real@4008000000000000
	fdiv	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR _u$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR _v$[ebp]
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(2), ST(0)
	fxch	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fadd	QWORD PTR __real@3ff0000000000000
	fmul	QWORD PTR _u$[ebp]
	fchs

; 3550 :     p = pk + h*(dpn + 0.5*h*(d2pn + h/3*(d3pn + 0.25*h*d4pn)));

	fld	ST(0)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR tv588[ebp]
	fld	QWORD PTR __real@3fd0000000000000
	fmul	ST(0), ST(1)
	fmul	QWORD PTR _d4pn$[ebp]
	faddp	ST(5), ST(0)
	fld	QWORD PTR __real@4008000000000000
	fdivr	ST(0), ST(1)
	fmulp	ST(5), ST(0)
	fxch	ST(4)
	fadd	ST(0), ST(1)
	fmul	QWORD PTR tv588[ebp]
	fadd	ST(0), ST(2)
	fmul	ST(0), ST(4)
	fadd	ST(0), ST(3)

; 3551 :     dp = dpn + h*(d2pn + .5*h*(d3pn + h*d4pn/3));

	fld	ST(4)
	fmul	QWORD PTR _d4pn$[ebp]
	fdiv	QWORD PTR __real@4008000000000000
	fadd	QWORD PTR _d3pn$[ebp]
	fmul	QWORD PTR tv588[ebp]
	fadd	ST(0), ST(2)
	fmul	ST(0), ST(5)
	fadd	ST(0), ST(3)

; 3552 :     h = h - p/dp;
; 3553 :     x[i-1] = x0 + h;
; 3554 :     fx = d1 - h*e1*((((0.2*h*d4pn + d3pn)*0.25*h + d2pn)*h/3 + dpn)*0.5*h + pk);
; 3555 :     w[n-i] = w[i-1] = (1 - x[i-1]*x[i-1])/fx/fx;

	mov	eax, DWORD PTR tv1059[ebp]
	add	DWORD PTR tv977[ebp], 4
	add	edi, 8
	fdivp	ST(1), ST(0)
	sub	ebx, 8
	dec	DWORD PTR tv345[ebp]
	fsubp	ST(4), ST(0)
	fld	ST(3)
	faddp	ST(5), ST(0)
	fxch	ST(4)
	fst	QWORD PTR [edi-8]
	fld	ST(3)
	fmul	QWORD PTR __real@3fc999999999999a
	fmul	QWORD PTR _d4pn$[ebp]
	fadd	QWORD PTR _d3pn$[ebp]
	fmul	QWORD PTR __real@3fd0000000000000
	fmul	ST(0), ST(4)
	faddp	ST(5), ST(0)
	fxch	ST(4)
	fmul	ST(0), ST(3)
	fdiv	QWORD PTR __real@4008000000000000
	faddp	ST(1), ST(0)
	fld	QWORD PTR __real@3fe0000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(2), ST(0)
	fld	QWORD PTR tv543[ebp]
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	fmulp	ST(2), ST(0)
	fld	QWORD PTR _d1$[ebp]
	fsubrp	ST(2), ST(0)
	fld	ST(2)
	fmulp	ST(3), ST(0)
	fld1
	fld	ST(0)
	fsubrp	ST(4), ST(0)
	fxch	ST(3)
	fdiv	ST(0), ST(2)
	fdivrp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR [edi+eax-8]
	fstp	QWORD PTR [eax+ebx+8]

; 3556 : 
; 3557 :     /* normalization to [0,1] */
; 3558 :     x[i-1] = (1 + x[i-1])/2;

	fld	QWORD PTR [edi-8]
	fadd	ST(0), ST(2)
	fmul	ST(0), ST(1)
	fst	QWORD PTR [edi-8]

; 3559 :     x[n-i] =  1 - x[i-1];

	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [ebx+8]
	jne	$LL52@grule

; 3526 :   e1 = n*(n+1);
; 3527 :   for ( i = 1 ; i <= m ; i++ )

	mov	eax, DWORD PTR _m$[ebp]
	mov	ebx, DWORD PTR _x$[ebp]
	jmp	SHORT $LN5@grule
$LN36@grule:
	fstp	ST(1)
$LN5@grule:

; 3560 :   }
; 3561 :   if ( 2*m > n ) x[m-1] = 0.5;

	lea	ecx, DWORD PTR [eax+eax]
	cmp	ecx, esi
	jle	SHORT $LN39@grule
	pop	edi
	fstp	QWORD PTR [ebx+eax*8-8]
	pop	esi
	pop	ebx

; 3562 : } // end grule()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@grule:
	pop	edi

; 3560 :   }
; 3561 :   if ( 2*m > n ) x[m-1] = 0.5;

	fstp	ST(0)
	pop	esi
	pop	ebx

; 3562 : } // end grule()

	mov	esp, ebp
	pop	ebp
	ret	0
_grule	ENDP
_TEXT	ENDS
PUBLIC	_binom_coeff
; Function compile flags: /Ogtp
;	COMDAT _binom_coeff
_TEXT	SEGMENT
_n$ = 8							; size = 4
_k$ = 12						; size = 4
_binom_coeff PROC					; COMDAT

; 3574 : { int i, c;

	push	ebp
	mov	ebp, esp
	push	esi

; 3575 : 
; 3576 :   if ( n < k ) return 0;

	mov	esi, DWORD PTR _n$[ebp]
	push	edi
	mov	edi, DWORD PTR _k$[ebp]
	cmp	esi, edi
	jge	SHORT $LN5@binom_coef
	pop	edi
	xor	eax, eax
	pop	esi

; 3581 : }  // end binom_coeff()

	pop	ebp
	ret	0
$LN5@binom_coef:

; 3577 :   if ( (n-k) < k ) k = n - k; 

	mov	eax, esi
	sub	eax, edi
	cmp	eax, edi
	jge	SHORT $LN4@binom_coef
	mov	edi, eax
$LN4@binom_coef:

; 3578 :   for ( i = 0, c = 1 ; i < k ; i++ )

	xor	eax, eax
	lea	edx, DWORD PTR [eax+1]
	test	edi, edi
	jle	SHORT $LN1@binom_coef
$LL3@binom_coef:

; 3579 :   { c *= n - i; c /= i+1; }

	lea	ecx, DWORD PTR [eax+1]
	mov	eax, esi
	imul	eax, edx
	cdq
	idiv	ecx
	dec	esi
	mov	edx, eax
	mov	eax, ecx
	cmp	eax, edi
	jl	SHORT $LL3@binom_coef
$LN1@binom_coef:
	pop	edi

; 3580 :   return c;

	mov	eax, edx
	pop	esi

; 3581 : }  // end binom_coeff()

	pop	ebp
	ret	0
_binom_coeff ENDP
_TEXT	ENDS
PUBLIC	_set_e_phase_density
EXTRN	_phase_data:DWORD
EXTRN	_F_PHASE_ATTR:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_e_phase_density
_TEXT	SEGMENT
tv420 = -4						; size = 4
_i$ = 8							; size = 4
_e_id$ = 8						; size = 4
_set_e_phase_density PROC				; COMDAT

; 3590 : { facetedge_id fe = get_edge_fe(e_id);

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv420[ebp], eax
	test	eax, eax
	je	SHORT $LN7@set_e_phas
$LN8@set_e_phas:
	mov	eax, DWORD PTR [eax+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN7@set_e_phas
	xor	eax, 134217728				; 08000000H
$LN7@set_e_phas:

; 3591 :   int i = get_f_phase(get_fe_facet(fe));      

	push	ebx
	mov	ebx, DWORD PTR _F_PHASE_ATTR
	imul	ebx, 240				; 000000f0H
	add	ebx, DWORD PTR _web+328
	push	esi
	add	ebx, DWORD PTR _dymem
	mov	esi, DWORD PTR _web+460
	push	edi
	mov	edi, DWORD PTR [ebx+88]
	test	edi, edi
	je	SHORT $LN35@set_e_phas
	mov	edx, eax
	shr	edx, 28					; 0000001cH
	and	edx, 1
	jne	SHORT $LN12@set_e_phas
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN11@set_e_phas
$LN12@set_e_phas:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN11@set_e_phas
	xor	ecx, 134217728				; 08000000H
$LN11@set_e_phas:
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN35@set_e_phas
	test	edx, edx
	jne	SHORT $LN16@set_e_phas
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN15@set_e_phas
$LN16@set_e_phas:
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+edx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN15@set_e_phas
	xor	ecx, 134217728				; 08000000H
$LN15@set_e_phas:
	mov	edx, DWORD PTR _web+236
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [ebx+64]
	mov	ecx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _i$[ebp], ecx
	jmp	SHORT $LN4@set_e_phas
$LN35@set_e_phas:
	mov	DWORD PTR _i$[ebp], 0
$LN4@set_e_phas:

; 3592 :   int j = get_f_phase(get_fe_facet(get_next_facet(fe)));      

	test	edi, edi
	je	$LN37@set_e_phas
	mov	edi, eax
	shr	edi, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	and	edi, 1
	mov	eax, DWORD PTR [esi+eax*4]
	je	SHORT $LN20@set_e_phas
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN19@set_e_phas
$LN20@set_e_phas:
	mov	ecx, DWORD PTR [eax+40]
$LN19@set_e_phas:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN24@set_e_phas
	mov	edx, DWORD PTR _NULLFACET
	jmp	SHORT $LN36@set_e_phas
$LN24@set_e_phas:
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR [edx+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN36@set_e_phas
	xor	edx, 134217728				; 08000000H
$LN36@set_e_phas:
	test	edx, 268435456				; 10000000H
	je	SHORT $LN37@set_e_phas
	test	edi, edi
	je	SHORT $LN28@set_e_phas
	mov	eax, DWORD PTR [eax+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN27@set_e_phas
$LN28@set_e_phas:
	mov	eax, DWORD PTR [eax+40]
$LN27@set_e_phas:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN32@set_e_phas
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN33@set_e_phas
$LN32@set_e_phas:
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR [edx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN31@set_e_phas
	xor	ecx, 134217728				; 08000000H
$LN31@set_e_phas:
	mov	eax, ecx
$LN33@set_e_phas:
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ebx+64]
	mov	eax, DWORD PTR [edx+eax]
	jmp	SHORT $LN6@set_e_phas
$LN37@set_e_phas:
	xor	eax, eax
$LN6@set_e_phas:

; 3593 :       set_edge_density(e_id,phase_data[i][j]);

	mov	ecx, DWORD PTR _phase_data
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	fld	QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR tv420[ebp]
	pop	edi
	fstp	QWORD PTR [edx+40]
	pop	esi
	pop	ebx

; 3594 : } // end set_e_phase_density()

	mov	esp, ebp
	pop	ebp
	ret	0
_set_e_phase_density ENDP
_TEXT	ENDS
PUBLIC	_set_f_phase_density
EXTRN	_B_PHASE_ATTR:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_f_phase_density
_TEXT	SEGMENT
_i$ = 8							; size = 4
_f_id$ = 8						; size = 4
_set_f_phase_density PROC				; COMDAT

; 3603 : { 

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 3604 :   int i = get_b_phase(get_facet_body(f_id));     

	mov	esi, DWORD PTR _f_id$[ebp]
	push	edi
	mov	edi, DWORD PTR _B_PHASE_ATTR
	imul	edi, 240				; 000000f0H
	add	edi, DWORD PTR _web+440
	add	edi, DWORD PTR _dymem
	mov	ebx, DWORD PTR [edi+88]
	test	ebx, ebx
	je	SHORT $LN10@set_f_phas
	push	esi
	call	_get_facet_body
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN10@set_f_phas
	push	esi
	call	_get_facet_body
	mov	edx, DWORD PTR _web+348
	mov	ecx, DWORD PTR [edi+64]
	add	esp, 4
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN4@set_f_phas
$LN10@set_f_phas:
	mov	DWORD PTR _i$[ebp], 0
$LN4@set_f_phas:

; 3605 :   int j = get_b_phase(get_facet_body(inverse_id(f_id)));      

	test	ebx, ebx
	je	SHORT $LN9@set_f_phas
	mov	ebx, esi
	xor	ebx, 134217728				; 08000000H
	push	ebx
	call	_get_facet_body
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN9@set_f_phas
	push	ebx
	call	_get_facet_body
	mov	ecx, DWORD PTR _web+348
	add	esp, 4
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edi+64]
	mov	edx, DWORD PTR [edx+eax]
	jmp	SHORT $LN6@set_f_phas
$LN9@set_f_phas:
	xor	edx, edx
$LN6@set_f_phas:

; 3606 :   set_attr(f_id,DENSITY);

	mov	eax, esi
	shr	esi, 29					; 0000001dH
	imul	esi, 112				; 00000070H
	mov	ecx, DWORD PTR _web[esi+12]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [ecx+eax]
	mov	esi, DWORD PTR [ecx+12]
	or	DWORD PTR [ecx+8], 16			; 00000010H
	mov	DWORD PTR [ecx+12], esi

; 3607 :   set_facet_density(f_id,phase_data[i][j]);

	mov	ecx, DWORD PTR _phase_data
	mov	esi, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR _web+236
	mov	eax, DWORD PTR [eax+esi]
	fld	QWORD PTR [ecx+edx*8]
	pop	edi
	pop	esi
	fstp	QWORD PTR [eax+32]
	pop	ebx

; 3608 : } // end set_f_phase_density()

	pop	ebp
	ret	0
_set_f_phase_density ENDP
_TEXT	ENDS
PUBLIC	_make_bfacet_lists
EXTRN	_set_prev_body_facet:PROC
EXTRN	_set_next_body_facet:PROC
EXTRN	_expand_attribute:PROC
EXTRN	_top_timestamp:DWORD
EXTRN	_bfacet_timestamp:DWORD
; Function compile flags: /Ogtp
;	COMDAT _make_bfacet_lists
_TEXT	SEGMENT
_four$ = -12						; size = 4
tv599 = -8						; size = 4
_b_id$ = -8						; size = 4
tv579 = -4						; size = 4
_make_bfacet_lists PROC					; COMDAT

; 3752 : { body_id b_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3753 :   facet_id f_id, ff_id,fff_id,fi_id;
; 3754 :   int four = 4;
; 3755 : 
; 3756 :   if ( bfacet_timestamp >= top_timestamp ) return; 

	mov	eax, DWORD PTR _bfacet_timestamp
	mov	DWORD PTR _four$[ebp], 4
	cmp	eax, DWORD PTR _top_timestamp
	jge	$LN27@make_bface

; 3757 :   if ( web.skel[BODY].count == 0 ) return;

	cmp	DWORD PTR _web+400, 0
	je	$LN27@make_bface

; 3758 :   expand_attribute(FACET,F_NEXT_BFACET_ATTR,&four);

	push	ebx
	push	esi
	push	edi
	lea	ecx, DWORD PTR _four$[ebp]
	push	ecx
	push	5
	push	2
	call	_expand_attribute

; 3759 :   /* start by making one-element loops on facets pointed to
; 3760 :       by body facet_edge link */
; 3761 :   FOR_ALL_BODIES(b_id)

	mov	edi, DWORD PTR _web+384
	mov	eax, edi
	shr	eax, 28					; 0000001cH
	add	esp, 12					; 0000000cH
	and	eax, 1
	mov	DWORD PTR _b_id$[ebp], edi
	mov	DWORD PTR tv579[ebp], eax
	je	$LN74@make_bface
	jmp	SHORT $LN24@make_bface
	npad	6
$LL75@make_bface:
	mov	edi, DWORD PTR _b_id$[ebp]
$LN24@make_bface:
	mov	edx, DWORD PTR _web+348
	mov	ebx, edi
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	esi, DWORD PTR [ebx+edx]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN23@make_bface

; 3762 :   { /* make sure legal pointer */
; 3763 :     f_id = get_body_facet(b_id);

	cmp	DWORD PTR tv579[ebp], ecx
	je	SHORT $LN31@make_bface
	mov	eax, DWORD PTR [esi+400]
	jmp	SHORT $LN32@make_bface
$LN31@make_bface:
	xor	eax, eax
$LN32@make_bface:

; 3764 :     if ( !valid_id(f_id) || 
; 3765 :     #ifdef MPI_EVOLVER
; 3766 :          !mpi_remote_present(f_id) ||
; 3767 :     #endif  
; 3768 :         !equal_id(b_id,get_facet_body(f_id))  )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN18@make_bface
	push	eax
	call	_get_facet_body
	add	esp, 4
	cmp	edi, eax
	je	$LN82@make_bface
$LN18@make_bface:

; 3769 :     { set_body_facet(b_id,NULLID);

	cmp	DWORD PTR tv579[ebp], 0
	je	SHORT $LN33@make_bface
	mov	DWORD PTR [esi+400], 0
$LN33@make_bface:

; 3770 :       FOR_ALL_FACETS(f_id)

	mov	esi, DWORD PTR _web+272
	test	esi, 268435456				; 10000000H
	je	$LN82@make_bface
$LL76@make_bface:
	mov	ecx, DWORD PTR _web+236
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN16@make_bface

; 3771 :       { if ( equal_id(b_id,get_facet_body(f_id)) ) 

	push	esi
	call	_get_facet_body
	add	esp, 4
	cmp	DWORD PTR _b_id$[ebp], eax
	je	SHORT $LN69@make_bface

; 3773 :         if ( equal_id(b_id,get_facet_body(inverse_id(f_id))) ) 

	mov	edx, esi
	xor	edx, 134217728				; 08000000H
	push	edx
	call	_get_facet_body
	add	esp, 4
	cmp	DWORD PTR _b_id$[ebp], eax
	je	SHORT $LN70@make_bface
$LN16@make_bface:

; 3770 :       FOR_ALL_FACETS(f_id)

	mov	esi, DWORD PTR [edi]
	test	esi, 268435456				; 10000000H
	jne	SHORT $LL76@make_bface

; 3773 :         if ( equal_id(b_id,get_facet_body(inverse_id(f_id))) ) 

	jmp	SHORT $LN82@make_bface
$LN69@make_bface:

; 3772 :         {set_body_facet(b_id,f_id); break; }

	cmp	DWORD PTR tv579[ebp], 0
	je	SHORT $LN77@make_bface
	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [ebx+eax]
	mov	DWORD PTR [ecx+400], esi
	jmp	SHORT $LN82@make_bface
$LN70@make_bface:

; 3774 :         {set_body_facet(b_id,inverse_id(f_id)); break; }

	cmp	DWORD PTR tv579[ebp], 0
	je	SHORT $LN77@make_bface
	mov	edx, DWORD PTR _web+348
	mov	eax, DWORD PTR [ebx+edx]
	xor	esi, 134217728				; 08000000H
	mov	DWORD PTR [eax+400], esi
$LN82@make_bface:

; 3775 :       }   
; 3776 :     }   
; 3777 :     f_id = get_body_facet(b_id);

	cmp	DWORD PTR tv579[ebp], 0
	je	SHORT $LN77@make_bface
	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [ebx+ecx]
	mov	esi, DWORD PTR [edx+400]
	jmp	SHORT $LN45@make_bface
$LN77@make_bface:
	xor	esi, esi
$LN45@make_bface:

; 3778 :     if ( valid_id(f_id) )

	test	esi, 268435456				; 10000000H
	je	SHORT $LN23@make_bface

; 3779 :     {
; 3780 :       set_next_body_facet(f_id,f_id);

	push	esi
	push	esi
	call	_set_next_body_facet

; 3781 :       set_prev_body_facet(f_id,f_id);

	push	esi
	push	esi
	call	_set_prev_body_facet
	add	esp, 16					; 00000010H
$LN23@make_bface:

; 3759 :   /* start by making one-element loops on facets pointed to
; 3760 :       by body facet_edge link */
; 3761 :   FOR_ALL_BODIES(b_id)

	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [ebx+eax]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _b_id$[ebp], eax
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR tv579[ebp], eax
	jne	$LL75@make_bface
$LN74@make_bface:

; 3782 :     }
; 3783 :   }
; 3784 : 
; 3785 :   /* now splice in all other facets */
; 3786 :   FOR_ALL_FACETS(f_id)

	mov	esi, DWORD PTR _web+272
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	je	$LN7@make_bface
$LL80@make_bface:
	mov	edx, DWORD PTR _web+236
	mov	ebx, esi
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	add	ebx, ebx
	mov	edx, DWORD PTR [ebx+edx]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	mov	DWORD PTR tv599[ebp], ebx
	je	$LN8@make_bface

; 3787 :   { b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, edi
	jne	SHORT $LN49@make_bface
	xor	eax, eax
	jmp	SHORT $LN46@make_bface
$LN49@make_bface:
	test	ecx, ecx
	jne	SHORT $LN48@make_bface
	xor	eax, eax
	jmp	SHORT $LN46@make_bface
$LN48@make_bface:
	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+328
	test	esi, 134217728				; 08000000H
	je	SHORT $LN47@make_bface
	mov	eax, DWORD PTR [ecx+eax+784]
	mov	eax, DWORD PTR [eax+edx+4]
	jmp	SHORT $LN46@make_bface
$LN47@make_bface:
	mov	ecx, DWORD PTR [ecx+eax+784]
	mov	eax, DWORD PTR [edx+ecx]
$LN46@make_bface:

; 3788 :     if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN78@make_bface

; 3789 :     { ff_id = get_body_facet(b_id);

	mov	edx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [eax+400]

; 3790 :       if ( !equal_id(f_id,ff_id) )

	cmp	esi, edi
	je	SHORT $LN78@make_bface

; 3791 :       { /* splice in after first one */
; 3792 :         fff_id = get_next_body_facet(ff_id);

	push	edi
	call	_get_next_body_facet

; 3793 :         set_next_body_facet(ff_id,f_id);

	push	esi
	push	edi
	mov	ebx, eax
	call	_set_next_body_facet

; 3794 :         set_prev_body_facet(f_id,ff_id);

	push	edi
	push	esi
	call	_set_prev_body_facet

; 3795 :         set_next_body_facet(f_id,fff_id);

	push	ebx
	push	esi
	call	_set_next_body_facet

; 3796 :         set_prev_body_facet(fff_id,f_id);

	push	esi
	push	ebx
	call	_set_prev_body_facet
	mov	ebx, DWORD PTR tv599[ebp]
	add	esp, 36					; 00000024H
$LN78@make_bface:

; 3797 :       }
; 3798 :     }
; 3799 :     fi_id = inverse_id(f_id);

	xor	esi, 134217728				; 08000000H

; 3800 :     b_id = get_facet_body(fi_id);

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN59@make_bface
	xor	eax, eax
	jmp	SHORT $LN56@make_bface
$LN59@make_bface:
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN58@make_bface
	xor	eax, eax
	jmp	SHORT $LN56@make_bface
$LN58@make_bface:
	test	esi, 134217728				; 08000000H
	je	SHORT $LN57@make_bface
	mov	edx, DWORD PTR _web+236
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+784]
	mov	eax, DWORD PTR [eax+ecx+4]
	jmp	SHORT $LN56@make_bface
$LN57@make_bface:
	mov	eax, DWORD PTR _web+236
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+328
	mov	edx, DWORD PTR [edx+eax+784]
	mov	eax, DWORD PTR [ecx+edx]
$LN56@make_bface:

; 3801 :     if ( valid_id(b_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN8@make_bface

; 3802 :       { ff_id = get_body_facet(b_id);

	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	edi, DWORD PTR [edx+400]

; 3803 :         if ( !equal_id(fi_id,ff_id) )

	cmp	esi, edi
	je	SHORT $LN8@make_bface

; 3804 :          { /* splice in after first one */
; 3805 :             fff_id = get_next_body_facet(ff_id);

	push	edi
	call	_get_next_body_facet

; 3806 :             set_next_body_facet(ff_id,fi_id);

	push	esi
	push	edi
	mov	ebx, eax
	call	_set_next_body_facet

; 3807 :             set_prev_body_facet(fi_id,ff_id);

	push	edi
	push	esi
	call	_set_prev_body_facet

; 3808 :             set_next_body_facet(fi_id,fff_id);

	push	ebx
	push	esi
	call	_set_next_body_facet

; 3809 :             set_prev_body_facet(fff_id,fi_id);

	push	esi
	push	ebx
	call	_set_prev_body_facet
	mov	ebx, DWORD PTR tv599[ebp]
	add	esp, 36					; 00000024H
$LN8@make_bface:

; 3782 :     }
; 3783 :   }
; 3784 : 
; 3785 :   /* now splice in all other facets */
; 3786 :   FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ebx+eax]
	mov	esi, DWORD PTR [ecx]
	mov	ecx, esi
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	jne	$LL80@make_bface
$LN7@make_bface:

; 3810 :          }
; 3811 :       }
; 3812 :   }
; 3813 :   bfacet_timestamp = top_timestamp; 

	mov	edx, DWORD PTR _top_timestamp
	pop	edi
	pop	esi
	mov	DWORD PTR _bfacet_timestamp, edx
	pop	ebx
$LN27@make_bface:

; 3814 : } // end make_bfacet_lists()

	mov	esp, ebp
	pop	ebp
	ret	0
_make_bfacet_lists ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@GNDIKONM@Internal?5error?3?5Vertex?5?$CFs?5edge?5l@ ; `string'
PUBLIC	??_C@_0DI@IIOIFLEK@Internal?5error?3?5Trying?5to?5insert@ ; `string'
PUBLIC	_insert_vertex_edge
;	COMDAT ??_C@_0DB@GNDIKONM@Internal?5error?3?5Vertex?5?$CFs?5edge?5l@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DB@GNDIKONM@Internal?5error?3?5Vertex?5?$CFs?5edge?5l@ DB 'Interna'
	DB	'l error: Vertex %s edge loop not closed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@IIOIFLEK@Internal?5error?3?5Trying?5to?5insert@
CONST	SEGMENT
??_C@_0DI@IIOIFLEK@Internal?5error?3?5Trying?5to?5insert@ DB 'Internal er'
	DB	'ror: Trying to insert edge to wrong vertex.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\utility.c
CONST	ENDS
;	COMDAT _insert_vertex_edge
_TEXT	SEGMENT
tv404 = -8						; size = 4
_ee_id$ = -4						; size = 4
_v_id$ = 8						; size = 4
tv385 = 12						; size = 4
_e_id$ = 12						; size = 4
_insert_vertex_edge PROC				; COMDAT

; 3828 : { edge_id ee_id,eee_id; 

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3829 :   int n;
; 3830 :   
; 3831 :   #ifdef MPI_EVOLVER
; 3832 :   if ( !elptr(v_id) || !elptr(e_id) ) 
; 3833 :     return;
; 3834 :   #endif
; 3835 : 
; 3836 :   if ( !equal_id(v_id,get_edge_tailv(e_id)) )

	mov	edx, DWORD PTR _e_id$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _dymem
	push	esi
	mov	esi, DWORD PTR _web+124
	mov	eax, edx
	push	edi
	mov	edi, DWORD PTR _web+216
	mov	edi, DWORD PTR [edi+ebx+304]
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR tv385[ebp], eax
	mov	ecx, edx
	je	SHORT $LN13@insert_ver
	mov	ebx, DWORD PTR _web+636
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+esi]
	lea	edi, DWORD PTR [edi+ebx*4]
	mov	ebx, DWORD PTR [edi+eax]
	jmp	SHORT $LN12@insert_ver
$LN13@insert_ver:
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+esi]
	mov	ebx, DWORD PTR [eax+edi]
$LN12@insert_ver:
	mov	edi, DWORD PTR _v_id$[ebp]
	cmp	edi, ebx
	je	SHORT $LN7@insert_ver

; 3837 :   { kb_error(1372,"Internal error: Trying to insert edge to wrong vertex.\n",
; 3838 :        WARNING);

	push	2
	push	OFFSET ??_C@_0DI@IIOIFLEK@Internal?5error?3?5Trying?5to?5insert@
	push	1372					; 0000055cH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 3864 : 
; 3865 : } /* end insert_vertex_edge */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@insert_ver:

; 3839 :     return;
; 3840 :   }
; 3841 :   ee_id = get_vertex_edge(v_id);

	mov	ebx, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR [ebx+28]
	mov	DWORD PTR tv404[ebp], edi
	mov	DWORD PTR _ee_id$[ebp], ebx

; 3842 :   if ( !valid_id(ee_id) )

	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN6@insert_ver

; 3843 :   { set_next_tail_edge(e_id,e_id);

	mov	ecx, DWORD PTR tv385[ebp]
	mov	DWORD PTR [eax+ecx*4+32], edx

; 3844 :     set_vertex_edge(v_id,e_id);

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [eax+edi*4]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+28], edx
	pop	ebx

; 3864 : 
; 3865 : } /* end insert_vertex_edge */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@insert_ver:

; 3845 :     return;
; 3846 :   }
; 3847 :   /* go around to be sure not already there */
; 3848 :   eee_id = ee_id; n = 0;

	mov	eax, ebx
	xor	edi, edi
	npad	2
$LL5@insert_ver:

; 3849 :   do 
; 3850 :   { eee_id = get_next_tail_edge(eee_id);

	mov	ebx, eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	shr	ebx, 27					; 0000001bH
	and	ebx, 1
	mov	eax, DWORD PTR [eax+ebx*4+32]

; 3851 :     if ( equal_id(eee_id,e_id) ) return;

	cmp	eax, edx
	je	SHORT $LN24@insert_ver

; 3852 :     if ( ++n > 2*web.skel[EDGE].count+5 ) /* sanity check */

	mov	ebx, DWORD PTR _web+176
	inc	edi
	lea	ebx, DWORD PTR [ebx+ebx+5]
	cmp	edi, ebx
	jg	SHORT $LN29@insert_ver

; 3856 :       return;
; 3857 :     }
; 3858 :   } while ( !equal_id(eee_id,ee_id) );

	cmp	eax, DWORD PTR _ee_id$[ebp]
	jne	SHORT $LL5@insert_ver

; 3859 : 
; 3860 :   /* insert into existing list */
; 3861 :   ee_id = get_next_tail_edge(eee_id);

	mov	edi, eax
	shr	edi, 27					; 0000001bH
	and	edi, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR [eax+edi*4+32]
	lea	eax, DWORD PTR [eax+edi*4+32]

; 3862 :   set_next_tail_edge(eee_id,e_id);

	mov	DWORD PTR [eax], edx

; 3863 :   set_next_tail_edge(e_id,ee_id);

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR tv385[ebp]
	mov	DWORD PTR [eax+ecx*4+32], esi
$LN24@insert_ver:
	pop	edi
	pop	esi
	pop	ebx

; 3864 : 
; 3865 : } /* end insert_vertex_edge */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@insert_ver:

; 3853 :     { sprintf(errmsg,"Internal error: Vertex %s edge loop not closed.\n",
; 3854 :           ELNAME(v_id));

	test	DWORD PTR _v_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN10@insert_ver
	mov	ecx, DWORD PTR tv404[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN11@insert_ver
$LN10@insert_ver:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN11@insert_ver:
	push	eax
	push	OFFSET ??_C@_0DB@GNDIKONM@Internal?5error?3?5Vertex?5?$CFs?5edge?5l@
	push	OFFSET _errmsg
	call	_sprintf

; 3855 :       kb_error(1373,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1373					; 0000055dH
	call	_kb_error
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx

; 3864 : 
; 3865 : } /* end insert_vertex_edge */

	mov	esp, ebp
	pop	ebp
	ret	0
_insert_vertex_edge ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EI@GIBHFBEI@Internal?5error?3?5Trying?5to?5detach@ ; `string'
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_remove_vertex_edge
EXTRN	_set_v_constraint_map:PROC
EXTRN	_unset_v_constraint_map:PROC
;	COMDAT ??_C@_0EI@GIBHFBEI@Internal?5error?3?5Trying?5to?5detach@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EI@GIBHFBEI@Internal?5error?3?5Trying?5to?5detach@ DB 'Internal er'
	DB	'ror: Trying to detach edge %s from vertex %s instead of %s.', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\utility.c
CONST	ENDS
;	COMDAT _remove_vertex_edge
_TEXT	SEGMENT
tv577 = -68						; size = 4
tv634 = -64						; size = 4
$T93384 = -64						; size = 4
_v_id$GSCopy$ = -60					; size = 4
tv604 = -56						; size = 4
_ee_id$ = -52						; size = 4
_n$ = -52						; size = 4
tv580 = -48						; size = 4
tv78 = -48						; size = 4
_to_do$91673 = -44					; size = 40
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_e_id$ = 12						; size = 4
_remove_vertex_edge PROC				; COMDAT

; 3879 : { edge_id ee_id,eee_id,eeee_id; 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3955 :     #define MAXTODO 10
; 3956 :     conmap_t to_do[MAXTODO]; 
; 3957 :     /* make list since unset and set can change order in map */
; 3958 :     for ( k = 1, n = 0; k <= (int)*map ; k++ )

	mov	eax, DWORD PTR _v_id$[ebp]
	mov	ecx, DWORD PTR _web+124
	push	ebx
	mov	ebx, DWORD PTR _e_id$[ebp]
	mov	DWORD PTR _v_id$GSCopy$[ebp], eax
	mov	eax, ebx
	push	esi
	shr	eax, 27					; 0000001bH
	and	eax, 1
	push	edi
	mov	edi, DWORD PTR _dymem
	mov	DWORD PTR tv577[ebp], eax
	mov	esi, ebx
	je	SHORT $LN36@remove_ver

; 3880 :   vertex_id vv_id = get_edge_tailv(e_id);

	and	esi, 134217727				; 07ffffffH
	lea	eax, DWORD PTR [esi*4]
	mov	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv580[ebp], eax
	mov	eax, DWORD PTR _web+216
	add	edx, DWORD PTR [eax+edi+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN35@remove_ver
$LN36@remove_ver:
	and	esi, 134217727				; 07ffffffH
	lea	eax, DWORD PTR [esi*4]
	mov	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv580[ebp], eax
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edi+304]
	mov	eax, DWORD PTR [edx+eax]
$LN35@remove_ver:

; 3881 :   int n = 0;
; 3882 : 
; 3883 : #ifdef MPI_EVOLVER
; 3884 :   if ( !mpi_remote_present(v_id) )
; 3885 :      return;
; 3886 : #endif
; 3887 : 
; 3888 :   if ( !equal_id(v_id,vv_id) )

	mov	edi, DWORD PTR _v_id$GSCopy$[ebp]
	xor	edx, edx
	cmp	edi, eax
	je	$LN20@remove_ver

; 3889 :   { sprintf(errmsg,
; 3890 :     "Internal error: Trying to detach edge %s from vertex %s instead of %s.\n",
; 3891 :        ELNAME(e_id),ELNAME1(v_id),ELNAME2(vv_id));

	test	eax, 268435456				; 10000000H
	je	SHORT $LN23@remove_ver
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv78[ebp], OFFSET _elnames+60
	jmp	SHORT $LN24@remove_ver
$LN23@remove_ver:
	mov	DWORD PTR tv78[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN24@remove_ver:
	test	edi, 268435456				; 10000000H
	je	SHORT $LN25@remove_ver
	and	edi, 134217727				; 07ffffffH
	inc	edi
	push	edi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	edi, OFFSET _elnames+30
	jmp	SHORT $LN26@remove_ver
$LN25@remove_ver:
	mov	edi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN26@remove_ver:
	test	ebx, 268435456				; 10000000H
	je	SHORT $LN27@remove_ver
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN28@remove_ver
$LN27@remove_ver:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN28@remove_ver:
	mov	ecx, DWORD PTR tv78[ebp]
	push	ecx
	push	edi
	push	eax
	push	OFFSET ??_C@_0EI@GIBHFBEI@Internal?5error?3?5Trying?5to?5detach@
	push	OFFSET _errmsg
	call	_sprintf

; 3892 :      kb_error(1374,errmsg,  WARNING);

	push	2
	push	OFFSET _errmsg
	push	1374					; 0000055eH
	call	_kb_error
	add	esp, 32					; 00000020H
	pop	edi
	pop	esi
	pop	ebx

; 3967 :     }  
; 3968 :    }
; 3969 : 
; 3970 : } /* end remove_vertex_edge() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@remove_ver:

; 3893 :     return;
; 3894 :   }
; 3895 :   /* make sure edge actually in vertex edge loop */
; 3896 :   ee_id = get_vertex_edge(v_id);

	mov	esi, DWORD PTR _web+12
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv604[ebp], eax
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR [eax+28]
	mov	DWORD PTR _ee_id$[ebp], esi

; 3897 :   if ( !valid_id(ee_id)) return;

	test	esi, 268435456				; 10000000H
	je	$LN1@remove_ver
$LL18@remove_ver:

; 3898 :   eee_id = ee_id;
; 3899 :   do
; 3900 :   { 
; 3901 :   #ifdef MPI_EVOLVER
; 3902 :     if ( !mpi_remote_present(eee_id) )
; 3903 :        return;  /* fail, but don't crash */
; 3904 :   #endif
; 3905 :     if ( equal_id(eee_id,e_id) ) break;

	cmp	esi, ebx
	je	$LN60@remove_ver

; 3906 :     eee_id = get_next_tail_edge(eee_id);

	mov	eax, esi
	shr	eax, 27					; 0000001bH
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+esi*4]
	and	eax, 1
	mov	esi, DWORD PTR [esi+eax*4+32]

; 3907 :     if ( ++n > 2*web.skel[EDGE].count ) /* sanity check */ 

	mov	eax, DWORD PTR _web+176
	inc	edx
	add	eax, eax
	cmp	edx, eax
	jg	SHORT $LN56@remove_ver

; 3911 :       break;
; 3912 :     }
; 3913 :   } while ( !equal_id(eee_id,ee_id) );

	cmp	esi, DWORD PTR _ee_id$[ebp]
	jne	SHORT $LL18@remove_ver
	jmp	SHORT $LN16@remove_ver
$LN56@remove_ver:

; 3908 :     { 
; 3909 :       sprintf(errmsg,"Internal error: Vertex %s edge loop not closed.\n",ELNAME(v_id));

	test	edi, 268435456				; 10000000H
	je	SHORT $LN29@remove_ver
	mov	ecx, DWORD PTR tv604[ebp]
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN30@remove_ver
$LN29@remove_ver:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN30@remove_ver:
	push	eax
	push	OFFSET ??_C@_0DB@GNDIKONM@Internal?5error?3?5Vertex?5?$CFs?5edge?5l@
	push	OFFSET _errmsg
	call	_sprintf

; 3910 :       kb_error(1375,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1375					; 0000055fH
	call	_kb_error
	mov	ecx, DWORD PTR _web+124
	add	esp, 24					; 00000018H
$LN16@remove_ver:

; 3914 :   if ( !equal_id(eee_id,e_id) ) return;

	cmp	esi, ebx
	jne	$LN1@remove_ver
$LN60@remove_ver:

; 3915 : 
; 3916 :   ee_id = get_next_tail_edge(e_id);

	mov	edx, DWORD PTR tv580[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	edx, DWORD PTR tv577[ebp]
	mov	edi, DWORD PTR [eax+edx*4+32]

; 3917 :   if ( equal_id(e_id,ee_id) )

	cmp	ebx, edi
	jne	SHORT $LN12@remove_ver

; 3918 :     { set_vertex_edge(v_id,NULLID);

	mov	ecx, DWORD PTR _web+12
	mov	eax, DWORD PTR tv604[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+28], 0
	pop	ebx

; 3967 :     }  
; 3968 :    }
; 3969 : 
; 3970 : } /* end remove_vertex_edge() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@remove_ver:

; 3919 :       return;
; 3920 :     }
; 3921 :   #ifdef MPI_EVOLVER
; 3922 :       if ( !mpi_remote_present(ee_id) )
; 3923 :          return;
; 3924 :   #endif
; 3925 :   eee_id = ee_id;
; 3926 :   eeee_id = get_next_tail_edge(ee_id);

	mov	eax, edi
	shr	eax, 27					; 0000001bH
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	and	eax, 1
	mov	eax, DWORD PTR [edx+eax*4+32]
	mov	esi, edi

; 3927 :   #ifdef MPI_EVOLVER
; 3928 :       if ( !mpi_remote_present(eeee_id) )
; 3929 :          return;
; 3930 :    #endif
; 3931 : 
; 3932 :   n = 0;

	mov	DWORD PTR _n$[ebp], 0

; 3933 :   while ( !equal_id(e_id,eeee_id) )

	cmp	ebx, eax
	je	$LN10@remove_ver
	mov	edx, DWORD PTR _web+176
	add	edx, edx
	mov	DWORD PTR tv634[ebp], edx
	npad	7
$LL11@remove_ver:

; 3934 :     { eee_id = eeee_id;
; 3935 :       eeee_id = get_next_tail_edge(eee_id);
; 3936 :       #ifdef MPI_EVOLVER
; 3937 :       if ( !mpi_remote_present(eeee_id) )
; 3938 :          return;
; 3939 :       #endif
; 3940 :       if ( ++n > 2*web.skel[EDGE].count ) /* sanity check */

	inc	DWORD PTR _n$[ebp]
	mov	edx, eax
	mov	esi, eax
	shr	edx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	and	edx, 1
	mov	eax, DWORD PTR [eax+edx*4+32]
	mov	edx, DWORD PTR tv634[ebp]
	cmp	DWORD PTR _n$[ebp], edx
	jg	SHORT $LN57@remove_ver

; 3933 :   while ( !equal_id(e_id,eeee_id) )

	cmp	ebx, eax
	jne	SHORT $LL11@remove_ver

; 3934 :     { eee_id = eeee_id;
; 3935 :       eeee_id = get_next_tail_edge(eee_id);
; 3936 :       #ifdef MPI_EVOLVER
; 3937 :       if ( !mpi_remote_present(eeee_id) )
; 3938 :          return;
; 3939 :       #endif
; 3940 :       if ( ++n > 2*web.skel[EDGE].count ) /* sanity check */

	jmp	SHORT $LN10@remove_ver
$LN57@remove_ver:

; 3941 :       { sprintf(errmsg, "Internal error: Vertex %s edge loop not closed.\n",
; 3942 :            ELNAME(v_id));

	test	DWORD PTR _v_id$GSCopy$[ebp], 268435456	; 10000000H
	je	SHORT $LN31@remove_ver
	mov	eax, DWORD PTR tv604[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN32@remove_ver
$LN31@remove_ver:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN32@remove_ver:
	push	eax
	push	OFFSET ??_C@_0DB@GNDIKONM@Internal?5error?3?5Vertex?5?$CFs?5edge?5l@
	push	OFFSET _errmsg
	call	_sprintf

; 3943 :         kb_error(1376,errmsg, WARNING);

	push	2
	push	OFFSET _errmsg
	push	1376					; 00000560H
	call	_kb_error
	mov	ecx, DWORD PTR _web+124
	add	esp, 24					; 00000018H
$LN10@remove_ver:

; 3944 :         break;
; 3945 :       }
; 3946 :     }
; 3947 :   set_next_tail_edge(eee_id,ee_id);

	mov	edx, esi
	shr	edx, 27					; 0000001bH
	and	edx, 1
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [eax+edx*4+32], edi

; 3948 :   set_next_tail_edge(e_id,e_id);

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv580[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR tv577[ebp]
	mov	DWORD PTR [eax+ecx*4+32], ebx

; 3949 :   set_vertex_edge(v_id,ee_id);

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR tv604[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx+28], edi

; 3950 :   
; 3951 :   /* clean up in case of constraint content quantities */
; 3952 :   if ( everything_quantities_flag && (web.representation == STRING) )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN1@remove_ver
	cmp	DWORD PTR _web+624, 1
	jne	$LN1@remove_ver

; 3953 :   { int k,n;
; 3954 :     conmap_t *map = get_v_constraint_map(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	cmp	DWORD PTR [ecx+edx+1288], 0
	je	SHORT $LN33@remove_ver
	mov	esi, DWORD PTR _web+12
	mov	edi, DWORD PTR [esi+eax*4]
	add	edi, DWORD PTR [ecx+edx+1264]
	jmp	SHORT $LN34@remove_ver
$LN33@remove_ver:
	mov	edi, OFFSET _nullcon
$LN34@remove_ver:
	mov	eax, DWORD PTR [edi]

; 3955 :     #define MAXTODO 10
; 3956 :     conmap_t to_do[MAXTODO]; 
; 3957 :     /* make list since unset and set can change order in map */
; 3958 :     for ( k = 1, n = 0; k <= (int)*map ; k++ )

	mov	esi, 1
	xor	ebx, ebx

; 3965 :     { unset_v_constraint_map(v_id,to_do[k]);

	mov	DWORD PTR $T93384[ebp], eax
	cmp	eax, esi
	jl	SHORT $LN5@remove_ver
	npad	5
$LL7@remove_ver:

; 3959 :     { int connum = map[k]&CONMASK;

	mov	ecx, DWORD PTR [edi+esi*4]

; 3960 :       struct constraint *con = get_constraint(connum);
; 3961 :       if ( (con->attr & CON_CONTENT) && (n < MAXTODO) )

	mov	edx, DWORD PTR _web+652
	and	ecx, 1073741823				; 3fffffffH
	mov	eax, ecx
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	mov	eax, DWORD PTR [eax+edx+32]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN6@remove_ver
	cmp	ebx, 10					; 0000000aH
	jge	SHORT $LN6@remove_ver

; 3962 :         to_do[n++] = connum;

	mov	DWORD PTR _to_do$91673[ebp+ebx*4], ecx
	inc	ebx
$LN6@remove_ver:

; 3955 :     #define MAXTODO 10
; 3956 :     conmap_t to_do[MAXTODO]; 
; 3957 :     /* make list since unset and set can change order in map */
; 3958 :     for ( k = 1, n = 0; k <= (int)*map ; k++ )

	inc	esi
	cmp	esi, DWORD PTR $T93384[ebp]
	jle	SHORT $LL7@remove_ver
$LN5@remove_ver:

; 3963 :     }
; 3964 :     for ( k = 0 ; k < n ; k++ )

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN1@remove_ver
$LL3@remove_ver:

; 3965 :     { unset_v_constraint_map(v_id,to_do[k]);

	mov	edi, DWORD PTR _to_do$91673[ebp+esi*4]
	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	edi
	push	eax
	call	_unset_v_constraint_map

; 3966 :       set_v_constraint_map(v_id,to_do[k]);

	mov	ecx, DWORD PTR _v_id$GSCopy$[ebp]
	push	edi
	push	ecx
	call	_set_v_constraint_map
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, ebx
	jl	SHORT $LL3@remove_ver
$LN1@remove_ver:

; 3967 :     }  
; 3968 :    }
; 3969 : 
; 3970 : } /* end remove_vertex_edge() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_remove_vertex_edge ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DJ@LHGHFCHL@Internal?5error?3?5get_next_vertex_@ ; `string'
PUBLIC	_get_simplex_next_vertex_facet
;	COMDAT ??_C@_0DJ@LHGHFCHL@Internal?5error?3?5get_next_vertex_@
CONST	SEGMENT
??_C@_0DJ@LHGHFCHL@Internal?5error?3?5get_next_vertex_@ DB 'Internal erro'
	DB	'r: get_next_vertex_facet failure v %s f %s', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_simplex_next_vertex_facet
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_f_id$ = 12						; size = 4
_get_simplex_next_vertex_facet PROC			; COMDAT

; 4175 : { int i;

	push	ebp
	mov	ebp, esp

; 4176 :   vertex_id *v = get_facet_vertices(f_id);

	mov	edx, DWORD PTR _f_id$[ebp]
	mov	eax, DWORD PTR _web+236
	push	ebx

; 4177 :   facet_id *f = F_ELID(f_id,F_NEXT_VFACET_ATTR);
; 4178 :   int vmax = web.skel[FACET].ctrlpts;
; 4179 : 
; 4180 :   for ( i = 0 ; i < vmax ; i++ )

	mov	ebx, DWORD PTR _v_id$[ebp]
	push	esi
	mov	esi, DWORD PTR _web+328
	push	edi
	mov	edi, DWORD PTR _dymem
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+edi+304]
	mov	esi, DWORD PTR [esi+edi+1024]
	mov	edi, DWORD PTR _web+232
	add	eax, ecx
	add	esi, ecx
	xor	ecx, ecx
	test	edi, edi
	jle	SHORT $LN2@get_simple
$LL4@get_simple:

; 4181 :      if (equal_id(v_id,v[i]))  return f[i] ;

	cmp	ebx, DWORD PTR [eax+ecx*4]
	je	SHORT $LN12@get_simple

; 4177 :   facet_id *f = F_ELID(f_id,F_NEXT_VFACET_ATTR);
; 4178 :   int vmax = web.skel[FACET].ctrlpts;
; 4179 : 
; 4180 :   for ( i = 0 ; i < vmax ; i++ )

	inc	ecx
	cmp	ecx, edi
	jl	SHORT $LL4@get_simple
$LN2@get_simple:

; 4182 :   sprintf(errmsg,"Internal error: get_next_vertex_facet failure v %s f %s\n",
; 4183 :       ELNAME(v_id), ELNAME1(f_id));

	test	DWORD PTR _f_id$[ebp], 268435456	; 10000000H
	je	SHORT $LN7@get_simple
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN8@get_simple
$LN12@get_simple:

; 4181 :      if (equal_id(v_id,v[i]))  return f[i] ;

	mov	eax, DWORD PTR [esi+ecx*4]
	pop	edi
	pop	esi
	pop	ebx

; 4187 : } // end get_simplex_next_vertex_facet()

	pop	ebp
	ret	0
$LN7@get_simple:

; 4182 :   sprintf(errmsg,"Internal error: get_next_vertex_facet failure v %s f %s\n",
; 4183 :       ELNAME(v_id), ELNAME1(f_id));

	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN8@get_simple:
	test	ebx, 268435456				; 10000000H
	je	SHORT $LN9@get_simple
	and	ebx, 134217727				; 07ffffffH
	inc	ebx
	push	ebx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN10@get_simple
$LN9@get_simple:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN10@get_simple:
	push	esi
	push	eax
	push	OFFSET ??_C@_0DJ@LHGHFCHL@Internal?5error?3?5get_next_vertex_@
	push	OFFSET _errmsg
	call	_sprintf

; 4184 :   kb_error(1306,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1306					; 0000051aH
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi

; 4185 : 
; 4186 :   return NULLID;

	xor	eax, eax
	pop	ebx

; 4187 : } // end get_simplex_next_vertex_facet()

	pop	ebp
	ret	0
_get_simplex_next_vertex_facet ENDP
_TEXT	ENDS
PUBLIC	_set_next_vertex_facet
; Function compile flags: /Ogtp
;	COMDAT _set_next_vertex_facet
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_f_id$ = 12						; size = 4
_ff_id$ = 16						; size = 4
_set_next_vertex_facet PROC				; COMDAT

; 4197 : {

	push	ebp
	mov	ebp, esp

; 4198 :    vertex_id *v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	push	esi
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+esi+304]

; 4199 :    facet_id *f = F_ELID(f_id,F_NEXT_VFACET_ATTR);

	mov	edx, DWORD PTR [edx+esi+1024]

; 4200 :    int vmax = web.skel[FACET].ctrlpts;

	mov	esi, DWORD PTR _web+232
	add	ecx, eax
	add	edx, eax

; 4201 :    int i;
; 4202 :    for ( i = 0 ; i < vmax ; i++ )

	xor	eax, eax
	test	esi, esi
	jle	SHORT $LN2@set_next_v
	push	edi
	mov	edi, DWORD PTR _v_id$[ebp]
$LL4@set_next_v:

; 4203 :    { if (equal_id(v_id,v[i]))

	cmp	edi, DWORD PTR [ecx+eax*4]
	je	SHORT $LN8@set_next_v

; 4201 :    int i;
; 4202 :    for ( i = 0 ; i < vmax ; i++ )

	inc	eax
	cmp	eax, esi
	jl	SHORT $LL4@set_next_v
	pop	edi
	pop	esi

; 4205 :        break;
; 4206 :      }
; 4207 :    }
; 4208 : } // end set_next_vertex_facet()

	pop	ebp
	ret	0
$LN8@set_next_v:

; 4204 :      { f[i] = ff_id ;

	mov	ecx, DWORD PTR _ff_id$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
	pop	edi
$LN2@set_next_v:
	pop	esi

; 4205 :        break;
; 4206 :      }
; 4207 :    }
; 4208 : } // end set_next_vertex_facet()

	pop	ebp
	ret	0
_set_next_vertex_facet ENDP
_TEXT	ENDS
PUBLIC	_count_fixed_vol
; Function compile flags: /Ogtp
;	COMDAT _count_fixed_vol
_TEXT	SEGMENT
tv204 = -8						; size = 8
_count_fixed_vol PROC					; COMDAT

; 4224 : { int retval = 0;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	xor	eax, eax
	push	esi

; 4225 :   body_id bi_id;  /* identifier for body i */
; 4226 :   int n;
; 4227 :   struct gen_quant *gq;
; 4228 : 
; 4229 :   if ( !everything_quantities_flag && !web.pressure_flag )

	cmp	DWORD PTR _everything_quantities_flag, eax
	jne	SHORT $LN9@count_fixe
	cmp	DWORD PTR _web+868, eax
	jne	SHORT $LN9@count_fixe

; 4230 :   { FOR_ALL_BODIES(bi_id)

	mov	ecx, DWORD PTR _web+384
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN9@count_fixe
	push	ebx
	mov	ebx, DWORD PTR _web+348
	push	edi
	npad	1
$LL11@count_fixe:
	and	ecx, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR tv204[ebp+4], ecx
	mov	ecx, edx
	and	ecx, 1
	xor	edi, edi
	or	ecx, edi
	je	SHORT $LN10@count_fixe

; 4231 :        if ( get_battr(bi_id) & (FIXEDVOL) ) retval++;

	and	edx, 32					; 00000020H
	xor	ecx, ecx
	or	edx, ecx
	je	SHORT $LN10@count_fixe
	inc	eax
$LN10@count_fixe:

; 4230 :   { FOR_ALL_BODIES(bi_id)

	mov	ecx, DWORD PTR [esi]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL11@count_fixe
	pop	edi
	pop	ebx
$LN9@count_fixe:

; 4232 :   }
; 4233 :   for (  n = 0 ; n < gen_quant_count ; n++ )

	mov	ecx, DWORD PTR _web+5528
	test	ecx, ecx
	jle	SHORT $LN3@count_fixe
	mov	edx, DWORD PTR _gen_quant_list
	add	edx, 136				; 00000088H
	mov	esi, ecx
	npad	5
$LL5@count_fixe:

; 4234 :   { gq = GEN_QUANT(n);
; 4235 :     if ( gq->flags & Q_DELETED ) continue;

	mov	ecx, DWORD PTR [edx]
	test	ecx, 524288				; 00080000H
	jne	SHORT $LN4@count_fixe

; 4236 :     if ( gq->flags & (Q_FIXED|Q_CONSERVED) )

	test	cl, 10					; 0000000aH
	je	SHORT $LN4@count_fixe

; 4237 :         retval++;

	inc	eax
$LN4@count_fixe:

; 4232 :   }
; 4233 :   for (  n = 0 ; n < gen_quant_count ; n++ )

	add	edx, 368				; 00000170H
	dec	esi
	jne	SHORT $LL5@count_fixe
$LN3@count_fixe:
	pop	esi

; 4238 :   }
; 4239 :   return retval;
; 4240 : } // end  count_fixed_vol()

	mov	esp, ebp
	pop	ebp
	ret	0
_count_fixed_vol ENDP
_TEXT	ENDS
PUBLIC	_sgenrand
_BSS	SEGMENT
_ptgfsr	DD	0270H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _sgenrand
_TEXT	SEGMENT
_seed$ = 8						; size = 4
_sgenrand PROC						; COMDAT

; 4301 : {

	push	ebp
	mov	ebp, esp

; 4302 :   int k;
; 4303 :   
; 4304 :   /* setting initial seeds to ptgfsr[N] using     */
; 4305 :   /* the generator Line 25 of Table 1 in      */
; 4306 :   /* [KNUTH 1981, The Art of Computer Programming */
; 4307 :   /*    Vol. 2 (2nd Ed.), pp102]          */
; 4308 : 
; 4309 :   ptgfsr[0]= seed & 0xffffffff;

	mov	eax, DWORD PTR _seed$[ebp]
	mov	DWORD PTR _ptgfsr, eax
	mov	eax, OFFSET _ptgfsr+4
$LL3@sgenrand:

; 4310 :   for (k=1; k<N; k++)
; 4311 :     ptgfsr[k] = (69069 * ptgfsr[k-1]) & 0xffffffff;

	mov	ecx, DWORD PTR [eax-4]
	imul	ecx, 69069				; 00010dcdH
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	cmp	eax, OFFSET _ptgfsr+2496
	jl	SHORT $LL3@sgenrand

; 4312 : } // end sgenrand()

	pop	ebp
	ret	0
_sgenrand ENDP
_TEXT	ENDS
PUBLIC	__real@3df0000000000000
PUBLIC	_kb_initr
_BSS	SEGMENT
_initflag DD	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@3df0000000000000
CONST	SEGMENT
__real@3df0000000000000 DQ 03df0000000000000r	; 2.32831e-010
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _kb_initr
_TEXT	SEGMENT
_ind$ = 8						; size = 4
_kb_initr PROC						; COMDAT

; 4319 : { sgenrand((unsigned long)ind); 

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _ind$[ebp]
	push	eax
	call	_sgenrand

; 4320 :   rfactor = 1.0/( (REAL)0xffffffff + 1.0) ;

	fld	QWORD PTR __real@3df0000000000000
	fstp	QWORD PTR _rfactor
	add	esp, 4

; 4321 :   initflag = 1;

	mov	DWORD PTR _initflag, 1

; 4322 :   k = N; kr = NR;

	mov	DWORD PTR _k, 624			; 00000270H
	mov	DWORD PTR _kr, 312			; 00000138H

; 4323 : }

	pop	ebp
	ret	0
_kb_initr ENDP
_TEXT	ENDS
PUBLIC	_kb_drand
_BSS	SEGMENT
	ALIGN	8

_drands	DQ	0138H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _kb_drand
_TEXT	SEGMENT
tv744 = -4						; size = 4
tv741 = -4						; size = 4
_kb_drand PROC						; COMDAT

; 4332 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4333 :   unsigned long y;
; 4334 :   /* mag01[x] = x * MATRIX_A  for x=0,1 */
; 4335 :   
; 4336 :   if(kr == NR){ /* generate N words at one time, and NR drands */

	mov	eax, DWORD PTR _kr
	cmp	eax, 312				; 00000138H
	jne	$LN14@kb_drand

; 4337 :     int kk;
; 4338 :     if ( initflag == 0 ) kb_initr(1);

	cmp	DWORD PTR _initflag, 0
	jne	SHORT $LN13@kb_drand
	push	1
	call	_kb_initr
	add	esp, 4
$LN13@kb_drand:

; 4339 :     for (kk=0;kk<N-M;kk++) {

	xor	ecx, ecx
	npad	7
$LL12@kb_drand:

; 4340 :       y = (ptgfsr[kk]&UPPER_MASK)|(ptgfsr[kk+1]&LOWER_MASK);

	mov	eax, DWORD PTR _ptgfsr[ecx*4+4]
	xor	eax, DWORD PTR _ptgfsr[ecx*4]
	inc	ecx
	and	eax, 2147483647				; 7fffffffH
	xor	eax, DWORD PTR _ptgfsr[ecx*4-4]

; 4341 :       ptgfsr[kk] = ptgfsr[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];

	mov	edx, eax
	shr	eax, 1
	and	edx, 1
	xor	eax, DWORD PTR _mag01[edx*4]
	xor	eax, DWORD PTR _ptgfsr[ecx*4+1584]
	mov	DWORD PTR _ptgfsr[ecx*4-4], eax
	cmp	ecx, 227				; 000000e3H
	jl	SHORT $LL12@kb_drand

; 4342 :     }
; 4343 :     for (;kk<N-1;kk++) {

	cmp	ecx, 623				; 0000026fH
	jge	SHORT $LN7@kb_drand
	lea	ecx, DWORD PTR _ptgfsr[ecx*4]
	npad	2
$LL9@kb_drand:

; 4344 :       y = (ptgfsr[kk]&UPPER_MASK)|(ptgfsr[kk+1]&LOWER_MASK);

	mov	eax, DWORD PTR [ecx]
	xor	eax, DWORD PTR [ecx+4]
	add	ecx, 4
	and	eax, 2147483647				; 7fffffffH
	xor	eax, DWORD PTR [ecx-4]

; 4345 :       ptgfsr[kk] = ptgfsr[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];

	mov	edx, eax
	and	edx, 1
	mov	edx, DWORD PTR _mag01[edx*4]
	xor	edx, DWORD PTR [ecx-912]
	shr	eax, 1
	xor	edx, eax
	mov	DWORD PTR [ecx-4], edx
	cmp	ecx, OFFSET _ptgfsr+2492
	jl	SHORT $LL9@kb_drand
$LN7@kb_drand:

; 4346 :     }
; 4347 :     y = (ptgfsr[N-1]&UPPER_MASK)|(ptgfsr[0]&LOWER_MASK);

	mov	ecx, DWORD PTR _ptgfsr+2492
	mov	eax, DWORD PTR _ptgfsr
	xor	eax, ecx
	and	eax, 2147483647				; 7fffffffH
	xor	eax, ecx

; 4348 :     ptgfsr[N-1] = ptgfsr[M-1] ^ (y >> 1) ^ mag01[y & 0x1];

	mov	ecx, eax
	and	ecx, 1
	shr	eax, 1
	xor	eax, DWORD PTR _mag01[ecx*4]
	mov	ecx, OFFSET _ptgfsr
	xor	eax, DWORD PTR _ptgfsr+1584
	mov	DWORD PTR _ptgfsr+2492, eax
$LL6@kb_drand:

; 4349 : 
; 4350 :     for ( k = 0 ; k < N ; k++ )
; 4351 :     { y = ptgfsr[k];

	mov	eax, DWORD PTR [ecx]

; 4352 :       y ^= TEMPERING_SHIFT_U(y);

	mov	edx, eax
	shr	edx, 11					; 0000000bH
	xor	eax, edx

; 4353 :       y ^= TEMPERING_SHIFT_S(y) & TEMPERING_MASK_B;

	mov	edx, eax
	and	edx, -12953427				; ff3a58adH
	shl	edx, 7
	xor	eax, edx

; 4354 :       y ^= TEMPERING_SHIFT_T(y) & TEMPERING_MASK_C;

	mov	edx, eax
	and	edx, -8308				; ffffdf8cH
	shl	edx, 15					; 0000000fH
	xor	eax, edx

; 4355 :       y &= 0xffffffff; /* you may delete this line if word size = 32 */
; 4356 :       y ^= TEMPERING_SHIFT_L(y);

	mov	edx, eax
	shr	edx, 18					; 00000012H
	xor	edx, eax

; 4357 :       ptgfsr[k] = y;

	mov	DWORD PTR [ecx], edx
	add	ecx, 4
	cmp	ecx, OFFSET _ptgfsr+2496
	jl	SHORT $LL6@kb_drand

; 4358 :     }
; 4359 : 
; 4360 :     for ( kr = 0 ; kr < NR ; kr++ )

	fld	QWORD PTR _rfactor
	xor	eax, eax
$LN3@kb_drand:

; 4361 :       drands[kr] = (ptgfsr[2*kr]*rfactor + ptgfsr[2*kr+1])*rfactor;

	mov	ecx, DWORD PTR _ptgfsr[eax]
	fild	DWORD PTR _ptgfsr[eax]
	test	ecx, ecx
	jns	SHORT $LN28@kb_drand
	fadd	QWORD PTR __real@41f0000000000000
$LN28@kb_drand:
	mov	edx, DWORD PTR _ptgfsr[eax+4]
	fmul	ST(0), ST(1)
	fild	DWORD PTR _ptgfsr[eax+4]
	test	edx, edx
	jns	SHORT $LN29@kb_drand
	fadd	QWORD PTR __real@41f0000000000000
$LN29@kb_drand:
	faddp	ST(1), ST(0)
	add	eax, 8
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _drands[eax-8]
	cmp	eax, 2496				; 000009c0H
	jl	SHORT $LN3@kb_drand

; 4362 :     
; 4363 :     k = 0;

	fstp	ST(0)
	mov	DWORD PTR _k, 0

; 4364 :     kr = 0;

	xor	eax, eax
$LN14@kb_drand:

; 4365 :   }
; 4366 :   
; 4367 :   return drands[kr++];

	fld	QWORD PTR _drands[eax*8]
	inc	eax
	mov	DWORD PTR _kr, eax

; 4368 : } // end kb_drand()

	mov	esp, ebp
	pop	ebp
	ret	0
_kb_drand ENDP
_TEXT	ENDS
PUBLIC	_drand48
; Function compile flags: /Ogtp
;	COMDAT _drand48
_TEXT	SEGMENT
_drand48 PROC						; COMDAT

; 4373 : { return (double)kb_drand(); }

	jmp	_kb_drand
_drand48 ENDP
_TEXT	ENDS
PUBLIC	_srand48
; Function compile flags: /Ogtp
;	COMDAT _srand48
_TEXT	SEGMENT
_seed$ = 8						; size = 4
_srand48 PROC						; COMDAT

; 4375 : { kb_initr(seed); }

	push	ebp
	mov	ebp, esp
	pop	ebp
	jmp	_kb_initr
_srand48 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EA@EENNBCHN@Can?5only?5do?5vertex?5wrap?5in?5LINEA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	_wrap_vertex
;	COMDAT ??_C@_0EA@EENNBCHN@Can?5only?5do?5vertex?5wrap?5in?5LINEA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0EA@EENNBCHN@Can?5only?5do?5vertex?5wrap?5in?5LINEA@ DB 'Can only d'
	DB	'o vertex wrap in LINEAR and QUADRATIC models so far.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\utility.c
CONST	ENDS
;	COMDAT _wrap_vertex
_TEXT	SEGMENT
_start_e$ = -60						; size = 4
_did_graphlock_here$91920 = -56				; size = 4
_newx$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_wrap$ = 12						; size = 4
_wrap_vertex PROC					; COMDAT

; 4389 : { int i;

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _v_id$[ebp]

; 4390 :   REAL newx[MAXCOORD];
; 4391 :   REAL *x = get_coord(v_id);

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	push	esi
	add	eax, eax
	push	edi
	lea	edi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _web+12
	mov	esi, DWORD PTR [edi+eax]

; 4392 :   edge_id e_id,start_e;
; 4393 : 
; 4394 :   if ( (web.modeltype != LINEAR) && (web.modeltype != QUADRATIC) )

	mov	eax, DWORD PTR _web+628
	add	esi, DWORD PTR [ecx+edx+64]
	cmp	eax, 1
	je	SHORT $LN34@wrap_verte
	cmp	eax, 2
	je	SHORT $LN34@wrap_verte

; 4395 :     kb_error(6016,
; 4396 :       "Can only do vertex wrap in LINEAR and QUADRATIC models so far.\n",
; 4397 :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0EA@EENNBCHN@Can?5only?5do?5vertex?5wrap?5in?5LINEA@
	push	6016					; 00001780H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN34@wrap_verte:

; 4398 : 
; 4399 :   if ( !web.symmetry_flag ) return;

	cmp	DWORD PTR _web+856, 0
	je	$LN1@wrap_verte

; 4400 :   if ( get_vattr(v_id) & (Q_MIDPOINT|Q_MIDEDGE|Q_MIDFACET) ) return;

	mov	eax, DWORD PTR _web+12
	mov	eax, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 6422528				; 00620000H
	xor	ecx, ecx
	or	eax, ecx
	jne	$LN1@wrap_verte

; 4401 : 
; 4402 :   ENTER_GRAPH_MUTEX;

	push	ebx
	mov	ebx, DWORD PTR __imp__GetCurrentThreadId@0
	call	ebx
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN13@wrap_verte
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	ebx
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$91920[ebp], 1
	jmp	SHORT $LN12@wrap_verte
$LN13@wrap_verte:
	mov	DWORD PTR _did_graphlock_here$91920[ebp], 0
$LN12@wrap_verte:

; 4403 :   sym_wrap(x,newx,wrap);

	mov	ecx, DWORD PTR _wrap$[ebp]
	push	ecx
	lea	edx, DWORD PTR _newx$[ebp]
	push	edx
	push	esi
	call	DWORD PTR _sym_wrap

; 4404 :   for ( i = 0 ; i < SDIM ; i++ ) x[i] = newx[i];

	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN9@wrap_verte
	lea	edx, DWORD PTR _newx$[ebp]
	mov	eax, esi
	sub	edx, esi
$LL11@wrap_verte:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL11@wrap_verte
$LN9@wrap_verte:

; 4405 :   start_e = e_id = get_vertex_edge(v_id);

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR _web+124
	mov	DWORD PTR _start_e$[ebp], eax
	npad	9
$LL8@wrap_verte:

; 4406 :   do
; 4407 :   { set_edge_wrap(e_id,sym_compose(wrap,get_edge_wrap(e_id)));

	mov	edi, DWORD PTR _dymem
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edi+784]
	mov	ecx, DWORD PTR [edx+ecx]
	shr	eax, 27					; 0000001bH
	mov	ebx, eax
	and	ebx, 1
	je	SHORT $LN21@wrap_verte
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN22@wrap_verte
$LN21@wrap_verte:
	mov	eax, ecx
$LN22@wrap_verte:
	mov	edx, DWORD PTR _wrap$[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose
	add	esp, 8
	test	ebx, ebx
	je	SHORT $LN25@wrap_verte
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN25@wrap_verte:
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR _web+216
	mov	edi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edi+784]
	mov	DWORD PTR [edx+ecx], eax

; 4408 :     if ( (web.modeltype == QUADRATIC) && !inverted(e_id) )

	cmp	DWORD PTR _web+628, 2
	jne	SHORT $LN35@wrap_verte
	test	ebx, ebx
	jne	SHORT $LN35@wrap_verte

; 4409 :     { x = get_coord(get_edge_midv(e_id));

	mov	edx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+eax+304]
	mov	ecx, DWORD PTR [ecx+edx+8]
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+104
	add	edi, DWORD PTR [ecx+eax+64]

; 4410 :       sym_wrap(x,newx,wrap);

	mov	edx, DWORD PTR _wrap$[ebp]
	push	edx
	lea	eax, DWORD PTR _newx$[ebp]
	push	eax
	push	edi
	call	DWORD PTR _sym_wrap

; 4411 :       for ( i = 0 ; i < SDIM ; i++ ) x[i] = newx[i];

	xor	ecx, ecx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN35@wrap_verte
	lea	edx, DWORD PTR _newx$[ebp]
	mov	eax, edi
	sub	edx, edi
$LL4@wrap_verte:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL4@wrap_verte
$LN35@wrap_verte:

; 4412 :     }
; 4413 :     e_id = get_next_tail_edge(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+ebx*4+32]

; 4414 :   } while ( !equal_id(start_e,e_id) );

	cmp	DWORD PTR _start_e$[ebp], eax
	jne	$LL8@wrap_verte

; 4415 :   LEAVE_GRAPH_MUTEX;

	cmp	DWORD PTR _did_graphlock_here$91920[ebp], 0
	pop	ebx
	je	SHORT $LN1@wrap_verte
	mov	eax, DWORD PTR _graphmutex
	push	eax
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN1@wrap_verte:

; 4416 : } // end void wrap_vertex()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_wrap_vertex ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@JGDFDOGK@dy_realloc?5?$AA@		; `string'
PUBLIC	_dy_realloc
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0M@JGDFDOGK@dy_realloc?5?$AA@
CONST	SEGMENT
??_C@_0M@JGDFDOGK@dy_realloc?5?$AA@ DB 'dy_realloc ', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _dy_realloc
_TEXT	SEGMENT
_did_graphlock_here$89527 = -4				; size = 4
_old$ = 8						; size = 4
_newnum$ = 12						; size = 4
_newsize$ = 16						; size = 4
_dy_realloc PROC					; COMDAT

; 1138 : { DY_OFFSET newspot;

	push	ebp
	mov	ebp, esp
	push	ecx

; 1139 :   struct dy_head *ptr;
; 1140 :   int i;
; 1141 : 
; 1142 :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	je	SHORT $LN10@dy_realloc

; 1143 :   { erroutstring("dy_realloc "); }

	push	OFFSET ??_C@_0M@JGDFDOGK@dy_realloc?5?$AA@
	call	_erroutstring
	add	esp, 4
$LN10@dy_realloc:

; 1144 : 
; 1145 :   ENTER_GRAPH_MUTEX

	push	esi
	mov	esi, DWORD PTR __imp__GetCurrentThreadId@0
	call	esi
	cmp	DWORD PTR _locking_thread, eax
	je	SHORT $LN9@dy_realloc
	push	0
	push	100000					; 000186a0H
	push	0
	push	OFFSET _graphmutex
	push	1
	call	DWORD PTR __imp__MsgWaitForMultipleObjects@20
	call	esi
	mov	DWORD PTR _locking_thread, eax
	mov	DWORD PTR _did_graphlock_here$89527[ebp], 1
	jmp	SHORT $LN8@dy_realloc
$LN9@dy_realloc:
	mov	DWORD PTR _did_graphlock_here$89527[ebp], 0
$LN8@dy_realloc:

; 1146 :   newspot = dy_calloc(newnum,newsize);

	mov	eax, DWORD PTR _newnum$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _newsize$[ebp]
	push	ebx
	push	eax
	call	_dy_calloc
	mov	esi, eax

; 1147 :   if ( old )

	mov	eax, DWORD PTR _old$[ebp]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN7@dy_realloc

; 1148 :   { ptr = (struct dy_head *)(dymem + old) - 1;

	push	edi
	mov	edi, DWORD PTR _dymem

; 1149 :     if ( ptr->size < newnum*newsize )

	mov	edx, DWORD PTR [edi+eax-24]
	lea	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR _newnum$[ebp]
	imul	eax, ebx

; 1150 :       memcpy(dymem+newspot,dymem+old,ptr->size);

	add	edi, esi
	cmp	edx, eax
	jge	SHORT $LN6@dy_realloc
	push	edx
	jmp	SHORT $LN21@dy_realloc
$LN6@dy_realloc:

; 1151 :     else  memcpy(dymem+newspot,dymem+old,newnum*newsize);

	push	eax
$LN21@dy_realloc:
	push	ecx
	push	edi
	call	_memcpy

; 1152 :     dy_free(old);

	mov	ecx, DWORD PTR _old$[ebp]
	add	esp, 12					; 0000000cH
	push	ecx
	call	_dy_free
	add	esp, 4
	pop	edi
$LN7@dy_realloc:

; 1153 :   }
; 1154 :   LEAVE_GRAPH_MUTEX

	cmp	DWORD PTR _did_graphlock_here$89527[ebp], 0
	pop	ebx
	je	SHORT $LN4@dy_realloc
	mov	edx, DWORD PTR _graphmutex
	push	edx
	mov	DWORD PTR _locking_thread, 0
	call	DWORD PTR __imp__ReleaseMutex@4
$LN4@dy_realloc:

; 1155 : 
; 1156 :   /* some handy debugging equivalences */
; 1157 :   Globals = (struct global **)(dymem + dy_globals);

	mov	eax, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+5652

; 1158 :   for ( i = 0 ; i < NUMELEMENTS ; i++ )
; 1159 :        Extras[i] = EXTRAS(i);

	mov	edx, DWORD PTR _web+104
	add	ecx, eax
	add	edx, eax
	mov	DWORD PTR _Globals, ecx
	mov	ecx, DWORD PTR _web+216
	mov	DWORD PTR _Extras, edx
	mov	edx, DWORD PTR _web+328
	add	ecx, eax
	add	edx, eax
	mov	DWORD PTR _Extras+4, ecx
	mov	ecx, DWORD PTR _web+440
	mov	DWORD PTR _Extras+8, edx
	mov	edx, DWORD PTR _web+552
	add	ecx, eax
	add	edx, eax

; 1160 : 
; 1161 : #ifdef _DEBUG
; 1162 : dy_check();
; 1163 : #endif
; 1164 :   return newspot;

	mov	eax, esi
	mov	DWORD PTR _Extras+12, ecx
	mov	DWORD PTR _Extras+16, edx
	pop	esi

; 1165 : } // end dy_realloc()

	mov	esp, ebp
	pop	ebp
	ret	0
_dy_realloc ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_calc_edge
EXTRN	_edge_ctrl:DWORD
EXTRN	_gauss1polyd:DWORD
EXTRN	_vec_mat_mul:PROC
EXTRN	_gauss1Dwt:DWORD
EXTRN	_gauss1Dpt:DWORD
EXTRN	_gauss1D_num:DWORD
EXTRN	_klein_length:PROC
EXTRN	_klein_metric_flag:DWORD
EXTRN	_instance_attribute:PROC
EXTRN	_length_method_number:DWORD
; Function compile flags: /Ogtp
;	COMDAT _calc_edge
_TEXT	SEGMENT
_xqXvS$89668 = -1304					; size = 12
_euclidean$ = -1300					; size = 8
_sum$89646 = -1292					; size = 8
tv548 = -1284						; size = 4
_i$ = -1280						; size = 4
_k$ = -1276						; size = 4
_len$ = -1272						; size = 8
tv1424 = -1264						; size = 4
_ctrl$89691 = -1264					; size = 4
_xt$ = -1264						; size = 4
tv997 = -1260						; size = 4
_x$89670 = -1260					; size = 4
tv1381 = -1256						; size = 4
tv995 = -1256						; size = 4
tv433 = -1256						; size = 4
_xxJ$89687 = -1252					; size = 960
_xxJ$89669 = -292					; size = 144
_xqXvS$89686 = -228					; size = 80
_midx$ = -148						; size = 48
_s$ = -100						; size = 48
_tang$89690 = -52					; size = 48
_tang$89672 = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_e_id$ = 8						; size = 4
_calc_edge PROC						; COMDAT

; 1301 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1304				; 00000518H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1302 :   REAL len=0.0;
; 1303 :   REAL s[MAXCOORD];
; 1304 :   REAL midx[MAXCOORD];
; 1305 :   int i,j,k;
; 1306 :   vertex_id tv = get_edge_tailv(e_id);

	mov	ecx, DWORD PTR _web+124
	fldz
	push	esi
	fstp	QWORD PTR _len$[ebp]
	push	edi
	mov	edi, DWORD PTR _e_id$[ebp]
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR tv548[ebp], eax
	mov	eax, DWORD PTR _web+216
	test	edi, 134217728				; 08000000H
	je	SHORT $LN43@calc_edge
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN42@calc_edge
$LN43@calc_edge:
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]
$LN42@calc_edge:

; 1307 :   REAL *xt=get_coord(tv);

	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	esi, DWORD PTR [eax+ecx+64]

; 1308 :   REAL euclidean;
; 1309 : 
; 1310 :   if ( everything_quantities_flag ) 

	cmp	DWORD PTR _everything_quantities_flag, 0
	mov	DWORD PTR _xt$[ebp], esi
	je	SHORT $LN39@calc_edge

; 1311 :   { instance_attribute(e_id,length_method_number);

	mov	ecx, DWORD PTR _length_method_number
	push	ecx
	push	edi
	call	_instance_attribute
	fstp	ST(0)
	add	esp, 8
	pop	edi
	pop	esi

; 1382 : } // end calc_edge()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@calc_edge:

; 1312 :        /* legitimate methods set edge length */
; 1313 :     return;
; 1314 :   }
; 1315 : 
; 1316 :   get_edge_side(e_id,s);

	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	push	edi
	call	_get_edge_side

; 1317 :   euclidean = SDIM_dot(s,s);

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	fst	QWORD PTR _euclidean$[ebp]
	add	esp, 20					; 00000014H

; 1318 :   if ( klein_metric_flag )

	cmp	DWORD PTR _klein_metric_flag, 0
	je	SHORT $LN38@calc_edge

; 1319 :   { for ( i = 0 ; i < SDIM ; i++ ) midx[i] = xt[i] + s[i];/*unwrap head*/

	mov	edi, DWORD PTR _web+616
	fstp	ST(0)
	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN35@calc_edge
	mov	edx, esi
	lea	ecx, DWORD PTR _s$[ebp]
	sub	edx, ecx
$LL37@calc_edge:
	lea	ecx, DWORD PTR _s$[ebp+eax*8]
	fld	QWORD PTR [edx+ecx]
	inc	eax
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR _midx$[ebp+eax*8-8]
	cmp	eax, edi
	jl	SHORT $LL37@calc_edge
$LN35@calc_edge:

; 1320 :     len = klein_length(xt,midx);

	lea	edx, DWORD PTR _midx$[ebp]
	push	edx
	push	esi
	call	_klein_length
	add	esp, 8
	jmp	$LN16@calc_edge
$LN38@calc_edge:

; 1321 :   }
; 1322 :   else if ( web.metric_flag )

	cmp	DWORD PTR _web+1676, 0
	push	ebx
	je	$LN33@calc_edge
	fstp	ST(0)

; 1323 :   {
; 1324 :      /* energy due to linear tension, metric evaluated at midpoint */
; 1325 :      for ( k = 0, len = 0.0 ; k < gauss1D_num ; k++ )

	xor	edi, edi
	fldz
	mov	DWORD PTR _k$[ebp], edi
	fst	QWORD PTR _len$[ebp]
	cmp	DWORD PTR _gauss1D_num, edi
	jle	$LN76@calc_edge
	mov	ebx, DWORD PTR _web+616
	npad	1
$LL92@calc_edge:
	fstp	ST(0)

; 1326 :      { REAL sum;
; 1327 :        for ( i = 0 ; i < SDIM ; i++ )

	test	ebx, ebx
	jle	SHORT $LN27@calc_edge
	lea	ecx, DWORD PTR _s$[ebp]
	lea	edx, DWORD PTR _midx$[ebp]
	sub	ecx, esi
	mov	eax, esi
	sub	edx, esi
	mov	DWORD PTR tv433[ebp], ebx
	npad	5
$LL29@calc_edge:

; 1328 :           midx[i] = gauss1Dpt[k]*s[i] + xt[i];

	fld	QWORD PTR [ecx+eax]
	mov	esi, DWORD PTR _gauss1Dpt
	fmul	QWORD PTR [esi+edi*8]
	add	eax, 8
	dec	DWORD PTR tv433[ebp]
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [edx+eax-8]
	jne	SHORT $LL29@calc_edge

; 1326 :      { REAL sum;
; 1327 :        for ( i = 0 ; i < SDIM ; i++ )

	mov	esi, DWORD PTR _xt$[ebp]
$LN27@calc_edge:

; 1329 :        if ( web.conformal_flag )

	cmp	DWORD PTR _web+1680, 0
	je	SHORT $LN26@calc_edge

; 1330 :        { REAL gg = eval(&web.metric[0][0],midx,NULLID,NULL);

	push	0
	push	0
	lea	eax, DWORD PTR _midx$[ebp]
	push	eax
	push	OFFSET _web+1688
	call	_eval

; 1331 :          len += gauss1Dwt[k]*sqrt(gg*euclidean);

	fmul	QWORD PTR _euclidean$[ebp]
	add	esp, 16					; 00000010H
	call	__CIsqrt
	mov	ecx, DWORD PTR _gauss1Dwt
	fmul	QWORD PTR [ecx+edi*8]

; 1332 :        }
; 1333 :        else

	mov	ebx, DWORD PTR _web+616
	jmp	$LN127@calc_edge
$LN26@calc_edge:

; 1334 :        { for ( sum = 0.0, i = 0 ; i < SDIM ; i++ )

	fldz
	mov	DWORD PTR _i$[ebp], 0
	fst	QWORD PTR _sum$89646[ebp]
	test	ebx, ebx
	jle	$LN22@calc_edge
	lea	edx, DWORD PTR _s$[ebp]
	mov	DWORD PTR tv995[ebp], OFFSET _web+1688
	mov	DWORD PTR tv997[ebp], edx
$LN73@calc_edge:

; 1335 :          for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	ebx, ebx
	jle	SHORT $LN23@calc_edge
	mov	edi, DWORD PTR tv995[ebp]
	npad	3
$LL104@calc_edge:

; 1336 :           sum += s[i]*s[j]*eval(&web.metric[i][j],midx,NULLID,NULL);

	push	0
	fstp	ST(0)
	push	0
	lea	eax, DWORD PTR _midx$[ebp]
	push	eax
	push	edi
	call	_eval
	fld	QWORD PTR _s$[ebp+esi*8]
	mov	ecx, DWORD PTR tv997[ebp]
	fmul	QWORD PTR [ecx]
	mov	ebx, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	fmulp	ST(1), ST(0)
	add	edi, 104				; 00000068H
	fadd	QWORD PTR _sum$89646[ebp]
	fst	QWORD PTR _sum$89646[ebp]
	cmp	esi, ebx
	jl	SHORT $LL104@calc_edge

; 1335 :          for ( j = 0 ; j < SDIM ; j++ )

	mov	edi, DWORD PTR _k$[ebp]
$LN23@calc_edge:

; 1334 :        { for ( sum = 0.0, i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv997[ebp], 8
	add	DWORD PTR tv995[ebp], 624		; 00000270H
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, ebx
	jl	SHORT $LN73@calc_edge
	mov	esi, DWORD PTR _xt$[ebp]
$LN22@calc_edge:

; 1337 :          len += gauss1Dwt[k]*sqrt(sum);

	call	__CIsqrt
	mov	edx, DWORD PTR _gauss1Dwt
	fmul	QWORD PTR [edx+edi*8]
$LN127@calc_edge:
	fadd	QWORD PTR _len$[ebp]
	inc	edi
	mov	DWORD PTR _k$[ebp], edi
	fst	QWORD PTR _len$[ebp]
	cmp	edi, DWORD PTR _gauss1D_num
	jl	$LL92@calc_edge

; 1338 :        }
; 1339 :      }
; 1340 :   }
; 1341 :   else

	jmp	SHORT $LN76@calc_edge
$LN33@calc_edge:

; 1342 :   {
; 1343 :     switch (web.modeltype)

	mov	eax, DWORD PTR _web+628
	dec	eax
	je	$LN15@calc_edge
	dec	eax
	fstp	ST(0)
	je	$LN14@calc_edge
	dec	eax
	jne	SHORT $LN72@calc_edge

; 1361 :     case LAGRANGE:
; 1362 :     { /* tangent vectors at gauss points */
; 1363 :       int m;
; 1364 :       MAT2D(x,20,MAXCOORD);

	push	6
	push	20					; 00000014H
	lea	eax, DWORD PTR _xxJ$89687[ebp]
	push	eax
	lea	ecx, DWORD PTR _xqXvS$89686[ebp]
	push	ecx
	call	_mat2d_setup

; 1365 :       REAL tang[MAXCOORD];
; 1366 :       int ctrl = web.skel[EDGE].ctrlpts;
; 1367 :       struct gauss_lag *gl = &gauss_lagrange[1][web.gauss1D_order];
; 1368 :       len = 0.0;

	fldz
	mov	esi, DWORD PTR _web+1592
	fstp	QWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _web+120
	mov	ebx, eax

; 1369 :       get_edge_verts(e_id,x,NULL);

	push	0
	push	ebx
	shl	esi, 5
	add	esi, DWORD PTR _gauss_lagrange+4
	push	edi
	mov	DWORD PTR _ctrl$89691[ebp], edx
	call	_get_edge_verts

; 1370 :       for ( m = 0 ; m < gl->gnumpts ; m++ )

	xor	edi, edi
	add	esp, 28					; 0000001cH
	cmp	DWORD PTR [esi+4], edi
	jg	SHORT $LN3@calc_edge
$LN72@calc_edge:

; 1344 :     { case LINEAR: len = sqrt(euclidean); break;

	fld	QWORD PTR _len$[ebp]
$LN76@calc_edge:
	pop	ebx
$LN16@calc_edge:

; 1378 : 
; 1379 :    } /* end switch */
; 1380 :  }
; 1381 :  set_edge_length(e_id,len);

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR tv548[ebp]
	mov	eax, DWORD PTR [edx+ecx]

; 1382 : } // end calc_edge()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	QWORD PTR [eax+48]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	5
$LL107@calc_edge:

; 1370 :       for ( m = 0 ; m < gl->gnumpts ; m++ )

	fstp	ST(0)
$LN3@calc_edge:

; 1371 :       {  vec_mat_mul(gl->gpolypart[m][0],x,tang,ctrl,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _ctrl$89691[ebp]
	push	eax
	mov	eax, DWORD PTR [esi+24]
	push	ecx
	mov	ecx, DWORD PTR [eax+edi*4]
	lea	edx, DWORD PTR _tang$89690[ebp]
	push	edx
	mov	edx, DWORD PTR [ecx]
	push	ebx
	push	edx
	call	_vec_mat_mul

; 1372 :           len += gl->gausswt[m]*sqrt(SDIM_dot(tang,tang));

	mov	eax, DWORD PTR _web+616
	push	eax
	lea	ecx, DWORD PTR _tang$89690[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	add	esp, 32					; 00000020H
	call	__CIsqrt
	mov	eax, DWORD PTR [esi+12]
	fmul	QWORD PTR [eax+edi*8]
	inc	edi
	fadd	QWORD PTR _len$[ebp]
	fst	QWORD PTR _len$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL107@calc_edge

; 1373 :       }
; 1374 : 
; 1375 :     }
; 1376 : 
; 1377 :     break; 

	jmp	SHORT $LN76@calc_edge
$LN14@calc_edge:

; 1345 :       case QUADRATIC:
; 1346 :       { MAT2D(x,3,MAXCOORD);

	push	6
	push	3
	lea	ecx, DWORD PTR _xxJ$89669[ebp]
	push	ecx
	lea	edx, DWORD PTR _xqXvS$89668[ebp]
	push	edx
	call	_mat2d_setup

; 1347 :         REAL tang[MAXCOORD];
; 1348 :         int m;
; 1349 : 
; 1350 :         len = 0;

	fldz

; 1351 :         get_edge_verts(e_id,x,NULL);

	push	0
	fstp	QWORD PTR _len$[ebp]
	push	eax
	push	edi
	mov	DWORD PTR _x$89670[ebp], eax
	call	_get_edge_verts

; 1352 :         for ( m = 0 ; m < gauss1D_num ; m++ )

	xor	esi, esi
	add	esp, 28					; 0000001cH
	cmp	DWORD PTR _gauss1D_num, esi
	jle	$LN72@calc_edge
	jmp	SHORT $LN75@calc_edge
$LL125@calc_edge:
	fstp	ST(0)
$LN75@calc_edge:

; 1353 :         { for ( j = 0 ; j < SDIM ; j ++ )

	mov	eax, DWORD PTR _web+616
	xor	ecx, ecx
	test	eax, eax
	jle	$LN8@calc_edge
	mov	ebx, DWORD PTR _gauss1polyd
	fldz
$LN70@calc_edge:

; 1355 :             for ( k = 0 ; k < edge_ctrl ; k++ )

	xor	edi, edi
	fst	QWORD PTR _tang$89672[ebp+ecx*8]
	cmp	DWORD PTR _edge_ctrl, 4
	jl	$LC65@calc_edge

; 1356 :             tang[j] += gauss1polyd[k][m]*x[k][j];

	mov	eax, DWORD PTR _x$89670[ebp]
	mov	edi, ebx
	sub	edi, DWORD PTR _x$89670[ebp]
	add	eax, 4
	mov	DWORD PTR tv1381[ebp], edi
	mov	edi, DWORD PTR _edge_ctrl
	add	edi, -4					; fffffffcH
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv1424[ebp], edi
	add	edi, edi
	add	edi, edi
	lea	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR _k$[ebp], edi
$LN66@calc_edge:
	mov	edi, DWORD PTR [edx-12]
	fld	QWORD PTR [edi+esi*8]
	mov	ebx, DWORD PTR [eax-4]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	edi, DWORD PTR tv1381[ebp]
	add	eax, 16					; 00000010H
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv1424[ebp]
	fadd	QWORD PTR _tang$89672[ebp+ecx*8]
	fst	QWORD PTR _tang$89672[ebp+ecx*8]
	mov	edi, DWORD PTR [edi+eax-16]
	mov	ebx, DWORD PTR [eax-16]
	fld	QWORD PTR [edi+esi*8]
	fmul	QWORD PTR [ebx+ecx*8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$89672[ebp+ecx*8]
	mov	edi, DWORD PTR [edx-20]
	mov	ebx, DWORD PTR [eax-12]
	fld	QWORD PTR [edi+esi*8]
	fmul	QWORD PTR [ebx+ecx*8]
	faddp	ST(1), ST(0)
	fst	QWORD PTR _tang$89672[ebp+ecx*8]
	mov	edi, DWORD PTR [eax-8]
	mov	ebx, DWORD PTR [edx-16]
	fld	QWORD PTR [edi+ecx*8]
	fmul	QWORD PTR [ebx+esi*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _tang$89672[ebp+ecx*8]
	jne	SHORT $LN66@calc_edge

; 1354 :          { tang[j] = 0.0;

	mov	ebx, DWORD PTR _gauss1polyd
	mov	edi, DWORD PTR _k$[ebp]
$LC65@calc_edge:

; 1355 :             for ( k = 0 ; k < edge_ctrl ; k++ )

	cmp	edi, DWORD PTR _edge_ctrl
	jge	SHORT $LN9@calc_edge
	sub	ebx, DWORD PTR _x$89670[ebp]
	mov	eax, DWORD PTR _x$89670[ebp]
	mov	edx, DWORD PTR _edge_ctrl
	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR tv1381[ebp], ebx
	sub	edx, edi
	jmp	SHORT $LC7@calc_edge
$LN69@calc_edge:
	mov	ebx, DWORD PTR tv1381[ebp]
$LC7@calc_edge:

; 1356 :             tang[j] += gauss1polyd[k][m]*x[k][j];

	mov	edi, DWORD PTR [eax+ebx]
	mov	ebx, DWORD PTR [eax]
	fld	QWORD PTR [edi+esi*8]
	fmul	QWORD PTR [ebx+ecx*8]
	add	eax, 4
	dec	edx
	fadd	QWORD PTR _tang$89672[ebp+ecx*8]
	fstp	QWORD PTR _tang$89672[ebp+ecx*8]
	jne	SHORT $LN69@calc_edge

; 1355 :             for ( k = 0 ; k < edge_ctrl ; k++ )

	mov	ebx, DWORD PTR _gauss1polyd
$LN9@calc_edge:

; 1353 :         { for ( j = 0 ; j < SDIM ; j ++ )

	mov	eax, DWORD PTR _web+616
	inc	ecx
	cmp	ecx, eax
	jl	$LN70@calc_edge
	fstp	ST(0)
$LN8@calc_edge:

; 1357 :          }
; 1358 :           len += gauss1Dwt[m]*sqrt(SDIM_dot(tang,tang));

	push	eax
	lea	ecx, DWORD PTR _tang$89672[ebp]
	push	ecx
	mov	edx, ecx
	push	edx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	mov	eax, DWORD PTR _gauss1Dwt
	fmul	QWORD PTR [eax+esi*8]
	inc	esi
	fadd	QWORD PTR _len$[ebp]
	fst	QWORD PTR _len$[ebp]
	cmp	esi, DWORD PTR _gauss1D_num
	jl	$LL125@calc_edge

; 1359 :         }
; 1360 :      } break;

	jmp	$LN76@calc_edge
$LN15@calc_edge:

; 1344 :     { case LINEAR: len = sqrt(euclidean); break;

	call	__CIsqrt
	jmp	$LN76@calc_edge
_calc_edge ENDP
_TEXT	ENDS
PUBLIC	_norm$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_lagrange_edge_normal
EXTRN	_kernel_basis_rows:PROC
EXTRN	__chkstk:PROC
; Function compile flags: /Ogtp
;	COMDAT _lagrange_edge_normal
_TEXT	SEGMENT
_vxqXvS$ = -5280					; size = 400
_norm$GSCopy$ = -4880					; size = 4
_t$ = -4876						; size = 4
_gl$ = -4872						; size = 4
_m$ = -4868						; size = 4
_ctrl$ = -4864						; size = 4
_k$ = -4860						; size = 4
tv621 = -4856						; size = 4
_vx$ = -4856						; size = 4
_vxxJ$ = -4852						; size = 4800
_tang$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_e_id$ = 12						; size = 4
_norm$ = 16						; size = 4
_lagrange_edge_normal PROC				; COMDAT

; 2090 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 5280				; 000014a0H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2091 :   MAT2D(vx,MAXVCOUNT,MAXCOORD);
; 2092 :   struct gauss_lag *gl = &gauss_lagrange[1][web.gauss1D_order];
; 2093 :   vertex_id *v = get_edge_vertices(e_id);
; 2094 :   int k,m,i;
; 2095 :   int ctrl = web.skel[EDGE].ctrlpts;

	mov	eax, DWORD PTR _norm$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _e_id$[ebp]
	push	esi
	push	edi
	push	6
	push	100					; 00000064H
	lea	ecx, DWORD PTR _vxxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vxqXvS$[ebp]
	push	edx
	mov	DWORD PTR _norm$GSCopy$[ebp], eax
	call	_mat2d_setup
	mov	edx, DWORD PTR _web+124
	mov	esi, DWORD PTR _web+1592
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	add	edi, DWORD PTR [ecx+edx+304]
	mov	ecx, DWORD PTR _web+120

; 2096 :   REAL tang[MAXCOORD],*t=tang;
; 2097 : 
; 2098 :   get_edge_verts(e_id,vx,NULL);

	push	0
	shl	esi, 5
	add	esi, DWORD PTR _gauss_lagrange+4
	push	eax
	lea	edx, DWORD PTR _tang$[ebp]
	push	ebx
	mov	DWORD PTR _vx$[ebp], eax
	mov	DWORD PTR _gl$[ebp], esi
	mov	DWORD PTR _ctrl$[ebp], ecx
	mov	DWORD PTR _t$[ebp], edx
	call	_get_edge_verts

; 2099 :   for ( k = 0 ; k < ctrl ; k++ ) if ( v[k] == v_id ) break;

	mov	edx, DWORD PTR _ctrl$[ebp]
	xor	eax, eax
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _k$[ebp], eax
	test	edx, edx
	jle	SHORT $LN28@lagrange_e
	mov	ecx, DWORD PTR _v_id$[ebp]
$LL13@lagrange_e:
	cmp	DWORD PTR [edi+eax*4], ecx
	je	SHORT $LN30@lagrange_e
	inc	eax
	cmp	eax, edx
	jl	SHORT $LL13@lagrange_e
$LN30@lagrange_e:
	mov	DWORD PTR _k$[ebp], eax
$LN28@lagrange_e:

; 2100 : #ifdef VOLUMEGRAD
; 2101 :   /* volume gradient */
; 2102 :   norm[0] = norm[1] = 0.0;
; 2103 :   for ( m = 0 ; m < gl->gnumpts ; m++ )
; 2104 :   { REAL y,dx;
; 2105 :     for ( y = 0.0, dx = 0.0, j = 0 ; j < ctrl ; j++ )
; 2106 :     { y += gl->gpoly[m][j]*vx[j][1];
; 2107 :       dx += gl->gpolypart[m][0][j]*vx[j][0];
; 2108 :     }
; 2109 :     norm[0] -= gl->gausswt[m]*y*gl->gpolypart[m][0][k];
; 2110 :     norm[1] -= gl->gausswt[m]*dx*gl->gpoly[m][k];
; 2111 :   }
; 2112 : #else
; 2113 :     /* geometric normal */
; 2114 :     for ( i = 0 ; i < SDIM ; i++ ) tang[i] = 0.0;

	mov	ebx, DWORD PTR _web+616
	test	ebx, ebx
	jle	SHORT $LN9@lagrange_e
	mov	ecx, ebx
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	lea	edi, DWORD PTR _tang$[ebp]
	rep stosd
$LN9@lagrange_e:

; 2115 :     for ( m = 0 ; m < ctrl ; m++ )

	xor	eax, eax
	mov	DWORD PTR _m$[ebp], eax
	test	edx, edx
	jle	$LN4@lagrange_e
	mov	edx, DWORD PTR _vx$[ebp]
$LL6@lagrange_e:

; 2116 :     { REAL prime;
; 2117 :       prime = gl->lpolypart[k][0][m]; 

	mov	ecx, DWORD PTR [esi+28]
	mov	edi, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [ecx]
	fld	QWORD PTR [ecx+eax*8]

; 2118 :       for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	cmp	ebx, 4
	jl	SHORT $LC26@lagrange_e

; 2119 :       tang[i] += prime*vx[m][i];

	lea	eax, DWORD PTR _tang$[ebp+8]
	mov	esi, 16					; 00000010H
	sub	esi, eax
	mov	eax, 24					; 00000018H
	lea	edi, DWORD PTR _tang$[ebp+8]
	sub	eax, edi
	mov	DWORD PTR tv621[ebp], eax
$LN27@lagrange_e:
	mov	edi, DWORD PTR [edx]
	fld	QWORD PTR [edi+ecx*8]
	lea	eax, DWORD PTR _tang$[ebp+ecx*8+8]
	fmul	ST(0), ST(1)
	add	ecx, 4
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	edi, DWORD PTR [edx]
	fld	QWORD PTR [edi+ecx*8-24]
	lea	edi, DWORD PTR [esi+eax]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	ebx, DWORD PTR [edx]
	fld	QWORD PTR [edi+ebx]
	mov	edi, DWORD PTR tv621[ebp]
	fmul	ST(0), ST(1)
	add	edi, eax
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	mov	ebx, DWORD PTR [edx]
	fld	QWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR _web+616
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+16]
	lea	eax, DWORD PTR [ebx-3]
	cmp	ecx, eax
	jl	SHORT $LN27@lagrange_e
	mov	esi, DWORD PTR _gl$[ebp]
	mov	eax, DWORD PTR _m$[ebp]
$LC26@lagrange_e:

; 2118 :       for ( i = 0 ; i < SDIM ; i++ )

	cmp	ecx, ebx
	jge	SHORT $LN39@lagrange_e
$LC3@lagrange_e:

; 2119 :       tang[i] += prime*vx[m][i];

	mov	edi, DWORD PTR [edx]
	fld	QWORD PTR [edi+ecx*8]
	inc	ecx
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _tang$[ebp+ecx*8-8]
	fstp	QWORD PTR _tang$[ebp+ecx*8-8]
	cmp	ecx, ebx
	jl	SHORT $LC3@lagrange_e
$LN39@lagrange_e:

; 2115 :     for ( m = 0 ; m < ctrl ; m++ )

	inc	eax

; 2118 :       for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
	add	edx, 4
	mov	DWORD PTR _m$[ebp], eax
	cmp	eax, DWORD PTR _ctrl$[ebp]
	jl	$LL6@lagrange_e
$LN4@lagrange_e:

; 2120 :     }
; 2121 :     return kernel_basis_rows(&t,norm,1,SDIM);

	mov	ecx, DWORD PTR _norm$GSCopy$[ebp]
	push	ebx
	push	1
	push	ecx
	lea	edx, DWORD PTR _t$[ebp]
	push	edx
	call	_kernel_basis_rows

; 2122 : #endif
; 2123 : } // end lagrange_edge_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_lagrange_edge_normal ENDP
_TEXT	ENDS
PUBLIC	_norm$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_quadratic_edge_normal
; Function compile flags: /Ogtp
;	COMDAT _quadratic_edge_normal
_TEXT	SEGMENT
_vxqXvS$ = -5276					; size = 400
_t$ = -4876						; size = 4
tv606 = -4872						; size = 4
tv615 = -4868						; size = 4
_norm$GSCopy$ = -4864					; size = 4
_ctrl$ = -4860						; size = 4
tv898 = -4856						; size = 4
_k$ = -4856						; size = 4
_vxxJ$ = -4852						; size = 4800
_tang$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_e_id$ = 12						; size = 4
_norm$ = 16						; size = 4
_quadratic_edge_normal PROC				; COMDAT

; 2179 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 5276				; 0000149cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2180 :   MAT2D(vx,MAXVCOUNT,MAXCOORD);
; 2181 :   vertex_id *v = get_edge_vertices(e_id);
; 2182 :   int k,m,i;
; 2183 :   int ctrl = web.skel[EDGE].ctrlpts;  /* should be 3 */

	mov	eax, DWORD PTR _norm$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _e_id$[ebp]
	push	6
	push	100					; 00000064H
	lea	ecx, DWORD PTR _vxxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vxqXvS$[ebp]
	push	edx
	mov	DWORD PTR _norm$GSCopy$[ebp], eax
	call	_mat2d_setup
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR _web+216
	mov	esi, eax
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	add	ebx, DWORD PTR [edx+eax+304]
	mov	ecx, DWORD PTR _web+120

; 2184 :   REAL tang[MAXCOORD],*t=tang;
; 2185 : 
; 2186 :   get_edge_verts(e_id,vx,NULL);  /* has midv in vx[1] */

	push	0
	lea	edx, DWORD PTR _tang$[ebp]
	push	esi
	push	edi
	mov	DWORD PTR _ctrl$[ebp], ecx
	mov	DWORD PTR _t$[ebp], edx
	call	_get_edge_verts

; 2187 :   for ( k = 0 ; k < ctrl ; k++ ) if ( v[k] == v_id ) break;

	mov	edi, DWORD PTR _ctrl$[ebp]
	xor	eax, eax
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _k$[ebp], eax
	test	edi, edi
	jle	SHORT $LN10@quadratic_
	mov	ecx, DWORD PTR _v_id$[ebp]
$LL14@quadratic_:
	cmp	DWORD PTR [ebx+eax*4], ecx
	je	SHORT $LN31@quadratic_
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL14@quadratic_
$LN31@quadratic_:
	mov	DWORD PTR _k$[ebp], eax

; 2188 :   if ( k != 0 ) k = 3 - k; /* switch vertices 1 and 2 compared to lagrange */

	test	eax, eax
	je	SHORT $LN10@quadratic_
	mov	ecx, 3
	sub	ecx, eax
	mov	DWORD PTR _k$[ebp], ecx
$LN10@quadratic_:

; 2189 : 
; 2190 :   /* geometric normal */
; 2191 :   for ( i = 0 ; i < SDIM ; i++ ) tang[i] = 0.0;

	mov	ebx, DWORD PTR _web+616
	test	ebx, ebx
	jle	SHORT $LN9@quadratic_
	mov	ecx, ebx
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	lea	edi, DWORD PTR _tang$[ebp]
	rep stosd
	mov	edi, DWORD PTR _ctrl$[ebp]
$LN9@quadratic_:

; 2192 :   for ( m = 0 ; m < ctrl ; m++ )

	xor	edx, edx
	test	edi, edi
	jle	$LN4@quadratic_
	mov	eax, DWORD PTR _k$[ebp]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR _quad_tang_coeffs[eax*8]
	mov	DWORD PTR tv898[ebp], ecx
	npad	7
$LL30@quadratic_:

; 2193 :   { REAL prime;
; 2194 :     prime = quad_tang_coeffs[k][m]; 

	mov	eax, DWORD PTR tv898[ebp]
	fld	QWORD PTR [eax]

; 2195 :     for ( i = 0 ; i < SDIM ; i++ )

	xor	ecx, ecx
	cmp	ebx, 4
	jl	$LC27@quadratic_

; 2196 :     tang[i] += prime*vx[m][i];

	lea	eax, DWORD PTR _tang$[ebp+8]
	mov	edi, 16					; 00000010H
	sub	edi, eax
	mov	eax, 24					; 00000018H
	lea	ebx, DWORD PTR _tang$[ebp+8]
	sub	eax, ebx
	mov	DWORD PTR tv606[ebp], edi
	mov	DWORD PTR tv615[ebp], eax
	jmp	SHORT $LN28@quadratic_
$LN29@quadratic_:
	mov	edi, DWORD PTR tv606[ebp]

; 2195 :     for ( i = 0 ; i < SDIM ; i++ )

$LN28@quadratic_:

; 2196 :     tang[i] += prime*vx[m][i];

	mov	ebx, DWORD PTR [esi+edx*4]
	fld	QWORD PTR [ebx+ecx*8]
	lea	eax, DWORD PTR _tang$[ebp+ecx*8+8]
	fmul	ST(0), ST(1)
	add	ecx, 4
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	ebx, DWORD PTR [esi+edx*4]
	fld	QWORD PTR [ebx+ecx*8-24]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	mov	ebx, DWORD PTR [esi+edx*4]
	add	ebx, edi
	fld	QWORD PTR [ebx+eax]
	mov	ebx, DWORD PTR _web+616
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax+8]
	mov	edi, DWORD PTR [esi+edx*4]
	add	edi, DWORD PTR tv615[ebp]
	fld	QWORD PTR [edi+eax]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax+16]
	fstp	QWORD PTR [eax+16]
	lea	eax, DWORD PTR [ebx-3]
	cmp	ecx, eax
	jl	SHORT $LN29@quadratic_
	mov	edi, DWORD PTR _ctrl$[ebp]
$LC27@quadratic_:

; 2195 :     for ( i = 0 ; i < SDIM ; i++ )

	cmp	ecx, ebx
	jge	SHORT $LN41@quadratic_
$LC3@quadratic_:

; 2196 :     tang[i] += prime*vx[m][i];

	mov	eax, DWORD PTR [esi+edx*4]
	fld	QWORD PTR [eax+ecx*8]
	inc	ecx
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _tang$[ebp+ecx*8-8]
	fstp	QWORD PTR _tang$[ebp+ecx*8-8]
	cmp	ecx, ebx
	jl	SHORT $LC3@quadratic_
$LN41@quadratic_:

; 2192 :   for ( m = 0 ; m < ctrl ; m++ )

	add	DWORD PTR tv898[ebp], 8

; 2195 :     for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
	inc	edx
	cmp	edx, edi
	jl	$LL30@quadratic_
$LN4@quadratic_:

; 2197 :   }
; 2198 :   return kernel_basis_rows(&t,norm,1,SDIM);

	mov	ecx, DWORD PTR _norm$GSCopy$[ebp]
	push	ebx
	push	1
	push	ecx
	lea	edx, DWORD PTR _t$[ebp]
	push	edx
	call	_kernel_basis_rows

; 2199 : 
; 2200 : } // end quadratic_edge_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_quadratic_edge_normal ENDP
_TEXT	ENDS
PUBLIC	_get_facet_verts
; Function compile flags: /Ogtp
;	COMDAT _get_facet_verts
_TEXT	SEGMENT
tv1892 = -28						; size = 4
tv1621 = -28						; size = 4
tv1752 = -24						; size = 4
tv1718 = -24						; size = 4
tv1682 = -24						; size = 4
tv654 = -24						; size = 4
tv358 = -24						; size = 4
tv253 = -24						; size = 4
tv1883 = -20						; size = 4
tv1736 = -20						; size = 4
tv1701 = -20						; size = 4
tv1650 = -20						; size = 4
tv1115 = -20						; size = 4
_ctrlpts$90860 = -20					; size = 4
_x$ = -16						; size = 4
_i$ = -16						; size = 4
_v$90855 = -16						; size = 4
_fe$ = -12						; size = 4
_n$90861 = -8						; size = 4
_wrap$ = -4						; size = 4
_f_id$ = 8						; size = 4
_verts$ = 12						; size = 4
_wraps$ = 16						; size = 4
_get_facet_verts PROC					; COMDAT

; 2847 : {

	push	ebp
	mov	ebp, esp

; 2848 :   facetedge_id fe;
; 2849 :   int i,j;
; 2850 :   WRAPTYPE wrap,fewrap;
; 2851 :   REAL *x;
; 2852 :   
; 2853 :   if ( web.modeltype == LAGRANGE )

	mov	eax, DWORD PTR _web+628
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	mov	esi, 3
	push	edi
	cmp	eax, esi
	jne	$LN61@get_facet_@5

; 2854 :     { vertex_id *v = get_facet_vertices(f_id);

	mov	ecx, DWORD PTR _f_id$[ebp]
	mov	edx, DWORD PTR _web+236
	mov	esi, DWORD PTR _dymem

; 2855 :       int ctrlpts = web.skel[FACET].ctrlpts;
; 2856 :       int n = web.lagrange_order;
; 2857 : 
; 2858 :       f_id = positive_id(f_id); /* since vertices in particular order */
; 2859 : 
; 2860 :       for ( i = 0 ; i < ctrlpts ; i++ )

	mov	ebx, DWORD PTR _verts$[ebp]
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+328
	add	eax, DWORD PTR [edx+esi+304]
	mov	edx, DWORD PTR _web+232
	mov	esi, DWORD PTR _web+632
	and	ecx, -134217729				; f7ffffffH
	mov	DWORD PTR _v$90855[ebp], eax
	mov	DWORD PTR _ctrlpts$90860[ebp], edx
	mov	DWORD PTR _n$90861[ebp], esi
	mov	DWORD PTR _f_id$[ebp], ecx
	test	edx, edx
	jle	SHORT $LN152@get_facet_@5
	mov	edi, DWORD PTR _web+616
	mov	ecx, eax
	sub	ecx, ebx
	mov	DWORD PTR tv654[ebp], edx
	npad	13
$LL60@get_facet_@5:

; 2861 :       { 
; 2862 :         x = get_coord(v[i]);

	mov	eax, DWORD PTR [ecx+ebx]
	mov	edx, DWORD PTR _web+12
	mov	esi, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _web+104
	add	edx, DWORD PTR [eax+esi+64]

; 2863 :        
; 2864 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN59@get_facet_@5
	mov	eax, DWORD PTR [ebx]
	sub	edx, eax
	npad	6
$LL57@get_facet_@5:

; 2865 :           verts[i][j] = x[j];

	fld	QWORD PTR [edx+eax]
	inc	esi
	fstp	QWORD PTR [eax]
	mov	edi, DWORD PTR _web+616
	add	eax, 8
	cmp	esi, edi
	jl	SHORT $LL57@get_facet_@5
$LN59@get_facet_@5:

; 2855 :       int ctrlpts = web.skel[FACET].ctrlpts;
; 2856 :       int n = web.lagrange_order;
; 2857 : 
; 2858 :       f_id = positive_id(f_id); /* since vertices in particular order */
; 2859 : 
; 2860 :       for ( i = 0 ; i < ctrlpts ; i++ )

	add	ebx, 4
	dec	DWORD PTR tv654[ebp]
	jne	SHORT $LL60@get_facet_@5
	mov	ecx, DWORD PTR _f_id$[ebp]
	mov	edx, DWORD PTR _ctrlpts$90860[ebp]
$LN152@get_facet_@5:

; 2866 :       }
; 2867 :       if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	$LN4@get_facet_@5

; 2868 :       {
; 2869 :         if ( wraps ) 

	mov	ebx, DWORD PTR _wraps$[ebp]
	test	ebx, ebx
	je	SHORT $LN52@get_facet_@5

; 2870 :           for ( j = 0 ; j < ctrlpts ; j++ ) wraps[j] = 0;

	test	edx, edx
	jle	SHORT $LN52@get_facet_@5
	mov	ecx, edx
	xor	eax, eax
	mov	edi, ebx
	rep stosd
	mov	ecx, DWORD PTR _f_id$[ebp]
$LN52@get_facet_@5:

; 2871 :     
; 2872 :         /* gotta go through the 3 edges */
; 2873 :         /* first edge */
; 2874 :         fe = get_facet_fe(f_id);

	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN65@get_facet_@5
	xor	eax, eax
	jmp	SHORT $LN64@get_facet_@5
$LN65@get_facet_@5:
	mov	eax, DWORD PTR _web+236
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edx+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN64@get_facet_@5
	xor	eax, 134217728				; 08000000H
$LN64@get_facet_@5:

; 2875 :         wrap = get_fe_wrap(fe);

	mov	ecx, DWORD PTR _web+460
	mov	esi, DWORD PTR _web+124
	mov	edi, DWORD PTR _web+216
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR tv1115[ebp], edx
	mov	edx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _fe$[ebp], eax
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR _dymem
	mov	esi, DWORD PTR [edi+esi+784]
	mov	edx, DWORD PTR [edx+esi]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN72@get_facet_@5
	push	edx
	call	DWORD PTR _sym_inverse
	mov	ecx, DWORD PTR _web+460
	add	esp, 4
	mov	DWORD PTR _wrap$[ebp], eax
	jmp	SHORT $LN73@get_facet_@5
$LN72@get_facet_@5:
	mov	eax, edx
	mov	DWORD PTR _wrap$[ebp], edx
$LN73@get_facet_@5:

; 2876 :         if ( wrap && inverted(get_fe_edge(fe)) )

	test	eax, eax
	je	$LN163@get_facet_@5
	mov	eax, DWORD PTR tv1115[ebp]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [ecx+20]
	xor	edx, DWORD PTR _fe$[ebp]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN46@get_facet_@5

; 2877 :           for ( j = 1 ; j < n ; j++ )

	cmp	DWORD PTR _n$90861[ebp], 1
	jle	SHORT $LN46@get_facet_@5
	mov	eax, DWORD PTR _v$90855[ebp]

; 2879 :              if ( wraps ) wraps[j] = wrap;

	mov	edi, DWORD PTR _verts$[ebp]
	mov	ecx, ebx
	sub	ecx, eax
	lea	esi, DWORD PTR [eax+4]
	sub	edi, eax
	mov	eax, DWORD PTR _n$90861[ebp]
	dec	eax
	mov	DWORD PTR tv1621[ebp], ecx
	mov	DWORD PTR tv358[ebp], eax
$LL153@get_facet_@5:

; 2878 :           { (*sym_wrap)(get_coord(v[j]),verts[j],wrap);

	mov	ecx, DWORD PTR _wrap$[ebp]
	mov	edx, DWORD PTR [edi+esi]
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	ecx, DWORD PTR _web+12
	push	edx
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+64]
	push	edx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH

; 2879 :              if ( wraps ) wraps[j] = wrap;

	test	ebx, ebx
	je	SHORT $LN47@get_facet_@5
	mov	edx, DWORD PTR _wrap$[ebp]
	mov	eax, DWORD PTR tv1621[ebp]
	mov	DWORD PTR [eax+esi], edx
$LN47@get_facet_@5:

; 2877 :           for ( j = 1 ; j < n ; j++ )

	add	esi, 4
	dec	DWORD PTR tv358[ebp]
	jne	SHORT $LL153@get_facet_@5
$LN46@get_facet_@5:

; 2880 :           }
; 2881 :         if ( wrap )
; 2882 :         { (*sym_wrap)(get_coord(v[n]),verts[n],wrap);

	mov	ecx, DWORD PTR _verts$[ebp]
	mov	esi, DWORD PTR _n$90861[ebp]
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	edi, DWORD PTR _wrap$[ebp]
	mov	eax, DWORD PTR _v$90855[ebp]
	mov	ecx, DWORD PTR [eax+esi*4]
	push	edi
	push	edx
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+64]
	push	eax
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH

; 2883 :           if ( wraps ) wraps[n] = wrap ;

	test	ebx, ebx
	je	SHORT $LN154@get_facet_@5
	mov	DWORD PTR [ebx+esi*4], edi
$LN154@get_facet_@5:
	mov	ecx, DWORD PTR _web+460
$LN163@get_facet_@5:

; 2884 :         }
; 2885 : 
; 2886 :         /* second edge */
; 2887 :         fe = get_next_edge(fe);

	test	DWORD PTR _fe$[ebp], 134217728		; 08000000H
	mov	eax, DWORD PTR tv1115[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	je	SHORT $LN77@get_facet_@5
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN166@get_facet_@5
$LN77@get_facet_@5:
	mov	eax, DWORD PTR [edx+32]
$LN166@get_facet_@5:

; 2888 :         if ( wrap && !inverted(get_fe_edge(fe)) )

	cmp	DWORD PTR _wrap$[ebp], 0
	mov	DWORD PTR _fe$[ebp], eax
	je	$LN164@get_facet_@5
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [edx+20]
	xor	edx, eax
	test	edx, 134217728				; 08000000H
	jne	SHORT $LN164@get_facet_@5

; 2889 :           for ( j = 1 ; j < n ; j++ )

	mov	edi, 1
	cmp	DWORD PTR _n$90861[ebp], edi
	jle	SHORT $LN164@get_facet_@5
	mov	eax, DWORD PTR _n$90861[ebp]
	lea	ecx, DWORD PTR [eax+eax]
	mov	DWORD PTR tv1650[ebp], ecx
	npad	6
$LL155@get_facet_@5:

; 2890 :           { int m = n*(j+1) - j*(j-1)/2;

	mov	esi, DWORD PTR tv1650[ebp]
	lea	eax, DWORD PTR [edi-1]
	imul	eax, edi
	cdq
	sub	eax, edx

; 2891 :              (*sym_wrap)(get_coord(v[m]),verts[m],wrap);

	mov	edx, DWORD PTR _wrap$[ebp]
	sar	eax, 1
	sub	esi, eax
	mov	eax, DWORD PTR _verts$[ebp]
	mov	ecx, DWORD PTR [eax+esi*4]
	push	edx
	mov	edx, DWORD PTR _v$90855[ebp]
	mov	eax, DWORD PTR [edx+esi*4]
	push	ecx
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+64]
	push	edx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH

; 2892 :              if ( wraps ) wraps[m] = wrap;

	test	ebx, ebx
	je	SHORT $LN40@get_facet_@5
	mov	edx, DWORD PTR _wrap$[ebp]
	mov	DWORD PTR [ebx+esi*4], edx
$LN40@get_facet_@5:

; 2889 :           for ( j = 1 ; j < n ; j++ )

	mov	eax, DWORD PTR _n$90861[ebp]
	add	DWORD PTR tv1650[ebp], eax
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL155@get_facet_@5
	mov	ecx, DWORD PTR _web+460
$LN164@get_facet_@5:

; 2893 :           }
; 2894 :         fewrap = get_fe_wrap(fe);

	mov	eax, DWORD PTR _fe$[ebp]
	mov	edi, DWORD PTR _web+216
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+ecx]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edi+ecx+784]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR tv1115[ebp], esi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN86@get_facet_@5
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN87@get_facet_@5
$LN86@get_facet_@5:
	mov	eax, ecx
$LN87@get_facet_@5:

; 2895 :         wrap = (*sym_compose)(wrap,fewrap);

	mov	edx, DWORD PTR _wrap$[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose
	add	esp, 8
	mov	DWORD PTR _wrap$[ebp], eax

; 2896 :         if ( wrap && inverted(get_fe_edge(fe)) )

	test	eax, eax
	je	$LN159@get_facet_@5
	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [esi+eax]
	mov	edx, DWORD PTR [ecx+20]
	xor	edx, DWORD PTR _fe$[ebp]

; 2897 :           for ( j = 1 ; j < n ; j++ )

	mov	ecx, DWORD PTR _n$90861[ebp]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN34@get_facet_@5
	mov	edi, 1
	cmp	ecx, edi
	jle	SHORT $LN34@get_facet_@5
	lea	eax, DWORD PTR [ecx+ecx]
	mov	DWORD PTR tv1682[ebp], eax
	npad	3
$LL36@get_facet_@5:

; 2898 :           { int m = n*(j+1) - j*(j-1)/2;
; 2899 :              (*sym_wrap)(get_coord(v[m]),verts[m],wrap);

	mov	ecx, DWORD PTR _wrap$[ebp]
	mov	esi, DWORD PTR tv1682[ebp]
	lea	eax, DWORD PTR [edi-1]
	imul	eax, edi
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _verts$[ebp]
	sar	eax, 1
	push	ecx
	mov	ecx, DWORD PTR _v$90855[ebp]
	sub	esi, eax
	mov	eax, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [ecx+esi*4]
	push	eax
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+eax+64]
	push	ecx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH

; 2900 :              if ( wraps ) wraps[m] = wrap;

	test	ebx, ebx
	je	SHORT $LN35@get_facet_@5
	mov	ecx, DWORD PTR _wrap$[ebp]
	mov	DWORD PTR [ebx+esi*4], ecx
$LN35@get_facet_@5:

; 2897 :           for ( j = 1 ; j < n ; j++ )

	mov	eax, DWORD PTR _n$90861[ebp]
	add	DWORD PTR tv1682[ebp], eax
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL36@get_facet_@5
	mov	esi, DWORD PTR tv1115[ebp]
	mov	ecx, eax
$LN34@get_facet_@5:

; 2901 :           }
; 2902 :         if ( wrap )
; 2903 :         { int m = n*(n+3)/2;

	lea	eax, DWORD PTR [ecx+3]
	imul	eax, ecx
	cdq
	sub	eax, edx

; 2904 :           (*sym_wrap)(get_coord(v[m]),verts[m],wrap);

	mov	edx, DWORD PTR _wrap$[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR _verts$[ebp]
	push	edx
	mov	edx, DWORD PTR _v$90855[ebp]
	sar	edi, 1
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [edx+edi*4]
	push	ecx
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+104
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+64]
	push	edx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH

; 2905 :           if ( wraps ) wraps[m] = wrap;

	test	ebx, ebx
	je	SHORT $LN159@get_facet_@5
	mov	edx, DWORD PTR _wrap$[ebp]
	mov	DWORD PTR [ebx+edi*4], edx
$LN159@get_facet_@5:

; 2906 :         }
; 2907 :      
; 2908 :         /* third edge */ 
; 2909 :         fe = get_next_edge(fe);

	test	DWORD PTR _fe$[ebp], 134217728		; 08000000H
	mov	ecx, DWORD PTR _web+460
	je	SHORT $LN91@get_facet_@5
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN167@get_facet_@5
$LN91@get_facet_@5:
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+32]
$LN167@get_facet_@5:

; 2910 :         if ( wrap && !inverted(get_fe_edge(fe)) )

	cmp	DWORD PTR _wrap$[ebp], 0
	mov	DWORD PTR _fe$[ebp], eax
	je	$LN27@get_facet_@5
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [edx+20]
	xor	edx, eax
	test	edx, 134217728				; 08000000H
	jne	SHORT $LN27@get_facet_@5

; 2911 :           for ( j = 1 ; j < n ; j++ )

	mov	edi, 1
	cmp	DWORD PTR _n$90861[ebp], edi
	jle	SHORT $LN27@get_facet_@5
	mov	eax, DWORD PTR _n$90861[ebp]
	mov	DWORD PTR tv1701[ebp], eax
	mov	DWORD PTR tv1718[ebp], 2
	npad	1
$LL29@get_facet_@5:

; 2912 :           { int m = n*j + j*(3-j)/2;

	mov	eax, DWORD PTR tv1718[ebp]

; 2913 :              (*sym_wrap)(get_coord(v[m]),verts[m],wrap);

	mov	ecx, DWORD PTR _wrap$[ebp]
	imul	eax, edi
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _verts$[ebp]
	mov	esi, eax
	push	ecx
	mov	ecx, DWORD PTR _v$90855[ebp]
	sar	esi, 1
	add	esi, DWORD PTR tv1701[ebp]
	mov	eax, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [ecx+esi*4]
	push	eax
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+eax+64]
	push	ecx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH

; 2914 :              if ( wraps ) wraps[m] = wrap;

	test	ebx, ebx
	je	SHORT $LN28@get_facet_@5
	mov	ecx, DWORD PTR _wrap$[ebp]
	mov	DWORD PTR [ebx+esi*4], ecx
$LN28@get_facet_@5:

; 2911 :           for ( j = 1 ; j < n ; j++ )

	mov	eax, DWORD PTR _n$90861[ebp]
	dec	DWORD PTR tv1718[ebp]
	add	DWORD PTR tv1701[ebp], eax
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL29@get_facet_@5
	mov	ecx, DWORD PTR _web+460
$LN27@get_facet_@5:

; 2915 :           }
; 2916 :         fewrap = get_fe_wrap(fe);

	mov	eax, DWORD PTR _fe$[ebp]
	mov	edi, DWORD PTR _dymem
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+ecx]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _web+124
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+edi+784]
	mov	ecx, DWORD PTR [ecx+edx]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN100@get_facet_@5
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN101@get_facet_@5
$LN100@get_facet_@5:
	mov	eax, ecx
$LN101@get_facet_@5:

; 2917 :         wrap = (*sym_compose)(wrap,fewrap);

	push	eax
	mov	eax, DWORD PTR _wrap$[ebp]
	push	eax
	call	DWORD PTR _sym_compose
	add	esp, 8
	mov	DWORD PTR _wrap$[ebp], eax

; 2918 :         if ( wrap && inverted(get_fe_edge(fe)) )

	test	eax, eax
	je	$LN4@get_facet_@5
	mov	ecx, DWORD PTR _web+460
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+20]
	xor	eax, DWORD PTR _fe$[ebp]
	test	eax, 134217728				; 08000000H
	je	$LN4@get_facet_@5

; 2919 :           for ( j = 1 ; j < n ; j++ )

	mov	eax, DWORD PTR _n$90861[ebp]
	mov	edi, 1
	cmp	eax, edi
	jle	$LN4@get_facet_@5
	mov	DWORD PTR tv1736[ebp], eax
	mov	DWORD PTR tv1752[ebp], 2
	npad	7
$LL24@get_facet_@5:

; 2920 :           { int m = n*j + j*(3-j)/2;

	mov	eax, DWORD PTR tv1752[ebp]

; 2921 :              (*sym_wrap)(get_coord(v[m]),verts[m],wrap);

	mov	ecx, DWORD PTR _wrap$[ebp]
	imul	eax, edi
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _verts$[ebp]
	mov	esi, eax
	push	ecx
	mov	ecx, DWORD PTR _v$90855[ebp]
	sar	esi, 1
	add	esi, DWORD PTR tv1736[ebp]
	mov	eax, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR [ecx+esi*4]
	push	eax
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+eax+64]
	push	ecx
	call	DWORD PTR _sym_wrap
	add	esp, 12					; 0000000cH

; 2922 :              if ( wraps ) wraps[m] = wrap;

	test	ebx, ebx
	je	SHORT $LN23@get_facet_@5
	mov	ecx, DWORD PTR _wrap$[ebp]
	mov	DWORD PTR [ebx+esi*4], ecx
$LN23@get_facet_@5:

; 2919 :           for ( j = 1 ; j < n ; j++ )

	mov	eax, DWORD PTR _n$90861[ebp]
	dec	DWORD PTR tv1752[ebp]
	add	DWORD PTR tv1736[ebp], eax
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL24@get_facet_@5
	pop	edi
	pop	esi
	pop	ebx

; 2960 :   }
; 2961 : } // end get_facet_verts(0

	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@get_facet_@5:

; 2923 :           }
; 2924 :       }
; 2925 :       return;
; 2926 :     }
; 2927 : 
; 2928 :   if ( (web.modeltype == QUADRATIC) && verts[3] ) 

	mov	ecx, DWORD PTR _verts$[ebp]
	xor	edx, edx
	cmp	eax, 2
	jne	SHORT $LN20@get_facet_@5
	cmp	DWORD PTR [ecx+12], edx
	je	SHORT $LN20@get_facet_@5

; 2929 :   { get_facet_verts_q(f_id,verts,wraps); return; }

	mov	edx, DWORD PTR _wraps$[ebp]
	mov	eax, DWORD PTR _f_id$[ebp]
	push	edx
	push	ecx
	push	eax
	call	_get_facet_verts_q
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2960 :   }
; 2961 : } // end get_facet_verts(0

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@get_facet_@5:

; 2930 : 
; 2931 :   if ( web.representation == SIMPLEX )
; 2932 :   { vertex_id *v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	cmp	DWORD PTR _web+624, esi
	jne	$LN19@get_facet_@5
	mov	esi, DWORD PTR _web+236
	mov	edi, DWORD PTR _dymem
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	esi, DWORD PTR _web+328
	add	eax, DWORD PTR [esi+edi+304]

; 2933 :     for ( i = 0 ; i <= web.dimension ; i++ )

	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _web+620, edx
	jl	$LN4@get_facet_@5
	mov	esi, DWORD PTR _web+616
	mov	ebx, eax
	mov	edi, ecx
	sub	ebx, ecx
	npad	7
$LL18@get_facet_@5:

; 2934 :      { x = get_coord(v[i]);

	mov	ecx, DWORD PTR [ebx+edi]
	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR _web+104
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	add	ecx, DWORD PTR [eax+edx+64]

; 2935 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN17@get_facet_@5
	mov	eax, DWORD PTR [edi]
	sub	ecx, eax
	npad	5
$LL15@get_facet_@5:

; 2936 :           verts[i][j] = x[j];

	fld	QWORD PTR [eax+ecx]
	inc	edx
	fstp	QWORD PTR [eax]
	mov	esi, DWORD PTR _web+616
	add	eax, 8
	cmp	edx, esi
	jl	SHORT $LL15@get_facet_@5
$LN17@get_facet_@5:

; 2933 :     for ( i = 0 ; i <= web.dimension ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	edi, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _web+620
	jle	SHORT $LL18@get_facet_@5
	pop	edi
	pop	esi
	pop	ebx

; 2960 :   }
; 2961 : } // end get_facet_verts(0

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@get_facet_@5:

; 2937 :      }
; 2938 :     return;
; 2939 :   }
; 2940 : 
; 2941 :   fe = get_facet_fe(f_id);

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN105@get_facet_@5
	xor	edi, edi
	jmp	SHORT $LN104@get_facet_@5
$LN105@get_facet_@5:
	mov	ebx, DWORD PTR _web+236
	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	edi, DWORD PTR [edi+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN104@get_facet_@5
	xor	edi, 134217728				; 08000000H
$LN104@get_facet_@5:

; 2942 :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, edx
	je	$LN12@get_facet_@5

; 2943 :   { wrap = 0;
; 2944 :     for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR _wraps$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv1892[ebp], eax
	mov	eax, DWORD PTR _web+460
	mov	DWORD PTR _wrap$[ebp], edx
	mov	DWORD PTR tv1883[ebp], ecx
	mov	DWORD PTR tv253[ebp], esi
	npad	6
$LL156@get_facet_@5:

; 2945 :     { 
; 2946 :       x = get_coord(get_fe_tailv(fe));

	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+eax]
	mov	ecx, DWORD PTR [eax+20]
	mov	ebx, edi
	and	ebx, 134217728				; 08000000H
	xor	ecx, ebx
	push	ecx
	call	_get_edge_tailv
	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+64]
	add	esp, 4

; 2947 :       if ( wraps ) wraps[i] = wrap;

	cmp	DWORD PTR _wraps$[ebp], 0
	mov	DWORD PTR _x$[ebp], eax
	je	SHORT $LN8@get_facet_@5
	mov	eax, DWORD PTR _wrap$[ebp]
	mov	ecx, DWORD PTR tv1892[ebp]
	mov	edx, DWORD PTR tv1883[ebp]
	mov	DWORD PTR [ecx+edx], eax
	mov	eax, DWORD PTR _x$[ebp]
$LN8@get_facet_@5:

; 2948 :       (*sym_wrap)(x,verts[i],wrap);

	mov	ecx, DWORD PTR _wrap$[ebp]
	mov	edx, DWORD PTR tv1883[ebp]
	push	ecx
	mov	ecx, DWORD PTR [edx]
	push	ecx
	push	eax
	call	DWORD PTR _sym_wrap

; 2949 :       fewrap = get_fe_wrap(fe);

	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _web+124
	xor	eax, ebx
	mov	ebx, DWORD PTR _dymem
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+ebx+784]
	mov	ecx, DWORD PTR [ecx+edx]
	add	esp, 12					; 0000000cH
	test	eax, 134217728				; 08000000H
	je	SHORT $LN114@get_facet_@5
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN115@get_facet_@5
$LN114@get_facet_@5:
	mov	eax, ecx
$LN115@get_facet_@5:

; 2950 :       wrap = (*sym_compose)(wrap,fewrap);

	push	eax
	mov	eax, DWORD PTR _wrap$[ebp]
	push	eax
	call	DWORD PTR _sym_compose
	add	esp, 8
	mov	DWORD PTR _wrap$[ebp], eax

; 2951 :       fe = get_next_edge(fe);

	mov	eax, DWORD PTR _web+460
	test	edi, 134217728				; 08000000H
	je	SHORT $LN117@get_facet_@5
	mov	ecx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [ecx+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN10@get_facet_@5
$LN117@get_facet_@5:
	mov	edx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [edx+32]
$LN10@get_facet_@5:

; 2943 :   { wrap = 0;
; 2944 :     for ( i = 0 ; i < FACET_VERTS ; i++ )

	add	DWORD PTR tv1883[ebp], 4
	dec	DWORD PTR tv253[ebp]
	jne	$LL156@get_facet_@5
	pop	edi
	pop	esi
	pop	ebx

; 2960 :   }
; 2961 : } // end get_facet_verts(0

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@get_facet_@5:

; 2952 :     }
; 2953 :   }
; 2954 :   else for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	ebx, DWORD PTR _web+460
	mov	DWORD PTR _i$[ebp], edx
	npad	8
$LL6@get_facet_@5:

; 2955 :   { vertex_id v_id = get_fe_tailv(fe);

	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ebx]
	mov	ecx, edi
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_get_edge_tailv

; 2956 :     x = get_coord(v_id);

	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+eax+64]

; 2957 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	add	esp, 4
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN162@get_facet_@5

; 2952 :     }
; 2953 :   }
; 2954 :   else for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR _verts$[ebp]
	mov	ebx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]

; 2957 :     for ( j = 0 ; j < SDIM ; j++ )

	sub	ecx, eax
$LL160@get_facet_@5:

; 2958 :       verts[i][j] = x[j];

	fld	QWORD PTR [eax+ecx]
	inc	edx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL160@get_facet_@5

; 2957 :     for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _web+460
$LN162@get_facet_@5:

; 2959 :     fe = get_next_edge(fe);

	test	edi, 134217728				; 08000000H
	je	SHORT $LN123@get_facet_@5
	mov	ecx, DWORD PTR [esi+ebx]
	mov	edi, DWORD PTR [ecx+28]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN5@get_facet_@5
$LN123@get_facet_@5:
	mov	edx, DWORD PTR [esi+ebx]
	mov	edi, DWORD PTR [edx+32]
$LN5@get_facet_@5:

; 2952 :     }
; 2953 :   }
; 2954 :   else for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, 3
	jl	$LL6@get_facet_@5
$LN4@get_facet_@5:
	pop	edi
	pop	esi
	pop	ebx

; 2960 :   }
; 2961 : } // end get_facet_verts(0

	mov	esp, ebp
	pop	ebp
	ret	0
_get_facet_verts ENDP
_TEXT	ENDS
PUBLIC	__real@3feccccccccccccd
PUBLIC	__real@483d6329f1c35ca5
PUBLIC	_get_facet_verts_special
EXTRN	_sym_flags:DWORD
;	COMDAT __real@3feccccccccccccd
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3feccccccccccccd DQ 03feccccccccccccdr	; 0.9
CONST	ENDS
;	COMDAT __real@483d6329f1c35ca5
CONST	SEGMENT
__real@483d6329f1c35ca5 DQ 0483d6329f1c35ca5r	; 1e+040
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\utility.c
CONST	ENDS
;	COMDAT _get_facet_verts_special
_TEXT	SEGMENT
_mindd$91033 = -24					; size = 8
_x$ = -20						; size = 4
_ii$ = -16						; size = 4
_jj$91048 = -12						; size = 4
_minfe$91035 = -12					; size = 4
tv480 = -8						; size = 4
_wrap$ = -8						; size = 4
_mini$91034 = -8					; size = 4
_i$ = -4						; size = 4
_f_id$ = 8						; size = 4
_verts$ = 12						; size = 4
_wraps$ = 16						; size = 4
_get_facet_verts_special PROC				; COMDAT

; 2977 : {

	push	ebp
	mov	ebp, esp

; 2978 :   facetedge_id fe;
; 2979 :   int i,j,ii;
; 2980 :   WRAPTYPE wrap,fewrap;
; 2981 :   REAL *x;
; 2982 : 
; 2983 :   if ( web.modeltype == LAGRANGE )

	mov	eax, DWORD PTR _web+628
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	cmp	eax, 3
	jne	$LN33@get_facet_@6

; 2984 :   { vertex_id *v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ecx+304]

; 2985 :     int k = web.skel[FACET].ctrlpts;

	mov	ecx, DWORD PTR _web+232

; 2986 :     for ( i = 0 ; i < k ; i++ )

	test	ecx, ecx
	jle	$LN4@get_facet_@6

; 2984 :   { vertex_id *v = get_facet_vertices(f_id);

	mov	edi, DWORD PTR _verts$[ebp]
	mov	esi, DWORD PTR _web+616

; 2986 :     for ( i = 0 ; i < k ; i++ )

	mov	ebx, eax
	sub	ebx, edi
	mov	DWORD PTR tv480[ebp], ecx
	npad	7
$LL90@get_facet_@6:

; 2987 :      { x = get_coord(v[i]);

	mov	edx, DWORD PTR [ebx+edi]
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+eax+64]

; 2988 :        for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN31@get_facet_@6
	mov	eax, DWORD PTR [edi]
	sub	ecx, eax
	npad	6
$LL29@get_facet_@6:

; 2989 :           verts[i][j] = x[j];

	fld	QWORD PTR [ecx+eax]
	inc	edx
	fstp	QWORD PTR [eax]
	mov	esi, DWORD PTR _web+616
	add	eax, 8
	cmp	edx, esi
	jl	SHORT $LL29@get_facet_@6
$LN31@get_facet_@6:

; 2986 :     for ( i = 0 ; i < k ; i++ )

	add	edi, 4
	dec	DWORD PTR tv480[ebp]
	jne	SHORT $LL90@get_facet_@6
	pop	edi
	pop	esi
	pop	ebx

; 3041 :     }
; 3042 : } // end get_facet_verts_special()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@get_facet_@6:

; 2990 :      }
; 2991 :      return;
; 2992 :   }
; 2993 : 
; 2994 :   if ( (web.modeltype == QUADRATIC) && verts[3] ) 

	mov	edi, DWORD PTR _verts$[ebp]
	xor	ebx, ebx
	cmp	eax, 2
	jne	SHORT $LN26@get_facet_@6
	cmp	DWORD PTR [edi+12], ebx
	je	SHORT $LN26@get_facet_@6

; 2995 :   { get_facet_verts_q(f_id,verts,wraps); return; }

	mov	ecx, DWORD PTR _wraps$[ebp]
	mov	edx, DWORD PTR _f_id$[ebp]
	push	ecx
	push	edi
	push	edx
	call	_get_facet_verts_q
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 3041 :     }
; 3042 : } // end get_facet_verts_special()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@get_facet_@6:

; 2996 : 
; 2997 :   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3

; 2998 :   { vertex_id *v = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	jne	$LN25@get_facet_@6
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+328
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ecx+304]

; 2999 :     for ( i = 0 ; i <= web.dimension ; i++ )

	mov	DWORD PTR _i$[ebp], ebx
	cmp	DWORD PTR _web+620, ebx
	jl	$LN4@get_facet_@6
	mov	esi, DWORD PTR _web+616
	mov	ebx, eax
	sub	ebx, edi
	npad	13
$LL91@get_facet_@6:

; 3000 :      { x = get_coord(v[i]);

	mov	edx, DWORD PTR [ebx+edi]
	mov	eax, DWORD PTR _web+12
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+eax+64]

; 3001 :        for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN23@get_facet_@6
	mov	eax, DWORD PTR [edi]
	sub	ecx, eax
	npad	6
$LL21@get_facet_@6:

; 3002 :           verts[i][j] = x[j];

	fld	QWORD PTR [eax+ecx]
	inc	edx
	fstp	QWORD PTR [eax]
	mov	esi, DWORD PTR _web+616
	add	eax, 8
	cmp	edx, esi
	jl	SHORT $LL21@get_facet_@6
$LN23@get_facet_@6:

; 2999 :     for ( i = 0 ; i <= web.dimension ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	edi, 4
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _web+620
	jle	SHORT $LL91@get_facet_@6
	pop	edi
	pop	esi
	pop	ebx

; 3041 :     }
; 3042 : } // end get_facet_verts_special()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@get_facet_@6:

; 3003 :      }
; 3004 :      return;
; 3005 :   }
; 3006 : 
; 3007 :   fe = get_facet_fe(f_id);

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN37@get_facet_@6
	xor	esi, esi
	jmp	SHORT $LN36@get_facet_@6
$LN37@get_facet_@6:
	mov	edx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	esi, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN36@get_facet_@6
	xor	esi, 134217728				; 08000000H
$LN36@get_facet_@6:

; 3008 :   if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, ebx
	je	$LN18@get_facet_@6

; 3009 :   {
; 3010 :     /* start with point closest to origin */
; 3011 :     if ( !(sym_flags & HAS_FIXED_PTS) )

	test	BYTE PTR _sym_flags, 1

; 3016 :       for ( i = 0 ; i < FACET_VERTS ; i++, fe = get_next_edge(fe) )

	mov	ecx, DWORD PTR _web+460
	jne	$LN17@get_facet_@6

; 3012 :     { REAL dd,mindd;
; 3013 :       int mini=0;

	fld	QWORD PTR __real@483d6329f1c35ca5
	mov	DWORD PTR _mini$91034[ebp], ebx

; 3014 :       facetedge_id minfe=fe;
; 3015 :       mindd = 1e40;

	fstp	QWORD PTR _mindd$91033[ebp]
	mov	DWORD PTR _minfe$91035[ebp], esi
$LL88@get_facet_@6:

; 3017 :       { x = get_coord(get_fe_tailv(fe));

	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, esi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	push	eax
	call	_get_edge_tailv
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ecx+64]

; 3018 :          dd = SDIM_dot(x,x);

	mov	edx, DWORD PTR _web+616
	push	edx
	push	eax
	push	eax
	call	_dot

; 3019 :          if ( dd < 0.9*mindd ) { mindd = dd; mini = i; minfe = fe;}

	fld	QWORD PTR _mindd$91033[ebp]
	fmul	QWORD PTR __real@3feccccccccccccd
	add	esp, 16					; 00000010H
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN93@get_facet_@6
	fstp	QWORD PTR _mindd$91033[ebp]
	mov	DWORD PTR _mini$91034[ebp], ebx
	mov	DWORD PTR _minfe$91035[ebp], esi
	jmp	SHORT $LN15@get_facet_@6
$LN93@get_facet_@6:
	fstp	ST(0)
$LN15@get_facet_@6:

; 3016 :       for ( i = 0 ; i < FACET_VERTS ; i++, fe = get_next_edge(fe) )

	mov	ecx, DWORD PTR _web+460
	inc	ebx
	test	esi, 134217728				; 08000000H
	je	SHORT $LN41@get_facet_@6
	mov	eax, DWORD PTR [edi+ecx]
	mov	esi, DWORD PTR [eax+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN80@get_facet_@6
$LN41@get_facet_@6:
	mov	edx, DWORD PTR [edi+ecx]
	mov	esi, DWORD PTR [edx+32]
$LN80@get_facet_@6:
	cmp	ebx, 3
	jl	$LL88@get_facet_@6

; 3020 :       }
; 3021 :       i = mini;

	mov	eax, DWORD PTR _mini$91034[ebp]

; 3022 :       fe = minfe;

	mov	esi, DWORD PTR _minfe$91035[ebp]
	mov	DWORD PTR _i$[ebp], eax
	xor	ebx, ebx
	jmp	SHORT $LN12@get_facet_@6
$LN17@get_facet_@6:

; 3023 :     }
; 3024 :     else { i = 0; }

	mov	DWORD PTR _i$[ebp], ebx
$LN12@get_facet_@6:

; 3025 :     wrap = 0;
; 3026 :     for ( ii = 0 ; ii < FACET_VERTS ; ii++ )

	xor	eax, eax
	mov	DWORD PTR _wrap$[ebp], ebx
	mov	DWORD PTR _ii$[ebp], eax
$LL84@get_facet_@6:

; 3027 :     { int jj = (i+ii)%FACET_VERTS;

	add	eax, DWORD PTR _i$[ebp]
	mov	edi, 3
	cdq
	idiv	edi

; 3028 :       x = get_coord(get_fe_tailv(fe));

	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _web+124
	mov	ebx, esi
	and	ebx, 134217728				; 08000000H
	xor	eax, ebx
	mov	DWORD PTR _jj$91048[ebp], edx
	test	eax, 134217728				; 08000000H
	je	SHORT $LN49@get_facet_@6
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN48@get_facet_@6
$LN49@get_facet_@6:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]
$LN48@get_facet_@6:
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+104
	add	eax, DWORD PTR [edx+ecx+64]

; 3029 :       if ( wraps ) wraps[jj] = wrap;

	mov	ecx, DWORD PTR _wraps$[ebp]
	mov	DWORD PTR _x$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN86@get_facet_@6
	mov	eax, DWORD PTR _jj$91048[ebp]
	mov	edx, DWORD PTR _wrap$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _x$[ebp]
$LN86@get_facet_@6:

; 3030 :       (*sym_wrap)(x,verts[jj],wrap);

	mov	ecx, DWORD PTR _wrap$[ebp]
	mov	edx, DWORD PTR _verts$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _jj$91048[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	push	edx
	push	eax
	call	DWORD PTR _sym_wrap

; 3031 :       fewrap = get_fe_wrap(fe);

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _web+124
	xor	eax, ebx
	mov	ebx, DWORD PTR _dymem
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+ebx+784]
	mov	ecx, DWORD PTR [edx+ecx]
	add	esp, 12					; 0000000cH
	test	eax, 134217728				; 08000000H
	je	SHORT $LN56@get_facet_@6
	push	ecx
	call	DWORD PTR _sym_inverse
	add	esp, 4
	jmp	SHORT $LN57@get_facet_@6
$LN56@get_facet_@6:
	mov	eax, ecx
$LN57@get_facet_@6:

; 3032 :       wrap = (*sym_compose)(wrap,fewrap);

	mov	edx, DWORD PTR _wrap$[ebp]
	push	eax
	push	edx
	call	DWORD PTR _sym_compose

; 3033 :       fe = get_next_edge(fe);

	mov	ecx, DWORD PTR _web+460
	add	esp, 8
	mov	DWORD PTR _wrap$[ebp], eax
	test	esi, 134217728				; 08000000H
	je	SHORT $LN59@get_facet_@6
	mov	eax, DWORD PTR [edi+ecx]
	mov	esi, DWORD PTR [eax+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN10@get_facet_@6
$LN59@get_facet_@6:
	mov	edx, DWORD PTR [edi+ecx]
	mov	esi, DWORD PTR [edx+32]
$LN10@get_facet_@6:

; 3025 :     wrap = 0;
; 3026 :     for ( ii = 0 ; ii < FACET_VERTS ; ii++ )

	mov	eax, DWORD PTR _ii$[ebp]
	inc	eax
	mov	DWORD PTR _ii$[ebp], eax
	cmp	eax, 3
	jl	$LL84@get_facet_@6
	pop	edi
	pop	esi
	pop	ebx

; 3041 :     }
; 3042 : } // end get_facet_verts_special()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@get_facet_@6:

; 3034 :     }
; 3035 :   }
; 3036 :   else for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	DWORD PTR _i$[ebp], ebx
	mov	ebx, DWORD PTR _web+460
$LL89@get_facet_@6:

; 3037 :     { x = get_coord(get_fe_tailv(fe));

	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+ebx]
	mov	ecx, esi
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_get_edge_tailv
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+eax+64]

; 3038 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	add	esp, 4
	cmp	DWORD PTR _web+616, edx
	jle	SHORT $LN1@get_facet_@6

; 3034 :     }
; 3035 :   }
; 3036 :   else for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR _verts$[ebp]
	mov	ebx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]

; 3038 :       for ( j = 0 ; j < SDIM ; j++ )

	sub	ecx, eax
$LL87@get_facet_@6:

; 3039 :         verts[i][j] = x[j];

	fld	QWORD PTR [eax+ecx]
	inc	edx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	edx, DWORD PTR _web+616
	jl	SHORT $LL87@get_facet_@6

; 3038 :       for ( j = 0 ; j < SDIM ; j++ )

	mov	ebx, DWORD PTR _web+460
$LN1@get_facet_@6:

; 3040 :       fe = get_next_edge(fe);

	test	esi, 134217728				; 08000000H
	je	SHORT $LN65@get_facet_@6
	mov	ecx, DWORD PTR [edi+ebx]
	mov	esi, DWORD PTR [ecx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN5@get_facet_@6
$LN65@get_facet_@6:
	mov	edx, DWORD PTR [edi+ebx]
	mov	esi, DWORD PTR [edx+32]
$LN5@get_facet_@6:

; 3034 :     }
; 3035 :   }
; 3036 :   else for ( i = 0 ; i < FACET_VERTS ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, 3
	jl	$LL89@get_facet_@6
$LN4@get_facet_@6:
	pop	edi
	pop	esi
	pop	ebx

; 3041 :     }
; 3042 : } // end get_facet_verts_special()

	mov	esp, ebp
	pop	ebp
	ret	0
_get_facet_verts_special ENDP
_TEXT	ENDS
PUBLIC	_make_vedge_lists
EXTRN	_vedge_timestamp:DWORD
; Function compile flags: /Ogtp
;	COMDAT _make_vedge_lists
_TEXT	SEGMENT
tv461 = -8						; size = 8
_make_vedge_lists PROC					; COMDAT

; 3620 : { vertex_id v_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3621 :   edge_id e_id;
; 3622 : 
; 3623 :   if ( web.representation == SIMPLEX ) return;

	cmp	DWORD PTR _web+624, 3
	je	$LN18@make_vedge

; 3624 : 
; 3625 :   /* clear out all old data */
; 3626 :   MFOR_ALL_EDGES(e_id)

	mov	edx, DWORD PTR _web+160
	push	ebx
	mov	ebx, DWORD PTR _web+124
	push	esi
	push	edi
	test	edx, 268435456				; 10000000H
	je	SHORT $LN14@make_vedge
	npad	6
$LL16@make_vedge:
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	esi, DWORD PTR [ecx+ebx]
	mov	eax, DWORD PTR [esi+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN15@make_vedge

; 3627 :   { set_next_tail_edge(e_id,NULLID);

	mov	eax, edx
	shr	eax, 27					; 0000001bH
	and	eax, 1
	mov	DWORD PTR [esi+eax*4+32], edi

; 3628 :     set_next_tail_edge(inverse_id(e_id),NULLID);

	mov	esi, DWORD PTR _web+124
	mov	eax, edx
	xor	eax, 134217728				; 08000000H
	mov	edx, eax
	shr	edx, 27					; 0000001bH
	and	edx, 1
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [eax+edx*4+32], edi
	mov	ebx, DWORD PTR _web+124
$LN15@make_vedge:

; 3624 : 
; 3625 :   /* clear out all old data */
; 3626 :   MFOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR [ecx+ebx]
	mov	edx, DWORD PTR [ecx]
	test	edx, 268435456				; 10000000H
	jne	SHORT $LL16@make_vedge
$LN14@make_vedge:

; 3629 :   }
; 3630 :   MFOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+48
	test	eax, 268435456				; 10000000H
	je	SHORT $LN9@make_vedge
	mov	ebx, DWORD PTR _web+12
	npad	3
$LL11@make_vedge:
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	edx, DWORD PTR [esi+ebx]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR tv461[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN10@make_vedge

; 3631 :   { if ( !(get_vattr(v_id) & (Q_MIDEDGE|Q_MIDFACET|Q_MIDPOINT)) )

	and	ecx, 6422528				; 00620000H
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN10@make_vedge

; 3632 :       set_vertex_edge(v_id,NULLID);

	mov	DWORD PTR [edx+28], eax
	mov	ebx, DWORD PTR _web+12
$LN10@make_vedge:

; 3629 :   }
; 3630 :   MFOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR [esi+ebx]
	mov	eax, DWORD PTR [ecx]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL11@make_vedge
	mov	ebx, DWORD PTR _web+124
$LN9@make_vedge:

; 3633 :   }
; 3634 : 
; 3635 :   /* now splice in all edges */
; 3636 :   MFOR_ALL_EDGES(e_id)

	mov	edi, DWORD PTR _web+160
	test	edi, 268435456				; 10000000H
	je	$LN3@make_vedge
	npad	6
$LL5@make_vedge:
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+ebx]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN4@make_vedge

; 3637 :   { insert_vertex_edge(get_edge_tailv(e_id),e_id);

	mov	ebx, edi
	shr	ebx, 27					; 0000001bH
	and	ebx, 1
	je	SHORT $LN25@make_vedge
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+eax+304]
	mov	eax, DWORD PTR _web+636
	lea	edx, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [edx+ecx]
	jmp	SHORT $LN24@make_vedge
$LN25@make_vedge:
	mov	eax, DWORD PTR _web+216
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+304]
	mov	ecx, DWORD PTR [ecx+eax]
$LN24@make_vedge:
	push	edi
	push	ecx
	call	_insert_vertex_edge

; 3638 :     insert_vertex_edge(get_edge_headv(e_id),inverse_id(e_id));

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	esp, 8
	test	ebx, ebx
	je	SHORT $LN29@make_vedge
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]
	jmp	SHORT $LN28@make_vedge
$LN29@make_vedge:
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]
$LN28@make_vedge:
	xor	edi, 134217728				; 08000000H
	push	edi
	push	eax
	call	_insert_vertex_edge
	mov	ebx, DWORD PTR _web+124
	add	esp, 8
$LN4@make_vedge:

; 3633 :   }
; 3634 : 
; 3635 :   /* now splice in all edges */
; 3636 :   MFOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR [esi+ebx]
	mov	edi, DWORD PTR [ecx]
	test	edi, 268435456				; 10000000H
	jne	$LL5@make_vedge
$LN3@make_vedge:

; 3639 :   }
; 3640 :   vedge_timestamp = top_timestamp; 

	mov	edx, DWORD PTR _top_timestamp
	pop	edi
	pop	esi
	mov	DWORD PTR _vedge_timestamp, edx
	pop	ebx
$LN18@make_vedge:

; 3641 : } // end make_vedge_lists()

	mov	esp, ebp
	pop	ebp
	ret	0
_make_vedge_lists ENDP
_TEXT	ENDS
PUBLIC	_get_next_vertex_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_vertex_facet
_TEXT	SEGMENT
tv405 = -20						; size = 4
_start_e$ = -16						; size = 4
_first_fe$ = -12					; size = 4
_found$ = -8						; size = 4
_start_fe$ = -4						; size = 4
_v_id$ = 8						; size = 4
_prev_id$ = 12						; size = 4
_get_next_vertex_facet PROC				; COMDAT

; 4012 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 4013 :   edge_id start_e,ee_id;
; 4014 :   facetedge_id fe_id,start_fe, first_fe = NULLID;
; 4015 :   facet_id next_f;
; 4016 :   int found; /* whether old f_id found yet */
; 4017 : 
; 4018 :   if ( web.representation == SIMPLEX ) 

	cmp	DWORD PTR _web+624, 3

; 4019 :   {
; 4020 :     return get_simplex_next_vertex_facet(v_id,prev_id);

	mov	eax, DWORD PTR _prev_id$[ebp]
	mov	DWORD PTR _first_fe$[ebp], 0
	jne	SHORT $LN18@get_next_v
	mov	ecx, DWORD PTR _v_id$[ebp]
	push	eax
	push	ecx
	call	_get_simplex_next_vertex_facet
	add	esp, 8

; 4064 :     return first_fe; /* looped all the way around */
; 4065 : 
; 4066 :   return NULLID;
; 4067 : } // end get_next_vertex_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@get_next_v:

; 4021 :   }
; 4022 : 
; 4023 :   if ( id_type(prev_id) == FACET )

	mov	edx, eax
	and	edx, -536870912				; e0000000H
	cmp	edx, 1073741824				; 40000000H
	jne	SHORT $LN17@get_next_v

; 4024 :     return NULLID;  /* interior Lagrange point */

	xor	eax, eax

; 4064 :     return first_fe; /* looped all the way around */
; 4065 : 
; 4066 :   return NULLID;
; 4067 : } // end get_next_vertex_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@get_next_v:

; 4025 : 
; 4026 :   /* now trace loop of edges and facetedges */
; 4027 :   start_e = get_vertex_edge(v_id);

	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	esi
	mov	esi, DWORD PTR [ecx+28]
	mov	DWORD PTR _start_e$[ebp], esi

; 4028 :   if ( !valid_id(start_e) ) return NULLID;

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN16@get_next_v
	xor	eax, eax
	pop	esi

; 4064 :     return first_fe; /* looped all the way around */
; 4065 : 
; 4066 :   return NULLID;
; 4067 : } // end get_next_vertex_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@get_next_v:

; 4029 :   ee_id = start_e;
; 4030 :   found = !valid_id(prev_id);

	shr	eax, 28					; 0000001cH
	push	ebx
	not	eax
	and	eax, 1
	push	edi
	mov	edi, DWORD PTR _web+460
	mov	ebx, esi
	mov	DWORD PTR _found$[ebp], eax
	npad	3
$LL15@get_next_v:

; 4031 :   do
; 4032 :   { fe_id = start_fe = get_edge_fe(ee_id);

	mov	ecx, DWORD PTR _web+124
	mov	edx, ebx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv405[ebp], edx
	test	edx, edx
	jne	SHORT $LN22@get_next_v
	xor	ecx, ecx
	mov	DWORD PTR _start_fe$[ebp], ecx
	jmp	SHORT $LN23@get_next_v
$LN22@get_next_v:
	mov	ecx, DWORD PTR [edx+28]
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN21@get_next_v
	xor	ecx, 134217728				; 08000000H
$LN21@get_next_v:
	mov	DWORD PTR _start_fe$[ebp], ecx
$LN23@get_next_v:

; 4033 :     if ( valid_id(fe_id) ) 

	test	ecx, 268435456				; 10000000H
	je	$LN9@get_next_v
	npad	1
$LL11@get_next_v:

; 4034 :     do
; 4035 :     { 
; 4036 :       facetedge_id ret_fe = fe_id;  /* return value */

	mov	eax, ecx

; 4037 :       next_f = get_fe_facet(fe_id);

	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN26@get_next_v
	mov	esi, DWORD PTR _NULLFACET
	jmp	SHORT $LN27@get_next_v
$LN26@get_next_v:
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [edx+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN25@get_next_v
	xor	edx, 134217728				; 08000000H
$LN25@get_next_v:
	mov	esi, edx
$LN27@get_next_v:

; 4038 : 
; 4039 :       if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN45@get_next_v

; 4040 :       { if ( !valid_id(next_f) ) 

	test	esi, 268435456				; 10000000H
	je	$LN41@get_next_v

; 4042 :         if ( !valid_id(get_prev_edge(fe_id)) && inverted(next_f) )

	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+edx*4]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN30@get_next_v
	mov	edx, DWORD PTR [edx+32]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN29@get_next_v
$LN30@get_next_v:
	mov	edx, DWORD PTR [edx+28]
$LN29@get_next_v:
	test	edx, 268435456				; 10000000H
	jne	SHORT $LN45@get_next_v
	test	esi, 134217728				; 08000000H
	je	SHORT $LN52@get_next_v

; 4043 :         { /* in case facet doesn't have positive facet */
; 4044 :           next_f = positive_id(next_f);
; 4045 :           ret_fe = inverse_id(fe_id);

	mov	eax, ecx
	and	esi, -134217729				; f7ffffffH
	xor	eax, 134217728				; 08000000H
$LN45@get_next_v:

; 4046 :         }
; 4047 :       }
; 4048 :       
; 4049 :       if ( !inverted(next_f) ) 

	test	esi, 134217728				; 08000000H
	jne	SHORT $LN2@get_next_v
$LN52@get_next_v:

; 4050 :       { if ( !valid_id(first_fe) )

	test	DWORD PTR _first_fe$[ebp], 268435456	; 10000000H
	jne	SHORT $LN4@get_next_v

; 4051 :           first_fe = ret_fe;

	mov	DWORD PTR _first_fe$[ebp], eax
$LN4@get_next_v:

; 4052 :         if ( found )

	cmp	DWORD PTR _found$[ebp], 0
	jne	SHORT $LN49@get_next_v

; 4053 :           return ret_fe;
; 4054 :         if ( equal_element(fe_id,prev_id) )

	mov	edx, DWORD PTR _prev_id$[ebp]
	mov	eax, ecx
	or	eax, 134217728				; 08000000H
	or	edx, 134217728				; 08000000H
	cmp	eax, edx
	jne	SHORT $LN2@get_next_v

; 4055 :           found = 1;

	mov	DWORD PTR _found$[ebp], 1
$LN2@get_next_v:

; 4056 :       }
; 4057 :       fe_id = get_next_facet(fe_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN34@get_next_v
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN10@get_next_v
$LN34@get_next_v:
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [ecx+40]
$LN10@get_next_v:

; 4058 :     } while ( !equal_id(start_fe,fe_id) );

	cmp	DWORD PTR _start_fe$[ebp], ecx
	jne	$LL11@get_next_v
	mov	esi, DWORD PTR _start_e$[ebp]
	mov	eax, DWORD PTR _found$[ebp]
	mov	edx, DWORD PTR tv405[ebp]
$LN9@get_next_v:

; 4059 : 
; 4060 :     ee_id = get_next_tail_edge(ee_id);

	shr	ebx, 27					; 0000001bH
	and	ebx, 1
	mov	ebx, DWORD PTR [edx+ebx*4+32]

; 4061 :   } while ( !equal_id(ee_id,start_e) );

	cmp	ebx, esi
	jne	$LL15@get_next_v

; 4062 : 
; 4063 :   if ( found )

	neg	eax
	sbb	eax, eax
	and	eax, DWORD PTR _first_fe$[ebp]
$LN49@get_next_v:
	pop	edi
	pop	ebx
	pop	esi

; 4064 :     return first_fe; /* looped all the way around */
; 4065 : 
; 4066 :   return NULLID;
; 4067 : } // end get_next_vertex_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@get_next_v:
	pop	edi
	pop	ebx

; 4041 :            return NULLID;

	xor	eax, eax
	pop	esi

; 4064 :     return first_fe; /* looped all the way around */
; 4065 : 
; 4066 :   return NULLID;
; 4067 : } // end get_next_vertex_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
_get_next_vertex_facet ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@CEPFIHDM@Internal?5error?3?5Vertex?5facet?5loo@ ; `string'
PUBLIC	_insert_vertex_facet
;	COMDAT ??_C@_0CP@CEPFIHDM@Internal?5error?3?5Vertex?5facet?5loo@
CONST	SEGMENT
??_C@_0CP@CEPFIHDM@Internal?5error?3?5Vertex?5facet?5loo@ DB 'Internal er'
	DB	'ror: Vertex facet loop not closed.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _insert_vertex_facet
_TEXT	SEGMENT
_ff_id$ = -4						; size = 4
_n$ = 8							; size = 4
_v_id$ = 8						; size = 4
_f_id$ = 12						; size = 4
_insert_vertex_facet PROC				; COMDAT

; 4087 : { facet_id ff_id,fff_id;

	push	ebp
	mov	ebp, esp
	push	ecx

; 4088 :   int n;
; 4089 : 
; 4090 :   ff_id = get_vertex_facet(v_id);

	mov	eax, DWORD PTR _web+12
	push	ebx

; 4091 :   if ( !valid_id(ff_id) )
; 4092 :   { set_next_vertex_facet(v_id,f_id,f_id);

	mov	ebx, DWORD PTR _f_id$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _v_id$[ebp]
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [ecx+32]
	mov	DWORD PTR _ff_id$[ebp], eax
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN6@insert_ver@2
	push	ebx
	push	ebx
	push	edi
	call	_set_next_vertex_facet

; 4093 :     set_vertex_facet(v_id,f_id);

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [esi+edx]
	mov	DWORD PTR [eax+32], ebx

; 4094 :     set_vertex_facet(v_id,f_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [esi+ecx]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+32], ebx
	pop	ebx

; 4112 : } // end insert_vertex_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@insert_ver@2:

; 4095 :     return;
; 4096 :   }
; 4097 :   /* go around to be sure not already there */
; 4098 :   fff_id = ff_id; n = 0;

	mov	esi, eax
	mov	DWORD PTR _n$[ebp], 0
	or	ebx, 134217728				; 08000000H
$LL5@insert_ver@2:

; 4099 :   do 
; 4100 :   { fff_id = get_next_vertex_facet(v_id,fff_id);

	push	esi
	push	edi
	call	_get_next_vertex_facet
	mov	esi, eax

; 4101 :     if ( equal_element(fff_id,f_id) ) return;

	or	eax, 134217728				; 08000000H
	add	esp, 8
	cmp	eax, ebx
	je	SHORT $LN7@insert_ver@2

; 4102 :     if ( ++n > 2*web.skel[FACET].count+5 ) /* sanity check */

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _web+288
	inc	eax
	lea	edx, DWORD PTR [ecx+ecx+5]
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, edx
	jg	SHORT $LN12@insert_ver@2

; 4104 :       return;
; 4105 :     }
; 4106 :   } while ( !equal_id(fff_id,ff_id) );

	cmp	esi, DWORD PTR _ff_id$[ebp]
	jne	SHORT $LL5@insert_ver@2

; 4107 : 
; 4108 :   /* insert into existing list */
; 4109 :   ff_id = get_next_vertex_facet(v_id,fff_id);

	push	esi
	push	edi
	call	_get_next_vertex_facet
	mov	ebx, eax

; 4110 :   set_next_vertex_facet(v_id,fff_id,f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	eax
	push	esi
	push	edi
	call	_set_next_vertex_facet

; 4111 :   set_next_vertex_facet(v_id,f_id,ff_id);

	mov	ecx, DWORD PTR _f_id$[ebp]
	push	ebx
	push	ecx
	push	edi
	call	_set_next_vertex_facet
	add	esp, 32					; 00000020H
$LN7@insert_ver@2:
	pop	edi
	pop	esi
	pop	ebx

; 4112 : } // end insert_vertex_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@insert_ver@2:

; 4103 :     { kb_error(2441,"Internal error: Vertex facet loop not closed.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CP@CEPFIHDM@Internal?5error?3?5Vertex?5facet?5loo@
	push	2441					; 00000989H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 4112 : } // end insert_vertex_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
_insert_vertex_facet ENDP
_TEXT	ENDS
PUBLIC	_remove_vertex_facet
; Function compile flags: /Ogtp
;	COMDAT _remove_vertex_facet
_TEXT	SEGMENT
tv225 = -8						; size = 4
_fff_id$ = -4						; size = 4
_ff_id$ = -4						; size = 4
tv236 = 8						; size = 4
_v_id$ = 8						; size = 4
_f_id$ = 12						; size = 4
_remove_vertex_facet PROC				; COMDAT

; 4125 : { facet_id ff_id,fff_id,ffff_id; 

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4126 :   int n = 0;
; 4127 : 
; 4128 :   /* find it */
; 4129 :   ff_id = get_vertex_facet(v_id);

	mov	ecx, DWORD PTR _web+12
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _v_id$[ebp]
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	mov	esi, DWORD PTR [edx+32]
	xor	ebx, ebx
	mov	DWORD PTR tv225[ebp], eax
	mov	DWORD PTR _ff_id$[ebp], esi

; 4130 :   if ( !valid_id(ff_id)) return;

	test	esi, 268435456				; 10000000H
	je	$LN1@remove_ver@2

; 4131 :   fff_id = ff_id;

	mov	eax, DWORD PTR _f_id$[ebp]
	or	eax, 134217728				; 08000000H
	mov	DWORD PTR tv236[ebp], eax
$LL11@remove_ver@2:

; 4132 :   do
; 4133 :   { if ( equal_element(fff_id,f_id) ) break;

	mov	ecx, esi
	or	ecx, 134217728				; 08000000H
	cmp	ecx, eax
	je	SHORT $LN9@remove_ver@2

; 4134 :     fff_id = get_next_vertex_facet(v_id,fff_id);

	push	esi
	push	edi
	call	_get_next_vertex_facet

; 4135 :     if ( ++n > 2*web.skel[FACET].count ) /* sanity check */ 

	mov	edx, DWORD PTR _web+288
	mov	esi, eax
	inc	ebx
	lea	eax, DWORD PTR [edx+edx]
	add	esp, 8
	cmp	ebx, eax
	jg	SHORT $LN18@remove_ver@2

; 4137 :       break;
; 4138 :     }
; 4139 :   } while ( !equal_element(fff_id,ff_id) );

	mov	edx, DWORD PTR _ff_id$[ebp]
	mov	ecx, esi
	or	ecx, 134217728				; 08000000H
	or	edx, 134217728				; 08000000H
	cmp	ecx, edx
	je	SHORT $LN9@remove_ver@2
	mov	eax, DWORD PTR tv236[ebp]
	jmp	SHORT $LL11@remove_ver@2
$LN18@remove_ver@2:

; 4136 :     { kb_error(2442,"Internal error: Vertex facet loop not closed.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CP@CEPFIHDM@Internal?5error?3?5Vertex?5facet?5loo@
	push	2442					; 0000098aH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN9@remove_ver@2:

; 4140 :   if ( !equal_id(fff_id,f_id) ) return;

	mov	eax, DWORD PTR _f_id$[ebp]
	cmp	esi, eax
	jne	$LN1@remove_ver@2

; 4141 : 
; 4142 :   ff_id = get_next_vertex_facet(v_id,f_id);

	push	eax
	push	edi
	call	_get_next_vertex_facet
	mov	ebx, eax

; 4143 :   if ( equal_element(f_id,ff_id) )

	or	eax, 134217728				; 08000000H
	add	esp, 8
	cmp	DWORD PTR tv236[ebp], eax
	jne	SHORT $LN5@remove_ver@2

; 4144 :     { set_vertex_facet(v_id,NULLID);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR tv225[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+32], 0
	pop	ebx

; 4163 : } // end remove_vertex_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@remove_ver@2:

; 4145 :       return;
; 4146 :     }
; 4147 :   fff_id = ff_id;
; 4148 :   ffff_id = get_next_vertex_facet(v_id,ff_id);

	push	ebx
	push	edi
	mov	DWORD PTR _fff_id$[ebp], ebx
	call	_get_next_vertex_facet

; 4149 :   n = 0;
; 4150 :   while ( !equal_element(f_id,ffff_id) )

	mov	ecx, eax
	or	ecx, 134217728				; 08000000H
	add	esp, 8
	xor	esi, esi
	cmp	DWORD PTR tv236[ebp], ecx
	je	SHORT $LN3@remove_ver@2
	npad	3
$LL4@remove_ver@2:

; 4151 :     { fff_id = ffff_id;
; 4152 :       ffff_id = get_next_vertex_facet(v_id,fff_id);

	push	eax
	push	edi
	mov	DWORD PTR _fff_id$[ebp], eax
	call	_get_next_vertex_facet

; 4153 :       if ( ++n > 2*web.skel[FACET].count ) /* sanity check */

	mov	edx, DWORD PTR _web+288
	inc	esi
	lea	ecx, DWORD PTR [edx+edx]
	add	esp, 8
	cmp	esi, ecx
	jg	SHORT $LN19@remove_ver@2

; 4149 :   n = 0;
; 4150 :   while ( !equal_element(f_id,ffff_id) )

	mov	edx, eax
	or	edx, 134217728				; 08000000H
	cmp	DWORD PTR tv236[ebp], edx
	jne	SHORT $LL4@remove_ver@2

; 4153 :       if ( ++n > 2*web.skel[FACET].count ) /* sanity check */

	jmp	SHORT $LN3@remove_ver@2
$LN19@remove_ver@2:

; 4154 :       { kb_error(2443,"Internal error: Vertex facet loop not closed.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CP@CEPFIHDM@Internal?5error?3?5Vertex?5facet?5loo@
	push	2443					; 0000098bH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN3@remove_ver@2:

; 4155 :         break;
; 4156 :       }
; 4157 :     }
; 4158 :   set_next_vertex_facet(v_id,fff_id,ff_id);

	mov	eax, DWORD PTR _fff_id$[ebp]
	push	ebx
	push	eax
	push	edi
	call	_set_next_vertex_facet

; 4159 :   set_next_vertex_facet(v_id,f_id,f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	eax
	push	eax
	push	edi
	call	_set_next_vertex_facet

; 4160 :   set_vertex_facet(v_id,ff_id);

	mov	ecx, DWORD PTR _web+12
	mov	eax, DWORD PTR tv225[ebp]
	mov	edx, DWORD PTR [eax+ecx]
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edx+32], ebx

; 4161 :   if ( web.representation==SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN1@remove_ver@2

; 4162 :      set_vertex_facet(v_id,ff_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [eax+ecx]
	mov	DWORD PTR [edx+32], ebx
$LN1@remove_ver@2:
	pop	edi
	pop	esi
	pop	ebx

; 4163 : } // end remove_vertex_facet()

	mov	esp, ebp
	pop	ebp
	ret	0
_remove_vertex_facet ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@NEGKEGG@Internal?5error?3?5Can?8t?5find?5verte@ ; `string'
PUBLIC	_norm$GSCopy$
PUBLIC	_f_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_lagrange_facet_normal
;	COMDAT ??_C@_0DD@NEGKEGG@Internal?5error?3?5Can?8t?5find?5verte@
CONST	SEGMENT
??_C@_0DD@NEGKEGG@Internal?5error?3?5Can?8t?5find?5verte@ DB 'Internal er'
	DB	'ror: Can''t find vertex %s in facet %s.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _lagrange_facet_normal
_TEXT	SEGMENT
_vxqXvS$ = -5556					; size = 400
_sidesqXvS$ = -5156					; size = 24
_kk$ = -5132						; size = 4
tv621 = -5128						; size = 4
_norm$GSCopy$ = -5124					; size = 4
_vx$ = -5120						; size = 4
_gl$ = -5116						; size = 4
_i$ = -5112						; size = 4
_f_id$GSCopy$ = -5108					; size = 4
_k$ = -5104						; size = 4
_sides$ = -5100						; size = 4
_ctrl$ = -5096						; size = 4
_vxxJ$ = -5092						; size = 4800
_sidesxJ$ = -292					; size = 288
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_f_id$ = 12						; size = 4
_norm$ = 16						; size = 4
_lagrange_facet_normal PROC				; COMDAT

; 2137 : { 

	push	ebp
	mov	ebp, esp
	mov	eax, 5556				; 000015b4H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2138 :   vertex_id *v = get_facet_vertices(f_id);
; 2139 :   struct gauss_lag *gl = &gauss_lagrange[web.dimension][web.gauss2D_order];
; 2140 :   MAT2D(sides,MAXCOORD,MAXCOORD);

	mov	eax, DWORD PTR _norm$[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR _web+328
	push	ebx
	push	esi
	mov	esi, DWORD PTR _f_id$[ebp]
	push	edi
	mov	edi, DWORD PTR _web+1596
	mov	DWORD PTR _f_id$GSCopy$[ebp], esi
	mov	DWORD PTR _norm$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _dymem
	and	esi, 134217727				; 07ffffffH
	mov	ebx, DWORD PTR [ecx+esi*4]
	add	ebx, DWORD PTR [edx+eax+304]
	mov	ecx, DWORD PTR _web+620
	push	6
	push	6
	lea	edx, DWORD PTR _sidesxJ$[ebp]
	shl	edi, 5
	add	edi, DWORD PTR _gauss_lagrange[ecx*4]
	push	edx
	lea	eax, DWORD PTR _sidesqXvS$[ebp]
	push	eax
	mov	DWORD PTR _gl$[ebp], edi
	call	_mat2d_setup

; 2141 :   MAT2D(vx,MAXVCOUNT,MAXCOORD);

	push	6
	push	100					; 00000064H
	lea	ecx, DWORD PTR _vxxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vxqXvS$[ebp]
	push	edx
	mov	DWORD PTR _sides$[ebp], eax
	call	_mat2d_setup

; 2142 :   int ctrl = web.skel[FACET].ctrlpts;
; 2143 :   int i,j,k,kk;
; 2144 : 
; 2145 :   get_facet_verts(f_id,vx,NULL);

	mov	edx, DWORD PTR _f_id$GSCopy$[ebp]
	mov	ecx, DWORD PTR _web+232
	push	0
	push	eax
	push	edx
	mov	DWORD PTR _vx$[ebp], eax
	mov	DWORD PTR _ctrl$[ebp], ecx
	call	_get_facet_verts

; 2146 :   for ( k = 0 ; k < ctrl ; k++ ) if ( v[k] == v_id ) break;

	mov	edx, DWORD PTR _ctrl$[ebp]
	xor	eax, eax
	add	esp, 44					; 0000002cH
	mov	DWORD PTR _k$[ebp], eax
	test	edx, edx
	jle	SHORT $LN46@lagrange_f
$LL49@lagrange_f:
	mov	ecx, DWORD PTR _v_id$[ebp]
	cmp	DWORD PTR [ebx+eax*4], ecx
	je	SHORT $LN34@lagrange_f
	inc	eax
	cmp	eax, edx
	jl	SHORT $LL49@lagrange_f
	mov	DWORD PTR _k$[ebp], eax

; 2147 :   if ( k >= ctrl )

	jmp	SHORT $LN44@lagrange_f
$LN34@lagrange_f:

; 2146 :   for ( k = 0 ; k < ctrl ; k++ ) if ( v[k] == v_id ) break;

	mov	DWORD PTR _k$[ebp], eax

; 2147 :   if ( k >= ctrl )

	cmp	eax, edx
	jl	$LN45@lagrange_f
	jmp	SHORT $LN44@lagrange_f
$LN46@lagrange_f:
	mov	ecx, DWORD PTR _v_id$[ebp]
$LN44@lagrange_f:

; 2148 :      { sprintf(errmsg,
; 2149 :           "Internal error: Can't find vertex %s in facet %s.\n",ELNAME(v_id),
; 2150 :              ELNAME1(f_id));

	test	DWORD PTR _f_id$GSCopy$[ebp], 268435456	; 10000000H
	je	SHORT $LN24@lagrange_f
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	mov	ecx, DWORD PTR _v_id$[ebp]
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN25@lagrange_f
$LN24@lagrange_f:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN25@lagrange_f:
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN26@lagrange_f
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN27@lagrange_f
$LN26@lagrange_f:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN27@lagrange_f:
	push	esi
	push	eax
	push	OFFSET ??_C@_0DD@NEGKEGG@Internal?5error?3?5Can?8t?5find?5verte@
	push	OFFSET _errmsg
	call	_sprintf

; 2151 :        kb_error(2210,errmsg,RECOVERABLE); 

	push	1
	push	OFFSET _errmsg
	push	2210					; 000008a2H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN45@lagrange_f:

; 2152 :      }
; 2153 : 
; 2154 :   for ( j = 0 ; j < SDIM ; j++ ) sides[0][j] = 0.0;

	mov	eax, DWORD PTR _web+616
	fldz
	mov	esi, DWORD PTR _sides$[ebp]
	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN14@lagrange_f
	mov	edx, DWORD PTR [esi]
$LN16@lagrange_f:
	fst	QWORD PTR [edx]
	mov	eax, DWORD PTR _web+616
	inc	ecx
	add	edx, 8
	cmp	ecx, eax
	jl	SHORT $LN16@lagrange_f
$LN14@lagrange_f:

; 2155 :   for ( i = 1 ; i <= web.dimension ; i++ )

	mov	ebx, 1
	mov	DWORD PTR _i$[ebp], ebx
	cmp	DWORD PTR _web+620, ebx
	jl	$LN77@lagrange_f
$LN13@lagrange_f:

; 2156 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	eax, eax
	jle	$LN12@lagrange_f

; 2157 :       for ( kk = 0, sides[i][j] = 0.0 ; kk < ctrl ; kk++ )

	mov	eax, DWORD PTR [esi+ebx*4]
	mov	DWORD PTR tv621[ebp], eax
$LN51@lagrange_f:
	mov	edx, DWORD PTR tv621[ebp]
	xor	eax, eax
	fst	QWORD PTR [edx+ecx*8]
	cmp	DWORD PTR _ctrl$[ebp], 4
	jl	$LC42@lagrange_f
	mov	eax, DWORD PTR [esi+ebx*4]
	mov	edx, DWORD PTR _vx$[ebp]
	lea	esi, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [edi+28]
	mov	edi, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	edi, DWORD PTR _ctrl$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4-4]
	add	edi, -4					; fffffffcH
	shr	edi, 2
	add	edx, 8
	add	eax, 16					; 00000010H
	inc	edi
	lea	ebx, DWORD PTR [edi*4]
	mov	DWORD PTR _kk$[ebp], ebx
$LN43@lagrange_f:

; 2158 :          sides[i][j] += gl->lpolypart[k][i-1][kk]*vx[kk][j];

	mov	ebx, DWORD PTR [edx-8]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [edx-4]
	fmul	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	add	edx, 16					; 00000010H
	dec	edi
	fadd	QWORD PTR [esi]
	fst	QWORD PTR [esi]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [edx-16]
	fmul	QWORD PTR [eax-40]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [esi]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [edx-12]
	fmul	QWORD PTR [eax-32]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [esi]
	fld	QWORD PTR [ebx+ecx*8]
	fmul	QWORD PTR [eax-24]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi]
	jne	SHORT $LN43@lagrange_f

; 2157 :       for ( kk = 0, sides[i][j] = 0.0 ; kk < ctrl ; kk++ )

	mov	edi, DWORD PTR _gl$[ebp]
	mov	ebx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _kk$[ebp]
	mov	esi, DWORD PTR _sides$[ebp]
$LC42@lagrange_f:
	cmp	eax, DWORD PTR _ctrl$[ebp]
	jge	SHORT $LN9@lagrange_f

; 2156 :     for ( j = 0 ; j < SDIM ; j++ )

	mov	edx, DWORD PTR [esi+ebx*4]
	lea	esi, DWORD PTR [edx+ecx*8]

; 2157 :       for ( kk = 0, sides[i][j] = 0.0 ; kk < ctrl ; kk++ )

	mov	edx, DWORD PTR [edi+28]
	mov	edi, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	edx, DWORD PTR [edx+ebx*4-4]
	lea	edx, DWORD PTR [edx+eax*8]
$LC7@lagrange_f:

; 2158 :          sides[i][j] += gl->lpolypart[k][i-1][kk]*vx[kk][j];

	mov	edi, DWORD PTR _vx$[ebp]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edi+ecx*8]
	inc	eax
	fmul	QWORD PTR [edx]
	add	edx, 8
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	cmp	eax, DWORD PTR _ctrl$[ebp]
	jl	SHORT $LC7@lagrange_f

; 2157 :       for ( kk = 0, sides[i][j] = 0.0 ; kk < ctrl ; kk++ )

	mov	edi, DWORD PTR _gl$[ebp]
	mov	esi, DWORD PTR _sides$[ebp]
$LN9@lagrange_f:

; 2156 :     for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	inc	ecx
	cmp	ecx, eax
	jl	$LN51@lagrange_f
$LN12@lagrange_f:

; 2155 :   for ( i = 1 ; i <= web.dimension ; i++ )

	inc	ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ebx, DWORD PTR _web+620
	jle	$LN13@lagrange_f
$LN77@lagrange_f:

; 2159 :   if ( inverted(f_id) ) 

	test	DWORD PTR _f_id$GSCopy$[ebp], 134217728	; 08000000H
	fstp	ST(0)
	je	SHORT $LN50@lagrange_f

; 2160 :      for ( j = 0 ; j < SDIM ; j++ ) sides[1][j] = -sides[1][j];

	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN50@lagrange_f
	mov	ecx, DWORD PTR [esi+4]
$LL3@lagrange_f:
	fld	QWORD PTR [ecx]
	inc	edx
	fchs
	add	ecx, 8
	fstp	QWORD PTR [ecx-8]
	mov	eax, DWORD PTR _web+616
	cmp	edx, eax
	jl	SHORT $LL3@lagrange_f
$LN50@lagrange_f:

; 2161 :   return kernel_basis_rows(sides+1,norm,web.dimension,SDIM);

	mov	ecx, DWORD PTR _norm$GSCopy$[ebp]
	push	eax
	mov	eax, DWORD PTR _web+620
	push	eax
	push	ecx
	add	esi, 4
	push	esi
	call	_kernel_basis_rows

; 2162 : } // end lagrange_facet_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_lagrange_facet_normal ENDP
_TEXT	ENDS
PUBLIC	_norm$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_quadratic_facet_normal
; Function compile flags: /Ogtp
;	COMDAT _quadratic_facet_normal
_TEXT	SEGMENT
_vxqXvS$ = -5568					; size = 400
_sidesqXvS$ = -5168					; size = 24
_norm$GSCopy$ = -5144					; size = 4
_gl$ = -5140						; size = 4
tv1094 = -5136						; size = 4
tv967 = -5136						; size = 4
_ctrl$ = -5132						; size = 4
_sides$ = -5128						; size = 4
_k$ = -5124						; size = 4
_fe_id$ = -5124						; size = 4
tv986 = -5120						; size = 4
_i$ = -5120						; size = 4
_vxxJ$ = -5116						; size = 4800
_sidesxJ$ = -316					; size = 288
_v$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_f_id$ = 12						; size = 4
_norm$ = 16						; size = 4
_quadratic_facet_normal PROC				; COMDAT

; 2216 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 5568				; 000015c0H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2244 :   return kernel_basis_rows(sides+1,norm,web.dimension,SDIM);

	mov	eax, DWORD PTR _norm$[ebp]
	mov	ecx, DWORD PTR _web+620
	push	ebx
	mov	DWORD PTR _norm$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _web+1596
	push	esi
	push	edi
	shl	eax, 5
	add	eax, DWORD PTR _gauss_lagrange[ecx*4]
	push	6
	push	6
	lea	edx, DWORD PTR _sidesxJ$[ebp]
	mov	DWORD PTR _gl$[ebp], eax
	push	edx
	lea	eax, DWORD PTR _sidesqXvS$[ebp]
	push	eax
	call	_mat2d_setup
	push	6
	push	100					; 00000064H
	lea	ecx, DWORD PTR _vxxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vxqXvS$[ebp]
	push	edx
	mov	DWORD PTR _sides$[ebp], eax
	call	_mat2d_setup
	mov	ecx, DWORD PTR _f_id$[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR _web+232
	mov	DWORD PTR _ctrl$[ebp], eax
	mov	eax, ecx
	shr	eax, 28					; 0000001cH
	add	esp, 32					; 00000020H
	and	eax, 1
	mov	DWORD PTR tv967[ebp], eax
	jne	SHORT $LN28@quadratic_@2

; 2217 :   vertex_id v[6];
; 2218 :   struct gauss_lag *gl = &gauss_lagrange[web.dimension][web.gauss2D_order];
; 2219 :   MAT2D(sides,MAXCOORD,MAXCOORD);
; 2220 :   MAT2D(vx,MAXVCOUNT,MAXCOORD);
; 2221 :   int ctrl = web.skel[FACET].ctrlpts;
; 2222 :   int i,j,k,kk;
; 2223 :   facetedge_id fe_id;
; 2224 : 
; 2225 :   fe_id = get_facet_fe(f_id);

	xor	eax, eax
	jmp	SHORT $LN27@quadratic_@2
$LN28@quadratic_@2:
	mov	eax, DWORD PTR _web+236
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edx+28]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN27@quadratic_@2
	xor	eax, 134217728				; 08000000H
$LN27@quadratic_@2:

; 2226 :   for ( i = 0 ; i < FACET_EDGES ; i++ )
; 2227 :      { v[qlconvert[2*i]] = get_fe_tailv(fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	esi, DWORD PTR [ecx+20]
	mov	edx, DWORD PTR _dymem
	mov	DWORD PTR _fe_id$[ebp], eax
	and	eax, 134217728				; 08000000H
	mov	DWORD PTR tv986[ebp], ecx
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+edx+304]
	mov	edx, DWORD PTR _web+124
	xor	eax, esi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN34@quadratic_@2
	mov	ebx, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN33@quadratic_@2
$LN34@quadratic_@2:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN33@quadratic_@2:
	mov	ebx, DWORD PTR _qlconvert
	mov	DWORD PTR _v$[ebp+ebx*4], eax

; 2228 :        v[qlconvert[2*i+1]] = get_fe_midv(fe_id);

	and	esi, 134217727				; 07ffffffH

; 2229 :        fe_id = get_next_edge(fe_id);

	test	DWORD PTR _fe_id$[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [eax+ecx+8]
	mov	esi, DWORD PTR _qlconvert+4
	mov	DWORD PTR _v$[ebp+esi*4], eax
	mov	eax, DWORD PTR tv986[ebp]
	je	SHORT $LN40@quadratic_@2
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN108@quadratic_@2
$LN40@quadratic_@2:
	mov	eax, DWORD PTR [eax+32]
$LN108@quadratic_@2:

; 2226 :   for ( i = 0 ; i < FACET_EDGES ; i++ )
; 2227 :      { v[qlconvert[2*i]] = get_fe_tailv(fe_id);

	mov	ebx, DWORD PTR _web+460
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+esi*4]

; 2229 :        fe_id = get_next_edge(fe_id);

	mov	DWORD PTR _fe_id$[ebp], eax
	mov	DWORD PTR tv986[ebp], esi
	mov	esi, DWORD PTR [esi+20]
	and	eax, 134217728				; 08000000H
	xor	eax, esi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN63@quadratic_@2

; 2226 :   for ( i = 0 ; i < FACET_EDGES ; i++ )
; 2227 :      { v[qlconvert[2*i]] = get_fe_tailv(fe_id);

	mov	ebx, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN64@quadratic_@2
$LN63@quadratic_@2:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN64@quadratic_@2:
	mov	ebx, DWORD PTR _qlconvert+8
	mov	DWORD PTR _v$[ebp+ebx*4], eax

; 2228 :        v[qlconvert[2*i+1]] = get_fe_midv(fe_id);

	and	esi, 134217727				; 07ffffffH

; 2229 :        fe_id = get_next_edge(fe_id);

	test	DWORD PTR _fe_id$[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR [edx+esi*4]
	mov	eax, DWORD PTR [eax+ecx+8]
	mov	esi, DWORD PTR _qlconvert+12
	mov	DWORD PTR _v$[ebp+esi*4], eax
	mov	eax, DWORD PTR tv986[ebp]
	je	SHORT $LN65@quadratic_@2
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN66@quadratic_@2
$LN65@quadratic_@2:
	mov	eax, DWORD PTR [eax+32]
$LN66@quadratic_@2:

; 2226 :   for ( i = 0 ; i < FACET_EDGES ; i++ )
; 2227 :      { v[qlconvert[2*i]] = get_fe_tailv(fe_id);

	mov	ebx, DWORD PTR _web+460
	mov	esi, eax
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	esi, DWORD PTR [esi+20]
	and	eax, 134217728				; 08000000H
	xor	eax, esi
	test	eax, 134217728				; 08000000H
	je	SHORT $LN68@quadratic_@2
	mov	ebx, DWORD PTR _web+636
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN69@quadratic_@2
$LN68@quadratic_@2:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+eax]
$LN69@quadratic_@2:
	mov	ebx, DWORD PTR _qlconvert+16

; 2228 :        v[qlconvert[2*i+1]] = get_fe_midv(fe_id);

	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+esi*4]

; 2230 :      }
; 2231 :   get_facet_verts(f_id,vx,NULL);

	mov	esi, DWORD PTR _f_id$[ebp]
	mov	DWORD PTR _v$[ebp+ebx*4], eax
	mov	eax, DWORD PTR [edx+ecx+8]
	mov	ecx, DWORD PTR _qlconvert+20
	push	0
	push	edi
	push	esi
	mov	DWORD PTR _v$[ebp+ecx*4], eax
	call	_get_facet_verts

; 2232 :   for ( k = 0 ; k < ctrl ; k++ ) if ( v[k] == v_id ) break;

	mov	ebx, DWORD PTR _ctrl$[ebp]
	xor	eax, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _k$[ebp], eax
	test	ebx, ebx
	jle	SHORT $LN76@quadratic_@2
$LL17@quadratic_@2:
	mov	ecx, DWORD PTR _v_id$[ebp]
	cmp	DWORD PTR _v$[ebp+eax*4], ecx
	je	SHORT $LN49@quadratic_@2
	inc	eax
	cmp	eax, ebx
	jl	SHORT $LL17@quadratic_@2
	mov	DWORD PTR _k$[ebp], eax

; 2233 :   if ( k >= ctrl )

	jmp	SHORT $LN75@quadratic_@2
$LN49@quadratic_@2:

; 2232 :   for ( k = 0 ; k < ctrl ; k++ ) if ( v[k] == v_id ) break;

	mov	DWORD PTR _k$[ebp], eax

; 2233 :   if ( k >= ctrl )

	cmp	eax, ebx
	jl	$LN80@quadratic_@2
	jmp	SHORT $LN75@quadratic_@2
$LN76@quadratic_@2:
	mov	ecx, DWORD PTR _v_id$[ebp]
$LN75@quadratic_@2:

; 2234 :      { sprintf(errmsg,"Internal error: Can't find vertex %s in facet %s.\n",
; 2235 :            ELNAME(v_id), ELNAME1(f_id));

	cmp	DWORD PTR tv967[ebp], 0
	je	SHORT $LN23@quadratic_@2
	and	esi, 134217727				; 07ffffffH
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	mov	ecx, DWORD PTR _v_id$[ebp]
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN24@quadratic_@2
$LN23@quadratic_@2:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN24@quadratic_@2:
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN25@quadratic_@2
	and	ecx, 134217727				; 07ffffffH
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN26@quadratic_@2
$LN25@quadratic_@2:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN26@quadratic_@2:
	push	esi
	push	eax
	push	OFFSET ??_C@_0DD@NEGKEGG@Internal?5error?3?5Can?8t?5find?5verte@
	push	OFFSET _errmsg
	call	_sprintf

; 2236 :        kb_error(2211,errmsg,RECOVERABLE); 

	push	1
	push	OFFSET _errmsg
	push	2211					; 000008a3H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN80@quadratic_@2:

; 2237 :      }
; 2238 : 
; 2239 :   for ( j = 0 ; j < SDIM ; j++ ) sides[0][j] = 0.0;

	mov	eax, DWORD PTR _web+616
	fldz
	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN77@quadratic_@2
	mov	edx, DWORD PTR _sides$[ebp]
	mov	edx, DWORD PTR [edx]
$LN12@quadratic_@2:
	fst	QWORD PTR [edx]
	mov	eax, DWORD PTR _web+616
	inc	ecx
	add	edx, 8
	cmp	ecx, eax
	jl	SHORT $LN12@quadratic_@2
$LN77@quadratic_@2:

; 2240 :   for ( i = 1 ; i <= web.dimension ; i++ )

	mov	esi, DWORD PTR _web+620
	mov	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	cmp	esi, ecx
	jl	$LN107@quadratic_@2
$LN81@quadratic_@2:

; 2241 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	eax, eax
	jle	$LN8@quadratic_@2
	mov	eax, DWORD PTR _sides$[ebp]

; 2242 :       for ( kk = 0, sides[i][j] = 0.0 ; kk < ctrl ; kk++ )

	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv1094[ebp], eax
$LN82@quadratic_@2:
	mov	esi, DWORD PTR tv1094[ebp]
	xor	eax, eax
	fst	QWORD PTR [esi+edx*8]
	cmp	ebx, 4
	jl	$LN79@quadratic_@2

; 2241 :     for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _sides$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]

; 2242 :       for ( kk = 0, sides[i][j] = 0.0 ; kk < ctrl ; kk++ )

	mov	ebx, DWORD PTR _k$[ebp]
	lea	esi, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _gl$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ebx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+ebx*4-4]
	add	ecx, 16					; 00000010H
$LN74@quadratic_@2:

; 2243 :         sides[i][j] += gl->lpolypart[k][i-1][kk]*vx[lqconvert[kk]][j];

	mov	ebx, DWORD PTR _lqconvert[eax*4]
	mov	ebx, DWORD PTR [edi+ebx*4]
	fld	QWORD PTR [ebx+edx*8]
	add	eax, 4
	fmul	QWORD PTR [ecx-16]
	add	ecx, 32					; 00000020H
	fadd	QWORD PTR [esi]
	fst	QWORD PTR [esi]
	mov	ebx, DWORD PTR _lqconvert[eax*4-12]
	mov	ebx, DWORD PTR [edi+ebx*4]
	fld	QWORD PTR [ebx+edx*8]
	fmul	QWORD PTR [ecx-40]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [esi]
	mov	ebx, DWORD PTR _lqconvert[eax*4-8]
	mov	ebx, DWORD PTR [edi+ebx*4]
	fld	QWORD PTR [ebx+edx*8]
	fmul	QWORD PTR [ecx-32]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [esi]
	mov	ebx, DWORD PTR _lqconvert[eax*4-4]
	mov	ebx, DWORD PTR [edi+ebx*4]
	fld	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR _ctrl$[ebp]
	fmul	QWORD PTR [ecx-24]
	add	ebx, -3					; fffffffdH
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi]
	cmp	eax, ebx
	jl	SHORT $LN74@quadratic_@2
	mov	ecx, DWORD PTR _i$[ebp]
	mov	ebx, DWORD PTR _ctrl$[ebp]
$LN79@quadratic_@2:

; 2242 :       for ( kk = 0, sides[i][j] = 0.0 ; kk < ctrl ; kk++ )

	cmp	eax, ebx
	jge	SHORT $LN5@quadratic_@2

; 2241 :     for ( j = 0 ; j < SDIM ; j++ )

	mov	esi, DWORD PTR _sides$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]

; 2242 :       for ( kk = 0, sides[i][j] = 0.0 ; kk < ctrl ; kk++ )

	mov	ebx, DWORD PTR _k$[ebp]
	lea	esi, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _gl$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ebx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [ecx+ebx*4-4]
	lea	ecx, DWORD PTR [ecx+eax*8]
$LC3@quadratic_@2:

; 2243 :         sides[i][j] += gl->lpolypart[k][i-1][kk]*vx[lqconvert[kk]][j];

	mov	ebx, DWORD PTR _lqconvert[eax*4]
	mov	ebx, DWORD PTR [edi+ebx*4]
	fld	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR _ctrl$[ebp]
	fmul	QWORD PTR [ecx]
	inc	eax
	add	ecx, 8
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	cmp	eax, ebx
	jl	SHORT $LC3@quadratic_@2

; 2242 :       for ( kk = 0, sides[i][j] = 0.0 ; kk < ctrl ; kk++ )

	mov	ecx, DWORD PTR _i$[ebp]
$LN5@quadratic_@2:

; 2241 :     for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
	inc	edx
	cmp	edx, eax
	jl	$LN82@quadratic_@2
	mov	esi, DWORD PTR _web+620
$LN8@quadratic_@2:

; 2240 :   for ( i = 1 ; i <= web.dimension ; i++ )

	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, esi
	jle	$LN81@quadratic_@2
$LN107@quadratic_@2:

; 2244 :   return kernel_basis_rows(sides+1,norm,web.dimension,SDIM);

	mov	edx, DWORD PTR _norm$GSCopy$[ebp]
	fstp	ST(0)
	push	eax
	mov	eax, DWORD PTR _sides$[ebp]
	push	esi
	push	edx
	add	eax, 4
	push	eax
	call	_kernel_basis_rows

; 2245 : } // end quadratic_facet_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_quadratic_facet_normal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DJ@BJKGNEB@Internal?5error?3?5Trying?5to?5take?5n@ ; `string'
PUBLIC	_normal$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_get_facet_normal
;	COMDAT ??_C@_0DJ@BJKGNEB@Internal?5error?3?5Trying?5to?5take?5n@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DJ@BJKGNEB@Internal?5error?3?5Trying?5to?5take?5n@ DB 'Internal er'
	DB	'ror: Trying to take normal in simplex model.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\utility.c
CONST	ENDS
;	COMDAT _get_facet_normal
_TEXT	SEGMENT
_xqXvS$90727 = -260					; size = 12
_normal$GSCopy$ = -248					; size = 4
_xxJ$90728 = -244					; size = 144
_side1$ = -100						; size = 48
_side2$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_f_id$ = 8						; size = 4
_normal$ = 12						; size = 4
_get_facet_normal PROC					; COMDAT

; 2669 : { facetedge_id fe;

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2670 :   REAL side1[MAXCOORD],side2[MAXCOORD];
; 2671 :   int i;
; 2672 : 
; 2673 :   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	push	ebx
	mov	ebx, DWORD PTR _normal$[ebp]

; 2681 :     { side1[i] = x[1][i] - x[0][i];

	mov	DWORD PTR _normal$GSCopy$[ebp], ebx
	jne	SHORT $LN31@get_facet_@7

; 2674 :     kb_error(1368,"Internal error: Trying to take normal in simplex model.\n",
; 2675 :        RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DJ@BJKGNEB@Internal?5error?3?5Trying?5to?5take?5n@
	push	1368					; 00000558H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN31@get_facet_@7:

; 2676 : 
; 2677 :   if ( web.modeltype == LINEAR )  /* better for strange symmetries */

	cmp	DWORD PTR _web+628, 1
	push	esi
	push	edi
	jne	$LN8@get_facet_@7

; 2678 :   { MAT2D(x,FACET_VERTS,MAXCOORD);

	push	6
	push	3
	lea	eax, DWORD PTR _xxJ$90728[ebp]
	push	eax
	lea	ecx, DWORD PTR _xqXvS$90727[ebp]
	push	ecx
	call	_mat2d_setup

; 2679 :     get_facet_verts(f_id,x,NULL);  /* in tail order */

	mov	edx, DWORD PTR _f_id$[ebp]
	mov	esi, eax
	push	0
	push	esi
	push	edx
	call	_get_facet_verts

; 2680 :     for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR _web+616
	add	esp, 28					; 0000001cH
	xor	eax, eax
	cmp	ecx, 4
	jl	$LC29@get_facet_@7
	lea	edx, DWORD PTR [ecx-3]
$LL30@get_facet_@7:

; 2681 :     { side1[i] = x[1][i] - x[0][i];

	mov	edi, DWORD PTR [esi+4]
	fld	QWORD PTR [edi+eax*8]
	mov	ebx, DWORD PTR [esi]
	fsub	QWORD PTR [ebx+eax*8]

; 2682 :       side2[i] = x[2][i] - x[1][i];

	add	eax, 4
	fstp	QWORD PTR _side1$[ebp+eax*8-32]
	mov	edi, DWORD PTR [esi+8]
	fld	QWORD PTR [edi+eax*8-32]
	mov	ebx, DWORD PTR [esi+4]
	fsub	QWORD PTR [ebx+eax*8-32]
	fstp	QWORD PTR _side2$[ebp+eax*8-32]
	mov	edi, DWORD PTR [esi+4]
	fld	QWORD PTR [edi+eax*8-24]
	mov	ebx, DWORD PTR [esi]
	fsub	QWORD PTR [ebx+eax*8-24]
	fstp	QWORD PTR _side1$[ebp+eax*8-24]
	mov	edi, DWORD PTR [esi+8]
	fld	QWORD PTR [edi+eax*8-24]
	mov	ebx, DWORD PTR [esi+4]
	fsub	QWORD PTR [ebx+eax*8-24]
	fstp	QWORD PTR _side2$[ebp+eax*8-24]
	mov	edi, DWORD PTR [esi+4]
	fld	QWORD PTR [edi+eax*8-16]
	mov	ebx, DWORD PTR [esi]
	fsub	QWORD PTR [ebx+eax*8-16]
	fstp	QWORD PTR _side1$[ebp+eax*8-16]
	mov	edi, DWORD PTR [esi+8]
	fld	QWORD PTR [edi+eax*8-16]
	mov	ebx, DWORD PTR [esi+4]
	fsub	QWORD PTR [ebx+eax*8-16]
	fstp	QWORD PTR _side2$[ebp+eax*8-16]
	mov	edi, DWORD PTR [esi+4]
	fld	QWORD PTR [edi+eax*8-8]
	mov	ebx, DWORD PTR [esi]
	fsub	QWORD PTR [ebx+eax*8-8]
	fstp	QWORD PTR _side1$[ebp+eax*8-8]
	mov	edi, DWORD PTR [esi+8]
	fld	QWORD PTR [edi+eax*8-8]
	mov	ebx, DWORD PTR [esi+4]
	fsub	QWORD PTR [ebx+eax*8-8]
	fstp	QWORD PTR _side2$[ebp+eax*8-8]
	cmp	eax, edx
	jl	$LL30@get_facet_@7
	mov	ebx, DWORD PTR _normal$GSCopy$[ebp]
$LC29@get_facet_@7:

; 2680 :     for ( i = 0 ; i < SDIM ; i++ )

	cmp	eax, ecx
	jge	$LN4@get_facet_@7
	npad	5
$LC7@get_facet_@7:

; 2681 :     { side1[i] = x[1][i] - x[0][i];

	mov	edx, DWORD PTR [esi+4]
	fld	QWORD PTR [edx+eax*8]
	mov	edi, DWORD PTR [esi]
	fsub	QWORD PTR [edi+eax*8]
	inc	eax
	fstp	QWORD PTR _side1$[ebp+eax*8-8]

; 2682 :       side2[i] = x[2][i] - x[1][i];

	mov	edx, DWORD PTR [esi+8]
	fld	QWORD PTR [edx+eax*8-8]
	mov	edi, DWORD PTR [esi+4]
	fsub	QWORD PTR [edi+eax*8-8]
	fstp	QWORD PTR _side2$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LC7@get_facet_@7

; 2683 :     }
; 2684 :   }
; 2685 :   else

	jmp	$LN4@get_facet_@7
$LN8@get_facet_@7:

; 2686 :   { fe = get_facet_fe(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN13@get_facet_@7
	xor	edi, edi
	jmp	SHORT $LN12@get_facet_@7
$LN13@get_facet_@7:
	mov	edx, DWORD PTR _web+236
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edi, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN12@get_facet_@7
	xor	edi, 134217728				; 08000000H
$LN12@get_facet_@7:

; 2687 :     get_edge_side(get_fe_edge(fe),side1);

	mov	eax, DWORD PTR _web+460
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	lea	edx, DWORD PTR _side1$[ebp]
	push	edx
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+eax]
	mov	edx, edi
	and	edx, 134217728				; 08000000H
	xor	edx, DWORD PTR [ecx+20]
	push	edx
	call	_get_edge_side

; 2688 :     fe = get_next_edge(fe);

	mov	ecx, DWORD PTR _web+460
	add	esp, 8
	test	edi, 134217728				; 08000000H
	je	SHORT $LN19@get_facet_@7
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN18@get_facet_@7
$LN19@get_facet_@7:
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+32]
$LN18@get_facet_@7:

; 2689 :     get_edge_side(get_fe_edge(fe),side2);

	lea	edx, DWORD PTR _side2$[ebp]
	push	edx
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	push	eax
	call	_get_edge_side
	add	esp, 8
$LN4@get_facet_@7:

; 2690 :   }
; 2691 :   cross_prod(side1,side2,normal);

	push	ebx
	lea	edx, DWORD PTR _side2$[ebp]
	push	edx
	lea	eax, DWORD PTR _side1$[ebp]
	push	eax
	call	_cross_prod
	add	esp, 12					; 0000000cH

; 2692 :   for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	pop	edi
	pop	esi
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN1@get_facet_@7
	fld	QWORD PTR __real@3fe0000000000000
$LN3@get_facet_@7:

; 2693 :      normal[i] /= 2;  /* triangle factor */

	fld	QWORD PTR [ebx+eax*8]
	inc	eax
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [ebx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@get_facet_@7

; 2692 :   for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN1@get_facet_@7:

; 2694 : } // end get_facet_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_get_facet_normal ENDP
_TEXT	ENDS
PUBLIC	_make_vfacet_lists
EXTRN	_vfacet_timestamp:DWORD
; Function compile flags: /Ogtp
;	COMDAT _make_vfacet_lists
_TEXT	SEGMENT
_fff_id$ = -20						; size = 4
_fv$91544 = -16						; size = 4
_i$ = -12						; size = 4
_facet_verts$ = -8					; size = 4
tv742 = -4						; size = 4
_make_vfacet_lists PROC					; COMDAT

; 3657 : { vertex_id v_id;

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3658 :   facet_id f_id, ff_id,fff_id;
; 3659 :   int i;
; 3660 :   int facet_verts;
; 3661 : 
; 3662 :   /* set all facet vertices */
; 3663 :   facet_verts = web.skel[FACET].ctrlpts;

	mov	eax, DWORD PTR _web+232
	push	ebx
	push	esi
	push	edi

; 3664 :   expand_attribute(FACET,F_NEXT_VFACET_ATTR,&facet_verts);

	lea	ecx, DWORD PTR _facet_verts$[ebp]
	push	ecx
	push	4
	push	2
	mov	DWORD PTR _facet_verts$[ebp], eax
	call	_expand_attribute

; 3665 :   if ( web.representation == SOAPFILM ) /* set up facet vertex lists */

	mov	eax, DWORD PTR _web+624
	add	esp, 12					; 0000000cH
	cmp	eax, 2
	jne	$LN48@make_vface

; 3666 :   { if ( web.modeltype != LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	je	$LN113@make_vface

; 3667 :     { FOR_ALL_FACETS(f_id)

	mov	edx, DWORD PTR _web+272
	mov	esi, edx
	shr	esi, 28					; 0000001cH
	and	esi, 1
	je	$LN113@make_vface
$LL46@make_vface:
	mov	eax, DWORD PTR _web+236
	mov	edi, edx
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [edi+eax]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	mov	DWORD PTR tv742[ebp], edi
	je	$LN45@make_vface

; 3668 :       { facetedge_id fe = get_facet_fe(f_id);

	test	esi, esi
	jne	SHORT $LN52@make_vface
	xor	edx, edx
	jmp	SHORT $LN53@make_vface
$LN52@make_vface:
	mov	eax, DWORD PTR [ecx+28]
	test	edx, 134217728				; 08000000H
	je	SHORT $LN51@make_vface
	xor	eax, 134217728				; 08000000H
$LN51@make_vface:
	mov	edx, eax
$LN53@make_vface:

; 3669 :         vertex_id *fv = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _web+328
	mov	edi, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+edi+304]

; 3670 :   
; 3671 :         for ( i = 0 ; i < FACET_VERTS ; i++ )
; 3672 :         { 
; 3673 :           v_id = get_fe_tailv(fe);

	mov	eax, DWORD PTR _web+460
	add	esi, ecx
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	ebx, DWORD PTR [ecx+eax]
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ebx+20]
	mov	ebx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN58@make_vface
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR _web+216
	add	eax, DWORD PTR [ebx+edi+304]
	mov	edi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN57@make_vface
$LN58@make_vface:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR _web+216
	mov	edi, DWORD PTR [ebx+edi+304]
	mov	eax, DWORD PTR [eax+edi]
$LN57@make_vface:

; 3674 :           fv[i] = v_id;

	mov	DWORD PTR [esi], eax

; 3675 :           fe = get_next_edge(fe);

	mov	eax, DWORD PTR _web+460
	test	edx, 134217728				; 08000000H
	je	SHORT $LN62@make_vface
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN61@make_vface
$LN62@make_vface:
	mov	edx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [edx+32]
$LN61@make_vface:

; 3676 :           if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	SHORT $LN40@make_vface

; 3677 :              fv[i+FACET_VERTS] = get_edge_midv(get_fe_edge(fe));

	mov	edi, DWORD PTR _dymem
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edi+304]
	mov	ecx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR [esi+12], ecx
	mov	eax, DWORD PTR _web+460
$LN40@make_vface:

; 3670 :   
; 3671 :         for ( i = 0 ; i < FACET_VERTS ; i++ )
; 3672 :         { 
; 3673 :           v_id = get_fe_tailv(fe);

	mov	ebx, DWORD PTR _dymem
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [ecx+eax]
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edi+20]
	mov	edi, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN99@make_vface
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	add	eax, DWORD PTR [edi+ebx+304]
	mov	edi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN100@make_vface
$LN99@make_vface:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	mov	edi, DWORD PTR [edi+ebx+304]
	mov	eax, DWORD PTR [eax+edi]
$LN100@make_vface:

; 3674 :           fv[i] = v_id;

	mov	DWORD PTR [esi+4], eax

; 3675 :           fe = get_next_edge(fe);

	mov	eax, DWORD PTR _web+460
	test	edx, 134217728				; 08000000H
	je	SHORT $LN101@make_vface
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [ecx+28]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN102@make_vface
$LN101@make_vface:
	mov	edx, DWORD PTR [ecx+eax]
	mov	edx, DWORD PTR [edx+32]
$LN102@make_vface:

; 3676 :           if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2
	jne	SHORT $LN122@make_vface

; 3677 :              fv[i+FACET_VERTS] = get_edge_midv(get_fe_edge(fe));

	mov	edi, DWORD PTR _dymem
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _web+124
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _web+216
	mov	eax, DWORD PTR [eax+edi+304]
	mov	ecx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR [esi+16], ecx
	mov	eax, DWORD PTR _web+460
$LN122@make_vface:

; 3670 :   
; 3671 :         for ( i = 0 ; i < FACET_VERTS ; i++ )
; 3672 :         { 
; 3673 :           v_id = get_fe_tailv(fe);

	mov	ebx, DWORD PTR _dymem
	mov	ecx, edx
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [ecx+eax]
	mov	eax, edx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edi+20]
	mov	edi, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN105@make_vface
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	add	eax, DWORD PTR [edi+ebx+304]
	mov	edi, DWORD PTR _web+636
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN106@make_vface
$LN105@make_vface:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	edi, DWORD PTR _web+216
	mov	edi, DWORD PTR [edi+ebx+304]
	mov	eax, DWORD PTR [eax+edi]
$LN106@make_vface:

; 3674 :           fv[i] = v_id;

	mov	DWORD PTR [esi+8], eax

; 3675 :           fe = get_next_edge(fe);

	test	edx, 134217728				; 08000000H
	mov	edx, DWORD PTR _web+460
	je	SHORT $LN107@make_vface
	mov	ecx, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [ecx+28]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN108@make_vface
$LN107@make_vface:
	mov	eax, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [eax+32]
$LN108@make_vface:

; 3676 :           if ( web.modeltype == QUADRATIC )

	cmp	DWORD PTR _web+628, 2

; 3677 :              fv[i+FACET_VERTS] = get_edge_midv(get_fe_edge(fe));

	mov	edi, DWORD PTR tv742[ebp]
	jne	SHORT $LN45@make_vface
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _web+124
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+216
	mov	edx, DWORD PTR [edx+eax+304]
	mov	eax, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR [esi+20], eax
$LN45@make_vface:

; 3667 :     { FOR_ALL_FACETS(f_id)

	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR [edi+ecx]
	mov	edx, DWORD PTR [edx]
	mov	esi, edx
	shr	esi, 28					; 0000001cH
	and	esi, 1
	jne	$LL46@make_vface

; 3678 :         }
; 3679 :       }
; 3680 :     }

	jmp	$LN113@make_vface
$LN48@make_vface:

; 3681 :   }
; 3682 :   else if ( web.representation == STRING )

	cmp	eax, 1
	jne	$LN36@make_vface

; 3683 :   { edge_id e_id;
; 3684 :     FOR_ALL_EDGES(e_id)

	mov	edi, DWORD PTR _web+160
	test	edi, 268435456				; 10000000H
	je	$LN113@make_vface
	mov	edx, DWORD PTR _web+124
	npad	2
$LL128@make_vface:
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	ebx, ebx
	or	eax, ebx
	je	$LN34@make_vface

; 3685 :     { facetedge_id fe = get_edge_fe(e_id);

	test	ecx, ecx
	jne	SHORT $LN68@make_vface
	xor	eax, eax
	jmp	SHORT $LN69@make_vface
$LN68@make_vface:
	mov	ecx, DWORD PTR [ecx+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN67@make_vface
	xor	ecx, 134217728				; 08000000H
$LN67@make_vface:
	mov	eax, ecx
$LN69@make_vface:

; 3686 :       if ( !valid_id(fe) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN34@make_vface

; 3687 :         continue;
; 3688 :       f_id = get_fe_facet(fe);

	mov	ebx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN71@make_vface
	xor	ebx, 134217728				; 08000000H
$LN71@make_vface:

; 3689 :       if ( !valid_id(f_id) )

	test	ebx, 268435456				; 10000000H
	je	SHORT $LN34@make_vface

; 3690 :         continue;
; 3691 :       set_vertex_facet(get_edge_tailv(e_id),f_id);

	push	edi
	call	_get_edge_tailv
	mov	edx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 3692 :       set_vertex_facet(get_edge_headv(e_id),f_id);

	push	edi
	mov	DWORD PTR [eax+32], ebx
	call	_get_edge_headv
	mov	ecx, DWORD PTR _web+12
	add	esp, 8
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+32], ebx
	mov	edx, DWORD PTR _web+124
$LN34@make_vface:

; 3683 :   { edge_id e_id;
; 3684 :     FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR [esi+edx]
	mov	edi, DWORD PTR [eax]
	test	edi, 268435456				; 10000000H
	jne	$LL128@make_vface

; 3693 :     }
; 3694 :   }
; 3695 :   else if ( web.representation == SIMPLEX )

	jmp	$LN113@make_vface
$LN36@make_vface:
	cmp	eax, 3
	jne	$LN113@make_vface

; 3696 :   { FOR_ALL_FACETS(f_id) /* simplex vertex to facet links */

	mov	esi, DWORD PTR _web+272
	test	esi, 268435456				; 10000000H
	je	SHORT $LN113@make_vface
	npad	2
$LL126@make_vface:
	mov	edx, DWORD PTR _web+236
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edi, DWORD PTR [ecx+edx]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN25@make_vface

; 3697 :     { vertex_id *fv = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR _dymem
	mov	edx, DWORD PTR [eax+edx+304]

; 3698 :       for ( i = 0 ; i < facet_verts ; i++ )

	xor	eax, eax
	add	edx, edi
	cmp	DWORD PTR _facet_verts$[ebp], eax
	jle	SHORT $LN25@make_vface
	npad	4
$LL121@make_vface:

; 3699 :       { 
; 3700 :         set_vertex_facet(fv[i],f_id);

	mov	edi, DWORD PTR [edx+eax*4]
	mov	ebx, DWORD PTR _web+12
	and	edi, 134217727				; 07ffffffH
	mov	edi, DWORD PTR [ebx+edi*4]
	inc	eax
	mov	DWORD PTR [edi+32], esi
	cmp	eax, DWORD PTR _facet_verts$[ebp]
	jl	SHORT $LL121@make_vface
$LN25@make_vface:

; 3696 :   { FOR_ALL_FACETS(f_id) /* simplex vertex to facet links */

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ecx+eax]
	mov	esi, DWORD PTR [ecx]
	test	esi, 268435456				; 10000000H
	jne	SHORT $LL126@make_vface
$LN113@make_vface:

; 3701 :       }
; 3702 :     }
; 3703 :   }
; 3704 :  
; 3705 :   /* start by making one-element loops on facets */
; 3706 :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+48
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN117@make_vface
	npad	5
$LL18@make_vface:
	mov	edx, DWORD PTR _web+12
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+edx]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	edi, edi
	or	eax, edi
	je	SHORT $LN17@make_vface

; 3707 :   {
; 3708 :      f_id = get_vertex_facet(v_id);

	mov	edi, DWORD PTR [edx+32]

; 3709 :      if ( valid_id(f_id) )

	test	edi, 268435456				; 10000000H
	je	SHORT $LN17@make_vface

; 3710 :      { set_next_vertex_facet(v_id,f_id,f_id);

	push	edi
	push	edi
	push	ecx
	call	_set_next_vertex_facet

; 3711 :        set_vertex_facet(v_id,f_id);

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [esi+eax]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+32], edi
$LN17@make_vface:

; 3701 :       }
; 3702 :     }
; 3703 :   }
; 3704 :  
; 3705 :   /* start by making one-element loops on facets */
; 3706 :   FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [esi+edx]
	mov	ecx, DWORD PTR [eax]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL18@make_vface
$LN117@make_vface:

; 3712 :      }
; 3713 :   }
; 3714 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	je	$LN111@make_vface

; 3715 :   { 
; 3716 :      /* not using explicit linked list; 
; 3717 :         since get_next_vertex_facet() uses
; 3718 :         edge list around vertex and facet 
; 3719 :         list around edge.
; 3720 :         */
; 3721 :   }
; 3722 :   else
; 3723 :   FOR_ALL_FACETS(f_id)

	mov	edi, DWORD PTR _web+272
	test	edi, 268435456				; 10000000H
	je	$LN110@make_vface
	mov	eax, DWORD PTR _web+236
	npad	7
$LL130@make_vface:
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	mov	DWORD PTR tv742[ebp], ecx
	je	$LN9@make_vface

; 3724 :   { 
; 3725 :     vertex_id *fv = get_facet_vertices(f_id);

	mov	eax, DWORD PTR _web+328
	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+esi+304]
	add	eax, edx

; 3726 :     for ( i = 0 ; i < facet_verts ; i++ )

	xor	edx, edx
	mov	DWORD PTR _fv$91544[ebp], eax
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _facet_verts$[ebp], edx
	jle	SHORT $LN9@make_vface
	jmp	SHORT $LN5@make_vface
$LL120@make_vface:
	mov	eax, DWORD PTR _fv$91544[ebp]
$LN5@make_vface:

; 3727 :     { v_id = fv[i]; 

	mov	esi, DWORD PTR [eax+edx*4]

; 3728 :       ff_id = get_vertex_facet(v_id);

	mov	eax, DWORD PTR _web+12
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	ebx, DWORD PTR [edx+32]

; 3729 :       if ( !equal_id(f_id,ff_id) )

	cmp	edi, ebx
	je	SHORT $LN4@make_vface

; 3730 :       { /* splice in after first one */
; 3731 :         fff_id = get_next_vertex_facet(v_id,ff_id);

	push	ebx
	push	esi
	call	_get_next_vertex_facet

; 3732 :         if ( !equal_element(f_id,fff_id) )

	mov	ecx, edi
	mov	DWORD PTR _fff_id$[ebp], eax
	or	eax, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	add	esp, 8
	cmp	ecx, eax
	je	SHORT $LN118@make_vface

; 3733 :         { set_next_vertex_facet(v_id,ff_id,f_id);

	push	edi
	push	ebx
	push	esi
	call	_set_next_vertex_facet

; 3734 :           set_next_vertex_facet(v_id,f_id,fff_id);

	mov	edx, DWORD PTR _fff_id$[ebp]
	push	edx
	push	edi
	push	esi
	call	_set_next_vertex_facet
	add	esp, 24					; 00000018H
$LN118@make_vface:
	mov	ecx, DWORD PTR tv742[ebp]
$LN4@make_vface:

; 3726 :     for ( i = 0 ; i < facet_verts ; i++ )

	mov	edx, DWORD PTR _i$[ebp]
	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, DWORD PTR _facet_verts$[ebp]
	jl	SHORT $LL120@make_vface
$LN9@make_vface:

; 3715 :   { 
; 3716 :      /* not using explicit linked list; 
; 3717 :         since get_next_vertex_facet() uses
; 3718 :         edge list around vertex and facet 
; 3719 :         list around edge.
; 3720 :         */
; 3721 :   }
; 3722 :   else
; 3723 :   FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ecx+eax]
	mov	edi, DWORD PTR [ecx]
	test	edi, 268435456				; 10000000H
	jne	$LL130@make_vface

; 3735 :         }
; 3736 :       }
; 3737 :     }
; 3738 :   }
; 3739 :   vfacet_timestamp = top_timestamp; 

	mov	edx, DWORD PTR _top_timestamp
	pop	edi
	pop	esi
	mov	DWORD PTR _vfacet_timestamp, edx
	pop	ebx

; 3740 : } // end make_vfacet_lists()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN110@make_vface:

; 3735 :         }
; 3736 :       }
; 3737 :     }
; 3738 :   }
; 3739 :   vfacet_timestamp = top_timestamp; 

	mov	eax, DWORD PTR _top_timestamp
	pop	edi
	pop	esi
	mov	DWORD PTR _vfacet_timestamp, eax
	pop	ebx

; 3740 : } // end make_vfacet_lists()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN111@make_vface:

; 3735 :         }
; 3736 :       }
; 3737 :     }
; 3738 :   }
; 3739 :   vfacet_timestamp = top_timestamp; 

	mov	ecx, DWORD PTR _top_timestamp
	pop	edi
	pop	esi
	mov	DWORD PTR _vfacet_timestamp, ecx
	pop	ebx

; 3740 : } // end make_vfacet_lists()

	mov	esp, ebp
	pop	ebp
	ret	0
_make_vfacet_lists ENDP
_TEXT	ENDS
PUBLIC	_get_vertex_first_facet
; Function compile flags: /Ogtp
;	COMDAT _get_vertex_first_facet
_TEXT	SEGMENT
_v_id$ = 8						; size = 4
_get_vertex_first_facet PROC				; COMDAT

; 3984 : { 

	push	ebp
	mov	ebp, esp

; 3985 :   /* special cases */
; 3986 :   if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN3@get_vertex@3

; 3987 :   { if ( vfacet_timestamp < top_timestamp )

	mov	eax, DWORD PTR _vfacet_timestamp
	cmp	eax, DWORD PTR _top_timestamp
	jge	SHORT $LN2@get_vertex@3

; 3988 :       make_vfacet_lists(); 

	call	_make_vfacet_lists
$LN2@get_vertex@3:

; 3989 :     return get_vertex_facet(v_id);

	mov	ecx, DWORD PTR _v_id$[ebp]
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax+32]

; 3996 : 
; 3997 : } /* end get_vertex_first_facet() */

	pop	ebp
	ret	0
$LN3@get_vertex@3:

; 3990 :   }
; 3991 : 
; 3992 :   if ( get_vattr(v_id) & Q_MIDFACET ) 

	mov	edx, DWORD PTR _web+12
	push	esi
	mov	esi, DWORD PTR _v_id$[ebp]
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 2097152				; 00200000H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN1@get_vertex@3

; 3993 :     return get_vertex_facet(v_id);

	mov	eax, DWORD PTR [ecx+32]
	pop	esi

; 3996 : 
; 3997 : } /* end get_vertex_first_facet() */

	pop	ebp
	ret	0
$LN1@get_vertex@3:

; 3994 : 
; 3995 :   return get_next_vertex_facet(v_id,NULLID);

	push	0
	push	esi
	call	_get_next_vertex_facet
	add	esp, 8
	pop	esi

; 3996 : 
; 3997 : } /* end get_vertex_first_facet() */

	pop	ebp
	ret	0
_get_vertex_first_facet ENDP
_TEXT	ENDS
PUBLIC	_norm$GSCopy$
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_vertex_total_vol_grad
; Function compile flags: /Ogtp
;	COMDAT _vertex_total_vol_grad
_TEXT	SEGMENT
_con$89997 = -268					; size = 28
_first_fe$ = -240					; size = 4
_v_id$GSCopy$ = -236					; size = 4
_fe_id$ = -232						; size = 4
_start_e$89950 = -232					; size = 4
_norm$GSCopy$ = -228					; size = 4
_perp$89999 = -224					; size = 48
_z$ = -176						; size = 48
_fnorm$ = -128						; size = 48
_conlist$89998 = -80					; size = 28
_y$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_norm$ = 12						; size = 4
_vertex_total_vol_grad PROC				; COMDAT

; 1755 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1756 :   int i,j;
; 1757 :   REAL y[MAXCOORD],z[MAXCOORD];
; 1758 :   REAL fnorm[MAXCOORD];
; 1759 :   facetedge_id fe_id,first_fe;
; 1760 :   REAL size;
; 1761 :   
; 1762 :   /* check for string */
; 1763 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	mov	eax, DWORD PTR _v_id$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _norm$[ebp]
	push	esi
	push	edi

; 1802 :     body_id bb_id = get_facet_body(invert(f_id));

	mov	DWORD PTR _v_id$GSCopy$[ebp], eax
	mov	DWORD PTR _norm$GSCopy$[ebp], ebx
	jne	$LN39@vertex_tot

; 1764 :   { edge_id e_id,start_e;
; 1765 :     
; 1766 :     norm[0] = norm[1] = 0.0;
; 1767 : 
; 1768 :     start_e = e_id = get_vertex_edge(v_id);

	fldz
	and	eax, 134217727				; 07ffffffH
	fst	QWORD PTR [ebx+8]
	fstp	QWORD PTR [ebx]
	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	esi, DWORD PTR [edx+28]
	mov	DWORD PTR _start_e$89950[ebp], esi
$LL38@vertex_tot:

; 1769 :     do 
; 1770 :     { facetedge_id fe,fe2;
; 1771 :       facet_id f_id;
; 1772 : 
; 1773 :       get_edge_side(e_id,y);

	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	push	esi
	call	_get_edge_side

; 1774 :       fe = get_edge_fe(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+ecx]
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN45@vertex_tot
	xor	edx, edx
	jmp	SHORT $LN46@vertex_tot
$LN45@vertex_tot:
	mov	eax, DWORD PTR [eax+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN44@vertex_tot
	xor	eax, 134217728				; 08000000H
$LN44@vertex_tot:
	mov	edx, eax
$LN46@vertex_tot:

; 1775 :       if ( valid_id(fe) )

	test	edx, 268435456				; 10000000H
	je	SHORT $LN32@vertex_tot

; 1776 :       { fe2 = get_next_facet(fe);

	mov	ecx, DWORD PTR _web+460
	mov	ebx, edx
	mov	eax, edx
	shr	ebx, 27					; 0000001bH
	and	eax, 134217727				; 07ffffffH
	and	ebx, 1
	mov	eax, DWORD PTR [ecx+eax*4]
	je	SHORT $LN49@vertex_tot
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN48@vertex_tot
$LN49@vertex_tot:
	mov	ecx, DWORD PTR [eax+40]
$LN48@vertex_tot:

; 1777 :         if ( equal_id(fe,fe2) ) 

	cmp	edx, ecx
	jne	SHORT $LN117@vertex_tot

; 1778 :         { /* valence 1, so count it according to facet orientation */
; 1779 :           f_id = get_fe_facet(fe);

	mov	eax, DWORD PTR [eax+24]
	test	ebx, ebx
	je	SHORT $LN116@vertex_tot
	xor	eax, 134217728				; 08000000H
$LN116@vertex_tot:

; 1780 :           if ( inverted(f_id) )

	test	eax, 134217728				; 08000000H

; 1781 :           { norm[0] -= y[1];

	mov	eax, DWORD PTR _norm$GSCopy$[ebp]
	fld	QWORD PTR [eax]

; 1783 :           }
; 1784 :           else

	mov	ebx, eax
	je	SHORT $LN33@vertex_tot

; 1781 :           { norm[0] -= y[1];

	fsub	QWORD PTR _y$[ebp+8]
	fstp	QWORD PTR [eax]

; 1782 :             norm[1] += y[0];

	fld	QWORD PTR [eax+8]
	fadd	QWORD PTR _y$[ebp]
	fstp	QWORD PTR [eax+8]

; 1783 :           }
; 1784 :           else

	jmp	SHORT $LN32@vertex_tot
$LN33@vertex_tot:

; 1785 :           { norm[0] += y[1];

	fadd	QWORD PTR _y$[ebp+8]
	fstp	QWORD PTR [eax]

; 1786 :             norm[1] -= y[0];

	fld	QWORD PTR [eax+8]
	fsub	QWORD PTR _y$[ebp]
	fstp	QWORD PTR [eax+8]
	jmp	SHORT $LN32@vertex_tot
$LN117@vertex_tot:

; 1783 :           }
; 1784 :           else

	mov	ebx, DWORD PTR _norm$GSCopy$[ebp]
$LN32@vertex_tot:

; 1787 :           }
; 1788 :         }
; 1789 :       }
; 1790 :       e_id = get_next_tail_edge(e_id);   

	mov	edx, DWORD PTR _web+124
	mov	eax, DWORD PTR [edi+edx]
	shr	esi, 27					; 0000001bH
	and	esi, 1
	mov	esi, DWORD PTR [eax+esi*4+32]

; 1791 :     } while ( !equal_id(e_id,start_e) );

	cmp	esi, DWORD PTR _start_e$89950[ebp]
	jne	$LL38@vertex_tot

; 1792 :     goto normalize;

	jmp	$normalize$89964
$LN39@vertex_tot:

; 1793 :   }
; 1794 : 
; 1795 :   /* Get here only for soapfilm model. */
; 1796 : 
; 1797 :   first_fe = fe_id = get_vertex_first_facet(v_id);

	push	eax
	call	_get_vertex_first_facet

; 1798 :   for ( i = 0 ; i < SDIM ; i++ ) norm[i] = 0.0;

	fldz
	xor	ecx, ecx
	add	esp, 4
	mov	DWORD PTR _fe_id$[ebp], eax
	mov	DWORD PTR _first_fe$[ebp], eax
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN132@vertex_tot
$LN31@vertex_tot:
	fst	QWORD PTR [ebx+ecx*8]
	inc	ecx
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN31@vertex_tot
$LN132@vertex_tot:
	fstp	ST(0)
$LN28@vertex_tot:

; 1799 :   do
; 1800 :   { facet_id f_id = get_fe_facet(fe_id);

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN59@vertex_tot
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN60@vertex_tot
$LN59@vertex_tot:
	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN58@vertex_tot
	xor	ecx, 134217728				; 08000000H
$LN58@vertex_tot:
	mov	eax, ecx
$LN60@vertex_tot:

; 1801 :     body_id b_id = get_facet_body(f_id);

	cmp	DWORD PTR _web+400, 0
	mov	edx, DWORD PTR _web+328
	mov	esi, DWORD PTR _web+236
	mov	edi, DWORD PTR _dymem
	jne	SHORT $LN65@vertex_tot
	xor	ecx, ecx
	jmp	SHORT $LN62@vertex_tot
$LN65@vertex_tot:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN64@vertex_tot
	xor	ecx, ecx
	jmp	SHORT $LN62@vertex_tot
$LN64@vertex_tot:
	mov	ebx, DWORD PTR [edx+edi+784]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN63@vertex_tot
	mov	ecx, DWORD PTR [ecx+ebx+4]
	jmp	SHORT $LN62@vertex_tot
$LN63@vertex_tot:
	mov	ecx, DWORD PTR [ecx+ebx]
$LN62@vertex_tot:

; 1802 :     body_id bb_id = get_facet_body(invert(f_id));

	xor	eax, 134217728				; 08000000H
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN71@vertex_tot
	xor	eax, eax
	jmp	SHORT $LN68@vertex_tot
$LN71@vertex_tot:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN70@vertex_tot
	xor	eax, eax
	jmp	SHORT $LN68@vertex_tot
$LN70@vertex_tot:
	mov	edx, DWORD PTR [edx+edi+784]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN69@vertex_tot
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+edx+4]
	jmp	SHORT $LN68@vertex_tot
$LN69@vertex_tot:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR [eax+edx]
$LN68@vertex_tot:

; 1803 :     if ( valid_id(b_id) != valid_id(bb_id) )
; 1804 :     { /* one-sided, so count it */  
; 1805 :       get_fe_side(fe_id,z);

	mov	ebx, DWORD PTR _fe_id$[ebp]
	shr	ecx, 28					; 0000001cH
	shr	eax, 28					; 0000001cH
	mov	edi, ecx
	and	edi, 1
	and	eax, 1
	cmp	edi, eax
	je	$LN115@vertex_tot
	mov	ecx, DWORD PTR _web+460
	mov	esi, ebx
	and	esi, 134217727				; 07ffffffH
	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, ebx
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	push	eax
	call	_get_edge_side

; 1806 :       get_fe_side(get_prev_edge(fe_id),y);

	mov	ecx, DWORD PTR _web+460
	add	esp, 8
	test	ebx, 134217728				; 08000000H
	je	SHORT $LN77@vertex_tot
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN76@vertex_tot
$LN77@vertex_tot:
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+28]
$LN76@vertex_tot:
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	push	eax
	call	_get_edge_side

; 1807 :       cross_prod(y,z,fnorm);

	lea	edx, DWORD PTR _fnorm$[ebp]
	push	edx
	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	call	_cross_prod
	add	esp, 20					; 00000014H

; 1808 :       if ( valid_id(b_id) )
; 1809 :         for ( i = 0 ; i < SDIM ; i++ ) norm[i] += fnorm[i];

	xor	ecx, ecx
	test	edi, edi
	je	SHORT $LN24@vertex_tot
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN115@vertex_tot
	mov	eax, DWORD PTR _norm$GSCopy$[ebp]
	lea	edx, DWORD PTR _fnorm$[ebp]
	sub	edx, eax
$LL124@vertex_tot:
	fld	QWORD PTR [eax+edx]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL124@vertex_tot

; 1810 :       else

	jmp	SHORT $LN115@vertex_tot
$LN24@vertex_tot:

; 1811 :         for ( i = 0 ; i < SDIM ; i++ ) norm[i] -= fnorm[i];

	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN115@vertex_tot
	mov	eax, DWORD PTR _norm$GSCopy$[ebp]
	lea	edx, DWORD PTR _fnorm$[ebp]
	sub	edx, eax
	npad	4
$LL125@vertex_tot:
	fld	QWORD PTR [eax]
	inc	ecx
	fsub	QWORD PTR [eax+edx]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL125@vertex_tot
$LN115@vertex_tot:

; 1812 : 
; 1813 :     }
; 1814 :     fe_id = get_next_vertex_facet(v_id,fe_id);

	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
	push	ebx
	push	edx
	call	_get_next_vertex_facet
	add	esp, 8
	mov	DWORD PTR _fe_id$[ebp], eax

; 1815 :   } while ( !equal_id(fe_id,first_fe) );

	cmp	eax, DWORD PTR _first_fe$[ebp]
	jne	$LN28@vertex_tot
	mov	ebx, DWORD PTR _norm$GSCopy$[ebp]
$normalize$89964:

; 1816 : 
; 1817 :   normalize:
; 1818 :   if ( get_vattr(v_id) & CONSTRAINT )

	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	mov	ecx, DWORD PTR _web+12
	and	eax, 134217727				; 07ffffffH
	lea	edi, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1024				; 00000400H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN112@vertex_tot

; 1819 :     {
; 1820 :       conmap_t * conmap = get_v_constraint_map(v_id);

	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	cmp	DWORD PTR [edx+eax+1288], ecx
	je	SHORT $LN42@vertex_tot
	mov	eax, DWORD PTR [edx+eax+1264]
	add	eax, DWORD PTR [edi]
	jmp	SHORT $LN43@vertex_tot
$LN42@vertex_tot:
	mov	eax, OFFSET _nullcon
$LN43@vertex_tot:

; 1821 :       int oncount = 0,hitcount;
; 1822 :       struct constraint *con[MAXCONHIT];
; 1823 :       int conlist[MAXCONHIT];
; 1824 :       REAL perp[MAXCOORD];
; 1825 : 
; 1826 :       for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	mov	ecx, 1
	xor	esi, esi
	cmp	DWORD PTR [eax], ecx
	jl	SHORT $LN122@vertex_tot
$LL126@vertex_tot:

; 1827 :         { 
; 1828 :           if ( (conmap[j] & CON_HIT_BIT) && (oncount < web.sdim) )

	mov	edx, DWORD PTR [eax+ecx*4]
	test	edx, edx
	jns	SHORT $LN14@vertex_tot

; 1829 :           { conlist[oncount] = conmap[j];
; 1830 :             con[oncount++] = get_constraint(conmap[j]);

	mov	ebx, DWORD PTR _norm$GSCopy$[ebp]
	cmp	esi, DWORD PTR _web+616
	jge	SHORT $LN14@vertex_tot
	mov	DWORD PTR _conlist$89998[ebp+esi*4], edx
	mov	edx, DWORD PTR [eax+ecx*4]
	and	edx, 1073741823				; 3fffffffH
	imul	edx, 176				; 000000b0H
	add	edx, DWORD PTR _web+652
	inc	esi
	mov	DWORD PTR _con$89997[ebp+esi*4-4], edx
$LN14@vertex_tot:

; 1821 :       int oncount = 0,hitcount;
; 1822 :       struct constraint *con[MAXCONHIT];
; 1823 :       int conlist[MAXCONHIT];
; 1824 :       REAL perp[MAXCOORD];
; 1825 : 
; 1826 :       for ( j = 1 ; j <= (int)conmap[0] ; j++ )

	inc	ecx
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LL126@vertex_tot
	mov	edx, DWORD PTR _web+104
$LN122@vertex_tot:

; 1831 :           }
; 1832 :         }
; 1833 : 
; 1834 :       hitcount = constr_proj(TANGPROJ,oncount,con,get_coord(v_id),
; 1835 :                  norm,perp,conlist,DETECT,v_id);

	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR _conlist$89998[ebp]
	push	ecx
	mov	ecx, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+ecx+64]
	add	edx, DWORD PTR [edi]
	lea	eax, DWORD PTR _perp$89999[ebp]
	push	eax
	push	ebx
	push	edx
	lea	eax, DWORD PTR _con$89997[ebp]
	push	eax
	push	esi
	push	2
	call	_constr_proj
	mov	edi, eax
	add	esp, 36					; 00000024H

; 1836 :       if ( hitcount != oncount )

	cmp	edi, esi
	je	SHORT $LN119@vertex_tot

; 1837 :         { clear_v_constraint_status(v_id);

	mov	ecx, DWORD PTR _v_id$GSCopy$[ebp]
	push	ecx
	call	_clear_v_constraint_status
	add	esp, 4

; 1838 :           for ( j = 0 ; j < hitcount ; j++ )

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN119@vertex_tot
$LL127@vertex_tot:

; 1839 :              set_v_constraint_status(v_id,conlist[j]);

	mov	edx, DWORD PTR _conlist$89998[ebp+esi*4]
	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	edx
	push	eax
	call	_set_v_constraint_status
	inc	esi
	add	esp, 8
	cmp	esi, edi
	jl	SHORT $LL127@vertex_tot
$LN119@vertex_tot:

; 1840 :         }
; 1841 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN112@vertex_tot
	lea	edx, DWORD PTR _perp$89999[ebp]
	mov	eax, ebx
	sub	edx, ebx
$LL128@vertex_tot:

; 1842 :         norm[j] -= perp[j];

	fld	QWORD PTR [eax]
	inc	ecx
	fsub	QWORD PTR [edx+eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL128@vertex_tot
$LN112@vertex_tot:

; 1843 :      }
; 1844 :       
; 1845 :   size = sqrt(SDIM_dot(norm,norm));

	mov	ecx, DWORD PTR _web+616
	push	ecx
	push	ebx
	push	ebx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 1846 :   if ( size <= 0.0 ) return 0.0; 

	fldz
	fcom	ST(1)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN134@vertex_tot
	pop	edi
	fstp	ST(1)
	pop	esi
	pop	ebx

; 1848 :   return size/web.simplex_factorial;
; 1849 : } // end vertex_total_vol_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN134@vertex_tot:

; 1847 :   for ( i = 0 ; i < SDIM ; i++ ) norm[i] /= size;

	xor	eax, eax
	fstp	ST(0)
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN1@vertex_tot
$LN129@vertex_tot:
	fld	QWORD PTR [ebx+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [ebx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN129@vertex_tot
$LN1@vertex_tot:

; 1848 :   return size/web.simplex_factorial;
; 1849 : } // end vertex_total_vol_grad()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fdiv	QWORD PTR _web+792
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_vertex_total_vol_grad ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DM@LEAEOHLA@Internal?5error?3?5Invalid?5fe?5in?5ca@ ; `string'
PUBLIC	??_C@_0EM@KAIHILAB@Internal?5error?3?5Using?5calc_verte@ ; `string'
PUBLIC	_norm$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_calc_vertex_smooth_normal
EXTRN	_E_BOUNDARY_ATTR:DWORD
EXTRN	_equal_constr:PROC
;	COMDAT ??_C@_0DM@LEAEOHLA@Internal?5error?3?5Invalid?5fe?5in?5ca@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0DM@LEAEOHLA@Internal?5error?3?5Invalid?5fe?5in?5ca@ DB 'Internal e'
	DB	'rror: Invalid fe in calc_vertex_smooth_normal().', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@KAIHILAB@Internal?5error?3?5Using?5calc_verte@
CONST	SEGMENT
??_C@_0EM@KAIHILAB@Internal?5error?3?5Using?5calc_verte@ DB 'Internal err'
	DB	'or: Using calc_vertex_smooth_normal() on non-soapfilm surface'
	DB	'.', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\utility.c
CONST	ENDS
;	COMDAT _calc_vertex_smooth_normal
_TEXT	SEGMENT
_f_id$ = -164						; size = 4
_norm$GSCopy$ = -160					; size = 4
_bdry$ = -156						; size = 4
tv962 = -152						; size = 4
$T94413 = -152						; size = 4
_y$ = -148						; size = 48
_fnorm$ = -100						; size = 48
_z$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_norm$ = 16						; size = 4
_calc_vertex_smooth_normal PROC				; COMDAT

; 2008 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2030 : 
; 2031 :   /* go around one way to edge of face */
; 2032 :   sidea = fe;

	mov	eax, DWORD PTR _norm$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _fe$[ebp]
	mov	esi, edi
	shr	esi, 28					; 0000001cH
	and	esi, 1
	mov	DWORD PTR _norm$GSCopy$[ebp], eax
	jne	SHORT $LN40@calc_verte@2

; 2009 :   int i;
; 2010 :   REAL y[MAXCOORD],z[MAXCOORD];
; 2011 :   REAL fnorm[MAXCOORD];
; 2012 :   facetedge_id sidea;
; 2013 :   facet_id f_id = get_fe_facet(fe);

	mov	ebx, DWORD PTR _NULLFACET
	mov	DWORD PTR _f_id$[ebp], ebx
	jmp	SHORT $LN41@calc_verte@2
$LN40@calc_verte@2:
	mov	edx, DWORD PTR _web+460
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN39@calc_verte@2
	xor	eax, 134217728				; 08000000H
$LN39@calc_verte@2:
	mov	ebx, eax
	mov	DWORD PTR _f_id$[ebp], eax
$LN41@calc_verte@2:

; 2014 :   struct boundary *bdry;  /* to check staying on same boundary */
; 2015 :   REAL size;
; 2016 : 
; 2017 : 
; 2018 :   /* check for string */
; 2019 :   if ( web.representation != SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	je	SHORT $LN26@calc_verte@2

; 2020 :   { kb_error(2208,"Internal error: Using calc_vertex_smooth_normal() on non-soapfilm surface.\n",
; 2021 :      RECOVERABLE); 

	push	1
	push	OFFSET ??_C@_0EM@KAIHILAB@Internal?5error?3?5Using?5calc_verte@
	push	2208					; 000008a0H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN26@calc_verte@2:

; 2022 :   }
; 2023 : 
; 2024 :   if ( !valid_id(fe) )

	test	esi, esi
	jne	SHORT $LN25@calc_verte@2

; 2025 :      kb_error(2209,"Internal error: Invalid fe in calc_vertex_smooth_normal().\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DM@LEAEOHLA@Internal?5error?3?5Invalid?5fe?5in?5ca@
	push	2209					; 000008a1H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN25@calc_verte@2:

; 2026 : 
; 2027 :   bdry = get_facet_boundary(f_id);  /* original boundary */

	mov	eax, DWORD PTR _F_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN29@calc_verte@2
	mov	edx, DWORD PTR _web+236
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	mov	ecx, ebx
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR [ecx+eax]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	mov	DWORD PTR _bdry$[ebp], eax
	jmp	SHORT $LN30@calc_verte@2
$LN29@calc_verte@2:
	mov	DWORD PTR _bdry$[ebp], 0
$LN30@calc_verte@2:

; 2028 : 
; 2029 :   get_facet_normal(f_id,norm);  /* starter normal */

	mov	ecx, DWORD PTR _norm$GSCopy$[ebp]
	push	ecx
	push	ebx
	call	_get_facet_normal
	add	esp, 8
	npad	7
$LL24@calc_verte@2:

; 2033 :   for(;;)
; 2034 :   { edge_id e_id;
; 2035 :     /* go to next facet */
; 2036 :     sidea = get_prev_edge(sidea);

	mov	ebx, DWORD PTR _web+460
	test	edi, 134217728				; 08000000H
	je	SHORT $LN44@calc_verte@2
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+edi*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN43@calc_verte@2
$LN44@calc_verte@2:
	and	edi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+edi*4]
	mov	eax, DWORD PTR [eax+28]
$LN43@calc_verte@2:

; 2037 :     if ( equal_id(sidea,get_next_facet(sidea)) ) break;  /* valence 1 */

	mov	edi, eax
	and	edi, 134217727				; 07ffffffH
	mov	esi, eax
	add	edi, edi
	shr	esi, 27					; 0000001bH
	add	edi, edi
	and	esi, 1
	mov	ecx, DWORD PTR [edi+ebx]
	je	SHORT $LN48@calc_verte@2
	mov	edx, DWORD PTR [ecx+36]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN47@calc_verte@2
$LN48@calc_verte@2:
	mov	edx, DWORD PTR [ecx+40]
$LN47@calc_verte@2:
	cmp	eax, edx
	je	$LN117@calc_verte@2

; 2038 :     if ( !equal_id(get_next_facet(sidea),get_prev_facet(sidea)) ) break;

	test	esi, esi
	je	SHORT $LN52@calc_verte@2
	mov	edx, DWORD PTR [ecx+36]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN150@calc_verte@2
$LN52@calc_verte@2:
	mov	edx, DWORD PTR [ecx+40]
$LN150@calc_verte@2:
	mov	DWORD PTR $T94413[ebp], edx
	test	esi, esi
	je	SHORT $LN56@calc_verte@2
	mov	edx, DWORD PTR [ecx+40]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN55@calc_verte@2
$LN56@calc_verte@2:
	mov	edx, DWORD PTR [ecx+36]
$LN55@calc_verte@2:
	cmp	DWORD PTR $T94413[ebp], edx
	jne	$LN117@calc_verte@2

; 2039 :     e_id = get_fe_edge(sidea);

	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	mov	ebx, eax

; 2040 :     if ( !equal_constr(f_id,e_id) ) break;

	mov	eax, DWORD PTR _f_id$[ebp]
	push	ebx
	push	eax
	call	_equal_constr
	add	esp, 8
	test	eax, eax
	je	$LN130@calc_verte@2

; 2041 :     if ( bdry != get_edge_boundary(e_id) ) break;

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	mov	edx, DWORD PTR _web+776
	test	eax, eax
	je	SHORT $LN31@calc_verte@2
	mov	ecx, DWORD PTR _web+124
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	and	ebx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ebx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ebx+64]
	mov	eax, DWORD PTR [ecx+eax]
	imul	eax, 136				; 00000088H
	add	eax, edx
	jmp	SHORT $LN32@calc_verte@2
$LN31@calc_verte@2:
	xor	eax, eax
$LN32@calc_verte@2:

; 2042 :     sidea = fe_inverse(get_next_facet(sidea));

	mov	ebx, DWORD PTR _web+460
	cmp	DWORD PTR _bdry$[ebp], eax
	jne	$LN117@calc_verte@2
	test	esi, esi
	je	SHORT $LN62@calc_verte@2
	mov	ecx, DWORD PTR [edi+ebx]
	mov	edi, DWORD PTR [ecx+36]
	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN61@calc_verte@2
$LN62@calc_verte@2:
	mov	eax, DWORD PTR [edi+ebx]
	mov	edi, DWORD PTR [eax+40]
$LN61@calc_verte@2:

; 2043 :     if ( bdry != get_facet_boundary(get_fe_facet(sidea)) ) break;

	mov	eax, DWORD PTR _F_BOUNDARY_ATTR
	xor	edi, 134217728				; 08000000H
	test	eax, eax
	je	SHORT $LN33@calc_verte@2
	test	edi, 268435456				; 10000000H
	jne	SHORT $LN66@calc_verte@2
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN65@calc_verte@2
$LN66@calc_verte@2:
	mov	ecx, edi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN65@calc_verte@2
	xor	ecx, 134217728				; 08000000H
$LN65@calc_verte@2:
	mov	esi, DWORD PTR _web+236
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	esi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+esi+64]
	mov	eax, DWORD PTR [ecx+eax]
	imul	eax, 136				; 00000088H
	add	eax, edx
	jmp	SHORT $LN34@calc_verte@2
$LN33@calc_verte@2:
	xor	eax, eax
$LN34@calc_verte@2:
	cmp	DWORD PTR _bdry$[ebp], eax
	jne	$LN117@calc_verte@2

; 2044 :     if ( equal_id(sidea,fe) ) goto snormalize; /* went all the way around */

	cmp	edi, DWORD PTR _fe$[ebp]
	je	$snormalize$90174

; 2045 : 
; 2046 :     get_fe_side(sidea,z);

	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+ebx]
	mov	eax, edi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	lea	ecx, DWORD PTR _z$[ebp]
	push	ecx
	push	eax
	call	_get_edge_side

; 2047 :     get_fe_side(get_prev_edge(sidea),y);

	mov	ecx, DWORD PTR _web+460
	add	esp, 8
	test	edi, 134217728				; 08000000H
	je	SHORT $LN72@calc_verte@2
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN71@calc_verte@2
$LN72@calc_verte@2:
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+28]
$LN71@calc_verte@2:
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	push	eax
	call	_get_edge_side

; 2048 :     cross_prod(y,z,fnorm);

	lea	edx, DWORD PTR _fnorm$[ebp]
	push	edx
	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	call	_cross_prod

; 2049 :     for ( i = 0 ; i < SDIM ; i++ ) norm[i] += fnorm[i]/2;

	xor	ecx, ecx
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _web+616, ecx
	jle	$LL24@calc_verte@2
	mov	eax, DWORD PTR _norm$GSCopy$[ebp]
	fld	QWORD PTR __real@3fe0000000000000
	lea	edx, DWORD PTR _fnorm$[ebp]
	sub	edx, eax
$LN16@calc_verte@2:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN16@calc_verte@2
	fstp	ST(0)

; 2050 : 
; 2051 :   }

	jmp	$LL24@calc_verte@2
$LN130@calc_verte@2:
	mov	ebx, DWORD PTR _web+460
$LN117@calc_verte@2:

; 2052 : 
; 2053 :   /* go around the other way */
; 2054 :   sidea = fe;

	mov	esi, DWORD PTR _fe$[ebp]

; 2069 :   }

	jmp	SHORT $LL13@calc_verte@2
	npad	5
$LL133@calc_verte@2:
	mov	ebx, DWORD PTR _web+460
$LL13@calc_verte@2:

; 2055 :   while ( equal_id(get_next_facet(sidea),get_prev_facet(sidea)) )

	mov	edx, esi
	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	DWORD PTR tv962[ebp], edx
	mov	edi, esi
	je	SHORT $LN78@calc_verte@2
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+ebx]
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN77@calc_verte@2
$LN78@calc_verte@2:
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	eax, DWORD PTR [edi+ebx]
	mov	ecx, DWORD PTR [eax+40]
$LN77@calc_verte@2:
	test	edx, edx
	je	SHORT $LN82@calc_verte@2
	mov	edx, DWORD PTR [eax+40]
	xor	edx, 134217728				; 08000000H
	jmp	SHORT $LN81@calc_verte@2
$LN82@calc_verte@2:
	mov	edx, DWORD PTR [eax+36]
$LN81@calc_verte@2:
	cmp	ecx, edx
	jne	$snormalize$90174

; 2056 :   { edge_id e_id;
; 2057 :     if ( equal_id(sidea,get_next_facet(sidea)) ) break;  /* edge */

	cmp	DWORD PTR tv962[ebp], 0
	je	SHORT $LN86@calc_verte@2
	mov	ecx, DWORD PTR [eax+36]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN85@calc_verte@2
$LN86@calc_verte@2:
	mov	ecx, DWORD PTR [eax+40]
$LN85@calc_verte@2:
	cmp	esi, ecx
	je	$snormalize$90174

; 2058 :     e_id = get_fe_edge(sidea);
; 2059 :     if ( !equal_constr(f_id,e_id) ) break;

	mov	edx, DWORD PTR _f_id$[ebp]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [eax+20]
	push	esi
	push	edx
	call	_equal_constr
	add	esp, 8
	test	eax, eax
	je	$snormalize$90174

; 2060 :     if ( bdry != get_edge_boundary(e_id) ) break;

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	mov	ebx, DWORD PTR _web+776
	test	eax, eax
	je	SHORT $LN35@calc_verte@2
	mov	ecx, DWORD PTR _web+124
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+216
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR [edx+eax]
	imul	eax, 136				; 00000088H
	add	eax, ebx
	jmp	SHORT $LN36@calc_verte@2
$LN35@calc_verte@2:
	xor	eax, eax
$LN36@calc_verte@2:
	cmp	DWORD PTR _bdry$[ebp], eax
	jne	$snormalize$90174

; 2061 :     sidea = fe_inverse(get_next_facet(sidea));

	cmp	DWORD PTR tv962[ebp], 0
	mov	edx, DWORD PTR _web+460
	je	SHORT $LN92@calc_verte@2
	mov	ecx, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [ecx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN91@calc_verte@2
$LN92@calc_verte@2:
	mov	eax, DWORD PTR [edi+edx]
	mov	eax, DWORD PTR [eax+40]
$LN91@calc_verte@2:
	xor	eax, 134217728				; 08000000H

; 2062 :     sidea = get_next_edge(sidea);

	test	eax, 134217728				; 08000000H
	je	SHORT $LN96@calc_verte@2
	and	eax, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	esi, DWORD PTR [ecx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN95@calc_verte@2
$LN96@calc_verte@2:
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	esi, DWORD PTR [eax+32]
$LN95@calc_verte@2:

; 2063 :     if ( bdry != get_facet_boundary(get_fe_facet(sidea)) ) break;

	mov	eax, DWORD PTR _F_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN37@calc_verte@2
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN100@calc_verte@2
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN99@calc_verte@2
$LN100@calc_verte@2:
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN99@calc_verte@2
	xor	ecx, 134217728				; 08000000H
$LN99@calc_verte@2:
	mov	edi, DWORD PTR _web+236
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edi+64]
	mov	eax, DWORD PTR [ecx+eax]
	imul	eax, 136				; 00000088H
	add	eax, ebx
	jmp	SHORT $LN38@calc_verte@2
$LN37@calc_verte@2:
	xor	eax, eax
$LN38@calc_verte@2:
	cmp	DWORD PTR _bdry$[ebp], eax
	jne	$snormalize$90174

; 2064 : 
; 2065 :     get_fe_side(sidea,z);

	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	edx, DWORD PTR [edi+edx]
	mov	eax, esi
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	lea	ecx, DWORD PTR _z$[ebp]
	push	ecx
	push	eax
	call	_get_edge_side

; 2066 :     get_fe_side(get_prev_edge(sidea),y);

	mov	ecx, DWORD PTR _web+460
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN106@calc_verte@2
	mov	edx, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN105@calc_verte@2
$LN106@calc_verte@2:
	mov	eax, DWORD PTR [edi+ecx]
	mov	eax, DWORD PTR [eax+28]
$LN105@calc_verte@2:
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+edx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]
	push	eax
	call	_get_edge_side

; 2067 :     cross_prod(y,z,fnorm);

	lea	edx, DWORD PTR _fnorm$[ebp]
	push	edx
	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	call	_cross_prod

; 2068 :     for ( i = 0 ; i < SDIM ; i++ ) norm[i] += fnorm[i]/2;

	xor	ecx, ecx
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _web+616, ecx
	jle	$LL133@calc_verte@2
	mov	eax, DWORD PTR _norm$GSCopy$[ebp]
	fld	QWORD PTR __real@3fe0000000000000
	lea	edx, DWORD PTR _fnorm$[ebp]
	sub	edx, eax
$LN136@calc_verte@2:
	fld	QWORD PTR [eax+edx]
	inc	ecx
	fmul	ST(0), ST(1)
	add	eax, 8
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN136@calc_verte@2
	fstp	ST(0)

; 2069 :   }

	jmp	$LL133@calc_verte@2
$snormalize$90174:

; 2070 : 
; 2071 :   snormalize:
; 2072 : 
; 2073 :   size = sqrt(SDIM_dot(norm,norm));

	mov	edx, DWORD PTR _web+616
	mov	esi, DWORD PTR _norm$GSCopy$[ebp]
	push	edx
	push	esi
	push	esi
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 2074 :   if ( size <= 0.0 ) return; 

	fldz
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN149@calc_verte@2

; 2075 :   for ( i = 0 ; i < SDIM ; i++ ) norm[i] /= size;

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN149@calc_verte@2
$LN137@calc_verte@2:
	fld	QWORD PTR [esi+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [esi+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN137@calc_verte@2
$LN149@calc_verte@2:

; 2076 : } // end calc_vertex_smooth_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_calc_vertex_smooth_normal ENDP
_TEXT	ENDS
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@4000000000000000
PUBLIC	??_C@_0DF@KNGPIABI@hessian_special_normal_vector?5is@ ; `string'
PUBLIC	_norm$GSCopy$
PUBLIC	_v_id$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_new_calc_vertex_normal
EXTRN	_matvec_mul:PROC
EXTRN	_hessian_normal_one_flag:DWORD
EXTRN	_hessian_special_normal_expr:BYTE
EXTRN	_hessian_special_normal_flag:DWORD
EXTRN	_simplex_vertex_normal:PROC
;	COMDAT __real@3ff8000000000000
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT ??_C@_0DF@KNGPIABI@hessian_special_normal_vector?5is@
CONST	SEGMENT
??_C@_0DF@KNGPIABI@hessian_special_normal_vector?5is@ DB 'hessian_special'
	DB	'_normal_vector is zero at vertex %s.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\utility.c
CONST	ENDS
;	COMDAT _new_calc_vertex_normal
_TEXT	SEGMENT
_fnormqXvS$ = -760					; size = 24
_norm2qXvS$90568 = -736					; size = 24
_norm2qXvS$90551 = -736					; size = 24
_matqXvS$90439 = -736					; size = 24
_vxqXvS$90527 = -724					; size = 12
tv1599 = -720						; size = 8
_size$ = -720						; size = 8
_vattr$ = -720						; size = 8
_t$90610 = -712						; size = 4
_triples$ = -712					; size = 4
_start_e$90612 = -708					; size = 4
_t$90531 = -708						; size = 4
_singles$ = -708					; size = 4
tv1387 = -704						; size = 8
tv1601 = -700						; size = 4
tv1293 = -700						; size = 4
tv896 = -700						; size = 4
tv371 = -700						; size = 4
_triple_count$90611 = -700				; size = 4
_t$90537 = -700						; size = 4
_e_id$90517 = -700					; size = 4
_doubles$ = -700					; size = 4
_fnorm$ = -696						; size = 4
_sidea$ = -692						; size = 4
_fe_id$90453 = -692					; size = 4
_bareflag$ = -692					; size = 4
_norm$GSCopy$ = -688					; size = 4
_v_id$GSCopy$ = -684					; size = 4
tv1217 = -680						; size = 4
_retval$ = -680						; size = 4
_fnormxJ$ = -676					; size = 288
_norm2xJ$90569 = -388					; size = 288
_norm2xJ$90552 = -388					; size = 288
_matxJ$90440 = -388					; size = 288
_vxxJ$90528 = -244					; size = 144
_z$ = -100						; size = 48
_y$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_v_id$ = 8						; size = 4
_norm$ = 12						; size = 4
_new_calc_vertex_normal PROC				; COMDAT

; 2269 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 760				; 000002f8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _v_id$[ebp]
	push	edi
	mov	edi, DWORD PTR _norm$[ebp]

; 2270 :   int i,j,kk;
; 2271 :   REAL y[MAXCOORD],z[MAXCOORD];
; 2272 :   MAT2D(fnorm,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _fnormxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _fnormqXvS$[ebp]
	push	ecx

; 2290 :       norm[0][i] = eval(hessian_special_normal_expr+i,x,v_id,NULL);

	mov	DWORD PTR _v_id$GSCopy$[ebp], ebx
	mov	DWORD PTR _norm$GSCopy$[ebp], edi
	call	_mat2d_setup
	xor	ecx, ecx
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _web+624, 3
	mov	DWORD PTR _fnorm$[ebp], eax
	mov	DWORD PTR _singles$[ebp], ecx
	mov	DWORD PTR _doubles$[ebp], ecx
	mov	DWORD PTR _triples$[ebp], ecx
	mov	DWORD PTR _bareflag$[ebp], ecx
	jne	SHORT $LN147@new_calc_v

; 2273 :   facetedge_id sidea,sideb,ffe;
; 2274 :  // struct boundary *bdry;  /* to check staying on same boundary */
; 2275 :   REAL size;
; 2276 :   int retval = 0;
; 2277 :   facetedge_id fe,start_fe;
; 2278 :   facet_id f_id;
; 2279 :   int valence,bares=0,singles=0,doubles=0,triples=0,bareflag=0;
; 2280 :   ATTR vattr;
; 2281 : 
; 2282 :   if (web.representation == SIMPLEX ) return simplex_vertex_normal(v_id,norm);

	push	edi
	push	ebx
	call	_simplex_vertex_normal
	add	esp, 8
	pop	edi
	pop	ebx

; 2579 : } // end new_calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN147@new_calc_v:

; 2283 : 
; 2284 :   vattr = get_vattr(v_id);

	mov	edx, DWORD PTR _web+12
	mov	eax, ebx
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv1217[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+8]
	push	esi
	mov	esi, DWORD PTR [eax+12]
	mov	DWORD PTR _vattr$[ebp], edx
	mov	DWORD PTR _vattr$[ebp+4], esi

; 2285 : 
; 2286 :   if ( hessian_special_normal_flag )

	cmp	DWORD PTR _hessian_special_normal_flag, ecx
	je	$LN146@new_calc_v

; 2287 :   { 
; 2288 :     REAL *x = get_coord(v_id); 

	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ecx+edx+64]
	add	ebx, eax

; 2289 :     for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN143@new_calc_v

; 2287 :   { 
; 2288 :     REAL *x = get_coord(v_id); 

	mov	edi, OFFSET _hessian_special_normal_expr
	npad	5
$LL145@new_calc_v:

; 2290 :       norm[0][i] = eval(hessian_special_normal_expr+i,x,v_id,NULL);

	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	0
	push	eax
	push	ebx
	push	edi
	call	_eval
	mov	ecx, DWORD PTR _norm$GSCopy$[ebp]
	mov	edx, DWORD PTR [ecx]
	fstp	QWORD PTR [edx+esi*8]
	mov	eax, DWORD PTR _web+616
	inc	esi
	add	esp, 16					; 00000010H
	add	edi, 104				; 00000068H
	cmp	esi, eax
	jl	SHORT $LL145@new_calc_v
$LN143@new_calc_v:

; 2291 :     size = sqrt(SDIM_dot(norm[0],norm[0]));

	mov	esi, DWORD PTR _norm$GSCopy$[ebp]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	ecx
	push	ecx
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt
	fst	QWORD PTR _size$[ebp]

; 2292 :     if ( size == 0.0 )

	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN235@new_calc_v

; 2293 :     { sprintf(errmsg, "hessian_special_normal_vector is zero at vertex %s.\n",
; 2294 :              ELNAME(v_id));

	test	DWORD PTR _v_id$GSCopy$[ebp], 268435456	; 10000000H
	fstp	ST(0)
	je	SHORT $LN150@new_calc_v
	mov	eax, DWORD PTR tv1217[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN151@new_calc_v
$LN150@new_calc_v:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN151@new_calc_v:
	push	eax
	push	OFFSET ??_C@_0DF@KNGPIABI@hessian_special_normal_vector?5is@
	push	OFFSET _errmsg
	call	_sprintf

; 2295 :       kb_error(2212,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2212					; 000008a4H
	call	_kb_error
	fld	QWORD PTR _size$[ebp]
	add	esp, 24					; 00000018H
$LN235@new_calc_v:

; 2296 :     }
; 2297 :     for ( i = 0 ; i < SDIM ; i++ ) norm[0][i] = norm[0][i]/size;

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN253@new_calc_v
$LN141@new_calc_v:
	mov	ecx, DWORD PTR [esi]
	fld	QWORD PTR [ecx+eax*8]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fdiv	ST(0), ST(1)
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN141@new_calc_v
$LN253@new_calc_v:
	pop	esi
	fstp	ST(0)
	pop	edi

; 2298 :     return 1; /* one-dimensional normal only */

	mov	eax, 1
	pop	ebx

; 2579 : } // end new_calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN146@new_calc_v:

; 2299 :   }                             
; 2300 : 
; 2301 :   if ( hessian_normal_one_flag )

	cmp	DWORD PTR _hessian_normal_one_flag, ecx
	je	$LN138@new_calc_v

; 2302 :   { MAT2D(mat,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	edx, DWORD PTR _matxJ$90440[ebp]
	push	edx
	lea	eax, DWORD PTR _matqXvS$90439[ebp]
	push	eax
	call	_mat2d_setup
	mov	ebx, eax

; 2303 :     facet_id f_id;
; 2304 :     edge_id e_id, starte;
; 2305 : 
; 2306 :     for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 16					; 00000010H
	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN135@new_calc_v
	fldz
$LN137@new_calc_v:

; 2307 :       for ( j = 0 ; j < SDIM ; j++ )

	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN136@new_calc_v

; 2303 :     facet_id f_id;
; 2304 :     edge_id e_id, starte;
; 2305 : 
; 2306 :     for ( i = 0 ; i < SDIM ; i++ )

	mov	ecx, DWORD PTR [ebx+esi*4]
$LN134@new_calc_v:

; 2308 :          mat[i][j] = 0.0;

	fst	QWORD PTR [ecx]
	mov	eax, DWORD PTR _web+616
	inc	edx
	add	ecx, 8
	cmp	edx, eax
	jl	SHORT $LN134@new_calc_v
$LN136@new_calc_v:

; 2303 :     facet_id f_id;
; 2304 :     edge_id e_id, starte;
; 2305 : 
; 2306 :     for ( i = 0 ; i < SDIM ; i++ )

	inc	esi
	cmp	esi, eax
	jl	SHORT $LN137@new_calc_v
	fstp	ST(0)
$LN135@new_calc_v:

; 2309 :     if ( web.representation == SOAPFILM )

	mov	ecx, DWORD PTR _web+624
	cmp	ecx, 2
	jne	$LN131@new_calc_v

; 2310 :     { facetedge_id fe_id,startfe; 
; 2311 :       fe_id = startfe = get_vertex_first_facet(v_id);

	mov	ecx, DWORD PTR _v_id$GSCopy$[ebp]
	push	ecx
	call	_get_vertex_first_facet
	add	esp, 4
	mov	DWORD PTR _fe_id$90453[ebp], eax
	or	eax, 134217728				; 08000000H

; 2337 :     { matvec_mul(mat,fnorm[0],y,SDIM,SDIM);

	mov	DWORD PTR tv1293[ebp], eax
	npad	2
$LL130@new_calc_v:

; 2312 :       do 
; 2313 :       { f_id = get_fe_facet(fe_id);

	mov	ecx, DWORD PTR _fe_id$90453[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN153@new_calc_v
	mov	eax, DWORD PTR _NULLFACET
	jmp	SHORT $LN152@new_calc_v
$LN153@new_calc_v:
	mov	eax, DWORD PTR _web+460
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edx+24]
	test	ecx, 134217728				; 08000000H
	je	SHORT $LN152@new_calc_v
	xor	eax, 134217728				; 08000000H
$LN152@new_calc_v:

; 2314 :         get_facet_normal(f_id,fnorm[0]);

	mov	esi, DWORD PTR _fnorm$[ebp]
	mov	ecx, DWORD PTR [esi]
	push	ecx
	push	eax
	call	_get_facet_normal

; 2315 :         size = SDIM_dot(fnorm[0],fnorm[0]);

	mov	edx, DWORD PTR _web+616
	mov	eax, DWORD PTR [esi]
	push	edx
	push	eax
	push	eax
	call	_dot

; 2316 :         for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR _web+616
	add	esp, 20					; 00000014H
	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN268@new_calc_v
$LN127@new_calc_v:

; 2317 :            for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	eax, eax
	jle	SHORT $LN126@new_calc_v
	mov	eax, DWORD PTR _fnorm$[ebp]
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+edx*4]
	mov	edi, esi
	sub	edi, eax
$LN234@new_calc_v:

; 2318 :               mat[i][j] += fnorm[0][i]*fnorm[0][j]/size;

	fld	QWORD PTR [edi+eax]
	inc	ecx
	fmul	QWORD PTR [esi+edx*8]
	add	eax, 8
	fdiv	ST(0), ST(1)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN234@new_calc_v

; 2317 :            for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR _web+616
$LN126@new_calc_v:

; 2316 :         for ( i = 0 ; i < SDIM ; i++ )

	inc	edx
	cmp	edx, eax
	jl	SHORT $LN127@new_calc_v
$LN268@new_calc_v:

; 2319 :         fe_id = get_next_vertex_facet(v_id,fe_id);

	mov	ecx, DWORD PTR _fe_id$90453[ebp]
	fstp	ST(0)
	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
	push	ecx
	push	edx
	call	_get_next_vertex_facet
	mov	DWORD PTR _fe_id$90453[ebp], eax

; 2320 :       } while ( !equal_element(fe_id,startfe) );

	or	eax, 134217728				; 08000000H
	add	esp, 8
	cmp	eax, DWORD PTR tv1293[ebp]
	jne	$LL130@new_calc_v

; 2332 :       } while ( !equal_element(e_id,starte) );

	mov	eax, DWORD PTR _web+616

; 2333 :     }
; 2334 : 
; 2335 :     /* find eigenvector */
; 2336 :     for ( kk = 0 ; kk < 10 ; kk++ )

	mov	esi, DWORD PTR _fnorm$[ebp]
	mov	edi, 10					; 0000000aH
	jmp	$LN116@new_calc_v
$LN131@new_calc_v:

; 2321 :     }
; 2322 :     else if ( web.representation == STRING )

	cmp	ecx, 1
	jne	$LN117@new_calc_v

; 2323 :     { 
; 2324 :       e_id = starte = get_vertex_edge(v_id);

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR tv1217[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	esi, DWORD PTR [edx+28]
	mov	eax, DWORD PTR _fnorm$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	edi, esi
	or	edi, 134217728				; 08000000H
	npad	7
$LL119@new_calc_v:

; 2325 :       do 
; 2326 :       { get_edge_side(e_id,fnorm[0]);

	push	eax
	push	esi
	call	_get_edge_side

; 2327 :         mat[0][0] += fnorm[0][1]*fnorm[0][1];

	mov	ecx, DWORD PTR _fnorm$[ebp]
	mov	eax, DWORD PTR [ecx]
	fld	QWORD PTR [eax+8]
	mov	ecx, DWORD PTR [ebx]
	fmul	ST(0), ST(0)

; 2328 :         mat[0][1] -= fnorm[0][1]*fnorm[0][0];
; 2329 :         mat[1][0] -= fnorm[0][0]*fnorm[0][1];
; 2330 :         mat[1][1] += fnorm[0][0]*fnorm[0][0];
; 2331 :         e_id = get_next_tail_edge(e_id);

	mov	edx, esi
	shr	edx, 27					; 0000001bH
	and	esi, 134217727				; 07ffffffH
	fadd	QWORD PTR [ecx]
	and	edx, 1
	add	esp, 8
	fstp	QWORD PTR [ecx]
	fld	QWORD PTR [eax+8]
	fmul	QWORD PTR [eax]
	fsubr	QWORD PTR [ecx+8]
	fstp	QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ebx+4]
	fld	QWORD PTR [eax+8]
	fmul	QWORD PTR [eax]
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	fld	QWORD PTR [eax]
	fmul	ST(0), ST(0)
	fadd	QWORD PTR [ecx+8]
	fstp	QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR [ecx+edx*4+32]

; 2332 :       } while ( !equal_element(e_id,starte) );

	mov	edx, esi
	or	edx, 134217728				; 08000000H
	cmp	edx, edi
	jne	SHORT $LL119@new_calc_v
	mov	eax, DWORD PTR _web+616
$LN117@new_calc_v:

; 2333 :     }
; 2334 : 
; 2335 :     /* find eigenvector */
; 2336 :     for ( kk = 0 ; kk < 10 ; kk++ )

	mov	esi, DWORD PTR _fnorm$[ebp]
	mov	edi, 10					; 0000000aH
	jmp	SHORT $LN116@new_calc_v
$LL226@new_calc_v:
	mov	eax, DWORD PTR _web+616
$LN116@new_calc_v:

; 2337 :     { matvec_mul(mat,fnorm[0],y,SDIM,SDIM);

	mov	ecx, DWORD PTR [esi]
	push	eax
	push	eax
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	push	ecx
	push	ebx
	call	_matvec_mul

; 2338 :       matvec_mul(mat,y,fnorm[0],SDIM,SDIM);

	mov	eax, DWORD PTR _web+616
	mov	edx, DWORD PTR [esi]
	push	eax
	push	eax
	push	edx
	lea	eax, DWORD PTR _y$[ebp]
	push	eax
	push	ebx
	call	_matvec_mul
	add	esp, 40					; 00000028H
	dec	edi
	jne	SHORT $LL226@new_calc_v

; 2339 :     }
; 2340 : 
; 2341 :     size = sqrt(SDIM_dot(fnorm[0],fnorm[0]));

	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 2342 :     for ( i = 0 ; i < SDIM ; i++ ) norm[0][i] = fnorm[0][i]/size;

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN273@new_calc_v
	mov	esi, DWORD PTR [esi]
	mov	ecx, DWORD PTR _norm$GSCopy$[ebp]
$LN113@new_calc_v:
	fld	QWORD PTR [esi+eax*8]
	mov	edx, DWORD PTR [ecx]
	fdiv	ST(0), ST(1)
	inc	eax
	fstp	QWORD PTR [edx+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN113@new_calc_v
$LN273@new_calc_v:
	pop	esi
	fstp	ST(0)
	pop	edi

; 2343 :     return 1;

	mov	eax, 1
	pop	ebx

; 2579 : } // end new_calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN138@new_calc_v:

; 2344 :   } /* end hessian_normal_one_flag */
; 2345 : 
; 2346 :   if ( vattr & Q_MIDFACET ) 

	mov	ecx, edx
	and	ecx, 2097152				; 00200000H
	xor	esi, esi
	or	ecx, esi
	je	SHORT $LN110@new_calc_v

; 2347 :   { /* Lagrange model */
; 2348 :      facet_id f_id = get_vertex_facet(v_id);

	mov	eax, DWORD PTR [eax+32]

; 2349 :      retval = lagrange_facet_normal(v_id,f_id,norm);

	push	edi
	push	eax
	push	ebx
	call	_lagrange_facet_normal
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi
	mov	DWORD PTR _retval$[ebp], eax
	pop	ebx

; 2579 : } // end new_calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN110@new_calc_v:

; 2350 :      goto ncn_exit;
; 2351 :   }
; 2352 : 
; 2353 :   /* Want to check for bare edges in SOAPFILM model */
; 2354 :   /* so can handle same way as string edges  */
; 2355 :   if ( web.representation == SOAPFILM )

	cmp	DWORD PTR _web+624, 2
	jne	$LN228@new_calc_v

; 2356 :   { edge_id e_id,start_e;
; 2357 : 
; 2358 :     e_id = get_vertex_edge(v_id);

	mov	esi, DWORD PTR [eax+28]

; 2359 :     if ( !valid_id(e_id) ) goto full_dim; /* bare point */

	test	esi, 268435456				; 10000000H
	je	$LN232@new_calc_v

; 2360 : 
; 2361 :     start_e = e_id;

	mov	edi, edx
	mov	ebx, esi
	and	edi, 4325376				; 00420000H
$LL107@new_calc_v:

; 2362 :     do 
; 2363 :     { valence = get_edge_valence(e_id);

	push	esi
	call	_get_edge_valence
	add	esp, 4

; 2364 :       if ( valence == 0 ) bares++;
; 2365 :       if ( valence == 1 ) singles++;

	cmp	eax, 1
	jne	SHORT $LN103@new_calc_v
	inc	DWORD PTR _singles$[ebp]

; 2366 :       if ( valence == 2 ) doubles++;

	jmp	SHORT $LN244@new_calc_v
$LN103@new_calc_v:
	cmp	eax, 2
	jne	SHORT $LN102@new_calc_v
	inc	DWORD PTR _doubles$[ebp]

; 2367 :       if ( valence >= 3 ) triples++;

	jmp	SHORT $LN244@new_calc_v
$LN102@new_calc_v:
	cmp	eax, 3
	jl	SHORT $LN244@new_calc_v
	inc	DWORD PTR _triples$[ebp]
$LN244@new_calc_v:

; 2368 :       if ( vattr & (Q_MIDPOINT|Q_MIDEDGE) ) break;

	mov	ecx, edi
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN105@new_calc_v

; 2369 :       e_id = get_next_tail_edge(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	edx, esi
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [ecx+esi*4]
	shr	edx, 27					; 0000001bH
	and	edx, 1
	mov	esi, DWORD PTR [ecx+edx*4+32]

; 2370 :     } while ( !equal_id(e_id,start_e) );

	cmp	esi, ebx
	jne	SHORT $LL107@new_calc_v
$LN105@new_calc_v:

; 2371 : 
; 2372 :     if ( triples >= SDIM ) goto full_dim;

	mov	esi, DWORD PTR _web+616
	mov	ecx, DWORD PTR _triples$[ebp]
	cmp	ecx, esi
	jge	$full_dim$90487

; 2373 : //    if ( singles >= SDIM ) goto full_dim;
; 2374 : //    if ( bares >= SDIM ) goto full_dim;
; 2375 : //    if ( bares && (singles+doubles+triples) ) goto full_dim;
; 2376 :     if ( triples >= 1 )

	cmp	ecx, 1
	jl	SHORT $LN96@new_calc_v

; 2377 :     { if ( vattr & (Q_MIDPOINT|Q_MIDEDGE) ) bareflag = 1; /* effectively */

	or	edi, eax
	je	$tripletest$90504
	mov	DWORD PTR _bareflag$[ebp], 1
$LN96@new_calc_v:

; 2378 :       else goto tripletest;
; 2379 :     }
; 2380 :     if ( (singles==0) && (doubles==0) )

	cmp	DWORD PTR _singles$[ebp], eax
	jne	SHORT $LN227@new_calc_v
	cmp	DWORD PTR _doubles$[ebp], eax
	jne	SHORT $LN227@new_calc_v

; 2381 :       bareflag = 1;

	mov	DWORD PTR _bareflag$[ebp], 1
$LN227@new_calc_v:
	mov	edi, DWORD PTR _norm$GSCopy$[ebp]
	mov	edx, DWORD PTR _vattr$[ebp]
	mov	ebx, DWORD PTR _v_id$GSCopy$[ebp]
	jmp	SHORT $LN95@new_calc_v
$LN228@new_calc_v:
	mov	esi, DWORD PTR _web+616
$LN95@new_calc_v:

; 2382 :   }
; 2383 :     
; 2384 :   if ( (vattr & Q_MIDEDGE) && (bareflag || (web.representation == STRING)) )

	and	edx, 4194304				; 00400000H
	xor	eax, eax
	mov	DWORD PTR tv1387[ebp], edx
	or	edx, eax
	je	SHORT $LN94@new_calc_v
	cmp	DWORD PTR _bareflag$[ebp], eax
	jne	SHORT $LN93@new_calc_v
	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN94@new_calc_v
$LN93@new_calc_v:

; 2385 :   { 
; 2386 :      edge_id e_id = get_vertex_edge(v_id);

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR tv1217[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ecx+28]

; 2387 :      retval = lagrange_edge_normal(v_id,e_id,norm);

	push	edi
	push	eax
	push	ebx
	call	_lagrange_edge_normal
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi
	mov	DWORD PTR _retval$[ebp], eax
	pop	ebx

; 2579 : } // end new_calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN94@new_calc_v:

; 2388 :      goto ncn_exit;
; 2389 :   }
; 2390 : 
; 2391 :   if ( (vattr & Q_MIDPOINT) && (bareflag || (web.representation == STRING)) )

	mov	ebx, DWORD PTR _vattr$[ebp]
	and	ebx, 131072				; 00020000H
	xor	eax, eax
	mov	edx, ebx
	or	edx, eax
	je	SHORT $LN92@new_calc_v
	cmp	DWORD PTR _bareflag$[ebp], eax
	jne	SHORT $LN91@new_calc_v
	cmp	DWORD PTR _web+624, 1
	jne	$LN90@new_calc_v
$LN91@new_calc_v:

; 2392 :   { 
; 2393 :      edge_id e_id = get_vertex_edge(v_id);

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR tv1217[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+28]

; 2394 :      retval = quadratic_edge_normal(v_id,e_id,norm);

	push	edi
	push	eax
	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	eax
	call	_quadratic_edge_normal
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi
	mov	DWORD PTR _retval$[ebp], eax
	pop	ebx

; 2579 : } // end new_calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN92@new_calc_v:

; 2395 :      goto ncn_exit;
; 2396 :   }
; 2397 : 
; 2398 :   /* check for string */
; 2399 :   if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	$LN90@new_calc_v

; 2400 :   { /* Must be endpoint of string edge */
; 2401 :     edge_id e_id,ee_id,eee_id;
; 2402 :     e_id = get_vertex_edge(v_id);

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR tv1217[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ebx, DWORD PTR [eax+28]
	mov	DWORD PTR _e_id$90517[ebp], ebx

; 2403 :     if ( !valid_id(e_id) ) goto full_dim;

	test	ebx, 268435456				; 10000000H
	je	$full_dim$90487

; 2404 :     ee_id = get_next_tail_edge(e_id);

	push	ebx
	call	_get_next_tail_edge
	mov	edi, eax

; 2405 :     eee_id = get_next_tail_edge(ee_id);

	push	edi
	call	_get_next_tail_edge
	add	esp, 8

; 2406 : 
; 2407 :     if ( !equal_id(e_id,eee_id)  )

	cmp	ebx, eax
	jne	$full_dim$90487

; 2408 :        goto full_dim;  /* triple vertex at least */
; 2409 : 
; 2410 :     if ( (web.modeltype == LAGRANGE) && (web.lagrange_order >= 2) )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 3
	jne	SHORT $LN87@new_calc_v
	cmp	DWORD PTR _web+632, 2
	jl	$LN85@new_calc_v

; 2411 :        retval = lagrange_edge_normal(v_id,e_id,norm);

	mov	esi, DWORD PTR _norm$GSCopy$[ebp]
	mov	ecx, DWORD PTR _v_id$GSCopy$[ebp]
	push	esi
	push	ebx
	push	ecx
	call	_lagrange_edge_normal
	add	esp, 12					; 0000000cH
	jmp	$LN302@new_calc_v
$LN87@new_calc_v:

; 2412 :     else if ( web.modeltype == QUADRATIC )

	cmp	eax, 2
	jne	$LN85@new_calc_v

; 2413 :     { MAT2D(vx,3,MAXCOORD);

	push	6
	push	3
	lea	edx, DWORD PTR _vxxJ$90528[ebp]
	push	edx
	lea	eax, DWORD PTR _vxqXvS$90527[ebp]
	push	eax
	call	_mat2d_setup
	mov	esi, eax

; 2414 :       REAL *t = y;
; 2415 :       get_edge_verts(e_id,vx,NULL);

	push	0
	lea	ecx, DWORD PTR _y$[ebp]
	push	esi
	push	ebx
	mov	DWORD PTR _t$90531[ebp], ecx
	call	_get_edge_verts

; 2416 :       for ( i = 0 ; i < SDIM ; i++ ) 

	fld	QWORD PTR __real@4000000000000000
	mov	edx, DWORD PTR _web+616
	fld	QWORD PTR __real@3ff8000000000000
	fld	QWORD PTR __real@3fe0000000000000
	add	esp, 28					; 0000001cH
	xor	eax, eax
	cmp	edx, 4
	jl	$LC220@new_calc_v

; 2417 :          y[i] = -1.5*vx[0][i] + 2*vx[1][i] - 0.5*vx[2][i];

	lea	edi, DWORD PTR [edx-3]
	lea	ecx, DWORD PTR _y$[ebp+8]
$LN221@new_calc_v:
	mov	ebx, DWORD PTR [esi+4]
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [esi]
	fmul	ST(0), ST(3)
	add	eax, 4
	fld	QWORD PTR [ebx+eax*8-32]
	mov	ebx, DWORD PTR [esi+8]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ebx+eax*8-32]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+eax*8-40]
	mov	ebx, DWORD PTR [esi+4]
	fld	QWORD PTR [ebx+eax*8-24]
	mov	ebx, DWORD PTR [esi]
	fmul	ST(0), ST(3)
	fld	QWORD PTR [ebx+eax*8-24]
	mov	ebx, DWORD PTR [esi+8]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ebx+eax*8-24]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+eax*8-32]
	mov	ebx, DWORD PTR [esi+4]
	fld	QWORD PTR [ebx+eax*8-16]
	mov	ebx, DWORD PTR [esi]
	fmul	ST(0), ST(3)
	fld	QWORD PTR [ebx+eax*8-16]
	mov	ebx, DWORD PTR [esi+8]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ebx+eax*8-16]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _y$[ebp+eax*8-16]
	mov	ebx, DWORD PTR [esi+4]
	fld	QWORD PTR [ebx+eax*8-8]
	mov	ebx, DWORD PTR [esi]
	fmul	ST(0), ST(3)
	fld	QWORD PTR [ebx+eax*8-8]
	mov	ebx, DWORD PTR [esi+8]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ebx+eax*8-8]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _y$[ebp+eax*8-8]
	cmp	eax, edi
	jl	$LN221@new_calc_v
	mov	ebx, DWORD PTR _e_id$90517[ebp]
$LC220@new_calc_v:

; 2416 :       for ( i = 0 ; i < SDIM ; i++ ) 

	cmp	eax, edx
	jge	SHORT $LN282@new_calc_v
$LC84@new_calc_v:

; 2417 :          y[i] = -1.5*vx[0][i] + 2*vx[1][i] - 0.5*vx[2][i];

	mov	ecx, DWORD PTR [esi+4]
	fld	QWORD PTR [ecx+eax*8]
	mov	ecx, DWORD PTR [esi]
	fmul	ST(0), ST(3)
	inc	eax
	fld	QWORD PTR [ecx+eax*8-8]
	mov	ecx, DWORD PTR [esi+8]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx+eax*8-8]
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _y$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC84@new_calc_v
$LN282@new_calc_v:

; 2418 :       retval = kernel_basis_rows(&t,norm,1,SDIM);

	mov	esi, DWORD PTR _norm$GSCopy$[ebp]
	fstp	ST(2)
	push	edx
	fstp	ST(0)
	push	1
	fstp	ST(0)
	push	esi
	lea	edx, DWORD PTR _t$90531[ebp]
	push	edx

; 2419 :     }
; 2420 :     else 

	jmp	$LN303@new_calc_v
$LN85@new_calc_v:

; 2421 :     { REAL *t = y;

	lea	eax, DWORD PTR _y$[ebp]

; 2422 :       get_edge_side(e_id,y);

	mov	ecx, eax
	push	ecx
	push	ebx
	mov	DWORD PTR _t$90537[ebp], eax
	call	_get_edge_side
	add	esp, 8

; 2423 :       if ( !equal_id(e_id,ee_id ) )

	cmp	ebx, edi
	je	SHORT $LN229@new_calc_v

; 2424 :       { get_edge_side(ee_id,z);

	lea	edx, DWORD PTR _z$[ebp]
	push	edx
	push	edi
	call	_get_edge_side

; 2425 :         for ( i = 0 ; i < SDIM ; i++ ) y[i] -= z[i];

	mov	edx, DWORD PTR _web+616
	add	esp, 8
	xor	eax, eax
	cmp	edx, 4
	jl	SHORT $LC223@new_calc_v
	lea	ecx, DWORD PTR [edx-3]
$LL224@new_calc_v:
	fld	QWORD PTR _y$[ebp+eax*8]
	add	eax, 4
	fsub	QWORD PTR _z$[ebp+eax*8-32]
	fstp	QWORD PTR _y$[ebp+eax*8-32]
	fld	QWORD PTR _y$[ebp+eax*8-24]
	fsub	QWORD PTR _z$[ebp+eax*8-24]
	fstp	QWORD PTR _y$[ebp+eax*8-24]
	fld	QWORD PTR _y$[ebp+eax*8-16]
	fsub	QWORD PTR _z$[ebp+eax*8-16]
	fstp	QWORD PTR _y$[ebp+eax*8-16]
	fld	QWORD PTR _y$[ebp+eax*8-8]
	fsub	QWORD PTR _z$[ebp+eax*8-8]
	fstp	QWORD PTR _y$[ebp+eax*8-8]
	cmp	eax, ecx
	jl	SHORT $LL224@new_calc_v
$LC223@new_calc_v:
	cmp	eax, edx
	jge	SHORT $LN222@new_calc_v
$LC79@new_calc_v:
	fld	QWORD PTR _y$[ebp+eax*8]
	inc	eax
	fsub	QWORD PTR _z$[ebp+eax*8-8]
	fstp	QWORD PTR _y$[ebp+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC79@new_calc_v
	jmp	SHORT $LN222@new_calc_v
$LN229@new_calc_v:
	mov	edx, DWORD PTR _web+616
$LN222@new_calc_v:

; 2426 :       }
; 2427 :       retval = kernel_basis_rows(&t,norm,1,SDIM);

	mov	esi, DWORD PTR _norm$GSCopy$[ebp]
	push	edx
	push	1
	push	esi
	lea	eax, DWORD PTR _t$90537[ebp]
	push	eax
$LN303@new_calc_v:
	call	_kernel_basis_rows
	add	esp, 16					; 00000010H
$LN302@new_calc_v:
	mov	DWORD PTR _retval$[ebp], eax

; 2428 :     }
; 2429 :     if ( inverted(e_id) )

	test	ebx, 134217728				; 08000000H
	je	$ncn_exit$90480

; 2430 :       for ( i = 0 ; i < SDIM ; i++ ) norm[0][i] = -norm[0][i];

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	$ncn_exit$90480
$LL75@new_calc_v:
	mov	ecx, DWORD PTR [esi]
	fld	QWORD PTR [ecx+eax*8]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fchs
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL75@new_calc_v

; 2565 :    }
; 2566 :    goto ncn_exit;
; 2567 :   
; 2568 : ncn_exit:
; 2569 : 
; 2570 :   return retval;

	mov	eax, DWORD PTR _retval$[ebp]
	pop	esi
	pop	edi
	pop	ebx

; 2579 : } // end new_calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN90@new_calc_v:

; 2431 : 
; 2432 :     goto ncn_exit;    
; 2433 :   }
; 2434 : 
; 2435 :   /* now have 2D facets */
; 2436 :   fe = get_vertex_fe(v_id);

	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
	push	edx
	call	_get_vertex_fe
	mov	edi, eax
	add	esp, 4

; 2437 :   if ( !valid_id(fe) ) 

	test	edi, 268435456				; 10000000H
	je	$full_dim$90487

; 2438 :      goto full_dim; 
; 2439 :  // bdry = get_facet_boundary(get_fe_facet(fe));  /* original boundary */
; 2440 : 
; 2441 :   sidea = fe;
; 2442 :   if ( vattr & Q_MIDPOINT )

	xor	eax, eax
	or	ebx, eax
	mov	DWORD PTR _sidea$[ebp], edi
	je	$LN71@new_calc_v

; 2443 :   { /* quadratic model */
; 2444 :     /* already tested for bare or triple edges, so one or two facets */
; 2445 :     /* If two, combine normals */
; 2446 :      MAT2D(norm2,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _norm2xJ$90552[ebp]
	push	eax
	lea	ecx, DWORD PTR _norm2qXvS$90551[ebp]
	push	ecx
	call	_mat2d_setup

; 2447 :      facet_id f_id = get_fe_facet(sidea);

	push	edi
	mov	ebx, eax
	call	_get_fe_facet
	add	esp, 20					; 00000014H

; 2448 :      if ( inverted(f_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN240@new_calc_v

; 2449 :         sidea = inverse_id(sidea); 

	xor	edi, 134217728				; 08000000H
	jmp	SHORT $LN70@new_calc_v
$LN240@new_calc_v:
	mov	edi, DWORD PTR _sidea$[ebp]
$LN70@new_calc_v:

; 2450 :      if ( !equal_id(get_next_facet(sidea),get_prev_facet(sidea)) )

	push	edi
	call	_get_next_facet
	push	edi
	mov	esi, eax
	call	_get_prev_facet
	add	esp, 8
	cmp	esi, eax
	jne	$LN230@new_calc_v

; 2451 :        goto tripletest;
; 2452 :      retval = quadratic_facet_normal(v_id,get_fe_facet(sidea),norm);

	mov	esi, DWORD PTR _norm$GSCopy$[ebp]
	push	esi
	push	edi
	call	_get_fe_facet
	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
	add	esp, 4
	push	eax
	push	edx
	call	_quadratic_facet_normal

; 2453 :      sideb = get_next_facet(sidea); 

	push	edi
	mov	DWORD PTR _retval$[ebp], eax
	call	_get_next_facet
	add	esp, 16					; 00000010H

; 2454 :      if ( equal_id(sidea,sideb) ) goto ncn_exit;

	cmp	edi, eax
	je	$ncn_exit$90480

; 2455 :      sideb = inverse_id(sideb);

	xor	eax, 134217728				; 08000000H

; 2456 :      retval = quadratic_facet_normal(v_id,get_fe_facet(sideb),norm2);

	push	ebx
	push	eax
	call	_get_fe_facet
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	eax
	call	_quadratic_facet_normal
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _retval$[ebp], eax

; 2457 :      for ( i = 0 ; i < retval ; i++ )

	test	eax, eax
	jle	$ncn_exit$90480

; 2456 :      retval = quadratic_facet_normal(v_id,get_fe_facet(sideb),norm2);

	mov	ecx, eax
	mov	edi, esi

; 2457 :      for ( i = 0 ; i < retval ; i++ )

	sub	ebx, esi
	mov	esi, DWORD PTR _web+616
	mov	DWORD PTR tv371[ebp], ecx
	npad	2
$LL246@new_calc_v:

; 2458 :         for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN66@new_calc_v
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ebx+edi]
	sub	edx, eax
	npad	3
$LL64@new_calc_v:

; 2459 :            norm[i][j] += norm2[i][j];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	esi, DWORD PTR _web+616
	cmp	ecx, esi
	jl	SHORT $LL64@new_calc_v
$LN66@new_calc_v:

; 2457 :      for ( i = 0 ; i < retval ; i++ )

	add	edi, 4
	dec	DWORD PTR tv371[ebp]
	jne	SHORT $LL246@new_calc_v

; 2565 :    }
; 2566 :    goto ncn_exit;
; 2567 :   
; 2568 : ncn_exit:
; 2569 : 
; 2570 :   return retval;

	mov	eax, DWORD PTR _retval$[ebp]
	pop	esi
	pop	edi
	pop	ebx

; 2579 : } // end new_calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@new_calc_v:

; 2460 :      goto ncn_exit;
; 2461 :   }
; 2462 :   if ( vattr & Q_MIDEDGE )

	mov	eax, DWORD PTR tv1387[ebp]
	xor	ecx, ecx
	or	eax, ecx
	je	$LN61@new_calc_v

; 2463 :   { /* Lagrange model */
; 2464 :      MAT2D(norm2,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	edx, DWORD PTR _norm2xJ$90569[ebp]
	push	edx
	lea	eax, DWORD PTR _norm2qXvS$90568[ebp]
	push	eax
	call	_mat2d_setup

; 2465 :      facet_id f_id = get_fe_facet(sidea);

	push	edi
	mov	ebx, eax
	call	_get_fe_facet
	add	esp, 20					; 00000014H

; 2466 :      if ( inverted(f_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN241@new_calc_v

; 2467 :         sidea = inverse_id(sidea); 

	xor	edi, 134217728				; 08000000H
	mov	DWORD PTR _sidea$[ebp], edi
	jmp	SHORT $LN60@new_calc_v
$LN241@new_calc_v:
	mov	edi, DWORD PTR _sidea$[ebp]
$LN60@new_calc_v:

; 2468 :      if ( !equal_id(get_next_facet(sidea),get_prev_facet(sidea)) )

	push	edi
	call	_get_next_facet
	push	edi
	mov	esi, eax
	call	_get_prev_facet
	add	esp, 8
	cmp	esi, eax
	je	$LN59@new_calc_v
$LN230@new_calc_v:
	mov	esi, DWORD PTR _web+616
$tripletest$90504:

; 2522 :  
; 2523 : 
; 2524 :   goto ncn_exit;
; 2525 : 
; 2526 : tripletest:
; 2527 :   /* if get here, know there are one or two triple edges into vertex */
; 2528 :   { /* triple line */
; 2529 :      REAL *t = fnorm[0];

	mov	ecx, DWORD PTR _fnorm$[ebp]
	mov	ecx, DWORD PTR [ecx]

; 2530 :      int triple_count = 0;

	xor	eax, eax
	mov	DWORD PTR _t$90610[ebp], ecx
	mov	DWORD PTR _triple_count$90611[ebp], eax

; 2531 :      facetedge_id start_e;
; 2532 :      edge_id e_id;
; 2533 : 
; 2534 :      for ( i = 0 ; i < SDIM ; i++ ) fnorm[0][i] = 0.;

	cmp	esi, eax
	jle	SHORT $LN237@new_calc_v

; 2522 :  
; 2523 : 
; 2524 :   goto ncn_exit;
; 2525 : 
; 2526 : tripletest:
; 2527 :   /* if get here, know there are one or two triple edges into vertex */
; 2528 :   { /* triple line */
; 2529 :      REAL *t = fnorm[0];

	fldz
$LN27@new_calc_v:

; 2531 :      facetedge_id start_e;
; 2532 :      edge_id e_id;
; 2533 : 
; 2534 :      for ( i = 0 ; i < SDIM ; i++ ) fnorm[0][i] = 0.;

	fst	QWORD PTR [ecx]
	inc	eax
	add	ecx, 8
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN27@new_calc_v
	fstp	ST(0)
$LN237@new_calc_v:

; 2535 :      start_e = e_id = get_vertex_edge(v_id);

	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR tv1217[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [ecx+28]
	mov	DWORD PTR _start_e$90612[ebp], edi
$LL24@new_calc_v:

; 2536 :      do 
; 2537 :      { int valence = get_edge_valence(e_id);

	push	edi
	call	_get_edge_valence
	add	esp, 4

; 2538 :        if ( valence >= 3 )  

	cmp	eax, 3
	jl	$LN238@new_calc_v

; 2539 :        { if ( web.modeltype==QUADRATIC )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	je	$LN192@new_calc_v

; 2541 :            goto ncn_exit; /* lazy; just use first triple */
; 2542 :          }
; 2543 :          if ( web.modeltype==LAGRANGE )

	cmp	eax, 3
	je	$LN194@new_calc_v

; 2546 :          }
; 2547 :          /* accumulate tangents */
; 2548 :          ffe = get_edge_fe(e_id);

	push	edi
	call	_get_edge_fe
	mov	esi, eax

; 2549 :          if ( !equal_id(get_next_facet(ffe),get_prev_facet(ffe)) )

	push	esi
	call	_get_next_facet
	push	esi
	mov	ebx, eax
	call	_get_prev_facet
	add	esp, 12					; 0000000cH
	cmp	ebx, eax
	je	$LN238@new_calc_v

; 2550 :          { /* triple again */
; 2551 :             triple_count++;

	mov	ebx, DWORD PTR _triple_count$90611[ebp]

; 2552 :             get_fe_side(ffe,z);

	lea	edx, DWORD PTR _z$[ebp]
	push	edx
	inc	ebx
	push	esi
	mov	DWORD PTR _triple_count$90611[ebp], ebx
	call	_get_fe_edge
	add	esp, 4
	push	eax
	call	_get_edge_side

; 2553 :             switch ( triple_count )

	mov	eax, ebx
	add	esp, 8
	dec	eax
	je	SHORT $LN15@new_calc_v
	dec	eax
	jne	$LN232@new_calc_v

; 2556 :               case 2:
; 2557 :                 for ( i = 0 ; i < SDIM ; i++ ) fnorm[0][i] -= z[i]; break;

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN238@new_calc_v
	mov	eax, DWORD PTR _fnorm$[ebp]
	mov	eax, DWORD PTR [eax]
	lea	edx, DWORD PTR _z$[ebp]
	sub	edx, eax
$LL10@new_calc_v:
	fld	QWORD PTR [eax]
	inc	ecx
	fsub	QWORD PTR [edx+eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL10@new_calc_v
	jmp	SHORT $LN238@new_calc_v
$LN15@new_calc_v:

; 2554 :             { case 1:
; 2555 :                 for ( i = 0 ; i < SDIM ; i++ ) fnorm[0][i] += z[i]; break;

	xor	ecx, ecx
	cmp	DWORD PTR _web+616, ecx
	jle	SHORT $LN238@new_calc_v
	mov	edx, DWORD PTR _fnorm$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	edx, DWORD PTR _z$[ebp]
	sub	edx, eax
$LL14@new_calc_v:
	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LL14@new_calc_v
$LN238@new_calc_v:

; 2558 :               default: goto full_dim;  /* more than 2 */
; 2559 :             }
; 2560 :          }
; 2561 :        }
; 2562 :        e_id = get_next_tail_edge(e_id);

	mov	ecx, DWORD PTR _web+124
	mov	eax, edi
	shr	eax, 27					; 0000001bH
	and	edi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edi*4]

; 2563 :      } while ( !equal_element(start_e,e_id) );

	mov	ecx, DWORD PTR _start_e$90612[ebp]
	and	eax, 1
	mov	edi, DWORD PTR [edx+eax*4+32]
	mov	eax, edi
	or	eax, 134217728				; 08000000H
	or	ecx, 134217728				; 08000000H
	cmp	ecx, eax
	jne	$LL24@new_calc_v

; 2564 :        retval = kernel_basis_rows(&t,norm,1,SDIM);

	mov	ecx, DWORD PTR _web+616
	mov	edx, DWORD PTR _norm$GSCopy$[ebp]
	push	ecx
	push	1
	push	edx
	lea	eax, DWORD PTR _t$90610[ebp]
	push	eax
	call	_kernel_basis_rows
	add	esp, 16					; 00000010H
	pop	esi
	pop	edi
	mov	DWORD PTR _retval$[ebp], eax
	pop	ebx

; 2579 : } // end new_calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN192@new_calc_v:

; 2540 :          { retval = quadratic_edge_normal(v_id,e_id,norm);

	mov	edx, DWORD PTR _norm$GSCopy$[ebp]
	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	push	edx
	push	edi
	push	eax
	call	_quadratic_edge_normal
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi
	mov	DWORD PTR _retval$[ebp], eax
	pop	ebx

; 2579 : } // end new_calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN194@new_calc_v:

; 2544 :          { retval = lagrange_edge_normal(v_id,e_id,norm);

	mov	ecx, DWORD PTR _norm$GSCopy$[ebp]
	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
	push	ecx
	push	edi
	push	edx
	call	_lagrange_edge_normal
	add	esp, 12					; 0000000cH
	pop	esi
	pop	edi
	mov	DWORD PTR _retval$[ebp], eax
	pop	ebx

; 2579 : } // end new_calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN232@new_calc_v:

; 2545 :            goto ncn_exit; /* lazy; just use first triple */

	mov	esi, DWORD PTR _web+616
$full_dim$90487:

; 2571 :   
; 2572 : full_dim:
; 2573 :   for ( i = 0 ; i < SDIM ; i++ )

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN4@new_calc_v
	fld1
	mov	edi, DWORD PTR _norm$GSCopy$[ebp]
$LN6@new_calc_v:

; 2574 :   { for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN1@new_calc_v

; 2571 :   
; 2572 : full_dim:
; 2573 :   for ( i = 0 ; i < SDIM ; i++ )

	mov	eax, DWORD PTR [edi+edx*4]
$LN3@new_calc_v:

; 2575 :        norm[i][j] = 0.0;

	fldz
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR _web+616
	jl	SHORT $LN3@new_calc_v
$LN1@new_calc_v:

; 2576 :     norm[i][i] = 1.0;

	mov	eax, DWORD PTR [edi+edx*4]
	fst	QWORD PTR [eax+edx*8]
	mov	esi, DWORD PTR _web+616
	inc	edx
	cmp	edx, esi
	jl	SHORT $LN6@new_calc_v

; 2571 :   
; 2572 : full_dim:
; 2573 :   for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN4@new_calc_v:

; 2577 :   }
; 2578 :   return SDIM;

	mov	eax, esi
	pop	esi
	pop	edi
	pop	ebx

; 2579 : } // end new_calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@new_calc_v:

; 2469 :        goto tripletest;
; 2470 :      retval = lagrange_facet_normal(v_id,get_fe_facet(sidea),norm);

	mov	esi, DWORD PTR _norm$GSCopy$[ebp]
	push	esi
	push	edi
	call	_get_fe_facet
	mov	edi, DWORD PTR _v_id$GSCopy$[ebp]
	add	esp, 4
	push	eax
	push	edi
	call	_lagrange_facet_normal

; 2471 :      sideb = get_next_facet(sidea); 

	mov	ecx, DWORD PTR _sidea$[ebp]
	push	ecx
	mov	DWORD PTR _retval$[ebp], eax
	call	_get_next_facet
	add	esp, 16					; 00000010H

; 2472 :      if ( equal_id(sidea,sideb) ) goto ncn_exit;

	cmp	DWORD PTR _sidea$[ebp], eax
	je	$ncn_exit$90480

; 2473 :      sideb = inverse_id(sideb);

	xor	eax, 134217728				; 08000000H

; 2474 :      retval = lagrange_facet_normal(v_id,get_fe_facet(sideb),norm2);

	push	ebx
	push	eax
	call	_get_fe_facet
	add	esp, 4
	push	eax
	push	edi
	call	_lagrange_facet_normal
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _retval$[ebp], eax

; 2475 :      for ( i = 0 ; i < retval ; i++ )

	test	eax, eax
	jle	$ncn_exit$90480

; 2474 :      retval = lagrange_facet_normal(v_id,get_fe_facet(sideb),norm2);

	mov	edx, eax
	mov	edi, esi

; 2475 :      for ( i = 0 ; i < retval ; i++ )

	sub	ebx, esi
	mov	esi, DWORD PTR _web+616
	mov	DWORD PTR tv896[ebp], edx
	npad	5
$LL57@new_calc_v:

; 2476 :          for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN56@new_calc_v
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ebx+edi]
	sub	edx, eax
	npad	3
$LL54@new_calc_v:

; 2477 :              norm[i][j] += norm2[i][j];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fadd	QWORD PTR [eax]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	esi, DWORD PTR _web+616
	cmp	ecx, esi
	jl	SHORT $LL54@new_calc_v
$LN56@new_calc_v:

; 2475 :      for ( i = 0 ; i < retval ; i++ )

	add	edi, 4
	dec	DWORD PTR tv896[ebp]
	jne	SHORT $LL57@new_calc_v

; 2565 :    }
; 2566 :    goto ncn_exit;
; 2567 :   
; 2568 : ncn_exit:
; 2569 : 
; 2570 :   return retval;

	mov	eax, DWORD PTR _retval$[ebp]
	pop	esi
	pop	edi
	pop	ebx

; 2579 : } // end new_calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@new_calc_v:

; 2478 :      goto ncn_exit;
; 2479 :   }
; 2480 :   /* usual case of facet in N dim */
; 2481 :   /* if get here, know no triple lines */
; 2482 :   retval = 1; // dimension of normal
; 2483 :   for ( j = 0 ; j < SDIM ; j++ )

	fldz
	mov	edi, DWORD PTR _norm$GSCopy$[ebp]
	xor	edx, edx
	mov	DWORD PTR _retval$[ebp], 1
	test	esi, esi
	jle	SHORT $LN292@new_calc_v
$LN51@new_calc_v:

; 2484 :      for ( i = 0 ; i < SDIM ; i++ ) norm[j][i] = 0.0;

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN50@new_calc_v

; 2478 :      goto ncn_exit;
; 2479 :   }
; 2480 :   /* usual case of facet in N dim */
; 2481 :   /* if get here, know no triple lines */
; 2482 :   retval = 1; // dimension of normal
; 2483 :   for ( j = 0 ; j < SDIM ; j++ )

	mov	eax, DWORD PTR [edi+edx*4]
$LN48@new_calc_v:

; 2484 :      for ( i = 0 ; i < SDIM ; i++ ) norm[j][i] = 0.0;

	fst	QWORD PTR [eax]
	mov	esi, DWORD PTR _web+616
	inc	ecx
	add	eax, 8
	cmp	ecx, esi
	jl	SHORT $LN48@new_calc_v
$LN50@new_calc_v:

; 2478 :      goto ncn_exit;
; 2479 :   }
; 2480 :   /* usual case of facet in N dim */
; 2481 :   /* if get here, know no triple lines */
; 2482 :   retval = 1; // dimension of normal
; 2483 :   for ( j = 0 ; j < SDIM ; j++ )

	inc	edx
	cmp	edx, esi
	jl	SHORT $LN51@new_calc_v
$LN292@new_calc_v:

; 2485 : 
; 2486 :     fe = start_fe = get_vertex_first_facet(v_id);

	mov	eax, DWORD PTR _v_id$GSCopy$[ebp]
	fstp	ST(0)
	push	eax
	call	_get_vertex_first_facet
	mov	ebx, eax
	mov	eax, DWORD PTR _vattr$[ebp]
	and	eax, 8388608				; 00800000H
	mov	esi, ebx
	add	esp, 4
	or	esi, 134217728				; 08000000H
	mov	DWORD PTR tv1599[ebp], eax

; 2517 :        }
; 2518 : 
; 2519 :        /* go to next facet */
; 2520 :        fe = get_next_vertex_facet(v_id,fe);

	mov	DWORD PTR tv1601[ebp], esi
$LL45@new_calc_v:

; 2487 :     do
; 2488 :     {  f_id = get_fe_facet(fe);

	push	ebx
	call	_get_fe_facet

; 2489 :        if ( vattr & AXIAL_POINT )

	mov	edx, DWORD PTR tv1599[ebp]
	xor	ecx, ecx
	add	esp, 4
	or	edx, ecx
	je	SHORT $LN42@new_calc_v

; 2490 :        { get_fe_side(sidea,z);

	mov	edi, DWORD PTR _sidea$[ebp]
	lea	eax, DWORD PTR _z$[ebp]
	push	eax
	push	edi
	call	_get_fe_edge
	add	esp, 4
	push	eax
	call	_get_edge_side
	add	esp, 8

; 2491 :          get_fe_side(get_next_edge(sidea),y);

	lea	ecx, DWORD PTR _y$[ebp]
	push	ecx
	push	edi
	call	_get_next_edge
	push	eax
	call	_get_fe_edge
	add	esp, 8
	push	eax
	call	_get_edge_side

; 2492 :          cross_prod(y,z,fnorm[0]);

	mov	edx, DWORD PTR _fnorm$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _z$[ebp]
	push	ecx
	lea	edx, DWORD PTR _y$[ebp]
	push	edx
	call	_cross_prod

; 2493 :          retval = 1;
; 2494 :        }
; 2495 :        else

	mov	edi, DWORD PTR _norm$GSCopy$[ebp]
	add	esp, 20					; 00000014H
	mov	DWORD PTR _retval$[ebp], 1
	jmp	SHORT $LN39@new_calc_v
$LN42@new_calc_v:

; 2496 :        { 
; 2497 :          switch ( web.modeltype )

	mov	ecx, DWORD PTR _web+628
	dec	ecx
	je	SHORT $LN38@new_calc_v
	dec	ecx
	je	SHORT $LN37@new_calc_v
	dec	ecx
	jne	SHORT $LN39@new_calc_v

; 2504 :            case LAGRANGE: 
; 2505 :              retval = lagrange_facet_normal(v_id,f_id,fnorm);  

	mov	ecx, DWORD PTR _fnorm$[ebp]
	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
	push	ecx
	push	eax
	push	edx
	call	_lagrange_facet_normal
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _retval$[ebp], eax

; 2506 :              break;

	jmp	SHORT $LN39@new_calc_v
$LN37@new_calc_v:

; 2500 :               break;
; 2501 :            case QUADRATIC: 
; 2502 :              retval = quadratic_facet_normal(v_id,f_id,fnorm);

	mov	ecx, DWORD PTR _fnorm$[ebp]
	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
	push	ecx
	push	eax
	push	edx
	call	_quadratic_facet_normal
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _retval$[ebp], eax

; 2503 :              break;

	jmp	SHORT $LN39@new_calc_v
$LN38@new_calc_v:

; 2498 :          { case LINEAR: 
; 2499 :               get_facet_normal(f_id,fnorm[0]);

	mov	ecx, DWORD PTR _fnorm$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	eax
	call	_get_facet_normal
	add	esp, 8
$LN39@new_calc_v:

; 2507 :          }
; 2508 :        }
; 2509 :        if ( !equal_element(start_fe,fe) && SDIM_dot(norm[0],fnorm[0]) < 0 )

	cmp	DWORD PTR tv1601[ebp], esi
	je	SHORT $LN35@new_calc_v
	mov	eax, DWORD PTR _web+616
	mov	ecx, DWORD PTR _fnorm$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edi]
	push	edx
	push	eax
	call	_dot
	fcomp	QWORD PTR __real@0000000000000000
	add	esp, 12					; 0000000cH
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN35@new_calc_v

; 2510 :        { // orientation reversed relative to normal so far
; 2511 :          for ( i = 0 ; i < SDIM ; i++ ) 

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN28@new_calc_v
	mov	ecx, DWORD PTR _fnorm$[ebp]
	mov	edx, DWORD PTR [ecx]
$LL34@new_calc_v:
	mov	ecx, DWORD PTR [edi]

; 2512 :            norm[0][i] -= fnorm[0][i];

	fld	QWORD PTR [ecx+eax*8]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fsub	QWORD PTR [edx+eax*8]
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL34@new_calc_v

; 2513 :        }
; 2514 :        else

	jmp	SHORT $LN28@new_calc_v
$LN35@new_calc_v:

; 2515 :        { for ( i = 0 ; i < SDIM ; i++ ) 

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN28@new_calc_v
	mov	edx, DWORD PTR _fnorm$[ebp]
	mov	edx, DWORD PTR [edx]
	npad	1
$LL30@new_calc_v:
	mov	ecx, DWORD PTR [edi]

; 2516 :            norm[0][i] += fnorm[0][i];

	fld	QWORD PTR [edx+eax*8]
	fadd	QWORD PTR [ecx+eax*8]
	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	eax
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LL30@new_calc_v
$LN28@new_calc_v:

; 2517 :        }
; 2518 : 
; 2519 :        /* go to next facet */
; 2520 :        fe = get_next_vertex_facet(v_id,fe);

	mov	edx, DWORD PTR _v_id$GSCopy$[ebp]
	push	ebx
	push	edx
	call	_get_next_vertex_facet
	mov	ebx, eax

; 2521 :      } while ( !equal_element(fe,start_fe) );   

	mov	esi, ebx
	or	esi, 134217728				; 08000000H
	add	esp, 8
	cmp	esi, DWORD PTR tv1601[ebp]
	jne	$LL45@new_calc_v
$ncn_exit$90480:

; 2579 : } // end new_calc_vertex_normal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, DWORD PTR _retval$[ebp]
	pop	esi
	pop	edi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_new_calc_vertex_normal ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_begin_normal_motion
; Function compile flags: /Ogtp
;	COMDAT _begin_normal_motion
_TEXT	SEGMENT
_normalsqXvS$ = -320					; size = 24
_normals$ = -296					; size = 4
_normalsxJ$ = -292					; size = 288
__$ArrayPad$ = -4					; size = 4
_begin_normal_motion PROC				; COMDAT

; 1693 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 320				; 00000140H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1694 :   vertex_id v_id;
; 1695 :   facetedge_id fe;
; 1696 :   MAT2D(normals,MAXCOORD,MAXCOORD);

	push	6
	push	6
	lea	eax, DWORD PTR _normalsxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _normalsqXvS$[ebp]
	push	ecx
	call	_mat2d_setup
	mov	DWORD PTR _normals$[ebp], eax

; 1697 :   int i;
; 1698 :   pt_type *vn;
; 1699 :   int normcount;
; 1700 :  
; 1701 :   if ( vertex_normals != NULL ) myfree((char*)vertex_normals); 

	mov	eax, DWORD PTR _vertex_normals
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN11@begin_norm
	push	eax
	call	_myfree
	add	esp, 4
$LN11@begin_norm:

; 1702 :   vertex_normals = (pt_type *)mycalloc(
; 1703 :      web.skel[VERTEX].max_ord+1,sizeof(pt_type));

	mov	edx, DWORD PTR _web+68
	push	esi
	push	edi
	push	1703					; 000006a7H
	push	OFFSET ??_C@_09GDMJAJJP@UTILITY?4C?$AA@
	inc	edx
	push	48					; 00000030H
	push	edx
	call	_kb_calloc

; 1704 : 
; 1705 :   FOR_ALL_VERTICES(v_id)

	mov	esi, DWORD PTR _web+48
	mov	edi, esi
	shr	edi, 28					; 0000001cH
	add	esp, 16					; 00000010H
	and	edi, 1
	mov	DWORD PTR _vertex_normals, eax
	je	$LN20@begin_norm
	push	ebx
	npad	3
$LL10@begin_norm:
	mov	eax, DWORD PTR _web+12
	mov	ebx, esi
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	ecx, ecx
	or	eax, ecx
	je	$LN9@begin_norm

; 1706 :   { REAL mag;
; 1707 :     fe = get_vertex_fe(v_id);

	push	esi
	call	_get_vertex_fe
	add	esp, 4

; 1708 :     if ( !valid_id(fe) ) continue;

	test	eax, 268435456				; 10000000H
	je	$LN9@begin_norm

; 1709 :     normcount = new_calc_vertex_normal(v_id,normals);

	mov	ecx, DWORD PTR _normals$[ebp]
	push	ecx
	push	esi
	call	_new_calc_vertex_normal

; 1710 :     project_vertex_normals(v_id,normals,normcount);

	mov	edx, DWORD PTR _normals$[ebp]
	push	eax
	push	edx
	push	esi
	call	_project_vertex_normals
	add	esp, 20					; 00000014H

; 1711 :     vn = vertex_normals + loc_ordinal(v_id);

	test	edi, edi
	je	SHORT $LN14@begin_norm
	mov	esi, ebx
	jmp	SHORT $LN15@begin_norm
$LN14@begin_norm:
	or	esi, -1
$LN15@begin_norm:

; 1712 :     mag = sqrt(dot(normals[0],normals[0],SDIM));

	mov	ecx, DWORD PTR _web+616
	mov	edi, DWORD PTR _normals$[ebp]
	mov	eax, DWORD PTR [edi]
	push	ecx
	lea	esi, DWORD PTR [esi+esi*2]
	push	eax
	shl	esi, 4
	add	esi, DWORD PTR _vertex_normals
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 1713 :     if ( mag != 0.0 )

	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN28@begin_norm

; 1714 :     for ( i = 0 ; i < SDIM ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _web+616, eax
	jle	SHORT $LN28@begin_norm
$LN3@begin_norm:

; 1715 :       (*vn)[i] = normals[0][i]/mag;

	mov	edx, DWORD PTR [edi]
	fld	QWORD PTR [edx+eax*8]
	inc	eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [esi+eax*8-8]
	cmp	eax, DWORD PTR _web+616
	jl	SHORT $LN3@begin_norm
$LN28@begin_norm:

; 1714 :     for ( i = 0 ; i < SDIM ; i++ )

	fstp	ST(0)
$LN9@begin_norm:

; 1704 : 
; 1705 :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR _web+12
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	esi, DWORD PTR [ecx]
	mov	edi, esi
	shr	edi, 28					; 0000001cH
	and	edi, 1
	jne	$LL10@begin_norm
	pop	ebx
$LN20@begin_norm:

; 1716 :   }
; 1717 :   normal_motion_flag = 1;
; 1718 : } // end begin_normal_motion()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	mov	DWORD PTR _normal_motion_flag, 1
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_begin_normal_motion ENDP
_TEXT	ENDS
END
