; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\MINDEG.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_supercount:DWORD
COMM	_superheap:DWORD
COMM	_xJL:DWORD
COMM	_K:DWORD
COMM	_xIL:DWORD
COMM	_SSS:DWORD
_minabsorb DD	02H
_DATA	ENDS
PUBLIC	_get_edge_tailv
EXTRN	_dymem:DWORD
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@FDJNBGIM@Elimcount?5?$CFd?5of?5?$CFd?$DL?5?5regions?5?$CFd?6@ ; `string'
PUBLIC	??_C@_08PPFDFAAI@MINDEG?4C?$AA@			; `string'
PUBLIC	_show_mindeg_state
EXTRN	_temp_free:PROC
EXTRN	_prompt:PROC
EXTRN	_errmsg:BYTE
EXTRN	_sprintf:PROC
EXTRN	_msg:DWORD
EXTRN	_update_display:PROC
EXTRN	_vhead:DWORD
EXTRN	_vhead_attr:DWORD
EXTRN	_kb_temp_calloc:PROC
_BSS	SEGMENT
_elim_count DD	01H DUP (?)
_slist	DD	01H DUP (?)
_superstart DD	01H DUP (?)
_regionstart DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CB@FDJNBGIM@Elimcount?5?$CFd?5of?5?$CFd?$DL?5?5regions?5?$CFd?6@
CONST	SEGMENT
??_C@_0CB@FDJNBGIM@Elimcount?5?$CFd?5of?5?$CFd?$DL?5?5regions?5?$CFd?6@ DB 'E'
	DB	'limcount %d of %d;  regions %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
CONST	SEGMENT
??_C@_08PPFDFAAI@MINDEG?4C?$AA@ DB 'MINDEG.C', 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\mindeg.c
CONST	ENDS
;	COMDAT _show_mindeg_state
_TEXT	SEGMENT
tv403 = -12						; size = 4
_rcount$ = -8						; size = 4
_marks$ = -4						; size = 4
_S$ = 8							; size = 4
_show_mindeg_state PROC					; COMDAT

; 154  : { char *marks;  /* unelim node numbers */

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 155  :   edge_id e_id;
; 156  :   int j;
; 157  :   int rcount;
; 158  :   struct region *r;
; 159  :   int rnum;
; 160  :   int snum;
; 161  :   struct supernode *s;
; 162  :   
; 163  :   /* count regions */
; 164  :   for ( rnum = regionstart, rcount=0 ; rnum >= 0 ; rnum = r->next )

	mov	eax, DWORD PTR _regionstart
	push	ebx
	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	xor	edx, edx
	push	edi
	mov	DWORD PTR _rcount$[ebp], edx
	test	eax, eax
	js	SHORT $LN14@show_minde
	mov	ecx, DWORD PTR [esi+92]
	npad	3
$LL16@show_minde:
	mov	eax, DWORD PTR [ecx+eax*4+36]

; 165  :   { r = REG(rnum);
; 166  :     rcount++;

	inc	edx
	test	eax, eax
	jns	SHORT $LL16@show_minde
	mov	DWORD PTR _rcount$[ebp], edx
$LN14@show_minde:

; 167  :   }
; 168  : 
; 169  :   /* figure out which vertices are not eliminated */
; 170  :   marks = temp_calloc(S->N,1);

	mov	eax, DWORD PTR [esi+4]
	push	170					; 000000aaH
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	push	1
	push	eax
	call	_kb_temp_calloc

; 171  :   for ( snum = superstart ; snum >= 0 ; snum = s->next )

	mov	ecx, DWORD PTR _superstart
	add	esp, 16					; 00000010H
	mov	ebx, eax
	mov	DWORD PTR _marks$[ebp], ebx
	test	ecx, ecx
	js	SHORT $LN11@show_minde
$LL13@show_minde:

; 172  :   { s = slist + snum; 

	imul	ecx, 44					; 0000002cH
	add	ecx, DWORD PTR _slist

; 173  :     for ( j = 0 ; j < s->vercount ; j++ )

	xor	eax, eax
	cmp	DWORD PTR [ecx+24], eax
	jle	SHORT $LN12@show_minde
$LL10@show_minde:

; 174  :       marks[INT(s->verlist)[j]] = 1;

	mov	edx, DWORD PTR [ecx+20]
	mov	edi, DWORD PTR [esi+92]
	add	edx, eax
	mov	edx, DWORD PTR [edi+edx*4]
	inc	eax
	mov	BYTE PTR [ebx+edx], 1
	cmp	eax, DWORD PTR [ecx+24]
	jl	SHORT $LL10@show_minde
$LN12@show_minde:

; 171  :   for ( snum = superstart ; snum >= 0 ; snum = s->next )

	mov	ecx, DWORD PTR [ecx+36]
	test	ecx, ecx
	jns	SHORT $LL13@show_minde
$LN11@show_minde:

; 175  :   }
; 176  :   FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+160
	test	ecx, 268435456				; 10000000H
	je	$LN5@show_minde
$LL37@show_minde:
	mov	eax, DWORD PTR _web+124
	mov	edx, ecx
	and	edx, 134217727				; 07ffffffH
	add	edx, edx
	add	edx, edx
	mov	edi, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [edi+8]
	and	eax, 1
	xor	esi, esi
	or	eax, esi
	je	$LN6@show_minde

; 177  :   { struct hess_verlist *vh = get_vertex_vhead(get_edge_headv(e_id));

	mov	esi, DWORD PTR _dymem
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	mov	DWORD PTR tv403[ebp], ecx
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+esi+304]
	je	SHORT $LN20@show_minde
	mov	eax, DWORD PTR [ecx+edi]
	add	ecx, edi
	jmp	SHORT $LN19@show_minde
$LN20@show_minde:
	mov	eax, DWORD PTR _web+636
	add	ecx, edi
	mov	eax, DWORD PTR [ecx+eax*4]
$LN19@show_minde:
	mov	ebx, DWORD PTR _vhead_attr
	imul	ebx, 240				; 000000f0H
	add	ebx, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ebx+esi+64]
	mov	ebx, DWORD PTR _web+12
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	eax, DWORD PTR [esi+eax]
	shl	eax, 5
	add	eax, DWORD PTR _vhead

; 178  :     struct hess_verlist *vt = get_vertex_vhead(get_edge_tailv(e_id));

	cmp	DWORD PTR tv403[ebp], 0
	je	SHORT $LN24@show_minde
	mov	ebx, DWORD PTR _web+636
	mov	ecx, DWORD PTR [ecx+ebx*4]
	jmp	SHORT $LN38@show_minde
$LN24@show_minde:
	mov	ecx, DWORD PTR [ecx]
$LN38@show_minde:
	mov	ebx, DWORD PTR _marks$[ebp]

; 179  :     if ( marks[vh->rownum] && marks[vt->rownum] )

	mov	eax, DWORD PTR [eax+12]
	cmp	BYTE PTR [ebx+eax], 0
	je	SHORT $LN35@show_minde

; 178  :     struct hess_verlist *vt = get_vertex_vhead(get_edge_tailv(e_id));

	mov	eax, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [esi+ecx]

; 179  :     if ( marks[vh->rownum] && marks[vt->rownum] )

	mov	ecx, DWORD PTR _vhead
	shl	eax, 5
	mov	eax, DWORD PTR [eax+ecx+12]
	cmp	BYTE PTR [ebx+eax], 0
	je	SHORT $LN35@show_minde

; 180  :       set_edge_color(e_id,RED);

	mov	ecx, 4
	mov	WORD PTR [edi+56], cx
	jmp	SHORT $LN6@show_minde
$LN35@show_minde:

; 181  :     else set_edge_color(e_id,WHITE);

	mov	eax, 15					; 0000000fH
	mov	WORD PTR [edi+56], ax
$LN6@show_minde:

; 175  :   }
; 176  :   FOR_ALL_EDGES(e_id)

	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR [edx]
	test	ecx, 268435456				; 10000000H
	jne	$LL37@show_minde
	mov	esi, DWORD PTR _S$[ebp]
$LN5@show_minde:

; 182  :   }
; 183  :   update_display();

	call	_update_display

; 184  :   sprintf(msg,"Elimcount %d of %d;  regions %d\n",elim_count,S->N,rcount);

	mov	eax, DWORD PTR _rcount$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _elim_count
	push	eax
	mov	eax, DWORD PTR _msg
	push	ecx
	push	edx
	push	OFFSET ??_C@_0CB@FDJNBGIM@Elimcount?5?$CFd?5of?5?$CFd?$DL?5?5regions?5?$CFd?6@
	push	eax
	call	_sprintf

; 185  :   prompt(msg,errmsg,2000);

	mov	ecx, DWORD PTR _msg
	push	2000					; 000007d0H
	push	OFFSET _errmsg
	push	ecx
	call	_prompt

; 186  :   temp_free(marks);

	push	ebx
	call	_temp_free
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi
	pop	ebx

; 187  : } // end show_mindeg_state()

	mov	esp, ebp
	pop	ebp
	ret	0
_show_mindeg_state ENDP
_TEXT	ENDS
PUBLIC	__real@bff8000000000000
PUBLIC	_md_alloc
EXTRN	_kb_temp_realloc:PROC
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@bff8000000000000
CONST	SEGMENT
__real@bff8000000000000 DQ 0bff8000000000000r	; -1.5
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _md_alloc
_TEXT	SEGMENT
_S$ = 8							; size = 4
tv171 = 12						; size = 4
_bytes$ = 12						; size = 4
_md_alloc PROC						; COMDAT

; 203  : { int spot; 

	push	ebp
	mov	ebp, esp
	push	ebx

; 204  :   int size; /* in ints */
; 205  : 
; 206  :   size = (bytes+3)/sizeof(int);

	mov	ebx, DWORD PTR _bytes$[ebp]
	push	esi
	push	edi

; 207  :   if ( S->ISP[0] + size + 1 > S->NSP )

	mov	edi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [edi+92]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edi+88]
	lea	esi, DWORD PTR [ebx+3]
	shr	esi, 2
	lea	edx, DWORD PTR [esi+eax+1]
	mov	DWORD PTR tv171[ebp], ecx
	cmp	edx, ecx
	jle	SHORT $LN1@md_alloc

; 208  :   { int newsize = (int)(1.5*S->NSP)+bytes;

	fild	DWORD PTR tv171[ebp]
	fmul	QWORD PTR __real@bff8000000000000
	call	__ftol2_sse
	sub	ebx, eax

; 209  :     S->ISP = (int*)temp_realloc((char*)S->ISP,newsize*sizeof(int));

	push	209					; 000000d1H
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	lea	eax, DWORD PTR [ebx*4]
	push	eax
	mov	eax, DWORD PTR [edi+92]
	push	eax
	call	_kb_temp_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR [edi+92], eax

; 210  :     S->NSP = newsize;

	mov	DWORD PTR [edi+88], ebx
$LN1@md_alloc:

; 211  :   }
; 212  :   spot = S->ISP[0] + 1;

	mov	edi, DWORD PTR [edi+92]
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+1]

; 213  :   S->ISP[0] += size;

	add	ecx, esi
	mov	DWORD PTR [edi], ecx
	pop	edi
	pop	esi
	pop	ebx

; 214  :   return spot;
; 215  : } // end md_alloc()

	pop	ebp
	ret	0
_md_alloc ENDP
_TEXT	ENDS
PUBLIC	_region_alloc
_BSS	SEGMENT
_last_region DD	01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _region_alloc
_TEXT	SEGMENT
_S$ = 8							; size = 4
_region_alloc PROC					; COMDAT

; 225  : { int spot;

	push	ebp
	mov	ebp, esp
	push	esi

; 226  :   struct region *r;
; 227  : 
; 228  :   spot = md_alloc(S,sizeof(struct region));

	mov	esi, DWORD PTR _S$[ebp]
	push	44					; 0000002cH
	push	esi
	call	_md_alloc

; 229  :   if ( last_region >= 0 ) REG(last_region)->next = spot;

	mov	edx, DWORD PTR _last_region
	add	esp, 8
	test	edx, edx
	js	SHORT $LN2@region_all
	mov	ecx, DWORD PTR [esi+92]
	mov	DWORD PTR [ecx+edx*4+36], eax
	jmp	SHORT $LN1@region_all
$LN2@region_all:

; 230  :   else regionstart = spot;

	mov	DWORD PTR _regionstart, eax
$LN1@region_all:

; 231  :   r = REG(spot);

	mov	ecx, DWORD PTR [esi+92]
	lea	ecx, DWORD PTR [ecx+eax*4]

; 232  :   r->prev = last_region;

	mov	DWORD PTR [ecx+40], edx

; 233  :   r->next = -1;

	or	edx, -1
	mov	DWORD PTR [ecx+36], edx

; 234  :   r->merged = spot;  /* self */

	mov	DWORD PTR [ecx+24], eax

; 235  :   r->son = -1;

	mov	DWORD PTR [ecx+28], edx

; 236  :   last_region = spot;

	mov	DWORD PTR _last_region, eax
	pop	esi

; 237  :   return spot;
; 238  : } // end region_alloc()

	pop	ebp
	ret	0
_region_alloc ENDP
_TEXT	ENDS
PUBLIC	_md_vertex_setup
EXTRN	_gen_quant_list:DWORD
EXTRN	_bhead_attr:DWORD
EXTRN	_everything_quantities_flag:DWORD
EXTRN	_augmented_hessian_mode:DWORD
EXTRN	_optparam:BYTE
EXTRN	_optparamcount:DWORD
_BSS	SEGMENT
_vlist	DD	01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _md_vertex_setup
_TEXT	SEGMENT
_S$ = 8							; size = 4
_md_vertex_setup PROC					; COMDAT

; 250  : { int i,k;

	push	ebp
	mov	ebp, esp

; 251  :   struct hess_verlist *vh;
; 252  :   vertex_id v_id;
; 253  :   body_id b_id;
; 254  :   
; 255  :   vlist = (struct md_vertex *)temp_calloc(S->N,sizeof(struct md_vertex));

	mov	eax, DWORD PTR _S$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ebx
	push	esi
	push	edi
	push	255					; 000000ffH
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	push	12					; 0000000cH
	push	ecx
	call	_kb_temp_calloc

; 256  : 
; 257  :   /* set up reverse indexing from vlist to vheads */
; 258  :   FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+48
	mov	edx, DWORD PTR _vhead
	add	esp, 16					; 00000010H
	mov	DWORD PTR _vlist, eax
	test	ecx, 268435456				; 10000000H
	je	$LN22@md_vertex_
	mov	ebx, DWORD PTR _web+12
$LL24@md_vertex_:
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	lea	eax, DWORD PTR [ecx+ecx]
	mov	esi, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [esi+8]
	and	ecx, 1
	xor	edi, edi
	or	ecx, edi
	je	SHORT $LN23@md_vertex_

; 259  :   { vh = get_vertex_vhead(v_id);

	mov	ecx, DWORD PTR _vhead_attr
	mov	edi, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+edi+64]
	mov	ecx, DWORD PTR [esi+ecx]
	shl	ecx, 5
	add	ecx, edx

; 260  :      for ( k = 0 ; k < vh->freedom ; k++ )

	xor	esi, esi
	cmp	DWORD PTR [ecx+8], esi
	jle	SHORT $LN23@md_vertex_
	npad	7
$LL19@md_vertex_:

; 261  :        vlist[vh->rownum+k].newspot = vh - vhead;

	mov	ebx, DWORD PTR _vlist
	mov	edi, ecx
	sub	edi, edx
	mov	edx, DWORD PTR [ecx+12]
	add	edx, esi
	sar	edi, 5
	lea	edx, DWORD PTR [edx+edx*2]
	mov	DWORD PTR [ebx+edx*4+8], edi
	mov	edx, DWORD PTR _vhead
	inc	esi
	cmp	esi, DWORD PTR [ecx+8]
	jl	SHORT $LL19@md_vertex_

; 260  :      for ( k = 0 ; k < vh->freedom ; k++ )

	mov	ebx, DWORD PTR _web+12
$LN23@md_vertex_:

; 256  : 
; 257  :   /* set up reverse indexing from vlist to vheads */
; 258  :   FOR_ALL_VERTICES(v_id)

	mov	eax, DWORD PTR [eax+ebx]
	mov	ecx, DWORD PTR [eax]
	test	ecx, 268435456				; 10000000H
	jne	$LL24@md_vertex_
	mov	eax, DWORD PTR _vlist
$LN22@md_vertex_:

; 262  :   }
; 263  :   for ( i = 0 ; i < optparamcount ; i++ )

	xor	esi, esi
	cmp	DWORD PTR _optparamcount, esi
	jle	SHORT $LN14@md_vertex_
	mov	edi, OFFSET _optparam+52
$LL39@md_vertex_:

; 264  :   { vh = vhead + optparam[i].vhead_index;

	mov	ecx, DWORD PTR [edi]
	shl	ecx, 5
	add	ecx, edx

; 265  :     vlist[vh->rownum].newspot = vh - vhead;

	mov	ebx, ecx
	mov	ecx, DWORD PTR [ecx+12]
	sub	ebx, edx
	sar	ebx, 5
	lea	ecx, DWORD PTR [ecx+ecx*2]
	mov	DWORD PTR [eax+ecx*4+8], ebx
	mov	edx, DWORD PTR _vhead
	inc	esi
	add	edi, 56					; 00000038H
	cmp	esi, DWORD PTR _optparamcount
	jl	SHORT $LL39@md_vertex_
$LN14@md_vertex_:

; 266  :   }
; 267  :   if ( augmented_hessian_mode )

	cmp	DWORD PTR _augmented_hessian_mode, 0
	je	$LN3@md_vertex_

; 268  :   { 
; 269  :     if ( !everything_quantities_flag ) /* bodies */

	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	$LN9@md_vertex_

; 270  :     { FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR _web+384
	test	ecx, 268435456				; 10000000H
	je	$LN9@md_vertex_
	mov	eax, DWORD PTR _web+348
	npad	5
$LL40@md_vertex_:
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	lea	ebx, DWORD PTR [ecx+ecx]
	mov	esi, DWORD PTR [ebx+eax]
	mov	ecx, DWORD PTR [esi+8]
	and	ecx, 1
	xor	edi, edi
	or	ecx, edi
	je	SHORT $LN10@md_vertex_

; 271  :       { vh = get_body_vhead(b_id);

	mov	ecx, DWORD PTR _bhead_attr
	mov	edi, DWORD PTR _dymem
	imul	ecx, 240				; 000000f0H
	add	ecx, DWORD PTR _web+440
	mov	ecx, DWORD PTR [ecx+edi+64]
	mov	ecx, DWORD PTR [esi+ecx]
	shl	ecx, 5
	add	ecx, edx

; 272  :         if ( vh->freedom )

	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN10@md_vertex_

; 273  :           vlist[vh->rownum].newspot = vh - vhead;

	mov	eax, ecx
	mov	ecx, DWORD PTR [ecx+12]
	sub	eax, edx
	mov	edx, DWORD PTR _vlist
	sar	eax, 5
	lea	ecx, DWORD PTR [ecx+ecx*2]
	mov	DWORD PTR [edx+ecx*4+8], eax
	mov	eax, DWORD PTR _web+348
	mov	edx, DWORD PTR _vhead
$LN10@md_vertex_:

; 270  :     { FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR [ebx+eax]
	mov	ecx, DWORD PTR [ecx]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL40@md_vertex_
	mov	eax, DWORD PTR _vlist
$LN9@md_vertex_:

; 274  :       }
; 275  :     }
; 276  :     for ( i=0 ; i < gen_quant_count ; i++ )

	xor	ebx, ebx
	cmp	DWORD PTR _web+5528, ebx
	jle	SHORT $LN3@md_vertex_
	mov	edi, DWORD PTR _gen_quant_list
	xor	esi, esi
	npad	6
$LL41@md_vertex_:

; 277  :     { 
; 278  :       if ( GEN_QUANT(i)->flags & Q_DELETED ) continue;

	test	DWORD PTR [esi+edi+136], 524288		; 00080000H
	jne	SHORT $LN4@md_vertex_

; 279  :       vh = vhead + GEN_QUANT(i)->vhead_index;

	mov	ecx, DWORD PTR [esi+edi+236]
	shl	ecx, 5
	add	ecx, edx

; 280  :       if ( vh->freedom )

	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN4@md_vertex_

; 281  :         vlist[vh->rownum].newspot =  vh - vhead;

	mov	edi, ecx
	mov	ecx, DWORD PTR [ecx+12]
	sub	edi, edx
	sar	edi, 5
	lea	edx, DWORD PTR [ecx+ecx*2]
	mov	DWORD PTR [eax+edx*4+8], edi
	mov	edx, DWORD PTR _vhead
	mov	edi, DWORD PTR _gen_quant_list
$LN4@md_vertex_:

; 274  :       }
; 275  :     }
; 276  :     for ( i=0 ; i < gen_quant_count ; i++ )

	inc	ebx
	add	esi, 368				; 00000170H
	cmp	ebx, DWORD PTR _web+5528
	jl	SHORT $LL41@md_vertex_
$LN3@md_vertex_:
	pop	edi
	pop	esi
	pop	ebx

; 282  :     }
; 283  :   }
; 284  : 
; 285  : } // end md_vertex_setup()

	pop	ebp
	ret	0
_md_vertex_setup ENDP
_TEXT	ENDS
PUBLIC	_md_region_string
EXTRN	_vhead_count:DWORD
; Function compile flags: /Ogtp
;	COMDAT _md_region_string
_TEXT	SEGMENT
_row$89357 = -32					; size = 4
_row$89332 = -32					; size = 4
_row$89319 = -32					; size = 4
_row$89306 = -32					; size = 4
_newspot$ = -32						; size = 4
tv1147 = -28						; size = 4
_p$ = -28						; size = 4
tv1074 = -24						; size = 4
tv1045 = -24						; size = 4
tv438 = -24						; size = 4
_s1$89285 = -24						; size = 4
tv1527 = -20						; size = 4
tv1503 = -20						; size = 4
_q$ = -16						; size = 4
_entrymark$ = -12					; size = 4
tv963 = -8						; size = 4
tv1411 = -4						; size = 4
tv1370 = -4						; size = 4
tv1329 = -4						; size = 4
_s2$89286 = -4						; size = 4
_j$ = -4						; size = 4
tv952 = 8						; size = 4
_k$ = 8							; size = 4
_S$ = 8							; size = 4
_md_region_string PROC					; COMDAT

; 295  : { int j,k,p,q;

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi

; 296  :   size_t n1,n2;
; 297  :   int rcount;
; 298  :   struct region *r;
; 299  :   char *entrymark;  /* for tagging done entries of A */
; 300  :   int size;
; 301  :   int newspot,spot;  /* index into workspace */
; 302  :   size_t n1_end;
; 303  : 
; 304  :   entrymark = temp_calloc(S->IA[S->N],sizeof(char));

	mov	esi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edi
	push	304					; 00000130H
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	push	1
	push	edx
	call	_kb_temp_calloc

; 305  : 
; 306  :   /* estimate regions needed */
; 307  :   regionstart = md_alloc(S,0);      /* since may need realloc for vertices */

	push	0
	push	esi
	mov	DWORD PTR _entrymark$[ebp], eax
	call	_md_alloc

; 308  :   last_region = -1;
; 309  :   for ( j = 0 ; j < vhead_count ; j++ ) vhead[j].flags &= ~HV_DONE;

	xor	ecx, ecx
	add	esp, 24					; 00000018H
	mov	DWORD PTR _regionstart, eax
	mov	DWORD PTR _last_region, -1
	cmp	DWORD PTR _vhead_count, ecx
	jle	SHORT $LN71@md_region_

; 296  :   size_t n1,n2;
; 297  :   int rcount;
; 298  :   struct region *r;
; 299  :   char *entrymark;  /* for tagging done entries of A */
; 300  :   int size;
; 301  :   int newspot,spot;  /* index into workspace */
; 302  :   size_t n1_end;
; 303  : 
; 304  :   entrymark = temp_calloc(S->IA[S->N],sizeof(char));

	xor	eax, eax
	mov	edi, -2					; fffffffeH
$LL73@md_region_:

; 308  :   last_region = -1;
; 309  :   for ( j = 0 ; j < vhead_count ; j++ ) vhead[j].flags &= ~HV_DONE;

	mov	edx, DWORD PTR _vhead
	and	DWORD PTR [eax+edx+4], edi
	inc	ecx
	add	eax, 32					; 00000020H
	cmp	ecx, DWORD PTR _vhead_count
	jl	SHORT $LL73@md_region_
$LN71@md_region_:

; 310  : 
; 311  :   /* fill in one region per edge detected in array */
; 312  :   rcount = 0;
; 313  :   for ( p = 0 ; p < S->N ; p++ )

	mov	eax, DWORD PTR _vhead
	xor	edi, edi
	mov	DWORD PTR _p$[ebp], edi
	cmp	DWORD PTR [esi+4], edi
	jle	$LN68@md_region_
	mov	DWORD PTR tv1503[ebp], 8
$LL70@md_region_:
	mov	ecx, DWORD PTR [esi+52]
	lea	edx, DWORD PTR [ecx+edi*4]

; 314  :   { for ( q =  S->IA[p]-A_OFF ; q < S->IA[p+1]-A_OFF ; q++ )

	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	dec	ecx
	dec	edx
	mov	DWORD PTR _q$[ebp], ecx
	cmp	ecx, edx
	jge	$LN69@md_region_
	npad	3
$LL151@md_region_:

; 315  :     { int s1,s2;
; 316  : 
; 317  :       if ( entrymark[q] ) continue;

	mov	edx, DWORD PTR _entrymark$[ebp]
	cmp	BYTE PTR [ecx+edx], 0
	jne	$LN66@md_region_

; 318  :       n1 = vlist[p].newspot;

	mov	ebx, DWORD PTR _vlist
	mov	edx, DWORD PTR tv1503[ebp]
	mov	edi, DWORD PTR [edx+ebx]

; 319  :       n2 = vlist[S->JA[q]-A_OFF].newspot;

	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+ecx*4]
	lea	edx, DWORD PTR [edx+edx*2]
	mov	ebx, DWORD PTR [ebx+edx*4-4]

; 320  :       if ( n1 == n2 ) continue;  /* don't do just one vertex here */

	cmp	edi, ebx
	je	$LN66@md_region_

; 321  : 
; 322  :       if ( n1 > n2 ) { size_t tmp = n1; n1 = n2; n2 = tmp; }

	jbe	SHORT $LN62@md_region_
	mov	eax, edi
	mov	edi, ebx
	mov	ebx, eax
$LN62@md_region_:

; 323  : 
; 324  :       /* need new region */
; 325  :       spot = region_alloc(S);

	push	esi
	call	_region_alloc

; 326  :       r = REG(spot);

	lea	ecx, DWORD PTR [eax*4]
	mov	eax, DWORD PTR [esi+92]
	add	eax, ecx
	mov	DWORD PTR tv952[ebp], ecx

; 327  : 
; 328  :       /* find its supernodes */
; 329  :       s1 = vlist[vhead[n1].rownum].supernode;

	mov	ecx, DWORD PTR _vhead
	shl	edi, 5
	mov	ecx, DWORD PTR [edi+ecx+12]
	lea	edx, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR _vlist
	mov	edx, DWORD PTR [ecx+edx*4]

; 330  :       s2 = vlist[vhead[n2].rownum].supernode;

	mov	ecx, DWORD PTR _vhead
	shl	ebx, 5
	mov	ecx, DWORD PTR [ebx+ecx+12]
	mov	DWORD PTR tv963[ebp], ebx
	mov	ebx, DWORD PTR _vlist
	lea	ecx, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR [ebx+ecx*4]

; 331  :       r->supercount = (s1==s2) ? 1 : 2;

	xor	ebx, ebx
	cmp	edx, ecx
	setne	bl
	mov	DWORD PTR _s2$89286[ebp], ecx
	mov	DWORD PTR _s1$89285[ebp], edx
	lea	ecx, DWORD PTR [ebx+1]

; 332  :       newspot = md_alloc(S,r->supercount*sizeof(int));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	push	esi
	mov	DWORD PTR [eax+12], ecx
	call	_md_alloc

; 333  :       r = REG(spot);  /* in case of reallocation of workspace */

	mov	ecx, DWORD PTR [esi+92]
	add	ecx, DWORD PTR tv952[ebp]

; 334  :       r->superlist = newspot;
; 335  :       INT(r->superlist)[0] = s1;

	mov	edx, DWORD PTR _s1$89285[ebp]
	mov	DWORD PTR [ecx+16], eax
	mov	ebx, DWORD PTR [esi+92]
	mov	DWORD PTR [ebx+eax*4], edx

; 336  :       if ( s1 != s2 )

	mov	eax, DWORD PTR _s2$89286[ebp]
	add	esp, 12					; 0000000cH
	cmp	edx, eax
	je	SHORT $LN61@md_region_

; 337  :         INT(r->superlist)[1] = s2;

	mov	edx, DWORD PTR [ecx+16]
	mov	ebx, DWORD PTR [esi+92]
	mov	DWORD PTR [ebx+edx*4+4], eax
$LN61@md_region_:

; 338  : 
; 339  :       size = vhead[n1].freedom + vhead[n2].freedom;

	mov	edx, DWORD PTR _vhead
	mov	ebx, DWORD PTR tv963[ebp]
	mov	eax, DWORD PTR [ebx+edx+8]
	add	eax, DWORD PTR [edi+edx+8]

; 340  :       r->size = r->vercount = size;

	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+32], eax

; 341  :       newspot = md_alloc(S,r->vercount*sizeof(int));

	add	eax, eax
	add	eax, eax
	push	eax
	push	esi
	call	_md_alloc

; 342  :       r = REG(spot);  /* in case of reallocation of workspace */

	mov	ecx, DWORD PTR [esi+92]
	add	ecx, DWORD PTR tv952[ebp]

; 343  :       r->verlist = newspot;
; 344  :       for ( k = 0 ; k < vhead[n1].freedom ; k++ )

	xor	edx, edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _vhead
	add	esp, 8
	mov	DWORD PTR _k$[ebp], edx
	cmp	DWORD PTR [edi+eax+8], edx
	jle	SHORT $LN134@md_region_
$LL60@md_region_:

; 345  :           INT(r->verlist)[k] = vhead[n1].rownum + k;

	mov	eax, DWORD PTR [edi+eax+12]
	mov	ebx, DWORD PTR [ecx+4]
	add	eax, edx
	add	ebx, edx
	mov	edx, DWORD PTR [esi+92]
	mov	DWORD PTR [edx+ebx*4], eax
	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _vhead
	inc	edx
	mov	DWORD PTR _k$[ebp], edx
	cmp	edx, DWORD PTR [edi+eax+8]
	jl	SHORT $LL60@md_region_

; 343  :       r->verlist = newspot;
; 344  :       for ( k = 0 ; k < vhead[n1].freedom ; k++ )

	mov	ebx, DWORD PTR tv963[ebp]
$LN134@md_region_:

; 346  :       for ( k = 0 ; k < vhead[n2].freedom ; k++ )

	xor	edx, edx
	mov	DWORD PTR _k$[ebp], edx
	cmp	DWORD PTR [ebx+eax+8], edx
	jle	SHORT $LN141@md_region_
$LL57@md_region_:

; 347  :           INT(r->verlist)[vhead[n1].freedom+k] = vhead[n2].rownum + k;

	mov	ebx, DWORD PTR [ebx+eax+12]
	mov	eax, DWORD PTR [edi+eax+8]
	add	eax, DWORD PTR [ecx+4]
	add	ebx, edx
	add	eax, edx
	mov	edx, DWORD PTR [esi+92]
	mov	DWORD PTR [edx+eax*4], ebx
	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _vhead
	mov	ebx, DWORD PTR tv963[ebp]
	inc	edx
	mov	DWORD PTR _k$[ebp], edx
	cmp	edx, DWORD PTR [eax+ebx+8]
	jl	SHORT $LL57@md_region_
$LN141@md_region_:

; 348  : 
; 349  :       /* the edge */
; 350  :       for ( k = 0 ; k < vhead[n1].freedom ; k++ )

	xor	edx, edx
	mov	DWORD PTR _k$[ebp], edx
	cmp	DWORD PTR [edi+eax+8], edx
	jle	$LN135@md_region_
	npad	2
$LL54@md_region_:

; 351  :       { int row;
; 352  :         row = vhead[n1].rownum + k;

	mov	ecx, DWORD PTR [edi+eax+12]
	add	ecx, edx

; 353  :         for ( spot = S->IA[row]-A_OFF ; spot < S->IA[row+1]-A_OFF ; spot++ )

	mov	edx, DWORD PTR [esi+52]
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _row$89306[ebp], ecx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	dec	edx
	dec	ecx
	mov	DWORD PTR tv1045[ebp], edx
	cmp	ecx, edx
	jge	SHORT $LN136@md_region_

; 351  :       { int row;
; 352  :         row = vhead[n1].rownum + k;

	mov	edx, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [ebx+eax+12]
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv1329[ebp], edx
	npad	6
$LL51@md_region_:

; 354  :            if ( S->JA[spot]-A_OFF >= vhead[n2].rownum ) break;

	mov	edx, DWORD PTR tv1329[ebp]
	mov	edx, DWORD PTR [edx]
	dec	edx
	cmp	edx, ebx
	jge	SHORT $LN127@md_region_

; 353  :         for ( spot = S->IA[row]-A_OFF ; spot < S->IA[row+1]-A_OFF ; spot++ )

	add	DWORD PTR tv1329[ebp], 4
	inc	ecx
	cmp	ecx, DWORD PTR tv1045[ebp]
	jl	SHORT $LL51@md_region_
$LN127@md_region_:
	mov	ebx, DWORD PTR tv963[ebp]
$LN136@md_region_:

; 355  :         /* entry may not exist if value 0 */
; 356  :         for ( j = 0 ; (spot<S->IA[row+1]-A_OFF) && (j<vhead[n2].freedom) ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	cmp	ecx, DWORD PTR tv1045[ebp]
	jge	SHORT $LN53@md_region_
$LL153@md_region_:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [eax+ebx+8]
	jge	SHORT $LN53@md_region_

; 357  :         {
; 358  :           if ( S->JA[spot]-A_OFF > vhead[n2].rownum+j ) continue;

	mov	ebx, DWORD PTR [ebx+eax+12]
	add	ebx, edx
	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+ecx*4]
	dec	edx
	cmp	edx, ebx
	jg	SHORT $LN46@md_region_

; 359  :           entrymark[spot] = 'x';

	mov	eax, DWORD PTR _entrymark$[ebp]
	mov	BYTE PTR [ecx+eax], 120			; 00000078H

; 360  :           spot++;

	mov	eax, DWORD PTR _vhead
	inc	ecx
$LN46@md_region_:

; 355  :         /* entry may not exist if value 0 */
; 356  :         for ( j = 0 ; (spot<S->IA[row+1]-A_OFF) && (j<vhead[n2].freedom) ; j++ )

	mov	ebx, DWORD PTR _row$89306[ebp]
	mov	edx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [edx+ebx*4+4]
	inc	DWORD PTR _j$[ebp]
	mov	ebx, DWORD PTR tv963[ebp]
	dec	edx
	cmp	ecx, edx
	jl	SHORT $LL153@md_region_
$LN53@md_region_:

; 348  : 
; 349  :       /* the edge */
; 350  :       for ( k = 0 ; k < vhead[n1].freedom ; k++ )

	mov	edx, DWORD PTR _k$[ebp]
	inc	edx
	mov	DWORD PTR _k$[ebp], edx
	cmp	edx, DWORD PTR [edi+eax+8]
	jl	$LL54@md_region_
$LN135@md_region_:

; 361  :         }
; 362  :       }
; 363  :       /* the vertices */
; 364  :       if ( !(vhead[n1].flags & HV_DONE) )

	test	BYTE PTR [edi+eax+4], 1
	jne	$LN43@md_region_

; 365  :       { for ( k = 0 ; k < vhead[n1].freedom ; k++ )

	cmp	DWORD PTR [edi+eax+8], 0
	mov	DWORD PTR _k$[ebp], 0
	jle	$LN40@md_region_
	npad	3
$LL42@md_region_:

; 366  :         { int row;
; 367  :           row = vhead[n1].rownum + k;

	mov	ecx, DWORD PTR [edi+eax+12]
	add	ecx, DWORD PTR _k$[ebp]

; 368  :           for ( spot = S->IA[row]-A_OFF ; spot < S->IA[row+1]-A_OFF ; spot++ )

	mov	edx, DWORD PTR [esi+52]
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _row$89319[ebp], ecx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	dec	edx
	dec	ecx
	mov	DWORD PTR tv1074[ebp], edx
	cmp	ecx, edx
	jge	SHORT $LN138@md_region_

; 366  :         { int row;
; 367  :           row = vhead[n1].rownum + k;

	mov	edx, DWORD PTR [esi+56]
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv1370[ebp], edx
$LL39@md_region_:

; 369  :             if ( S->JA[spot]-A_OFF >= vhead[n1].rownum ) break;

	mov	edx, DWORD PTR tv1370[ebp]
	mov	edx, DWORD PTR [edx]
	dec	edx
	cmp	edx, DWORD PTR [edi+eax+12]
	jge	SHORT $LN133@md_region_

; 368  :           for ( spot = S->IA[row]-A_OFF ; spot < S->IA[row+1]-A_OFF ; spot++ )

	add	DWORD PTR tv1370[ebp], 4
	inc	ecx
	cmp	ecx, DWORD PTR tv1074[ebp]
	jl	SHORT $LL39@md_region_
$LN133@md_region_:
	mov	ebx, DWORD PTR tv963[ebp]
$LN138@md_region_:

; 370  :           for ( j=0 ; (spot<S->IA[row+1]-A_OFF) && (j<vhead[n1].freedom) ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	cmp	ecx, DWORD PTR tv1074[ebp]
	jge	SHORT $LN41@md_region_
	npad	4
$LL35@md_region_:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [edi+eax+8]
	jge	SHORT $LN41@md_region_

; 371  :           { if ( S->JA[spot]-A_OFF > vhead[n1].rownum+j ) continue;

	mov	edx, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [edi+eax+12]
	mov	edx, DWORD PTR [edx+ecx*4]
	add	ebx, DWORD PTR _j$[ebp]
	dec	edx
	cmp	edx, ebx
	jg	SHORT $LN34@md_region_

; 372  :             entrymark[spot] = 'x';

	mov	eax, DWORD PTR _entrymark$[ebp]
	mov	BYTE PTR [ecx+eax], 120			; 00000078H

; 373  :             spot++;

	mov	eax, DWORD PTR _vhead
	inc	ecx
$LN34@md_region_:

; 370  :           for ( j=0 ; (spot<S->IA[row+1]-A_OFF) && (j<vhead[n1].freedom) ; j++ )

	mov	ebx, DWORD PTR _row$89319[ebp]
	mov	edx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [edx+ebx*4+4]
	inc	DWORD PTR _j$[ebp]
	mov	ebx, DWORD PTR tv963[ebp]
	dec	edx
	cmp	ecx, edx
	jl	SHORT $LL35@md_region_
$LN41@md_region_:

; 365  :       { for ( k = 0 ; k < vhead[n1].freedom ; k++ )

	mov	ecx, DWORD PTR _k$[ebp]
	inc	ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ecx, DWORD PTR [edi+eax+8]
	jl	$LL42@md_region_
$LN40@md_region_:

; 374  :           }
; 375  :         }
; 376  :         vhead[n1].flags |= HV_DONE;

	or	DWORD PTR [edi+eax+4], 1
	mov	eax, DWORD PTR _vhead
$LN43@md_region_:

; 377  :       }
; 378  :       if ( !(vhead[n2].flags & HV_DONE) )

	test	BYTE PTR [ebx+eax+4], 1
	jne	$LN120@md_region_

; 379  :       { for ( k = 0 ; k < vhead[n2].freedom ; k++ )

	xor	ecx, ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	DWORD PTR [ebx+eax+8], ecx
	jle	$LN28@md_region_
$LL30@md_region_:

; 380  :         { int row;
; 381  :           row = vhead[n2].rownum + k;

	mov	edi, DWORD PTR [ebx+eax+12]

; 382  :           for ( spot = S->IA[row]-A_OFF ; spot < S->IA[row+1]-A_OFF ; spot++ )

	mov	edx, DWORD PTR [esi+52]
	add	ecx, edi
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _row$89332[ebp], ecx
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	dec	ecx
	dec	edx
	cmp	ecx, edx
	jge	SHORT $LN99@md_region_

; 380  :         { int row;
; 381  :           row = vhead[n2].rownum + k;

	mov	ebx, DWORD PTR [esi+56]
	lea	ebx, DWORD PTR [ebx+ecx*4]
	mov	DWORD PTR tv1411[ebp], ebx
$LL27@md_region_:

; 383  :             if ( S->JA[spot]-A_OFF >= vhead[n2].rownum ) break;

	mov	ebx, DWORD PTR tv1411[ebp]
	mov	ebx, DWORD PTR [ebx]
	dec	ebx
	cmp	ebx, edi
	jge	SHORT $LN140@md_region_

; 382  :           for ( spot = S->IA[row]-A_OFF ; spot < S->IA[row+1]-A_OFF ; spot++ )

	add	DWORD PTR tv1411[ebp], 4
	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LL27@md_region_
$LN140@md_region_:
	mov	ebx, DWORD PTR tv963[ebp]
$LN99@md_region_:

; 384  :           for ( j = 0 ; (spot<S->IA[row+1]-A_OFF)&&(j<vhead[n2].freedom) ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	cmp	ecx, edx
	jge	SHORT $LN29@md_region_
$LL122@md_region_:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [eax+ebx+8]
	jge	SHORT $LN29@md_region_

; 385  :           { if ( S->JA[spot]-A_OFF > vhead[n2].rownum+j ) continue;

	mov	edx, DWORD PTR [esi+56]
	mov	edi, DWORD PTR [ebx+eax+12]
	mov	edx, DWORD PTR [edx+ecx*4]
	add	edi, DWORD PTR _j$[ebp]
	dec	edx
	cmp	edx, edi
	jg	SHORT $LN22@md_region_

; 386  :             entrymark[spot] = 'x';

	mov	eax, DWORD PTR _entrymark$[ebp]
	mov	BYTE PTR [ecx+eax], 120			; 00000078H

; 387  :             spot++;

	mov	eax, DWORD PTR _vhead
	inc	ecx
$LN22@md_region_:

; 384  :           for ( j = 0 ; (spot<S->IA[row+1]-A_OFF)&&(j<vhead[n2].freedom) ; j++ )

	mov	edx, DWORD PTR [esi+52]
	mov	edi, DWORD PTR _row$89332[ebp]
	mov	edx, DWORD PTR [edx+edi*4+4]
	inc	DWORD PTR _j$[ebp]
	dec	edx
	cmp	ecx, edx
	jl	SHORT $LL122@md_region_
$LN29@md_region_:

; 379  :       { for ( k = 0 ; k < vhead[n2].freedom ; k++ )

	mov	ecx, DWORD PTR _k$[ebp]
	inc	ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ecx, DWORD PTR [eax+ebx+8]
	jl	$LL30@md_region_
$LN28@md_region_:

; 388  :           }
; 389  :         }
; 390  :         vhead[n2].flags |= HV_DONE;

	or	DWORD PTR [ebx+eax+4], 1
	mov	eax, DWORD PTR _vhead
$LN120@md_region_:
	mov	ecx, DWORD PTR _q$[ebp]
$LN66@md_region_:

; 314  :   { for ( q =  S->IA[p]-A_OFF ; q < S->IA[p+1]-A_OFF ; q++ )

	mov	edx, DWORD PTR [esi+52]
	mov	edi, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR [edx+edi*4+4]
	inc	ecx
	dec	edx
	mov	DWORD PTR _q$[ebp], ecx
	cmp	ecx, edx
	jl	$LL151@md_region_
$LN69@md_region_:

; 310  : 
; 311  :   /* fill in one region per edge detected in array */
; 312  :   rcount = 0;
; 313  :   for ( p = 0 ; p < S->N ; p++ )

	add	DWORD PTR tv1503[ebp], 12		; 0000000cH
	inc	edi
	mov	DWORD PTR _p$[ebp], edi
	cmp	edi, DWORD PTR [esi+4]
	jl	$LL70@md_region_
$LN68@md_region_:

; 391  :       }
; 392  : 
; 393  :       rcount++;
; 394  :     }
; 395  :   }
; 396  : 
; 397  :   /* now see if any vertices have been missed */
; 398  :   n1_end = augmented_hessian_mode ? vhead_count : 
; 399  :         web.skel[VERTEX].max_ord+1 + optparamcount;

	cmp	DWORD PTR _augmented_hessian_mode, 0
	je	SHORT $LN76@md_region_
	mov	ecx, DWORD PTR _vhead_count
	jmp	SHORT $LN77@md_region_
$LN76@md_region_:
	mov	ecx, DWORD PTR _web+68
	mov	edx, DWORD PTR _optparamcount
	lea	ecx, DWORD PTR [edx+ecx+1]
$LN77@md_region_:

; 400  :   for ( n1 = 0 ; n1 < n1_end ; n1++ )

	test	ecx, ecx
	je	$LN17@md_region_
	xor	edi, edi
	mov	DWORD PTR tv438[ebp], ecx
$LL152@md_region_:

; 401  :   { if ( vhead[n1].flags & HV_DONE ) continue;

	test	BYTE PTR [edi+eax+4], 1
	jne	$LN18@md_region_

; 402  :     if ( vhead[n1].freedom == 0 ) continue;

	cmp	DWORD PTR [edi+eax+8], 0
	je	$LN18@md_region_

; 403  : 
; 404  :     /* need new region */
; 405  :     spot = region_alloc(S);

	push	esi
	call	_region_alloc

; 406  :     r = REG(spot);

	lea	ebx, DWORD PTR [eax*4]
	mov	eax, DWORD PTR [esi+92]

; 407  : 
; 408  :     r->supercount = 1;
; 409  :     newspot = md_alloc(S,r->supercount*sizeof(int));

	push	4
	push	esi
	mov	DWORD PTR tv952[ebp], ebx
	mov	DWORD PTR [eax+ebx+12], 1
	call	_md_alloc

; 410  :     r = REG(spot);  /* in case of reallocation of workspace */

	mov	ecx, DWORD PTR [esi+92]
	add	ecx, ebx

; 411  :     r->superlist = newspot;
; 412  :     INT(r->superlist)[0] = vlist[vhead[n1].rownum].supernode;

	mov	ebx, DWORD PTR _vlist
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR _newspot$[ebp], eax
	mov	eax, DWORD PTR _vhead
	mov	eax, DWORD PTR [edi+eax+12]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	eax, DWORD PTR [esi+92]
	mov	ebx, DWORD PTR _newspot$[ebp]
	mov	DWORD PTR [eax+ebx*4], edx

; 413  :     size = vhead[n1].freedom;

	mov	eax, DWORD PTR _vhead
	mov	eax, DWORD PTR [edi+eax+8]

; 414  :     r->size = r->vercount = size;

	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+32], eax

; 415  :     newspot = md_alloc(S,r->vercount*sizeof(int));

	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	push	esi
	call	_md_alloc

; 416  :     r = REG(spot);  /* in case of reallocation of workspace */

	mov	edx, DWORD PTR [esi+92]
	add	edx, DWORD PTR tv952[ebp]
	add	esp, 20					; 00000014H

; 417  :     r->verlist = newspot;

	mov	DWORD PTR [edx+4], eax

; 418  :     for ( k = 0 ; k < vhead[n1].freedom ; k++ )

	mov	ecx, DWORD PTR _vhead
	xor	eax, eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR [edi+ecx+8], eax
	jle	SHORT $LN144@md_region_
	npad	1
$LL14@md_region_:

; 419  :       INT(r->verlist)[k] = vhead[n1].rownum + k;

	mov	ecx, DWORD PTR [edi+ecx+12]
	mov	ebx, DWORD PTR [edx+4]
	add	ecx, eax
	add	ebx, eax
	mov	eax, DWORD PTR [esi+92]
	mov	DWORD PTR [eax+ebx*4], ecx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _vhead
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR [edi+ecx+8]
	jl	SHORT $LL14@md_region_
$LN144@md_region_:

; 420  : 
; 421  :     /* fill matrix */
; 422  :     for ( k = 0 ; k < vhead[n1].freedom ; k++ )

	xor	eax, eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR [edi+ecx+8], eax
	jle	$LN145@md_region_
$LL11@md_region_:

; 423  :     { int row;
; 424  :       row = vhead[n1].rownum + k;

	mov	ebx, DWORD PTR [edi+ecx+12]

; 425  :       for ( spot = S->IA[row]-A_OFF ; spot < S->IA[row+1]-A_OFF ; spot++ )

	mov	edx, DWORD PTR [esi+52]
	add	eax, ebx
	lea	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _row$89357[ebp], eax
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	dec	edx
	dec	eax
	mov	DWORD PTR tv1147[ebp], edx
	cmp	eax, edx
	jge	SHORT $LN147@md_region_

; 423  :     { int row;
; 424  :       row = vhead[n1].rownum + k;

	mov	edx, DWORD PTR [esi+56]
	lea	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv1527[ebp], edx
	npad	7
$LL150@md_region_:

; 426  :          if ( S->JA[spot]-A_OFF >= vhead[n1].rownum ) break;

	mov	edx, DWORD PTR tv1527[ebp]
	mov	edx, DWORD PTR [edx]
	dec	edx
	cmp	edx, ebx
	mov	edx, DWORD PTR tv1147[ebp]
	jge	SHORT $LN147@md_region_

; 425  :       for ( spot = S->IA[row]-A_OFF ; spot < S->IA[row+1]-A_OFF ; spot++ )

	add	DWORD PTR tv1527[ebp], 4
	inc	eax
	cmp	eax, edx
	jl	SHORT $LL150@md_region_
$LN147@md_region_:

; 427  :       for ( j=0 ; (spot<S->IA[row+1]-A_OFF) && (j<vhead[n1].freedom) ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	cmp	eax, edx
	jge	SHORT $LN10@md_region_
$LL142@md_region_:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [edi+ecx+8]
	jge	SHORT $LN10@md_region_

; 428  :       { if ( S->JA[spot]-A_OFF > vhead[n1].rownum+j ) continue;

	mov	edx, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [edi+ecx+12]
	mov	edx, DWORD PTR [edx+eax*4]
	add	ebx, DWORD PTR _j$[ebp]
	dec	edx
	cmp	edx, ebx
	jg	SHORT $LN3@md_region_

; 429  :         entrymark[spot] = 'x';

	mov	ecx, DWORD PTR _entrymark$[ebp]
	mov	BYTE PTR [eax+ecx], 120			; 00000078H

; 430  :         spot++;

	mov	ecx, DWORD PTR _vhead
	inc	eax
$LN3@md_region_:

; 427  :       for ( j=0 ; (spot<S->IA[row+1]-A_OFF) && (j<vhead[n1].freedom) ; j++ )

	mov	edx, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR _row$89357[ebp]
	mov	edx, DWORD PTR [edx+ebx*4+4]
	inc	DWORD PTR _j$[ebp]
	dec	edx
	cmp	eax, edx
	jl	SHORT $LL142@md_region_
$LN10@md_region_:

; 420  : 
; 421  :     /* fill matrix */
; 422  :     for ( k = 0 ; k < vhead[n1].freedom ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR [edi+ecx+8]
	jl	$LL11@md_region_
$LN145@md_region_:

; 431  :       }
; 432  :     }
; 433  :     vhead[n1].flags |= HV_DONE;

	or	DWORD PTR [edi+ecx+4], 1
	mov	eax, DWORD PTR _vhead
$LN18@md_region_:

; 400  :   for ( n1 = 0 ; n1 < n1_end ; n1++ )

	add	edi, 32					; 00000020H
	dec	DWORD PTR tv438[ebp]
	jne	$LL152@md_region_
$LN17@md_region_:

; 434  :     rcount++;
; 435  :   }
; 436  : 
; 437  :   temp_free(entrymark);

	mov	eax, DWORD PTR _entrymark$[ebp]
	push	eax
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 438  : } // end md_region_string()

	mov	esp, ebp
	pop	ebp
	ret	0
_md_region_string ENDP
_TEXT	ENDS
PUBLIC	_md_supernode_regions
; Function compile flags: /Ogtp
;	COMDAT _md_supernode_regions
_TEXT	SEGMENT
_S$ = 8							; size = 4
_md_supernode_regions PROC				; COMDAT

; 464  : { int k,rnum,snum;

	push	ebp
	mov	ebp, esp

; 465  :   struct region *r;
; 466  :   struct supernode *s;
; 467  : 
; 468  :   /* count number of correspondences needed */
; 469  :   for ( rnum = regionstart ; rnum >= 0 ; rnum = r->next )

	mov	ecx, DWORD PTR _regionstart
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _S$[ebp]
	test	ecx, ecx
	js	SHORT $LN13@md_superno
$LL15@md_superno:

; 470  :   { r = REG(rnum);

	mov	eax, DWORD PTR [edi+92]
	lea	ecx, DWORD PTR [eax+ecx*4]

; 471  :      for ( k = 0 ; k < r->supercount ; k++ )

	xor	eax, eax
	cmp	DWORD PTR [ecx+12], eax
	jle	SHORT $LN14@md_superno
$LL12@md_superno:

; 472  :         slist[INT(r->superlist)[k]].rcount++;

	mov	edx, DWORD PTR [ecx+16]
	mov	esi, DWORD PTR [edi+92]
	add	edx, eax
	mov	edx, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR _slist
	imul	edx, 44					; 0000002cH
	inc	DWORD PTR [edx+esi]
	inc	eax
	cmp	eax, DWORD PTR [ecx+12]
	jl	SHORT $LL12@md_superno
$LN14@md_superno:

; 465  :   struct region *r;
; 466  :   struct supernode *s;
; 467  : 
; 468  :   /* count number of correspondences needed */
; 469  :   for ( rnum = regionstart ; rnum >= 0 ; rnum = r->next )

	mov	ecx, DWORD PTR [ecx+36]
	test	ecx, ecx
	jns	SHORT $LL15@md_superno
	mov	ecx, DWORD PTR _regionstart
$LN13@md_superno:

; 473  :   }
; 474  : 
; 475  :   for ( snum = superstart ; snum >= 0 ; snum = s->next )

	mov	esi, DWORD PTR _superstart
	test	esi, esi
	js	SHORT $LN7@md_superno
$LL28@md_superno:

; 476  :   { s = slist + snum;

	imul	esi, 44					; 0000002cH
	add	esi, DWORD PTR _slist

; 477  :     s->rlist = md_alloc(S,s->rcount*sizeof(int));

	mov	eax, DWORD PTR [esi]
	add	eax, eax
	add	eax, eax
	push	eax
	push	edi
	call	_md_alloc
	mov	DWORD PTR [esi+4], eax

; 478  :     s->rcount = 0;  /* reset so can use as index in loading */

	mov	DWORD PTR [esi], 0
	mov	esi, DWORD PTR [esi+36]
	add	esp, 8
	test	esi, esi
	jns	SHORT $LL28@md_superno

; 473  :   }
; 474  : 
; 475  :   for ( snum = superstart ; snum >= 0 ; snum = s->next )

	mov	ecx, DWORD PTR _regionstart
$LN7@md_superno:

; 479  :   }
; 480  :   for ( rnum = regionstart; rnum >= 0 ; rnum = r->next )

	mov	ebx, ecx
	test	ecx, ecx
	js	SHORT $LN4@md_superno
	npad	7
$LL6@md_superno:

; 481  :   { r = REG(rnum);

	mov	ecx, DWORD PTR [edi+92]
	lea	esi, DWORD PTR [ecx+ebx*4]

; 482  :     for ( k = 0 ; k < r->supercount ; k++ )

	xor	ecx, ecx
	cmp	DWORD PTR [esi+12], ecx
	jle	SHORT $LN5@md_superno
	npad	3
$LL29@md_superno:

; 483  :     { s = slist + INT(r->superlist)[k];

	mov	edx, DWORD PTR [edi+92]
	mov	eax, DWORD PTR [esi+16]
	add	eax, ecx
	mov	eax, DWORD PTR [edx+eax*4]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR _slist
	inc	ecx

; 484  :       INT(s->rlist)[s->rcount++] = rnum;

	mov	edi, DWORD PTR [eax+4]
	add	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx+edi*4], ebx
	inc	DWORD PTR [eax]
	mov	edi, DWORD PTR _S$[ebp]
	cmp	ecx, DWORD PTR [esi+12]
	jl	SHORT $LL29@md_superno
$LN5@md_superno:

; 479  :   }
; 480  :   for ( rnum = regionstart; rnum >= 0 ; rnum = r->next )

	mov	ebx, DWORD PTR [esi+36]
	test	ebx, ebx
	jns	SHORT $LL6@md_superno
$LN4@md_superno:
	pop	edi
	pop	esi
	pop	ebx

; 485  :     } 
; 486  :   }
; 487  : } // end md_supernode_regions()

	pop	ebp
	ret	0
_md_supernode_regions ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_md_supernode_setup
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _md_supernode_setup
_TEXT	SEGMENT
tv689 = -20						; size = 4
tv594 = -16						; size = 4
_v$89447 = -16						; size = 4
_ctrl$89448 = -12					; size = 4
_v$89410 = -12						; size = 4
_n$ = -12						; size = 4
_vhead_hi$ = -8						; size = 4
_df$89458 = -4						; size = 4
_j$ = -4						; size = 4
_S$ = 8							; size = 4
_md_supernode_setup PROC				; COMDAT

; 498  : { int n,i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 499  :   struct supernode *s;
; 500  :   int vhead_hi;
; 501  :   struct hess_verlist *vh;
; 502  :  
; 503  :   vhead_hi = augmented_hessian_mode ? vhead_count : 
; 504  :         web.skel[VERTEX].max_ord+1 + optparamcount;

	cmp	DWORD PTR _augmented_hessian_mode, 0
	je	SHORT $LN50@md_superno@2
	mov	eax, DWORD PTR _vhead_count
	jmp	SHORT $LN89@md_superno@2
$LN50@md_superno@2:
	mov	ecx, DWORD PTR _web+68
	mov	edx, DWORD PTR _optparamcount
	lea	eax, DWORD PTR [edx+ecx+1]
$LN89@md_superno@2:

; 505  : 
; 506  :   /* allocate supernode list */
; 507  :   for ( n = 0, supercount = 0; n < vhead_hi ; n++ )

	xor	ecx, ecx
	mov	edx, eax
	mov	DWORD PTR _vhead_hi$[ebp], eax
	mov	DWORD PTR _supercount, ecx
	test	edx, edx
	jle	SHORT $LN45@md_superno@2
	mov	eax, DWORD PTR _vhead
	add	eax, 8
	npad	1
$LL47@md_superno@2:

; 508  :      if ( vhead[n].freedom > 0 ) supercount++;

	cmp	DWORD PTR [eax], 0
	jle	SHORT $LN46@md_superno@2
	inc	ecx
	mov	DWORD PTR _supercount, ecx
$LN46@md_superno@2:

; 505  : 
; 506  :   /* allocate supernode list */
; 507  :   for ( n = 0, supercount = 0; n < vhead_hi ; n++ )

	add	eax, 32					; 00000020H
	dec	edx
	jne	SHORT $LL47@md_superno@2
$LN45@md_superno@2:
	push	ebx
	push	esi
	push	edi

; 509  :   slist = (struct supernode *)temp_calloc(supercount,sizeof(struct supernode));

	push	509					; 000001fdH
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	push	44					; 0000002cH
	push	ecx
	call	_kb_temp_calloc

; 510  :   s = slist;
; 511  :   supercount = 0;
; 512  : 
; 513  :   /* Higher-order Lagrange edge and facet innards */
; 514  :   if ( web.lagrange_order >= 3 )  /* do edge innards */

	mov	edi, DWORD PTR _web+632
	add	esp, 16					; 00000010H
	mov	DWORD PTR _slist, eax
	mov	esi, eax
	mov	DWORD PTR _supercount, 0
	cmp	edi, 3
	jl	$LN83@md_superno@2

; 515  :   { edge_id e_id;
; 516  :     vertex_id *v;
; 517  :     FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR _web+160
	test	eax, 268435456				; 10000000H
	je	$LN83@md_superno@2
	npad	6
$LL85@md_superno@2:
	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv594[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN41@md_superno@2

; 518  :     { int df; /* total degrees of freedom on edge */
; 519  :       v = get_edge_vertices(e_id);

	mov	edx, DWORD PTR _web+216
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax+304]
	add	eax, ecx

; 520  :       for ( j = 1, df = 0 ; j < web.lagrange_order ; j++ )

	mov	ecx, 1
	xor	edx, edx
	mov	DWORD PTR _v$89410[ebp], eax
	cmp	edi, ecx
	jle	$LN41@md_superno@2
	jmp	SHORT $LN37@md_superno@2
	npad	3
$LL74@md_superno@2:
	mov	eax, DWORD PTR _v$89410[ebp]
$LN37@md_superno@2:

; 521  :       { vh = get_vertex_vhead(v[j]); 

	mov	edi, DWORD PTR _vhead_attr
	mov	eax, DWORD PTR [eax+ecx*4]
	imul	edi, 240				; 000000f0H
	mov	ebx, DWORD PTR _web+12
	add	edi, DWORD PTR _web+104
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR _dymem
	mov	edi, DWORD PTR [edi+ebx+64]
	mov	eax, DWORD PTR [eax+edi]
	shl	eax, 5
	add	eax, DWORD PTR _vhead
	inc	ecx

; 522  :         df += vh->freedom;
; 523  :         vh->flags |= SUPERNODE_DONE;

	or	DWORD PTR [eax+4], 2
	mov	edi, DWORD PTR _web+632
	add	edx, DWORD PTR [eax+8]
	cmp	ecx, edi
	jl	SHORT $LL74@md_superno@2

; 524  :       }
; 525  :       if ( df == 0 ) continue;

	test	edx, edx
	je	$LN41@md_superno@2

; 526  :       s->verlist = md_alloc(S,df*sizeof(int));

	lea	ecx, DWORD PTR [edx*4]
	mov	edx, DWORD PTR _S$[ebp]
	push	ecx
	push	edx
	call	_md_alloc

; 527  :       for ( j = 1 ; j < web.lagrange_order ; j++ )

	mov	edi, 1
	add	esp, 8
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR _j$[ebp], edi
	cmp	DWORD PTR _web+632, edi
	jle	$LN80@md_superno@2
$LL88@md_superno@2:

; 528  :       { vh = get_vertex_vhead(v[j]);

	mov	edx, DWORD PTR _vhead_attr
	mov	eax, DWORD PTR _v$89410[ebp]
	imul	edx, 240				; 000000f0H
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR _web+12
	add	edx, DWORD PTR _web+104
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [edx+eax+64]
	mov	eax, DWORD PTR [ecx+edx]
	shl	eax, 5
	add	eax, DWORD PTR _vhead

; 529  :         if ( vh->freedom > 0 )

	mov	edx, DWORD PTR [eax+8]
	test	edx, edx
	jle	SHORT $LN32@md_superno@2

; 530  :         { 
; 531  :           for ( i = 0 ; i < vh->freedom ; i++ )

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN27@md_superno@2
	npad	7
$LL78@md_superno@2:

; 532  :           { INT(s->verlist)[s->vercount+i] = vh->rownum + i;

	mov	edi, DWORD PTR [esi+24]
	add	edi, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [eax+12]
	mov	ebx, DWORD PTR _S$[ebp]
	mov	ebx, DWORD PTR [ebx+92]
	add	edx, ecx
	add	edi, ecx
	mov	DWORD PTR [ebx+edi*4], edx

; 533  :             vlist[INT(s->verlist)[s->vercount+i]].supernode = supercount;

	mov	edx, DWORD PTR [esi+24]
	add	edx, DWORD PTR [esi+20]
	mov	edi, DWORD PTR _S$[ebp]
	mov	edi, DWORD PTR [edi+92]
	mov	ebx, DWORD PTR _vlist
	add	edx, ecx
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR _supercount
	lea	edx, DWORD PTR [edx+edx*2]
	inc	ecx
	mov	DWORD PTR [ebx+edx*4], edi
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $LL78@md_superno@2

; 530  :         { 
; 531  :           for ( i = 0 ; i < vh->freedom ; i++ )

	mov	edi, DWORD PTR _j$[ebp]
$LN27@md_superno@2:

; 534  :           }
; 535  :           s->vercount += vh->freedom;

	mov	eax, DWORD PTR [eax+8]
	add	DWORD PTR [esi+24], eax
$LN32@md_superno@2:

; 527  :       for ( j = 1 ; j < web.lagrange_order ; j++ )

	inc	edi
	mov	DWORD PTR _j$[ebp], edi
	cmp	edi, DWORD PTR _web+632
	jl	$LL88@md_superno@2
$LN80@md_superno@2:

; 536  :         }
; 537  :       }
; 538  :       s->next = supercount+1;

	mov	ecx, DWORD PTR _supercount
	inc	ecx
	mov	DWORD PTR [esi+36], ecx

; 539  :       s->prev = supercount-1;

	mov	edx, DWORD PTR _supercount
	dec	edx
	mov	DWORD PTR [esi+40], edx

; 540  :       supercount++;

	inc	DWORD PTR _supercount

; 541  :       s++; 

	mov	edi, DWORD PTR _web+632
	add	esi, 44					; 0000002cH
$LN41@md_superno@2:

; 515  :   { edge_id e_id;
; 516  :     vertex_id *v;
; 517  :     FOR_ALL_EDGES(e_id)

	mov	eax, DWORD PTR tv594[ebp]
	mov	ecx, DWORD PTR _web+124
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	$LL85@md_superno@2
$LN83@md_superno@2:

; 542  :     }
; 543  :   } /* end edge innards */
; 544  : 
; 545  :   /* do facet innards */
; 546  :   if ( (web.lagrange_order >= 4) && (web.representation == SOAPFILM) )  

	cmp	edi, 4
	jl	$LN23@md_superno@2
	cmp	DWORD PTR _web+624, 2
	jne	$LN23@md_superno@2

; 547  :   { facet_id f_id;
; 548  :     vertex_id *v;
; 549  :     int ctrl = (web.lagrange_order+1)*(web.lagrange_order+2)/2;

	lea	eax, DWORD PTR [edi+2]
	inc	edi
	imul	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _ctrl$89448[ebp], eax

; 550  : 
; 551  :     FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR _web+272
	test	eax, 268435456				; 10000000H
	je	$LN23@md_superno@2
	npad	7
$LL86@md_superno@2:
	mov	ecx, DWORD PTR _web+236
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	mov	DWORD PTR tv689[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	$LN24@md_superno@2

; 552  :     { int df; /* total degrees of freedom on facet interior */
; 553  :       v = get_facet_vertices(f_id);

	mov	edx, DWORD PTR _web+328
	mov	eax, DWORD PTR _dymem
	mov	edi, DWORD PTR [edx+eax+304]
	add	edi, ecx

; 554  :       for ( j = 1, df = 0 ; j < ctrl ; j++ )

	mov	ebx, 1
	mov	DWORD PTR _v$89447[ebp], edi
	mov	DWORD PTR _df$89458[ebp], 0
	cmp	DWORD PTR _ctrl$89448[ebp], ebx
	jle	$LN24@md_superno@2
$LL20@md_superno@2:

; 555  :       { if ( !(get_vattr(v[j]) & Q_MIDFACET) ) continue;

	mov	ecx, DWORD PTR [edi+ebx*4]
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 2097152				; 00200000H
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN19@md_superno@2

; 556  :         vh = get_vertex_vhead(v[j]); 

	mov	eax, DWORD PTR _vhead_attr
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR [ecx+eax]
	shl	eax, 5
	add	eax, DWORD PTR _vhead

; 557  :         df += vh->freedom;

	mov	ecx, DWORD PTR [eax+8]
	add	DWORD PTR _df$89458[ebp], ecx

; 558  :         vh->flags |= SUPERNODE_DONE;

	or	DWORD PTR [eax+4], 2
$LN19@md_superno@2:

; 554  :       for ( j = 1, df = 0 ; j < ctrl ; j++ )

	inc	ebx
	cmp	ebx, DWORD PTR _ctrl$89448[ebp]
	jl	SHORT $LL20@md_superno@2

; 559  :       }
; 560  :       if ( df == 0 ) continue;

	mov	eax, DWORD PTR _df$89458[ebp]
	test	eax, eax
	je	$LN24@md_superno@2

; 561  :       s->verlist = md_alloc(S,df*sizeof(int));

	lea	edx, DWORD PTR [eax*4]
	mov	eax, DWORD PTR _S$[ebp]
	push	edx
	push	eax
	call	_md_alloc

; 562  :       for ( j = 1 ; j < ctrl ; j++ )

	mov	ebx, 1
	add	esp, 8
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR _j$[ebp], ebx
	npad	14
$LL15@md_superno@2:

; 563  :       { if ( !(get_vattr(v[j]) & Q_MIDFACET) ) continue;

	mov	ecx, DWORD PTR [edi+ebx*4]
	mov	edx, DWORD PTR _web+12
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 2097152				; 00200000H
	xor	edx, edx
	or	eax, edx
	je	$LN14@md_superno@2

; 564  :         vh = get_vertex_vhead(v[j]);

	mov	eax, DWORD PTR _vhead_attr
	mov	edx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+104
	mov	eax, DWORD PTR [eax+edx+64]
	mov	ecx, DWORD PTR [ecx+eax]
	shl	ecx, 5
	add	ecx, DWORD PTR _vhead

; 565  :         for ( i = 0 ; i < vh->freedom ; i++ )

	xor	eax, eax
	cmp	DWORD PTR [ecx+8], eax
	jle	SHORT $LN9@md_superno@2
$LL79@md_superno@2:

; 566  :         { INT(s->verlist)[s->vercount+i] = vh->rownum + i;

	mov	edi, DWORD PTR [esi+24]
	add	edi, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [ecx+12]
	mov	ebx, DWORD PTR _S$[ebp]
	mov	ebx, DWORD PTR [ebx+92]
	add	edx, eax
	add	edi, eax
	mov	DWORD PTR [ebx+edi*4], edx

; 567  :           vlist[INT(s->verlist)[s->vercount+i]].supernode = supercount;

	mov	edx, DWORD PTR [esi+24]
	add	edx, DWORD PTR [esi+20]
	mov	edi, DWORD PTR _S$[ebp]
	mov	edi, DWORD PTR [edi+92]
	mov	ebx, DWORD PTR _vlist
	add	edx, eax
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR _supercount
	lea	edx, DWORD PTR [edx+edx*2]
	inc	eax
	mov	DWORD PTR [ebx+edx*4], edi
	cmp	eax, DWORD PTR [ecx+8]
	jl	SHORT $LL79@md_superno@2

; 565  :         for ( i = 0 ; i < vh->freedom ; i++ )

	mov	edi, DWORD PTR _v$89447[ebp]
	mov	ebx, DWORD PTR _j$[ebp]
$LN9@md_superno@2:

; 568  :         }
; 569  :         s->vercount += vh->freedom;

	mov	eax, DWORD PTR [ecx+8]
	add	DWORD PTR [esi+24], eax
$LN14@md_superno@2:

; 562  :       for ( j = 1 ; j < ctrl ; j++ )

	inc	ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, DWORD PTR _ctrl$89448[ebp]
	jl	$LL15@md_superno@2

; 570  :       }
; 571  :       s->next = supercount+1;

	mov	ecx, DWORD PTR _supercount
	inc	ecx
	mov	DWORD PTR [esi+36], ecx

; 572  :       s->prev = supercount-1;

	mov	edx, DWORD PTR _supercount
	dec	edx
	mov	DWORD PTR [esi+40], edx

; 573  :       supercount++;

	inc	DWORD PTR _supercount

; 574  :       s++; 

	add	esi, 44					; 0000002cH
$LN24@md_superno@2:

; 550  : 
; 551  :     FOR_ALL_FACETS(f_id)

	mov	eax, DWORD PTR tv689[ebp]
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx]
	test	eax, 268435456				; 10000000H
	jne	$LL86@md_superno@2
$LN23@md_superno@2:

; 575  :     }
; 576  :   } /* end facet innards */
; 577  : 
; 578  :   /* now all single vertices and miscellaneous */
; 579  :   for ( n = 0 ; n < vhead_hi ; n++ )

	xor	edi, edi
	mov	DWORD PTR _n$[ebp], edi
	cmp	DWORD PTR _vhead_hi$[ebp], edi
	jle	$LN6@md_superno@2
	mov	ecx, DWORD PTR _vhead
	add	esi, 20					; 00000014H
	npad	9
$LL87@md_superno@2:

; 580  :     if ( vhead[n].freedom > 0 && !(vhead[n].flags & SUPERNODE_DONE) )

	mov	eax, DWORD PTR [edi+ecx+8]
	test	eax, eax
	jle	$LN7@md_superno@2
	test	BYTE PTR [edi+ecx+4], 2
	jne	$LN7@md_superno@2

; 581  :     { s->vercount = vhead[n].freedom;
; 582  :       s->verlist = md_alloc(S,s->vercount*sizeof(int));

	mov	ebx, DWORD PTR _S$[ebp]
	mov	DWORD PTR [esi+4], eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ebx
	call	_md_alloc
	mov	DWORD PTR [esi], eax

; 583  :       for ( i = 0 ; i < vhead[n].freedom ; i++ )

	mov	ecx, DWORD PTR _vhead
	xor	eax, eax
	add	esp, 8
	cmp	DWORD PTR [edi+ecx+8], eax
	jle	SHORT $LN2@md_superno@2
	npad	5
$LL81@md_superno@2:

; 584  :       { INT(s->verlist)[i] = vhead[n].rownum + i;

	mov	ecx, DWORD PTR [edi+ecx+12]
	mov	edx, DWORD PTR [esi]
	mov	ebx, DWORD PTR [ebx+92]
	add	ecx, eax
	add	edx, eax
	mov	DWORD PTR [ebx+edx*4], ecx

; 585  :         vlist[INT(s->verlist)[i]].supernode = supercount;

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _S$[ebp]
	mov	edx, DWORD PTR [edx+92]
	mov	ebx, DWORD PTR _vlist
	add	ecx, eax
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR _supercount
	lea	ecx, DWORD PTR [ecx+ecx*2]
	mov	DWORD PTR [ebx+ecx*4], edx
	mov	ecx, DWORD PTR _vhead
	mov	ebx, DWORD PTR _S$[ebp]
	inc	eax
	cmp	eax, DWORD PTR [edi+ecx+8]
	jl	SHORT $LL81@md_superno@2
$LN2@md_superno@2:

; 586  :       }
; 587  :       /* s->height = get_coord(vhead[n].v_id)[0];*/ /* not so good */
; 588  :       s->height = (float)n; /* pretty good */

	fild	DWORD PTR _n$[ebp]

; 589  :       if ( (s->vercount == 1) && (S->A[S->IA[s->verlist]-A_OFF] == 0.0) )

	mov	ecx, 1
	fstp	DWORD PTR [esi-4]
	cmp	DWORD PTR [esi+4], ecx
	jne	SHORT $LN1@md_superno@2
	mov	edx, DWORD PTR [ebx+52]
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ebx+60]
	fld	QWORD PTR [edx+eax*8-8]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@md_superno@2

; 590  :           s->flag |= MD_AUG_CON;  /* so don't eliminate constraints first */

	or	DWORD PTR [esi-8], ecx
$LN1@md_superno@2:

; 591  :       s->next = supercount+1;

	mov	eax, DWORD PTR _supercount
	inc	eax
	mov	DWORD PTR [esi+16], eax

; 592  :       s->prev = supercount-1;

	mov	edx, DWORD PTR _supercount
	dec	edx
	mov	DWORD PTR [esi+20], edx

; 593  :       supercount++;

	add	DWORD PTR _supercount, ecx

; 594  :       s++; 

	mov	ecx, DWORD PTR _vhead
	add	esi, 44					; 0000002cH
$LN7@md_superno@2:

; 575  :     }
; 576  :   } /* end facet innards */
; 577  : 
; 578  :   /* now all single vertices and miscellaneous */
; 579  :   for ( n = 0 ; n < vhead_hi ; n++ )

	mov	eax, DWORD PTR _n$[ebp]
	inc	eax
	add	edi, 32					; 00000020H
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, DWORD PTR _vhead_hi$[ebp]
	jl	$LL87@md_superno@2
$LN6@md_superno@2:

; 595  :     }
; 596  :   slist[0].prev = -1;

	mov	ecx, DWORD PTR _slist
	or	eax, -1
	mov	DWORD PTR [ecx+40], eax

; 597  :   slist[supercount-1].next = -1;

	mov	edx, DWORD PTR _supercount
	imul	edx, 44					; 0000002cH
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+ecx-8], eax

; 598  :   superstart = 0;

	mov	DWORD PTR _superstart, 0
	pop	ebx

; 599  : } // end md_supernode_setup()

	mov	esp, ebp
	pop	ebp
	ret	0
_md_supernode_setup ENDP
_TEXT	ENDS
PUBLIC	_clean_supernodes
_BSS	SEGMENT
_old_rtimestamp DD 01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _clean_supernodes
_TEXT	SEGMENT
_i$ = -8						; size = 4
_j$ = -4						; size = 4
_S$ = 8							; size = 4
_clean_supernodes PROC					; COMDAT

; 608  : { struct supernode *s;

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	edi

; 609  :   int i,j,k,m;
; 610  :   int n;
; 611  :   for ( n = superstart ; n >= 0 ; n = s->next )

	mov	edi, DWORD PTR _superstart
	test	edi, edi
	js	$LN16@clean_supe
	push	ebx
	push	esi
	npad	9
$LL18@clean_supe:

; 612  :   { s = slist + n;

	imul	edi, 44					; 0000002cH
	add	edi, DWORD PTR _slist

; 613  :     for ( i=0,j=0 ; i < s->rcount ; i++ )

	xor	esi, esi
	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], esi
	cmp	DWORD PTR [edi], esi
	jle	$LN13@clean_supe
	npad	3
$LL36@clean_supe:

; 614  :     { int rnum = INT(s->rlist)[i];

	mov	eax, DWORD PTR _S$[ebp]
	mov	edx, DWORD PTR [eax+92]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	ebx, DWORD PTR [edi+4]
	lea	eax, DWORD PTR [ebx+ecx]
	mov	eax, DWORD PTR [edx+eax*4]

; 615  :       while ( REG(rnum)->merged != rnum ) rnum = REG(rnum)->merged;

	mov	ecx, DWORD PTR [edx+eax*4+24]
	cmp	ecx, eax
	je	SHORT $LN11@clean_supe
	npad	6
$LL12@clean_supe:
	mov	eax, ecx
	mov	ecx, DWORD PTR [edx+eax*4+24]
	cmp	ecx, eax
	jne	SHORT $LL12@clean_supe
$LN11@clean_supe:

; 616  :       if ( REG(rnum)->timestamp > old_rtimestamp )

	mov	edx, DWORD PTR [edx+eax*4+20]
	cmp	edx, DWORD PTR _old_rtimestamp
	jle	SHORT $LN10@clean_supe

; 617  :         s->rtimestamp = REG(rnum)->timestamp;  /* mark as affected */

	mov	DWORD PTR [edi+28], edx
$LN10@clean_supe:

; 618  :       for ( k = 0 ; k < j ; k++ )

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN35@clean_supe
	mov	edx, DWORD PTR _S$[ebp]
	mov	edx, DWORD PTR [edx+92]
	lea	edx, DWORD PTR [edx+ebx*4]
$LL9@clean_supe:

; 619  :       { if ( INT(s->rlist)[k] == rnum ) break; /* duplicate */

	mov	ebx, DWORD PTR [edx]
	cmp	ebx, eax
	je	SHORT $LN35@clean_supe

; 620  :         if ( INT(s->rlist)[k] > rnum ) /* insert */

	jg	SHORT $LN27@clean_supe

; 618  :       for ( k = 0 ; k < j ; k++ )

	inc	ecx
	add	edx, 4
	cmp	ecx, esi
	jl	SHORT $LL9@clean_supe

; 620  :         if ( INT(s->rlist)[k] > rnum ) /* insert */

	jmp	SHORT $LN35@clean_supe
$LN27@clean_supe:

; 621  :            { for ( m = j ; m > k ; m-- ) INT(s->rlist)[m] = INT(s->rlist)[m-1];

	mov	edx, esi
	cmp	esi, ecx
	jle	SHORT $LN34@clean_supe
$LL33@clean_supe:
	mov	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR _S$[ebp]
	mov	ebx, DWORD PTR [ebx+92]
	add	esi, edx
	lea	esi, DWORD PTR [ebx+esi*4]
	mov	ebx, DWORD PTR [esi-4]
	dec	edx
	mov	DWORD PTR [esi], ebx
	cmp	edx, ecx
	jg	SHORT $LL33@clean_supe
	mov	esi, DWORD PTR _j$[ebp]
$LN34@clean_supe:

; 622  :                 INT(s->rlist)[k] = rnum; 

	mov	edx, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR _S$[ebp]
	mov	ebx, DWORD PTR [ebx+92]
	add	edx, ecx

; 623  :                 j++;

	inc	esi
	mov	DWORD PTR [ebx+edx*4], eax
	mov	DWORD PTR _j$[ebp], esi
$LN35@clean_supe:

; 624  :                 break;
; 625  :            }
; 626  :       }
; 627  :       if ( k == j ) { INT(s->rlist)[j++] = rnum; }

	cmp	ecx, esi
	jne	SHORT $LN14@clean_supe
	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR _S$[ebp]
	mov	edx, DWORD PTR [edx+92]
	add	ecx, esi
	inc	esi
	mov	DWORD PTR [edx+ecx*4], eax
	mov	DWORD PTR _j$[ebp], esi
$LN14@clean_supe:

; 613  :     for ( i=0,j=0 ; i < s->rcount ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [edi]
	jl	$LL36@clean_supe
$LN13@clean_supe:

; 628  :     }
; 629  :     s->rcount = j;

	mov	DWORD PTR [edi], esi
	mov	edi, DWORD PTR [edi+36]
	test	edi, edi
	jns	$LL18@clean_supe
	pop	esi
	pop	ebx
$LN16@clean_supe:
	pop	edi

; 630  :   }
; 631  : } // end clean_supernodes()

	mov	esp, ebp
	pop	ebp
	ret	0
_clean_supernodes ENDP
_TEXT	ENDS
PUBLIC	_supernode_compare
; Function compile flags: /Ogtp
;	COMDAT _supernode_compare
_TEXT	SEGMENT
tv178 = 8						; size = 4
_aa$ = 8						; size = 4
_bb$ = 12						; size = 4
_supernode_compare PROC					; COMDAT

; 645  : { int k;

	push	ebp
	mov	ebp, esp

; 646  :   struct linsys *S;
; 647  :   struct supernode *a = *aa, *b = *bb;

	mov	ecx, DWORD PTR _bb$[ebp]
	mov	eax, DWORD PTR _aa$[ebp]
	mov	eax, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR [ecx]

; 648  :   if ( a->rcount < b->rcount ) return -1;

	mov	ecx, DWORD PTR [ebx]
	push	edi
	mov	edi, DWORD PTR [eax]
	cmp	edi, ecx
	jge	SHORT $LN16@supernode_
	pop	edi
	or	eax, -1
	pop	ebx

; 656  : } // end int supernode_compare()

	pop	ebp
	ret	0
$LN16@supernode_:

; 649  :   if ( a->rcount > b->rcount ) return 1;

	jle	SHORT $LN6@supernode_
	pop	edi
	mov	eax, 1
	pop	ebx

; 656  : } // end int supernode_compare()

	pop	ebp
	ret	0
$LN6@supernode_:

; 650  :   S = SSS;

	mov	ecx, DWORD PTR _SSS
	push	esi

; 651  :   for ( k = 0 ; k < a->rcount ; k++ )

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN3@supernode_

; 650  :   S = SSS;

	mov	edx, DWORD PTR [ecx+92]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ebx+4]
	add	ecx, ecx
	add	eax, eax
	add	ecx, ecx

; 651  :   for ( k = 0 ; k < a->rcount ; k++ )

	mov	DWORD PTR tv178[ebp], edx
	add	eax, eax
	jmp	SHORT $LN5@supernode_
	npad	4
$LL14@supernode_:

; 650  :   S = SSS;

	mov	edx, DWORD PTR tv178[ebp]
$LN5@supernode_:

; 652  :   { if ( INT(a->rlist)[k] < INT(b->rlist)[k] ) return -1;

	mov	ebx, DWORD PTR [ecx+edx]
	cmp	ebx, DWORD PTR [eax+edx]
	jl	SHORT $LN11@supernode_

; 653  :      if ( INT(a->rlist)[k] > INT(b->rlist)[k] ) return  1;

	mov	edx, DWORD PTR _SSS
	mov	edx, DWORD PTR [edx+92]
	mov	ebx, DWORD PTR [ecx+edx]
	cmp	ebx, DWORD PTR [eax+edx]
	jg	SHORT $LN12@supernode_

; 651  :   for ( k = 0 ; k < a->rcount ; k++ )

	inc	esi
	add	eax, 4
	add	ecx, 4
	cmp	esi, edi
	jl	SHORT $LL14@supernode_
$LN3@supernode_:
	pop	esi
	pop	edi

; 654  :   }
; 655  :   return 0;

	xor	eax, eax
	pop	ebx

; 656  : } // end int supernode_compare()

	pop	ebp
	ret	0
$LN11@supernode_:
	pop	esi
	pop	edi

; 652  :   { if ( INT(a->rlist)[k] < INT(b->rlist)[k] ) return -1;

	or	eax, -1
	pop	ebx

; 656  : } // end int supernode_compare()

	pop	ebp
	ret	0
$LN12@supernode_:
	pop	esi
	pop	edi

; 653  :      if ( INT(a->rlist)[k] > INT(b->rlist)[k] ) return  1;

	mov	eax, 1
	pop	ebx

; 656  : } // end int supernode_compare()

	pop	ebp
	ret	0
_supernode_compare ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@GLBBBLED@Merging?5supernode?5?$CFld?5into?5?$CFld?4?6@ ; `string'
PUBLIC	_merge_supernodes
EXTRN	_printf:PROC
EXTRN	_mindeg_debug_level:DWORD
EXTRN	_qsort:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0CB@GLBBBLED@Merging?5supernode?5?$CFld?5into?5?$CFld?4?6@
CONST	SEGMENT
??_C@_0CB@GLBBBLED@Merging?5supernode?5?$CFld?5into?5?$CFld?4?6@ DB 'Merg'
	DB	'ing supernode %ld into %ld.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _merge_supernodes
_TEXT	SEGMENT
_sslist$ = -24						; size = 4
tv579 = -20						; size = 4
_j$ = -16						; size = 4
_newverlist$ = -16					; size = 4
_s$ = -16						; size = 4
_n$ = -12						; size = 4
_count$ = -8						; size = 4
tv598 = -4						; size = 4
_S$ = 8							; size = 4
_merge_supernodes PROC					; COMDAT

; 665  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 666  :   struct supernode **sslist,*s,*ss;
; 667  :   int n,k,j,i;
; 668  :   int count;
; 669  :   int newverlist;
; 670  : 
; 671  :   if ( superstart < 0 ) { supercount = 0; return; } /* all done */

	cmp	DWORD PTR _superstart, 0
	jge	SHORT $LN25@merge_supe
	mov	DWORD PTR _supercount, 0

; 723  : } // end merge_supernodes()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@merge_supe:

; 672  : 
; 673  :   /* make list to sort */
; 674  :   sslist = (struct supernode **)temp_calloc(supercount,sizeof(struct supernode *));

	mov	eax, DWORD PTR _supercount
	push	ebx
	push	esi
	push	edi
	push	674					; 000002a2H
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	push	4
	push	eax
	call	_kb_temp_calloc
	mov	esi, eax

; 675  :   /* fill list */
; 676  :   for ( n = superstart, count = 0 ; n >= 0 ; n = s->next )

	mov	eax, DWORD PTR _superstart
	xor	edi, edi
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sslist$[ebp], esi
	mov	DWORD PTR _count$[ebp], edi
	test	eax, eax
	js	SHORT $LN22@merge_supe
	mov	ecx, DWORD PTR _slist
	mov	edx, DWORD PTR _old_rtimestamp
	npad	7
$LL24@merge_supe:

; 677  :   { s = slist + n;  /* only do touched supernodes */

	imul	eax, 44					; 0000002cH
	add	eax, ecx

; 678  :      if ( s->rtimestamp > old_rtimestamp ) sslist[count++] = s;

	cmp	DWORD PTR [eax+28], edx
	jle	SHORT $LN23@merge_supe
	mov	DWORD PTR [esi+edi*4], eax
	inc	edi
$LN23@merge_supe:

; 675  :   /* fill list */
; 676  :   for ( n = superstart, count = 0 ; n >= 0 ; n = s->next )

	mov	eax, DWORD PTR [eax+36]
	test	eax, eax
	jns	SHORT $LL24@merge_supe

; 678  :      if ( s->rtimestamp > old_rtimestamp ) sslist[count++] = s;

	mov	DWORD PTR _count$[ebp], edi
$LN22@merge_supe:

; 679  :   }
; 680  :   /* sort */
; 681  :   SSS = S; /* for communication with compare routine */

	mov	ebx, DWORD PTR _S$[ebp]

; 682  :   qsort((char*)sslist,count,sizeof(struct supernode *),FCAST supernode_compare);

	push	OFFSET _supernode_compare
	push	4
	push	edi
	push	esi
	mov	DWORD PTR _SSS, ebx
	call	_qsort
	add	esp, 16					; 00000010H

; 683  :   /* merge */
; 684  :   for ( n = 1, k = 0 ; n < count ; n++ )

	mov	DWORD PTR _n$[ebp], 1
	cmp	edi, 1
	jle	$LN18@merge_supe

; 679  :   }
; 680  :   /* sort */
; 681  :   SSS = S; /* for communication with compare routine */

	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR tv579[ebp], 0
	mov	DWORD PTR tv598[ebp], ecx
	npad	1
$LL20@merge_supe:

; 685  :   { s = sslist[k];

	mov	edx, DWORD PTR tv579[ebp]

; 686  :     if ( supernode_compare(sslist+n ,&s) == 0 )

	mov	ecx, DWORD PTR tv598[ebp]
	mov	esi, DWORD PTR [edx+esi]
	lea	eax, DWORD PTR _s$[ebp]
	push	eax
	push	ecx
	mov	DWORD PTR _s$[ebp], esi
	call	_supernode_compare
	add	esp, 8
	test	eax, eax
	jne	$LN17@merge_supe

; 687  :     { /* merge */
; 688  :       ss = sslist[n];
; 689  :       if ( mindeg_debug_level > 7 )

	cmp	DWORD PTR _mindeg_debug_level, 7
	mov	edx, DWORD PTR tv598[ebp]
	mov	edi, DWORD PTR [edx]
	jle	SHORT $LN16@merge_supe

; 690  :         printf("Merging supernode %ld into %ld.\n",(long)(ss-slist),
; 691  :             (long)(s-slist));

	mov	ecx, DWORD PTR _slist
	mov	edx, esi
	sub	edx, ecx
	mov	eax, 780903145				; 2e8ba2e9H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	mov	edx, edi
	sub	edx, ecx
	mov	eax, 780903145				; 2e8ba2e9H
	imul	edx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	push	ecx
	push	OFFSET ??_C@_0CB@GLBBBLED@Merging?5supernode?5?$CFld?5into?5?$CFld?4?6@
	call	_printf
	add	esp, 12					; 0000000cH
$LN16@merge_supe:

; 692  :       newverlist = md_alloc(S,(s->vercount+ss->vercount)*sizeof(int));

	mov	edx, DWORD PTR [esi+24]
	add	edx, DWORD PTR [edi+24]
	add	edx, edx
	add	edx, edx
	push	edx
	push	ebx
	call	_md_alloc

; 693  :       memcpy(CHAR(newverlist),CHAR(s->verlist),s->vercount*sizeof(int));

	mov	edx, DWORD PTR [esi+24]
	mov	ecx, DWORD PTR [ebx+92]
	add	edx, edx
	add	edx, edx
	push	edx
	mov	edx, DWORD PTR [esi+20]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _newverlist$[ebp], eax
	push	edx
	lea	eax, DWORD PTR [ecx+eax*4]
	push	eax
	call	_memcpy

; 694  :       memcpy(CHAR(newverlist+s->vercount),CHAR(ss->verlist),
; 695  :                 ss->vercount*sizeof(int));

	mov	ecx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR [ebx+92]
	mov	edx, DWORD PTR [edi+20]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [esi+24]
	add	edx, DWORD PTR _newverlist$[ebp]
	push	ecx
	lea	eax, DWORD PTR [eax+edx*4]
	push	eax
	call	_memcpy

; 696  :       s->verlist = newverlist;

	mov	ecx, DWORD PTR _newverlist$[ebp]
	mov	DWORD PTR [esi+20], ecx

; 697  :       s->vercount += ss->vercount;

	mov	edx, DWORD PTR [edi+24]
	add	DWORD PTR [esi+24], edx

; 698  :       s->flag = 0;

	xor	ecx, ecx
	mov	DWORD PTR [esi+12], ecx

; 699  :       if ( s->height < ss->height ) s->height = ss->height;

	fld	DWORD PTR [esi+16]
	fld	DWORD PTR [edi+16]
	add	esp, 32					; 00000020H
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN15@merge_supe
	fld	DWORD PTR [edi+16]
	fstp	DWORD PTR [esi+16]
$LN15@merge_supe:

; 700  :       ss->verlist = -1;
; 701  :       ss->vercount = 0;
; 702  :       ss->flag = 0;
; 703  :       if ( ss->next >= 0 ) slist[ss->next].prev = ss->prev;

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [edi+20], -1
	mov	DWORD PTR [edi+24], ecx
	mov	DWORD PTR [edi+12], ecx
	cmp	eax, ecx
	jl	SHORT $LN41@merge_supe
	mov	edx, DWORD PTR [edi+40]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _slist
	mov	DWORD PTR [eax+esi+40], edx
$LN41@merge_supe:

; 704  :       if ( ss->prev >= 0 ) slist[ss->prev].next = ss->next;

	mov	eax, DWORD PTR [edi+40]
	cmp	eax, ecx
	jl	SHORT $LN13@merge_supe
	mov	edx, DWORD PTR [edi+36]
	imul	eax, 44					; 0000002cH
	mov	esi, DWORD PTR _slist
	mov	DWORD PTR [eax+esi+36], edx
	jmp	SHORT $LN12@merge_supe
$LN13@merge_supe:

; 705  :       else superstart = ss->next;

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR _superstart, eax
$LN12@merge_supe:

; 706  :       supercount--;

	dec	DWORD PTR _supercount

; 707  : 
; 708  :       /* remove from region supernode list */
; 709  :       for ( j = 0 ; j < ss->rcount ; j++ )

	xor	eax, eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	DWORD PTR [edi], ecx
	jle	$LN42@merge_supe
	npad	1
$LL43@merge_supe:

; 710  :       { struct region *r = REG(INT(ss->rlist)[j]);

	mov	edx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [ebx+92]
	add	edx, eax
	mov	eax, DWORD PTR [ecx+edx*4]
	lea	ecx, DWORD PTR [ecx+eax*4]

; 711  :         for ( i = 0 ; i < r->supercount ; i++ )

	xor	esi, esi
	cmp	DWORD PTR [ecx+12], esi
	jle	SHORT $LN33@merge_supe
	mov	edx, DWORD PTR tv598[ebp]
	mov	edx, DWORD PTR [edx]
	sub	edx, DWORD PTR _slist
	mov	ebx, DWORD PTR [ebx+92]
	mov	eax, 780903145				; 2e8ba2e9H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR [ecx+16]
	lea	edx, DWORD PTR [ebx+edx*4]
	npad	6
$LL8@merge_supe:

; 712  :            if ( INT(r->superlist)[i] == (sslist[n]-slist) ) break;

	cmp	DWORD PTR [edx], eax
	je	SHORT $LN39@merge_supe

; 711  :         for ( i = 0 ; i < r->supercount ; i++ )

	inc	esi
	add	edx, 4
	cmp	esi, DWORD PTR [ecx+12]
	jl	SHORT $LL8@merge_supe
$LN39@merge_supe:
	mov	ebx, DWORD PTR _S$[ebp]
$LN33@merge_supe:

; 713  :         r->supercount--;

	mov	eax, DWORD PTR [ecx+12]
	dec	eax
	mov	DWORD PTR [ecx+12], eax

; 714  :         for ( ; i < r->supercount ; i++ )

	cmp	esi, eax
	jge	SHORT $LN10@merge_supe
	npad	5
$LL4@merge_supe:

; 715  :            INT(r->superlist)[i] = INT(r->superlist)[i+1];

	mov	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR [ebx+92]
	add	eax, esi
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+4]
	inc	esi
	mov	DWORD PTR [eax], edx
	cmp	esi, DWORD PTR [ecx+12]
	jl	SHORT $LL4@merge_supe
$LN10@merge_supe:

; 707  : 
; 708  :       /* remove from region supernode list */
; 709  :       for ( j = 0 ; j < ss->rcount ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR [edi]
	jl	$LL43@merge_supe
$LN42@merge_supe:

; 716  :       }
; 717  :     }
; 718  :     else /* keep supernode */

	mov	edi, DWORD PTR _count$[ebp]
$LN19@merge_supe:

; 683  :   /* merge */
; 684  :   for ( n = 1, k = 0 ; n < count ; n++ )

	mov	eax, DWORD PTR _n$[ebp]
	add	DWORD PTR tv598[ebp], 4
	mov	esi, DWORD PTR _sslist$[ebp]
	inc	eax
	mov	DWORD PTR _n$[ebp], eax
	cmp	eax, edi
	jl	$LL20@merge_supe
$LN18@merge_supe:

; 719  :     { k = n;
; 720  :     }
; 721  :   }
; 722  :   temp_free((char*)sslist);

	push	esi
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 723  : } // end merge_supernodes()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@merge_supe:

; 683  :   /* merge */
; 684  :   for ( n = 1, k = 0 ; n < count ; n++ )

	mov	eax, DWORD PTR _n$[ebp]
	lea	ecx, DWORD PTR [eax*4]
	mov	DWORD PTR tv579[ebp], ecx
	jmp	SHORT $LN19@merge_supe
_merge_supernodes ENDP
_TEXT	ENDS
PUBLIC	_do_region_absorb
; Function compile flags: /Ogtp
;	COMDAT _do_region_absorb
_TEXT	SEGMENT
_S$ = 8							; size = 4
_keeper$ = 12						; size = 4
_goner$ = 16						; size = 4
_do_region_absorb PROC					; COMDAT

; 737  : { int n;

	push	ebp
	mov	ebp, esp

; 738  :   struct region *rk = REG(keeper),*rg = REG(goner);

	mov	edx, DWORD PTR _goner$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _keeper$[ebp]
	push	edi
	mov	edi, DWORD PTR _S$[ebp]
	mov	ecx, DWORD PTR [edi+92]

; 739  : 
; 740  :   /* find spots in keeper matrix */
; 741  :   for ( n = 0 ; n < rk->vercount ; n++ )

	xor	eax, eax
	cmp	DWORD PTR [ecx+esi*4], eax
	jle	SHORT $LN5@do_region_
	npad	7
$LL7@do_region_:

; 742  :      vlist[INT(rk->verlist)[n]].newspot = n;

	mov	edx, DWORD PTR [ecx+esi*4+4]
	mov	ebx, DWORD PTR [edi+92]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _vlist
	lea	edx, DWORD PTR [edx+edx*2]
	mov	DWORD PTR [ebx+edx*4+8], eax
	inc	eax
	cmp	eax, DWORD PTR [ecx+esi*4]
	jl	SHORT $LL7@do_region_

; 739  : 
; 740  :   /* find spots in keeper matrix */
; 741  :   for ( n = 0 ; n < rk->vercount ; n++ )

	mov	edx, DWORD PTR _goner$[ebp]
$LN5@do_region_:

; 743  :   rg->merged = keeper;
; 744  :   if ( rg->next >= 0 ) REG(rg->next)->prev = rg->prev; 

	mov	eax, DWORD PTR [ecx+edx*4+36]
	mov	DWORD PTR [ecx+edx*4+24], esi
	test	eax, eax
	js	SHORT $LN4@do_region_
	mov	edx, DWORD PTR [ecx+edx*4+40]
	mov	ebx, DWORD PTR [edi+92]
	mov	DWORD PTR [ebx+eax*4+40], edx
	mov	edx, DWORD PTR _goner$[ebp]
	jmp	SHORT $LN3@do_region_
$LN4@do_region_:

; 745  :   else last_region = rg->prev;

	mov	eax, DWORD PTR [ecx+edx*4+40]
	mov	DWORD PTR _last_region, eax
$LN3@do_region_:

; 746  :   if ( rg->prev >= 0 ) REG(rg->prev)->next = rg->next;

	mov	eax, DWORD PTR [ecx+edx*4+40]
	test	eax, eax
	js	SHORT $LN2@do_region_
	mov	edi, DWORD PTR [edi+92]
	mov	ebx, DWORD PTR [ecx+edx*4+36]
	mov	DWORD PTR [edi+eax*4+36], ebx

; 748  :   rg->BROTHER = rk->son;

	mov	eax, DWORD PTR [ecx+esi*4+28]
	lea	esi, DWORD PTR [ecx+esi*4+28]
	pop	edi
	mov	DWORD PTR [ecx+edx*4+16], eax

; 749  :   rk->son = goner;

	mov	DWORD PTR [esi], edx
	pop	esi
	pop	ebx

; 750  : /*  rg->size = rg->vercount; */
; 751  : } // end do_region_absorb()

	pop	ebp
	ret	0
$LN2@do_region_:

; 747  :   else regionstart = rg->next;

	mov	eax, DWORD PTR [ecx+edx*4+36]

; 748  :   rg->BROTHER = rk->son;

	lea	esi, DWORD PTR [ecx+esi*4+28]
	mov	DWORD PTR _regionstart, eax
	mov	eax, DWORD PTR [esi]
	pop	edi
	mov	DWORD PTR [ecx+edx*4+16], eax

; 749  :   rk->son = goner;

	mov	DWORD PTR [esi], edx
	pop	esi
	pop	ebx

; 750  : /*  rg->size = rg->vercount; */
; 751  : } // end do_region_absorb()

	pop	ebp
	ret	0
_do_region_absorb ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BDDPNPFE@Absorbed?5?$CFd?$DL?5max?5size?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@NLNAEKFI@Absorbing?5region?5?$CFd?5with?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	_region_absorb
_BSS	SEGMENT
_stimestamp DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BK@BDDPNPFE@Absorbed?5?$CFd?$DL?5max?5size?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BK@BDDPNPFE@Absorbed?5?$CFd?$DL?5max?5size?5?$CFd?6?$AA@ DB 'Absor'
	DB	'bed %d; max size %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NLNAEKFI@Absorbing?5region?5?$CFd?5with?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@NLNAEKFI@Absorbing?5region?5?$CFd?5with?5?$CFd?4?6?$AA@ DB 'Abs'
	DB	'orbing region %d with %d.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _region_absorb
_TEXT	SEGMENT
$T90880 = -64						; size = 4
tv296 = -60						; size = 4
tv342 = -56						; size = 4
tv291 = -52						; size = 4
tv592 = -48						; size = 4
_r$ = -44						; size = 4
_k$ = -40						; size = 4
_count$89649 = -36					; size = 4
_j$ = -32						; size = 4
_rnum$89647 = -28					; size = 4
_absorbcount$ = -24					; size = 4
_maxab$ = -20						; size = 4
tv635 = -16						; size = 4
$T90885 = -12						; size = 4
$T90884 = -8						; size = 4
_i$ = -4						; size = 4
_S$ = 8							; size = 4
_region_absorb PROC					; COMDAT

; 762  : { int i,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 763  :   struct region *r;
; 764  :   struct supernode *s;
; 765  :   int absorbcount = 0;
; 766  :   int maxab = 0; 
; 767  : 
; 768  :   for ( i = regionstart ; i >= 0 ; i = r->next )

	mov	eax, DWORD PTR _regionstart
	mov	DWORD PTR _absorbcount$[ebp], 0
	mov	DWORD PTR _maxab$[ebp], 0
	mov	DWORD PTR _i$[ebp], eax
	test	eax, eax
	js	$LN37@region_abs
	push	ebx
	mov	ebx, DWORD PTR _stimestamp
	push	esi
	push	edi
	mov	edi, DWORD PTR _slist
$LL38@region_abs:

; 769  :   { r = REG(i);

	mov	eax, DWORD PTR _S$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [ecx+edx*4]

; 770  :     if ( r->supercount > minabsorb ) continue;

	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR _r$[ebp], edx
	cmp	ecx, DWORD PTR _minabsorb
	jg	$LN19@region_abs

; 771  :     /* timestamp supernodes of r */
; 772  :     stimestamp++;

	inc	ebx

; 773  :     for ( j = 0 ; j < r->supercount ; j++ )

	xor	eax, eax
	mov	DWORD PTR _stimestamp, ebx
	test	ecx, ecx
	jle	SHORT $LN14@region_abs
	npad	2
$LL41@region_abs:

; 774  :        slist[INT(r->superlist)[j]].stimestamp = stimestamp;

	mov	ecx, DWORD PTR [edx+16]
	mov	esi, DWORD PTR _S$[ebp]
	mov	esi, DWORD PTR [esi+92]
	add	ecx, eax
	mov	ecx, DWORD PTR [esi+ecx*4]
	imul	ecx, 44					; 0000002cH
	inc	eax
	mov	DWORD PTR [ecx+edi+32], ebx
	cmp	eax, DWORD PTR [edx+12]
	jl	SHORT $LL41@region_abs
$LN14@region_abs:

; 775  :     /* pick a supernode */
; 776  :     s = slist + INT(r->superlist)[0];

	mov	eax, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [eax+92]
	mov	ecx, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax+ecx*4]
	imul	ecx, 44					; 0000002cH
	mov	esi, DWORD PTR [ecx+edi]
	mov	DWORD PTR tv291[ebp], eax

; 777  :     /* test regions of s */
; 778  :     for ( k = 0 ; k < s->rcount ; k++ )

	mov	DWORD PTR _k$[ebp], 0
	mov	DWORD PTR $T90880[ebp], esi
	test	esi, esi
	jle	$LN19@region_abs

; 775  :     /* pick a supernode */
; 776  :     s = slist + INT(r->superlist)[0];

	mov	ecx, DWORD PTR [ecx+edi+4]
	mov	edx, DWORD PTR [edx+12]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv296[ebp], edx
	mov	DWORD PTR tv635[ebp], ecx
$LL13@region_abs:

; 779  :     { int rnum = INT(s->rlist)[k];

	mov	ecx, DWORD PTR tv635[ebp]
	mov	esi, DWORD PTR [ecx]

; 780  :       struct region *rr;
; 781  :       int count;
; 782  :         
; 783  :       while ( REG(rnum)->merged != rnum ) rnum = REG(rnum)->merged;

	mov	ecx, DWORD PTR [eax+esi*4+24]
	mov	DWORD PTR _rnum$89647[ebp], esi
	cmp	ecx, esi
	je	SHORT $LN9@region_abs
$LL10@region_abs:
	mov	esi, ecx
	mov	DWORD PTR _rnum$89647[ebp], ecx
	mov	ecx, DWORD PTR [eax+esi*4+24]
	cmp	ecx, esi
	jne	SHORT $LL10@region_abs
$LN9@region_abs:

; 784  :       rr = REG(rnum);
; 785  :       if ( rr->supercount <= r->supercount ) continue;

	mov	ecx, DWORD PTR [eax+esi*4+12]
	mov	DWORD PTR tv342[ebp], ecx
	cmp	ecx, edx
	jle	$LN12@region_abs

; 786  :       for ( j = 0, count = 0 ; j < rr->supercount ; j++ )

	mov	DWORD PTR $T90884[ebp], 0
	mov	DWORD PTR $T90885[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	mov	DWORD PTR _count$89649[ebp], 0
	cmp	ecx, 2
	jl	SHORT $LN39@region_abs

; 787  :         count += (slist[INT(rr->superlist)[j]].stimestamp == stimestamp);

	mov	edx, DWORD PTR [eax+esi*4+16]
	add	ecx, -2					; fffffffeH
	shr	ecx, 1
	inc	ecx
	lea	eax, DWORD PTR [eax+edx*4]
	lea	edx, DWORD PTR [ecx+ecx]
	mov	DWORD PTR _j$[ebp], edx
$LL36@region_abs:
	mov	edx, DWORD PTR [eax]
	imul	edx, 44					; 0000002cH
	mov	DWORD PTR tv592[ebp], ecx
	xor	ecx, ecx
	cmp	DWORD PTR [edx+edi+32], ebx
	mov	edx, DWORD PTR [eax+4]
	sete	cl
	imul	edx, 44					; 0000002cH
	add	DWORD PTR $T90884[ebp], ecx
	xor	ecx, ecx
	cmp	DWORD PTR [edx+edi+32], ebx
	sete	cl
	add	eax, 8
	add	DWORD PTR $T90885[ebp], ecx
	mov	ecx, DWORD PTR tv592[ebp]
	dec	ecx
	jne	SHORT $LL36@region_abs
	mov	esi, DWORD PTR _rnum$89647[ebp]
	mov	eax, DWORD PTR tv291[ebp]
	mov	ecx, DWORD PTR tv342[ebp]
$LN39@region_abs:

; 786  :       for ( j = 0, count = 0 ; j < rr->supercount ; j++ )

	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, ecx
	jge	SHORT $LN40@region_abs

; 787  :         count += (slist[INT(rr->superlist)[j]].stimestamp == stimestamp);

	mov	ecx, DWORD PTR [eax+esi*4+16]
	add	ecx, edx
	mov	edx, DWORD PTR [eax+ecx*4]
	imul	edx, 44					; 0000002cH
	xor	ecx, ecx
	cmp	DWORD PTR [edx+edi+32], ebx
	sete	cl
	mov	DWORD PTR _count$89649[ebp], ecx
$LN40@region_abs:

; 788  :       if ( count == r->supercount ) /* have it */

	mov	ecx, DWORD PTR $T90885[ebp]
	add	ecx, DWORD PTR $T90884[ebp]
	mov	edx, DWORD PTR tv296[ebp]
	add	ecx, DWORD PTR _count$89649[ebp]
	cmp	ecx, edx
	je	SHORT $LN28@region_abs
$LN12@region_abs:

; 777  :     /* test regions of s */
; 778  :     for ( k = 0 ; k < s->rcount ; k++ )

	mov	ecx, DWORD PTR _k$[ebp]
	add	DWORD PTR tv635[ebp], 4
	inc	ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ecx, DWORD PTR $T90880[ebp]
	jl	$LL13@region_abs

; 788  :       if ( count == r->supercount ) /* have it */

	jmp	SHORT $LN43@region_abs
$LN28@region_abs:

; 789  :       {
; 790  :         if ( r->supercount > maxab ) maxab = r->supercount;

	cmp	edx, DWORD PTR _maxab$[ebp]
	jle	SHORT $LN3@region_abs
	mov	DWORD PTR _maxab$[ebp], edx
$LN3@region_abs:

; 791  :         do_region_absorb(S,rnum,i);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _S$[ebp]
	push	edx
	push	esi
	push	eax
	call	_do_region_absorb
	add	esp, 12					; 0000000cH

; 792  :         if ( mindeg_debug_level >= 5 )

	cmp	DWORD PTR _mindeg_debug_level, 5
	jl	SHORT $LN2@region_abs

; 793  :            printf("Absorbing region %d with %d.\n",i,rnum);

	mov	ecx, DWORD PTR _i$[ebp]
	push	esi
	push	ecx
	push	OFFSET ??_C@_0BO@NLNAEKFI@Absorbing?5region?5?$CFd?5with?5?$CFd?4?6?$AA@
	call	_printf
	mov	ebx, DWORD PTR _stimestamp
	mov	edi, DWORD PTR _slist
	add	esp, 12					; 0000000cH
$LN2@region_abs:

; 794  :         absorbcount++;

	inc	DWORD PTR _absorbcount$[ebp]
$LN43@region_abs:
	mov	edx, DWORD PTR _r$[ebp]
$LN19@region_abs:

; 763  :   struct region *r;
; 764  :   struct supernode *s;
; 765  :   int absorbcount = 0;
; 766  :   int maxab = 0; 
; 767  : 
; 768  :   for ( i = regionstart ; i >= 0 ; i = r->next )

	mov	edx, DWORD PTR [edx+36]
	mov	DWORD PTR _i$[ebp], edx
	test	edx, edx
	jns	$LL38@region_abs
	pop	edi
	pop	esi
	pop	ebx
$LN37@region_abs:

; 795  :         break;
; 796  :       }
; 797  :     }
; 798  :   }
; 799  :   if ( mindeg_debug_level > 1 ) 

	cmp	DWORD PTR _mindeg_debug_level, 1
	jle	SHORT $LN1@region_abs

; 800  :       printf("Absorbed %d; max size %d\n",absorbcount,maxab);

	mov	edx, DWORD PTR _maxab$[ebp]
	mov	eax, DWORD PTR _absorbcount$[ebp]
	push	edx
	push	eax
	push	OFFSET ??_C@_0BK@BDDPNPFE@Absorbed?5?$CFd?$DL?5max?5size?5?$CFd?6?$AA@
	call	_printf
	add	esp, 12					; 0000000cH
$LN1@region_abs:

; 801  : } // end  region_absorb()

	mov	esp, ebp
	pop	ebp
	ret	0
_region_absorb ENDP
_TEXT	ENDS
PUBLIC	_degree_compare
; Function compile flags: /Ogtp
;	COMDAT _degree_compare
_TEXT	SEGMENT
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
_degree_compare PROC					; COMDAT

; 814  : { int diff = s1->degree - s2->degree;

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _s1$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _s2$[ebp]
	sub	eax, DWORD PTR [ecx+8]

; 815  : 
; 816  :   if ( s1->flag & MD_AUG_CON )

	test	BYTE PTR [edx+12], 1
	je	SHORT $LN3@degree_com

; 817  :   { if ( s2->flag & MD_AUG_CON ) 

	test	BYTE PTR [ecx+12], 1

; 818  :       return (s1->height < s2->height) ? -1 : 1;  

	jne	SHORT $LN1@degree_com

; 823  :   return (s1->height < s2->height) ? -1 : 1;  

	mov	eax, 1

; 824  :   /* high order, since high first */
; 825  : } // end degree_compare()

	pop	ebp
	ret	0
$LN3@degree_com:

; 819  :     else return 1;
; 820  :   }
; 821  :   if ( s2->flag & MD_AUG_CON ) return -1;

	test	BYTE PTR [ecx+12], 1
	je	SHORT $LN2@degree_com
$LN14@degree_com:
	or	eax, -1

; 824  :   /* high order, since high first */
; 825  : } // end degree_compare()

	pop	ebp
	ret	0
$LN2@degree_com:

; 822  :   if ( diff ) return diff;

	test	eax, eax
	jne	SHORT $LN6@degree_com
$LN1@degree_com:

; 823  :   return (s1->height < s2->height) ? -1 : 1;  

	fld	DWORD PTR [edx+16]
	fld	DWORD PTR [ecx+16]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN14@degree_com
	mov	eax, 1
$LN6@degree_com:

; 824  :   /* high order, since high first */
; 825  : } // end degree_compare()

	pop	ebp
	ret	0
_degree_compare ENDP
_TEXT	ENDS
PUBLIC	_exact_degree
; Function compile flags: /Ogtp
;	COMDAT _exact_degree
_TEXT	SEGMENT
_i$ = -4						; size = 4
_degree$ = 8						; size = 4
_S$ = 8							; size = 4
_s$ = 12						; size = 4
_exact_degree PROC					; COMDAT

; 841  : { int i,j,degree;

	push	ebp
	mov	ebp, esp
	push	ecx

; 842  :   struct region *r;
; 843  :   struct supernode *ss;
; 844  : 
; 845  :   stimestamp += 2; /* for current supernode */

	mov	eax, DWORD PTR _stimestamp

; 846  :   SSS = S;
; 847  :   for ( i = 0, degree = 0 ; i < s->rcount ; i++ )

	mov	ecx, DWORD PTR _s$[ebp]
	push	ebx
	push	edi
	mov	edi, DWORD PTR _S$[ebp]
	xor	ebx, ebx
	add	eax, 2
	mov	DWORD PTR _SSS, edi
	mov	DWORD PTR _stimestamp, eax
	mov	DWORD PTR _i$[ebp], ebx
	mov	DWORD PTR _degree$[ebp], ebx
	cmp	DWORD PTR [ecx], ebx
	jle	SHORT $LN5@exact_degr
	push	esi
	npad	4
$LL15@exact_degr:

; 848  :   { r = REG(INT(s->rlist)[i]);

	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edi+92]
	add	edx, ebx
	mov	edx, DWORD PTR [ecx+edx*4]
	lea	edx, DWORD PTR [ecx+edx*4]

; 849  :     for ( j = 0 ; j < r->supercount ; j++ )

	xor	esi, esi
	cmp	DWORD PTR [edx+12], esi
	jle	SHORT $LN6@exact_degr
$LL4@exact_degr:

; 850  :     { ss = slist + INT(r->superlist)[j];

	mov	ecx, DWORD PTR [edx+16]
	mov	ebx, DWORD PTR [edi+92]
	add	ecx, esi
	mov	ecx, DWORD PTR [ebx+ecx*4]
	imul	ecx, 44					; 0000002cH
	add	ecx, DWORD PTR _slist

; 851  :       if ( ss->stimestamp < stimestamp )

	cmp	DWORD PTR [ecx+32], eax
	jge	SHORT $LN3@exact_degr

; 852  :       { degree += ss->vercount ; ss->stimestamp = stimestamp; }

	mov	ebx, DWORD PTR [ecx+24]
	add	DWORD PTR _degree$[ebp], ebx
	mov	DWORD PTR [ecx+32], eax
$LN3@exact_degr:

; 849  :     for ( j = 0 ; j < r->supercount ; j++ )

	inc	esi
	cmp	esi, DWORD PTR [edx+12]
	jl	SHORT $LL4@exact_degr
	mov	ebx, DWORD PTR _i$[ebp]
$LN6@exact_degr:

; 846  :   SSS = S;
; 847  :   for ( i = 0, degree = 0 ; i < s->rcount ; i++ )

	mov	edx, DWORD PTR _s$[ebp]
	inc	ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ebx, DWORD PTR [edx]
	jl	SHORT $LL15@exact_degr
	pop	esi
$LN5@exact_degr:

; 853  :     }
; 854  :   }
; 855  :   return degree - s->vercount;

	mov	eax, DWORD PTR _degree$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	sub	eax, DWORD PTR [ecx+24]
	pop	edi
	pop	ebx

; 856  : } // end exact_degree()

	mov	esp, ebp
	pop	ebp
	ret	0
_exact_degree ENDP
_TEXT	ENDS
PUBLIC	_exact_sdegree
; Function compile flags: /Ogtp
;	COMDAT _exact_sdegree
_TEXT	SEGMENT
_i$ = -8						; size = 4
_degree$ = -4						; size = 4
_S$ = 8							; size = 4
_s$ = 12						; size = 4
_exact_sdegree PROC					; COMDAT

; 873  : { int i,j,degree;

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 874  :   struct region *r;
; 875  :   struct supernode *ss;
; 876  : 
; 877  :   stimestamp++; /* for current supernode */
; 878  :   for ( i = 0, degree = 0 ; i < s->rcount ; i++ )

	mov	edx, DWORD PTR _s$[ebp]
	push	edi
	mov	edi, DWORD PTR _stimestamp
	xor	eax, eax
	inc	edi
	xor	ecx, ecx
	mov	DWORD PTR _stimestamp, edi
	mov	DWORD PTR _i$[ebp], eax
	mov	DWORD PTR _degree$[ebp], ecx
	cmp	DWORD PTR [edx], eax
	jle	SHORT $LN5@exact_sdeg
	push	ebx
	mov	ebx, DWORD PTR _S$[ebp]
	push	esi
	npad	6
$LL16@exact_sdeg:

; 879  :   { r = REG(INT(s->rlist)[i]);

	mov	edx, DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ebx+92]
	add	edx, eax
	mov	edx, DWORD PTR [ecx+edx*4]
	lea	edx, DWORD PTR [ecx+edx*4]

; 880  :     for ( j = 0 ; j < r->supercount ; j++ )

	xor	esi, esi
	cmp	DWORD PTR [edx+12], esi
	jle	SHORT $LN6@exact_sdeg
$LL4@exact_sdeg:

; 881  :     { ss = slist + INT(r->superlist)[j];

	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [ebx+92]
	add	eax, esi
	mov	ecx, DWORD PTR [ecx+eax*4]
	imul	ecx, 44					; 0000002cH
	add	ecx, DWORD PTR _slist

; 882  :       if ( ss->stimestamp < stimestamp )

	cmp	DWORD PTR [ecx+32], edi
	jge	SHORT $LN3@exact_sdeg

; 883  :       { degree++ ; ss->stimestamp = stimestamp; }

	inc	DWORD PTR _degree$[ebp]
	mov	DWORD PTR [ecx+32], edi
$LN3@exact_sdeg:

; 880  :     for ( j = 0 ; j < r->supercount ; j++ )

	inc	esi
	cmp	esi, DWORD PTR [edx+12]
	jl	SHORT $LL4@exact_sdeg
	mov	eax, DWORD PTR _i$[ebp]
$LN6@exact_sdeg:

; 874  :   struct region *r;
; 875  :   struct supernode *ss;
; 876  : 
; 877  :   stimestamp++; /* for current supernode */
; 878  :   for ( i = 0, degree = 0 ; i < s->rcount ; i++ )

	mov	edx, DWORD PTR _s$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [edx]
	jl	SHORT $LL16@exact_sdeg

; 884  :     }
; 885  :   }
; 886  :   return degree;

	mov	eax, DWORD PTR _degree$[ebp]
	pop	esi
	pop	ebx
$LN5@exact_sdeg:
	pop	edi

; 887  : } // end exact_sdegree()

	mov	esp, ebp
	pop	ebp
	ret	0
_exact_sdegree ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DM@DKPKLKLE@Internal?5error?3?5degree_sort?$CI?$CJ?5ha@ ; `string'
PUBLIC	_degree_sort
EXTRN	_kb_error:PROC
_BSS	SEGMENT
_heapcount DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DM@DKPKLKLE@Internal?5error?3?5degree_sort?$CI?$CJ?5ha@
CONST	SEGMENT
??_C@_0DM@DKPKLKLE@Internal?5error?3?5degree_sort?$CI?$CJ?5ha@ DB 'Intern'
	DB	'al error: degree_sort() has heapcount != supercount.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _degree_sort
_TEXT	SEGMENT
_s$ = -4						; size = 4
_S$ = 8							; size = 4
_degree_sort PROC					; COMDAT

; 898  : { int n;

	push	ebp
	mov	ebp, esp
	push	ecx

; 899  :   struct supernode *s;
; 900  :   int spot;
; 901  : 
; 902  :   heapcount = 0; 
; 903  :   for ( n = superstart ; n >= 0 ; n = s->next )

	mov	eax, DWORD PTR _superstart
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR _heapcount, ebx
	test	eax, eax
	js	$LN8@degree_sor
	push	esi
	push	edi
	npad	4
$LL10@degree_sor:

; 904  :   { s = slist + n;

	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR _slist
	mov	edi, eax

; 905  :     if ( s->rcount == 0 ) continue; /* empty */

	cmp	DWORD PTR [edi], 0
	mov	DWORD PTR _s$[ebp], edi
	je	SHORT $LN9@degree_sor

; 906  :     /* calculate degree */
; 907  :     if ( s->rtimestamp > old_rtimestamp ) 

	mov	eax, DWORD PTR _old_rtimestamp
	cmp	DWORD PTR [edi+28], eax
	jle	SHORT $LN6@degree_sor

; 908  :       s->degree = exact_degree(S,s);

	mov	ecx, DWORD PTR _S$[ebp]
	push	edi
	push	ecx
	call	_exact_degree
	add	esp, 8
	mov	DWORD PTR [edi+8], eax
$LN6@degree_sor:

; 909  :     /* insert in heap */
; 910  :     spot = ++heapcount;    /* using heap[1] as root for convenience */

	inc	ebx
	mov	DWORD PTR _heapcount, ebx
	mov	esi, ebx

; 911  :     while ( spot>1 ) /* filter down */

	cmp	ebx, 1
	jle	SHORT $LN3@degree_sor
	npad	5
$LL5@degree_sor:

; 912  :     { 
; 913  :       if ( degree_compare(s,superheap[spot>>1]) < 0 )

	mov	edx, DWORD PTR _superheap
	mov	eax, DWORD PTR _s$[ebp]
	mov	edi, esi
	sar	edi, 1
	mov	ebx, DWORD PTR [edx+edi*4]
	push	ebx
	push	eax
	call	_degree_compare
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN19@degree_sor

; 914  :         superheap[spot] = superheap[spot>>1];

	mov	ecx, DWORD PTR _superheap
	mov	DWORD PTR [ecx+esi*4], ebx

; 915  :       else break;
; 916  :       spot >>= 1;

	mov	esi, edi
	cmp	esi, 1
	jg	SHORT $LL5@degree_sor
$LN19@degree_sor:

; 911  :     while ( spot>1 ) /* filter down */

	mov	ebx, DWORD PTR _heapcount
	mov	edi, DWORD PTR _s$[ebp]
$LN3@degree_sor:

; 917  :     }
; 918  :     superheap[spot] = s;

	mov	edx, DWORD PTR _superheap
	mov	DWORD PTR [edx+esi*4], edi
$LN9@degree_sor:

; 899  :   struct supernode *s;
; 900  :   int spot;
; 901  : 
; 902  :   heapcount = 0; 
; 903  :   for ( n = superstart ; n >= 0 ; n = s->next )

	mov	eax, DWORD PTR [edi+36]
	test	eax, eax
	jns	$LL10@degree_sor
	pop	edi
	pop	esi
$LN8@degree_sor:

; 919  :   }
; 920  :   if ( heapcount != supercount )

	cmp	ebx, DWORD PTR _supercount
	pop	ebx
	je	SHORT $LN1@degree_sor

; 921  :    kb_error(2467,"Internal error: degree_sort() has heapcount != supercount.\n",
; 922  :      RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DM@DKPKLKLE@Internal?5error?3?5degree_sort?$CI?$CJ?5ha@
	push	2467					; 000009a3H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN1@degree_sor:

; 923  : } // end degree_sort()

	mov	esp, ebp
	pop	ebp
	ret	0
_degree_sort ENDP
_TEXT	ENDS
PUBLIC	??_C@_09GPABKGMJ@?5?5?5elim?3?5?$AA@		; `string'
PUBLIC	??_C@_03JDANDILB@?$CFd?5?$AA@			; `string'
PUBLIC	??_C@_08CEFHCKEH@Border?3?5?$AA@		; `string'
PUBLIC	??_C@_0CL@NPGBJNFG@New?5region?5?$CFd?5size?5?$CFd?5vercount?5?$CF@ ; `string'
PUBLIC	??_C@_0BM@HNAECILK@Merging?5region?5?$CFd?5with?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CO@OGBDNAHH@Incorporating?5small?5region?5?$CFd?5in@ ; `string'
PUBLIC	??_C@_0BN@CCEMFIAN@Dropping?5nodeless?5region?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0CJ@NHJNPHLH@vercount?5?$CFd?5?$CB?$DN?5degree?5?$CFd?0?5supern@ ; `string'
PUBLIC	??_C@_0CG@PMEADHKP@Eliminating?5supernode?5?$CFld?0?5size?5@ ; `string'
PUBLIC	_mass_eliminate
EXTRN	_mindeg_min_region_size:DWORD
_BSS	SEGMENT
_vtimestamp DD	01H DUP (?)
_rtimestamp DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09GPABKGMJ@?5?5?5elim?3?5?$AA@
CONST	SEGMENT
??_C@_09GPABKGMJ@?5?5?5elim?3?5?$AA@ DB '   elim: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JDANDILB@?$CFd?5?$AA@
CONST	SEGMENT
??_C@_03JDANDILB@?$CFd?5?$AA@ DB '%d ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CEFHCKEH@Border?3?5?$AA@
CONST	SEGMENT
??_C@_08CEFHCKEH@Border?3?5?$AA@ DB 'Border: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NPGBJNFG@New?5region?5?$CFd?5size?5?$CFd?5vercount?5?$CF@
CONST	SEGMENT
??_C@_0CL@NPGBJNFG@New?5region?5?$CFd?5size?5?$CFd?5vercount?5?$CF@ DB 'N'
	DB	'ew region %d size %d vercount %d son %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HNAECILK@Merging?5region?5?$CFd?5with?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@HNAECILK@Merging?5region?5?$CFd?5with?5?$CFd?4?6?$AA@ DB 'Mergi'
	DB	'ng region %d with %d.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@OGBDNAHH@Incorporating?5small?5region?5?$CFd?5in@
CONST	SEGMENT
??_C@_0CO@OGBDNAHH@Incorporating?5small?5region?5?$CFd?5in@ DB 'Incorpora'
	DB	'ting small region %d into region %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CCEMFIAN@Dropping?5nodeless?5region?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BN@CCEMFIAN@Dropping?5nodeless?5region?5?$CFd?6?$AA@ DB 'Dropping '
	DB	'nodeless region %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NHJNPHLH@vercount?5?$CFd?5?$CB?$DN?5degree?5?$CFd?0?5supern@
CONST	SEGMENT
??_C@_0CJ@NHJNPHLH@vercount?5?$CFd?5?$CB?$DN?5degree?5?$CFd?0?5supern@ DB 'v'
	DB	'ercount %d != degree %d, supernode %ld', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PMEADHKP@Eliminating?5supernode?5?$CFld?0?5size?5@
CONST	SEGMENT
??_C@_0CG@PMEADHKP@Eliminating?5supernode?5?$CFld?0?5size?5@ DB 'Eliminat'
	DB	'ing supernode %ld, size %ld.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _mass_eliminate
_TEXT	SEGMENT
_size$ = -32						; size = 4
tv1177 = -28						; size = 4
tv1155 = -28						; size = 4
tv1102 = -28						; size = 4
tv828 = -28						; size = 4
tv808 = -28						; size = 4
_newslist$ = -24					; size = 4
_scount$ = -20						; size = 4
_newvlist$ = -16					; size = 4
_rkeep$ = -12						; size = 4
_r$ = -12						; size = 4
_rk$ = -8						; size = 4
_k$ = -8						; size = 4
_sontotal$ = -8						; size = 4
_vercount$ = -4						; size = 4
_S$ = 8							; size = 4
tv1100 = 12						; size = 4
_i$ = 12						; size = 4
_s$ = 12						; size = 4
_mass_eliminate PROC					; COMDAT

; 935  : { int i,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi

; 945  : 
; 946  :   /* check independence and gather son elim totals */
; 947  :   for ( i = 0 ; i < s->rcount ; i++ )

	mov	esi, DWORD PTR _S$[ebp]
	push	edi
	mov	edi, DWORD PTR _s$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _sontotal$[ebp], ecx
	cmp	DWORD PTR [edi], ecx
	jle	SHORT $LN56@mass_elimi

; 936  :   struct region *r,*rk;
; 937  :   struct md_vertex *v;
; 938  :   int newvlist;
; 939  :   int newslist;
; 940  :   int vercount;
; 941  :   int size,ssize;
; 942  :   int scount;
; 943  :   int rkeep;
; 944  :   int sontotal = 0; /* of elim nodes of sons */

	mov	edx, DWORD PTR [esi+92]
	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [edx+eax*4]
$LL58@mass_elimi:

; 948  :   { int rnum = INT(s->rlist)[i];
; 949  :     r = REG(rnum);

	mov	ebx, DWORD PTR [edx]
	mov	eax, DWORD PTR [esi+92]
	lea	eax, DWORD PTR [eax+ebx*4]

; 950  :     if ( r->timestamp == rtimestamp ) return; /* not independent */

	mov	ebx, DWORD PTR [eax+20]
	cmp	ebx, DWORD PTR _rtimestamp
	je	$LN59@mass_elimi

; 951  :     if ( r->son < 0 )

	cmp	DWORD PTR [eax+28], 0
	jge	SHORT $LN57@mass_elimi

; 952  :       sontotal += r->size - r->vercount;

	mov	ebx, DWORD PTR [eax+32]
	sub	ebx, DWORD PTR [eax]
	add	DWORD PTR _sontotal$[ebp], ebx
$LN57@mass_elimi:

; 945  : 
; 946  :   /* check independence and gather son elim totals */
; 947  :   for ( i = 0 ; i < s->rcount ; i++ )

	inc	ecx
	add	edx, 4
	cmp	ecx, DWORD PTR [edi]
	jl	SHORT $LL58@mass_elimi
$LN56@mass_elimi:

; 953  :   }
; 954  :   if ( mindeg_debug_level >= 2 )

	cmp	DWORD PTR _mindeg_debug_level, 2
	jl	SHORT $LN87@mass_elimi

; 955  :      printf("Eliminating supernode %ld, size %ld.\n",
; 956  :        (long)(s-slist),(long)(s->vercount));

	mov	ecx, DWORD PTR [edi+24]
	push	ecx
	mov	ecx, edi
	sub	ecx, DWORD PTR _slist
	mov	eax, 780903145				; 2e8ba2e9H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	OFFSET ??_C@_0CG@PMEADHKP@Eliminating?5supernode?5?$CFld?0?5size?5@
	call	_printf
	add	esp, 12					; 0000000cH
$LN87@mass_elimi:

; 957  :   /* mark timestamps */
; 958  :   for ( i = 0 ; i < s->rcount ; i++ )

	xor	eax, eax
	cmp	DWORD PTR [edi], eax
	jle	SHORT $LN50@mass_elimi
	mov	edx, DWORD PTR _rtimestamp
	npad	2
$LL52@mass_elimi:

; 959  :   { r = REG(INT(s->rlist)[i]);
; 960  :     r->timestamp = rtimestamp;

	mov	ebx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+92]
	add	ebx, eax
	mov	ebx, DWORD PTR [ecx+ebx*4]
	inc	eax
	mov	DWORD PTR [ecx+ebx*4+20], edx
	cmp	eax, DWORD PTR [edi]
	jl	SHORT $LL52@mass_elimi
$LN50@mass_elimi:

; 961  :   }
; 962  : 
; 963  :   /* create merged supernode and vertex lists */
; 964  :   /* with eliminated supernode vertices at end */
; 965  :   if ( sontotal > mindeg_min_region_size )

	mov	ecx, DWORD PTR _sontotal$[ebp]
	cmp	ecx, DWORD PTR _mindeg_min_region_size
	jle	SHORT $LN49@mass_elimi

; 966  :     sontotal = 0; /* don't merge with sons */

	mov	DWORD PTR _sontotal$[ebp], 0
$LN49@mass_elimi:

; 967  :   size = s->degree + s->vercount + sontotal;

	mov	eax, DWORD PTR [edi+8]
	add	eax, DWORD PTR _sontotal$[ebp]
	add	eax, DWORD PTR [edi+24]

; 968  :   newvlist = md_alloc(S,size*sizeof(int));

	lea	edx, DWORD PTR [eax*4]
	push	edx
	push	esi
	mov	DWORD PTR _size$[ebp], eax
	call	_md_alloc

; 969  :   ssize = exact_sdegree(S,s);

	push	edi
	push	esi
	mov	DWORD PTR _newvlist$[ebp], eax
	call	_exact_sdegree
	mov	ebx, eax

; 970  :   newslist = md_alloc(S,ssize*sizeof(int));

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	push	esi
	call	_md_alloc
	mov	DWORD PTR _newslist$[ebp], eax

; 971  : 
; 972  :   /* first, elim supernode at end */
; 973  :   vtimestamp++; /* new round */

	mov	eax, 1

; 974  :   stimestamp++; /* new round */

	add	DWORD PTR _stimestamp, eax
	add	DWORD PTR _vtimestamp, eax

; 975  :   INT(newslist)[ssize-1] = (int)(s-slist);

	mov	ecx, edi
	sub	ecx, DWORD PTR _slist
	mov	eax, 780903145				; 2e8ba2e9H
	imul	ecx
	mov	eax, DWORD PTR [esi+92]
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	edx, DWORD PTR _newslist$[ebp]
	add	edx, ebx
	mov	DWORD PTR [eax+edx*4-4], ecx

; 976  :   s->stimestamp = stimestamp;

	mov	ecx, DWORD PTR _stimestamp

; 977  :   vercount = s->degree;

	mov	edx, DWORD PTR [edi+8]

; 978  :   for ( k = 0 ; k < s->vercount ; k++ )

	xor	eax, eax
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+32], ecx
	mov	DWORD PTR _vercount$[ebp], edx
	cmp	DWORD PTR [edi+24], eax
	jle	$LN46@mass_elimi

; 967  :   size = s->degree + s->vercount + sontotal;

	mov	ecx, DWORD PTR _elim_count
	add	edx, DWORD PTR _newvlist$[ebp]
	add	ecx, ecx
	add	ecx, ecx
	add	edx, edx
	mov	DWORD PTR tv1100[ebp], ecx
	add	edx, edx
	jmp	SHORT $LN48@mass_elimi
$LL84@mass_elimi:
	mov	edx, DWORD PTR tv1102[ebp]
$LN48@mass_elimi:

; 979  :   { INT(newvlist)[vercount++] = INT(s->verlist)[k];

	mov	ebx, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [esi+92]
	add	ebx, eax
	mov	ebx, DWORD PTR [ecx+ebx*4]
	mov	DWORD PTR [ecx+edx], ebx

; 980  :     vlist[INT(s->verlist)[k]].timestamp = vtimestamp;

	mov	ecx, DWORD PTR [esi+92]
	mov	ebx, DWORD PTR _vlist
	add	edx, 4
	mov	DWORD PTR tv1102[ebp], edx
	mov	edx, DWORD PTR [edi+20]
	inc	DWORD PTR _vercount$[ebp]
	add	edx, eax
	mov	ecx, DWORD PTR [ecx+edx*4]
	lea	edx, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR _vtimestamp
	mov	DWORD PTR [ebx+edx*4+4], ecx

; 981  :     S->P[elim_count+k] = INT(s->verlist)[k];

	mov	edx, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [esi+92]
	mov	ebx, DWORD PTR [esi+68]
	add	edx, eax
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR tv1100[ebp]
	add	DWORD PTR tv1100[ebp], 4
	mov	DWORD PTR [ecx+ebx], edx

; 982  :     S->IP[INT(s->verlist)[k]] = elim_count+k;

	mov	ecx, DWORD PTR [edi+20]
	mov	ebx, DWORD PTR [esi+92]
	mov	edx, DWORD PTR _elim_count
	add	ecx, eax
	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	ebx, DWORD PTR [esi+72]
	add	edx, eax
	inc	eax
	mov	DWORD PTR [ebx+ecx*4], edx
	cmp	eax, DWORD PTR [edi+24]
	jl	SHORT $LL84@mass_elimi
$LN46@mass_elimi:

; 983  :   }
; 984  :   /* and sons, if merging */
; 985  :   if ( sontotal > 0 )

	cmp	DWORD PTR _sontotal$[ebp], 0
	jle	SHORT $LN42@mass_elimi

; 986  :     for ( i = 0 ; i < s->rcount ; i++ )

	xor	ecx, ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR [edi], ecx
	jle	SHORT $LN42@mass_elimi
$LL95@mass_elimi:

; 987  :     { int j;
; 988  :       r = REG(INT(s->rlist)[i]);

	mov	eax, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [esi+92]
	add	eax, ecx
	mov	eax, DWORD PTR [edx+eax*4]

; 989  :       if ( r->son >= 0 ) continue;

	cmp	DWORD PTR [edx+eax*4+28], 0
	lea	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _r$[ebp], edx
	jge	SHORT $LN43@mass_elimi

; 990  :       for ( j = r->vercount ; j < r->size ; j++ )

	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [edx+32]
	jge	SHORT $LN43@mass_elimi
	mov	ebx, DWORD PTR _vercount$[ebp]
	add	ebx, DWORD PTR _newvlist$[ebp]
	add	ebx, ebx
	add	ebx, ebx
	npad	3
$LL40@mass_elimi:

; 991  :         INT(newvlist)[vercount++] = INT(r->verlist)[j];

	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [esi+92]
	inc	DWORD PTR _vercount$[ebp]
	add	edx, eax
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx+ebx], edx
	mov	edx, DWORD PTR _r$[ebp]
	inc	eax
	add	ebx, 4
	cmp	eax, DWORD PTR [edx+32]
	jl	SHORT $LL40@mass_elimi

; 990  :       for ( j = r->vercount ; j < r->size ; j++ )

	mov	ecx, DWORD PTR _i$[ebp]
$LN43@mass_elimi:

; 986  :     for ( i = 0 ; i < s->rcount ; i++ )

	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, DWORD PTR [edi]
	jl	SHORT $LL95@mass_elimi
$LN42@mass_elimi:

; 992  :     }
; 993  :   
; 994  :   vercount = 0;

	xor	eax, eax
	xor	ebx, ebx
	mov	DWORD PTR _vercount$[ebp], ebx

; 995  :   scount = 0;

	mov	DWORD PTR _scount$[ebp], eax

; 996  :   for ( i = 0 ; i < s->rcount ; i++ )

	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR [edi], eax
	jle	$LN35@mass_elimi
	npad	3
$LL37@mass_elimi:

; 997  :   { struct supernode *ss;
; 998  :     r = REG(INT(s->rlist)[i]);

	mov	ecx, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [esi+92]
	add	ecx, eax
	mov	edx, DWORD PTR [ebx+ecx*4]
	lea	ebx, DWORD PTR [ebx+edx*4]

; 999  :     for ( k = 0 ; k < r->supercount ; k++ )

	xor	edx, edx
	mov	DWORD PTR _r$[ebp], ebx
	mov	DWORD PTR _k$[ebp], edx
	cmp	DWORD PTR [ebx+12], edx
	jle	SHORT $LN32@mass_elimi

; 997  :   { struct supernode *ss;
; 998  :     r = REG(INT(s->rlist)[i]);

	mov	eax, DWORD PTR _scount$[ebp]
	add	eax, DWORD PTR _newslist$[ebp]
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1155[ebp], eax
$LL34@mass_elimi:

; 1000 :     { ss = slist + INT(r->superlist)[k];

	mov	ecx, DWORD PTR [ebx+16]
	add	ecx, edx
	mov	edx, DWORD PTR [esi+92]
	add	ecx, ecx
	add	ecx, ecx
	mov	eax, DWORD PTR [ecx+edx]

; 1001 :       if ( ss->stimestamp == stimestamp ) continue;

	mov	edx, DWORD PTR _stimestamp
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR _slist
	cmp	DWORD PTR [eax+32], edx
	je	SHORT $LN33@mass_elimi

; 1002 :       INT(newslist)[scount++] = INT(r->superlist)[k];

	mov	edx, DWORD PTR [esi+92]
	mov	ebx, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR tv1155[ebp]
	inc	DWORD PTR _scount$[ebp]
	mov	DWORD PTR [edx+ecx], ebx

; 1003 :       ss->stimestamp = stimestamp;
; 1004 :       ss->rtimestamp = rtimestamp;

	mov	edx, DWORD PTR _rtimestamp
	mov	ebx, DWORD PTR _r$[ebp]
	add	ecx, 4
	mov	DWORD PTR tv1155[ebp], ecx
	mov	ecx, DWORD PTR _stimestamp
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+28], edx
$LN33@mass_elimi:

; 999  :     for ( k = 0 ; k < r->supercount ; k++ )

	mov	edx, DWORD PTR _k$[ebp]
	inc	edx
	mov	DWORD PTR _k$[ebp], edx
	cmp	edx, DWORD PTR [ebx+12]
	jl	SHORT $LL34@mass_elimi
$LN32@mass_elimi:

; 1005 :     }
; 1006 :     for ( k = 0 ; k < r->vercount ; k++ )

	xor	ecx, ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	DWORD PTR [ebx], ecx
	jle	SHORT $LN36@mass_elimi
	mov	eax, DWORD PTR _vercount$[ebp]
	add	eax, DWORD PTR _newvlist$[ebp]
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1177[ebp], eax
$LL30@mass_elimi:

; 1007 :     { v = vlist + INT(r->verlist)[k];

	mov	eax, DWORD PTR [ebx+4]
	add	eax, ecx
	mov	ecx, DWORD PTR [esi+92]
	add	eax, eax
	add	eax, eax
	mov	ecx, DWORD PTR [eax+ecx]
	lea	edx, DWORD PTR [ecx+ecx*2]
	mov	ecx, DWORD PTR _vlist
	lea	edx, DWORD PTR [ecx+edx*4]

; 1008 :       if ( v->timestamp == vtimestamp ) continue;

	mov	ecx, DWORD PTR _vtimestamp
	cmp	DWORD PTR [edx+4], ecx
	je	SHORT $LN29@mass_elimi

; 1009 :       INT(newvlist)[vercount++] = INT(r->verlist)[k];

	mov	ecx, DWORD PTR [esi+92]
	mov	ebx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR tv1177[ebp]
	inc	DWORD PTR _vercount$[ebp]
	mov	DWORD PTR [ecx+eax], ebx

; 1010 :       v->timestamp = vtimestamp;

	mov	ebx, DWORD PTR _r$[ebp]
	add	eax, 4
	mov	DWORD PTR tv1177[ebp], eax
	mov	eax, DWORD PTR _vtimestamp
	mov	DWORD PTR [edx+4], eax
$LN29@mass_elimi:

; 1005 :     }
; 1006 :     for ( k = 0 ; k < r->vercount ; k++ )

	mov	ecx, DWORD PTR _k$[ebp]
	inc	ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ecx, DWORD PTR [ebx]
	jl	SHORT $LL30@mass_elimi
$LN36@mass_elimi:

; 996  :   for ( i = 0 ; i < s->rcount ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [edi]
	jl	$LL37@mass_elimi
	mov	ebx, DWORD PTR _vercount$[ebp]
$LN35@mass_elimi:

; 1011 :     }
; 1012 :   }
; 1013 : 
; 1014 :   /* set up new region */
; 1015 :   rkeep = region_alloc(S);

	push	esi
	call	_region_alloc

; 1016 :   rk = REG(rkeep);
; 1017 :   rk->verlist = newvlist;
; 1018 :   rk->vercount = vercount;
; 1019 :   rk->superlist = newslist;

	mov	edx, DWORD PTR _newslist$[ebp]
	lea	ecx, DWORD PTR [eax*4]
	mov	DWORD PTR _rkeep$[ebp], eax
	mov	eax, DWORD PTR [esi+92]
	add	eax, ecx
	mov	ecx, DWORD PTR _newvlist$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1020 :   rk->supercount = scount;

	mov	ecx, DWORD PTR _scount$[ebp]
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+16], edx
	mov	DWORD PTR [eax+12], ecx

; 1021 :   rk->son = -1;

	mov	DWORD PTR [eax+28], -1

; 1022 :   if ( vercount != s->degree ) 

	mov	ecx, DWORD PTR [edi+8]
	add	esp, 4
	mov	DWORD PTR _rk$[ebp], eax
	cmp	ebx, ecx
	je	SHORT $LN26@mass_elimi

; 1023 :      printf("vercount %d != degree %d, supernode %ld\n",vercount,s->degree,
; 1024 :              (long)(s-slist));

	mov	edx, edi
	sub	edx, DWORD PTR _slist
	mov	eax, 780903145				; 2e8ba2e9H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	ecx
	push	ebx
	push	OFFSET ??_C@_0CJ@NHJNPHLH@vercount?5?$CFd?5?$CB?$DN?5degree?5?$CFd?0?5supern@
	call	_printf
	add	esp, 16					; 00000010H
$LN26@mass_elimi:

; 1025 :      
; 1026 :   /* mark all old regions as merged and remove from active list */
; 1027 :   for ( i = 0 ; i < s->rcount ; i++ )

	cmp	DWORD PTR [edi], 0
	mov	DWORD PTR _i$[ebp], 0
	jle	$LN23@mass_elimi
$LL92@mass_elimi:

; 1028 :   {  int rnum = INT(s->rlist)[i]; 

	mov	eax, DWORD PTR [esi+92]
	mov	ecx, DWORD PTR [edi+4]
	add	ecx, DWORD PTR _i$[ebp]

; 1029 :      r = REG(rnum);
; 1030 :      r->merged = rkeep;

	mov	edx, DWORD PTR _rkeep$[ebp]
	mov	ebx, DWORD PTR [eax+ecx*4]

; 1031 :      if ( (r->size > r->vercount) || ( r->son >= 0 ) )

	mov	ecx, DWORD PTR [eax+ebx*4+32]
	mov	DWORD PTR [eax+ebx*4+24], edx
	mov	edx, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR tv808[ebp], eax
	cmp	ecx, edx
	jg	SHORT $LN85@mass_elimi
	cmp	DWORD PTR [eax+ebx*4+28], 0
	jge	SHORT $LN85@mass_elimi

; 1035 :      }
; 1036 :      else if ( mindeg_debug_level >= 5 )

	cmp	DWORD PTR _mindeg_debug_level, 5
	jl	SHORT $LN86@mass_elimi

; 1037 :      { if (r->size == r->vercount)

	cmp	ecx, edx
	jne	SHORT $LN18@mass_elimi

; 1038 :          printf("Dropping nodeless region %d\n",rnum);

	push	ebx
	push	OFFSET ??_C@_0BN@CCEMFIAN@Dropping?5nodeless?5region?5?$CFd?6?$AA@
	call	_printf

; 1039 :        else

	mov	eax, DWORD PTR tv808[ebp]
	add	esp, 8
	jmp	SHORT $LN86@mass_elimi
$LN18@mass_elimi:

; 1040 :          printf("Incorporating small region %d into region %d\n",rnum,rkeep);

	mov	eax, DWORD PTR _rkeep$[ebp]
	push	eax
	push	ebx
	push	OFFSET ??_C@_0CO@OGBDNAHH@Incorporating?5small?5region?5?$CFd?5in@
	call	_printf
	mov	eax, DWORD PTR tv808[ebp]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN86@mass_elimi
$LN85@mass_elimi:

; 1032 :      { /* keep nonleaf regions */
; 1033 :        r->BROTHER = rk->son; 

	mov	ecx, DWORD PTR _rk$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+ebx*4+16], edx

; 1034 :        rk->son = rnum;

	mov	DWORD PTR [ecx+28], ebx
$LN86@mass_elimi:

; 1041 :      }
; 1042 :      if ( r->next >= 0 ) REG(r->next)->prev = r->prev; 

	mov	ecx, DWORD PTR [eax+ebx*4+36]
	lea	edx, DWORD PTR [eax+ebx*4+36]
	mov	DWORD PTR tv828[ebp], edx
	lea	ebx, DWORD PTR [eax+ebx*4+40]
	test	ecx, ecx
	js	SHORT $LN16@mass_elimi
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [esi+92]
	mov	DWORD PTR [eax+ecx*4+40], edx
	mov	edx, DWORD PTR tv828[ebp]
	jmp	SHORT $LN15@mass_elimi
$LN16@mass_elimi:

; 1043 :      else last_region = r->prev;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR _last_region, eax
$LN15@mass_elimi:

; 1044 :      if ( r->prev >= 0 ) REG(r->prev)->next = r->next;

	mov	ebx, DWORD PTR [ebx]
	test	ebx, ebx
	js	SHORT $LN14@mass_elimi
	mov	ecx, DWORD PTR [esi+92]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+ebx*4+36], edx
	jmp	SHORT $LN13@mass_elimi
$LN14@mass_elimi:

; 1045 :      else regionstart = r->next;

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _regionstart, eax
$LN13@mass_elimi:

; 1046 :      if ( mindeg_debug_level >= 5 )

	cmp	DWORD PTR _mindeg_debug_level, 5
	jl	SHORT $LN24@mass_elimi

; 1047 :         printf("Merging region %d with %d.\n",INT(s->rlist)[i],rkeep);

	mov	edx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR _rkeep$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [esi+92]
	push	ecx
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	push	OFFSET ??_C@_0BM@HNAECILK@Merging?5region?5?$CFd?5with?5?$CFd?4?6?$AA@
	call	_printf
	add	esp, 12					; 0000000cH
$LN24@mass_elimi:

; 1025 :      
; 1026 :   /* mark all old regions as merged and remove from active list */
; 1027 :   for ( i = 0 ; i < s->rcount ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [edi]
	jl	$LL92@mass_elimi
$LN23@mass_elimi:

; 1048 :   }
; 1049 : 
; 1050 :   /* eliminate nodes */
; 1051 :   rk = REG(rkeep);

	mov	ecx, DWORD PTR _rkeep$[ebp]
	mov	ebx, DWORD PTR [esi+92]
	lea	eax, DWORD PTR [ecx*4]
	add	ebx, eax

; 1052 :   rk->size = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [ebx+32], eax

; 1053 : 
; 1054 :   if ( mindeg_debug_level >= 5 )

	cmp	DWORD PTR _mindeg_debug_level, 5
	jl	SHORT $LN11@mass_elimi

; 1055 :      printf("New region %d size %d vercount %d son %d.\n",
; 1056 :           rkeep,rk->size,rk->vercount,rk->son);

	mov	edx, DWORD PTR [ebx+28]
	push	edx
	mov	edx, DWORD PTR [ebx]
	push	edx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0CL@NPGBJNFG@New?5region?5?$CFd?5size?5?$CFd?5vercount?5?$CF@
	call	_printf
	add	esp, 20					; 00000014H
$LN11@mass_elimi:

; 1057 :   if ( mindeg_debug_level >= 7 )

	cmp	DWORD PTR _mindeg_debug_level, 7
	jl	$LN4@mass_elimi

; 1058 :   { printf("Border: ");

	push	OFFSET ??_C@_08CEFHCKEH@Border?3?5?$AA@
	call	_printf
	add	esp, 4

; 1059 :     for ( i = 0 ; i < rk->vercount ; i++ )

	cmp	DWORD PTR [ebx], 0
	mov	DWORD PTR _i$[ebp], 0
	jle	SHORT $LN7@mass_elimi
	npad	4
$LL90@mass_elimi:

; 1060 :        printf("%d ",INT(rk->verlist)[i]);

	mov	eax, DWORD PTR [ebx+4]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [esi+92]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	OFFSET ??_C@_03JDANDILB@?$CFd?5?$AA@
	call	_printf
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	esp, 8
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [ebx]
	jl	SHORT $LL90@mass_elimi
$LN7@mass_elimi:

; 1061 :     printf("   elim: ");

	push	OFFSET ??_C@_09GPABKGMJ@?5?5?5elim?3?5?$AA@
	call	_printf

; 1062 :     for ( ; i < rk->size ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	esp, 4
	cmp	eax, DWORD PTR [ebx+32]
	jge	SHORT $LN4@mass_elimi
	npad	6
$LL91@mass_elimi:

; 1063 :        printf("%d ",INT(rk->verlist)[i]);

	mov	ecx, DWORD PTR [ebx+4]
	add	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [esi+92]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	push	OFFSET ??_C@_03JDANDILB@?$CFd?5?$AA@
	call	_printf
	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	esp, 8
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR [ebx+32]
	jl	SHORT $LL91@mass_elimi
$LN4@mass_elimi:

; 1064 :   }
; 1065 :   elim_count += s->vercount;

	mov	ecx, DWORD PTR [edi+24]
	add	DWORD PTR _elim_count, ecx

; 1066 : 
; 1067 :   /* delete this supernode */
; 1068 :   if ( s->next >= 0 ) slist[s->next].prev = s->prev;

	mov	eax, DWORD PTR [edi+36]
	mov	ecx, DWORD PTR _slist
	test	eax, eax
	js	SHORT $LN3@mass_elimi
	mov	edx, DWORD PTR [edi+40]
	imul	eax, 44					; 0000002cH
	mov	DWORD PTR [eax+ecx+40], edx
$LN3@mass_elimi:

; 1069 :   if ( s->prev >= 0 ) slist[s->prev].next = s->next;

	mov	eax, DWORD PTR [edi+40]
	test	eax, eax
	js	SHORT $LN2@mass_elimi
	mov	edx, DWORD PTR [edi+36]
	imul	eax, 44					; 0000002cH
	mov	DWORD PTR [eax+ecx+36], edx
	jmp	SHORT $LN1@mass_elimi
$LN2@mass_elimi:

; 1070 :   else superstart = s->next;

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR _superstart, eax
$LN1@mass_elimi:

; 1071 :   s->verlist = -1;

	mov	DWORD PTR [edi+20], -1

; 1072 :   supercount--;

	dec	DWORD PTR _supercount

; 1073 : 
; 1074 :   s->rcount = 0; /* inactivate */

	mov	DWORD PTR [edi], 0
$LN59@mass_elimi:
	pop	edi
	pop	esi
	pop	ebx

; 1075 : } // end mass_eliminate()

	mov	esp, ebp
	pop	ebp
	ret	0
_mass_eliminate ENDP
_TEXT	ENDS
PUBLIC	__real@4008000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	_groom_regions_recur
_BSS	SEGMENT
	ALIGN	8

_total_flops DQ	01H DUP (?)
_final_versizes DD 01H DUP (?)
_total_fill DD	01H DUP (?)
_final_regions DD 01H DUP (?)
_BSS	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _groom_regions_recur
_TEXT	SEGMENT
_vn$89854 = -4						; size = 4
_S$ = 8							; size = 4
_vd$89855 = 12						; size = 4
_r$ = 12						; size = 4
_groom_regions_recur PROC				; COMDAT

; 1094 : { struct region *rr;

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi

; 1095 :   int son,k;
; 1096 :   
; 1097 :   for ( son = r->son ; son >= 0 ; son = rr->BROTHER )

	mov	esi, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [esi+28]
	push	edi
	mov	edi, DWORD PTR _S$[ebp]
	test	eax, eax
	js	SHORT $LN4@groom_regi
$LL6@groom_regi:

; 1098 :   { rr = REG(son);

	mov	ecx, DWORD PTR [edi+92]
	lea	ebx, DWORD PTR [ecx+eax*4]

; 1099 :     groom_regions_recur(S,rr);

	push	ebx
	push	edi
	call	_groom_regions_recur
	mov	eax, DWORD PTR [ebx+16]
	add	esp, 8
	test	eax, eax
	jns	SHORT $LL6@groom_regi
$LN4@groom_regi:

; 1100 :   }
; 1101 : 
; 1102 :   /* record fills per vertex for later factoring */
; 1103 :   for ( k = r->vercount ; k < r->size ; k++ )

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+32]
	cmp	eax, ecx
	jge	SHORT $LN1@groom_regi
$LL3@groom_regi:

; 1104 :   { int v = INT(r->verlist)[k];

	mov	edx, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [edi+92]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4]

; 1105 :     S->LIA[v] += r->size - (k - r->vercount);

	mov	ebx, DWORD PTR [edi+128]
	sub	ecx, eax
	add	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [ebx+edx*4]
	add	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [esi+32]
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL3@groom_regi
$LN1@groom_regi:

; 1106 :   }
; 1107 : 
; 1108 :   /* gather stats */
; 1109 :   { int vn = r->vercount,vd = r->size;

	mov	ecx, DWORD PTR [esi]
	mov	esi, DWORD PTR [esi+32]
	mov	edx, esi
	mov	DWORD PTR _vd$89855[ebp], edx

; 1110 :     total_fill += (vd*(vd+1) - vn*(vn+1))/2;
; 1111 :     total_flops += ((vd+1.)*vd*(vd+2.) - (vn+1.)*vn*(vn+2.))/3;

	fild	DWORD PTR _vd$89855[ebp]
	mov	DWORD PTR _vn$89854[ebp], ecx
	fild	DWORD PTR _vn$89854[ebp]

; 1112 :   }
; 1113 :   final_regions++;

	inc	DWORD PTR _final_regions
	lea	eax, DWORD PTR [edx+1]
	fld	ST(1)
	imul	eax, edx
	fld1
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	fld	QWORD PTR __real@4000000000000000
	fadd	ST(4), ST(0)
	lea	edx, DWORD PTR [ecx+1]
	fxch	ST(1)
	imul	edx, ecx
	fmulp	ST(4), ST(0)
	fld	ST(2)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(2)
	fxch	ST(2)
	faddp	ST(1), ST(0)
	sub	eax, edx
	cdq
	fmulp	ST(1), ST(0)
	sub	eax, edx
	sar	eax, 1
	fsubp	ST(1), ST(0)
	add	DWORD PTR _total_fill, eax

; 1114 :   final_versizes += r->size;

	add	DWORD PTR _final_versizes, esi
	pop	edi
	fdiv	QWORD PTR __real@4008000000000000
	pop	esi
	pop	ebx
	fadd	QWORD PTR _total_flops
	fstp	QWORD PTR _total_flops

; 1115 : } // end groom_regions_recur()

	mov	esp, ebp
	pop	ebp
	ret	0
_groom_regions_recur ENDP
_TEXT	ENDS
PUBLIC	_compact_recur
_BSS	SEGMENT
_new_ISP_spot DD 01H DUP (?)
_new_ISP DD	01H DUP (?)
; Function compile flags: /Ogtp
_BSS	ENDS
;	COMDAT _compact_recur
_TEXT	SEGMENT
_S$ = 8							; size = 4
_retval$ = 12						; size = 4
_r$ = 12						; size = 4
_compact_recur PROC					; COMDAT

; 1133 : { struct region *rr;

	push	ebp
	mov	ebp, esp
	push	ebx

; 1134 :   int son;
; 1135 :   int *v;
; 1136 :   int retval;
; 1137 :   int *rnumptr;
; 1138 :   int i;
; 1139 : 
; 1140 :   rnumptr = &(r->son);

	mov	ebx, DWORD PTR _r$[ebp]

; 1141 :   for ( son = r->son ; son >= 0 ; son = rr->BROTHER )

	mov	eax, DWORD PTR [ebx+28]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebx+28]
	test	eax, eax
	js	SHORT $LN14@compact_re
$LL6@compact_re:

; 1142 :   { rr = REG(son);

	mov	ecx, DWORD PTR _S$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	lea	esi, DWORD PTR [edx+eax*4]

; 1143 :     *rnumptr = compact_recur(S,rr);

	push	esi
	push	ecx
	call	_compact_recur

; 1144 :     rnumptr = &(((struct region*)(new_ISP + *rnumptr))->BROTHER);

	mov	ecx, DWORD PTR _new_ISP
	mov	DWORD PTR [edi], eax
	lea	edi, DWORD PTR [ecx+eax*4+16]
	mov	eax, DWORD PTR [esi+16]
	add	esp, 8
	test	eax, eax
	jns	SHORT $LL6@compact_re
$LN14@compact_re:

; 1145 :   }
; 1146 : 
; 1147 :   /* now do this region */
; 1148 :   retval = new_ISP_spot;

	mov	edx, DWORD PTR _new_ISP_spot

; 1149 :   rr = (struct region *)(new_ISP + new_ISP_spot);

	mov	eax, DWORD PTR _new_ISP
	lea	eax, DWORD PTR [eax+edx*4]

; 1150 :   *rr = *r;

	mov	ecx, 11					; 0000000bH
	mov	esi, ebx
	mov	edi, eax
	rep movsd

; 1151 :   new_ISP_spot += sizeof(struct region)/sizeof(int);
; 1152 :   v = INT(r->verlist);

	mov	ecx, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR _S$[ebp]
	mov	esi, DWORD PTR [esi+92]
	mov	DWORD PTR _retval$[ebp], edx
	add	edx, 11					; 0000000bH
	lea	esi, DWORD PTR [esi+ecx*4]

; 1153 :   rr->verlist = new_ISP_spot;
; 1154 :   for ( i = 0 ; i < r->size ; i++ )

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR _new_ISP_spot, edx
	cmp	DWORD PTR [ebx+32], ecx
	jle	SHORT $LN13@compact_re
$LL3@compact_re:

; 1155 :     new_ISP[new_ISP_spot++] = v[i];

	mov	eax, DWORD PTR [esi+ecx*4]
	mov	edi, DWORD PTR _new_ISP
	mov	DWORD PTR [edi+edx*4], eax
	inc	edx
	inc	ecx
	mov	DWORD PTR _new_ISP_spot, edx
	cmp	ecx, DWORD PTR [ebx+32]
	jl	SHORT $LL3@compact_re
$LN13@compact_re:

; 1156 : 
; 1157 :   return retval;

	mov	eax, DWORD PTR _retval$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 1158 : 
; 1159 : } // end compact_recur()

	pop	ebp
	ret	0
_compact_recur ENDP
_TEXT	ENDS
PUBLIC	_compact_regions
; Function compile flags: /Ogtp
;	COMDAT _compact_regions
_TEXT	SEGMENT
_S$ = 8							; size = 4
_compact_regions PROC					; COMDAT

; 1169 : { int rnum;

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 1170 :   int *new_rnum;
; 1171 :   int new_NSP;
; 1172 :   struct region *r;
; 1173 : 
; 1174 :   new_NSP = final_regions*sizeof(struct region) + final_versizes*sizeof(int);

	mov	esi, DWORD PTR _final_regions
	imul	esi, 11					; 0000000bH
	add	esi, DWORD PTR _final_versizes
	push	edi

; 1175 :   new_ISP = (int*)temp_calloc(new_NSP,1);

	push	1175					; 00000497H
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	add	esi, esi
	add	esi, esi
	push	1
	push	esi
	call	_kb_temp_calloc
	mov	DWORD PTR _new_ISP, eax

; 1176 :   new_ISP_spot = 0;
; 1177 : 
; 1178 :   new_rnum = &regionstart;
; 1179 :   for ( rnum = regionstart ; rnum >= 0 ; rnum = r->next )

	mov	eax, DWORD PTR _regionstart
	add	esp, 16					; 00000010H
	mov	DWORD PTR _new_ISP_spot, 0
	mov	ebx, OFFSET _regionstart
	test	eax, eax
	js	SHORT $LN1@compact_re@2
	npad	5
$LL3@compact_re@2:

; 1180 :   { r = REG(rnum);

	mov	ecx, DWORD PTR _S$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	lea	edi, DWORD PTR [edx+eax*4]

; 1181 :     *new_rnum = compact_recur(S,r);

	push	edi
	push	ecx
	call	_compact_recur

; 1182 :     new_rnum = &(((struct region*)(new_ISP+*new_rnum))->next);

	mov	ecx, DWORD PTR _new_ISP
	mov	DWORD PTR [ebx], eax
	lea	ebx, DWORD PTR [ecx+eax*4+36]
	mov	eax, DWORD PTR [edi+36]
	add	esp, 8
	test	eax, eax
	jns	SHORT $LL3@compact_re@2
$LN1@compact_re@2:

; 1183 :   }
; 1184 :   temp_free((char*)S->ISP);

	mov	edi, DWORD PTR _S$[ebp]
	mov	edx, DWORD PTR [edi+92]
	push	edx
	call	_temp_free

; 1185 :   S->ISP = new_ISP;

	mov	eax, DWORD PTR _new_ISP
	add	esp, 4

; 1186 :   S->NSP = new_NSP/sizeof(int);  // since new_NSP was in bytes

	shr	esi, 2
	mov	DWORD PTR [edi+88], esi
	mov	DWORD PTR [edi+92], eax
	pop	edi
	pop	esi
	pop	ebx

; 1187 : } // end compact_regions()

	pop	ebp
	ret	0
_compact_regions ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@GELLFHCK@Low?5degree?5?$CFd?4?6?$AA@	; `string'
PUBLIC	_multiple_eliminate
EXTRN	_mindeg_margin:DWORD
_BSS	SEGMENT
_sentinel DB	02cH DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BA@GELLFHCK@Low?5degree?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BA@GELLFHCK@Low?5degree?5?$CFd?4?6?$AA@ DB 'Low degree %d.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _multiple_eliminate
_TEXT	SEGMENT
tv205 = -8						; size = 4
_bounddegree$ = -4					; size = 4
_S$ = 8							; size = 4
_multiple_eliminate PROC				; COMDAT

; 1197 : { 

	push	ebp
	mov	ebp, esp

; 1198 :   int lowdegree;
; 1199 :   int bounddegree; /* cutoff for multiple elimination */
; 1200 :   int spot;
; 1201 : 
; 1202 :   old_rtimestamp = rtimestamp; /* save, so know who changed */

	mov	eax, DWORD PTR _rtimestamp
	mov	DWORD PTR _old_rtimestamp, eax

; 1203 :   rtimestamp++;    /* new round of independence */

	inc	eax
	mov	DWORD PTR _rtimestamp, eax

; 1204 :   lowdegree = superheap[1]->degree;  /* so we know where we started */

	mov	eax, DWORD PTR _superheap
	mov	ecx, DWORD PTR [eax+4]
	sub	esp, 8

; 1205 :   if ( mindeg_debug_level >= 1 ) printf("Low degree %d.\n",lowdegree);

	cmp	DWORD PTR _mindeg_debug_level, 1
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	jl	SHORT $LN9@multiple_e
	push	esi
	push	OFFSET ??_C@_0BA@GELLFHCK@Low?5degree?5?$CFd?4?6?$AA@
	call	_printf
	add	esp, 8
$LN9@multiple_e:

; 1206 : 
; 1207 :   /* using higher bounddegree leads to about 1/3 as many passes through
; 1208 :      main loop, but not much reduction in total time */
; 1209 :   bounddegree = lowdegree+margin;        /* conservative to start with */
; 1210 :   bounddegree = mindeg_margin < lowdegree ? lowdegree+mindeg_margin : 
; 1211 :     2*lowdegree;

	mov	eax, DWORD PTR _mindeg_margin
	cmp	eax, esi
	jge	SHORT $LN12@multiple_e
	add	eax, esi
	mov	DWORD PTR _bounddegree$[ebp], eax
	jmp	SHORT $LN13@multiple_e
$LN12@multiple_e:
	lea	edx, DWORD PTR [esi+esi]
	mov	DWORD PTR _bounddegree$[ebp], edx
$LN13@multiple_e:

; 1212 : 
; 1213 :   sentinel.degree = 2+bounddegree;    /* big degree */

	mov	ecx, DWORD PTR _bounddegree$[ebp]

; 1214 :   sentinel.verlist = 1 << (8*sizeof(int)-2); /* big for degree_compare */
; 1215 :   while ( superheap[1]->degree <= bounddegree )

	mov	edx, DWORD PTR _superheap
	lea	eax, DWORD PTR [ecx+2]
	mov	DWORD PTR _sentinel+8, eax
	mov	DWORD PTR _sentinel+20, 1073741824	; 40000000H
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+8], ecx
	jg	$LN7@multiple_e
	push	ebx
	push	edi
$LL8@multiple_e:

; 1216 :   { 
; 1217 :     mass_eliminate(S,superheap[1]);

	push	eax
	mov	eax, DWORD PTR _S$[ebp]
	push	eax
	call	_mass_eliminate
	add	esp, 8

; 1218 :     /* now adjust heap */
; 1219 :     spot = 1;  /* empty spot */
; 1220 :     for ( ;; )
; 1221 :     { if ( spot*2 > heapcount ) { superheap[spot] = &sentinel;  break; }

	cmp	DWORD PTR _heapcount, 2
	mov	esi, 1
	jl	SHORT $LN17@multiple_e
$LL6@multiple_e:

; 1222 :       if ( spot*2 == heapcount )

	lea	eax, DWORD PTR [esi+esi]
	mov	DWORD PTR tv205[ebp], eax
	cmp	eax, DWORD PTR _heapcount
	je	SHORT $LN18@multiple_e

; 1225 :         break;
; 1226 :       }
; 1227 :       if ( degree_compare(superheap[spot*2],superheap[spot*2+1]) < 0 )

	mov	edi, DWORD PTR _superheap
	mov	ebx, DWORD PTR [edi+esi*8+4]
	mov	eax, DWORD PTR [edi+esi*8]
	push	ebx
	push	eax
	call	_degree_compare
	add	esp, 8
	test	eax, eax
	jns	SHORT $LN2@multiple_e

; 1228 :       { superheap[spot] = superheap[spot*2];

	mov	eax, DWORD PTR [edi+esi*8]
	mov	DWORD PTR [edi+esi*4], eax

; 1229 :         spot *= 2;

	mov	esi, DWORD PTR tv205[ebp]

; 1230 :       }
; 1231 :       else

	jmp	SHORT $LN1@multiple_e
$LN2@multiple_e:

; 1232 :       { superheap[spot] = superheap[spot*2+1];

	mov	DWORD PTR [edi+esi*4], ebx

; 1233 :         spot = spot*2 + 1;

	mov	esi, DWORD PTR tv205[ebp]
	inc	esi
$LN1@multiple_e:

; 1218 :     /* now adjust heap */
; 1219 :     spot = 1;  /* empty spot */
; 1220 :     for ( ;; )
; 1221 :     { if ( spot*2 > heapcount ) { superheap[spot] = &sentinel;  break; }

	lea	edx, DWORD PTR [esi+esi]
	cmp	edx, DWORD PTR _heapcount
	jle	SHORT $LL6@multiple_e
$LN17@multiple_e:
	mov	eax, DWORD PTR _superheap
	mov	DWORD PTR [eax+esi*4], OFFSET _sentinel
	jmp	SHORT $LN5@multiple_e
$LN18@multiple_e:

; 1223 :       { superheap[spot] = superheap[spot*2];

	mov	eax, DWORD PTR _superheap
	mov	ecx, DWORD PTR [eax+esi*8]
	mov	DWORD PTR [eax+esi*4], ecx

; 1224 :         superheap[spot*2] = &sentinel;

	mov	edx, DWORD PTR _superheap
	mov	DWORD PTR [edx+esi*8], OFFSET _sentinel
$LN5@multiple_e:

; 1214 :   sentinel.verlist = 1 << (8*sizeof(int)-2); /* big for degree_compare */
; 1215 :   while ( superheap[1]->degree <= bounddegree )

	mov	eax, DWORD PTR _superheap
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _bounddegree$[ebp]
	cmp	DWORD PTR [eax+8], ecx
	jle	$LL8@multiple_e
	pop	edi
	pop	ebx
$LN7@multiple_e:
	pop	esi

; 1234 :       }
; 1235 :     }
; 1236 :   }
; 1237 : } // end multiple_eliminate()

	mov	esp, ebp
	pop	ebp
	ret	0
_multiple_eliminate ENDP
_TEXT	ENDS
PUBLIC	??_C@_03PMGGPEJJ@?$CFd?6?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	_traverse_recur
_BSS	SEGMENT
_treedepth DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_03PMGGPEJJ@?$CFd?6?$AA@
CONST	SEGMENT
??_C@_03PMGGPEJJ@?$CFd?6?$AA@ DB '%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _traverse_recur
_TEXT	SEGMENT
_sonfill$ = -8						; size = 4
_sondepth$ = -4						; size = 4
_S$ = 8							; size = 4
_r$ = 12						; size = 4
_depth$ = 16						; size = 4
_fill$ = 20						; size = 4
_traverse_recur PROC					; COMDAT

; 1258 : { int son;

	push	ebp
	mov	ebp, esp

; 1259 :   struct region *rr;
; 1260 :   int fillsum = 0;
; 1261 :   int sondepth;
; 1262 :   int maxdepth = 0;
; 1263 :   int sonfill;
; 1264 :   int thisfill;
; 1265 : 
; 1266 :   treedepth++;

	inc	DWORD PTR _treedepth
	sub	esp, 8
	push	ebx
	push	esi

; 1267 :   for ( son = r->son ; son >= 0 ; son = rr->BROTHER )

	mov	esi, DWORD PTR _r$[ebp]
	mov	eax, DWORD PTR [esi+28]
	push	edi
	xor	ebx, ebx
	xor	edi, edi
	test	eax, eax
	js	SHORT $LN5@traverse_r
	npad	3
$LL7@traverse_r:

; 1268 :   { rr = REG(son);

	mov	ecx, DWORD PTR _S$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	lea	esi, DWORD PTR [edx+eax*4]

; 1269 :     traverse_recur(S,rr,&sondepth,&sonfill);

	lea	eax, DWORD PTR _sonfill$[ebp]
	push	eax
	lea	edx, DWORD PTR _sondepth$[ebp]
	push	edx
	push	esi
	push	ecx
	call	_traverse_recur

; 1270 :     if ( sondepth > maxdepth ) maxdepth = sondepth;

	mov	eax, DWORD PTR _sondepth$[ebp]
	add	esp, 16					; 00000010H
	cmp	eax, edi
	jle	SHORT $LN4@traverse_r
	mov	edi, eax
$LN4@traverse_r:

; 1267 :   for ( son = r->son ; son >= 0 ; son = rr->BROTHER )

	mov	eax, DWORD PTR [esi+16]

; 1271 :     fillsum += sonfill;

	add	ebx, DWORD PTR _sonfill$[ebp]
	test	eax, eax
	jns	SHORT $LL7@traverse_r

; 1267 :   for ( son = r->son ; son >= 0 ; son = rr->BROTHER )

	mov	esi, DWORD PTR _r$[ebp]
$LN5@traverse_r:

; 1272 :   }
; 1273 :   thisfill = (r->size*(r->size+1) 
; 1274 :                   - r->vercount*(r->vercount+1))/2;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+32]
	lea	edx, DWORD PTR [eax+1]
	imul	edx, eax
	lea	eax, DWORD PTR [ecx+1]
	imul	eax, ecx

; 1275 :   *fill = fillsum + thisfill;

	mov	ecx, DWORD PTR _fill$[ebp]
	sub	eax, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ebx
	mov	DWORD PTR [ecx], eax

; 1276 :   *depth = maxdepth + (r->size*(r->size+1))/2;

	mov	ecx, DWORD PTR [esi+32]
	lea	eax, DWORD PTR [ecx+1]
	imul	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _depth$[ebp]
	sar	eax, 1
	add	eax, edi

; 1277 : { int n; for (n=0;n<treedepth;n++)printf("  ");printf("%d\n",(r->size*(r->size+1))/2); }

	xor	edi, edi
	mov	DWORD PTR [edx], eax
	cmp	DWORD PTR _treedepth, edi
	jle	SHORT $LN1@traverse_r
	npad	1
$LL3@traverse_r:
	push	OFFSET ??_C@_02KNHHEEKP@?5?5?$AA@
	call	_printf
	inc	edi
	add	esp, 4
	cmp	edi, DWORD PTR _treedepth
	jl	SHORT $LL3@traverse_r
$LN1@traverse_r:
	mov	esi, DWORD PTR [esi+32]
	lea	eax, DWORD PTR [esi+1]
	imul	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	push	OFFSET ??_C@_03PMGGPEJJ@?$CFd?6?$AA@
	call	_printf
	add	esp, 8

; 1278 : treedepth--;

	dec	DWORD PTR _treedepth
	pop	edi
	pop	esi
	pop	ebx

; 1279 : } // end traverse_recur()

	mov	esp, ebp
	pop	ebp
	ret	0
_traverse_recur ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@PFBKKCPG@permute_recur?5region?5?$CFld?0?5vercou@ ; `string'
PUBLIC	_permute_recur
_BSS	SEGMENT
_IJA_base DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0DA@PFBKKCPG@permute_recur?5region?5?$CFld?0?5vercou@
CONST	SEGMENT
??_C@_0DA@PFBKKCPG@permute_recur?5region?5?$CFld?0?5vercou@ DB 'permute_r'
	DB	'ecur region %ld, vercount %d rsize %d', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _permute_recur
_TEXT	SEGMENT
_S$ = 8							; size = 4
_r$ = 12						; size = 4
_permute_recur PROC					; COMDAT

; 1292 : { int k;

	push	ebp
	mov	ebp, esp

; 1293 :   struct region *rr;
; 1294 :   int son;
; 1295 : 
; 1296 :   if ( mindeg_debug_level > 5 ) 

	cmp	DWORD PTR _mindeg_debug_level, 5
	push	ebx
	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	push	edi
	mov	edi, DWORD PTR _r$[ebp]
	jle	SHORT $LN7@permute_re

; 1297 :      printf("permute_recur region %ld, vercount %d rsize %d\n",
; 1298 :          (long)((int*)r-S->ISP),r->vercount,r->size);

	mov	eax, DWORD PTR [edi+32]
	mov	ecx, DWORD PTR [edi]
	push	eax
	mov	edx, edi
	sub	edx, DWORD PTR [esi+92]
	push	ecx
	sar	edx, 2
	push	edx
	push	OFFSET ??_C@_0DA@PFBKKCPG@permute_recur?5region?5?$CFld?0?5vercou@
	call	_printf
	add	esp, 16					; 00000010H
$LN7@permute_re:

; 1299 :   for ( son = r->son ; son >= 0 ; son = rr->BROTHER )

	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	js	SHORT $LN4@permute_re
	npad	7
$LL6@permute_re:

; 1300 :   { rr = REG(son);

	mov	ecx, DWORD PTR [esi+92]
	lea	ebx, DWORD PTR [ecx+eax*4]

; 1301 :     permute_recur(S,rr);

	push	ebx
	push	esi
	call	_permute_recur
	mov	eax, DWORD PTR [ebx+16]
	add	esp, 8
	test	eax, eax
	jns	SHORT $LL6@permute_re
$LN4@permute_re:

; 1302 :   }
; 1303 :   for ( k = r->vercount ; k < r->size ; k++ )

	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [edi+32]
	jge	SHORT $LN14@permute_re
	npad	2
$LL3@permute_re:

; 1304 :   { S->P[K] = INT(r->verlist)[k];

	mov	edx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+92]
	mov	ebx, DWORD PTR [esi+68]
	add	edx, eax
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _K
	mov	DWORD PTR [ebx+ecx*4], edx

; 1305 :     S->IP[S->P[K]] = K;

	mov	edx, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR _K
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [esi+72]
	mov	DWORD PTR [ebx+edx*4], ecx

; 1306 :     K++;

	inc	DWORD PTR _K
	inc	eax
	cmp	eax, DWORD PTR [edi+32]
	jl	SHORT $LL3@permute_re

; 1307 :   }
; 1308 :   IJA_base += r->size;

	mov	eax, DWORD PTR [edi+32]
	add	DWORD PTR _IJA_base, eax
	pop	edi
	pop	esi
	pop	ebx

; 1309 : } // permute_recur()

	pop	ebp
	ret	0
$LN14@permute_re:

; 1307 :   }
; 1308 :   IJA_base += r->size;

	mov	ecx, DWORD PTR [edi+32]
	add	DWORD PTR _IJA_base, ecx
	pop	edi
	pop	esi
	pop	ebx

; 1309 : } // permute_recur()

	pop	ebp
	ret	0
_permute_recur ENDP
_TEXT	ENDS
PUBLIC	_sparse_permute
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT _sparse_permute
_TEXT	SEGMENT
tv785 = -24						; size = 4
_tmp$90033 = -24					; size = 4
_ii$90000 = -24						; size = 4
_j$ = -20						; size = 4
_end$ = -16						; size = 4
_cA$ = -12						; size = 4
_cJA$ = -8						; size = 4
tv2923 = -4						; size = 4
_m$90018 = -4						; size = 4
_total$ = 8						; size = 4
_i$ = 8							; size = 4
_S$ = 8							; size = 4
_sparse_permute PROC					; COMDAT

; 1322 : { int i,j,end,total;

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi

; 1323 :   int *cIA;
; 1324 :   int *cJA;
; 1325 :   REAL *cA;
; 1326 : 
; 1327 :   /* allocate */
; 1328 : 
; 1329 :   S->pIA = (int*)temp_realloc((char*)S->pIA,(S->N+1)*sizeof(int));

	mov	esi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+96]
	push	edi
	push	1329					; 00000531H
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	lea	ecx, DWORD PTR [eax*4+4]
	push	ecx
	push	edx
	call	_kb_temp_realloc

; 1330 :   S->pJA = (int*)temp_realloc((char*)S->pJA,(S->IA[S->N]-A_OFF)*sizeof(int));

	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+96], eax
	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [esi+100]
	push	1330					; 00000532H
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	lea	eax, DWORD PTR [edx*4-4]
	push	eax
	push	ecx
	call	_kb_temp_realloc

; 1331 :   S->pA = (REAL*)temp_realloc((char*)S->pA,(S->IA[S->N]-A_OFF)*sizeof(REAL));

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+100], eax
	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+104]
	push	1331					; 00000533H
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	lea	edx, DWORD PTR [ecx*8-8]
	push	edx
	push	eax
	call	_kb_temp_realloc

; 1332 :   memset((char*)S->pIA,0,(S->N+1)*sizeof(int));

	mov	ecx, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [ecx*4+4]
	push	edx
	mov	DWORD PTR [esi+104], eax
	mov	eax, DWORD PTR [esi+96]
	push	0
	push	eax
	call	_memset

; 1333 :   memset((char*)S->pJA,0,(S->IA[S->N]-A_OFF)*sizeof(int));

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [esi+100]
	lea	ecx, DWORD PTR [eax*4-4]
	push	ecx
	push	0
	push	edx
	call	_memset

; 1334 :   memset((char*)S->pA,0,(S->IA[S->N]-A_OFF)*sizeof(REAL));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [esi+104]
	add	esp, 72					; 00000048H
	lea	eax, DWORD PTR [edx*8-8]
	push	eax
	push	0
	push	ecx
	call	_memset

; 1335 :   
; 1336 :   cIA = (int*)temp_calloc(S->N+1,sizeof(int));

	mov	edx, DWORD PTR [esi+4]
	push	1336					; 00000538H
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	inc	edx
	push	4
	push	edx
	call	_kb_temp_calloc

; 1337 :   cJA = (int*)temp_calloc(S->IA[S->N]-A_OFF,sizeof(int));

	mov	ecx, DWORD PTR [esi+52]
	mov	edi, eax
	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	1337					; 00000539H
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	dec	edx
	push	4
	push	edx
	call	_kb_temp_calloc
	mov	ebx, eax
	mov	DWORD PTR _cJA$[ebp], ebx

; 1338 :   cA = (REAL*)temp_calloc(S->IA[S->N]-A_OFF,sizeof(REAL));

	push	1338					; 0000053aH
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	dec	edx
	push	8
	push	edx
	call	_kb_temp_calloc

; 1339 : 
; 1340 :   /* sort on permuted column */
; 1341 :   for ( i = 0 ; i < S->N ; i++ )

	xor	edx, edx
	add	esp, 60					; 0000003cH
	mov	DWORD PTR _cA$[ebp], eax
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN82@sparse_per
$LL40@sparse_per:

; 1342 :   { int ii = S->IP[i];

	mov	eax, DWORD PTR [esi+72]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+52]
	lea	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _ii$90000[ebp], ecx

; 1343 :     end = S->IA[i+1] - A_OFF;

	mov	ecx, DWORD PTR [eax+4]

; 1344 :     for ( j = S->IA[i] - A_OFF ; j < end ; j++ )

	mov	eax, DWORD PTR [eax]
	dec	ecx
	dec	eax
	mov	DWORD PTR _end$[ebp], ecx
	cmp	eax, ecx
	jge	SHORT $LN39@sparse_per
	npad	2
$LL37@sparse_per:

; 1345 :     { int m = S->IP[S->JA[j]-A_OFF];

	mov	ecx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [esi+72]
	mov	ecx, DWORD PTR [ecx+edx*4-4]

; 1346 :       if ( ii < m )

	mov	edx, DWORD PTR _ii$90000[ebp]
	cmp	edx, ecx
	jge	SHORT $LN34@sparse_per

; 1347 :          cIA[m]++;

	inc	DWORD PTR [edi+ecx*4]
	jmp	SHORT $LN36@sparse_per
$LN34@sparse_per:

; 1348 :       else cIA[ii]++;

	inc	DWORD PTR [edi+edx*4]
$LN36@sparse_per:

; 1344 :     for ( j = S->IA[i] - A_OFF ; j < end ; j++ )

	inc	eax
	cmp	eax, DWORD PTR _end$[ebp]
	jl	SHORT $LL37@sparse_per
	mov	edx, DWORD PTR _i$[ebp]
$LN39@sparse_per:

; 1339 : 
; 1340 :   /* sort on permuted column */
; 1341 :   for ( i = 0 ; i < S->N ; i++ )

	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LL40@sparse_per
$LN82@sparse_per:

; 1349 :     }
; 1350 :   }
; 1351 :   for ( i = 0, total = 0 ; i < S->N ; i++ )

	xor	eax, eax
	xor	ecx, ecx
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN30@sparse_per
$LL32@sparse_per:

; 1352 :   { int tmp = cIA[i]; cIA[i] = total; total += tmp; 

	mov	edx, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [edi+eax*4], ecx
	inc	eax
	add	ecx, edx
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL32@sparse_per
$LN30@sparse_per:

; 1353 :   }
; 1354 :   cIA[S->N] = total;

	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+edx*4], ecx

; 1355 :   for ( i = 0 ; i < S->N ; i++ )

	xor	ecx, ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR [esi+4], ecx
	jle	$LN27@sparse_per
	npad	7
$LL29@sparse_per:

; 1356 :   { int ii = S->IP[i];

	mov	eax, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR [esi+52]
	lea	ecx, DWORD PTR [edx+ecx*4]

; 1357 :     end = S->IA[i+1] - A_OFF;

	mov	edx, DWORD PTR [ecx+4]

; 1358 :     for ( j = S->IA[i] - A_OFF ; j < end ; j++ )

	mov	ecx, DWORD PTR [ecx]
	dec	edx
	dec	ecx
	mov	DWORD PTR _end$[ebp], edx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, edx
	jge	$LN83@sparse_per
	sub	edx, ecx
	cmp	edx, 4
	jl	$LC68@sparse_per
	npad	4
$LL77@sparse_per:

; 1359 :     { int m = S->IP[S->JA[j]-A_OFF];

	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [ebx+edx*4-4]
	mov	DWORD PTR _m$90018[ebp], edx

; 1360 :       if ( ii < m )

	cmp	eax, edx
	jge	SHORT $LN69@sparse_per

; 1361 :       { cA[cIA[m]] = S->A[j];  cJA[cIA[m]++] = ii; }

	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+ecx*8]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	ecx, DWORD PTR _cA$[ebp]
	mov	ebx, DWORD PTR _cJA$[ebp]
	fstp	QWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _m$90018[ebp]
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR [ebx+edx*4], eax
	inc	DWORD PTR [edi+ecx*4]
	jmp	SHORT $LN70@sparse_per
$LN69@sparse_per:

; 1362 :       else { cA[cIA[ii]] = S->A[j]; cJA[cIA[ii]++] = m; }

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+ecx*8]
	mov	ebx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR _cA$[ebp]
	fstp	QWORD PTR [ecx+ebx*8]
	mov	edx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR _m$90018[ebp]
	mov	ebx, DWORD PTR _cJA$[ebp]
	mov	DWORD PTR [ebx+edx*4], ecx
	inc	DWORD PTR [edi+eax*4]
$LN70@sparse_per:

; 1359 :     { int m = S->IP[S->JA[j]-A_OFF];

	mov	edx, DWORD PTR [esi+56]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+4]
	mov	ebx, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [ebx+edx*4-4]
	mov	DWORD PTR _m$90018[ebp], edx

; 1360 :       if ( ii < m )

	cmp	eax, edx
	jge	SHORT $LN71@sparse_per

; 1361 :       { cA[cIA[m]] = S->A[j];  cJA[cIA[m]++] = ii; }

	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+ecx*8+8]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	ecx, DWORD PTR _cA$[ebp]
	mov	ebx, DWORD PTR _cJA$[ebp]
	fstp	QWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _m$90018[ebp]
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR [ebx+edx*4], eax
	inc	DWORD PTR [edi+ecx*4]
	jmp	SHORT $LN72@sparse_per
$LN71@sparse_per:

; 1362 :       else { cA[cIA[ii]] = S->A[j]; cJA[cIA[ii]++] = m; }

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+ecx*8+8]
	mov	ebx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR _cA$[ebp]
	fstp	QWORD PTR [ecx+ebx*8]
	mov	edx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR _m$90018[ebp]
	mov	ebx, DWORD PTR _cJA$[ebp]
	mov	DWORD PTR [ebx+edx*4], ecx
	inc	DWORD PTR [edi+eax*4]
$LN72@sparse_per:

; 1359 :     { int m = S->IP[S->JA[j]-A_OFF];

	mov	edx, DWORD PTR [esi+56]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+8]
	mov	ebx, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [ebx+edx*4-4]
	mov	DWORD PTR _m$90018[ebp], edx

; 1360 :       if ( ii < m )

	cmp	eax, edx
	jge	SHORT $LN73@sparse_per

; 1361 :       { cA[cIA[m]] = S->A[j];  cJA[cIA[m]++] = ii; }

	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+ecx*8+16]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	ecx, DWORD PTR _cA$[ebp]
	mov	ebx, DWORD PTR _cJA$[ebp]
	fstp	QWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _m$90018[ebp]
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR [ebx+edx*4], eax
	inc	DWORD PTR [edi+ecx*4]
	jmp	SHORT $LN74@sparse_per
$LN73@sparse_per:

; 1362 :       else { cA[cIA[ii]] = S->A[j]; cJA[cIA[ii]++] = m; }

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+ecx*8+16]
	mov	ebx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR _cA$[ebp]
	fstp	QWORD PTR [ecx+ebx*8]
	mov	edx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR _m$90018[ebp]
	mov	ebx, DWORD PTR _cJA$[ebp]
	mov	DWORD PTR [ebx+edx*4], ecx
	inc	DWORD PTR [edi+eax*4]
$LN74@sparse_per:

; 1359 :     { int m = S->IP[S->JA[j]-A_OFF];

	mov	edx, DWORD PTR [esi+56]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4+12]
	mov	ebx, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [ebx+edx*4-4]
	mov	DWORD PTR _m$90018[ebp], edx

; 1360 :       if ( ii < m )

	cmp	eax, edx
	jge	SHORT $LN75@sparse_per

; 1361 :       { cA[cIA[m]] = S->A[j];  cJA[cIA[m]++] = ii; }

	mov	ebx, DWORD PTR [esi+60]
	fld	QWORD PTR [ebx+ecx*8+24]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	ecx, DWORD PTR _cA$[ebp]
	mov	ebx, DWORD PTR _cJA$[ebp]
	fstp	QWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _m$90018[ebp]
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR [ebx+edx*4], eax
	inc	DWORD PTR [edi+ecx*4]
	jmp	SHORT $LN76@sparse_per
$LN75@sparse_per:

; 1362 :       else { cA[cIA[ii]] = S->A[j]; cJA[cIA[ii]++] = m; }

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+ecx*8+24]
	mov	ebx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR _cA$[ebp]
	fstp	QWORD PTR [ecx+ebx*8]
	mov	edx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR _m$90018[ebp]
	mov	ebx, DWORD PTR _cJA$[ebp]
	mov	DWORD PTR [ebx+edx*4], ecx
	inc	DWORD PTR [edi+eax*4]
$LN76@sparse_per:
	mov	ecx, DWORD PTR _j$[ebp]

; 1380 :     { S->pA[S->pIA[cJA[j]]] = cA[j]; S->pJA[S->pIA[cJA[j]]++] = i; }

	mov	edx, DWORD PTR _end$[ebp]
	add	ecx, 4
	add	edx, -3					; fffffffdH
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, edx
	jl	$LL77@sparse_per
$LC68@sparse_per:

; 1358 :     for ( j = S->IA[i] - A_OFF ; j < end ; j++ )

	cmp	ecx, DWORD PTR _end$[ebp]
	jge	SHORT $LN83@sparse_per
$LC26@sparse_per:

; 1359 :     { int m = S->IP[S->JA[j]-A_OFF];

	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [ebx+edx*4-4]
	mov	DWORD PTR _m$90018[ebp], edx

; 1360 :       if ( ii < m )

	cmp	eax, edx
	jge	SHORT $LN23@sparse_per

; 1361 :       { cA[cIA[m]] = S->A[j];  cJA[cIA[m]++] = ii; }

	mov	ebx, DWORD PTR [esi+60]
	mov	edx, DWORD PTR [edi+edx*4]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR _cA$[ebp]
	fstp	QWORD PTR [ebx+edx*8]
	mov	edx, DWORD PTR _m$90018[ebp]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	ebx, DWORD PTR _cJA$[ebp]
	mov	DWORD PTR [ebx+edx*4], eax
	mov	edx, DWORD PTR _m$90018[ebp]
	inc	DWORD PTR [edi+edx*4]
	jmp	SHORT $LN25@sparse_per
$LN23@sparse_per:

; 1362 :       else { cA[cIA[ii]] = S->A[j]; cJA[cIA[ii]++] = m; }

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+ecx*8]
	mov	ebx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR _cA$[ebp]
	fstp	QWORD PTR [ecx+ebx*8]
	mov	edx, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR _m$90018[ebp]
	mov	ebx, DWORD PTR _cJA$[ebp]
	mov	DWORD PTR [ebx+edx*4], ecx
	inc	DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
$LN25@sparse_per:

; 1359 :     { int m = S->IP[S->JA[j]-A_OFF];

	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR _end$[ebp]
	jl	SHORT $LC26@sparse_per
$LN83@sparse_per:

; 1358 :     for ( j = S->IA[i] - A_OFF ; j < end ; j++ )

	mov	ecx, DWORD PTR _i$[ebp]
	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, DWORD PTR [esi+4]
	jl	$LL29@sparse_per
$LN27@sparse_per:

; 1363 :     }
; 1364 :   }
; 1365 :   for ( i = S->N-1 ; i > 0 ; i-- ) cIA[i] = cIA[i-1];

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	test	eax, eax
	jle	SHORT $LN19@sparse_per
	npad	1
$LL21@sparse_per:
	mov	edx, DWORD PTR [edi+eax*4-4]
	mov	DWORD PTR [edi+eax*4], edx
	dec	eax
	test	eax, eax
	jg	SHORT $LL21@sparse_per
$LN19@sparse_per:

; 1366 :   cIA[0] = 0;
; 1367 :   /* now sort on permuted row */
; 1368 :   for ( i = 0 ; i < S->N ; i++ )

	xor	ecx, ecx
	mov	DWORD PTR [edi], 0
	mov	DWORD PTR _i$[ebp], ecx
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN16@sparse_per
	npad	4
$LL18@sparse_per:

; 1369 :   { end = cIA[i+1];

	mov	edx, DWORD PTR [edi+ecx*4+4]

; 1370 :     for ( j = cIA[i] ; j < end ; j++ )

	mov	eax, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR _end$[ebp], edx
	cmp	eax, edx
	jge	SHORT $LN17@sparse_per
	npad	2
$LL15@sparse_per:

; 1371 :          S->pIA[cJA[j]]++;

	mov	ecx, DWORD PTR [ebx+eax*4]
	mov	edx, DWORD PTR [esi+96]
	inc	DWORD PTR [edx+ecx*4]
	lea	ecx, DWORD PTR [edx+ecx*4]
	inc	eax
	cmp	eax, DWORD PTR _end$[ebp]
	jl	SHORT $LL15@sparse_per

; 1370 :     for ( j = cIA[i] ; j < end ; j++ )

	mov	ecx, DWORD PTR _i$[ebp]
$LN17@sparse_per:

; 1366 :   cIA[0] = 0;
; 1367 :   /* now sort on permuted row */
; 1368 :   for ( i = 0 ; i < S->N ; i++ )

	inc	ecx
	mov	DWORD PTR _i$[ebp], ecx
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LL18@sparse_per
$LN16@sparse_per:

; 1372 :   }
; 1373 :   for ( i = 0, total = 0 ; i < S->N ; i++ )

	xor	eax, eax
	xor	edx, edx
	mov	DWORD PTR _total$[ebp], edx
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN10@sparse_per
	npad	6
$LL12@sparse_per:
	mov	ecx, DWORD PTR [esi+96]

; 1374 :   { int tmp = S->pIA[i]; S->pIA[i] = total; total += tmp; 

	mov	edx, DWORD PTR [ecx+eax*4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _tmp$90033[ebp], edx
	mov	edx, DWORD PTR _total$[ebp]
	mov	DWORD PTR [ecx], edx
	add	edx, DWORD PTR _tmp$90033[ebp]
	inc	eax
	mov	DWORD PTR _total$[ebp], edx
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL12@sparse_per
$LN10@sparse_per:

; 1375 :   }
; 1376 :   S->pIA[S->N] = total;

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+96]
	mov	DWORD PTR [ecx+eax*4], edx

; 1377 :   for ( i = 0 ; i < S->N ; i++ )

	xor	edx, edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR [esi+4], edx
	jle	$LN7@sparse_per
$LL9@sparse_per:

; 1378 :   { end = cIA[i+1];

	mov	eax, DWORD PTR [edi+edx*4+4]

; 1379 :     for ( j = cIA[i] ; j < end ; j++ )

	mov	ecx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR _end$[ebp], eax
	cmp	ecx, eax
	jge	$LN8@sparse_per
	sub	eax, ecx
	cmp	eax, 4
	jl	$LC79@sparse_per

; 1380 :     { S->pA[S->pIA[cJA[j]]] = cA[j]; S->pJA[S->pIA[cJA[j]]++] = i; }

	mov	edx, DWORD PTR _cA$[ebp]
	lea	edx, DWORD PTR [edx+ecx*8+16]
	mov	DWORD PTR tv2923[ebp], edx
	mov	edx, DWORD PTR _end$[ebp]
	sub	edx, ecx
	sub	edx, 4
	shr	edx, 2
	inc	edx
	lea	eax, DWORD PTR [ebx+ecx*4+8]
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR tv785[ebp], edx
	mov	DWORD PTR _j$[ebp], ecx
$LL80@sparse_per:
	mov	edx, DWORD PTR [eax-8]
	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [esi+104]
	mov	ebx, DWORD PTR tv2923[ebp]
	fld	QWORD PTR [ebx-16]
	mov	ebx, DWORD PTR _i$[ebp]
	fstp	QWORD PTR [ecx+edx*8]
	mov	edx, DWORD PTR [eax-8]
	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [esi+100]
	mov	DWORD PTR [ecx+edx*4], ebx
	mov	edx, DWORD PTR [eax-8]
	mov	ecx, DWORD PTR [esi+96]
	inc	DWORD PTR [ecx+edx*4]
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [eax-4]
	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [esi+104]
	mov	ebx, DWORD PTR tv2923[ebp]
	fld	QWORD PTR [ebx-8]
	mov	ebx, DWORD PTR _i$[ebp]
	fstp	QWORD PTR [ecx+edx*8]
	mov	edx, DWORD PTR [eax-4]
	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [esi+100]
	mov	DWORD PTR [ecx+edx*4], ebx
	mov	edx, DWORD PTR [eax-4]
	mov	ecx, DWORD PTR [esi+96]
	inc	DWORD PTR [ecx+edx*4]
	mov	ebx, DWORD PTR tv2923[ebp]
	fld	QWORD PTR [ebx]
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [esi+104]
	mov	ebx, DWORD PTR _i$[ebp]
	fstp	QWORD PTR [ecx+edx*8]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [esi+100]
	mov	DWORD PTR [ecx+edx*4], ebx
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [esi+96]
	inc	DWORD PTR [ecx+edx*4]
	mov	ebx, DWORD PTR tv2923[ebp]
	fld	QWORD PTR [ebx+8]
	add	DWORD PTR tv2923[ebp], 32		; 00000020H
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [esi+104]
	fstp	QWORD PTR [ecx+edx*8]
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [esi+96]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	ebx, DWORD PTR [esi+100]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ebx+ecx*4], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR [esi+96]
	inc	DWORD PTR [ebx+ecx*4]
	lea	ecx, DWORD PTR [ebx+ecx*4]
	add	eax, 16					; 00000010H
	dec	DWORD PTR tv785[ebp]
	jne	$LL80@sparse_per
	mov	ecx, DWORD PTR _j$[ebp]
	mov	ebx, DWORD PTR _cJA$[ebp]
$LC79@sparse_per:

; 1379 :     for ( j = cIA[i] ; j < end ; j++ )

	cmp	ecx, DWORD PTR _end$[ebp]
	jge	SHORT $LN8@sparse_per
$LL81@sparse_per:

; 1380 :     { S->pA[S->pIA[cJA[j]]] = cA[j]; S->pJA[S->pIA[cJA[j]]++] = i; }

	mov	edx, DWORD PTR [ebx+ecx*4]
	mov	eax, DWORD PTR [esi+96]
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+104]
	mov	ebx, DWORD PTR _cA$[ebp]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR _i$[ebp]
	fstp	QWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR _cJA$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [esi+100]
	mov	DWORD PTR [edx+eax*4], ebx
	mov	ebx, DWORD PTR _cJA$[ebp]
	mov	eax, DWORD PTR [ebx+ecx*4]
	mov	edx, DWORD PTR [esi+96]
	inc	DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [edx+eax*4]
	inc	ecx
	cmp	ecx, DWORD PTR _end$[ebp]
	jl	SHORT $LL81@sparse_per

; 1379 :     for ( j = cIA[i] ; j < end ; j++ )

	mov	edx, DWORD PTR _i$[ebp]
$LN8@sparse_per:

; 1377 :   for ( i = 0 ; i < S->N ; i++ )

	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, DWORD PTR [esi+4]
	jl	$LL9@sparse_per
$LN7@sparse_per:

; 1381 :   }
; 1382 :   for ( i = S->N-1 ; i > 0 ; i-- ) S->pIA[i] = S->pIA[i-1];

	mov	eax, DWORD PTR [esi+4]
	dec	eax
	test	eax, eax
	jle	SHORT $LN1@sparse_per
	npad	2
$LL3@sparse_per:
	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR [ecx+eax*4-4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	dec	eax
	mov	DWORD PTR [ecx], edx
	test	eax, eax
	jg	SHORT $LL3@sparse_per
$LN1@sparse_per:

; 1383 :   S->pIA[0] = 0;

	mov	eax, DWORD PTR [esi+96]

; 1384 :   temp_free((char*)cIA);

	push	edi
	mov	DWORD PTR [eax], 0
	call	_temp_free

; 1385 :   temp_free((char*)cJA);

	push	ebx
	call	_temp_free

; 1386 :   temp_free((char*)cA); 

	mov	ecx, DWORD PTR _cA$[ebp]
	push	ecx
	call	_temp_free
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 1387 : } // end sparse_permute()

	mov	esp, ebp
	pop	ebp
	ret	0
_sparse_permute ENDP
_TEXT	ENDS
PUBLIC	_vcompare
; Function compile flags: /Ogtp
;	COMDAT _vcompare
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_vcompare PROC						; COMDAT

; 1399 : { return *a-*b;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR _b$[ebp]
	sub	eax, DWORD PTR [ecx]

; 1400 : }

	pop	ebp
	ret	0
_vcompare ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	??_C@_0CH@LHAOEJKE@Internal?5error?3?5Illegal?5case?5of?5@ ; `string'
PUBLIC	_factor_recur
EXTRN	_BKalpha:QWORD
EXTRN	_hessian_epsilon:QWORD
EXTRN	_BK_flag:DWORD
EXTRN	_Met:BYTE
EXTRN	_hessian_linear_metric_flag:DWORD
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT ??_C@_0CH@LHAOEJKE@Internal?5error?3?5Illegal?5case?5of?5@
CONST	SEGMENT
??_C@_0CH@LHAOEJKE@Internal?5error?3?5Illegal?5case?5of?5@ DB 'Internal e'
	DB	'rror: Illegal case of psize', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _factor_recur
_TEXT	SEGMENT
tv7997 = -40						; size = 4
tv7564 = -40						; size = 4
tv7446 = -40						; size = 4
tv7356 = -40						; size = 4
tv6863 = -40						; size = 4
tv4611 = -40						; size = 4
tv4131 = -40						; size = 4
_rii$90212 = -40					; size = 4
tv7773 = -36						; size = 4
tv6811 = -36						; size = 4
tv6782 = -36						; size = 4
tv6672 = -36						; size = 4
tv6511 = -36						; size = 4
tv6415 = -36						; size = 4
tv6378 = -36						; size = 4
tv6237 = -36						; size = 4
tv6216 = -36						; size = 4
tv4360 = -36						; size = 4
tv4220 = -36						; size = 4
tv4096 = -36						; size = 4
tv3884 = -36						; size = 4
tv3617 = -36						; size = 4
tv858 = -36						; size = 4
_k$90208 = -36						; size = 4
tv8059 = -32						; size = 4
tv4741 = -32						; size = 4
tv3968 = -32						; size = 4
tv3895 = -32						; size = 4
_ii$ = -32						; size = 4
tv8036 = -28						; size = 4
tv7296 = -28						; size = 4
tv6513 = -28						; size = 4
tv6187 = -28						; size = 4
tv4236 = -28						; size = 4
tv4212 = -28						; size = 4
_c$90214 = -28						; size = 4
_subbase$90112 = -28					; size = 4
tv3892 = -24						; size = 4
_pivrow2$90199 = -24					; size = 4
_IJdiff$90115 = -24					; size = 4
tv4409 = -20						; size = 4
tv4116 = -20						; size = 4
tv6528 = -16						; size = 4
_rr$90166 = -16						; size = 4
_jj$90093 = -16						; size = 4
_la$90113 = -16						; size = 4
_ii_next$ = -16						; size = 4
_pivrow$90152 = -12					; size = 4
_end$ = -12						; size = 4
tv7693 = -8						; size = 4
tv4101 = -8						; size = 4
_m$ = -8						; size = 4
_j$ = -8						; size = 4
_to_elim$ = -4						; size = 4
_S$ = 8							; size = 4
_r$ = 12						; size = 4
_factor_recur PROC					; COMDAT

; 1406 : { int to_elim = r->size - r->vercount;

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi

; 1407 :   REAL *base;  /* scratch row start in LA */
; 1408 :   int i,j,m,ii,ii_next;
; 1409 :   int end;
; 1410 :   REAL pivot;
; 1411 :   int *jspot;
; 1412 :   struct region *reg;
; 1413 :   int son;
; 1414 : 
; 1415 :   /* first, do sons */
; 1416 :   for ( son = r->son ; son >= 0 ; son = reg->BROTHER )

	mov	esi, DWORD PTR _S$[ebp]
	push	edi
	mov	edi, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR [edi+32]
	sub	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR _to_elim$[ebp], ecx
	test	eax, eax
	js	SHORT $LN116@factor_rec
	npad	2
$LL118@factor_rec:

; 1417 :   { reg = REG(son);

	mov	ecx, DWORD PTR [esi+92]
	lea	ebx, DWORD PTR [ecx+eax*4]

; 1418 :     factor_recur(S,reg);

	push	ebx
	push	esi
	call	_factor_recur
	mov	eax, DWORD PTR [ebx+16]
	add	esp, 8
	test	eax, eax
	jns	SHORT $LL118@factor_rec

; 1407 :   REAL *base;  /* scratch row start in LA */
; 1408 :   int i,j,m,ii,ii_next;
; 1409 :   int end;
; 1410 :   REAL pivot;
; 1411 :   int *jspot;
; 1412 :   struct region *reg;
; 1413 :   int son;
; 1414 : 
; 1415 :   /* first, do sons */
; 1416 :   for ( son = r->son ; son >= 0 ; son = reg->BROTHER )

	mov	ecx, DWORD PTR _to_elim$[ebp]
$LN116@factor_rec:

; 1419 :   }
; 1420 : 
; 1421 :   if ( to_elim == 0 ) return;

	test	ecx, ecx
	je	$LN119@factor_rec

; 1422 : 
; 1423 :   /* get verlist in proper order with permuted numbers */
; 1424 :   for ( j = 0 ; j < r->size ; j++ )

	xor	eax, eax
	cmp	DWORD PTR [edi+32], eax
	jle	SHORT $LN112@factor_rec
	npad	7
$LL114@factor_rec:

; 1425 :     INT(r->verlist)[j] = S->IP[INT(r->verlist)[j]];

	mov	edx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+92]
	mov	ebx, DWORD PTR [esi+72]
	add	edx, eax
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx+edx*4]
	inc	eax
	mov	DWORD PTR [ecx], edx
	cmp	eax, DWORD PTR [edi+32]
	jl	SHORT $LL114@factor_rec
$LN112@factor_rec:

; 1426 :   qsort((char*)(INT(r->verlist)),r->size,sizeof(int), FCAST vcompare);

	push	OFFSET _vcompare
	mov	eax, edi
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi+92]
	push	4
	push	ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_qsort

; 1427 : 
; 1428 :   /* fill in full rows in scratch space */
; 1429 :   for ( i = 0, base = S->LA + S->LIA[K] ; i < to_elim ; i++ )

	fldz
	mov	edx, DWORD PTR [esi+128]
	mov	eax, DWORD PTR _K
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [esi+140]
	xor	edi, edi
	add	esp, 16					; 00000010H
	lea	ebx, DWORD PTR [edx+ecx*8]
	cmp	DWORD PTR _to_elim$[ebp], edi
	jle	$LN228@factor_rec

; 1426 :   qsort((char*)(INT(r->verlist)),r->size,sizeof(int), FCAST vcompare);

	mov	eax, DWORD PTR _to_elim$[ebp]
	lea	ecx, DWORD PTR [eax*8]
	mov	DWORD PTR tv6863[ebp], ecx
$LN210@factor_rec:

; 1430 :   { REAL pa,pb,p11,p12,p21,p22;
; 1431 :     int jj;
; 1432 : 
; 1433 :     /* first, fill from original matrix */
; 1434 :     end = S->pIA[K+i+1];

	mov	edx, DWORD PTR _K
	mov	eax, DWORD PTR [esi+96]
	add	edx, edi
	mov	ecx, DWORD PTR [eax+edx*4+4]
	lea	eax, DWORD PTR [eax+edx*4]

; 1435 :     for ( j = S->pIA[K+i] ; j < end ; j++ )

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _end$[ebp], ecx
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, ecx
	jge	$LN169@factor_rec
	sub	ecx, eax
	cmp	ecx, 4
	jl	SHORT $LC170@factor_rec
$LN211@factor_rec:

; 1436 :        base[S->pJA[j]-(K+i)] = S->pA[j];

	mov	ecx, DWORD PTR [esi+100]
	mov	ecx, DWORD PTR [ecx+eax*4]
	sub	ecx, DWORD PTR _K
	mov	edx, DWORD PTR [esi+104]
	fld	QWORD PTR [edx+eax*8]
	sub	ecx, edi
	fstp	QWORD PTR [ebx+ecx*8]
	mov	ecx, DWORD PTR [esi+100]
	mov	ecx, DWORD PTR [ecx+eax*4+4]
	sub	ecx, DWORD PTR _K
	mov	edx, DWORD PTR [esi+104]
	fld	QWORD PTR [edx+eax*8+8]
	sub	ecx, edi
	fstp	QWORD PTR [ebx+ecx*8]
	mov	ecx, DWORD PTR [esi+100]
	mov	eax, DWORD PTR [ecx+eax*4+8]
	sub	eax, DWORD PTR _K
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [esi+104]
	fld	QWORD PTR [edx+ecx*8+16]
	sub	eax, edi
	fstp	QWORD PTR [ebx+eax*8]
	mov	eax, DWORD PTR [esi+100]
	mov	eax, DWORD PTR [eax+ecx*4+12]
	sub	eax, DWORD PTR _K
	mov	edx, DWORD PTR [esi+104]
	fld	QWORD PTR [edx+ecx*8+24]
	sub	eax, edi
	fstp	QWORD PTR [ebx+eax*8]
	mov	eax, ecx
	mov	ecx, DWORD PTR _end$[ebp]
	add	eax, 4
	add	ecx, -3					; fffffffdH
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, ecx
	jl	SHORT $LN211@factor_rec
$LC170@factor_rec:

; 1435 :     for ( j = S->pIA[K+i] ; j < end ; j++ )

	cmp	eax, DWORD PTR _end$[ebp]
	jge	SHORT $LN169@factor_rec
$LN212@factor_rec:

; 1436 :        base[S->pJA[j]-(K+i)] = S->pA[j];

	mov	ecx, DWORD PTR [esi+100]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR [esi+104]
	sub	ecx, DWORD PTR _K
	fld	QWORD PTR [edx+eax*8]
	inc	eax
	sub	ecx, edi
	fstp	QWORD PTR [ebx+ecx*8]
	cmp	eax, DWORD PTR _end$[ebp]
	jl	SHORT $LN212@factor_rec
$LN169@factor_rec:

; 1437 : 
; 1438 :     /* incorporate the shift */
; 1439 :     if ( S->lambda != 0.0 )

	fld	QWORD PTR [esi+112]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN94@factor_rec

; 1440 :     {
; 1441 :       if ( hessian_linear_metric_flag )

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	je	$LN104@factor_rec

; 1442 :       { if ( S->lambda != 0.0 )

	fld	QWORD PTR [esi+112]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN94@factor_rec

; 1443 :         { end = Met.pIA[K+i+1];

	mov	edx, DWORD PTR _K
	mov	eax, DWORD PTR _Met+96
	add	edx, edi
	mov	ecx, DWORD PTR [eax+edx*4+4]
	lea	eax, DWORD PTR [eax+edx*4]

; 1444 :           for ( j = Met.pIA[K+i] ; j < end ; j++ )

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _end$[ebp], ecx
	cmp	eax, ecx
	jge	$LN94@factor_rec
	sub	ecx, eax
	cmp	ecx, 4
	jl	$LC173@factor_rec
	mov	ecx, DWORD PTR _end$[ebp]
	add	ecx, -3					; fffffffdH

; 1445 :              base[Met.pJA[j]-(K+i)] -= S->lambda*Met.pA[j];

	mov	DWORD PTR tv3968[ebp], ecx
$LN213@factor_rec:
	mov	edx, DWORD PTR _Met+100
	mov	ecx, DWORD PTR [edx+eax*4]
	sub	ecx, DWORD PTR _K
	mov	edx, DWORD PTR _Met+104
	fld	QWORD PTR [edx+eax*8]
	sub	ecx, edi
	fmul	QWORD PTR [esi+112]
	lea	ecx, DWORD PTR [ebx+ecx*8]
	add	eax, 4
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _Met+100
	mov	edx, DWORD PTR [ecx+eax*4-12]
	sub	edx, DWORD PTR _K
	sub	edx, edi
	lea	ecx, DWORD PTR [ebx+edx*8]
	mov	edx, DWORD PTR _Met+104
	fld	QWORD PTR [edx+eax*8-24]
	fmul	QWORD PTR [esi+112]
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _Met+100
	mov	edx, DWORD PTR [ecx+eax*4-8]
	sub	edx, DWORD PTR _K
	sub	edx, edi
	lea	ecx, DWORD PTR [ebx+edx*8]
	mov	edx, DWORD PTR _Met+104
	fld	QWORD PTR [edx+eax*8-16]
	mov	DWORD PTR tv6782[ebp], ecx
	fmul	QWORD PTR [esi+112]
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _Met+100
	mov	edx, DWORD PTR [ecx+eax*4-4]
	sub	edx, DWORD PTR _K
	sub	edx, edi
	lea	ecx, DWORD PTR [ebx+edx*8]
	mov	edx, DWORD PTR _Met+104
	fld	QWORD PTR [edx+eax*8-8]
	mov	DWORD PTR tv6811[ebp], ecx
	fmul	QWORD PTR [esi+112]
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR tv3968[ebp]
	jl	$LN213@factor_rec
$LC173@factor_rec:

; 1444 :           for ( j = Met.pIA[K+i] ; j < end ; j++ )

	cmp	eax, DWORD PTR _end$[ebp]
	jge	SHORT $LN94@factor_rec
$LN214@factor_rec:

; 1445 :              base[Met.pJA[j]-(K+i)] -= S->lambda*Met.pA[j];

	mov	ecx, DWORD PTR _Met+100
	mov	edx, DWORD PTR [ecx+eax*4]
	sub	edx, DWORD PTR _K
	inc	eax
	sub	edx, edi
	lea	ecx, DWORD PTR [ebx+edx*8]
	mov	edx, DWORD PTR _Met+104
	fld	QWORD PTR [edx+eax*8-8]
	fmul	QWORD PTR [esi+112]
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	cmp	eax, DWORD PTR _end$[ebp]
	jl	SHORT $LN214@factor_rec

; 1446 :         }

	jmp	SHORT $LN94@factor_rec
$LN104@factor_rec:

; 1447 :       }
; 1448 :       else if ( web.area_norm_flag )

	cmp	DWORD PTR _web+876, 0
	je	SHORT $LN98@factor_rec

; 1449 :          base[0] -= S->lambda*Met.A[S->P[K+i]]; /* special metric matrix */

	mov	eax, DWORD PTR _K
	mov	ecx, DWORD PTR [esi+68]
	add	eax, edi
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _Met+60
	fld	QWORD PTR [eax+edx*8]
	fmul	QWORD PTR [esi+112]
	fsubr	QWORD PTR [ebx]
	jmp	SHORT $LN537@factor_rec
$LN98@factor_rec:

; 1450 :       else if ( augmented_hessian_mode )

	cmp	DWORD PTR _augmented_hessian_mode, 0
	je	SHORT $LN96@factor_rec

; 1451 :       { if ( S->P[K+i] < S->A_rows )   /* do not shift constraints! */

	mov	ecx, DWORD PTR _K
	mov	edx, DWORD PTR [esi+68]
	add	ecx, edi
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, DWORD PTR [esi+12]
	jge	SHORT $LN94@factor_rec
$LN96@factor_rec:

; 1452 :           base[0] -= S->lambda;
; 1453 :       }
; 1454 :       else base[0] -= S->lambda;

	fld	QWORD PTR [ebx]
	fsub	QWORD PTR [esi+112]
$LN537@factor_rec:
	fstp	QWORD PTR [ebx]
$LN94@factor_rec:

; 1455 :     }
; 1456 : 
; 1457 :     /* next, add in previous rows that have entry in col K */
; 1458 :     ii_next = 0;
; 1459 :     for ( ii = xJL[K+i] ; ii >= 0 ; ii = ii_next )

	mov	ecx, DWORD PTR _K
	mov	edx, DWORD PTR _xJL
	add	ecx, edi
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _ii_next$[ebp], 0
	mov	DWORD PTR _ii$[ebp], ecx
	test	ecx, ecx
	js	$LN91@factor_rec
$LN232@factor_rec:

; 1460 :     { REAL *subbase = base - (K+i);

	mov	eax, DWORD PTR _K
	add	eax, edi
	add	eax, eax
	add	eax, eax
	lea	edx, DWORD PTR [eax+eax]
	mov	eax, ebx
	sub	eax, edx

; 1461 :       REAL *la;
; 1462 :       int *ja;
; 1463 :       int  IJdiff = S->LIA[ii] - S->LIJA[ii];

	mov	edx, DWORD PTR [esi+136]
	mov	DWORD PTR _subbase$90112[ebp], eax
	mov	eax, DWORD PTR [esi+128]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv4101[ebp], eax
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _IJdiff$90115[ebp], eax

; 1464 :       switch ( S->psize[ii] )

	mov	eax, DWORD PTR [esi+120]
	mov	eax, DWORD PTR [eax+ecx*4]
	cmp	eax, 3
	ja	$LN292@factor_rec
	jmp	DWORD PTR $LN539@factor_rec[eax*4]
$LN88@factor_rec:

; 1465 :       { case ONEBYONE:
; 1466 :             pivot = S->LA[S->LIA[ii]]*S->LA[xIL[ii]];

	mov	eax, DWORD PTR _xIL
	mov	edx, DWORD PTR [esi+140]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [ecx]
	fld	QWORD PTR [edx+eax*8]
	mov	DWORD PTR tv4116[ebp], ecx
	mov	ecx, DWORD PTR tv4101[ebp]
	mov	ecx, DWORD PTR [ecx]
	fmul	QWORD PTR [edx+ecx*8]

; 1467 :             end = S->LIA[ii+1];

	mov	ecx, DWORD PTR tv4101[ebp]
	mov	ecx, DWORD PTR [ecx+4]

; 1468 :             for ( j = xIL[ii],ja = S->LJA+j-IJdiff,la=S->LA+j ;
; 1469 :                              j < end ; j++,la++,ja++ )

	mov	DWORD PTR _j$[ebp], eax
	sub	eax, DWORD PTR _IJdiff$90115[ebp]
	mov	DWORD PTR _end$[ebp], ecx
	mov	ecx, DWORD PTR [esi+132]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _j$[ebp]
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _la$90113[ebp], edx
	mov	edx, DWORD PTR _end$[ebp]
	cmp	ecx, edx
	jge	$LN305@factor_rec
	mov	ecx, DWORD PTR tv4116[ebp]
	sub	edx, DWORD PTR [ecx]
	cmp	edx, 4
	jl	SHORT $LN222@factor_rec

; 1470 :                      subbase[*ja] -= pivot*(*la);  /* big improvement */

	mov	edx, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _end$[ebp]
	sub	ecx, edx
	sub	ecx, 4
	shr	ecx, 2
	inc	ecx
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv858[ebp], ecx
	mov	DWORD PTR _j$[ebp], edx
$LN231@factor_rec:
	mov	ecx, DWORD PTR [eax]
	fld	ST(0)
	mov	edx, DWORD PTR _subbase$90112[ebp]
	lea	ecx, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _la$90113[ebp]
	fmul	QWORD PTR [edx]
	mov	edx, DWORD PTR _subbase$90112[ebp]
	add	eax, 16					; 00000010H
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax-12]
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _la$90113[ebp]
	fld	QWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _subbase$90112[ebp]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [eax-8]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _la$90113[ebp]
	fld	QWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _subbase$90112[ebp]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [eax-4]
	lea	edx, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _la$90113[ebp]
	fld	QWORD PTR [ecx+24]
	add	ecx, 32					; 00000020H
	dec	DWORD PTR tv858[ebp]
	fmul	ST(0), ST(1)
	mov	DWORD PTR _la$90113[ebp], ecx
	fsubr	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	jne	SHORT $LN231@factor_rec
$LN222@factor_rec:

; 1468 :             for ( j = xIL[ii],ja = S->LJA+j-IJdiff,la=S->LA+j ;
; 1469 :                              j < end ; j++,la++,ja++ )

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _end$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN305@factor_rec
	sub	edx, ecx
	mov	DWORD PTR tv3617[ebp], edx
$LN233@factor_rec:

; 1470 :                      subbase[*ja] -= pivot*(*la);  /* big improvement */

	mov	edx, DWORD PTR [eax]
	fld	ST(0)
	mov	ecx, DWORD PTR _subbase$90112[ebp]
	lea	ecx, DWORD PTR [ecx+edx*8]
	mov	edx, DWORD PTR _la$90113[ebp]
	fmul	QWORD PTR [edx]
	add	edx, 8
	add	eax, 4
	dec	DWORD PTR tv3617[ebp]
	fsubr	QWORD PTR [ecx]
	mov	DWORD PTR _la$90113[ebp], edx
	fstp	QWORD PTR [ecx]
	jne	SHORT $LN233@factor_rec

; 1468 :             for ( j = xIL[ii],ja = S->LJA+j-IJdiff,la=S->LA+j ;
; 1469 :                              j < end ; j++,la++,ja++ )

	mov	edx, DWORD PTR _end$[ebp]
$LN305@factor_rec:

; 1471 :             ii_next = xJL[ii];

	mov	ecx, DWORD PTR _xJL
	fstp	ST(0)
	mov	eax, DWORD PTR _ii$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _ii_next$[ebp], ecx

; 1472 :             if ( ++(xIL[ii]) < end )

	mov	ecx, DWORD PTR tv4116[ebp]
	inc	DWORD PTR [ecx]
	cmp	DWORD PTR [ecx], edx
	jge	$LN92@factor_rec

; 1473 :             { m = S->LJA[xIL[ii]-IJdiff];

	mov	edx, DWORD PTR _xIL
	mov	ecx, DWORD PTR [edx+eax*4]
	sub	ecx, DWORD PTR _IJdiff$90115[ebp]
	mov	edx, DWORD PTR [esi+132]
	mov	edx, DWORD PTR [edx+ecx*4]

; 1474 :               xJL[ii] = xJL[m]; xJL[m] = ii;

	mov	ecx, DWORD PTR _xJL
	mov	DWORD PTR _m$[ebp], edx
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	ecx, DWORD PTR _xJL
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 1475 :             }
; 1476 :           break;

	jmp	$LN92@factor_rec
$LN83@factor_rec:

; 1477 :         case ZEROPIVOT:  /* nothing to add */
; 1478 :             ii_next = xJL[ii];

	mov	eax, DWORD PTR _xJL
	mov	edx, DWORD PTR [eax+ecx*4]

; 1479 :             if ( ++(xIL[ii]) < end )

	mov	eax, DWORD PTR _xIL
	inc	DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _ii_next$[ebp], edx
	mov	edx, DWORD PTR _end$[ebp]
	cmp	DWORD PTR [eax], edx
	jge	$LN92@factor_rec

; 1480 :             { m = S->LJA[xIL[ii]-IJdiff];

	mov	eax, DWORD PTR _xIL
	mov	edx, DWORD PTR [eax+ecx*4]
	sub	edx, DWORD PTR _IJdiff$90115[ebp]
	mov	eax, DWORD PTR [esi+132]
	mov	edx, DWORD PTR [eax+edx*4]

; 1481 :               xJL[ii] = xJL[m]; xJL[m] = ii;

	mov	eax, DWORD PTR _xJL
	mov	DWORD PTR _m$[ebp], edx
	mov	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	eax, DWORD PTR _xJL
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1482 :             }
; 1483 :             break;

	jmp	$LN92@factor_rec
$LN81@factor_rec:

; 1484 :         case SECONDOFPAIR:  /* will handle under FIRSTOFPAIR */
; 1485 :             ii_next = xJL[ii];

	mov	eax, DWORD PTR _xJL
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _ii_next$[ebp], ecx

; 1486 :             break;

	jmp	$LN92@factor_rec
$LN80@factor_rec:

; 1487 :         case FIRSTOFPAIR:
; 1488 :             p11 = S->LA[S->LIA[ii]]; p21 = p12 = S->LA[S->LIA[ii]+1];

	mov	edx, DWORD PTR [esi+140]
	mov	eax, DWORD PTR tv4101[ebp]
	mov	eax, DWORD PTR [eax]
	fld	QWORD PTR [edx+eax*8+8]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	DWORD PTR tv4212[ebp], eax

; 1489 :             p22 = S->LA[S->LIA[ii+1]];
; 1490 :             pa = p11*S->LA[xIL[ii]] + p12*S->LA[xIL[ii+1]];

	mov	eax, DWORD PTR _xIL
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv4116[ebp], eax
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv4220[ebp], eax
	mov	eax, DWORD PTR tv4116[ebp]
	mov	eax, DWORD PTR [eax+4]
	fld	QWORD PTR [edx+eax*8]
	mov	eax, DWORD PTR tv4220[ebp]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [edx+eax*8]
	mov	eax, DWORD PTR tv4212[ebp]
	fmul	QWORD PTR [eax]
	mov	eax, DWORD PTR tv4101[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR tv4236[ebp], eax
	faddp	ST(1), ST(0)

; 1491 :             pb = p21*S->LA[xIL[ii]] + p22*S->LA[xIL[ii+1]];

	fld	QWORD PTR [edx+eax*8]
	mov	eax, DWORD PTR tv4116[ebp]
	mov	eax, DWORD PTR [eax+4]
	fmul	QWORD PTR [edx+eax*8]
	mov	eax, DWORD PTR tv4220[ebp]
	fld	QWORD PTR [edx+eax*8]

; 1492 :             end = S->LIA[ii+1];

	mov	edx, DWORD PTR tv4236[ebp]
	mov	DWORD PTR _end$[ebp], edx
	fmulp	ST(3), ST(0)

; 1493 :             for ( j = xIL[ii], jj = xIL[ii+1] ; j < end ; j++,jj++ )

	mov	edx, DWORD PTR tv4116[ebp]
	mov	edx, DWORD PTR [edx+4]
	faddp	ST(2), ST(0)
	mov	DWORD PTR _jj$90093[ebp], edx
	cmp	eax, DWORD PTR _end$[ebp]
	jge	$LN316@factor_rec
	mov	ecx, DWORD PTR _end$[ebp]
	sub	ecx, eax
	cmp	ecx, 4
	jl	$LN224@factor_rec

; 1494 :                 base[S->LJA[j-IJdiff]-(K+i)] -= pa*S->LA[j] + pb*S->LA[jj];

	mov	ecx, eax
	sub	ecx, DWORD PTR _IJdiff$90115[ebp]
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR tv6187[ebp], ecx
$LN215@factor_rec:
	mov	edx, DWORD PTR [esi+132]
	mov	ecx, DWORD PTR [edx+ecx]
	sub	ecx, DWORD PTR _K
	add	eax, 4
	sub	ecx, edi
	lea	edx, DWORD PTR [ebx+ecx*8]
	mov	ecx, DWORD PTR [esi+140]
	fld	QWORD PTR [ecx+eax*8-32]
	mov	DWORD PTR tv6216[ebp], edx
	mov	edx, DWORD PTR _jj$90093[ebp]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR tv6216[ebp]
	fmul	ST(0), ST(3)
	mov	edx, DWORD PTR tv6187[ebp]
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+132]
	mov	ecx, DWORD PTR [ecx+edx+4]
	sub	ecx, DWORD PTR _K
	sub	ecx, edi
	lea	edx, DWORD PTR [ebx+ecx*8]
	mov	ecx, DWORD PTR [esi+140]
	fld	QWORD PTR [ecx+eax*8-24]
	mov	DWORD PTR tv6237[ebp], edx
	mov	edx, DWORD PTR _jj$90093[ebp]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [ecx+edx*8+8]
	mov	ecx, DWORD PTR tv6237[ebp]
	mov	edx, DWORD PTR tv6187[ebp]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+132]
	mov	ecx, DWORD PTR [ecx+edx+8]
	sub	ecx, DWORD PTR _K
	sub	ecx, edi
	lea	edx, DWORD PTR [ebx+ecx*8]
	mov	ecx, DWORD PTR [esi+140]
	fld	QWORD PTR [ecx+eax*8-16]
	mov	DWORD PTR tv6378[ebp], edx
	mov	edx, DWORD PTR _jj$90093[ebp]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [ecx+edx*8+16]
	mov	ecx, DWORD PTR tv6378[ebp]
	mov	edx, DWORD PTR tv6187[ebp]
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR [esi+132]
	mov	ecx, DWORD PTR [ecx+edx+12]
	sub	ecx, DWORD PTR _K
	sub	ecx, edi
	lea	edx, DWORD PTR [ebx+ecx*8]
	mov	ecx, DWORD PTR [esi+140]
	fld	QWORD PTR [ecx+eax*8-8]
	mov	DWORD PTR tv6415[ebp], edx
	mov	edx, DWORD PTR _jj$90093[ebp]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [ecx+edx*8+24]
	mov	ecx, DWORD PTR tv6415[ebp]
	mov	edx, DWORD PTR _end$[ebp]
	fmul	ST(0), ST(3)
	add	DWORD PTR _jj$90093[ebp], 4
	add	edx, -3					; fffffffdH
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR tv6187[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR tv6187[ebp], ecx
	cmp	eax, edx
	jl	$LN215@factor_rec
$LN224@factor_rec:

; 1493 :             for ( j = xIL[ii], jj = xIL[ii+1] ; j < end ; j++,jj++ )

	cmp	eax, DWORD PTR _end$[ebp]
	jge	SHORT $LN323@factor_rec
	mov	edx, DWORD PTR _jj$90093[ebp]
	mov	ecx, eax
	sub	ecx, DWORD PTR _IJdiff$90115[ebp]
	add	edx, edx
	add	ecx, ecx
	add	ecx, ecx
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR tv6511[ebp], ecx
	mov	DWORD PTR tv6513[ebp], edx
$LN216@factor_rec:

; 1494 :                 base[S->LJA[j-IJdiff]-(K+i)] -= pa*S->LA[j] + pb*S->LA[jj];

	mov	edx, DWORD PTR [esi+132]
	mov	ecx, DWORD PTR [ecx+edx]
	sub	ecx, DWORD PTR _K
	inc	eax
	sub	ecx, edi
	lea	edx, DWORD PTR [ebx+ecx*8]
	mov	ecx, DWORD PTR [esi+140]
	fld	QWORD PTR [ecx+eax*8-8]
	mov	DWORD PTR tv6528[ebp], edx
	mov	edx, DWORD PTR tv6513[ebp]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR tv6528[ebp]
	fmul	ST(0), ST(3)
	add	edx, 8
	mov	DWORD PTR tv6513[ebp], edx
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	mov	ecx, DWORD PTR tv6511[ebp]
	add	ecx, 4
	mov	DWORD PTR tv6511[ebp], ecx
	cmp	eax, DWORD PTR _end$[ebp]
	jl	SHORT $LN216@factor_rec
$LN323@factor_rec:

; 1493 :             for ( j = xIL[ii], jj = xIL[ii+1] ; j < end ; j++,jj++ )

	mov	ecx, DWORD PTR _ii$[ebp]
$LN316@factor_rec:

; 1495 :             ii_next = xJL[ii];

	mov	eax, DWORD PTR _xJL
	fstp	ST(0)
	mov	edx, DWORD PTR [eax+ecx*4]
	fstp	ST(0)

; 1496 :             if ( ++(xIL[ii]) < end )

	mov	eax, DWORD PTR tv4116[ebp]
	inc	DWORD PTR [eax]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _ii_next$[ebp], edx
	cmp	eax, DWORD PTR _end$[ebp]
	jge	SHORT $LN230@factor_rec

; 1497 :             { m = S->LJA[xIL[ii]-IJdiff];

	mov	edx, DWORD PTR _xIL
	mov	eax, DWORD PTR [edx+ecx*4]
	sub	eax, DWORD PTR _IJdiff$90115[ebp]
	mov	edx, DWORD PTR [esi+132]
	mov	eax, DWORD PTR [edx+eax*4]

; 1498 :               xJL[ii] = xJL[m]; xJL[m] = ii;

	mov	edx, DWORD PTR _xJL
	mov	DWORD PTR _m$[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	edx, DWORD PTR _xJL
	mov	eax, DWORD PTR _m$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx
$LN230@factor_rec:

; 1499 :             }
; 1500 :             if ( ii_next == ii+1 ) ii_next = xJL[ii+1];

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR tv4360[ebp], eax
	cmp	DWORD PTR _ii_next$[ebp], eax
	jne	SHORT $LN75@factor_rec
	mov	edx, DWORD PTR _xJL
	mov	eax, DWORD PTR [edx+ecx*4+4]
	mov	DWORD PTR _ii_next$[ebp], eax
$LN75@factor_rec:

; 1501 :             if ( ++(xIL[ii+1]) < end )

	mov	edx, DWORD PTR _xIL
	inc	DWORD PTR [edx+ecx*4+4]
	lea	eax, DWORD PTR [edx+ecx*4+4]
	mov	edx, DWORD PTR _end$[ebp]
	cmp	DWORD PTR [eax], edx
	jge	SHORT $LN92@factor_rec

; 1502 :             { m = S->LJA[xIL[ii+1]-(S->LIA[ii+1]-S->LIJA[ii+1])];

	mov	eax, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [eax+ecx*4+4]
	mov	edx, DWORD PTR [esi+128]
	sub	eax, DWORD PTR [edx+ecx*4+4]
	mov	edx, DWORD PTR _xIL
	add	eax, DWORD PTR [edx+ecx*4+4]
	mov	edx, DWORD PTR [esi+132]
	mov	edx, DWORD PTR [edx+eax*4]

; 1503 :               xJL[ii+1] = xJL[m]; xJL[m] = ii+1;

	mov	eax, DWORD PTR _xJL
	mov	DWORD PTR _m$[ebp], edx
	mov	edx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [eax+ecx*4+4], edx
	mov	eax, DWORD PTR _xJL
	mov	ecx, DWORD PTR tv4360[ebp]
	mov	edx, DWORD PTR _m$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1504 :             }
; 1505 : 
; 1506 :              break;

	jmp	SHORT $LN92@factor_rec
$LN292@factor_rec:

; 1507 :         default: kb_error(1835,"Internal error: Illegal case of psize\n",
; 1508 :                           RECOVERABLE);

	push	1
	fstp	ST(0)
	push	OFFSET ??_C@_0CH@LHAOEJKE@Internal?5error?3?5Illegal?5case?5of?5@
	push	1835					; 0000072bH
	call	_kb_error
	fldz
	add	esp, 12					; 0000000cH
$LN92@factor_rec:

; 1455 :     }
; 1456 : 
; 1457 :     /* next, add in previous rows that have entry in col K */
; 1458 :     ii_next = 0;
; 1459 :     for ( ii = xJL[K+i] ; ii >= 0 ; ii = ii_next )

	mov	ecx, DWORD PTR _ii_next$[ebp]
	mov	DWORD PTR _ii$[ebp], ecx
	test	ecx, ecx
	jns	$LN232@factor_rec
$LN91@factor_rec:

; 1509 : 
; 1510 :        }
; 1511 :      }
; 1512 : 
; 1513 :      /* compress to dense form */ 
; 1514 :      for ( j = to_elim ; j < r->size ; j++ )

	mov	eax, DWORD PTR _to_elim$[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR [ecx+32]
	jge	SHORT $LN227@factor_rec
	mov	edx, DWORD PTR tv6863[ebp]
	add	edx, ebx
	mov	DWORD PTR tv6672[ebp], edx
$LN72@factor_rec:

; 1515 :      { REAL *to =  base + j - i;
; 1516 :        REAL *from = base + INT(r->verlist)[j] - (K+i);

	mov	edx, DWORD PTR [ecx+4]
	add	edx, eax
	mov	eax, DWORD PTR [esi+92]
	mov	edx, DWORD PTR [eax+edx*4]
	sub	edx, DWORD PTR _K
	sub	edx, edi
	lea	eax, DWORD PTR [ebx+edx*8]

; 1517 :        if ( from != to )

	mov	edx, DWORD PTR tv6672[ebp]
	cmp	eax, edx
	je	SHORT $LN71@factor_rec

; 1518 :        { *to = *from;

	fld	QWORD PTR [eax]
	fstp	QWORD PTR [edx]

; 1519 :          *from = 0.0;  /* clear for next round */

	fst	QWORD PTR [eax]
$LN71@factor_rec:

; 1509 : 
; 1510 :        }
; 1511 :      }
; 1512 : 
; 1513 :      /* compress to dense form */ 
; 1514 :      for ( j = to_elim ; j < r->size ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	add	edx, 8
	mov	DWORD PTR _j$[ebp], eax
	mov	DWORD PTR tv6672[ebp], edx
	cmp	eax, DWORD PTR [ecx+32]
	jl	SHORT $LN72@factor_rec
$LN227@factor_rec:

; 1520 :        }
; 1521 :      }
; 1522 :      S->LIA[K+i+1] = S->LIA[K+i] + r->size - i;

	mov	eax, DWORD PTR _K
	mov	edx, DWORD PTR [esi+128]
	sub	DWORD PTR tv6863[ebp], 8
	add	eax, edi
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax]
	sub	edx, edi
	add	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+4], edx

; 1523 : 
; 1524 :      base += r->size - i;

	mov	eax, DWORD PTR [ecx+32]
	sub	eax, edi
	inc	edi
	lea	ebx, DWORD PTR [ebx+eax*8]
	cmp	edi, DWORD PTR _to_elim$[ebp]
	jl	$LN210@factor_rec
$LN228@factor_rec:

; 1525 :   }
; 1526 : 
; 1527 :   /* fill in LJA */
; 1528 :   for ( i = 0 ; i < to_elim ; i++ )

	mov	edi, DWORD PTR _IJA_base
	xor	eax, eax
	cmp	DWORD PTR _to_elim$[ebp], eax
	jle	SHORT $LN66@factor_rec
$LN218@factor_rec:

; 1529 :         S->LIJA[K+i] =  IJA_base + i;

	mov	edx, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+136]
	add	edx, eax
	lea	ecx, DWORD PTR [edi+eax]
	inc	eax
	mov	DWORD PTR [ebx+edx*4], ecx
	cmp	eax, DWORD PTR _to_elim$[ebp]
	jl	SHORT $LN218@factor_rec
$LN66@factor_rec:

; 1530 :   jspot = S->LJA + S->LIJA[K];

	mov	eax, DWORD PTR [esi+136]
	mov	ecx, DWORD PTR _K
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [esi+132]

; 1531 :   for ( m = 0 ; m < r->size ; m++,jspot++ ) 

	mov	ecx, DWORD PTR _r$[ebp]
	lea	edx, DWORD PTR [eax+edx*4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+32], eax
	jle	SHORT $LN63@factor_rec
$LN65@factor_rec:

; 1532 :           *jspot = INT(r->verlist)[m];

	mov	edi, DWORD PTR [ecx+4]
	mov	ebx, DWORD PTR [esi+92]
	add	edi, eax
	mov	edi, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR [edx], edi
	inc	eax
	add	edx, 4
	cmp	eax, DWORD PTR [ecx+32]
	jl	SHORT $LN65@factor_rec

; 1531 :   for ( m = 0 ; m < r->size ; m++,jspot++ ) 

	mov	edi, DWORD PTR _IJA_base
$LN63@factor_rec:

; 1533 :   IJA_base += r->size;

	add	edi, DWORD PTR [ecx+32]
	mov	DWORD PTR _IJA_base, edi

; 1534 : 
; 1535 :   /* factor */
; 1536 :   for ( i = 0 ; i < to_elim ; i++ )  /* pivot row */

	xor	edi, edi
	cmp	DWORD PTR _to_elim$[ebp], edi
	jle	$LN515@factor_rec
$LN221@factor_rec:

; 1537 :   { REAL *pivrow = S->LA + S->LIA[K+i];

	mov	ebx, DWORD PTR _K
	fld	QWORD PTR __real@bff0000000000000
	mov	eax, DWORD PTR [esi+128]
	fld1
	mov	ecx, DWORD PTR [esi+140]

; 1538 :     int p;
; 1539 :     REAL big,sigma,critsize;
; 1540 :     int br;
; 1541 : 
; 1542 :     /* first, decide on 1x1 or 2x2 pivot */
; 1543 :     p = ONEBYONE; /* default pivot size 1 */
; 1544 :     /* find max element in pivot row (same as pivot col) */
; 1545 :     /* but only considering current supernode */
; 1546 :     for ( j=i+1,big=-1.0,br = 0  ; j < to_elim ; j++ )

	fld	ST(1)
	add	ebx, edi
	mov	edx, DWORD PTR [eax+ebx*4]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	DWORD PTR _pivrow$90152[ebp], eax
	mov	eax, DWORD PTR _to_elim$[ebp]
	lea	edx, DWORD PTR [edi+1]
	xor	ecx, ecx
	mov	DWORD PTR tv3895[ebp], ebx
	mov	DWORD PTR tv4409[ebp], edx
	cmp	edx, eax
	jge	$LN239@factor_rec
	sub	eax, edx
	cmp	eax, 4
	jl	SHORT $LN234@factor_rec

; 1547 :       if ( fabs(pivrow[j-i]) > big )

	mov	ebx, DWORD PTR _pivrow$90152[ebp]
	mov	eax, edx
	sub	eax, edi
	lea	ebx, DWORD PTR [ebx+eax*8+16]
$LN187@factor_rec:
	fld	QWORD PTR [ebx-16]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN362@factor_rec

; 1548 :       { big = fabs(pivrow[j-i]); br = j; }

	fstp	ST(1)
	mov	ecx, edx
	jmp	SHORT $LN183@factor_rec
$LN362@factor_rec:
	fstp	ST(0)
$LN183@factor_rec:

; 1547 :       if ( fabs(pivrow[j-i]) > big )

	fld	QWORD PTR [ebx-8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN365@factor_rec
	fstp	ST(1)
	lea	ecx, DWORD PTR [edx+1]
	jmp	SHORT $LN184@factor_rec
$LN365@factor_rec:
	fstp	ST(0)
$LN184@factor_rec:
	fld	QWORD PTR [ebx]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN368@factor_rec
	fstp	ST(1)
	lea	ecx, DWORD PTR [edx+2]
	jmp	SHORT $LN185@factor_rec
$LN368@factor_rec:
	fstp	ST(0)
$LN185@factor_rec:
	fld	QWORD PTR [ebx+8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN371@factor_rec
	fstp	ST(1)
	lea	ecx, DWORD PTR [edx+3]
	jmp	SHORT $LN186@factor_rec
$LN371@factor_rec:
	fstp	ST(0)
$LN186@factor_rec:
	mov	eax, DWORD PTR _to_elim$[ebp]
	add	edx, 4
	add	eax, -3					; fffffffdH
	add	ebx, 32					; 00000020H
	cmp	edx, eax
	jl	SHORT $LN187@factor_rec
$LN234@factor_rec:

; 1538 :     int p;
; 1539 :     REAL big,sigma,critsize;
; 1540 :     int br;
; 1541 : 
; 1542 :     /* first, decide on 1x1 or 2x2 pivot */
; 1543 :     p = ONEBYONE; /* default pivot size 1 */
; 1544 :     /* find max element in pivot row (same as pivot col) */
; 1545 :     /* but only considering current supernode */
; 1546 :     for ( j=i+1,big=-1.0,br = 0  ; j < to_elim ; j++ )

	cmp	edx, DWORD PTR _to_elim$[ebp]
	jge	SHORT $LN235@factor_rec
	mov	ebx, DWORD PTR _pivrow$90152[ebp]
	mov	eax, edx
	sub	eax, edi
	lea	ebx, DWORD PTR [ebx+eax*8]
$LC59@factor_rec:

; 1547 :       if ( fabs(pivrow[j-i]) > big )

	fld	QWORD PTR [ebx]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN378@factor_rec

; 1548 :       { big = fabs(pivrow[j-i]); br = j; }

	fstp	ST(1)
	mov	ecx, edx
	jmp	SHORT $LN58@factor_rec
$LN378@factor_rec:
	fstp	ST(0)
$LN58@factor_rec:
	inc	edx

; 1538 :     int p;
; 1539 :     REAL big,sigma,critsize;
; 1540 :     int br;
; 1541 : 
; 1542 :     /* first, decide on 1x1 or 2x2 pivot */
; 1543 :     p = ONEBYONE; /* default pivot size 1 */
; 1544 :     /* find max element in pivot row (same as pivot col) */
; 1545 :     /* but only considering current supernode */
; 1546 :     for ( j=i+1,big=-1.0,br = 0  ; j < to_elim ; j++ )

	add	ebx, 8
	cmp	edx, DWORD PTR _to_elim$[ebp]
	jl	SHORT $LC59@factor_rec
$LN235@factor_rec:
	mov	ebx, DWORD PTR tv3895[ebp]
$LN239@factor_rec:

; 1549 :     critsize = hessian_epsilon * S->rowmag[S->P[K+i]];

	mov	edx, DWORD PTR [esi+68]
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR [esi+204]
	fld	QWORD PTR [edx+eax*8]

; 1550 :     if ( ((big <= critsize)||(!BK_flag))
; 1551 :                     && (fabs(pivrow[0]) <= critsize) )

	mov	edx, DWORD PTR _BK_flag
	fmul	QWORD PTR _hessian_epsilon
	fcom	ST(1)
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN250@factor_rec
	test	edx, edx
	jne	$LN385@factor_rec
$LN250@factor_rec:
	mov	eax, DWORD PTR _pivrow$90152[ebp]
	fld	QWORD PTR [eax]
	fabs
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H

; 1552 :        p = ZEROPIVOT;

	jp	SHORT $LN251@factor_rec

; 1563 :       { p = FIRSTOFPAIR; }
; 1564 :     }
; 1565 : 
; 1566 :     if ( p == ZEROPIVOT )
; 1567 :     { S->psize[K+i] = ZEROPIVOT; S->zero++;

	mov	ecx, DWORD PTR [esi+120]
	fstp	ST(0)
	mov	DWORD PTR [ecx+ebx*4], 0
	fstp	ST(1)

; 1568 :       if ( S->P[K+i] >= S->A_rows ) S->degencon++;

	mov	ecx, DWORD PTR [esi+68]
	fstp	ST(1)
	mov	eax, 1
	fstp	ST(0)
	add	DWORD PTR [esi+192], eax
	mov	edx, DWORD PTR _K
	add	edx, edi
	mov	edx, DWORD PTR [ecx+edx*4]
	cmp	edx, DWORD PTR [esi+12]
	jl	SHORT $LN41@factor_rec
	add	DWORD PTR [esi+196], eax
$LN41@factor_rec:

; 1569 :       memset((char*)pivrow,0,(r->size-i)*sizeof(REAL));

	mov	eax, DWORD PTR _r$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _pivrow$90152[ebp]
	sub	ecx, edi
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	0
	push	edx
	call	_memset

; 1570 :       xIL[K+i] = -1;

	fldz
	mov	eax, DWORD PTR _K
	mov	ecx, DWORD PTR _xIL
	mov	ebx, DWORD PTR _to_elim$[ebp]
	add	esp, 12					; 0000000cH
	add	eax, edi
	mov	DWORD PTR [ecx+eax*4], -1
	jmp	$LN61@factor_rec
$LN385@factor_rec:

; 1552 :        p = ZEROPIVOT;

	fstp	ST(0)
$LN251@factor_rec:

; 1553 :     else if ( (big*BKalpha > fabs(pivrow[0])) && BK_flag )

	fld	QWORD PTR _BKalpha
	mov	eax, DWORD PTR _pivrow$90152[ebp]
	fmul	ST(0), ST(1)
	fld	QWORD PTR [eax]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	$LN390@factor_rec
	test	edx, edx
	je	$LN390@factor_rec

; 1554 :     { /* find max in row/col r */
; 1555 :       REAL *rr;
; 1556 :       for ( j = i, sigma = -1.0; j<br ; j++,rr++ )

	mov	edx, edi
	cmp	edi, ecx
	jge	$LN188@factor_rec
	mov	eax, ecx
	sub	eax, edi
	cmp	eax, 4
	jl	$LC189@factor_rec

; 1557 :       { rr = S->LA + S->LIA[K+j] + br - j;

	mov	eax, DWORD PTR [esi+128]
	lea	eax, DWORD PTR [eax+ebx*4+8]
	mov	DWORD PTR tv7296[ebp], eax
	mov	eax, DWORD PTR [esi+128]
	lea	eax, DWORD PTR [eax+ebx*4+4]
	mov	DWORD PTR tv7356[ebp], eax
$LN194@factor_rec:
	mov	eax, DWORD PTR tv7296[ebp]
	mov	eax, DWORD PTR [eax-8]
	mov	ebx, DWORD PTR [esi+140]
	sub	eax, edx
	add	eax, ecx

; 1558 :         if ( fabs(*rr) > sigma ) sigma = fabs(*rr);

	fld	QWORD PTR [ebx+eax*8]
	lea	eax, DWORD PTR [ebx+eax*8]
	fabs
	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN400@factor_rec
	fstp	ST(5)
	jmp	SHORT $LN190@factor_rec
$LN400@factor_rec:
	fstp	ST(0)
$LN190@factor_rec:

; 1557 :       { rr = S->LA + S->LIA[K+j] + br - j;

	mov	ebx, DWORD PTR tv7356[ebp]
	mov	eax, ecx
	sub	eax, edx
	add	eax, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [esi+140]

; 1558 :         if ( fabs(*rr) > sigma ) sigma = fabs(*rr);

	fld	QWORD PTR [ebx+eax*8-8]
	lea	eax, DWORD PTR [ebx+eax*8-8]
	fabs
	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN403@factor_rec
	fstp	ST(5)
	jmp	SHORT $LN191@factor_rec
$LN403@factor_rec:
	fstp	ST(0)
$LN191@factor_rec:

; 1557 :       { rr = S->LA + S->LIA[K+j] + br - j;

	mov	ebx, DWORD PTR tv7296[ebp]
	mov	eax, ecx
	sub	eax, edx
	add	eax, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [esi+140]

; 1558 :         if ( fabs(*rr) > sigma ) sigma = fabs(*rr);

	fld	QWORD PTR [ebx+eax*8-16]
	lea	eax, DWORD PTR [ebx+eax*8-16]
	fabs
	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN406@factor_rec
	fstp	ST(5)
	jmp	SHORT $LN192@factor_rec
$LN406@factor_rec:
	fstp	ST(0)
$LN192@factor_rec:

; 1557 :       { rr = S->LA + S->LIA[K+j] + br - j;

	mov	eax, DWORD PTR tv7296[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, edx
	add	eax, ecx

; 1558 :         if ( fabs(*rr) > sigma ) sigma = fabs(*rr);

	fld	QWORD PTR [ebx+eax*8-24]
	lea	eax, DWORD PTR [ebx+eax*8-24]
	fabs
	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN409@factor_rec
	fstp	ST(5)
	jmp	SHORT $LN193@factor_rec
$LN409@factor_rec:
	fstp	ST(0)
$LN193@factor_rec:

; 1557 :       { rr = S->LA + S->LIA[K+j] + br - j;

	mov	eax, 16					; 00000010H
	add	DWORD PTR tv7356[ebp], eax
	add	DWORD PTR tv7296[ebp], eax
	add	edx, 4
	lea	eax, DWORD PTR [ecx-3]
	cmp	edx, eax
	jl	$LN194@factor_rec
	mov	ebx, DWORD PTR tv3895[ebp]
$LC189@factor_rec:

; 1554 :     { /* find max in row/col r */
; 1555 :       REAL *rr;
; 1556 :       for ( j = i, sigma = -1.0; j<br ; j++,rr++ )

	cmp	edx, ecx
	jge	SHORT $LN188@factor_rec
	mov	eax, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	eax, edx
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR tv7446[ebp], eax
$LC51@factor_rec:

; 1557 :       { rr = S->LA + S->LIA[K+j] + br - j;

	mov	eax, DWORD PTR tv7446[ebp]
	mov	ebx, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+140]
	sub	ebx, edx
	add	ebx, ecx

; 1558 :         if ( fabs(*rr) > sigma ) sigma = fabs(*rr);

	fld	QWORD PTR [eax+ebx*8]
	lea	eax, DWORD PTR [eax+ebx*8]
	fabs
	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN417@factor_rec
	fstp	ST(5)
	jmp	SHORT $LN50@factor_rec
$LN417@factor_rec:
	fstp	ST(0)
$LN50@factor_rec:

; 1554 :     { /* find max in row/col r */
; 1555 :       REAL *rr;
; 1556 :       for ( j = i, sigma = -1.0; j<br ; j++,rr++ )

	add	DWORD PTR tv7446[ebp], 4
	inc	edx
	cmp	edx, ecx
	jl	SHORT $LC51@factor_rec
	mov	ebx, DWORD PTR tv3895[ebp]
$LN188@factor_rec:

; 1559 :       }
; 1560 :       for ( rr = S->LA + S->LIA[K+br], j = br ; j < to_elim; rr++, j++ )

	mov	edx, DWORD PTR _K
	mov	eax, DWORD PTR [esi+128]
	add	edx, ecx
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [esi+140]
	lea	edx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _rr$90166[ebp], edx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR _to_elim$[ebp]
	jge	$LN195@factor_rec
	mov	edx, DWORD PTR _to_elim$[ebp]
	mov	eax, edx
	sub	eax, ecx
	cmp	eax, 4
	jl	SHORT $LN240@factor_rec

; 1561 :        if ( fabs(*rr) > sigma ) sigma = fabs(*rr);

	sub	edx, ecx
	sub	edx, 4
	shr	edx, 2
	inc	edx
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _j$[ebp], eax
$LN201@factor_rec:
	mov	eax, DWORD PTR _rr$90166[ebp]
	fld	QWORD PTR [eax]
	fabs
	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN429@factor_rec
	fstp	ST(5)
	jmp	SHORT $LN197@factor_rec
$LN429@factor_rec:
	fstp	ST(0)
$LN197@factor_rec:
	mov	eax, DWORD PTR _rr$90166[ebp]
	fld	QWORD PTR [eax+8]
	fabs
	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN432@factor_rec
	fstp	ST(5)
	jmp	SHORT $LN198@factor_rec
$LN432@factor_rec:
	fstp	ST(0)
$LN198@factor_rec:
	mov	eax, DWORD PTR _rr$90166[ebp]
	fld	QWORD PTR [eax+16]
	fabs
	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN435@factor_rec
	fstp	ST(5)
	jmp	SHORT $LN199@factor_rec
$LN435@factor_rec:
	fstp	ST(0)
$LN199@factor_rec:
	mov	eax, DWORD PTR _rr$90166[ebp]
	fld	QWORD PTR [eax+24]
	fabs
	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN438@factor_rec
	fstp	ST(5)
	jmp	SHORT $LN200@factor_rec
$LN438@factor_rec:
	fstp	ST(0)
$LN200@factor_rec:
	add	DWORD PTR _rr$90166[ebp], 32		; 00000020H
	dec	edx
	jne	SHORT $LN201@factor_rec
	mov	edx, DWORD PTR _to_elim$[ebp]
$LN240@factor_rec:

; 1559 :       }
; 1560 :       for ( rr = S->LA + S->LIA[K+br], j = br ; j < to_elim; rr++, j++ )

	cmp	DWORD PTR _j$[ebp], edx
	jge	SHORT $LN195@factor_rec
	mov	edx, DWORD PTR _to_elim$[ebp]
	sub	edx, DWORD PTR _j$[ebp]
$LC47@factor_rec:

; 1561 :        if ( fabs(*rr) > sigma ) sigma = fabs(*rr);

	mov	eax, DWORD PTR _rr$90166[ebp]
	fld	QWORD PTR [eax]
	fabs
	fcom	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN446@factor_rec
	fstp	ST(5)
	jmp	SHORT $LN46@factor_rec
$LN446@factor_rec:
	fstp	ST(0)
$LN46@factor_rec:

; 1559 :       }
; 1560 :       for ( rr = S->LA + S->LIA[K+br], j = br ; j < to_elim; rr++, j++ )

	add	DWORD PTR _rr$90166[ebp], 8
	dec	edx
	jne	SHORT $LC47@factor_rec
$LN195@factor_rec:

; 1562 :       if ( BKalpha*big*big > sigma*fabs(pivrow[0]) )

	fxch	ST(1)
	fmulp	ST(2), ST(0)
	fmulp	ST(3), ST(0)
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jne	$LN248@factor_rec

; 1596 :     { REAL *pivrow1 = pivrow;
; 1597 :       REAL *pivrow2 = S->LA + S->LIA[K+i+1];

	mov	eax, DWORD PTR [esi+128]
	mov	edx, DWORD PTR [eax+ebx*4+4]
	mov	eax, DWORD PTR [esi+140]
	lea	edx, DWORD PTR [eax+edx*8]

; 1598 :       REAL p11,p12,p22,detinv,*yy1,*yy2,pa1,pa2;
; 1599 :       int k;
; 1600 :       REAL *x;
; 1601 : 
; 1602 :       S->psize[K+i] = FIRSTOFPAIR;

	mov	eax, DWORD PTR [esi+120]
	mov	DWORD PTR [eax+ebx*4], 2

; 1603 :       S->psize[K+i+1] = SECONDOFPAIR;

	mov	eax, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+120]
	add	eax, edi
	mov	DWORD PTR [ebx+eax*4+4], 3

; 1604 :       if ( br != i+1 ) /* swap rows to get adjacent */

	mov	ebx, DWORD PTR tv4409[ebp]
	mov	DWORD PTR _pivrow2$90199[ebp], edx
	cmp	ecx, ebx
	je	$LN246@factor_rec

; 1605 :       { REAL dtmp,*rii,*rr;
; 1606 :         int c;
; 1607 : 
; 1608 :         /* swap in matrix, both A and JA */
; 1609 : #define DSWAP(a,b)  {dtmp=(a);(a)=(b);(b)=dtmp;}
; 1610 :         for ( j = 0 ; j <= i ; j++ ) /* swap columns */

	xor	eax, eax
	test	edi, edi
	js	$LN202@factor_rec
	cmp	ebx, 4
	jl	$LC203@factor_rec
$LN204@factor_rec:

; 1611 :         { rr = S->LA + S->LIA[K+j] - j;

	mov	edx, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR [esi+140]
	sub	edx, eax
	lea	edx, DWORD PTR [ebx+edx*8]

; 1612 :           DSWAP(rr[i+1],rr[br]);

	fld	QWORD PTR [edx+edi*8+8]
	fld	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+edi*8+8]
	fstp	QWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4+4]
	mov	ebx, DWORD PTR [esi+140]
	sub	edx, eax
	lea	edx, DWORD PTR [ebx+edx*8-8]
	fld	QWORD PTR [edx+edi*8+8]
	fld	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+edi*8+8]
	fstp	QWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4+8]
	mov	ebx, DWORD PTR [esi+140]
	sub	edx, eax
	lea	edx, DWORD PTR [ebx+edx*8-16]
	fld	QWORD PTR [edx+edi*8+8]
	fld	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+edi*8+8]
	fstp	QWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4+12]
	mov	ebx, DWORD PTR [esi+140]
	sub	edx, eax
	lea	edx, DWORD PTR [ebx+edx*8-24]
	fld	QWORD PTR [edx+edi*8+8]
	add	eax, 4
	fld	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+edi*8+8]
	fstp	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edi-3]
	cmp	eax, edx
	jle	$LN204@factor_rec
	mov	edx, DWORD PTR _pivrow2$90199[ebp]
$LC203@factor_rec:

; 1605 :       { REAL dtmp,*rii,*rr;
; 1606 :         int c;
; 1607 : 
; 1608 :         /* swap in matrix, both A and JA */
; 1609 : #define DSWAP(a,b)  {dtmp=(a);(a)=(b);(b)=dtmp;}
; 1610 :         for ( j = 0 ; j <= i ; j++ ) /* swap columns */

	cmp	eax, edi
	jg	SHORT $LN202@factor_rec
$LC24@factor_rec:

; 1611 :         { rr = S->LA + S->LIA[K+j] - j;

	mov	edx, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR [esi+140]
	sub	edx, eax
	lea	edx, DWORD PTR [ebx+edx*8]

; 1612 :           DSWAP(rr[i+1],rr[br]);

	fld	QWORD PTR [edx+edi*8+8]
	inc	eax
	fld	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+edi*8+8]
	fstp	QWORD PTR [edx+ecx*8]
	cmp	eax, edi
	jle	SHORT $LC24@factor_rec

; 1605 :       { REAL dtmp,*rii,*rr;
; 1606 :         int c;
; 1607 : 
; 1608 :         /* swap in matrix, both A and JA */
; 1609 : #define DSWAP(a,b)  {dtmp=(a);(a)=(b);(b)=dtmp;}
; 1610 :         for ( j = 0 ; j <= i ; j++ ) /* swap columns */

	mov	edx, DWORD PTR _pivrow2$90199[ebp]
$LN202@factor_rec:

; 1613 :         }
; 1614 :         for ( j = i+2 ; j < br ; j++ )  /* across to down */

	lea	eax, DWORD PTR [edi+2]
	cmp	eax, ecx
	jge	$LN205@factor_rec
	mov	ebx, ecx
	sub	ebx, eax
	cmp	ebx, 4
	jl	$LC206@factor_rec

; 1615 :         { DSWAP(pivrow2[j-(i+1)],S->LA[S->LIA[K+j]+br-j]);

	mov	ebx, eax
	sub	ebx, edi
	lea	edx, DWORD PTR [edx+ebx*8+8]
	mov	DWORD PTR tv7693[ebp], edx
$LN207@factor_rec:
	mov	ebx, DWORD PTR [esi+128]
	mov	edx, DWORD PTR tv7693[ebp]
	fld	QWORD PTR [edx-16]
	mov	edx, DWORD PTR _K
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4]
	sub	edx, eax
	add	edx, ecx
	mov	ebx, DWORD PTR [esi+140]
	fld	QWORD PTR [ebx+edx*8]
	mov	edx, DWORD PTR tv7693[ebp]
	fstp	QWORD PTR [edx-16]
	mov	edx, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4]
	sub	edx, eax
	mov	ebx, DWORD PTR [esi+140]
	add	edx, ecx
	fstp	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [esi+128]
	mov	edx, DWORD PTR tv7693[ebp]
	fld	QWORD PTR [edx-8]
	mov	edx, DWORD PTR _K
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4+4]
	mov	ebx, DWORD PTR [esi+140]
	sub	edx, eax
	add	edx, ecx
	fld	QWORD PTR [ebx+edx*8-8]
	mov	edx, DWORD PTR tv7693[ebp]
	fstp	QWORD PTR [edx-8]
	mov	edx, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4+4]
	mov	ebx, DWORD PTR [esi+140]
	sub	edx, eax
	add	edx, ecx
	fstp	QWORD PTR [ebx+edx*8-8]
	mov	edx, DWORD PTR tv7693[ebp]
	fld	QWORD PTR [edx]
	mov	edx, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4+8]
	mov	ebx, DWORD PTR [esi+140]
	sub	edx, eax
	add	edx, ecx
	fld	QWORD PTR [ebx+edx*8-16]
	mov	edx, DWORD PTR tv7693[ebp]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4+8]
	mov	ebx, DWORD PTR [esi+140]
	sub	edx, eax
	add	edx, ecx
	fstp	QWORD PTR [ebx+edx*8-16]
	mov	edx, DWORD PTR tv7693[ebp]
	fld	QWORD PTR [edx+8]
	mov	edx, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4+12]
	mov	ebx, DWORD PTR [esi+140]
	sub	edx, eax
	add	edx, ecx
	fld	QWORD PTR [ebx+edx*8-24]
	mov	edx, DWORD PTR tv7693[ebp]
	fstp	QWORD PTR [edx+8]
	mov	edx, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4+12]
	mov	ebx, DWORD PTR [esi+140]
	sub	edx, eax
	add	edx, ecx
	fstp	QWORD PTR [ebx+edx*8-24]
	add	eax, 4
	add	DWORD PTR tv7693[ebp], 32		; 00000020H
	lea	edx, DWORD PTR [ecx-3]
	cmp	eax, edx
	jl	$LN207@factor_rec
	mov	edx, DWORD PTR _pivrow2$90199[ebp]
$LC206@factor_rec:

; 1613 :         }
; 1614 :         for ( j = i+2 ; j < br ; j++ )  /* across to down */

	cmp	eax, ecx
	jge	SHORT $LN205@factor_rec
	mov	ebx, eax
	sub	ebx, edi
	lea	edx, DWORD PTR [edx+ebx*8-8]
	mov	DWORD PTR tv7773[ebp], edx
$LC21@factor_rec:

; 1615 :         { DSWAP(pivrow2[j-(i+1)],S->LA[S->LIA[K+j]+br-j]);

	mov	edx, DWORD PTR tv7773[ebp]
	fld	QWORD PTR [edx]
	mov	edx, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR [esi+140]
	sub	edx, eax
	add	edx, ecx
	fld	QWORD PTR [ebx+edx*8]
	mov	edx, DWORD PTR tv7773[ebp]
	add	DWORD PTR tv7773[ebp], 8
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	edx, eax
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR [esi+140]
	sub	edx, eax
	add	edx, ecx
	inc	eax
	fstp	QWORD PTR [ebx+edx*8]
	cmp	eax, ecx
	jl	SHORT $LC21@factor_rec

; 1613 :         }
; 1614 :         for ( j = i+2 ; j < br ; j++ )  /* across to down */

	mov	edx, DWORD PTR _pivrow2$90199[ebp]
$LN205@factor_rec:

; 1616 :         }
; 1617 :         for ( j = br+1, rr=pivrow2+(br-i), rii=S->LA+S->LIA[K+br]+1 ;
; 1618 :                       j < r->size ; j++, rr++, rii++ )

	mov	ebx, DWORD PTR [esi+128]
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR _j$[ebp], eax
	mov	eax, ecx
	sub	eax, edi
	lea	eax, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _K
	add	edx, ecx
	mov	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR [esi+140]
	lea	edx, DWORD PTR [ebx+edx*8+8]
	mov	ebx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _rii$90212[ebp], edx
	mov	edx, DWORD PTR _r$[ebp]
	cmp	ebx, DWORD PTR [edx+32]
	jge	SHORT $LN245@factor_rec
$LN244@factor_rec:

; 1619 :         { DSWAP(*rr,*rii); }

	mov	edx, DWORD PTR _rii$90212[ebp]
	fld	QWORD PTR [eax]
	fld	QWORD PTR [edx]
	add	edx, 8
	fstp	QWORD PTR [eax]
	mov	DWORD PTR _rii$90212[ebp], edx
	inc	ebx
	fstp	QWORD PTR [edx-8]
	mov	edx, DWORD PTR _r$[ebp]
	add	eax, 8
	cmp	ebx, DWORD PTR [edx+32]
	jl	SHORT $LN244@factor_rec
$LN245@factor_rec:

; 1620 :         DSWAP(pivrow2[0],S->LA[S->LIA[K+br]]); /* diag elements */

	mov	eax, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	mov	edx, DWORD PTR _pivrow2$90199[ebp]
	fld	QWORD PTR [edx]
	add	eax, ecx
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR [esi+140]
	fld	QWORD PTR [ebx+eax*8]
	fstp	QWORD PTR [edx]
	mov	eax, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	eax, ecx
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR [esi+140]
	fstp	QWORD PTR [ebx+eax*8]

; 1621 : 
; 1622 :         /* fix up LJA in swapped columns */
; 1623 :         c = S->LJA[S->LIJA[K+i+1]];

	mov	ebx, DWORD PTR _K
	mov	eax, DWORD PTR [esi+136]
	add	ebx, edi
	mov	eax, DWORD PTR [eax+ebx*4+4]
	mov	ebx, DWORD PTR [esi+132]
	lea	eax, DWORD PTR [ebx+eax*4]

; 1624 :         S->LJA[S->LIJA[K+i+1]] = S->LJA[S->LIJA[K+br]];

	mov	ebx, DWORD PTR [esi+136]
	mov	DWORD PTR tv4741[ebp], eax
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _c$90214[ebp], eax
	mov	eax, DWORD PTR _K
	add	eax, ecx
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR [esi+132]
	mov	eax, DWORD PTR [ebx+eax*4]
	mov	ebx, DWORD PTR tv4741[ebp]
	mov	DWORD PTR [ebx], eax

; 1625 :         S->LJA[S->LIJA[K+br]] = c;

	mov	eax, DWORD PTR _K
	mov	ebx, DWORD PTR _c$90214[ebp]
	add	eax, ecx
	mov	ecx, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [esi+132]
	mov	DWORD PTR [ecx+eax*4], ebx
$LN246@factor_rec:

; 1626 :       }
; 1627 : 
; 1628 :       /* now, actual 2x2 pivot */
; 1629 :       p11 = pivrow1[0]; p12 = pivrow1[1]; p22 = pivrow2[0];

	mov	eax, DWORD PTR _pivrow$90152[ebp]
	fld	QWORD PTR [eax]
	fld	QWORD PTR [eax+8]
	fld	QWORD PTR [edx]

; 1630 :       detinv = 1/(p11*p22 - p12*p12);

	fld	ST(0)
	fmul	ST(0), ST(3)
	fld	ST(2)
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fdivp	ST(4), ST(0)

; 1631 :       if ( detinv > 0.0 )

	fxch	ST(3)
	fcom	ST(4)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN15@factor_rec

; 1632 :         { if ( p11+p22 > 0.0 ) S->pos += 2; else S->neg += 2; }

	fld	ST(3)
	fadd	ST(0), ST(3)
	fcomp	ST(5)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN14@factor_rec
	add	DWORD PTR [esi+184], 2
	jmp	$LN12@factor_rec
$LN390@factor_rec:

; 1553 :     else if ( (big*BKalpha > fabs(pivrow[0])) && BK_flag )

	fstp	ST(2)
	fstp	ST(0)
	fstp	ST(0)
	fstp	ST(1)
$LN248@factor_rec:

; 1571 :     }
; 1572 :     else if ( p == ONEBYONE )
; 1573 :     { S->psize[K+i] = ONEBYONE;

	mov	edx, DWORD PTR [esi+120]
	mov	ecx, 1
	mov	DWORD PTR [edx+ebx*4], ecx

; 1574 :       pivot = 1/pivrow[0];

	mov	edx, DWORD PTR _pivrow$90152[ebp]
	fdiv	QWORD PTR [edx]

; 1575 :       if ( pivot > 0.0 ) S->pos++; else S->neg++;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN38@factor_rec
	add	DWORD PTR [esi+184], ecx
	jmp	SHORT $LN37@factor_rec
$LN38@factor_rec:
	add	DWORD PTR [esi+188], ecx
$LN37@factor_rec:

; 1576 :       for ( j = i+1; j < to_elim ; j++ ) /* row down */

	mov	ecx, DWORD PTR tv4409[ebp]
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR _to_elim$[ebp]
	jge	SHORT $LN219@factor_rec
	mov	eax, DWORD PTR _r$[ebp]
	mov	ebx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR _pivrow$90152[ebp]
	mov	edx, ecx
	sub	edx, edi
	lea	edx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR tv7564[ebp], edx
$LN36@factor_rec:

; 1577 :       { REAL *spot = S->LA + S->LIA[K+j];

	mov	eax, DWORD PTR _K

; 1578 :         REAL pp = pivrow[j-i]*pivot;

	fld	ST(0)
	mov	edx, DWORD PTR [esi+128]
	add	eax, ecx
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [esi+140]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR tv7564[ebp]
	fmul	QWORD PTR [edx]

; 1579 :         REAL *pr = pivrow + j - i;
; 1580 : 
; 1581 :         /* this is the time-consuming inner loop */
; 1582 :         for ( m = j ; m < r->size ; m++ , spot++, pr++)

	cmp	DWORD PTR _j$[ebp], ebx
	jge	SHORT $LN527@factor_rec
$LN237@factor_rec:

; 1583 : /* semiheavy */  /*  *spot -= pivrow[m-i]*pp; */
; 1584 :                     *spot -= (*pr)*pp;    /* no improvement */

	fld	QWORD PTR [edx]
	mov	ebx, DWORD PTR _r$[ebp]
	fmul	ST(0), ST(1)
	inc	ecx
	add	eax, 8
	add	edx, 8
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	mov	ebx, DWORD PTR [ebx+32]
	cmp	ecx, ebx
	jl	SHORT $LN237@factor_rec
$LN527@factor_rec:

; 1576 :       for ( j = i+1; j < to_elim ; j++ ) /* row down */

	mov	ecx, DWORD PTR _j$[ebp]

; 1579 :         REAL *pr = pivrow + j - i;
; 1580 : 
; 1581 :         /* this is the time-consuming inner loop */
; 1582 :         for ( m = j ; m < r->size ; m++ , spot++, pr++)

	fstp	ST(0)
	add	DWORD PTR tv7564[ebp], 8
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR _to_elim$[ebp]
	jl	SHORT $LN36@factor_rec

; 1576 :       for ( j = i+1; j < to_elim ; j++ ) /* row down */

	mov	edx, DWORD PTR _pivrow$90152[ebp]
$LN219@factor_rec:

; 1585 :       }
; 1586 :       for ( m = i+1, pivrow++ ; m < r->size ; m++,pivrow++ ) 

	mov	eax, DWORD PTR tv4409[ebp]
	mov	ecx, DWORD PTR _r$[ebp]
	add	edx, 8
	cmp	eax, DWORD PTR [ecx+32]
	jge	SHORT $LN532@factor_rec
$LN30@factor_rec:

; 1587 :             *pivrow *= pivot;  /* pivot row */

	fld	QWORD PTR [edx]
	inc	eax
	fmul	ST(0), ST(1)
	add	edx, 8
	fstp	QWORD PTR [edx-8]
	cmp	eax, DWORD PTR [ecx+32]
	jl	SHORT $LN30@factor_rec
$LN532@factor_rec:

; 1588 :       xIL[K+i] = S->LIA[K+i]+(to_elim-i);

	mov	eax, DWORD PTR _K
	fstp	ST(0)
	mov	ecx, DWORD PTR [esi+128]
	add	eax, edi
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _xIL
	sub	edx, edi
	add	edx, DWORD PTR _to_elim$[ebp]
	mov	DWORD PTR [eax+ecx], edx

; 1589 :       if ( xIL[K+i] < S->LIA[K+i+1] )

	mov	eax, DWORD PTR _K
	mov	edx, DWORD PTR _xIL
	mov	ecx, DWORD PTR [esi+128]
	add	eax, edi
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+edx]
	cmp	edx, DWORD PTR [ecx+eax+4]
	jge	SHORT $LN27@factor_rec

; 1590 :       { m = S->LJA[xIL[K+i]-(S->LIA[K+i]-S->LIJA[K+i])];

	mov	ebx, DWORD PTR [esi+136]
	mov	ebx, DWORD PTR [eax+ebx]
	sub	ebx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR [esi+132]
	add	ebx, edx

; 1591 :         xJL[K+i] = xJL[m]; xJL[m] = K+i;

	mov	edx, DWORD PTR _xJL
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	ebx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+edx], ebx
	mov	edx, DWORD PTR _K
	mov	eax, DWORD PTR _xJL
	add	edx, edi
	mov	DWORD PTR [eax+ecx*4], edx
$LN27@factor_rec:

; 1592 :       }
; 1593 :       S->psize[K+i] = ONEBYONE;

	mov	ecx, DWORD PTR _K
	mov	edx, DWORD PTR [esi+120]

; 1594 :     }
; 1595 :     else /* 2x2 pivot */

	mov	ebx, DWORD PTR _to_elim$[ebp]
	add	ecx, edi
	mov	DWORD PTR [edx+ecx*4], 1
	jmp	$LN61@factor_rec
$LN14@factor_rec:

; 1632 :         { if ( p11+p22 > 0.0 ) S->pos += 2; else S->neg += 2; }

	add	DWORD PTR [esi+188], 2

; 1633 :       else { S->pos++; S->neg++; }

	jmp	SHORT $LN12@factor_rec
$LN15@factor_rec:
	mov	eax, 1
	add	DWORD PTR [esi+184], eax
	add	DWORD PTR [esi+188], eax
$LN12@factor_rec:

; 1634 :       /* sweep through matrix */
; 1635 :       for ( k = i+2, x = S->LA+S->LIA[K+i+2] ; k < to_elim ; k++ ) /* row */

	mov	ecx, DWORD PTR _K
	mov	ebx, DWORD PTR [esi+128]
	add	ecx, edi
	mov	ecx, DWORD PTR [ebx+ecx*4+8]
	mov	ebx, DWORD PTR [esi+140]
	lea	eax, DWORD PTR [edi+2]
	lea	ecx, DWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR _to_elim$[ebp]
	mov	DWORD PTR _k$90208[ebp], eax
	cmp	eax, ebx
	jge	$LN241@factor_rec
	mov	ebx, eax
	mov	eax, DWORD PTR _pivrow$90152[ebp]
	sub	ebx, edi
	add	ebx, ebx
	add	ebx, ebx
	add	ebx, ebx
	add	eax, ebx
	lea	ebx, DWORD PTR [ebx+edx-8]
	mov	edx, DWORD PTR _k$90208[ebp]
	mov	DWORD PTR tv7997[ebp], eax
	mov	DWORD PTR tv8036[ebp], ebx
	jmp	SHORT $LN11@factor_rec
$LN242@factor_rec:
	mov	ebx, DWORD PTR tv8036[ebp]
$LN11@factor_rec:

; 1636 :       { pa1 = (pivrow1[k-i]*p22 - pivrow2[k-i-1]*p12)*detinv;

	fld	ST(3)

; 1637 :         pa2 = (pivrow2[k-i-1]*p11 - pivrow1[k-i]*p12)*detinv;
; 1638 :         for ( j=k,yy1=pivrow1+k-i,yy2=pivrow2+k-i-1 ; j<r->size; 
; 1639 :                   j++ ,x++,yy1++,yy2++) /*col*/

	mov	DWORD PTR _j$[ebp], edx
	fmul	QWORD PTR [eax]
	fld	ST(2)
	fmul	QWORD PTR [ebx]
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(1)
	fld	ST(3)
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR _r$[ebp]
	fld	ST(3)
	fmul	QWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	cmp	edx, DWORD PTR [ebx+32]
	jge	SHORT $LN220@factor_rec
	mov	ebx, DWORD PTR tv8036[ebp]
	fstp	ST(6)
	sub	ebx, eax
	mov	DWORD PTR tv8059[ebp], ebx
	jmp	SHORT $LN8@factor_rec
$LN238@factor_rec:
	mov	ebx, DWORD PTR tv8059[ebp]
$LN8@factor_rec:

; 1640 :         {  *x -=  pa1*(*yy1) + pa2*(*yy2); 

	fld	QWORD PTR [ebx+eax]
	mov	ebx, DWORD PTR _r$[ebp]
	fmul	ST(0), ST(6)
	inc	edx
	fld	QWORD PTR [eax]
	add	ecx, 8
	fmul	ST(0), ST(2)
	add	eax, 8
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
	cmp	edx, DWORD PTR [ebx+32]
	jl	SHORT $LN238@factor_rec

; 1637 :         pa2 = (pivrow2[k-i-1]*p11 - pivrow1[k-i]*p12)*detinv;
; 1638 :         for ( j=k,yy1=pivrow1+k-i,yy2=pivrow2+k-i-1 ; j<r->size; 
; 1639 :                   j++ ,x++,yy1++,yy2++) /*col*/

	fldz
	mov	eax, DWORD PTR tv7997[ebp]
	jmp	SHORT $LN538@factor_rec
$LN220@factor_rec:

; 1634 :       /* sweep through matrix */
; 1635 :       for ( k = i+2, x = S->LA+S->LIA[K+i+2] ; k < to_elim ; k++ ) /* row */

	fxch	ST(6)
$LN538@factor_rec:

; 1641 :         }
; 1642 :         pivrow1[k-i] = pa1;
; 1643 :         pivrow2[k-i-1] = pa2;

	mov	edx, DWORD PTR tv8036[ebp]
	fxch	ST(1)
	inc	DWORD PTR _k$90208[ebp]
	fstp	QWORD PTR [eax]
	mov	ebx, DWORD PTR _to_elim$[ebp]
	fxch	ST(5)
	add	DWORD PTR tv8036[ebp], 8
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR _k$90208[ebp]
	add	eax, 8
	mov	DWORD PTR tv7997[ebp], eax
	cmp	edx, ebx
	jl	SHORT $LN242@factor_rec

; 1634 :       /* sweep through matrix */
; 1635 :       for ( k = i+2, x = S->LA+S->LIA[K+i+2] ; k < to_elim ; k++ ) /* row */

	mov	edx, DWORD PTR _pivrow2$90199[ebp]
$LN241@factor_rec:

; 1644 :       }
; 1645 :       for ( k = to_elim ; k < r->size ; k++ ) /* finish pivot rows */

	mov	eax, DWORD PTR _r$[ebp]
	cmp	ebx, DWORD PTR [eax+32]
	jge	SHORT $LN504@factor_rec
	mov	eax, DWORD PTR _pivrow$90152[ebp]
	mov	ecx, ebx
	sub	ecx, edi
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	eax, ecx
	lea	ecx, DWORD PTR [ecx+edx-8]
	mov	edx, DWORD PTR _r$[ebp]
$LN243@factor_rec:

; 1646 :       { pa1 = (pivrow1[k-i]*p22 - pivrow2[k-i-1]*p12)*detinv;
; 1647 :         pa2 = (pivrow2[k-i-1]*p11 - pivrow1[k-i]*p12)*detinv;

	fld	ST(2)
	inc	ebx
	fmul	QWORD PTR [ecx]
	add	eax, 8
	fld	QWORD PTR [eax-8]
	add	ecx, 8
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(1)
	fld	QWORD PTR [eax-8]
	fmul	ST(0), ST(5)
	fld	ST(3)
	fmul	QWORD PTR [ecx-8]
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)

; 1648 :         pivrow1[k-i] = pa1;

	fstp	QWORD PTR [eax-8]

; 1649 :         pivrow2[k-i-1] = pa2;

	fstp	QWORD PTR [ecx-8]
	cmp	ebx, DWORD PTR [edx+32]
	jl	SHORT $LN243@factor_rec

; 1644 :       }
; 1645 :       for ( k = to_elim ; k < r->size ; k++ ) /* finish pivot rows */

	mov	ebx, DWORD PTR _to_elim$[ebp]
$LN504@factor_rec:

; 1650 :       }
; 1651 :       xIL[K+i] = S->LIA[K+i]+(to_elim-i);

	mov	eax, DWORD PTR _K
	fstp	ST(1)
	mov	edx, DWORD PTR [esi+128]
	fstp	ST(0)
	add	eax, edi
	fstp	ST(0)
	add	eax, eax
	fstp	ST(0)
	add	eax, eax
	mov	ecx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR _xIL
	sub	ecx, edi
	add	ecx, ebx
	mov	DWORD PTR [eax+edx], ecx

; 1652 :       if ( xIL[K+i] < S->LIA[K+i+1] )

	mov	eax, DWORD PTR _K
	mov	edx, DWORD PTR _xIL
	mov	ecx, DWORD PTR [esi+128]
	add	eax, edi
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR tv4611[ebp], edx
	cmp	edx, DWORD PTR [ecx+eax+4]
	jge	SHORT $LN249@factor_rec

; 1653 :       { m = S->LJA[xIL[K+i]-(S->LIA[K+i]-S->LIJA[K+i])];

	mov	edx, DWORD PTR [esi+136]
	mov	edx, DWORD PTR [eax+edx]
	sub	edx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR [esi+132]
	add	edx, DWORD PTR tv4611[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]

; 1654 :         xJL[K+i] = xJL[m]; xJL[m] = K+i;

	mov	edx, DWORD PTR _xJL
	mov	DWORD PTR _m$[ebp], ecx
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+edx], ecx
	mov	eax, DWORD PTR _K
	mov	ecx, DWORD PTR _xJL
	mov	edx, DWORD PTR _m$[ebp]
	add	eax, edi
	mov	DWORD PTR [ecx+edx*4], eax
$LN249@factor_rec:

; 1655 :       }
; 1656 :       i++;  /* since just did 2 rows */

	mov	edi, DWORD PTR tv4409[ebp]

; 1657 :       xIL[K+i] = S->LIA[K+i]+(to_elim-i);

	mov	eax, DWORD PTR _K
	mov	ecx, DWORD PTR [esi+128]
	add	eax, edi
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	mov	ecx, DWORD PTR _xIL
	sub	edx, edi
	add	edx, ebx
	mov	DWORD PTR [eax+ecx], edx

; 1658 :       if ( xIL[K+i] < S->LIA[K+i+1] )

	mov	eax, DWORD PTR _K
	mov	edx, DWORD PTR _xIL
	mov	ecx, DWORD PTR [esi+128]
	add	eax, edi
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR tv4611[ebp], edx
	cmp	edx, DWORD PTR [ecx+eax+4]
	jge	SHORT $LN61@factor_rec

; 1659 :       { m = S->LJA[xIL[K+i]-(S->LIA[K+i]-S->LIJA[K+i])];

	mov	edx, DWORD PTR [esi+136]
	mov	edx, DWORD PTR [eax+edx]
	sub	edx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR [esi+132]
	add	edx, DWORD PTR tv4611[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]

; 1660 :         xJL[K+i] = xJL[m]; xJL[m] = K+i;

	mov	edx, DWORD PTR _xJL
	mov	DWORD PTR _m$[ebp], ecx
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+edx], ecx
	mov	eax, DWORD PTR _K
	mov	ecx, DWORD PTR _xJL
	mov	edx, DWORD PTR _m$[ebp]
	add	eax, edi
	mov	DWORD PTR [ecx+edx*4], eax
$LN61@factor_rec:

; 1534 : 
; 1535 :   /* factor */
; 1536 :   for ( i = 0 ; i < to_elim ; i++ )  /* pivot row */

	inc	edi
	cmp	edi, ebx
	jl	$LN221@factor_rec
$LN515@factor_rec:

; 1661 :       }
; 1662 :     }
; 1663 :   }
; 1664 : 
; 1665 :   K += to_elim;

	mov	eax, DWORD PTR _to_elim$[ebp]
	fstp	ST(0)
	add	DWORD PTR _K, eax
$LN119@factor_rec:
	pop	edi
	pop	esi
	pop	ebx

; 1666 : } // end factor_recur()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN539@factor_rec:
	DD	$LN83@factor_rec
	DD	$LN88@factor_rec
	DD	$LN80@factor_rec
	DD	$LN81@factor_rec
_factor_recur ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@FGEPFIGL@Internal?5error?3?5fill?5?$CFd?5?5?$CB?$DN?5?5tot@ ; `string'
PUBLIC	_traverse_region_tree
;	COMDAT ??_C@_0CM@FGEPFIGL@Internal?5error?3?5fill?5?$CFd?5?5?$CB?$DN?5?5tot@
CONST	SEGMENT
??_C@_0CM@FGEPFIGL@Internal?5error?3?5fill?5?$CFd?5?5?$CB?$DN?5?5tot@ DB 'I'
	DB	'nternal error: fill %d  !=  total_fill %d', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _traverse_region_tree
_TEXT	SEGMENT
_S$ = 8							; size = 4
_traverse_region_tree PROC				; COMDAT

; 1678 : { struct region *r;

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 1679 :   int rnum,n;
; 1680 :   int fill;
; 1681 : 
; 1682 :   /* allocate space */
; 1683 :   for ( fill = 0, n = 0 ; n < S->N ; n++ )

	mov	esi, DWORD PTR _S$[ebp]
	xor	ebx, ebx
	xor	ecx, ecx
	xor	eax, eax
	push	edi
	cmp	DWORD PTR [esi+4], ebx
	jle	SHORT $LN12@traverse_r@2
$LL14@traverse_r@2:
	mov	edx, DWORD PTR [esi+128]

; 1684 :   { int tmp = S->LIA[n]; S->LIA[n] = fill; fill += tmp; }

	mov	edi, DWORD PTR [edx+eax*4]
	lea	edx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx], ecx
	inc	eax
	add	ecx, edi
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL14@traverse_r@2
$LN12@traverse_r@2:

; 1685 :   S->LIA[S->N] = fill;

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+128]
	mov	DWORD PTR [edx+eax*4], ecx

; 1686 :   if ( fill != total_fill )

	mov	eax, DWORD PTR _total_fill
	cmp	ecx, eax
	je	SHORT $LN26@traverse_r@2

; 1687 :   { sprintf(errmsg,"Internal error: fill %d  !=  total_fill %d\n",fill,total_fill);

	push	eax
	push	ecx
	push	OFFSET ??_C@_0CM@FGEPFIGL@Internal?5error?3?5fill?5?$CFd?5?5?$CB?$DN?5?5tot@
	push	OFFSET _errmsg
	call	_sprintf

; 1688 :     kb_error(1836,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1836					; 0000072cH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN26@traverse_r@2:

; 1689 :   }
; 1690 :   xIL = (int*)temp_calloc(S->N,sizeof(int));

	mov	eax, DWORD PTR [esi+4]
	push	1690					; 0000069aH
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	push	4
	push	eax
	call	_kb_temp_calloc

; 1691 :   xJL = (int*)temp_calloc(S->N,sizeof(int));

	push	1691					; 0000069bH
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	mov	DWORD PTR _xIL, eax
	mov	ecx, DWORD PTR [esi+4]
	push	4
	push	ecx
	call	_kb_temp_calloc
	mov	DWORD PTR _xJL, eax
	add	esp, 32					; 00000020H

; 1692 :   for ( n = 0 ; n < S->N ; n++ ) xJL[n] = -1;  /* list terminators */

	xor	eax, eax
	cmp	DWORD PTR [esi+4], ebx
	jle	SHORT $LN8@traverse_r@2
$LL25@traverse_r@2:
	mov	edx, DWORD PTR _xJL
	mov	DWORD PTR [edx+eax*4], -1
	inc	eax
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL25@traverse_r@2
$LN8@traverse_r@2:

; 1693 : 
; 1694 :   /* get tree traverse permutation order */
; 1695 :   K = 0;
; 1696 :   IJA_base = 0; /* for total LIJA entries */
; 1697 :   for ( rnum = regionstart ; rnum >= 0 ; rnum = r->next )

	mov	eax, DWORD PTR _regionstart
	mov	DWORD PTR _K, ebx
	mov	DWORD PTR _IJA_base, ebx
	cmp	eax, ebx
	jl	SHORT $LN5@traverse_r@2
	npad	6
$LL7@traverse_r@2:

; 1698 :   { r = REG(rnum);

	mov	ecx, DWORD PTR [esi+92]
	lea	edi, DWORD PTR [ecx+eax*4]

; 1699 :     permute_recur(S,r);

	push	edi
	push	esi
	call	_permute_recur
	mov	eax, DWORD PTR [edi+36]
	add	esp, 8
	cmp	eax, ebx
	jge	SHORT $LL7@traverse_r@2
$LN5@traverse_r@2:

; 1700 :   }
; 1701 :   sparse_permute(S);

	push	esi
	call	_sparse_permute
	add	esp, 4

; 1702 :   if ( hessian_linear_metric_flag && (S->lambda != 0.0) )

	cmp	DWORD PTR _hessian_linear_metric_flag, ebx
	je	SHORT $LN4@traverse_r@2
	fld	QWORD PTR [esi+112]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@traverse_r@2

; 1703 :   { memcpy((char*)Met.P,(char*)S->P,S->N*sizeof(int));

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR _Met+68
	add	edx, edx
	add	edx, edx
	push	edx
	push	eax
	push	ecx
	call	_memcpy

; 1704 :     memcpy((char*)Met.IP,(char*)S->IP,S->N*sizeof(int));

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+72]
	mov	ecx, DWORD PTR _Met+72
	add	edx, edx
	add	edx, edx
	push	edx
	push	eax
	push	ecx
	call	_memcpy

; 1705 :     sparse_permute(&Met);

	push	OFFSET _Met
	call	_sparse_permute
	add	esp, 28					; 0000001cH
$LN4@traverse_r@2:

; 1706 :   }
; 1707 : 
; 1708 :   /* allocate L space */
; 1709 :   S->Lsize = total_fill; 

	mov	edx, DWORD PTR _total_fill

; 1710 :   S->LJA = (int*)temp_realloc((char*)S->LJA,IJA_base*sizeof(int));

	mov	eax, DWORD PTR _IJA_base
	push	1710					; 000006aeH
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	lea	ecx, DWORD PTR [eax*4]
	mov	DWORD PTR [esi+124], edx
	mov	edx, DWORD PTR [esi+132]
	push	ecx
	push	edx
	call	_kb_temp_realloc

; 1711 :   S->LIJA = (int*)temp_realloc((char*)S->LIJA,(S->N+1)*sizeof(int));

	mov	edx, DWORD PTR [esi+136]
	mov	DWORD PTR [esi+132], eax
	mov	eax, DWORD PTR [esi+4]
	push	1711					; 000006afH
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	lea	ecx, DWORD PTR [eax*4+4]
	push	ecx
	push	edx
	call	_kb_temp_realloc

; 1712 :   S->LA = (REAL*)temp_realloc((char*)S->LA,S->Lsize*sizeof(REAL));

	mov	ecx, DWORD PTR [esi+140]
	mov	DWORD PTR [esi+136], eax
	mov	eax, DWORD PTR [esi+124]
	add	eax, eax
	push	1712					; 000006b0H
	add	eax, eax
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	add	eax, eax
	push	eax
	push	ecx
	call	_kb_temp_realloc

; 1713 :   memset(S->LJA,0,IJA_base*sizeof(int));

	mov	edx, DWORD PTR _IJA_base
	mov	ecx, DWORD PTR [esi+132]
	mov	DWORD PTR [esi+140], eax
	lea	eax, DWORD PTR [edx*4]
	push	eax
	push	ebx
	push	ecx
	call	_memset

; 1714 :   memset(S->LIJA,0,(S->N+1)*sizeof(int));

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+136]
	lea	eax, DWORD PTR [edx*4+4]
	push	eax
	push	ebx
	push	ecx
	call	_memset

; 1715 :   memset(S->LA,0,S->Lsize*sizeof(REAL));

	mov	edx, DWORD PTR [esi+124]
	mov	eax, DWORD PTR [esi+140]
	add	edx, edx
	add	edx, edx
	add	esp, 72					; 00000048H
	add	edx, edx
	push	edx
	push	ebx
	push	eax
	call	_memset

; 1716 :   
; 1717 :   K = 0;  /* current row */
; 1718 :   IJA_base = 0 ;
; 1719 :   for ( rnum = regionstart ; rnum >= 0 ; rnum = r->next )

	mov	eax, DWORD PTR _regionstart
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _K, ebx
	mov	DWORD PTR _IJA_base, ebx
	cmp	eax, ebx
	jl	SHORT $LN1@traverse_r@2
$LL3@traverse_r@2:

; 1720 :   { r = REG(rnum);

	mov	ecx, DWORD PTR [esi+92]
	lea	edi, DWORD PTR [ecx+eax*4]

; 1721 :     factor_recur(S,r);

	push	edi
	push	esi
	call	_factor_recur
	mov	eax, DWORD PTR [edi+36]
	add	esp, 8
	cmp	eax, ebx
	jge	SHORT $LL3@traverse_r@2
$LN1@traverse_r@2:

; 1722 :   }
; 1723 :   temp_free((char*)xIL); xIL = NULL;

	mov	edx, DWORD PTR _xIL
	push	edx
	call	_temp_free

; 1724 :   temp_free((char*)xJL); xJL = NULL;

	mov	eax, DWORD PTR _xJL
	push	eax
	mov	DWORD PTR _xIL, ebx
	call	_temp_free
	add	esp, 8
	pop	edi
	pop	esi
	mov	DWORD PTR _xJL, ebx
	pop	ebx

; 1725 : 
; 1726 :   /* test_print(S,0); */
; 1727 : /*debug */    /*  dsolve(S); */  
; 1728 : } // end traverse_region_tree()

	pop	ebp
	ret	0
_traverse_region_tree ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DI@LMEPNCFO@Internal?5error?3?5Must?5call?5xmd_fa@ ; `string'
PUBLIC	_xmd_solve
;	COMDAT ??_C@_0DI@LMEPNCFO@Internal?5error?3?5Must?5call?5xmd_fa@
CONST	SEGMENT
??_C@_0DI@LMEPNCFO@Internal?5error?3?5Must?5call?5xmd_fa@ DB 'Internal er'
	DB	'ror: Must call xmd_factor before xmd_solve.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _xmd_solve
_TEXT	SEGMENT
tv449 = -20						; size = 4
tv379 = -20						; size = 4
_start$90346 = -20					; size = 4
_Y$ = -20						; size = 4
tv302 = -16						; size = 4
tv265 = -16						; size = 4
_start$90324 = -16					; size = 4
_end$90347 = -12					; size = 4
_end$90325 = -12					; size = 4
_i$ = -8						; size = 4
tv1257 = -4						; size = 4
_jp$ = -4						; size = 4
tv738 = 8						; size = 4
_n$ = 8							; size = 4
_S$ = 8							; size = 4
_B$ = 12						; size = 4
_x$ = 16						; size = 4
_mtype$ = 20						; size = 4
_xmd_solve PROC						; COMDAT

; 1747 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 1748 :   int n; /* row index */
; 1749 :   int i;
; 1750 :   int *jp;  /* pointer into LIJA */
; 1751 :   REAL *BB,*Y,*e;
; 1752 : 
; 1753 : 
; 1754 :   if ( S->psize == NULL )

	mov	esi, DWORD PTR _S$[ebp]
	cmp	DWORD PTR [esi+120], 0
	push	edi
	jne	SHORT $LN59@xmd_solve

; 1755 :      kb_error(1837,"Internal error: Must call xmd_factor before xmd_solve.\n",
; 1756 :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DI@LMEPNCFO@Internal?5error?3?5Must?5call?5xmd_fa@
	push	1837					; 0000072dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN59@xmd_solve:

; 1757 : 
; 1758 :   /* Use existing working storage if possible */
; 1759 :   if ( S->NSP*sizeof(int) < 2*S->N*sizeof(REAL))

	mov	edi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+88]
	add	ecx, ecx
	mov	eax, edi
	shl	eax, 4
	add	ecx, ecx
	cmp	ecx, eax
	jae	SHORT $LN31@xmd_solve

; 1760 :   { S->ISP = (int*)temp_realloc((char*)S->ISP,2*S->N*sizeof(REAL));

	mov	edx, DWORD PTR [esi+92]
	push	1760					; 000006e0H
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	push	eax
	push	edx
	call	_kb_temp_realloc

; 1761 :     S->NSP = (2*S->N*sizeof(REAL))/sizeof(int);

	mov	edi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+92], eax
	mov	eax, edi
	shl	eax, 4
	add	esp, 16					; 00000010H
	shr	eax, 2
	mov	DWORD PTR [esi+88], eax
$LN31@xmd_solve:

; 1762 :   }
; 1763 :   BB = (REAL*)S->ISP;           /* intermediate solutions */

	mov	ecx, DWORD PTR [esi+92]

; 1764 :   Y  = ((REAL*)S->ISP) + S->N;  /* intermediate solutions */

	lea	edx, DWORD PTR [ecx+edi*8]

; 1765 : 
; 1766 :   /* solve U^T Y = B */
; 1767 :   for ( n = 0 ; n < S->N ; n++ ) BB[n] = B[S->P[n]]; /* permute */

	xor	eax, eax
	push	ebx
	mov	DWORD PTR _Y$[ebp], edx
	test	edi, edi
	jle	SHORT $LN28@xmd_solve
	mov	edi, DWORD PTR _B$[ebp]
$LL30@xmd_solve:
	mov	ebx, DWORD PTR [esi+68]
	mov	ebx, DWORD PTR [ebx+eax*4]
	fld	QWORD PTR [edi+ebx*8]
	inc	eax
	fstp	QWORD PTR [ecx+eax*8-8]
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL30@xmd_solve
$LN28@xmd_solve:

; 1768 : 
; 1769 :   for ( n = 0 ; n < S->N ; n++ )

	fldz
	xor	ebx, ebx
	mov	DWORD PTR _n$[ebp], ebx
	cmp	DWORD PTR [esi+4], ebx
	jle	$LN25@xmd_solve
	mov	DWORD PTR tv1257[ebp], edx
$LN27@xmd_solve:

; 1770 :   { int start,end;
; 1771 :     Y[n] = BB[S->LJA[S->LIJA[n]]];  /* for BK inner permutation */

	mov	eax, DWORD PTR [esi+136]
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	edi, DWORD PTR [esi+132]
	mov	eax, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR tv1257[ebp]
	fst	QWORD PTR [eax]

; 1772 :     if ( Y[n] == 0.0 ) continue;

	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN26@xmd_solve

; 1773 :     if ( S->psize[n] == FIRSTOFPAIR ) start = 2;

	mov	edx, DWORD PTR [esi+120]
	xor	eax, eax
	cmp	DWORD PTR [edx+ebx*4], 2
	sete	al
	lea	edx, DWORD PTR [eax+1]
	mov	eax, DWORD PTR [esi+128]

; 1774 :     else start = 1; 
; 1775 :     end = S->LIA[n+1];

	mov	edi, DWORD PTR [eax+ebx*4+4]
	lea	eax, DWORD PTR [eax+ebx*4]
	mov	DWORD PTR _end$90325[ebp], edi

; 1776 :     for ( i=S->LIA[n]+start, e=S->LA+i , jp=S->LJA+S->LIJA[n]+start ; 
; 1777 :                    i < end ; i++,e++,jp++ )

	mov	edi, DWORD PTR [eax]
	add	edi, edx
	mov	DWORD PTR _start$90324[ebp], edx
	mov	edx, DWORD PTR [esi+140]
	lea	eax, DWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR [esi+136]
	mov	edx, DWORD PTR [edx+ebx*4]
	add	edx, DWORD PTR _start$90324[ebp]
	mov	ebx, DWORD PTR [esi+132]
	lea	edx, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR _end$90325[ebp]
	cmp	edi, ebx
	jge	$LN55@xmd_solve
	sub	ebx, edi
	cmp	ebx, 4
	jl	SHORT $LC50@xmd_solve

; 1778 :     {  BB[*jp] -= (*e)*Y[n];

	mov	ebx, DWORD PTR _end$90325[ebp]
	sub	ebx, edi
	sub	ebx, 4
	shr	ebx, 2
	inc	ebx
	lea	edi, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR _i$[ebp], edi
	mov	edi, DWORD PTR tv1257[ebp]
	mov	DWORD PTR tv302[ebp], ebx
$LN51@xmd_solve:
	fld	QWORD PTR [eax]
	mov	ebx, DWORD PTR [edx]
	fmul	QWORD PTR [edi]
	lea	ebx, DWORD PTR [ecx+ebx*8]
	add	eax, 32					; 00000020H
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv302[ebp]
	fsubr	QWORD PTR [ebx]
	fstp	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [edx-12]
	fld	QWORD PTR [eax-24]
	lea	ebx, DWORD PTR [ecx+ebx*8]
	fmul	QWORD PTR [edi]
	fsubr	QWORD PTR [ebx]
	fstp	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [edx-8]
	fld	QWORD PTR [eax-16]
	lea	ebx, DWORD PTR [ecx+ebx*8]
	fmul	QWORD PTR [edi]
	fsubr	QWORD PTR [ebx]
	fstp	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [edx-4]
	fld	QWORD PTR [eax-8]
	lea	ebx, DWORD PTR [ecx+ebx*8]
	fmul	QWORD PTR [edi]
	fsubr	QWORD PTR [ebx]
	fstp	QWORD PTR [ebx]
	jne	SHORT $LN51@xmd_solve
	mov	edi, DWORD PTR _i$[ebp]
$LC50@xmd_solve:

; 1776 :     for ( i=S->LIA[n]+start, e=S->LA+i , jp=S->LJA+S->LIJA[n]+start ; 
; 1777 :                    i < end ; i++,e++,jp++ )

	mov	ebx, DWORD PTR _end$90325[ebp]
	cmp	edi, ebx
	jge	SHORT $LN55@xmd_solve
	sub	ebx, edi
	mov	DWORD PTR tv265[ebp], ebx
$LC21@xmd_solve:

; 1778 :     {  BB[*jp] -= (*e)*Y[n];

	fld	QWORD PTR [eax]
	mov	edi, DWORD PTR [edx]
	mov	ebx, DWORD PTR tv1257[ebp]
	fmul	QWORD PTR [ebx]
	lea	edi, DWORD PTR [ecx+edi*8]
	add	eax, 8
	add	edx, 4
	dec	DWORD PTR tv265[ebp]
	fsubr	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	jne	SHORT $LC21@xmd_solve
$LN55@xmd_solve:

; 1776 :     for ( i=S->LIA[n]+start, e=S->LA+i , jp=S->LJA+S->LIJA[n]+start ; 
; 1777 :                    i < end ; i++,e++,jp++ )

	mov	edx, DWORD PTR _Y$[ebp]
	mov	ebx, DWORD PTR _n$[ebp]
$LN26@xmd_solve:

; 1768 : 
; 1769 :   for ( n = 0 ; n < S->N ; n++ )

	add	DWORD PTR tv1257[ebp], 8
	inc	ebx
	mov	DWORD PTR _n$[ebp], ebx
	cmp	ebx, DWORD PTR [esi+4]
	jl	$LN27@xmd_solve
$LN25@xmd_solve:

; 1779 :     }
; 1780 :   }
; 1781 : 
; 1782 :   /* solve D V = Y (will use Y to store V) */
; 1783 :   for ( n = 0 ; n < S->N ; n++ )

	xor	eax, eax
	cmp	DWORD PTR [esi+4], eax
	jle	$LN90@xmd_solve
$LN62@xmd_solve:

; 1784 :   { if ( S->psize[n] == ONEBYONE )

	mov	edi, DWORD PTR [esi+120]
	mov	edi, DWORD PTR [edi+eax*4]
	cmp	edi, 1
	jne	SHORT $LN15@xmd_solve

; 1785 :        Y[n] /= S->LA[S->LIA[n]];

	mov	edi, DWORD PTR [esi+128]
	fld	QWORD PTR [edx+eax*8]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	ebx, DWORD PTR [esi+140]
	fdiv	QWORD PTR [ebx+edi*8]
	fstp	QWORD PTR [edx+eax*8]
	jmp	SHORT $LN17@xmd_solve
$LN15@xmd_solve:

; 1786 :     else if ( S->psize[n] == ZEROPIVOT ) Y[n] = 0.0;  /* generalized inverse */

	test	edi, edi
	jne	SHORT $LN13@xmd_solve
	fst	QWORD PTR [edx+eax*8]

; 1787 :     else

	jmp	SHORT $LN17@xmd_solve
$LN13@xmd_solve:

; 1779 :     }
; 1780 :   }
; 1781 : 
; 1782 :   /* solve D V = Y (will use Y to store V) */
; 1783 :   for ( n = 0 ; n < S->N ; n++ )

	mov	edi, DWORD PTR [esi+128]
	lea	ebx, DWORD PTR [edi+eax*4]

; 1788 :     { REAL piv[2][2];
; 1789 :       REAL pinv[2][2];
; 1790 :       REAL det,yy;
; 1791 :       piv[0][0] = S->LA[S->LIA[n]];

	mov	edi, DWORD PTR [esi+140]
	mov	DWORD PTR tv738[ebp], ebx
	mov	ebx, DWORD PTR [ebx]
	fld	QWORD PTR [edi+ebx*8]
	lea	ebx, DWORD PTR [edi+ebx*8]

; 1792 :       piv[0][1] = piv[1][0] = S->LA[S->LIA[n]+1];

	fld	QWORD PTR [ebx+8]

; 1793 :       piv[1][1] = S->LA[S->LIA[n+1]];

	mov	ebx, DWORD PTR tv738[ebp]
	mov	ebx, DWORD PTR [ebx+4]
	fld	QWORD PTR [edi+ebx*8]

; 1794 :       det = piv[0][0]*piv[1][1] - piv[0][1]*piv[1][0];
; 1795 :       pinv[0][0] = piv[1][1]/det;
; 1796 :       pinv[1][0] = pinv[0][1] = -piv[0][1]/det;
; 1797 :       pinv[1][1] = piv[0][0]/det;
; 1798 :       yy = Y[n]*pinv[0][0] + Y[n+1]*pinv[1][0];
; 1799 :       Y[n+1] = Y[n]*pinv[0][1] + Y[n+1]*pinv[1][1];
; 1800 :       Y[n] = yy;
; 1801 :       n++; 

	inc	eax
	fld	ST(0)
	fmul	ST(0), ST(3)
	fld	ST(2)
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fdiv	ST(1), ST(0)
	fdiv	ST(2), ST(0)
	fxch	ST(2)
	fchs
	fxch	ST(3)
	fdivrp	ST(2), ST(0)
	fmul	QWORD PTR [edx+eax*8-8]
	fld	ST(2)
	fmul	QWORD PTR [edx+eax*8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx+eax*8-8]
	fmulp	ST(3), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR [edx+eax*8]
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR [edx+eax*8]
	fstp	QWORD PTR [edx+eax*8-8]
$LN17@xmd_solve:

; 1779 :     }
; 1780 :   }
; 1781 : 
; 1782 :   /* solve D V = Y (will use Y to store V) */
; 1783 :   for ( n = 0 ; n < S->N ; n++ )

	inc	eax
	cmp	eax, DWORD PTR [esi+4]
	jl	$LN62@xmd_solve
$LN90@xmd_solve:

; 1802 :     }
; 1803 :   }
; 1804 : 
; 1805 :   /* solve U X = V */
; 1806 :   for ( n = S->N-1 ; n >= 0 ; n-- )

	mov	edi, DWORD PTR [esi+4]
	fstp	ST(0)
	dec	edi
	mov	DWORD PTR _n$[ebp], edi
	js	$LN61@xmd_solve
	lea	eax, DWORD PTR [edx+edi*8]
	npad	7
$LL11@xmd_solve:

; 1807 :   { int start,end;
; 1808 :     if ( S->psize[n] == FIRSTOFPAIR ) start = 2;

	mov	edx, DWORD PTR [esi+120]
	xor	ebx, ebx
	cmp	DWORD PTR [edx+edi*4], 2
	mov	edx, DWORD PTR [esi+128]
	sete	bl
	lea	edx, DWORD PTR [edx+edi*4]
	inc	ebx
	mov	DWORD PTR _start$90346[ebp], ebx

; 1809 :     else start = 1; 
; 1810 :     end = S->LIA[n+1];

	mov	ebx, DWORD PTR [edx+4]

; 1811 :     for ( i=S->LIA[n]+start, e=S->LA+i, jp=S->LJA+S->LIJA[n]+start  ; 
; 1812 :         i < end ; i++,e++,jp++ )

	mov	edx, DWORD PTR [edx]
	add	edx, DWORD PTR _start$90346[ebp]
	mov	DWORD PTR _end$90347[ebp], ebx
	mov	ebx, DWORD PTR [esi+140]
	mov	DWORD PTR _i$[ebp], edx
	lea	edx, DWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [esi+136]
	mov	edi, DWORD PTR [ebx+edi*4]
	add	edi, DWORD PTR _start$90346[ebp]
	mov	ebx, DWORD PTR [esi+132]
	lea	edi, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR _end$90347[ebp]
	mov	DWORD PTR _jp$[ebp], edi
	mov	edi, DWORD PTR _i$[ebp]
	cmp	edi, ebx
	jge	$LN57@xmd_solve
	sub	ebx, edi
	cmp	ebx, 4
	jl	SHORT $LN56@xmd_solve

; 1813 :          Y[n] -= (*e)*BB[*jp];

	mov	ebx, DWORD PTR _end$90347[ebp]
	sub	ebx, edi
	sub	ebx, 4
	shr	ebx, 2
	inc	ebx
	lea	edi, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR _i$[ebp], edi
	mov	edi, DWORD PTR _jp$[ebp]
	mov	DWORD PTR tv379[ebp], ebx
$LL54@xmd_solve:
	mov	ebx, DWORD PTR [edi]
	fld	QWORD PTR [ecx+ebx*8]
	add	edx, 32					; 00000020H
	fmul	QWORD PTR [edx-32]
	add	edi, 16					; 00000010H
	dec	DWORD PTR tv379[ebp]
	fsubr	QWORD PTR [eax]
	fst	QWORD PTR [eax]
	mov	ebx, DWORD PTR [edi-12]
	fld	QWORD PTR [ecx+ebx*8]
	fmul	QWORD PTR [edx-24]
	fsubp	ST(1), ST(0)
	fst	QWORD PTR [eax]
	mov	ebx, DWORD PTR [edi-8]
	fld	QWORD PTR [ecx+ebx*8]
	fmul	QWORD PTR [edx-16]
	fsubp	ST(1), ST(0)
	fst	QWORD PTR [eax]
	mov	ebx, DWORD PTR [edi-4]
	fld	QWORD PTR [ecx+ebx*8]
	fmul	QWORD PTR [edx-8]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax]
	jne	SHORT $LL54@xmd_solve
	mov	DWORD PTR _jp$[ebp], edi
	mov	edi, DWORD PTR _i$[ebp]
$LN56@xmd_solve:

; 1811 :     for ( i=S->LIA[n]+start, e=S->LA+i, jp=S->LJA+S->LIJA[n]+start  ; 
; 1812 :         i < end ; i++,e++,jp++ )

	mov	ebx, DWORD PTR _end$90347[ebp]
	cmp	edi, ebx
	jge	SHORT $LN57@xmd_solve
	sub	ebx, edi
	mov	edi, DWORD PTR _jp$[ebp]
	mov	DWORD PTR tv449[ebp], ebx
$LC6@xmd_solve:

; 1813 :          Y[n] -= (*e)*BB[*jp];

	mov	ebx, DWORD PTR [edi]
	fld	QWORD PTR [ecx+ebx*8]
	add	edx, 8
	fmul	QWORD PTR [edx-8]
	add	edi, 4
	dec	DWORD PTR tv449[ebp]
	fsubr	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	jne	SHORT $LC6@xmd_solve
$LN57@xmd_solve:

; 1814 :     BB[S->LJA[S->LIJA[n]]] = Y[n];

	mov	edi, DWORD PTR _n$[ebp]
	fld	QWORD PTR [eax]
	mov	edx, DWORD PTR [esi+136]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	ebx, DWORD PTR [esi+132]
	mov	edx, DWORD PTR [ebx+edx*4]
	dec	edi
	fstp	QWORD PTR [ecx+edx*8]
	sub	eax, 8
	mov	DWORD PTR _n$[ebp], edi
	test	edi, edi
	jns	$LL11@xmd_solve
$LN61@xmd_solve:

; 1815 :   }
; 1816 : 
; 1817 :   /* unpermute */
; 1818 :   for ( n = 0 ; n < S->N ; n++ )

	xor	eax, eax
	pop	ebx
	cmp	DWORD PTR [esi+4], eax
	jle	SHORT $LN1@xmd_solve
	mov	edx, DWORD PTR _x$[ebp]
$LL3@xmd_solve:

; 1819 :      x[S->P[n]] = BB[n];

	mov	edi, DWORD PTR [esi+68]
	fld	QWORD PTR [ecx+eax*8]
	mov	edi, DWORD PTR [edi+eax*4]
	inc	eax
	fstp	QWORD PTR [edx+edi*8]
	cmp	eax, DWORD PTR [esi+4]
	jl	SHORT $LL3@xmd_solve
$LN1@xmd_solve:
	pop	edi
	pop	esi

; 1820 : 
; 1821 : } // end xmd_solve()

	mov	esp, ebp
	pop	ebp
	ret	0
_xmd_solve ENDP
_TEXT	ENDS
PUBLIC	_xmd_solve_multi
; Function compile flags: /Ogtp
;	COMDAT _xmd_solve_multi
_TEXT	SEGMENT
_S$ = 8							; size = 4
_B$ = 12						; size = 4
_x$ = 16						; size = 4
_rk$ = 20						; size = 4
_mtype$ = 24						; size = 4
_xmd_solve_multi PROC					; COMDAT

; 1841 : { int k; /* rhs column index */

	push	ebp
	mov	ebp, esp
	push	ebx

; 1842 : 
; 1843 :   for ( k = 0 ; k < rk ; k++ )

	mov	ebx, DWORD PTR _rk$[ebp]
	test	ebx, ebx
	jle	SHORT $LN1@xmd_solve_
	push	esi
	mov	esi, DWORD PTR _B$[ebp]
	push	edi
	mov	edi, DWORD PTR _x$[ebp]
	sub	edi, esi
$LL3@xmd_solve_:

; 1844 :     xmd_solve(S,B[k],x[k],mtype);

	mov	eax, DWORD PTR _mtype$[ebp]
	mov	ecx, DWORD PTR [edi+esi]
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	eax, DWORD PTR _S$[ebp]
	push	ecx
	push	edx
	push	eax
	call	_xmd_solve
	add	esp, 16					; 00000010H
	add	esi, 4
	dec	ebx
	jne	SHORT $LL3@xmd_solve_
	pop	edi
	pop	esi
$LN1@xmd_solve_:
	pop	ebx

; 1845 :   return;
; 1846 : 
; 1847 : #ifdef OLDXMDMULTI
; 1848 : /* something wrong with this */
; 1849 : { int n; /* row index */
; 1850 :   int i;
; 1851 :   int *jp;  /* pointer into LIJA */
; 1852 :   REAL **BB,**Y,*e;
; 1853 : 
; 1854 :   if ( S->psize == NULL )
; 1855 :      kb_error(2531,"Internal error: Must call BK_factor before BK_solve.\n",RECOVERABLE);
; 1856 : 
; 1857 : 
; 1858 :   BB = dmatrix(0,S->N-1,0,rk-1);  /* intermediate solutions */
; 1859 :   Y =  dmatrix(0,S->N-1,0,rk-1);  /* intermediate solutions */
; 1860 : 
; 1861 :   /* solve U^T Y = B */
; 1862 :   for ( n = 0 ; n < S->N ; n++ ) 
; 1863 :     for ( k = 0 ; k < rk ; k++ )
; 1864 :       BB[n][k] = B[k][S->P[n]]; /* permute */
; 1865 : 
; 1866 :   for ( n = 0 ; n < S->N ; n++ )
; 1867 :   { int start,end;
; 1868 :     REAL *yy,*bb,ee;
; 1869 :     for ( yy = Y[n], k = 0 , bb = BB[S->LJA[S->LIJA[n]]]; k < rk ; k++ )
; 1870 :         *(yy++) = *(bb++);
; 1871 :     if ( S->psize[n] == FIRSTOFPAIR ) start = 2;
; 1872 :     else start = 1; 
; 1873 :     end = S->LIA[n+1];
; 1874 :     for ( i=S->LIA[n]+start, e=S->LA+i , jp=S->LJA+S->LIJA[n]+start ; 
; 1875 :                  i < end ; i++,e++,jp++ )
; 1876 :     { ee = *e;
; 1877 :       for ( bb = BB[*jp], yy = Y[n], k = 0 ; k < rk ; k++ )
; 1878 :          *(bb++) -= ee*(*(yy++));
; 1879 :     }
; 1880 :   }
; 1881 : 
; 1882 :   /* solve D V = Y (will use Y to store V) */
; 1883 :   for ( n = 0 ; n < S->N ; n++ )
; 1884 :   { if ( S->psize[n] == ONEBYONE )
; 1885 :     { REAL *y,pinv;
; 1886 :       pinv = 1.0/S->LA[S->LIA[n]];
; 1887 :       for ( y = Y[n], k = 0 ; k < rk ; k++ )
; 1888 :           *(y++) *= pinv;
; 1889 :     }
; 1890 :     else if ( S->psize[n] == ZEROPIVOT )
; 1891 :        for ( k = 0 ; k < rk ; k++ ) Y[n][k] = 0.0;  /* generalized inverse */
; 1892 :     else
; 1893 :     { REAL piv[2][2];
; 1894 :       REAL pinv[2][2];
; 1895 :       REAL det,yy;
; 1896 :       piv[0][0] = S->LA[S->LIA[n]];
; 1897 :       piv[0][1] = piv[1][0] = S->LA[S->LIA[n]+1];
; 1898 :       piv[1][1] = S->LA[S->LIA[n+1]];
; 1899 :       det = piv[0][0]*piv[1][1] - piv[0][1]*piv[1][0];
; 1900 :       pinv[0][0] = piv[1][1]/det;
; 1901 :       pinv[1][0] = pinv[0][1] = -piv[0][1]/det;
; 1902 :       pinv[1][1] = piv[0][0]/det;
; 1903 :       for ( k = 0 ; k < rk ; k++ )
; 1904 :       { yy = Y[n][k]*pinv[0][0] + Y[n+1][k]*pinv[1][0];
; 1905 :         Y[n+1][k] = Y[n][k]*pinv[0][1] + Y[n+1][k]*pinv[1][1];
; 1906 :         Y[n][k] = yy;
; 1907 :       }
; 1908 :       n++; 
; 1909 :     }
; 1910 :   }
; 1911 : 
; 1912 :   /* solve U X = V */
; 1913 :   for ( n = S->N-1 ; n >= 0 ; n-- )
; 1914 :   { int start,end;
; 1915 :     REAL *yy,*bb,ee;
; 1916 :     if ( S->psize[n] == FIRSTOFPAIR ) start = 2;
; 1917 :     else start = 1; 
; 1918 :     end = S->LIA[n+1];
; 1919 :     for ( i=S->LIA[n]+start, e=S->LA+i, jp=S->LJA+S->LIJA[n]+start  ; 
; 1920 :         i < end ; i++,e++,jp++ )
; 1921 :     { ee = *e;
; 1922 :       for ( yy = Y[n], bb = BB[*jp], k = 0 ; k < rk ; k++ )
; 1923 :          *(yy++) -= ee*(*(bb++));
; 1924 :     }
; 1925 :     for ( yy = Y[n], bb = BB[S->LJA[S->LIJA[n]]], k = 0 ; k < rk ; k++ )
; 1926 :       *(bb++) = *(yy++);
; 1927 :   }
; 1928 : 
; 1929 :   /* unpermute */
; 1930 :   for ( n = 0 ; n < S->N ; n++ )
; 1931 :     for ( k = 0 ; k < rk ; k++ )
; 1932 :      x[k][S->P[n]] = BB[n][k];
; 1933 : 
; 1934 :   free_matrix(Y);
; 1935 :   free_matrix(BB);
; 1936 : } 
; 1937 : #endif
; 1938 : } // end xmd_solve_multi()

	pop	ebp
	ret	0
_xmd_solve_multi ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@FCHIICPF@u?$FL?$CFd?$FN?$FL?$CFd?$FN?5?$DN?5?$CF20?415f?5?5?5?5a?$FL?$CFd?$FN?$FL?$CFd?$FN@ ; `string'
PUBLIC	__real@4059000000000000
PUBLIC	_dsolve
EXTRN	_free_matrix:PROC
EXTRN	_machine_eps:QWORD
EXTRN	_kb_dmatrix:PROC
;	COMDAT ??_C@_0CM@FCHIICPF@u?$FL?$CFd?$FN?$FL?$CFd?$FN?5?$DN?5?$CF20?415f?5?5?5?5a?$FL?$CFd?$FN?$FL?$CFd?$FN@
CONST	SEGMENT
??_C@_0CM@FCHIICPF@u?$FL?$CFd?$FN?$FL?$CFd?$FN?5?$DN?5?$CF20?415f?5?5?5?5a?$FL?$CFd?$FN?$FL?$CFd?$FN@ DB 'u'
	DB	'[%d][%d] = %20.15f    a[%d][%d] = %20.15f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _dsolve
_TEXT	SEGMENT
tv1874 = -48						; size = 4
tv1781 = -48						; size = 4
tv1693 = -44						; size = 4
tv1275 = -44						; size = 4
tv1902 = -40						; size = 4
tv1786 = -40						; size = 4
tv1154 = -36						; size = 4
tv722 = -36						; size = 4
tv1870 = -32						; size = 4
tv1784 = -32						; size = 4
tv986 = -32						; size = 4
tv677 = -28						; size = 4
tv1595 = -24						; size = 4
_xIP$ = -20						; size = 4
tv1322 = -16						; size = 4
_u$ = -16						; size = 4
_k$ = -12						; size = 4
_j$ = -8						; size = 4
_a$ = -4						; size = 4
tv1754 = 8						; size = 4
tv1326 = 8						; size = 4
tv767 = 8						; size = 4
_S$ = 8							; size = 4
_dsolve	PROC						; COMDAT

; 1945 : { REAL **a,**u;

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi

; 1946 :   int i,j,k,m,jj;
; 1947 : 
; 1948 :   int *xIP = (int*)temp_calloc(S->N,sizeof(int));

	mov	esi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [esi+4]
	push	edi
	push	1948					; 0000079cH
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	push	4
	push	eax
	call	_kb_temp_calloc

; 1949 :   for ( k = 0 ; k < S->N ; k++ )

	xor	ecx, ecx
	add	esp, 16					; 00000010H
	mov	DWORD PTR _xIP$[ebp], eax
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN42@dsolve
	npad	2
$LL44@dsolve:

; 1950 :      xIP[S->LJA[S->LIJA[k]]] = k;

	mov	edx, DWORD PTR [esi+136]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	edi, DWORD PTR [esi+132]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	DWORD PTR [eax+edx*4], ecx
	inc	ecx
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LL44@dsolve
$LN42@dsolve:

; 1951 : 
; 1952 :   a = dmatrix(0,S->N-1,0,S->N-1);

	mov	eax, DWORD PTR [esi+4]
	push	1952					; 000007a0H
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 1953 :   for ( i = 0 ; i < S->N ; i++ )

	xor	ebx, ebx
	add	esp, 24					; 00000018H
	mov	edi, eax
	mov	DWORD PTR _a$[ebp], edi
	cmp	DWORD PTR [esi+4], ebx
	jle	SHORT $LN77@dsolve
	mov	ecx, DWORD PTR [esi+52]
$LL41@dsolve:

; 1954 :   { for ( j = S->IA[i]-A_OFF  ; j < S->IA[i+1] - A_OFF ; j++ )

	mov	eax, DWORD PTR [ecx+ebx*4]
	mov	edx, DWORD PTR [ecx+ebx*4+4]
	dec	eax
	dec	edx
	cmp	eax, edx
	jge	SHORT $LN40@dsolve
$LL78@dsolve:

; 1955 :      { k = xIP[S->IP[i]];

	mov	ecx, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [ecx+ebx*4]
	mov	edi, DWORD PTR _xIP$[ebp]
	mov	edx, DWORD PTR [edi+edx*4]

; 1956 :        m = xIP[S->IP[S->JA[j]-A_OFF]];

	mov	edi, DWORD PTR [esi+56]
	mov	edi, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [ecx+edi*4-4]
	mov	edi, DWORD PTR _xIP$[ebp]
	mov	ecx, DWORD PTR [edi+ecx*4]

; 1957 :        a[k][m] = a[m][k] = S->A[j];

	mov	edi, DWORD PTR [esi+60]
	fld	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR _a$[ebp]
	mov	edi, DWORD PTR [edi+ecx*4]
	fst	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [edi+edx*4]
	fstp	QWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [ecx+ebx*4+4]
	inc	eax
	dec	edx
	cmp	eax, edx
	jl	SHORT $LL78@dsolve
$LN40@dsolve:

; 1953 :   for ( i = 0 ; i < S->N ; i++ )

	inc	ebx
	cmp	ebx, DWORD PTR [esi+4]
	jl	SHORT $LL41@dsolve
$LN77@dsolve:

; 1958 :      }
; 1959 :   }
; 1960 :   for ( i = 0 ; i < S->N ; i++ )

	mov	eax, DWORD PTR [esi+4]
	xor	ecx, ecx
	test	eax, eax
	jle	$LN80@dsolve
	mov	ebx, 2
	mov	DWORD PTR tv1322[ebp], ebx
	mov	DWORD PTR tv1326[ebp], 1
$LL35@dsolve:

; 1961 :   { 
; 1962 :      if ( S->psize[i] == ONEBYONE )

	mov	edx, DWORD PTR [esi+120]
	mov	edx, DWORD PTR [edx+ecx*4]
	cmp	edx, 1
	jne	$LN32@dsolve

; 1963 :      { for ( j = i+1 ; j < S->N ; j++ )

	mov	edx, DWORD PTR tv1326[ebp]
	mov	ebx, edx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	edx, eax
	jge	SHORT $LN29@dsolve
$LL31@dsolve:

; 1964 :           for ( k = i+1 ; k < S->N ; k++ )

	mov	DWORD PTR _k$[ebp], edx
	cmp	edx, eax
	jge	SHORT $LN30@dsolve

; 1958 :      }
; 1959 :   }
; 1960 :   for ( i = 0 ; i < S->N ; i++ )

	mov	edx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [edi+ebx*4]
	mov	eax, DWORD PTR tv1326[ebp]

; 1964 :           for ( k = i+1 ; k < S->N ; k++ )

	mov	ebx, edx
	sub	ebx, edi
	lea	eax, DWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR _k$[ebp]
	mov	DWORD PTR tv986[ebp], ebx
	jmp	SHORT $LN28@dsolve
$LL76@dsolve:
	mov	ebx, DWORD PTR tv986[ebp]
$LN28@dsolve:

; 1965 :              a[j][k] -= a[i][j]*a[i][k]/a[i][i];

	fld	QWORD PTR [ebx+eax]
	mov	ebx, DWORD PTR _j$[ebp]
	fmul	QWORD PTR [edx+ebx*8]
	inc	edi
	add	eax, 8
	fdiv	QWORD PTR [edx+ecx*8]
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL76@dsolve

; 1964 :           for ( k = i+1 ; k < S->N ; k++ )

	mov	edi, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR tv1326[ebp]
$LN30@dsolve:

; 1963 :      { for ( j = i+1 ; j < S->N ; j++ )

	mov	eax, DWORD PTR [esi+4]
	inc	ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, eax
	jl	SHORT $LL31@dsolve
$LN29@dsolve:

; 1966 :         for ( k = i+1 ; k < S->N ; k++ )

	mov	ebx, edx
	cmp	edx, DWORD PTR [esi+4]
	jge	SHORT $LN79@dsolve

; 1958 :      }
; 1959 :   }
; 1960 :   for ( i = 0 ; i < S->N ; i++ )

	mov	eax, DWORD PTR [edi+ecx*4]
	lea	eax, DWORD PTR [eax+edx*8]
	npad	4
$LL25@dsolve:

; 1967 :           a[i][k] /= a[i][i];

	fld	QWORD PTR [eax]
	mov	edx, DWORD PTR [edi+ecx*4]
	fdiv	QWORD PTR [edx+ecx*8]
	inc	ebx
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	ebx, DWORD PTR [esi+4]
	jl	SHORT $LL25@dsolve

; 1968 :      }
; 1969 :      else if ( S->psize[i] == ZEROPIVOT )

	mov	edx, DWORD PTR tv1326[ebp]
$LN79@dsolve:
	mov	ebx, DWORD PTR tv1322[ebp]
$LN34@dsolve:

; 1958 :      }
; 1959 :   }
; 1960 :   for ( i = 0 ; i < S->N ; i++ )

	mov	eax, DWORD PTR [esi+4]
	inc	ecx
	inc	edx
	inc	ebx
	mov	DWORD PTR tv1326[ebp], edx
	mov	DWORD PTR tv1322[ebp], ebx
	cmp	ecx, eax
	jl	$LL35@dsolve
$LN80@dsolve:

; 1987 :      }
; 1988 : 
; 1989 :   }
; 1990 :   u = dmatrix(0,S->N-1,0,S->N-1);

	mov	eax, DWORD PTR [esi+4]
	push	1990					; 000007c6H
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	dec	eax
	push	eax
	push	0
	push	eax
	push	0
	call	_kb_dmatrix

; 1991 :   for ( i = 0 ; i < S->N ; i++ )

	xor	ecx, ecx
	add	esp, 24					; 00000018H
	mov	DWORD PTR _u$[ebp], eax
	cmp	DWORD PTR [esi+4], ecx
	jle	SHORT $LN11@dsolve
	mov	edx, DWORD PTR [esi+128]
	npad	6
$LL13@dsolve:

; 1992 :      for ( j = S->LIA[i], jj = S->LIJA[i]; j < S->LIA[i+1] ; j++ )

	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [esi+136]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	cmp	eax, DWORD PTR [edx+ecx*4+4]
	jge	SHORT $LN12@dsolve
	mov	edx, DWORD PTR _u$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv767[ebp], edx
	npad	5
$LL10@dsolve:

; 1993 :         u[i][S->LJA[jj]] = S->LA[j];

	mov	edx, DWORD PTR [esi+140]
	fld	QWORD PTR [edx+eax*8]
	mov	edi, DWORD PTR [esi+132]
	mov	edx, DWORD PTR tv767[ebp]
	mov	edi, DWORD PTR [edi+ebx*4]
	fstp	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR [esi+128]
	inc	eax
	cmp	eax, DWORD PTR [edx+ecx*4+4]
	jl	SHORT $LL10@dsolve

; 1992 :      for ( j = S->LIA[i], jj = S->LIJA[i]; j < S->LIA[i+1] ; j++ )

	mov	edi, DWORD PTR _a$[ebp]
$LN12@dsolve:

; 1991 :   for ( i = 0 ; i < S->N ; i++ )

	inc	ecx
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LL13@dsolve
	mov	eax, DWORD PTR _u$[ebp]
$LN11@dsolve:

; 1994 :   for ( i = 0 ; i < S->N ; i++ )

	mov	edx, DWORD PTR [esi+4]
	xor	ebx, ebx
	test	edx, edx
	jle	$LN5@dsolve
	mov	ecx, edi
	sub	ecx, eax
	mov	DWORD PTR tv1754[ebp], eax
	mov	DWORD PTR tv1781[ebp], ecx
	npad	8
$LL7@dsolve:

; 1995 :     for ( j = i ; j < S->N ; j++ )

	mov	ecx, ebx
	cmp	ebx, edx
	jge	$LN6@dsolve
	mov	eax, DWORD PTR tv1754[ebp]
	fld	QWORD PTR _machine_eps
	mov	edx, DWORD PTR tv1781[ebp]
	fmul	QWORD PTR __real@4059000000000000
	mov	edx, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv1784[ebp], edx
	lea	edx, DWORD PTR [eax+ebx*8]
	mov	DWORD PTR tv1693[ebp], edx
	mov	edx, DWORD PTR tv1784[ebp]
	sub	edx, eax
	mov	DWORD PTR tv1786[ebp], edx
	mov	edx, DWORD PTR tv1693[ebp]
$LN4@dsolve:

; 1996 :       if ( fabs(a[i][j]-u[i][j]) > 100*machine_eps )

	mov	eax, DWORD PTR tv1786[ebp]
	fld	QWORD PTR [eax+edx]
	fsub	QWORD PTR [edx]
	fabs
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$LN98@dsolve

; 1995 :     for ( j = i ; j < S->N ; j++ )

	inc	ecx
	add	edx, 8
	cmp	ecx, DWORD PTR [esi+4]
	jl	SHORT $LN4@dsolve
	fstp	ST(0)

; 1996 :       if ( fabs(a[i][j]-u[i][j]) > 100*machine_eps )

	jmp	$LN6@dsolve
$LN32@dsolve:

; 1968 :      }
; 1969 :      else if ( S->psize[i] == ZEROPIVOT )

	test	edx, edx

; 1970 :      { a[i][i] = 0.0;

	mov	edx, DWORD PTR [edi+ecx*4]
	jne	SHORT $LN21@dsolve
	fldz
	fstp	QWORD PTR [edx+ecx*8]

; 1971 :      }
; 1972 :      else

	mov	edx, DWORD PTR tv1326[ebp]
	jmp	$LN34@dsolve
$LN21@dsolve:

; 1973 :      { REAL p11,p12,p22,detinv,pa1,pa2;
; 1974 :        p11 = a[i][i]; p12 = a[i][i+1]; p22 = a[i+1][i+1];

	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fld	QWORD PTR [edx+8]
	mov	edx, DWORD PTR [edi+ecx*4+4]
	fld	QWORD PTR [edx+ecx*8+8]
	mov	DWORD PTR tv1595[ebp], edx

; 1975 :        detinv = 1/(p11*p22 - p12*p12);

	fld	ST(0)

; 1976 :        /* sweep through matrix */
; 1977 :        for ( k = i+2 ; k < S->N ; k++ ) /* row */

	mov	DWORD PTR _k$[ebp], ebx
	fmul	ST(0), ST(3)
	fld	ST(2)
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fld1
	fdivrp	ST(1), ST(0)
	cmp	ebx, eax
	jge	$LN84@dsolve

; 1958 :      }
; 1959 :   }
; 1960 :   for ( i = 0 ; i < S->N ; i++ )

	mov	edx, DWORD PTR [edi+ecx*4]
	lea	edi, DWORD PTR [edx+ebx*8]

; 1976 :        /* sweep through matrix */
; 1977 :        for ( k = i+2 ; k < S->N ; k++ ) /* row */

	mov	ebx, DWORD PTR _a$[ebp]
	mov	ebx, DWORD PTR [ebx+ecx*4+4]
	sub	ebx, edx
	mov	DWORD PTR tv1870[ebp], ebx
	mov	ebx, edx
	sub	ebx, edx
	mov	DWORD PTR tv1275[ebp], ebx
	mov	ebx, DWORD PTR tv1595[ebp]
	sub	ebx, edx
	mov	DWORD PTR tv677[ebp], edx
	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR tv1874[ebp], ebx
	mov	ebx, DWORD PTR tv1870[ebp]
$LN19@dsolve:

; 1978 :           { pa1 = (a[i][k]*p22 - a[i+1][k]*p12)*detinv;

	fld	QWORD PTR [edi]

; 1979 :              pa2 = (a[i+1][k]*p11 - a[i][k]*p12)*detinv;
; 1980 :              for ( j=k ; j < S->N ; j++ ) /*col*/

	mov	DWORD PTR _j$[ebp], edx
	fmul	ST(0), ST(2)
	fld	QWORD PTR [ebx+edi]
	fmul	ST(0), ST(4)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(1)
	fld	QWORD PTR [ebx+edi]
	fmul	ST(0), ST(5)
	fld	QWORD PTR [edi]
	fmul	ST(0), ST(5)
	fsubp	ST(1), ST(0)
	fmul	ST(0), ST(2)
	cmp	edx, eax
	jge	SHORT $LN75@dsolve
	mov	eax, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	ebx, DWORD PTR tv1595[ebp]
	mov	DWORD PTR tv722[ebp], eax
	lea	eax, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR tv677[ebp]
	sub	ebx, edx
	sub	edx, DWORD PTR tv722[ebp]
	mov	DWORD PTR tv1902[ebp], ebx
	mov	DWORD PTR tv1154[ebp], edx
	jmp	SHORT $LN16@dsolve
$LN74@dsolve:
	mov	edx, DWORD PTR tv1154[ebp]
$LN16@dsolve:

; 1981 :              {  a[k][j] -=  pa1*a[i][j] + pa2*a[i+1][j]; 

	add	edx, eax
	fld	QWORD PTR [ebx+edx]
	add	eax, 8
	fmul	ST(0), ST(1)
	fld	QWORD PTR [edx]
	mov	edx, DWORD PTR _j$[ebp]
	fmul	ST(0), ST(3)
	inc	edx
	mov	DWORD PTR _j$[ebp], edx
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LN74@dsolve

; 1979 :              pa2 = (a[i+1][k]*p11 - a[i][k]*p12)*detinv;
; 1980 :              for ( j=k ; j < S->N ; j++ ) /*col*/

	mov	ebx, DWORD PTR tv1870[ebp]
	mov	edx, DWORD PTR _k$[ebp]
$LN75@dsolve:

; 1982 :              }
; 1983 :              a[i][k] = pa1;

	mov	eax, DWORD PTR tv1275[ebp]
	fxch	ST(1)
	fstp	QWORD PTR [eax+edi]

; 1984 :              a[i+1][k] = pa2;

	mov	eax, DWORD PTR tv1874[ebp]
	inc	edx
	fstp	QWORD PTR [eax+edi]
	mov	eax, DWORD PTR [esi+4]
	add	edi, 8
	mov	DWORD PTR _k$[ebp], edx
	cmp	edx, eax
	jl	$LN19@dsolve

; 1976 :        /* sweep through matrix */
; 1977 :        for ( k = i+2 ; k < S->N ; k++ ) /* row */

	mov	edi, DWORD PTR _a$[ebp]
	mov	ebx, DWORD PTR tv1322[ebp]
$LN84@dsolve:
	mov	edx, DWORD PTR tv1326[ebp]
	fstp	ST(2)
	fstp	ST(1)

; 1985 :           }
; 1986 :        i++;  /* since did 2 rows */

	inc	ecx
	fstp	ST(1)
	inc	edx
	fstp	ST(0)
	inc	ebx
	jmp	$LN34@dsolve
$LN98@dsolve:

; 1997 :       { printf("u[%d][%d] = %20.15f    a[%d][%d] = %20.15f\n",
; 1998 :               i,j,(DOUBLE)u[i][j],i,j,(DOUBLE)a[i][j]);

	mov	edx, DWORD PTR tv1784[ebp]
	fstp	ST(0)
	fld	QWORD PTR [edx+ecx*8]
	mov	eax, DWORD PTR tv1754[ebp]
	mov	eax, DWORD PTR [eax]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	fld	QWORD PTR [eax+ecx*8]
	push	ebx
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	ecx
	push	ebx
	push	OFFSET ??_C@_0CM@FCHIICPF@u?$FL?$CFd?$FN?$FL?$CFd?$FN?5?$DN?5?$CF20?415f?5?5?5?5a?$FL?$CFd?$FN?$FL?$CFd?$FN@
	call	_printf
	add	esp, 36					; 00000024H
$LN6@dsolve:

; 1994 :   for ( i = 0 ; i < S->N ; i++ )

	mov	edx, DWORD PTR [esi+4]
	add	DWORD PTR tv1754[ebp], 4
	inc	ebx
	cmp	ebx, edx
	jl	$LL7@dsolve
$LN5@dsolve:

; 1999 :         break;
; 2000 :       }
; 2001 : 
; 2002 :   free_matrix(a);

	push	edi
	call	_free_matrix

; 2003 :   free_matrix(u);

	mov	ecx, DWORD PTR _u$[ebp]
	push	ecx
	call	_free_matrix

; 2004 :   temp_free((char*)xIP);

	mov	edx, DWORD PTR _xIP$[ebp]
	push	edx
	call	_temp_free
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2005 : } // end dsolve()

	mov	esp, ebp
	pop	ebp
	ret	0
_dsolve	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@DKPLIEML@Total_flops?3?5?$CFg?6?$AA@	; `string'
PUBLIC	??_C@_0BB@LPNDPICA@Total_fill?3?5?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0BO@NBIMJJFJ@Passes?5through?5main?5loop?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@PHAAIKMF@Workspace?3?5?$CFlu?5bytes?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@KNNCMEHI@Variables?3?5?$CFd?5?5Original?5fill?3?5?$CFd@ ; `string'
PUBLIC	??_C@_0CG@BADDHOBP@Internal?5error?3?5Empty?5linear?5sys@ ; `string'
PUBLIC	_xmd_factor
EXTRN	_hessian_quiet_flag:DWORD
EXTRN	_eigen_zero:DWORD
EXTRN	_eigen_neg:DWORD
EXTRN	_eigen_pos:DWORD
EXTRN	__CIsqrt:PROC
_BSS	SEGMENT
_passes	DD	01H DUP (?)
_L_total DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BB@DKPLIEML@Total_flops?3?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BB@DKPLIEML@Total_flops?3?5?$CFg?6?$AA@ DB 'Total_flops: %g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LPNDPICA@Total_fill?3?5?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BB@LPNDPICA@Total_fill?3?5?5?$CFd?6?$AA@ DB 'Total_fill:  %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NBIMJJFJ@Passes?5through?5main?5loop?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BO@NBIMJJFJ@Passes?5through?5main?5loop?3?5?$CFd?6?$AA@ DB 'Passes'
	DB	' through main loop: %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PHAAIKMF@Workspace?3?5?$CFlu?5bytes?6?$AA@
CONST	SEGMENT
??_C@_0BG@PHAAIKMF@Workspace?3?5?$CFlu?5bytes?6?$AA@ DB 'Workspace: %lu b'
	DB	'ytes', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KNNCMEHI@Variables?3?5?$CFd?5?5Original?5fill?3?5?$CFd@
CONST	SEGMENT
??_C@_0CC@KNNCMEHI@Variables?3?5?$CFd?5?5Original?5fill?3?5?$CFd@ DB 'Var'
	DB	'iables: %d  Original fill: %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@BADDHOBP@Internal?5error?3?5Empty?5linear?5sys@
CONST	SEGMENT
??_C@_0CG@BADDHOBP@Internal?5error?3?5Empty?5linear?5sys@ DB 'Internal er'
	DB	'ror: Empty linear system.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _xmd_factor
_TEXT	SEGMENT
tv1046 = 8						; size = 4
_end$90460 = 8						; size = 4
_S$ = 8							; size = 4
_mtype$ = 12						; size = 4
_xmd_factor PROC					; COMDAT

; 2015 : { int i,j;

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 2016 :   int rnum;
; 2017 :   struct region *r;
; 2018 :   
; 2019 :   if ( S->N <= 0 )

	mov	esi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [esi+4]
	xor	ebx, ebx
	cmp	eax, ebx
	jg	SHORT $LN19@xmd_factor

; 2020 :   { kb_error(1839,"Internal error: Empty linear system.\n",WARNING); 

	push	2
	push	OFFSET ??_C@_0CG@BADDHOBP@Internal?5error?3?5Empty?5linear?5sys@
	push	1839					; 0000072fH
	call	_kb_error

; 2108 :     printf("Total_flops: %g\n",(DOUBLE)total_flops);

	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebx

; 2109 :   }
; 2110 : } // end  xmd_factor()

	pop	ebp
	ret	0
$LN19@xmd_factor:

; 2021 :     return;
; 2022 :   }
; 2023 :   total_flops = total_fill = 0;
; 2024 :   rtimestamp = 0;
; 2025 :   stimestamp = 0;
; 2026 :   old_rtimestamp = -1; /* less than rtimestamp first time around */
; 2027 :   vtimestamp = 0;
; 2028 :   S->neg = S->zero = S->pos = 0;
; 2029 :   S->degencon = 0;
; 2030 : 
; 2031 :   /* working storage */
; 2032 :   S->NSP = 4*S->IA[S->N];

	mov	ecx, DWORD PTR [esi+52]
	fldz
	mov	DWORD PTR [esi+184], ebx
	fstp	QWORD PTR _total_flops
	mov	DWORD PTR [esi+192], ebx
	mov	DWORD PTR [esi+188], ebx
	mov	DWORD PTR [esi+196], ebx
	mov	eax, DWORD PTR [ecx+eax*4]
	push	edi
	add	eax, eax
	add	eax, eax

; 2033 :   S->ISP = (int*)temp_realloc((char*)S->ISP,S->NSP*sizeof(int));

	push	2033					; 000007f1H
	lea	edx, DWORD PTR [eax*4]
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	mov	DWORD PTR [esi+88], eax
	mov	eax, DWORD PTR [esi+92]
	push	edx
	push	eax
	mov	DWORD PTR _total_fill, ebx
	mov	DWORD PTR _rtimestamp, ebx
	mov	DWORD PTR _stimestamp, ebx
	mov	DWORD PTR _old_rtimestamp, -1
	mov	DWORD PTR _vtimestamp, ebx
	call	_kb_temp_realloc

; 2034 :   memset(S->ISP,0,S->NSP*sizeof(int));

	mov	ecx, DWORD PTR [esi+88]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	ebx
	push	eax
	mov	DWORD PTR [esi+92], eax
	call	_memset

; 2035 : 
; 2036 :   /* row magnitudes for nullity detection */
; 2037 :   S->rowmag = (REAL *)temp_realloc((char*)S->rowmag,S->N*sizeof(REAL));

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+204]
	add	edx, edx
	push	2037					; 000007f5H
	add	edx, edx
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	add	edx, edx
	push	edx
	push	eax
	call	_kb_temp_realloc

; 2038 :   memset(S->rowmag,0,S->N*sizeof(REAL));

	mov	ecx, DWORD PTR [esi+4]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	ebx
	push	eax
	mov	DWORD PTR [esi+204], eax
	call	_memset
	add	esp, 56					; 00000038H

; 2039 :   for ( i = 0 ; i < S->N ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR [esi+4], ebx
	jle	$LN16@xmd_factor
	npad	5
$LL18@xmd_factor:
	mov	edx, DWORD PTR [esi+52]

; 2040 :   { int end = S->IA[i+1] - A_OFF;

	mov	edi, DWORD PTR [edx+ecx*4+4]
	lea	eax, DWORD PTR [edx+ecx*4]

; 2041 :     for ( j = S->IA[i]-A_OFF ; j < end ; j++ )

	mov	eax, DWORD PTR [eax]
	dec	edi
	dec	eax
	mov	DWORD PTR _end$90460[ebp], edi
	cmp	eax, edi
	jge	$LN17@xmd_factor
	mov	edx, edi
	sub	edx, eax
	cmp	edx, 4
	jl	$LC35@xmd_factor
	add	edi, -3					; fffffffdH
	npad	7
$LL36@xmd_factor:

; 2042 :     { S->rowmag[i] += S->A[j]*S->A[j];

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [esi+204]
	fmul	ST(0), ST(0)
	lea	edx, DWORD PTR [edx+ecx*8]

; 2043 :       S->rowmag[S->JA[j]-A_OFF] += S->A[j]*S->A[j];

	add	eax, 4
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8-32]
	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4-16]
	fmul	ST(0), ST(0)
	mov	ebx, DWORD PTR [esi+204]
	lea	edx, DWORD PTR [ebx+edx*8-8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8-24]
	mov	edx, DWORD PTR [esi+204]
	fmul	ST(0), ST(0)
	lea	edx, DWORD PTR [edx+ecx*8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8-24]
	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4-12]
	fmul	ST(0), ST(0)
	mov	ebx, DWORD PTR [esi+204]
	lea	edx, DWORD PTR [ebx+edx*8-8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8-16]
	mov	edx, DWORD PTR [esi+204]
	fmul	ST(0), ST(0)
	lea	edx, DWORD PTR [edx+ecx*8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8-16]
	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4-8]
	fmul	ST(0), ST(0)
	mov	ebx, DWORD PTR [esi+204]
	lea	edx, DWORD PTR [ebx+edx*8-8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8-8]
	mov	edx, DWORD PTR [esi+204]
	fmul	ST(0), ST(0)
	lea	edx, DWORD PTR [edx+ecx*8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8-8]
	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4-4]
	fmul	ST(0), ST(0)
	mov	ebx, DWORD PTR [esi+204]
	lea	edx, DWORD PTR [ebx+edx*8-8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	cmp	eax, edi
	jl	$LL36@xmd_factor
	mov	edi, DWORD PTR _end$90460[ebp]
	xor	ebx, ebx
$LC35@xmd_factor:

; 2041 :     for ( j = S->IA[i]-A_OFF ; j < end ; j++ )

	cmp	eax, edi
	jge	SHORT $LN17@xmd_factor
$LC15@xmd_factor:

; 2042 :     { S->rowmag[i] += S->A[j]*S->A[j];

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [esi+204]
	fmul	ST(0), ST(0)
	lea	edx, DWORD PTR [edx+ecx*8]
	inc	eax
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]

; 2043 :       S->rowmag[S->JA[j]-A_OFF] += S->A[j]*S->A[j];

	mov	edx, DWORD PTR [esi+60]
	fld	QWORD PTR [edx+eax*8-8]
	mov	edx, DWORD PTR [esi+56]
	mov	edx, DWORD PTR [edx+eax*4-4]
	fmul	ST(0), ST(0)
	mov	ebx, DWORD PTR [esi+204]
	lea	edx, DWORD PTR [ebx+edx*8-8]
	fadd	QWORD PTR [edx]
	fstp	QWORD PTR [edx]
	cmp	eax, edi
	jl	SHORT $LC15@xmd_factor

; 2041 :     for ( j = S->IA[i]-A_OFF ; j < end ; j++ )

	xor	ebx, ebx
$LN17@xmd_factor:

; 2039 :   for ( i = 0 ; i < S->N ; i++ )

	inc	ecx
	cmp	ecx, DWORD PTR [esi+4]
	jl	$LL18@xmd_factor
$LN16@xmd_factor:

; 2044 :     }
; 2045 :   }
; 2046 :   for ( i = 0 ; i < S->N ; i++ )

	xor	edi, edi
	cmp	DWORD PTR [esi+4], ebx
	jle	SHORT $LN10@xmd_factor
	npad	2
$LL12@xmd_factor:
	mov	eax, DWORD PTR [esi+204]

; 2047 :    S->rowmag[i] = sqrt(S->rowmag[i]);

	fld	QWORD PTR [eax+edi*8]
	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR tv1046[ebp], eax
	call	__CIsqrt
	mov	ecx, DWORD PTR tv1046[ebp]
	inc	edi
	fstp	QWORD PTR [ecx]
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL12@xmd_factor
$LN10@xmd_factor:

; 2048 :       
; 2049 : 
; 2050 :   md_vertex_setup(S);

	push	esi
	call	_md_vertex_setup

; 2051 :   md_supernode_setup(S);

	push	esi
	call	_md_supernode_setup

; 2052 :   md_region_string(S);

	push	esi
	call	_md_region_string

; 2053 :   md_supernode_regions(S);

	push	esi
	call	_md_supernode_regions

; 2054 :   /* space for lists */
; 2055 :   superheap = (struct supernode**)temp_calloc(supercount+1,
; 2056 :                   sizeof(struct supernode*));

	mov	edx, DWORD PTR _supercount
	push	2056					; 00000808H
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	inc	edx
	push	4
	push	edx
	call	_kb_temp_calloc
	mov	DWORD PTR _superheap, eax

; 2057 :                   
; 2058 :   /* final lower triangular matrix storage */
; 2059 :   S->psize = (int*)temp_realloc((char*)S->psize,S->N*sizeof(int));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+120]
	push	2059					; 0000080bH
	add	eax, eax
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	add	eax, eax
	push	eax
	push	ecx
	call	_kb_temp_realloc

; 2060 :   S->LIA = (int*)temp_realloc((char*)S->LIA,(S->N+1)*sizeof(int));

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+128]
	push	2060					; 0000080cH
	mov	DWORD PTR [esi+120], eax
	push	OFFSET ??_C@_08PPFDFAAI@MINDEG?4C?$AA@
	lea	eax, DWORD PTR [edx*4+4]
	push	eax
	push	ecx
	call	_kb_temp_realloc

; 2061 :   memset((char*)S->psize,0,S->N*sizeof(int));

	mov	edx, DWORD PTR [esi+4]
	add	edx, edx
	add	esp, 64					; 00000040H
	add	edx, edx
	push	edx
	mov	DWORD PTR [esi+128], eax
	mov	eax, DWORD PTR [esi+120]
	push	ebx
	push	eax
	call	_memset

; 2062 :   memset((char*)S->LIA,0,(S->N+1)*sizeof(int));

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+128]
	lea	edx, DWORD PTR [ecx*4+4]
	push	edx
	push	ebx
	push	eax
	call	_memset
	add	esp, 24					; 00000018H

; 2063 :   
; 2064 :   L_total = 0;

	mov	DWORD PTR _L_total, ebx

; 2065 :   elim_count = 0;

	mov	DWORD PTR _elim_count, ebx

; 2066 : 
; 2067 :   for(passes=0;;passes++)

	mov	DWORD PTR _passes, ebx

; 2068 :   {
; 2069 :      if ( supercount == 0 ) break;

	cmp	DWORD PTR _supercount, ebx
	je	SHORT $LN28@xmd_factor
$LL9@xmd_factor:

; 2070 :      degree_sort(S);

	push	esi
	call	_degree_sort

; 2071 :      multiple_eliminate(S);

	push	esi
	call	_multiple_eliminate

; 2072 :      region_absorb(S);  /* needed to have few passes through main loop */

	push	esi
	call	_region_absorb

; 2073 :      clean_supernodes(S);  /* supernodes stamped */

	push	esi
	call	_clean_supernodes

; 2074 :      merge_supernodes(S);

	push	esi
	call	_merge_supernodes
	add	esp, 20					; 00000014H

; 2075 : 
; 2076 :   if ( mindeg_debug_level == -1 )

	cmp	DWORD PTR _mindeg_debug_level, -1
	jne	SHORT $LN8@xmd_factor

; 2077 :     show_mindeg_state(S);

	push	esi
	call	_show_mindeg_state
	add	esp, 4
$LN8@xmd_factor:

; 2068 :   {
; 2069 :      if ( supercount == 0 ) break;

	inc	DWORD PTR _passes
	cmp	DWORD PTR _supercount, ebx
	jne	SHORT $LL9@xmd_factor
$LN28@xmd_factor:

; 2078 : 
; 2079 :   }
; 2080 :   S->LIA[elim_count] = L_total;  /* final sentinel */

	mov	ecx, DWORD PTR [esi+128]
	mov	edx, DWORD PTR _L_total
	mov	eax, DWORD PTR _elim_count
	mov	DWORD PTR [ecx+eax*4], edx

; 2081 : 
; 2082 :   /* free temp storage */ 
; 2083 :   temp_free((char*)slist);

	mov	ecx, DWORD PTR _slist
	push	ecx
	call	_temp_free

; 2084 :   temp_free((char*)vlist); vlist = NULL;

	mov	edx, DWORD PTR _vlist
	push	edx
	call	_temp_free

; 2085 :   temp_free((char*)superheap); superheap = NULL;

	mov	eax, DWORD PTR _superheap
	push	eax
	mov	DWORD PTR _vlist, ebx
	call	_temp_free

; 2086 : 
; 2087 :   /* gather stats */
; 2088 :   final_regions = 0;
; 2089 :   final_versizes   = 0;
; 2090 :   for ( rnum = regionstart ; rnum >= 0 ; rnum = r->next )

	mov	eax, DWORD PTR _regionstart
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _superheap, ebx
	mov	DWORD PTR _final_regions, ebx
	mov	DWORD PTR _final_versizes, ebx
	cmp	eax, ebx
	jl	SHORT $LN2@xmd_factor
$LL4@xmd_factor:

; 2091 :   { r = REG(rnum);

	mov	ecx, DWORD PTR [esi+92]
	lea	edi, DWORD PTR [ecx+eax*4]

; 2092 :     groom_regions_recur(S,r);

	push	edi
	push	esi
	call	_groom_regions_recur
	mov	eax, DWORD PTR [edi+36]
	add	esp, 8
	cmp	eax, ebx
	jge	SHORT $LL4@xmd_factor
$LN2@xmd_factor:

; 2093 :   }
; 2094 :   compact_regions(S);

	push	esi
	call	_compact_regions

; 2095 : 
; 2096 :   traverse_region_tree(S); 

	push	esi
	call	_traverse_region_tree

; 2097 : 
; 2098 :   eigen_pos = S->pos; 

	mov	edx, DWORD PTR [esi+184]
	mov	DWORD PTR _eigen_pos, edx

; 2099 :   eigen_neg = S->neg;

	mov	eax, DWORD PTR [esi+188]
	add	esp, 8
	mov	DWORD PTR _eigen_neg, eax

; 2100 :   eigen_zero = S->zero;

	mov	ecx, DWORD PTR [esi+192]
	mov	DWORD PTR _eigen_zero, ecx
	pop	edi

; 2101 : 
; 2102 :   if ( !hessian_quiet_flag )

	cmp	DWORD PTR _hessian_quiet_flag, ebx
	jne	SHORT $LN1@xmd_factor

; 2103 :   {
; 2104 :     printf("Variables: %d  Original fill: %d\n",S->N,S->IA[S->N]);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	push	eax
	push	OFFSET ??_C@_0CC@KNNCMEHI@Variables?3?5?$CFd?5?5Original?5fill?3?5?$CFd@
	call	_printf

; 2105 :     printf("Workspace: %lu bytes\n",(unsigned long)(S->ISP[0]*sizeof(int)));

	mov	edx, DWORD PTR [esi+92]
	mov	eax, DWORD PTR [edx]
	add	eax, eax
	add	eax, eax
	push	eax
	push	OFFSET ??_C@_0BG@PHAAIKMF@Workspace?3?5?$CFlu?5bytes?6?$AA@
	call	_printf

; 2106 :     printf("Passes through main loop: %d\n",passes);

	mov	ecx, DWORD PTR _passes
	push	ecx
	push	OFFSET ??_C@_0BO@NBIMJJFJ@Passes?5through?5main?5loop?3?5?$CFd?6?$AA@
	call	_printf

; 2107 :     printf("Total_fill:  %d\n",total_fill);

	mov	edx, DWORD PTR _total_fill
	push	edx
	push	OFFSET ??_C@_0BB@LPNDPICA@Total_fill?3?5?5?$CFd?6?$AA@
	call	_printf

; 2108 :     printf("Total_flops: %g\n",(DOUBLE)total_flops);

	fld	QWORD PTR _total_flops
	add	esp, 28					; 0000001cH
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BB@DKPLIEML@Total_flops?3?5?$CFg?6?$AA@
	call	_printf
	add	esp, 12					; 0000000cH
$LN1@xmd_factor:
	pop	esi
	pop	ebx

; 2109 :   }
; 2110 : } // end  xmd_factor()

	pop	ebp
	ret	0
_xmd_factor ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@FMGOOMLP@This?5Evolver?5not?5enabled?5for?5MKL@ ; `string'
PUBLIC	_mkl_factor
;	COMDAT ??_C@_0CD@FMGOOMLP@This?5Evolver?5not?5enabled?5for?5MKL@
CONST	SEGMENT
??_C@_0CD@FMGOOMLP@This?5Evolver?5not?5enabled?5for?5MKL@ DB 'This Evolve'
	DB	'r not enabled for MKL.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _mkl_factor
_TEXT	SEGMENT
_S$ = 8							; size = 4
_mtype$ = 12						; size = 4
_mkl_factor PROC					; COMDAT

; 2350 : { kb_error(6010,"This Evolver not enabled for MKL.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CD@FMGOOMLP@This?5Evolver?5not?5enabled?5for?5MKL@
	push	6010					; 0000177aH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2351 : }

	ret	0
_mkl_factor ENDP
_TEXT	ENDS
PUBLIC	_mkl_solve
; Function compile flags: /Ogtp
;	COMDAT _mkl_solve
_TEXT	SEGMENT
_S$ = 8							; size = 4
_b$ = 12						; size = 4
_x$ = 16						; size = 4
_mtype$ = 20						; size = 4
_mkl_solve PROC						; COMDAT

; 2353 : { kb_error(6011,"This Evolver not enabled for MKL.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CD@FMGOOMLP@This?5Evolver?5not?5enabled?5for?5MKL@
	push	6011					; 0000177bH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2354 : }

	ret	0
_mkl_solve ENDP
_TEXT	ENDS
PUBLIC	_mkl_solve_multi
; Function compile flags: /Ogtp
;	COMDAT _mkl_solve_multi
_TEXT	SEGMENT
_S$ = 8							; size = 4
_b$ = 12						; size = 4
_x$ = 16						; size = 4
_nrhs$ = 20						; size = 4
_mtype$ = 24						; size = 4
_mkl_solve_multi PROC					; COMDAT

; 2356 : { kb_error(6012,"This Evolver not enabled for MKL.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CD@FMGOOMLP@This?5Evolver?5not?5enabled?5for?5MKL@
	push	6012					; 0000177cH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2357 : }

	ret	0
_mkl_solve_multi ENDP
_TEXT	ENDS
PUBLIC	_mkl_free
; Function compile flags: /Ogtp
;	COMDAT _mkl_free
_TEXT	SEGMENT
_S$ = 8							; size = 4
_mkl_free PROC						; COMDAT

; 2359 : { kb_error(6013,"This Evolver not enabled for MKL.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CD@FMGOOMLP@This?5Evolver?5not?5enabled?5for?5MKL@
	push	6013					; 0000177dH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 2360 : }

	ret	0
_mkl_free ENDP
_TEXT	ENDS
END
