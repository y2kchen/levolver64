; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\EVALMORE.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

EXTRN	__ctime64:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _ctime
_TEXT	SEGMENT
_ctime	PROC						; COMDAT
; __Time$ = eax

; 88   : #pragma warning( push )
; 89   : #pragma warning( disable : 4996 )
; 90   :     return _ctime64(_Time);

	push	eax
	call	__ctime64
	add	esp, 4

; 91   : #pragma warning( pop )
; 92   : }

	ret	0
_ctime	ENDP
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

	push	eax
	call	__time64
	add	esp, 4

; 134  : }

	ret	0
_time	ENDP
_TEXT	ENDS
PUBLIC	_set_attr
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
;	COMDAT _set_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_set_attr PROC						; COMDAT

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   :   elptr(id)->attr |= attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	or	DWORD PTR [eax+8], ecx
	or	DWORD PTR [eax+12], edx

; 23   : }

	pop	ebp
	ret	0
_set_attr ENDP
_TEXT	ENDS
PUBLIC	_unset_attr
; Function compile flags: /Ogtp
;	COMDAT _unset_attr
_TEXT	SEGMENT
_id$ = 8						; size = 4
_attrib$ = 12						; size = 8
_unset_attr PROC					; COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp

; 29   :   elptr(id)->attr &= ~attrib;

	mov	eax, DWORD PTR _id$[ebp]
	mov	ecx, eax
	shr	ecx, 29					; 0000001dH
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _web[ecx+12]
	mov	ecx, DWORD PTR _attrib$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _attrib$[ebp+4]
	not	ecx
	and	DWORD PTR [eax+8], ecx
	not	edx
	and	DWORD PTR [eax+12], edx

; 30   : }

	pop	ebp
	ret	0
_unset_attr ENDP
_TEXT	ENDS
PUBLIC	_get_fe_edge
; Function compile flags: /Ogtp
;	COMDAT _get_fe_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_edge PROC					; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp

; 44   :   edge_id e_id;
; 45   :     
; 46   :   e_id = feptr(fe_id)->fe_edge_id;

	mov	eax, DWORD PTR _fe_id$[ebp]

; 47   : 
; 48   :   /*
; 49   :   if ( inverted(fe_id) ) invert(e_id);
; 50   :   return e_id;
; 51   :   */
; 52   :   
; 53   :   return same_sign(e_id,fe_id);

	mov	edx, DWORD PTR _web+460
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [ecx+20]

; 54   : }

	pop	ebp
	ret	0
_get_fe_edge ENDP
_TEXT	ENDS
PUBLIC	_get_fe_facet
EXTRN	_NULLFACET:DWORD
; Function compile flags: /Ogtp
;	COMDAT _get_fe_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_fe_facet PROC					; COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp

; 59   :   facet_id f_id;
; 60   :   
; 61   :   if ( !valid_id(fe_id) ) return NULLFACET;

	mov	ecx, DWORD PTR _fe_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_fe_fac
	mov	eax, DWORD PTR _NULLFACET

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
$LN2@get_fe_fac:

; 62   :   f_id = feptr(fe_id)->fe_facet_id;

	mov	edx, DWORD PTR _web+460
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+24]

; 63   :   if ( inverted(fe_id) ) invert(f_id);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_fe_fac
	xor	eax, 134217728				; 08000000H
$LN3@get_fe_fac:

; 64   :   return f_id;
; 65   : }

	pop	ebp
	ret	0
_get_fe_facet ENDP
_TEXT	ENDS
PUBLIC	_get_prev_edge
; Function compile flags: /Ogtp
;	COMDAT _get_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_edge PROC					; COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp

; 70   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[1]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]
	xor	eax, 134217728				; 08000000H

; 72   : }

	pop	ebp
	ret	0
$LN2@get_prev_e:

; 71   :   else return feptr(fe_id)->nextedge[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]

; 72   : }

	pop	ebp
	ret	0
_get_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_get_next_edge
; Function compile flags: /Ogtp
;	COMDAT _get_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_edge PROC					; COMDAT

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   :   if ( inverted(fe_id) ) return inverse_id(feptr(fe_id)->nextedge[0]);

	mov	eax, DWORD PTR _fe_id$[ebp]
	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_e
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+28]
	xor	eax, 134217728				; 08000000H

; 79   : }

	pop	ebp
	ret	0
$LN2@get_next_e:

; 78   :   else return feptr(fe_id)->nextedge[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+32]

; 79   : }

	pop	ebp
	ret	0
_get_next_edge ENDP
_TEXT	ENDS
PUBLIC	_get_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _get_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_prev_facet PROC					; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp

; 84   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 85   :     return inverse_id(feptr(fe_id)->nextfacet[1]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_prev_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]
	xor	eax, 134217728				; 08000000H

; 88   : }

	pop	ebp
	ret	0
$LN2@get_prev_f:

; 86   :   else 
; 87   :     return feptr(fe_id)->nextfacet[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]

; 88   : }

	pop	ebp
	ret	0
_get_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_get_next_facet
; Function compile flags: /Ogtp
;	COMDAT _get_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_get_next_facet PROC					; COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp

; 93   :   if ( inverted(fe_id) ) 

	mov	eax, DWORD PTR _fe_id$[ebp]

; 94   :     return inverse_id(feptr(fe_id)->nextfacet[0]);

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_next_f
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H

; 97   : }

	pop	ebp
	ret	0
$LN2@get_next_f:

; 95   :   else 
; 96   :     return feptr(fe_id)->nextfacet[1];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]

; 97   : }

	pop	ebp
	ret	0
_get_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_prev_edge
EXTRN	_top_timestamp:DWORD
EXTRN	_global_timestamp:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_prev_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_edge PROC					; COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp

; 103  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_e

; 104  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_e

; 105  :     { invert(fe);
; 106  :       feptr(fe_id)->nextedge[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+32], ecx

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 111  : }

	pop	ebp
	ret	0
$LN2@set_prev_e:

; 107  :     }
; 108  :   else
; 109  :       feptr(fe_id)->nextedge[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 110  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_e:

; 111  : }

	pop	ebp
	ret	0
_set_prev_edge ENDP
_TEXT	ENDS
PUBLIC	_set_next_edge
; Function compile flags: /Ogtp
;	COMDAT _set_next_edge
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_next_edge PROC					; COMDAT

; 116  : {

	push	ebp
	mov	ebp, esp

; 117  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_next_e

; 118  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_next_e

; 119  :     { invert(fe);

	mov	ecx, DWORD PTR _fe$[ebp]

; 120  :       feptr(fe_id)->nextedge[0] = fe;

	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+28], ecx

; 124  : }

	pop	ebp
	ret	0
$LN2@set_next_e:

; 121  :     }
; 122  :   else
; 123  :       feptr(fe_id)->nextedge[1] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN1@set_next_e:

; 124  : }

	pop	ebp
	ret	0
_set_next_edge ENDP
_TEXT	ENDS
PUBLIC	_set_prev_facet
; Function compile flags: /Ogtp
;	COMDAT _set_prev_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_prev_facet PROC					; COMDAT

; 129  : {

	push	ebp
	mov	ebp, esp

; 130  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@set_prev_f

; 131  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_prev_f

; 132  :   { invert(fe);
; 133  :     feptr(fe_id)->nextfacet[1] = fe;

	mov	edx, DWORD PTR _web+460
	mov	ecx, DWORD PTR _fe$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	xor	ecx, 134217728				; 08000000H
	mov	DWORD PTR [eax+40], ecx

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 138  : }

	pop	ebp
	ret	0
$LN2@set_prev_f:

; 134  :   }
; 135  :   else
; 136  :     feptr(fe_id)->nextfacet[0] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+36], eax

; 137  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax
$LN4@set_prev_f:

; 138  : }

	pop	ebp
	ret	0
_set_prev_facet ENDP
_TEXT	ENDS
PUBLIC	_set_next_facet
; Function compile flags: /Ogtp
;	COMDAT _set_next_facet
_TEXT	SEGMENT
_fe_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_next_facet PROC					; COMDAT

; 143  : {

	push	ebp
	mov	ebp, esp

; 144  :   if ( !valid_id(fe_id) ) return;

	mov	eax, DWORD PTR _fe_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_next_f

; 145  :   if ( inverted(fe_id) )

	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@set_next_f

; 146  :   { invert(fe);

	mov	ecx, DWORD PTR _fe$[ebp]

; 147  :     feptr(fe_id)->nextfacet[0] = fe;

	mov	edx, DWORD PTR _web+460
	xor	ecx, 134217728				; 08000000H
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+36], ecx

; 151  : }

	pop	ebp
	ret	0
$LN2@set_next_f:

; 148  :   }
; 149  :   else
; 150  :     feptr(fe_id)->nextfacet[1] = fe;

	mov	ecx, DWORD PTR _web+460
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+40], eax
$LN1@set_next_f:

; 151  : }

	pop	ebp
	ret	0
_set_next_facet ENDP
_TEXT	ENDS
PUBLIC	_set_edge_wrap
EXTRN	_dymem:DWORD
EXTRN	_sym_inverse:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_edge_wrap
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_wrap$ = 12						; size = 4
_set_edge_wrap PROC					; COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp

; 158  :  *EINT(e_id,E_WRAP_ATTR) =  inverted(e_id)  ? (*sym_inverse)(wrap) : wrap ;

	mov	eax, DWORD PTR _wrap$[ebp]
	push	esi
	mov	esi, DWORD PTR _e_id$[ebp]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN4@set_edge_w
	push	eax
	call	DWORD PTR _sym_inverse
	add	esp, 4
$LN4@set_edge_w:
	mov	ecx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR _dymem
	mov	ecx, DWORD PTR _web+216
	mov	ecx, DWORD PTR [ecx+esi+784]
	mov	DWORD PTR [edx+ecx], eax
	pop	esi

; 159  : }

	pop	ebp
	ret	0
_set_edge_wrap ENDP
_TEXT	ENDS
PUBLIC	_set_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _set_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_fe$ = 12						; size = 4
_set_edge_fe PROC					; COMDAT

; 171  : {

	push	ebp
	mov	ebp, esp

; 172  :   if ( inverted(e_id) ) invert(fe);

	mov	eax, DWORD PTR _e_id$[ebp]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN1@set_edge_f
	xor	DWORD PTR _fe$[ebp], 134217728		; 08000000H
$LN1@set_edge_f:

; 173  :   eptr(e_id)->fe_id = fe;

	mov	ecx, DWORD PTR _web+124
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _fe$[ebp]
	mov	DWORD PTR [edx+28], eax

; 174  :   top_timestamp = ++global_timestamp;

	mov	eax, DWORD PTR _global_timestamp
	inc	eax
	mov	DWORD PTR _global_timestamp, eax
	mov	DWORD PTR _top_timestamp, eax

; 175  : }

	pop	ebp
	ret	0
_set_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_fe
; Function compile flags: /Ogtp
;	COMDAT _get_edge_fe
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_fe PROC					; COMDAT

; 179  : {   struct edge *ep;

	push	ebp
	mov	ebp, esp

; 180  :     facetedge_id fe;
; 181  : 
; 182  :  	ep = eptr(e_id);

	mov	ecx, DWORD PTR _e_id$[ebp]
	mov	edx, DWORD PTR _web+124
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]

; 183  :     if ( !ep ) return NULLID;

	test	eax, eax
	jne	SHORT $LN2@get_edge_f

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
$LN2@get_edge_f:

; 184  :     fe = ep->fe_id; 

	mov	eax, DWORD PTR [eax+28]

; 185  :     if ( inverted(e_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_edge_f
	xor	eax, 134217728				; 08000000H
$LN3@get_edge_f:

; 186  :     return fe;
; 187  : }

	pop	ebp
	ret	0
_get_edge_fe ENDP
_TEXT	ENDS
PUBLIC	_get_edge_tailv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_tailv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_tailv PROC					; COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp

; 192  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 193  :      return get_edge_vertices(e_id)[web.headvnum];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_t
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 196  : }

	pop	ebp
	ret	0
$LN2@get_edge_t:

; 194  :   else
; 195  :      return get_edge_vertices(e_id)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 196  : }

	pop	ebp
	ret	0
_get_edge_tailv ENDP
_TEXT	ENDS
PUBLIC	_get_edge_headv
; Function compile flags: /Ogtp
;	COMDAT _get_edge_headv
_TEXT	SEGMENT
_e_id$ = 8						; size = 4
_get_edge_headv PROC					; COMDAT

; 200  : {

	push	ebp
	mov	ebp, esp

; 201  :   if ( inverted(e_id) )

	mov	eax, DWORD PTR _e_id$[ebp]

; 202  :      return get_edge_vertices(e_id)[0];

	mov	ecx, DWORD PTR _web+124
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_edge_h
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR [edx+eax]

; 205  : }

	pop	ebp
	ret	0
$LN2@get_edge_h:

; 203  :   else
; 204  :      return get_edge_vertices(e_id)[web.headvnum];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+216
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [eax+ecx+304]
	mov	eax, DWORD PTR _web+636
	mov	eax, DWORD PTR [edx+eax*4]

; 205  : }

	pop	ebp
	ret	0
_get_edge_headv ENDP
_TEXT	ENDS
PUBLIC	_get_facet_body
; Function compile flags: /Ogtp
;	COMDAT _get_facet_body
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_body PROC					; COMDAT

; 250  : {

	push	ebp
	mov	ebp, esp

; 251  :   if ( web.skel[BODY].count == 0 ) return NULLID;

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN4@get_facet_
$LN7@get_facet_:
	xor	eax, eax

; 255  : }

	pop	ebp
	ret	0
$LN4@get_facet_:

; 252  :   if ( !valid_id(f_id) ) return NULLID;

	mov	eax, DWORD PTR _f_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN7@get_facet_

; 253  :   if ( inverted(f_id) ) return F_ELID(f_id,F_BODY_LIST_ATTR)[1];

	mov	ecx, DWORD PTR _web+236
	test	eax, 134217728				; 08000000H
	je	SHORT $LN2@get_facet_
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax+4]

; 255  : }

	pop	ebp
	ret	0
$LN2@get_facet_:

; 254  :   else  return F_ELID(f_id,F_BODY_LIST_ATTR)[0];

	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _web+328
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+784]
	mov	eax, DWORD PTR [edx+eax]

; 255  : }

	pop	ebp
	ret	0
_get_facet_body ENDP
_TEXT	ENDS
PUBLIC	_get_facet_fe
; Function compile flags: /Ogtp
;	COMDAT _get_facet_fe
_TEXT	SEGMENT
_f_id$ = 8						; size = 4
_get_facet_fe PROC					; COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp

; 261  :   facetedge_id fe;
; 262  :   
; 263  :   if ( !valid_id(f_id) ) return NULLID;

	mov	ecx, DWORD PTR _f_id$[ebp]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN2@get_facet_@2
	xor	eax, eax

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
$LN2@get_facet_@2:

; 264  :   fe = fptr(f_id)->fe_id;

	mov	edx, DWORD PTR _web+236
	mov	eax, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+28]

; 265  :   if ( inverted(f_id) ) invert(fe);

	test	ecx, 134217728				; 08000000H
	je	SHORT $LN3@get_facet_@2
	xor	eax, 134217728				; 08000000H
$LN3@get_facet_@2:

; 266  :   return fe;
; 267  : }

	pop	ebp
	ret	0
_get_facet_fe ENDP
_TEXT	ENDS
PUBLIC	_get_body_facet
; Function compile flags: /Ogtp
;	COMDAT _get_body_facet
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_facet PROC					; COMDAT

; 279  : { return ( valid_id(b_id) ? bptr(b_id)->f_id : NULLID ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_f
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+400]
	pop	ebp
	ret	0
$LN3@get_body_f:
	xor	eax, eax
	pop	ebp
	ret	0
_get_body_facet ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_get_body_density
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_body_density
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_density PROC					; COMDAT

; 305  :     { return  ( valid_id(b_id) ?  bptr(b_id)->density : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_d
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+344]
	pop	ebp
	ret	0
$LN3@get_body_d:
	fldz
	pop	ebp
	ret	0
_get_body_density ENDP
_TEXT	ENDS
PUBLIC	_get_body_volume
; Function compile flags: /Ogtp
;	COMDAT _get_body_volume
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_volume PROC					; COMDAT

; 308  :     { return    ( valid_id(b_id) ?  bptr(b_id)->volume : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_v
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+40]
	pop	ebp
	ret	0
$LN3@get_body_v:
	fldz
	pop	ebp
	ret	0
_get_body_volume ENDP
_TEXT	ENDS
PUBLIC	_get_body_fixvol
; Function compile flags: /Ogtp
;	COMDAT _get_body_fixvol
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_fixvol PROC					; COMDAT

; 311  :      { return ( valid_id(b_id) ?  bptr(b_id)->fixvol : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_f@2
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+32]
	pop	ebp
	ret	0
$LN3@get_body_f@2:
	fldz
	pop	ebp
	ret	0
_get_body_fixvol ENDP
_TEXT	ENDS
PUBLIC	_get_body_pressure
; Function compile flags: /Ogtp
;	COMDAT _get_body_pressure
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_pressure PROC					; COMDAT

; 317  :     { return  ( valid_id(b_id) ?    bptr(b_id)->pressure : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_p
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+312]
	pop	ebp
	ret	0
$LN3@get_body_p:
	fldz
	pop	ebp
	ret	0
_get_body_pressure ENDP
_TEXT	ENDS
PUBLIC	_get_body_volconst
; Function compile flags: /Ogtp
;	COMDAT _get_body_volconst
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_get_body_volconst PROC					; COMDAT

; 320  :   { return    ( valid_id(b_id) ?  bptr(b_id)->volconst : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@get_body_v@2
	mov	ecx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fld	QWORD PTR [edx+328]
	pop	ebp
	ret	0
$LN3@get_body_v@2:
	fldz
	pop	ebp
	ret	0
_get_body_volconst ENDP
_TEXT	ENDS
PUBLIC	_set_body_density
; Function compile flags: /Ogtp
;	COMDAT _set_body_density
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_set_body_density PROC					; COMDAT

; 323  :       {         ( valid_id(b_id) ?  bptr(b_id)->density = (v) : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@set_body_d
	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [edx+344]
$LN3@set_body_d:
	pop	ebp
	ret	0
_set_body_density ENDP
_TEXT	ENDS
PUBLIC	_set_body_pressure
; Function compile flags: /Ogtp
;	COMDAT _set_body_pressure
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_set_body_pressure PROC					; COMDAT

; 326  :       {         ( valid_id(b_id) ?  bptr(b_id)->pressure = (v) : 0.0 ) ; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN3@set_body_p
	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	fstp	QWORD PTR [edx+312]
$LN3@set_body_p:
	pop	ebp
	ret	0
_set_body_pressure ENDP
_TEXT	ENDS
PUBLIC	_set_body_volconst
EXTRN	_gen_quant_list:DWORD
EXTRN	_everything_quantities_flag:DWORD
; Function compile flags: /Ogtp
;	COMDAT _set_body_volconst
_TEXT	SEGMENT
_b_id$ = 8						; size = 4
_v$ = 12						; size = 8
_set_body_volconst PROC					; COMDAT

; 329  : { if ( !valid_id(b_id) ) return;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _b_id$[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@set_body_v

; 330  :   bptr(b_id)->volconst = v;

	mov	ecx, DWORD PTR _web+348
	fld	QWORD PTR _v$[ebp]
	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	add	eax, eax
	mov	edx, DWORD PTR [eax+ecx]
	fst	QWORD PTR [edx+328]

; 331  :   if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN6@set_body_v

; 332  :   { struct gen_quant *q = GEN_QUANT(get_body_volquant(b_id));

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, DWORD PTR [edx+404]

; 333  :     q->volconst = v;

	mov	ecx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H
	fstp	QWORD PTR [eax+ecx+208]

; 334  :   }
; 335  : }

	pop	ebp
	ret	0
$LN6@set_body_v:

; 333  :     q->volconst = v;

	fstp	ST(0)
$LN1@set_body_v:

; 334  :   }
; 335  : }

	pop	ebp
	ret	0
_set_body_volconst ENDP
_TEXT	ENDS
PUBLIC	_get_extra
; Function compile flags: /Ogtp
;	COMDAT _get_extra
_TEXT	SEGMENT
_id$ = 8						; size = 4
_n$ = 12						; size = 4
_get_extra PROC						; COMDAT

; 348  : { int type = id_type(id);

	push	ebp
	mov	ebp, esp

; 349  : 
; 350  :   return ( (char*)elptr(id) + EXTRAS(type)[n].offset);

	mov	ecx, DWORD PTR _id$[ebp]
	mov	eax, ecx
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	shr	eax, 29					; 0000001dH
	imul	esi, 240				; 000000f0H
	imul	eax, 112				; 00000070H
	mov	edx, DWORD PTR _web[eax+12]
	push	edi
	mov	edi, DWORD PTR _web[eax+104]
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	add	edi, esi
	add	eax, DWORD PTR [edi+ecx+64]
	pop	edi
	pop	esi

; 351  : }

	pop	ebp
	ret	0
_get_extra ENDP
_TEXT	ENDS
EXTRN	__stat64i32:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\sys\stat.inl
;	COMDAT _stat
_TEXT	SEGMENT
_stat	PROC						; COMDAT
; __Filename$ = ecx
; __Stat$ = eax

; 58   :     _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat64i32) );
; 59   :     return _stat64i32(_Filename,(struct _stat64i32 *)_Stat);

	push	eax
	push	ecx
	call	__stat64i32
	add	esp, 8

; 60   : }

	ret	0
_stat	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@	; `string'
PUBLIC	??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@	; `string'
PUBLIC	??_C@_0O@JOCJHGPD@?5?$CIwas?5unset?$CJ?6?$AA@	; `string'
PUBLIC	??_C@_05FCFNGLEN@?5OFF?4?$AA@			; `string'
PUBLIC	??_C@_04EKGIMGGL@?5ON?4?$AA@			; `string'
PUBLIC	_flip_toggle
EXTRN	_outstring:PROC
;	COMDAT ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\evalmore.c
CONST	SEGMENT
??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@ DB ' (was on)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@ DB ' (was off)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JOCJHGPD@?5?$CIwas?5unset?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0O@JOCJHGPD@?5?$CIwas?5unset?$CJ?6?$AA@ DB ' (was unset)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05FCFNGLEN@?5OFF?4?$AA@
CONST	SEGMENT
??_C@_05FCFNGLEN@?5OFF?4?$AA@ DB ' OFF.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EKGIMGGL@?5ON?4?$AA@
CONST	SEGMENT
??_C@_04EKGIMGGL@?5ON?4?$AA@ DB ' ON.', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _flip_toggle
_TEXT	SEGMENT
_flag$ = 8						; size = 4
_newstate$ = 12						; size = 4
_phrase$ = 16						; size = 4
_flip_toggle PROC					; COMDAT

; 2894 : { int old;

	push	ebp
	mov	ebp, esp

; 2895 :   old = *flag;
; 2896 :   *flag = (newstate==ON_) ? 1 : 0;
; 2897 :   outstring(phrase);

	mov	ecx, DWORD PTR _phrase$[ebp]
	xor	eax, eax
	cmp	DWORD PTR _newstate$[ebp], 15000	; 00003a98H
	push	esi
	mov	esi, DWORD PTR _flag$[ebp]
	sete	al
	push	edi
	mov	edi, DWORD PTR [esi]
	push	ecx
	mov	DWORD PTR [esi], eax
	call	_outstring
	add	esp, 4

; 2898 :   outstring(*flag ? " ON." : " OFF.");

	cmp	DWORD PTR [esi], 0
	mov	eax, OFFSET ??_C@_04EKGIMGGL@?5ON?4?$AA@
	jne	SHORT $LN8@flip_toggl
	mov	eax, OFFSET ??_C@_05FCFNGLEN@?5OFF?4?$AA@
$LN8@flip_toggl:
	push	eax
	call	_outstring
	add	esp, 4

; 2899 :   if ( old < 0 ) outstring(" (was unset)\n");

	test	edi, edi
	jns	SHORT $LN9@flip_toggl
	push	OFFSET ??_C@_0O@JOCJHGPD@?5?$CIwas?5unset?$CJ?6?$AA@

; 2901 :   else outstring(" (was on)\n");

	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi

; 2902 : } // end flip_toggle()

	pop	ebp
	ret	0
$LN9@flip_toggl:

; 2900 :   else if ( old == 0 ) outstring(" (was off)\n");

	jne	SHORT $LN2@flip_toggl
	push	OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@

; 2901 :   else outstring(" (was on)\n");

	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi

; 2902 : } // end flip_toggle()

	pop	ebp
	ret	0
$LN2@flip_toggl:

; 2901 :   else outstring(" (was on)\n");

	push	OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi

; 2902 : } // end flip_toggle()

	pop	ebp
	ret	0
_flip_toggle ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@FBPIKPGM@Internal?5error?3?5?5Toggle?5value?5om@ ; `string'
PUBLIC	_get_toggle_value
EXTRN	_kb_error:PROC
EXTRN	_sprintf:PROC
EXTRN	_errmsg:BYTE
EXTRN	_rgb_colors_flag:DWORD
EXTRN	_little_endian_flag:DWORD
EXTRN	_big_endian_flag:DWORD
EXTRN	_quantity_function_sparse_flag:DWORD
EXTRN	_verbose_flag:DWORD
EXTRN	_augmented_hessian_flag:DWORD
EXTRN	_break_on_warning:DWORD
EXTRN	_break_after_warning:DWORD
EXTRN	_blas_flag:DWORD
EXTRN	_sparse_constraints_flag:DWORD
EXTRN	_visibility_test:DWORD
EXTRN	_quantities_only_flag:DWORD
EXTRN	_show_all_quantities:DWORD
EXTRN	_labelflag:DWORD
EXTRN	_crossingflag:DWORD
EXTRN	_edgeshow_flag:DWORD
EXTRN	_box_flag:DWORD
EXTRN	_septum_flag:DWORD
EXTRN	_force_edgeswap_flag:DWORD
EXTRN	_gridflag:DWORD
EXTRN	_ps_cmykflag:DWORD
EXTRN	_ps_colorflag:DWORD
EXTRN	_interp_bdry_param:DWORD
EXTRN	_hessian_double_normal_flag:DWORD
EXTRN	_hessian_normal_one_flag:DWORD
EXTRN	_hessian_normal_perp_flag:DWORD
EXTRN	_hessian_special_normal_flag:DWORD
EXTRN	_hessian_normal_flag:DWORD
EXTRN	_K_altitude_flag:DWORD
EXTRN	_kraynikpopedge_flag:DWORD
EXTRN	_kraynikpopvertex_flag:DWORD
EXTRN	_sobolev_flag:DWORD
EXTRN	_dirichlet_flag:DWORD
EXTRN	_assume_oriented_flag:DWORD
EXTRN	_ribiere_flag:DWORD
EXTRN	_go_display_flag:DWORD
EXTRN	_self_similar_flag:DWORD
EXTRN	_gv_binary_flag:DWORD
EXTRN	_make_pos_def_flag:DWORD
EXTRN	_autorecalc_flag:DWORD
EXTRN	_view_4D_flag:DWORD
EXTRN	_check_pinning_flag:DWORD
EXTRN	_normal_motion_flag:DWORD
EXTRN	_boundary_curvature_flag:DWORD
EXTRN	_color_flag:DWORD
EXTRN	_shading_flag:DWORD
EXTRN	_div_normal_curvature_flag:DWORD
EXTRN	_normal_curvature_flag:DWORD
EXTRN	_mean_curv_int_flag:DWORD
EXTRN	_post_project_flag:DWORD
EXTRN	_hessian_by_diff_flag:DWORD
EXTRN	_colorflag:DWORD
EXTRN	_outerflag:DWORD
EXTRN	_innerflag:DWORD
EXTRN	_BK_flag:DWORD
EXTRN	_metric_convert_flag:DWORD
EXTRN	_hessian_linear_metric_flag:DWORD
EXTRN	_ysmp_flag:DWORD
EXTRN	_thickenflag:DWORD
EXTRN	_effective_area_flag:DWORD
EXTRN	_conf_edge_curv_flag:DWORD
EXTRN	_transforms_flag:DWORD
EXTRN	_conj_grad_flag:DWORD
EXTRN	_check_increase_flag:DWORD
EXTRN	_runge_kutta_flag:DWORD
EXTRN	_approx_curve_flag:DWORD
EXTRN	_old_area_flag:DWORD
EXTRN	_quiet_load_flag:DWORD
EXTRN	_quiet_go_flag:DWORD
EXTRN	_hessian_quiet_flag:DWORD
EXTRN	_quiet_flag:DWORD
EXTRN	_autochop_flag:DWORD
EXTRN	_autopop_quartic_flag:DWORD
EXTRN	_immediate_autopop_flag:DWORD
EXTRN	_autopop_flag:DWORD
EXTRN	_sqgauss_flag:DWORD
EXTRN	_clip_view_flag:DWORD
EXTRN	_slice_view_flag:DWORD
EXTRN	_unit_normal_flag:DWORD
EXTRN	_estimate_flag:DWORD
EXTRN	_kusner_flag:DWORD
EXTRN	_volgrads_every_flag:DWORD
EXTRN	_backcull_flag:DWORD
EXTRN	_zener_drag_flag:DWORD
EXTRN	_mpi_local_bodies_flag:DWORD
EXTRN	_mpi_debug:DWORD
EXTRN	_pop_to_face_flag:DWORD
EXTRN	_pop_to_edge_flag:DWORD
EXTRN	_pop_enjoin_flag:DWORD
EXTRN	_pop_disjoin_flag:DWORD
EXTRN	_full_bounding_box_flag:DWORD
EXTRN	_smooth_graph_flag:DWORD
EXTRN	_bezier_flag:DWORD
EXTRN	_detorus_sticky:DWORD
EXTRN	_view_transforms_unique_point_flag:DWORD
EXTRN	_geomview_flag:DWORD
EXTRN	_logfile_flag:DWORD
EXTRN	_itdebug:DWORD
EXTRN	_memdebug:DWORD
EXTRN	_yydebug:DWORD
;	COMDAT ??_C@_0DG@FBPIKPGM@Internal?5error?3?5?5Toggle?5value?5om@
CONST	SEGMENT
??_C@_0DG@FBPIKPGM@Internal?5error?3?5?5Toggle?5value?5om@ DB 'Internal e'
	DB	'rror:  Toggle value omitted for toggle %d.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_toggle_value
_TEXT	SEGMENT
_tog$ = 8						; size = 4
_get_toggle_value PROC					; COMDAT

; 5363 : {

	push	ebp
	mov	ebp, esp

; 5364 :   switch (tog)

	mov	eax, DWORD PTR _tog$[ebp]
	cmp	eax, 10519				; 00002917H
	jg	SHORT $LN125@get_toggle
	je	SHORT $LN101@get_toggle
	cmp	eax, 10489				; 000028f9H
	jg	SHORT $LN126@get_toggle
	je	SHORT $LN77@get_toggle
	mov	ecx, eax
	sub	ecx, 10010				; 0000271aH
	je	SHORT $LN99@get_toggle
	dec	ecx
	je	SHORT $LN98@get_toggle
	dec	ecx
	jne	$LN1@get_toggle

; 5387 :        case LAGRANGE_NODE: return (web.modeltype == LAGRANGE);

	xor	eax, eax
	cmp	DWORD PTR _web+628, 3
	sete	al

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN98@get_toggle:

; 5386 :        case QUADRATIC_NODE: return (web.modeltype == QUADRATIC);

	xor	eax, eax
	cmp	DWORD PTR _web+628, 2
	sete	al

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN99@get_toggle:

; 5384 :        case KEYLOGFILE_NODE: return logfile_flag;
; 5385 :        case LINEAR_NODE: return (web.modeltype == LINEAR);

	xor	eax, eax
	cmp	DWORD PTR _web+628, 1
	sete	al

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN77@get_toggle:

; 5407 :        case DEBUG_NODE: return yydebug; 

	mov	eax, DWORD PTR _yydebug

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN126@get_toggle:

; 5364 :   switch (tog)

	mov	ecx, eax
	sub	ecx, 10490				; 000028faH
	je	SHORT $LN45@get_toggle
	dec	ecx
	jne	$LN1@get_toggle

; 5438 :        case MEMDEBUG_NODE: return memdebug; 

	mov	eax, DWORD PTR _memdebug

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN45@get_toggle:

; 5439 :        case ITDEBUG_NODE: return itdebug; 

	mov	eax, DWORD PTR _itdebug

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN101@get_toggle:

; 5383 :        case LOGFILE_NODE: return logfile_flag;

	mov	eax, DWORD PTR _logfile_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN125@get_toggle:

; 5364 :   switch (tog)

	lea	ecx, DWORD PTR [eax-10520]
	cmp	ecx, 235				; 000000ebH
	ja	$LN1@get_toggle
	movzx	ecx, BYTE PTR $LN127@get_toggle[ecx]
	jmp	DWORD PTR $LN128@get_toggle[ecx*4]
$LN118@get_toggle:

; 5365 :     {  case GEOMVIEW_NODE: return geomview_flag; 

	mov	eax, DWORD PTR _geomview_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN117@get_toggle:

; 5366 :        case VIEW_TRANSFORMS_USE_UNIQUE_NODE: 
; 5367 :              return view_transforms_unique_point_flag;

	mov	eax, DWORD PTR _view_transforms_unique_point_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN116@get_toggle:

; 5368 :        case DETORUS_STICKY_NODE: return detorus_sticky;

	mov	eax, DWORD PTR _detorus_sticky

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN115@get_toggle:

; 5369 :        case BEZIER_BASIS_NODE: return bezier_flag;

	mov	eax, DWORD PTR _bezier_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN114@get_toggle:

; 5370 :        case SMOOTH_GRAPH_NODE: return smooth_graph_flag;

	mov	eax, DWORD PTR _smooth_graph_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN113@get_toggle:

; 5371 :        case FULL_BOUNDING_BOX_NODE: return full_bounding_box_flag;

	mov	eax, DWORD PTR _full_bounding_box_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN112@get_toggle:

; 5372 :        case POP_DISJOIN_NODE: return pop_disjoin_flag;

	mov	eax, DWORD PTR _pop_disjoin_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN111@get_toggle:

; 5373 :        case POP_ENJOIN_NODE: return pop_enjoin_flag;

	mov	eax, DWORD PTR _pop_enjoin_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN110@get_toggle:

; 5374 :        case POP_TO_EDGE_NODE: return pop_to_edge_flag;

	mov	eax, DWORD PTR _pop_to_edge_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN109@get_toggle:

; 5375 :        case POP_TO_FACE_NODE: return pop_to_face_flag;

	mov	eax, DWORD PTR _pop_to_face_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN108@get_toggle:

; 5376 :        case MPI_DEBUG_NODE: return mpi_debug;

	mov	eax, DWORD PTR _mpi_debug

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN107@get_toggle:

; 5377 :        case MPI_LOCAL_BODIES_NODE: return mpi_local_bodies_flag; 

	mov	eax, DWORD PTR _mpi_local_bodies_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN106@get_toggle:

; 5378 :        case AMBIENT_PRESSURE_NODE: return web.pressure_flag;

	mov	eax, DWORD PTR _web+868

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN105@get_toggle:

; 5379 :        case ZENER_DRAG_NODE: return zener_drag_flag;

	mov	eax, DWORD PTR _zener_drag_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN104@get_toggle:

; 5380 :        case BACKCULL_NODE: return backcull_flag;

	mov	eax, DWORD PTR _backcull_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN103@get_toggle:

; 5381 :        case TORUS_FILLED_NODE: return web.full_flag;

	mov	eax, DWORD PTR _web+864

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN102@get_toggle:

; 5382 :        case VOLGRADS_EVERY_NODE: return volgrads_every_flag;

	mov	eax, DWORD PTR _volgrads_every_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN96@get_toggle:

; 5388 :        case KUSNER_NODE: return kusner_flag; 

	mov	eax, DWORD PTR _kusner_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN95@get_toggle:

; 5389 :        case ESTIMATE_NODE: return estimate_flag;

	mov	eax, DWORD PTR _estimate_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN94@get_toggle:

; 5390 :        case DETURCK_NODE: return unit_normal_flag;

	mov	eax, DWORD PTR _unit_normal_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN93@get_toggle:

; 5391 :        case HOMOTHETY_NODE: return web.homothety;

	mov	eax, DWORD PTR _web+904

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN92@get_toggle:

; 5392 :        case SLICE_VIEW_NODE: return slice_view_flag; 

	mov	eax, DWORD PTR _slice_view_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN91@get_toggle:

; 5393 :        case CLIP_VIEW_NODE: return clip_view_flag; 

	mov	eax, DWORD PTR _clip_view_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN90@get_toggle:

; 5394 :        case SQGAUSS_NODE: return sqgauss_flag; 

	mov	eax, DWORD PTR _sqgauss_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN89@get_toggle:

; 5395 :        case AUTOPOP_NODE: return autopop_flag;

	mov	eax, DWORD PTR _autopop_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN88@get_toggle:

; 5396 :        case IMMEDIATE_AUTOPOP_NODE: return immediate_autopop_flag;

	mov	eax, DWORD PTR _immediate_autopop_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN87@get_toggle:

; 5397 :        case AUTOPOP_QUARTIC_NODE: return autopop_quartic_flag;

	mov	eax, DWORD PTR _autopop_quartic_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN86@get_toggle:

; 5398 :        case AUTOCHOP_NODE: return autochop_flag;

	mov	eax, DWORD PTR _autochop_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN85@get_toggle:

; 5399 :        case QUIET_NODE: return quiet_flag; 

	mov	eax, DWORD PTR _quiet_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN84@get_toggle:

; 5400 :        case HESSIAN_QUIET_NODE: return hessian_quiet_flag; 

	mov	eax, DWORD PTR _hessian_quiet_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN83@get_toggle:

; 5401 :        case QUIETGO_NODE: return quiet_go_flag; 

	mov	eax, DWORD PTR _quiet_go_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN82@get_toggle:

; 5402 :        case QUIETLOAD_NODE: return quiet_load_flag; 

	mov	eax, DWORD PTR _quiet_load_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN81@get_toggle:

; 5403 :        case OLD_AREA_NODE: return old_area_flag;

	mov	eax, DWORD PTR _old_area_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN80@get_toggle:

; 5404 :        case APPROX_CURV_NODE: return approx_curve_flag;

	mov	eax, DWORD PTR _approx_curve_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN79@get_toggle:

; 5405 :        case RUNGE_KUTTA_NODE: return runge_kutta_flag; 

	mov	eax, DWORD PTR _runge_kutta_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN78@get_toggle:

; 5406 :        case CHECK_INCREASE_NODE: return check_increase_flag; 

	mov	eax, DWORD PTR _check_increase_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN76@get_toggle:

; 5408 :        case MEAN_CURV_NODE: return web.area_norm_flag; 

	mov	eax, DWORD PTR _web+876

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN75@get_toggle:

; 5409 :        case DIFFUSION_NODE: return web.diffusion_flag; 

	mov	eax, DWORD PTR _web+780

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN74@get_toggle:

; 5410 :        case GRAVITY_NODE: return web.gravflag; 

	mov	eax, DWORD PTR _web+824

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN73@get_toggle:

; 5411 :        case CONJ_GRAD_NODE: return conj_grad_flag; 

	mov	eax, DWORD PTR _conj_grad_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN72@get_toggle:

; 5412 :        case TRANSFORMS_NODE: return transforms_flag; 

	mov	eax, DWORD PTR _transforms_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN71@get_toggle:

; 5413 :        case CONF_EDGE_SQCURV_NODE: return conf_edge_curv_flag; 

	mov	eax, DWORD PTR _conf_edge_curv_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN70@get_toggle:

; 5414 :        case EFFECTIVE_AREA_NODE: return effective_area_flag; 

	mov	eax, DWORD PTR _effective_area_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN69@get_toggle:

; 5415 :        case RAW_CELLS_NODE: return !web.torus_body_flag && !web.torus_clip_flag; 

	cmp	DWORD PTR _web+804, 0
	jne	$LN123@get_toggle
	cmp	DWORD PTR _web+800, 0
	jne	$LN123@get_toggle
	mov	eax, 1

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN68@get_toggle:

; 5416 :        case CONNECTED_CELLS_NODE: return web.torus_body_flag; 

	mov	eax, DWORD PTR _web+804

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN67@get_toggle:

; 5417 :        case CLIPPED_CELLS_NODE: return web.torus_clip_flag; 

	mov	eax, DWORD PTR _web+800

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN66@get_toggle:

; 5418 :        case THICKEN_NODE: return thickenflag; 

	mov	eax, DWORD PTR _thickenflag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN65@get_toggle:

; 5419 :        case YSMP_NODE: return ysmp_flag; 

	mov	eax, DWORD PTR _ysmp_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN64@get_toggle:

; 5420 :        case LINEAR_METRIC_NODE: return hessian_linear_metric_flag; 

	mov	eax, DWORD PTR _hessian_linear_metric_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN63@get_toggle:

; 5421 :        case METRIC_CONVERT_NODE: return metric_convert_flag; 

	mov	eax, DWORD PTR _metric_convert_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN62@get_toggle:

; 5422 :        case BUNCH_KAUFMAN_NODE: return BK_flag; 

	mov	eax, DWORD PTR _BK_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN61@get_toggle:

; 5423 :        case SHOW_INNER_NODE: return innerflag; 

	mov	eax, DWORD PTR _innerflag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN60@get_toggle:

; 5424 :        case SHOW_OUTER_NODE: return outerflag; 

	mov	eax, DWORD PTR _outerflag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN59@get_toggle:

; 5425 :        case COLORMAP_NODE: return colorflag; 

	mov	eax, DWORD PTR _colorflag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN58@get_toggle:

; 5426 :        case HESSIAN_DIFF_NODE: return hessian_by_diff_flag; 

	mov	eax, DWORD PTR _hessian_by_diff_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN57@get_toggle:

; 5427 :        case POST_PROJECT_NODE: return post_project_flag; 

	mov	eax, DWORD PTR _post_project_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN56@get_toggle:

; 5428 :        case MEAN_CURV_INT_NODE: return mean_curv_int_flag; 

	mov	eax, DWORD PTR _mean_curv_int_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN55@get_toggle:

; 5429 :        case OPTIMIZE_NODE: return !web.motion_flag; 

	xor	eax, eax
	cmp	DWORD PTR _web+852, eax
	sete	al

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN54@get_toggle:

; 5430 :        case NORMAL_CURVATURE_NODE: return normal_curvature_flag; 

	mov	eax, DWORD PTR _normal_curvature_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN53@get_toggle:

; 5431 :        case DIV_NORMAL_CURVATURE_NODE: return div_normal_curvature_flag; 

	mov	eax, DWORD PTR _div_normal_curvature_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN52@get_toggle:

; 5432 :        case SHADING_NODE: return shading_flag; 

	mov	eax, DWORD PTR _shading_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN51@get_toggle:

; 5433 :        case FACET_COLORS_NODE: return color_flag; 

	mov	eax, DWORD PTR _color_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN50@get_toggle:

; 5434 :        case BOUNDARY_CURVATURE_NODE: return boundary_curvature_flag; 

	mov	eax, DWORD PTR _boundary_curvature_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN49@get_toggle:

; 5435 :        case NORMAL_MOTION_NODE: return normal_motion_flag; 

	mov	eax, DWORD PTR _normal_motion_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN48@get_toggle:

; 5436 :        case PINNING_NODE: return check_pinning_flag; 

	mov	eax, DWORD PTR _check_pinning_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN47@get_toggle:

; 5437 :        case VIEW_4D_NODE: return view_4D_flag; 

	mov	eax, DWORD PTR _view_4D_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN43@get_toggle:

; 5440 :        case METRIC_CONVERSION_NODE: return metric_convert_flag; 
; 5441 :        case AUTORECALC_NODE: return autorecalc_flag; 

	mov	eax, DWORD PTR _autorecalc_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN42@get_toggle:

; 5442 :        case FORCE_POS_DEF_NODE: return make_pos_def_flag; 

	mov	eax, DWORD PTR _make_pos_def_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN41@get_toggle:

; 5443 :        case GV_BINARY_NODE: return gv_binary_flag; 

	mov	eax, DWORD PTR _gv_binary_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN40@get_toggle:

; 5444 :        case SELF_SIMILAR_NODE: return self_similar_flag; 

	mov	eax, DWORD PTR _self_similar_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN39@get_toggle:

; 5445 :        case AUTODISPLAY_NODE: return go_display_flag; 

	mov	eax, DWORD PTR _go_display_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN38@get_toggle:

; 5446 :        case RIBIERE_CG_NODE: return ribiere_flag; 

	mov	eax, DWORD PTR _ribiere_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN37@get_toggle:

; 5447 :        case ASSUME_ORIENTED_NODE: return assume_oriented_flag; 

	mov	eax, DWORD PTR _assume_oriented_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN36@get_toggle:

; 5448 :        case DIRICHLET_MODE_NODE: return dirichlet_flag; 

	mov	eax, DWORD PTR _dirichlet_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN35@get_toggle:

; 5449 :        case SOBOLEV_MODE_NODE: return sobolev_flag; 

	mov	eax, DWORD PTR _sobolev_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN34@get_toggle:

; 5450 :        case KRAYNIKPOPVERTEX_FLAG_NODE: return kraynikpopvertex_flag; 

	mov	eax, DWORD PTR _kraynikpopvertex_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN33@get_toggle:

; 5451 :        case KRAYNIKPOPEDGE_FLAG_NODE: return kraynikpopedge_flag; 

	mov	eax, DWORD PTR _kraynikpopedge_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN32@get_toggle:

; 5452 :        case K_ALTITUDE_FLAG_NODE: return K_altitude_flag; 

	mov	eax, DWORD PTR _K_altitude_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN31@get_toggle:

; 5453 :        case HESSIAN_NORMAL_NODE: return hessian_normal_flag; 

	mov	eax, DWORD PTR _hessian_normal_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN30@get_toggle:

; 5454 :        case HESSIAN_SPECIAL_NORMAL_NODE: return hessian_special_normal_flag; 

	mov	eax, DWORD PTR _hessian_special_normal_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN29@get_toggle:

; 5455 :        case HESSIAN_NORMAL_PERP_NODE: return hessian_normal_perp_flag; 

	mov	eax, DWORD PTR _hessian_normal_perp_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN28@get_toggle:

; 5456 :        case HESSIAN_NORMAL_ONE_NODE: return hessian_normal_one_flag; 

	mov	eax, DWORD PTR _hessian_normal_one_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN27@get_toggle:

; 5457 :        case HESSIAN_DOUBLE_NORMAL_NODE: return hessian_double_normal_flag; 

	mov	eax, DWORD PTR _hessian_double_normal_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN26@get_toggle:

; 5458 :        case INTERP_BDRY_PARAM_NODE: return interp_bdry_param; 

	mov	eax, DWORD PTR _interp_bdry_param

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN25@get_toggle:

; 5459 :        case H_INVERSE_METRIC_NODE: return web.h_inverse_metric_flag; 

	mov	eax, DWORD PTR _web+812

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN24@get_toggle:

; 5460 :        case PSCOLORFLAG_NODE: return ps_colorflag;

	mov	eax, DWORD PTR _ps_colorflag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN23@get_toggle:

; 5461 :        case PS_CMYKFLAG_NODE: return ps_cmykflag;

	mov	eax, DWORD PTR _ps_cmykflag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN22@get_toggle:

; 5462 :        case GRIDFLAG_NODE: return gridflag;

	mov	eax, DWORD PTR _gridflag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN21@get_toggle:

; 5463 :        case FORCE_EDGESWAP_NODE: return force_edgeswap_flag;

	mov	eax, DWORD PTR _force_edgeswap_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN20@get_toggle:

; 5464 :        case SEPTUM_FLAG_NODE: return septum_flag; 

	mov	eax, DWORD PTR _septum_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN19@get_toggle:

; 5465 :        case BOX_FLAG_NODE: return box_flag;

	mov	eax, DWORD PTR _box_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN18@get_toggle:

; 5466 :        case SHOW_ALL_EDGES_NODE: return edgeshow_flag;

	mov	eax, DWORD PTR _edgeshow_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN17@get_toggle:

; 5467 :        case METIS_FACTOR_NODE: return ysmp_flag == METIS_FACTORING;

	xor	eax, eax
	cmp	DWORD PTR _ysmp_flag, 2
	sete	al

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN16@get_toggle:

; 5468 :        case CROSSINGFLAG_NODE: return crossingflag;

	mov	eax, DWORD PTR _crossingflag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN15@get_toggle:

; 5469 :        case LABELFLAG_NODE: return labelflag;

	mov	eax, DWORD PTR _labelflag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN14@get_toggle:

; 5470 :        case SHOW_ALL_QUANTITIES_NODE: return show_all_quantities;

	mov	eax, DWORD PTR _show_all_quantities

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN13@get_toggle:

; 5471 :        case QUANTITIES_ONLY_NODE: return quantities_only_flag;

	mov	eax, DWORD PTR _quantities_only_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN12@get_toggle:

; 5472 :        case VISIBILITY_TEST_NODE: return visibility_test;

	mov	eax, DWORD PTR _visibility_test

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN11@get_toggle:

; 5473 :        case SPARSE_CONSTRAINTS_NODE: return sparse_constraints_flag;

	mov	eax, DWORD PTR _sparse_constraints_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN10@get_toggle:

; 5474 :        case BLAS_FLAG_NODE: return blas_flag; 

	mov	eax, DWORD PTR _blas_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN9@get_toggle:

; 5475 :        case BREAK_AFTER_WARNING_NODE : return break_after_warning;

	mov	eax, DWORD PTR _break_after_warning

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN8@get_toggle:

; 5476 :        case BREAK_ON_WARNING_NODE : return break_on_warning;

	mov	eax, DWORD PTR _break_on_warning

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN7@get_toggle:

; 5477 :        case AUGMENTED_HESSIAN_NODE: return augmented_hessian_flag;

	mov	eax, DWORD PTR _augmented_hessian_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN6@get_toggle:

; 5478 :        case VERBOSE_NODE: return verbose_flag;

	mov	eax, DWORD PTR _verbose_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN5@get_toggle:

; 5479 :        case FUNCTION_QUANTITY_SPARSE_NODE: return quantity_function_sparse_flag;

	mov	eax, DWORD PTR _quantity_function_sparse_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN4@get_toggle:

; 5480 :        case BIG_ENDIAN_NODE: return big_endian_flag; 

	mov	eax, DWORD PTR _big_endian_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN3@get_toggle:

; 5481 :        case LITTLE_ENDIAN_NODE : return little_endian_flag;

	mov	eax, DWORD PTR _little_endian_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN2@get_toggle:

; 5482 :        case RGB_COLORS_FLAG_NODE : return rgb_colors_flag;

	mov	eax, DWORD PTR _rgb_colors_flag

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
$LN1@get_toggle:

; 5483 :        default:
; 5484 :             sprintf(errmsg,"Internal error:  Toggle value omitted for toggle %d.\n",tog);

	push	eax
	push	OFFSET ??_C@_0DG@FBPIKPGM@Internal?5error?3?5?5Toggle?5value?5om@
	push	OFFSET _errmsg
	call	_sprintf

; 5485 :             kb_error(1236,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1236					; 000004d4H
	call	_kb_error
	add	esp, 24					; 00000018H
$LN123@get_toggle:

; 5486 :     }
; 5487 :     return 0;

	xor	eax, eax

; 5488 : } /* end get_toggle_value */

	pop	ebp
	ret	0
	npad	2
$LN128@get_toggle:
	DD	$LN101@get_toggle
	DD	$LN118@get_toggle
	DD	$LN74@get_toggle
	DD	$LN51@get_toggle
	DD	$LN52@get_toggle
	DD	$LN49@get_toggle
	DD	$LN47@get_toggle
	DD	$LN48@get_toggle
	DD	$LN63@get_toggle
	DD	$LN40@get_toggle
	DD	$LN41@get_toggle
	DD	$LN96@get_toggle
	DD	$LN50@get_toggle
	DD	$LN71@get_toggle
	DD	$LN57@get_toggle
	DD	$LN56@get_toggle
	DD	$LN43@get_toggle
	DD	$LN42@get_toggle
	DD	$LN95@get_toggle
	DD	$LN72@get_toggle
	DD	$LN94@get_toggle
	DD	$LN90@get_toggle
	DD	$LN89@get_toggle
	DD	$LN87@get_toggle
	DD	$LN88@get_toggle
	DD	$LN86@get_toggle
	DD	$LN81@get_toggle
	DD	$LN80@get_toggle
	DD	$LN25@get_toggle
	DD	$LN37@get_toggle
	DD	$LN38@get_toggle
	DD	$LN73@get_toggle
	DD	$LN76@get_toggle
	DD	$LN14@get_toggle
	DD	$LN24@get_toggle
	DD	$LN23@get_toggle
	DD	$LN21@get_toggle
	DD	$LN22@get_toggle
	DD	$LN16@get_toggle
	DD	$LN15@get_toggle
	DD	$LN19@get_toggle
	DD	$LN18@get_toggle
	DD	$LN20@get_toggle
	DD	$LN103@get_toggle
	DD	$LN6@get_toggle
	DD	$LN85@get_toggle
	DD	$LN82@get_toggle
	DD	$LN5@get_toggle
	DD	$LN116@get_toggle
	DD	$LN117@get_toggle
	DD	$LN92@get_toggle
	DD	$LN91@get_toggle
	DD	$LN104@get_toggle
	DD	$LN102@get_toggle
	DD	$LN105@get_toggle
	DD	$LN83@get_toggle
	DD	$LN36@get_toggle
	DD	$LN2@get_toggle
	DD	$LN9@get_toggle
	DD	$LN8@get_toggle
	DD	$LN10@get_toggle
	DD	$LN7@get_toggle
	DD	$LN11@get_toggle
	DD	$LN12@get_toggle
	DD	$LN34@get_toggle
	DD	$LN33@get_toggle
	DD	$LN32@get_toggle
	DD	$LN114@get_toggle
	DD	$LN113@get_toggle
	DD	$LN110@get_toggle
	DD	$LN109@get_toggle
	DD	$LN112@get_toggle
	DD	$LN111@get_toggle
	DD	$LN4@get_toggle
	DD	$LN3@get_toggle
	DD	$LN108@get_toggle
	DD	$LN107@get_toggle
	DD	$LN115@get_toggle
	DD	$LN35@get_toggle
	DD	$LN31@get_toggle
	DD	$LN30@get_toggle
	DD	$LN29@get_toggle
	DD	$LN27@get_toggle
	DD	$LN28@get_toggle
	DD	$LN84@get_toggle
	DD	$LN58@get_toggle
	DD	$LN26@get_toggle
	DD	$LN55@get_toggle
	DD	$LN79@get_toggle
	DD	$LN78@get_toggle
	DD	$LN93@get_toggle
	DD	$LN75@get_toggle
	DD	$LN39@get_toggle
	DD	$LN61@get_toggle
	DD	$LN60@get_toggle
	DD	$LN59@get_toggle
	DD	$LN106@get_toggle
	DD	$LN70@get_toggle
	DD	$LN54@get_toggle
	DD	$LN53@get_toggle
	DD	$LN69@get_toggle
	DD	$LN68@get_toggle
	DD	$LN67@get_toggle
	DD	$LN66@get_toggle
	DD	$LN13@get_toggle
	DD	$LN64@get_toggle
	DD	$LN65@get_toggle
	DD	$LN17@get_toggle
	DD	$LN62@get_toggle
	DD	$LN1@get_toggle
$LN127@get_toggle:
	DB	0
	DB	1
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	2
	DB	109					; 0000006dH
	DB	3
	DB	4
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	109					; 0000006dH
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	109					; 0000006dH
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	46					; 0000002eH
	DB	47					; 0000002fH
	DB	48					; 00000030H
	DB	49					; 00000031H
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	50					; 00000032H
	DB	51					; 00000033H
	DB	52					; 00000034H
	DB	109					; 0000006dH
	DB	53					; 00000035H
	DB	54					; 00000036H
	DB	55					; 00000037H
	DB	56					; 00000038H
	DB	57					; 00000039H
	DB	58					; 0000003aH
	DB	59					; 0000003bH
	DB	60					; 0000003cH
	DB	61					; 0000003dH
	DB	62					; 0000003eH
	DB	63					; 0000003fH
	DB	109					; 0000006dH
	DB	64					; 00000040H
	DB	65					; 00000041H
	DB	66					; 00000042H
	DB	67					; 00000043H
	DB	68					; 00000044H
	DB	69					; 00000045H
	DB	70					; 00000046H
	DB	71					; 00000047H
	DB	72					; 00000048H
	DB	73					; 00000049H
	DB	74					; 0000004aH
	DB	75					; 0000004bH
	DB	76					; 0000004cH
	DB	77					; 0000004dH
	DB	78					; 0000004eH
	DB	79					; 0000004fH
	DB	80					; 00000050H
	DB	81					; 00000051H
	DB	82					; 00000052H
	DB	83					; 00000053H
	DB	84					; 00000054H
	DB	85					; 00000055H
	DB	86					; 00000056H
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	87					; 00000057H
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	88					; 00000058H
	DB	89					; 00000059H
	DB	90					; 0000005aH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	91					; 0000005bH
	DB	92					; 0000005cH
	DB	93					; 0000005dH
	DB	94					; 0000005eH
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	96					; 00000060H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	99					; 00000063H
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	109					; 0000006dH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	103					; 00000067H
	DB	8
	DB	104					; 00000068H
	DB	109					; 0000006dH
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	106					; 0000006aH
	DB	107					; 0000006bH
	DB	108					; 0000006cH
_get_toggle_value ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@IJFNOCFF@Internal?3?5illegal?5variable?5numbe@ ; `string'
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@41f0000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_get_internal_variable
EXTRN	_autochop_length:QWORD
EXTRN	_bad_errors_count:DWORD
EXTRN	_facets_same_vertices_count:DWORD
EXTRN	_edges_same_vertices_count:DWORD
EXTRN	_edge_loop_count:DWORD
EXTRN	_inconsistent_bodies_count:DWORD
EXTRN	_bad_next_prev_count:DWORD
EXTRN	_mindeg_min_region_size:DWORD
EXTRN	_mindeg_margin:DWORD
EXTRN	_string_curve_tolerance:QWORD
EXTRN	_window_aspect_ratio:QWORD
EXTRN	_this_task:DWORD
EXTRN	_bounding_box_color:DWORD
EXTRN	_dt_eps:QWORD
EXTRN	_mindeg_debug_level:DWORD
EXTRN	__heapwalk:PROC
EXTRN	_GetProcessMemoryInfo@12:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	_clock:PROC
EXTRN	_transform_count:DWORD
EXTRN	_ps_gridedgewidth:QWORD
EXTRN	_ps_bareedgewidth:QWORD
EXTRN	_ps_conedgewidth:QWORD
EXTRN	_ps_tripleedgewidth:QWORD
EXTRN	_ps_fixededgewidth:QWORD
EXTRN	_ps_stringwidth:QWORD
EXTRN	_ps_labelsize:QWORD
EXTRN	_background_color:DWORD
EXTRN	_last_error:DWORD
EXTRN	_brightness:QWORD
EXTRN	_last_hessian_scale:QWORD
EXTRN	_last_eigenvalue:QWORD
EXTRN	_breakflag:DWORD
EXTRN	_scrollbuffersize:DWORD
EXTRN	_visdebuglevel:DWORD
EXTRN	_check_count:DWORD
EXTRN	_hessian_slant_cutoff:QWORD
EXTRN	_thickness:QWORD
EXTRN	_kb_drand:PROC
EXTRN	_quadratic_metric_mix:QWORD
EXTRN	_random_seed:DWORD
EXTRN	_linear_metric_mix:QWORD
EXTRN	_pickfnum:DWORD
EXTRN	_pickenum:DWORD
EXTRN	_pickvnum:DWORD
EXTRN	_eigen_zero:DWORD
EXTRN	_eigen_neg:DWORD
EXTRN	_eigen_pos:DWORD
EXTRN	_hessian_epsilon:QWORD
EXTRN	_gocount:DWORD
EXTRN	_total_time:QWORD
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0CH@IJFNOCFF@Internal?3?5illegal?5variable?5numbe@
CONST	SEGMENT
??_C@_0CH@IJFNOCFF@Internal?3?5illegal?5variable?5numbe@ DB 'Internal: il'
	DB	'legal variable number %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _get_internal_variable
_TEXT	SEGMENT
_hinfo$93299 = -56					; size = 12
_cycles$93293 = -52					; size = 8
tv603 = -48						; size = 4
tv590 = -48						; size = 4
tv531 = -48						; size = 4
tv521 = -48						; size = 4
tv514 = -48						; size = 4
tv255 = -48						; size = 4
_meminfo$93296 = -44					; size = 40
__$ArrayPad$ = -4					; size = 4
_vartok$ = 8						; size = 4
_get_internal_variable PROC				; COMDAT

; 5498 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5499 :   switch(vartok)

	mov	eax, DWORD PTR _vartok$[ebp]
	cmp	eax, 1861				; 00000745H
	jg	$LN120@get_intern
	je	$LN29@get_intern
	lea	ecx, DWORD PTR [eax-1602]
	cmp	ecx, 240				; 000000f0H
	ja	$LN1@get_intern
	movzx	ecx, BYTE PTR $LN124@get_intern[ecx]
	jmp	DWORD PTR $LN130@get_intern[ecx*4]
$LN107@get_intern:

; 5511 : #endif
; 5512 : #ifdef MPI_EVOLVER
; 5513 :     case V_CORONA_STATE: 
; 5514 :       return (REAL)mpi_corona_state; 
; 5515 : #endif
; 5516 :     case V_VERTEXCOUNT:
; 5517 :       return (REAL)web.skel[VERTEX].count; 

	fild	DWORD PTR _web+64

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN106@get_intern:

; 5518 :     case V_EDGECOUNT:
; 5519 :       return (REAL)web.skel[EDGE].count; 

	fild	DWORD PTR _web+176

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN105@get_intern:

; 5520 :     case V_FACETCOUNT:
; 5521 :       return (REAL)web.skel[FACET].count; 

	fild	DWORD PTR _web+288

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN104@get_intern:

; 5522 :     case V_BODYCOUNT:
; 5523 :       return (REAL)web.skel[BODY].count; 

	fild	DWORD PTR _web+400

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN103@get_intern:

; 5524 :     case V_FACETEDGECOUNT:
; 5525 :       return (REAL)web.skel[FACETEDGE].count; 

	fild	DWORD PTR _web+512

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN102@get_intern:

; 5526 :     case V_ENERGY:
; 5527 :       return web.total_energy; 

	fld	QWORD PTR _web+1240

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN100@get_intern:

; 5530 :     case V_TIME:
; 5531 :       return total_time; 

	fld	QWORD PTR _total_time

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN99@get_intern:

; 5532 :     case V_JIG_TEMP:
; 5533 :       return web.temperature; 

	fld	QWORD PTR _web+1576

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN98@get_intern:

; 5534 :     case V_AREA:
; 5535 :     case V_LENGTH:
; 5536 :       return web.total_area; 

	fld	QWORD PTR _web+992

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN97@get_intern:

; 5537 :     case V_ITER_COUNTER:
; 5538 :       return (REAL)gocount; 

	fild	DWORD PTR _gocount

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN94@get_intern:

; 5543 :     case V_SCALE:
; 5544 :       return web.scale; 

	fld	QWORD PTR _web+1512

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN93@get_intern:

; 5545 :     case V_SCALE_SCALE:
; 5546 :       return web.scale_scale; 

	fld	QWORD PTR _web+1520

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN92@get_intern:

; 5547 :     case V_SPACE_DIMENSION:
; 5548 :       return (REAL)SDIM; 

	fild	DWORD PTR _web+616

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN91@get_intern:

; 5549 :     case V_SURFACE_DIMENSION:
; 5550 :       return (REAL)web.dimension; 

	fild	DWORD PTR _web+620

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN90@get_intern:

; 5551 :     case V_TORUS:
; 5552 :       return (REAL)web.torus_flag; 

	fild	DWORD PTR _web+860

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN89@get_intern:

; 5553 :     case V_SYMMETRY_GROUP:
; 5554 :       return (REAL)web.symmetry_flag; 

	fild	DWORD PTR _web+856

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN88@get_intern:

; 5555 :     case V_SIMPLEX:
; 5556 :       return (REAL)(web.representation == SIMPLEX); 

	xor	edx, edx
	cmp	DWORD PTR _web+624, 3
	sete	dl
	mov	DWORD PTR tv603[ebp], edx
	fild	DWORD PTR tv603[ebp]

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN87@get_intern:

; 5557 :     case V_INTEGRAL_ORDER:
; 5558 :       return ((REAL)web.gauss1D_order+2)/2; 

	fild	DWORD PTR _web+1592
	fadd	QWORD PTR __real@4000000000000000
	fmul	QWORD PTR __real@3fe0000000000000

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN86@get_intern:

; 5559 :     case V_INTEGRAL_ORDER_1D:
; 5560 :       return (REAL)web.gauss1D_order; 

	fild	DWORD PTR _web+1592

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN85@get_intern:

; 5561 :     case V_INTEGRAL_ORDER_2D:
; 5562 :       return (REAL)web.gauss2D_order; 

	fild	DWORD PTR _web+1596

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN84@get_intern:

; 5563 :     case V_TOLERANCE:
; 5564 :       return web.tolerance; 

	fld	QWORD PTR _web+752

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN80@get_intern:

; 5571 :     case V_HESS_EPSILON:
; 5572 :       return hessian_epsilon; 

	fld	QWORD PTR _hessian_epsilon

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN78@get_intern:

; 5573 :     case GRAV_CONST_NODE:
; 5574 :       return web.grav_const; 
; 5575 :     case V_EQUI_COUNT:
; 5576 :       return (REAL)web.equi_count; 

	fild	DWORD PTR _web+5432

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN75@get_intern:

; 5581 :     case V_DELETE_COUNT:
; 5582 :       return (REAL)web.edge_delete_count + web.facet_delete_count; 

	fild	DWORD PTR _web+5440
	fiadd	DWORD PTR _web+5436

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN72@get_intern:

; 5587 :     case V_REFINE_COUNT:
; 5588 :       return (REAL)web.edge_refine_count + web.facet_refine_count;; 

	fild	DWORD PTR _web+5448
	fiadd	DWORD PTR _web+5444

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN69@get_intern:

; 5593 :     case V_NOTCH_COUNT:
; 5594 :       return (REAL)web.notch_count; 

	fild	DWORD PTR _web+5516

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN68@get_intern:

; 5595 :     case V_DISSOLVE_COUNT:
; 5596 :       return (REAL)web.vertex_dissolve_count + web.edge_dissolve_count
; 5597 :              + web.facet_dissolve_count + web.body_dissolve_count; 

	fild	DWORD PTR _web+5456
	fiadd	DWORD PTR _web+5452
	fiadd	DWORD PTR _web+5460
	fiadd	DWORD PTR _web+5464

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@get_intern:

; 5626 :     case V_POP_COUNT:
; 5627 :       return web.vertex_pop_count + web.edge_pop_count;

	mov	ecx, DWORD PTR _web+5480
	add	ecx, DWORD PTR _web+5476
	mov	DWORD PTR tv590[ebp], ecx
	fild	DWORD PTR tv590[ebp]

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@get_intern:

; 5638 :     case V_WHERE_COUNT:
; 5639 :       return (REAL)web.where_count; 

	fild	DWORD PTR _web+5496

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@get_intern:

; 5640 :     case V_EIGENPOS:
; 5641 :       return (REAL)eigen_pos; 

	fild	DWORD PTR _eigen_pos

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@get_intern:

; 5642 :     case V_EIGENNEG:
; 5643 :       return (REAL)eigen_neg; 

	fild	DWORD PTR _eigen_neg

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@get_intern:

; 5644 :     case V_EIGENZERO:
; 5645 :       return (REAL)eigen_zero; 

	fild	DWORD PTR _eigen_zero

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@get_intern:

; 5666 :     case V_PICKVNUM:
; 5667 :       return (REAL)pickvnum; 

	fild	DWORD PTR _pickvnum

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@get_intern:

; 5668 :     case V_PICKENUM:
; 5669 :       return (REAL)pickenum; 

	fild	DWORD PTR _pickenum

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@get_intern:

; 5670 :     case V_PICKFNUM:
; 5671 :       return (REAL)pickfnum; 

	fild	DWORD PTR _pickfnum

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@get_intern:

; 5672 :     case V_LINEAR_METRIC_MIX:
; 5673 :       return linear_metric_mix; 

	fld	QWORD PTR _linear_metric_mix

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@get_intern:

; 5676 :     case V_RANDOM_SEED:
; 5677 :       return (REAL)random_seed; 

	fild	DWORD PTR _random_seed

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@get_intern:

; 5674 :     case V_QUADRATIC_METRIC_MIX:
; 5675 :       return quadratic_metric_mix; 

	fld	QWORD PTR _quadratic_metric_mix

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN120@get_intern:

; 5499 :   switch(vartok)

	cmp	eax, 2268				; 000008dcH
	jg	$LN121@get_intern
	je	$LN57@get_intern
	lea	ecx, DWORD PTR [eax-1863]
	cmp	ecx, 254				; 000000feH
	ja	$LN1@get_intern
	movzx	edx, BYTE PTR $LN125@get_intern[ecx]
	jmp	DWORD PTR $LN131@get_intern[edx*4]
$LN109@get_intern:

; 5505 :     case V_RANDOM: return kb_drand();

	call	_kb_drand

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN101@get_intern:

; 5528 :     case V_GAP_CONSTANT:
; 5529 :       return web.spring_constant; 

	fld	QWORD PTR _web+1584

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN96@get_intern:

; 5539 :     case V_AMBIENT_PRESSURE:
; 5540 :       return web.pressure; 

	fld	QWORD PTR _web+1536

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN95@get_intern:

; 5541 :     case V_DIFFUSION:
; 5542 :       return web.diffusion_const; 

	fld	QWORD PTR _web+784

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN83@get_intern:

; 5565 :     case V_TARGET_TOLERANCE:
; 5566 :       return web.target_tolerance; 

	fld	QWORD PTR _web+760

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN82@get_intern:

; 5567 :     case V_THICKNESS:
; 5568 :       return thickness; 

	fld	QWORD PTR _thickness

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN81@get_intern:

; 5569 :     case V_HESSIAN_SLANT_CUTOFF:
; 5570 :       return hessian_slant_cutoff; 

	fld	QWORD PTR _hessian_slant_cutoff

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN77@get_intern:

; 5577 :     case V_EDGESWAP_COUNT:
; 5578 :       return (REAL)web.edgeswap_count; 

	fild	DWORD PTR _web+5500

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN76@get_intern:

; 5579 :     case V_T1_EDGESWAP_COUNT:
; 5580 :       return (REAL)web.t1_edgeswap_count; 

	fild	DWORD PTR _web+5504

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@get_intern:

; 5583 :     case V_EDGE_DELETE_COUNT:
; 5584 :       return (REAL)web.edge_delete_count; 

	fild	DWORD PTR _web+5436

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@get_intern:

; 5585 :     case V_FACET_DELETE_COUNT:
; 5586 :       return (REAL)web.facet_delete_count; 

	fild	DWORD PTR _web+5440

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@get_intern:

; 5589 :     case V_EDGE_REFINE_COUNT:
; 5590 :       return (REAL)web.edge_refine_count; 

	fild	DWORD PTR _web+5444

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN70@get_intern:

; 5591 :     case V_FACET_REFINE_COUNT:
; 5592 :       return (REAL)web.facet_refine_count; 

	fild	DWORD PTR _web+5448

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN67@get_intern:

; 5598 :     case V_VERTEX_DISSOLVE_COUNT:
; 5599 :       return (REAL)web.vertex_dissolve_count; 

	fild	DWORD PTR _web+5452

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN66@get_intern:

; 5600 :     case V_EDGE_DISSOLVE_COUNT:
; 5601 :       return (REAL)web.edge_dissolve_count; 

	fild	DWORD PTR _web+5456

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@get_intern:

; 5602 :     case V_FACET_DISSOLVE_COUNT:
; 5603 :       return (REAL)web.facet_dissolve_count; 

	fild	DWORD PTR _web+5460

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN64@get_intern:

; 5604 :     case V_BODY_DISSOLVE_COUNT:
; 5605 :       return (REAL)web.body_dissolve_count; 

	fild	DWORD PTR _web+5464

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@get_intern:

; 5610 :     case V_FIX_COUNT:
; 5611 :       return web.fix_count;

	fild	DWORD PTR _web+5508

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@get_intern:

; 5624 :     case V_UNFIX_COUNT:
; 5625 :       return web.unfix_count;

	fild	DWORD PTR _web+5512

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@get_intern:

; 5628 :     case V_VERTEX_POP_COUNT:
; 5629 :       return web.vertex_pop_count;

	fild	DWORD PTR _web+5476

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@get_intern:

; 5630 :     case V_EDGE_POP_COUNT:
; 5631 :       return web.edge_pop_count;

	fild	DWORD PTR _web+5480

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@get_intern:

; 5632 :     case V_POP_TRI_TO_EDGE_COUNT:
; 5633 :       return web.pop_tri_to_edge_count;

	fild	DWORD PTR _web+5484

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@get_intern:

; 5634 :     case V_POP_EDGE_TO_TRI_COUNT:
; 5635 :       return web.pop_edge_to_tri_count;

	fild	DWORD PTR _web+5488

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@get_intern:

; 5636 :     case V_POP_QUAD_TO_QUAD_COUNT:
; 5637 :       return web.pop_quad_to_quad_count;

	fild	DWORD PTR _web+5492

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@get_intern:

; 5646 :     case V_CHECK_COUNT:
; 5647 :       return (REAL)check_count; 

	fild	DWORD PTR _check_count

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@get_intern:

; 5660 :     case V_VISIBILITY_DEBUG:
; 5661 :       return (REAL)visdebuglevel; 

	fild	DWORD PTR _visdebuglevel

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@get_intern:

; 5662 :     case V_SCROLLBUFFERSIZE:
; 5663 :       return (REAL)scrollbuffersize;

	fild	DWORD PTR _scrollbuffersize

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@get_intern:

; 5664 :     case V_BREAKFLAG:
; 5665 :       return (REAL)breakflag; 

	fild	DWORD PTR _breakflag

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@get_intern:

; 5678 :     case V_LAST_EIGENVALUE:
; 5679 :       return last_eigenvalue; 

	fld	QWORD PTR _last_eigenvalue

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@get_intern:

; 5680 :     case V_LAST_HESSIAN_SCALE:
; 5681 :       return last_hessian_scale; 

	fld	QWORD PTR _last_hessian_scale

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@get_intern:

; 5682 :     case V_LAGRANGE_ORDER:
; 5683 :       return (REAL)web.lagrange_order; 

	fild	DWORD PTR _web+632

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@get_intern:

; 5684 :     case V_SCALE_LIMIT:
; 5685 :       return web.maxscale; 

	fld	QWORD PTR _web+1528

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@get_intern:

; 5686 :     case V_BRIGHTNESS:
; 5687 :       return brightness; 

	fld	QWORD PTR _brightness

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@get_intern:

; 5688 :     case V_LAST_ERROR: return last_error;

	fild	DWORD PTR _last_error

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@get_intern:

; 5689 :     case V_BACKGROUND: return background_color;

	fild	DWORD PTR _background_color

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@get_intern:

; 5690 :     case V_PS_LABELSIZE: return ps_labelsize;

	fld	QWORD PTR _ps_labelsize

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@get_intern:

; 5691 :     case V_PS_STRINGWIDTH: return ps_stringwidth;

	fld	QWORD PTR _ps_stringwidth

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@get_intern:

; 5692 :     case V_PS_FIXEDEDGEWIDTH: return ps_fixededgewidth;

	fld	QWORD PTR _ps_fixededgewidth

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@get_intern:

; 5693 :     case V_PS_TRIPLEEDGEWIDTH: return ps_tripleedgewidth;

	fld	QWORD PTR _ps_tripleedgewidth

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@get_intern:

; 5694 :     case V_PS_CONEDGEWIDTH: return ps_conedgewidth;

	fld	QWORD PTR _ps_conedgewidth

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@get_intern:

; 5695 :     case V_PS_BAREEDGEWIDTH: return ps_bareedgewidth;

	fld	QWORD PTR _ps_bareedgewidth

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@get_intern:

; 5696 :     case V_PS_GRIDEDGEWIDTH: return ps_gridedgewidth;

	fld	QWORD PTR _ps_gridedgewidth

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@get_intern:

; 5700 :     case V_TRANSFORM_COUNT:
; 5701 :       return transform_count == 0 ? 1 : transform_count;

	mov	eax, DWORD PTR _transform_count
	mov	DWORD PTR tv255[ebp], 1
	test	eax, eax
	je	SHORT $LN119@get_intern
	mov	DWORD PTR tv255[ebp], eax
$LN119@get_intern:
	fild	DWORD PTR tv255[ebp]

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@get_intern:

; 5702 :     case V_CLOCK:
; 5703 : #if defined (__SYS_TIMES_H__) && defined(HZ)
; 5704 :       { struct tms t;
; 5705 :         times(&t);
; 5706 :         return t.tms_utime/(REAL)HZ;
; 5707 :       }
; 5708 : #else
; 5709 : #if defined (_SYS_TIMES_H) && defined(CLK_TCK)
; 5710 :       { struct tms t;    /* SGI, anyway */
; 5711 :         times(&t);
; 5712 :         return t.tms_utime/(REAL)CLK_TCK;
; 5713 :       }
; 5714 : #else
; 5715 : #ifdef CLOCKS_PER_SEC
; 5716 :       return clock()/(REAL)CLOCKS_PER_SEC;

	call	_clock
	mov	DWORD PTR tv531[ebp], eax
	fild	DWORD PTR tv531[ebp]
	fdiv	QWORD PTR __real@408f400000000000

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@get_intern:

; 5717 : #else
; 5718 :       return 0.0;
; 5719 : #endif
; 5720 : #endif
; 5721 : #endif
; 5722 :       break;
; 5723 :     
; 5724 :     case V_CPU_COUNTER:
; 5725 :       { long long int cycles; 
; 5726 :         PROF_NOW(cycles);

	rdtsc
	mov	DWORD PTR _cycles$93293[ebp], eax
	mov	DWORD PTR _cycles$93293[ebp+4], edx

; 5727 :         return (REAL)PROF_CYCLES(cycles);

	fild	QWORD PTR _cycles$93293[ebp]

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@get_intern:

; 5728 :       }
; 5729 : 
; 5730 :     case V_MEMARENA:
; 5731 : #if defined(M_MXFAST) && defined(IRIS)
; 5732 :       { struct mallinfo m = mallinfo();
; 5733 :         return (REAL)m.arena;
; 5734 :       }
; 5735 : #else
; 5736 : #if defined(_UNISTD_H)
; 5737 :   /* do this only on unix systems with unistd.h */
; 5738 :   return  (char*)sbrk(0)-(char*)&evolver_version;
; 5739 : #else
; 5740 : #ifdef MSC
; 5741 :       { 
; 5742 : 
; 5743 :           /*
; 5744 :         struct _heapinfo hinfo;
; 5745 :         size_t mem_use=0,mem_free=0;
; 5746 :         hinfo._pentry = NULL;
; 5747 :         while ( _heapwalk(&hinfo) == _HEAPOK )
; 5748 :            if (hinfo._useflag) { mem_use+= hinfo._size; }
; 5749 :            else {  mem_free += hinfo._size; }
; 5750 :         return (REAL)(mem_use+mem_free);
; 5751 :         */
; 5752 :         PROCESS_MEMORY_COUNTERS meminfo;
; 5753 :         meminfo.cb = sizeof(meminfo);
; 5754 :         GetProcessMemoryInfo(GetCurrentProcess(),&meminfo,sizeof(meminfo));

	push	40					; 00000028H
	lea	eax, DWORD PTR _meminfo$93296[ebp]
	push	eax
	mov	DWORD PTR _meminfo$93296[ebp], 40	; 00000028H
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	eax
	call	_GetProcessMemoryInfo@12

; 5755 :         return (REAL)meminfo.WorkingSetSize;

	fild	DWORD PTR _meminfo$93296[ebp+12]
	mov	ecx, DWORD PTR _meminfo$93296[ebp+12]
	test	ecx, ecx
	jns	$LN116@get_intern
	fadd	QWORD PTR __real@41f0000000000000

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@get_intern:
	push	esi

; 5756 :       }          
; 5757 : 
; 5758 : #else
; 5759 : #ifdef TC
; 5760 :       { struct heapinfo hinfo;
; 5761 :         long mem_use=0,mem_free=0;
; 5762 :         hinfo.ptr = NULL;
; 5763 :         while ( heapwalk(&hinfo) == _HEAPOK )
; 5764 :            if (hinfo.in_use) { mem_use+= hinfo.size; }
; 5765 :            else {  mem_free += hinfo.size; }
; 5766 :         return (REAL)(mem_use+mem_free);
; 5767 :       }          
; 5768 : 
; 5769 : #else
; 5770 :       return 0.0;
; 5771 : #endif
; 5772 : #endif
; 5773 : #endif
; 5774 : #endif
; 5775 :       break;
; 5776 : 
; 5777 :     case V_MEMUSED:
; 5778 : #if defined(M_MXFAST) && defined(IRIS)
; 5779 :       { struct mallinfo m = mallinfo();
; 5780 :         return (REAL)(m.uordblks + m.usmblks);
; 5781 :       }
; 5782 : #else
; 5783 : #ifdef WIN32
; 5784 :       { struct _heapinfo hinfo;
; 5785 :         size_t mem_use=0,mem_free=0;
; 5786 :         hinfo._pentry = NULL;
; 5787 :         while ( _heapwalk(&hinfo) == _HEAPOK )

	lea	edx, DWORD PTR _hinfo$93299[ebp]
	xor	esi, esi
	push	edx
	mov	DWORD PTR _hinfo$93299[ebp], esi
	call	__heapwalk
	add	esp, 4
	cmp	eax, -2					; fffffffeH
	jne	SHORT $LN4@get_intern
$LL5@get_intern:

; 5788 :            if (hinfo._useflag) { mem_use+= hinfo._size; }

	cmp	DWORD PTR _hinfo$93299[ebp+8], 0
	je	SHORT $LN3@get_intern
	add	esi, DWORD PTR _hinfo$93299[ebp+4]
$LN3@get_intern:

; 5756 :       }          
; 5757 : 
; 5758 : #else
; 5759 : #ifdef TC
; 5760 :       { struct heapinfo hinfo;
; 5761 :         long mem_use=0,mem_free=0;
; 5762 :         hinfo.ptr = NULL;
; 5763 :         while ( heapwalk(&hinfo) == _HEAPOK )
; 5764 :            if (hinfo.in_use) { mem_use+= hinfo.size; }
; 5765 :            else {  mem_free += hinfo.size; }
; 5766 :         return (REAL)(mem_use+mem_free);
; 5767 :       }          
; 5768 : 
; 5769 : #else
; 5770 :       return 0.0;
; 5771 : #endif
; 5772 : #endif
; 5773 : #endif
; 5774 : #endif
; 5775 :       break;
; 5776 : 
; 5777 :     case V_MEMUSED:
; 5778 : #if defined(M_MXFAST) && defined(IRIS)
; 5779 :       { struct mallinfo m = mallinfo();
; 5780 :         return (REAL)(m.uordblks + m.usmblks);
; 5781 :       }
; 5782 : #else
; 5783 : #ifdef WIN32
; 5784 :       { struct _heapinfo hinfo;
; 5785 :         size_t mem_use=0,mem_free=0;
; 5786 :         hinfo._pentry = NULL;
; 5787 :         while ( _heapwalk(&hinfo) == _HEAPOK )

	lea	eax, DWORD PTR _hinfo$93299[ebp]
	push	eax
	call	__heapwalk
	add	esp, 4
	cmp	eax, -2					; fffffffeH
	je	SHORT $LL5@get_intern
$LN4@get_intern:

; 5789 :            else {  mem_free += hinfo._size; }
; 5790 :         return (REAL)(mem_use);

	mov	DWORD PTR tv514[ebp], esi
	fild	DWORD PTR tv514[ebp]
	test	esi, esi
	jns	SHORT $LN128@get_intern
	fadd	QWORD PTR __real@41f0000000000000
$LN128@get_intern:
	pop	esi

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN57@get_intern:

; 5618 :     case V_MINDEG_DEBUG_LEVEL:
; 5619 :       return mindeg_debug_level;

	fild	DWORD PTR _mindeg_debug_level

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN121@get_intern:

; 5499 :   switch(vartok)

	cmp	eax, 10415				; 000028afH
	jg	$LN122@get_intern
	je	$LN11@get_intern
	lea	ecx, DWORD PTR [eax-2269]
	cmp	ecx, 40					; 00000028H
	ja	$LN1@get_intern
	movzx	ecx, BYTE PTR $LN126@get_intern[ecx]
	jmp	DWORD PTR $LN132@get_intern[ecx*4]
$LN113@get_intern:

; 5500 :   { 
; 5501 :     case V_DETORUS_EPSILON: return dt_eps; 

	fld	QWORD PTR _dt_eps

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN112@get_intern:

; 5502 :     case V_BOUNDING_BOX_COLOR: return bounding_box_color;

	fild	DWORD PTR _bounding_box_color

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN111@get_intern:

; 5503 :     case V_HIGH_BOUNDARY: return web.highbdry;

	fild	DWORD PTR _web+772

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN110@get_intern:

; 5504 :     case V_HIGH_CONSTRAINT: return web.highcon;

	fild	DWORD PTR _web+648

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN108@get_intern:

; 5506 :     case V_MPI_MAXTASK: 
; 5507 : #ifdef MPI_EVOLVER
; 5508 :          return mpi_nprocs-1;
; 5509 : #else
; 5510 :          return 1;

	fld1

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@get_intern:

; 5606 :     case V_EDGE_REVERSE_COUNT:
; 5607 :       return (REAL)web.edge_reverse_count; 

	fild	DWORD PTR _web+5468

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@get_intern:

; 5608 :     case V_FACET_REVERSE_COUNT:
; 5609 :       return (REAL)web.facet_reverse_count; 

	fild	DWORD PTR _web+5472

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN60@get_intern:

; 5612 :     case V_THIS_TASK:
; 5613 :       return this_task;

	fild	DWORD PTR _this_task

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN59@get_intern:

; 5614 :     case V_WINDOW_ASPECT_RATIO:
; 5615 :       return window_aspect_ratio;

	fld	QWORD PTR _window_aspect_ratio

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN58@get_intern:

; 5616 :     case V_STRING_CURVE_TOLERANCE:
; 5617 :       return string_curve_tolerance; 

	fld	QWORD PTR _string_curve_tolerance

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@get_intern:

; 5620 :     case V_MINDEG_MARGIN:
; 5621 :       return mindeg_margin; 

	fild	DWORD PTR _mindeg_margin

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN55@get_intern:

; 5622 :     case V_MINDEG_MIN_REGION_SIZE:
; 5623 :       return mindeg_min_region_size; 

	fild	DWORD PTR _mindeg_min_region_size

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@get_intern:

; 5648 :     case V_BAD_NEXT_PREV_COUNT:
; 5649 :       return (REAL)bad_next_prev_count; 

	fild	DWORD PTR _bad_next_prev_count

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@get_intern:

; 5650 :     case V_INCONSISTENT_BODIES_COUNT:
; 5651 :       return (REAL)inconsistent_bodies_count; 

	fild	DWORD PTR _inconsistent_bodies_count

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@get_intern:

; 5652 :     case V_EDGE_LOOP_COUNT:
; 5653 :       return (REAL)edge_loop_count; 

	fild	DWORD PTR _edge_loop_count

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@get_intern:

; 5654 :     case V_EDGES_SAME_VERTICES_COUNT:
; 5655 :       return (REAL)edges_same_vertices_count; 

	fild	DWORD PTR _edges_same_vertices_count

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@get_intern:

; 5656 :     case V_FACETS_SAME_VERTICES_COUNT:
; 5657 :       return (REAL)facets_same_vertices_count; 

	fild	DWORD PTR _facets_same_vertices_count

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@get_intern:

; 5658 :     case V_BAD_ERRORS_COUNT:
; 5659 :       return (REAL)bad_errors_count; 

	fild	DWORD PTR _bad_errors_count

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@get_intern:

; 5697 :     case V_EVERYTHING_QUANTITIES: return everything_quantities_flag;

	fild	DWORD PTR _everything_quantities_flag

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@get_intern:

; 5698 :     case V_AUTOCHOP_LENGTH: return autochop_length;

	fld	QWORD PTR _autochop_length

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN122@get_intern:

; 5499 :   switch(vartok)

	cmp	eax, 35080				; 00008908H
	je	SHORT $LN11@get_intern
$LN1@get_intern:

; 5791 :       }          
; 5792 : 
; 5793 : #else
; 5794 :       return 0.0;
; 5795 : #endif
; 5796 : #endif
; 5797 :       break;
; 5798 : 
; 5799 :     default: 
; 5800 :       sprintf(errmsg,"Internal: illegal variable number %d.\n",vartok);

	push	eax
	push	OFFSET ??_C@_0CH@IJFNOCFF@Internal?3?5illegal?5variable?5numbe@
	push	OFFSET _errmsg
	call	_sprintf

; 5801 :       kb_error(1208, errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1208					; 000004b8H
	call	_kb_error

; 5802 : 
; 5803 :   }
; 5804 :   return 0.0;

	fldz
	add	esp, 24					; 00000018H

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@get_intern:

; 5699 :     case GRAV_CONST_TOK: return web.grav_const;

	fld	QWORD PTR _web+832
$LN116@get_intern:

; 5805 : 
; 5806 : } // end get_internal_variable()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN130@get_intern:
	DD	$LN107@get_intern
	DD	$LN106@get_intern
	DD	$LN105@get_intern
	DD	$LN104@get_intern
	DD	$LN103@get_intern
	DD	$LN102@get_intern
	DD	$LN98@get_intern
	DD	$LN94@get_intern
	DD	$LN91@get_intern
	DD	$LN92@get_intern
	DD	$LN90@get_intern
	DD	$LN89@get_intern
	DD	$LN88@get_intern
	DD	$LN87@get_intern
	DD	$LN84@get_intern
	DD	$LN78@get_intern
	DD	$LN75@get_intern
	DD	$LN72@get_intern
	DD	$LN69@get_intern
	DD	$LN68@get_intern
	DD	$LN53@get_intern
	DD	$LN47@get_intern
	DD	$LN80@get_intern
	DD	$LN93@get_intern
	DD	$LN97@get_intern
	DD	$LN100@get_intern
	DD	$LN99@get_intern
	DD	$LN46@get_intern
	DD	$LN45@get_intern
	DD	$LN44@get_intern
	DD	$LN33@get_intern
	DD	$LN32@get_intern
	DD	$LN31@get_intern
	DD	$LN30@get_intern
	DD	$LN28@get_intern
	DD	$LN86@get_intern
	DD	$LN85@get_intern
	DD	$LN1@get_intern
$LN124@get_intern:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	6
	DB	7
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	8
	DB	9
	DB	37					; 00000025H
	DB	10					; 0000000aH
	DB	37					; 00000025H
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	14					; 0000000eH
	DB	37					; 00000025H
	DB	15					; 0000000fH
	DB	37					; 00000025H
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	22					; 00000016H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	23					; 00000017H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	24					; 00000018H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	27					; 0000001bH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	37					; 00000025H
	DB	33					; 00000021H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	37					; 00000025H
	DB	34					; 00000022H
	DB	37					; 00000025H
	DB	35					; 00000023H
	DB	36					; 00000024H
	npad	3
$LN131@get_intern:
	DD	$LN27@get_intern
	DD	$LN26@get_intern
	DD	$LN25@get_intern
	DD	$LN101@get_intern
	DD	$LN82@get_intern
	DD	$LN83@get_intern
	DD	$LN9@get_intern
	DD	$LN24@get_intern
	DD	$LN10@get_intern
	DD	$LN109@get_intern
	DD	$LN23@get_intern
	DD	$LN95@get_intern
	DD	$LN21@get_intern
	DD	$LN7@get_intern
	DD	$LN6@get_intern
	DD	$LN22@get_intern
	DD	$LN96@get_intern
	DD	$LN81@get_intern
	DD	$LN43@get_intern
	DD	$LN34@get_intern
	DD	$LN36@get_intern
	DD	$LN35@get_intern
	DD	$LN19@get_intern
	DD	$LN18@get_intern
	DD	$LN17@get_intern
	DD	$LN16@get_intern
	DD	$LN15@get_intern
	DD	$LN14@get_intern
	DD	$LN67@get_intern
	DD	$LN66@get_intern
	DD	$LN65@get_intern
	DD	$LN64@get_intern
	DD	$LN71@get_intern
	DD	$LN70@get_intern
	DD	$LN52@get_intern
	DD	$LN51@get_intern
	DD	$LN50@get_intern
	DD	$LN49@get_intern
	DD	$LN48@get_intern
	DD	$LN77@get_intern
	DD	$LN76@get_intern
	DD	$LN74@get_intern
	DD	$LN73@get_intern
	DD	$LN61@get_intern
	DD	$LN54@get_intern
	DD	$LN20@get_intern
	DD	$LN8@get_intern
	DD	$LN1@get_intern
$LN125@get_intern:
	DB	0
	DB	1
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	2
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	3
	DB	4
	DB	5
	DB	6
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	7
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	8
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	9
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	47					; 0000002fH
	DB	12					; 0000000cH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	47					; 0000002fH
	DB	15					; 0000000fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
	DB	27					; 0000001bH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	28					; 0000001cH
	DB	29					; 0000001dH
	DB	30					; 0000001eH
	DB	31					; 0000001fH
	DB	32					; 00000020H
	DB	33					; 00000021H
	DB	34					; 00000022H
	DB	35					; 00000023H
	DB	47					; 0000002fH
	DB	36					; 00000024H
	DB	37					; 00000025H
	DB	38					; 00000026H
	DB	39					; 00000027H
	DB	40					; 00000028H
	DB	47					; 0000002fH
	DB	47					; 0000002fH
	DB	41					; 00000029H
	DB	42					; 0000002aH
	DB	47					; 0000002fH
	DB	43					; 0000002bH
	DB	44					; 0000002cH
	DB	45					; 0000002dH
	DB	46					; 0000002eH
	npad	1
$LN132@get_intern:
	DD	$LN56@get_intern
	DD	$LN55@get_intern
	DD	$LN13@get_intern
	DD	$LN42@get_intern
	DD	$LN41@get_intern
	DD	$LN40@get_intern
	DD	$LN39@get_intern
	DD	$LN38@get_intern
	DD	$LN59@get_intern
	DD	$LN37@get_intern
	DD	$LN60@get_intern
	DD	$LN63@get_intern
	DD	$LN62@get_intern
	DD	$LN12@get_intern
	DD	$LN108@get_intern
	DD	$LN58@get_intern
	DD	$LN110@get_intern
	DD	$LN111@get_intern
	DD	$LN113@get_intern
	DD	$LN112@get_intern
	DD	$LN1@get_intern
$LN126@get_intern:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	13					; 0000000dH
	DB	20					; 00000014H
	DB	14					; 0000000eH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	15					; 0000000fH
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
_get_internal_variable ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@		; `string'
PUBLIC	_tree_copy
EXTRN	_stack_usage:PROC
EXTRN	_kb_calloc:PROC
EXTRN	_myfree:PROC
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
CONST	SEGMENT
??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@ DB 'EVALMORE.C', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _tree_copy
_TEXT	SEGMENT
_count$ = -4						; size = 4
tv134 = 8						; size = 4
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_tree_copy PROC						; COMDAT

; 5821 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 5822 :   struct treenode *enode;
; 5823 :   size_t count,n;
; 5824 : 
; 5825 :   if ( dest == NULL ) return;

	mov	ebx, DWORD PTR _dest$[ebp]
	test	ebx, ebx
	je	$LN17@tree_copy

; 5826 :   if ( dest->start ) myfree((char*)dest->start);

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN15@tree_copy
	push	eax
	call	_myfree
	add	esp, 4
$LN15@tree_copy:

; 5827 :   if ( src == NULL )  

	mov	edx, DWORD PTR _src$[ebp]
	test	edx, edx
	jne	SHORT $LN14@tree_copy

; 5828 :   { dest->start = dest->root = NULL; return; }

	mov	DWORD PTR [ebx+4], edx
	mov	DWORD PTR [ebx], edx
	pop	ebx

; 5872 : }  /* end tree_copy() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@tree_copy:
	push	esi
	push	edi

; 5829 :   enode=src; 

	mov	edi, edx
$LL13@tree_copy:

; 5830 :   while ( enode->left || enode->right ) 

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	jne	SHORT $LN11@tree_copy
	cmp	DWORD PTR [edi+8], eax
	je	SHORT $LN12@tree_copy
$LN11@tree_copy:

; 5831 :   { if ( enode->left < enode->right ) enode+=enode->left;

	mov	ecx, DWORD PTR [edi+8]
	cmp	eax, ecx
	jge	SHORT $LN10@tree_copy
	imul	eax, 168				; 000000a8H
	add	edi, eax
	jmp	SHORT $LL13@tree_copy
$LN10@tree_copy:

; 5832 :     else enode += enode->right;

	imul	ecx, 168				; 000000a8H
	add	edi, ecx

; 5833 :   }

	jmp	SHORT $LL13@tree_copy
$LN12@tree_copy:

; 5834 :   count = src - enode + 1;

	mov	ecx, edx
	sub	ecx, edi
	mov	eax, 818089009				; 30c30c31H
	imul	ecx
	sar	edx, 5
	mov	eax, edx

; 5835 :   dest->start = (struct treenode *)mycalloc(count+3,sizeof(struct treenode));

	push	5835					; 000016cbH
	shr	eax, 31					; 0000001fH
	lea	esi, DWORD PTR [edx+eax+1]
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	lea	ecx, DWORD PTR [esi+3]
	push	168					; 000000a8H
	push	ecx
	mov	DWORD PTR _count$[ebp], esi
	call	_kb_calloc

; 5836 :   dest->flag |= USERCOPY;
; 5837 :   memcpy((char*)(dest->start+2),(char*)enode,count*sizeof(struct treenode));

	imul	esi, 168				; 000000a8H
	or	DWORD PTR [ebx+12], 1
	push	esi
	mov	DWORD PTR [ebx], eax
	add	eax, 336				; 00000150H
	push	edi
	push	eax
	call	_memcpy

; 5838 :   dest->root = dest->start + count + 1;

	mov	eax, DWORD PTR [ebx]
	lea	edx, DWORD PTR [esi+eax+168]
	mov	DWORD PTR [ebx+4], edx

; 5839 :   dest->start[1].type = SETUP_FRAME_NODE;
; 5840 :   /* make copies of strings and locallists */
; 5841 :   for ( enode=dest->start+2, n = 0 ; n < count ; enode++,n++ )

	mov	edx, DWORD PTR _count$[ebp]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR [eax+168], 10001		; 00002711H
	mov	eax, DWORD PTR [ebx]
	test	edx, edx
	je	$LN6@tree_copy

; 5834 :   count = src - enode + 1;

	lea	esi, DWORD PTR [eax+488]
	mov	DWORD PTR tv134[ebp], edx
$LL8@tree_copy:

; 5842 :   { if ( enode->flags & HAS_STRING )

	test	BYTE PTR [esi-128], 32			; 00000020H
	je	SHORT $LN5@tree_copy

; 5843 :     { char *s = mycalloc(strlen(enode->op1.string)+1,sizeof(char));

	mov	eax, DWORD PTR [esi-120]
	lea	edx, DWORD PTR [eax+1]
$LL27@tree_copy:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL27@tree_copy
	push	5843					; 000016d3H
	sub	eax, edx
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	inc	eax
	push	1
	push	eax
	call	_kb_calloc

; 5844 :       strcpy(s,enode->op1.string);

	mov	edx, DWORD PTR [esi-120]
	add	esp, 16					; 00000010H
	mov	edi, eax
$LL19@tree_copy:
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [edi], cl
	inc	edx
	inc	edi
	test	cl, cl
	jne	SHORT $LL19@tree_copy

; 5845 :       enode->op1.string = s;

	mov	DWORD PTR [esi-120], eax
$LN5@tree_copy:

; 5846 :     }
; 5847 :     if ( enode->flags & HAS_STRING_5 )

	test	DWORD PTR [esi-128], 512		; 00000200H
	je	SHORT $LN4@tree_copy

; 5848 :     { char *s = mycalloc(strlen(enode->op5.string)+1,sizeof(char));

	mov	eax, DWORD PTR [esi]
	lea	edx, DWORD PTR [eax+1]
$LL28@tree_copy:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL28@tree_copy
	push	5848					; 000016d8H
	sub	eax, edx
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	inc	eax
	push	1
	push	eax
	call	_kb_calloc

; 5849 :       strcpy(s,enode->op5.string);

	mov	edx, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	mov	edi, eax
$LL20@tree_copy:
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [edi], cl
	inc	edx
	inc	edi
	test	cl, cl
	jne	SHORT $LL20@tree_copy

; 5850 :       enode->op5.string = s;

	mov	DWORD PTR [esi], eax
$LN4@tree_copy:

; 5851 :     }
; 5852 :     if ( enode->flags & HAS_LOCALLIST )

	test	DWORD PTR [esi-128], 256		; 00000100H
	je	SHORT $LN7@tree_copy

; 5853 :     { struct locallist_t *locals =
; 5854 :          (struct locallist_t *)mycalloc(1,sizeof(struct locallist_t));

	push	5854					; 000016deH
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	push	24					; 00000018H
	push	1
	call	_kb_calloc
	mov	edi, eax

; 5855 :       *locals = *enode->op5.locals;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edi], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edi+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [edi+12], edx
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edi+16], ecx
	mov	edx, DWORD PTR [eax+20]

; 5856 :       locals->list = (struct localvar_t *)mycalloc(enode->op5.locals->count,
; 5857 :                              sizeof(struct localvar_t));

	push	5857					; 000016e1H
	mov	DWORD PTR [edi+20], edx
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+8]
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	push	224					; 000000e0H
	push	ecx
	call	_kb_calloc
	mov	DWORD PTR [edi], eax

; 5858 :       memcpy(locals->list,enode->op5.locals->list,enode->op5.locals->count*
; 5859 :                               sizeof(struct localvar_t));

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx]
	imul	edx, 224				; 000000e0H
	push	edx
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 44					; 0000002cH

; 5860 :       enode->op5.locals = locals;

	mov	DWORD PTR [esi], edi
$LN7@tree_copy:

; 5839 :   dest->start[1].type = SETUP_FRAME_NODE;
; 5840 :   /* make copies of strings and locallists */
; 5841 :   for ( enode=dest->start+2, n = 0 ; n < count ; enode++,n++ )

	add	esi, 168				; 000000a8H
	dec	DWORD PTR tv134[ebp]
	jne	$LL8@tree_copy
	mov	edx, DWORD PTR _count$[ebp]
$LN6@tree_copy:

; 5861 :     }
; 5862 :   }
; 5863 :   /* copy root to first place */
; 5864 :   dest->start[0] = *src;

	mov	esi, DWORD PTR _src$[ebp]
	mov	edi, DWORD PTR [ebx]
	mov	ecx, 42					; 0000002aH
	rep movsd

; 5865 :   if ( dest->start[0].left ) dest->start[0].left += (int)count+1;

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+4], 0
	pop	edi
	pop	esi
	je	SHORT $LN2@tree_copy
	lea	ecx, DWORD PTR [edx+1]
	add	DWORD PTR [eax+4], ecx
$LN2@tree_copy:

; 5866 :   if ( dest->start[0].right ) dest->start[0].right += (int)count+1;

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@tree_copy
	lea	ecx, DWORD PTR [edx+1]
	add	DWORD PTR [eax+8], ecx
$LN1@tree_copy:

; 5867 : 
; 5868 :   /* FINISH node */
; 5869 :   dest->start[count+2].type = FINISHED_NODE;

	mov	eax, DWORD PTR [ebx]
	add	edx, 2
	imul	edx, 168				; 000000a8H

; 5870 : 
; 5871 :   stack_usage(dest);

	push	ebx
	mov	DWORD PTR [edx+eax], 10386		; 00002892H
	call	_stack_usage
	add	esp, 4
$LN17@tree_copy:
	pop	ebx

; 5872 : }  /* end tree_copy() */

	mov	esp, ebp
	pop	ebp
	ret	0
_tree_copy ENDP
_TEXT	ENDS
PUBLIC	_perm_tree_copy
EXTRN	_calloc:PROC
EXTRN	_free:PROC
; Function compile flags: /Ogtp
;	COMDAT _perm_tree_copy
_TEXT	SEGMENT
_count$ = -4						; size = 4
tv362 = 8						; size = 4
_enode$ = 8						; size = 4
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_perm_tree_copy PROC					; COMDAT

; 5888 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 5889 :   struct treenode *enode;
; 5890 :   size_t count,n;
; 5891 :   if ( dest == NULL ) return;

	mov	ebx, DWORD PTR _dest$[ebp]
	test	ebx, ebx
	je	$LN15@perm_tree_

; 5892 :   if ( dest->start ) free((char*)dest->start);

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN13@perm_tree_
	push	eax
	call	_free
	add	esp, 4
$LN13@perm_tree_:

; 5893 :   if ( src == NULL )  

	mov	ecx, DWORD PTR _src$[ebp]
	test	ecx, ecx
	jne	SHORT $LN12@perm_tree_

; 5894 :   { dest->start = dest->root = NULL; return; }

	mov	DWORD PTR [ebx+4], ecx
	mov	DWORD PTR [ebx], ecx
	pop	ebx

; 5925 : 
; 5926 : } // end perm_tree_copy()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@perm_tree_:
	push	esi

; 5895 :   enode=src; 

	mov	eax, ecx
	push	edi
$LL11@perm_tree_:

; 5896 :   while ( enode->left || enode->right ) 

	mov	edx, DWORD PTR [eax+4]
	test	edx, edx
	jne	SHORT $LN9@perm_tree_
	cmp	DWORD PTR [eax+8], edx
	je	SHORT $LN10@perm_tree_
$LN9@perm_tree_:

; 5897 :   { if ( enode->left < enode->right ) enode+=enode->left;

	mov	esi, DWORD PTR [eax+8]
	cmp	edx, esi
	jge	SHORT $LN8@perm_tree_
	imul	edx, 168				; 000000a8H
	add	eax, edx
	jmp	SHORT $LL11@perm_tree_
$LN8@perm_tree_:

; 5898 :     else enode += enode->right;

	imul	esi, 168				; 000000a8H
	add	eax, esi

; 5899 :   }

	jmp	SHORT $LL11@perm_tree_
$LN10@perm_tree_:

; 5900 :   count = src - enode + 1;

	sub	ecx, eax
	mov	DWORD PTR _enode$[ebp], eax
	mov	eax, 818089009				; 30c30c31H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	lea	esi, DWORD PTR [edx+eax+1]

; 5901 :   dest->start = (struct treenode *)calloc(count+3,sizeof(struct treenode));

	lea	ecx, DWORD PTR [esi+3]
	push	168					; 000000a8H
	push	ecx
	mov	DWORD PTR _count$[ebp], esi
	call	_calloc

; 5902 :   dest->flag |= USERCOPY;
; 5903 :   memcpy((char*)(dest->start+2),(char*)enode,count*sizeof(struct treenode));

	mov	edx, DWORD PTR _enode$[ebp]
	or	DWORD PTR [ebx+12], 1
	mov	edi, esi
	imul	edi, 168				; 000000a8H
	push	edi
	mov	DWORD PTR [ebx], eax
	push	edx
	add	eax, 336				; 00000150H
	push	eax
	call	_memcpy

; 5904 :   dest->root = dest->start + count + 1;

	mov	eax, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [edi+eax+168]
	add	esp, 20					; 00000014H
	mov	DWORD PTR [ebx+4], ecx

; 5905 :   dest->start[1].type = SETUP_FRAME_NODE;

	mov	DWORD PTR [eax+168], 10001		; 00002711H

; 5906 :   /* make copies of strings */
; 5907 :   for ( enode=dest->start+2, n = 0 ; n < count ; enode++,n++ )

	mov	eax, DWORD PTR [ebx]
	test	esi, esi
	je	SHORT $LN4@perm_tree_

; 5900 :   count = src - enode + 1;

	add	eax, 360				; 00000168H
	mov	DWORD PTR tv362[ebp], eax
	npad	7
$LL6@perm_tree_:

; 5908 :   { if ( enode->flags & HAS_STRING )

	test	BYTE PTR [eax], 32			; 00000020H
	je	SHORT $LN25@perm_tree_

; 5909 :     { char *s = calloc(strlen(enode->op1.string)+1,sizeof(char));

	mov	edi, DWORD PTR [eax+8]
	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL23@perm_tree_:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL23@perm_tree_
	sub	eax, edx
	inc	eax
	push	1
	push	eax
	call	_calloc

; 5910 :       strcpy(s,enode->op1.string);

	mov	edx, edi
	add	esp, 8
	mov	edi, eax
	npad	7
$LL17@perm_tree_:
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [edi], cl
	inc	edx
	inc	edi
	test	cl, cl
	jne	SHORT $LL17@perm_tree_

; 5911 :       enode->op1.string = s;

	mov	edx, DWORD PTR tv362[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	eax, edx
$LN25@perm_tree_:

; 5912 :     }
; 5913 :     enode->flags |= PERMNODE;

	or	DWORD PTR [eax], 128			; 00000080H
	add	eax, 168				; 000000a8H
	dec	esi
	mov	DWORD PTR tv362[ebp], eax
	jne	SHORT $LL6@perm_tree_
$LN4@perm_tree_:

; 5914 :   }
; 5915 :   /* copy root to first place */
; 5916 :   dest->start[0] = *src;

	mov	esi, DWORD PTR _src$[ebp]
	mov	edi, DWORD PTR [ebx]
	mov	ecx, 42					; 0000002aH
	rep movsd

; 5917 :   if ( dest->start[0].left ) dest->start[0].left += (int)count + 1;

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _count$[ebp]
	pop	edi
	pop	esi
	je	SHORT $LN2@perm_tree_
	lea	edx, DWORD PTR [ecx+1]
	add	DWORD PTR [eax+4], edx
$LN2@perm_tree_:

; 5918 :   if ( dest->start[0].right ) dest->start[0].right += (int)count + 1;

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN1@perm_tree_
	lea	edx, DWORD PTR [ecx+1]
	add	DWORD PTR [eax+8], edx
$LN1@perm_tree_:

; 5919 :   dest->start[0].flags |= PERMNODE;

	mov	eax, DWORD PTR [ebx]
	or	DWORD PTR [eax+24], 128			; 00000080H

; 5920 : 
; 5921 :   /* FINISH node */
; 5922 :   dest->start[count+2].type = FINISHED_NODE;

	mov	eax, DWORD PTR [ebx]
	add	ecx, 2
	imul	ecx, 168				; 000000a8H

; 5923 : 
; 5924 :   stack_usage(dest);

	push	ebx
	mov	DWORD PTR [ecx+eax], 10386		; 00002892H
	call	_stack_usage
	add	esp, 4
$LN15@perm_tree_:
	pop	ebx

; 5925 : 
; 5926 : } // end perm_tree_copy()

	mov	esp, ebp
	pop	ebp
	ret	0
_perm_tree_copy ENDP
_TEXT	ENDS
PUBLIC	_reduce_string
; Function compile flags: /Ogtp
;	COMDAT _reduce_string
_TEXT	SEGMENT
_s$ = 8							; size = 4
_reduce_string PROC					; COMDAT

; 5937 : { char *c = s;

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _s$[ebp]

; 5938 :   while ( *s ) /* reduce escape sequences */

	mov	dl, BYTE PTR [ecx]
	mov	eax, ecx
	test	dl, dl
	je	SHORT $LN20@reduce_str
	push	esi
	npad	1
$LL15@reduce_str:

; 5939 :   if ( *s == '\\' )

	cmp	dl, 92					; 0000005cH
	jne	SHORT $LN13@reduce_str

; 5940 :   { 
; 5941 :     switch ( s[1] )

	mov	dl, BYTE PTR [ecx+1]
	movsx	esi, dl
	add	esi, -92				; ffffffa4H
	cmp	esi, 24					; 00000018H
	ja	SHORT $LN4@reduce_str
	movzx	esi, BYTE PTR $LN19@reduce_str[esi]
	jmp	DWORD PTR $LN22@reduce_str[esi*4]
$LN10@reduce_str:

; 5942 :     { case 'n' : *(c++) = '\n'; s += 2; break;

	mov	BYTE PTR [eax], 10			; 0000000aH
	inc	eax
	add	ecx, 2
	jmp	SHORT $LN1@reduce_str
$LN9@reduce_str:

; 5943 :       case 't' : *(c++) = '\t'; s += 2; break;

	mov	BYTE PTR [eax], 9
	inc	eax
	add	ecx, 2
	jmp	SHORT $LN1@reduce_str
$LN8@reduce_str:

; 5944 :       case 'b' : *(c++) = '\b'; s += 2; break;

	mov	BYTE PTR [eax], 8
	inc	eax
	add	ecx, 2
	jmp	SHORT $LN1@reduce_str
$LN7@reduce_str:

; 5945 :       case 'r' : *(c++) = '\r'; s += 2; break;

	mov	BYTE PTR [eax], 13			; 0000000dH
	inc	eax
	add	ecx, 2
	jmp	SHORT $LN1@reduce_str
$LN6@reduce_str:

; 5946 :       case '\\' : *(c++) = '\\'; s += 2; break;

	mov	BYTE PTR [eax], 92			; 0000005cH
	inc	eax
	add	ecx, 2
	jmp	SHORT $LN1@reduce_str
$LN5@reduce_str:

; 5947 :       case 'q' : *(c++) = '"'; s += 2; break;

	mov	BYTE PTR [eax], 34			; 00000022H
	inc	eax
	add	ecx, 2
	jmp	SHORT $LN1@reduce_str
$LN4@reduce_str:

; 5948 :       default:  *(c++) =  s[1]; s += 2; break;

	mov	BYTE PTR [eax], dl
	inc	eax
	add	ecx, 2

; 5949 :     }
; 5950 :   }
; 5951 :   else if (*s == '\n' ) s++;  /* omit newlines */

	jmp	SHORT $LN1@reduce_str
$LN13@reduce_str:
	cmp	dl, 10					; 0000000aH
	je	SHORT $LN21@reduce_str

; 5952 :   else *(c++) = *(s++);

	mov	BYTE PTR [eax], dl
	inc	eax
$LN21@reduce_str:
	inc	ecx
$LN1@reduce_str:

; 5938 :   while ( *s ) /* reduce escape sequences */

	mov	dl, BYTE PTR [ecx]
	test	dl, dl
	jne	SHORT $LL15@reduce_str
	pop	esi
$LN20@reduce_str:

; 5953 :   *c = '\0';

	mov	BYTE PTR [eax], 0

; 5954 : 
; 5955 : } // end reduce_string()

	pop	ebp
	ret	0
$LN22@reduce_str:
	DD	$LN6@reduce_str
	DD	$LN8@reduce_str
	DD	$LN10@reduce_str
	DD	$LN5@reduce_str
	DD	$LN7@reduce_str
	DD	$LN9@reduce_str
	DD	$LN4@reduce_str
$LN19@reduce_str:
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	6
	DB	6
	DB	3
	DB	4
	DB	6
	DB	5
_reduce_string ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@BIPLPNAL@Could?5not?5link?5edge?5?$CFs?5onto?5face@ ; `string'
PUBLIC	??_C@_0DG@HFHJDECL@Need?5to?5set?5the?5body?8s?5facet?5bef@ ; `string'
PUBLIC	??_C@_0DI@EMDFOILH@Not?5unbodying?5edge?5?$CFs?5since?5woul@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_0CL@EOCLCGCK@Trying?5to?5set?5body?5of?5wrong?5type@ ; `string'
PUBLIC	_set_body
EXTRN	_new_facetedge:PROC
EXTRN	_apply_method_num:PROC
EXTRN	_free_element:PROC
EXTRN	_set_facet_fe:PROC
EXTRN	_unapply_method:PROC
EXTRN	_msg:DWORD
EXTRN	_elnames:BYTE
EXTRN	_set_facet_body:PROC
;	COMDAT ??_C@_0CN@BIPLPNAL@Could?5not?5link?5edge?5?$CFs?5onto?5face@
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\inline.h
CONST	SEGMENT
??_C@_0CN@BIPLPNAL@Could?5not?5link?5edge?5?$CFs?5onto?5face@ DB 'Could n'
	DB	'ot link edge %s onto facet %s chain.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HFHJDECL@Need?5to?5set?5the?5body?8s?5facet?5bef@
CONST	SEGMENT
??_C@_0DG@HFHJDECL@Need?5to?5set?5the?5body?8s?5facet?5bef@ DB 'Need to s'
	DB	'et the body''s facet before assigning edges.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@EMDFOILH@Not?5unbodying?5edge?5?$CFs?5since?5woul@
CONST	SEGMENT
??_C@_0DI@EMDFOILH@Not?5unbodying?5edge?5?$CFs?5since?5woul@ DB 'Not unbo'
	DB	'dying edge %s since would make facet two arcs.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EOCLCGCK@Trying?5to?5set?5body?5of?5wrong?5type@
CONST	SEGMENT
??_C@_0CL@EOCLCGCK@Trying?5to?5set?5body?5of?5wrong?5type@ DB 'Trying to '
	DB	'set body of wrong type element.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\evalmore.c
CONST	ENDS
;	COMDAT _set_body
_TEXT	SEGMENT
tv890 = -24						; size = 4
_prev_fe$93430 = -24					; size = 4
_inserted_flag$93476 = -20				; size = 4
tv807 = -16						; size = 4
_start_fe$93473 = -12					; size = 4
_f_id$93469 = -8					; size = 4
_f_id$93431 = -8					; size = 4
_newfe$93474 = -4					; size = 4
_id$ = 8						; size = 4
_b_id$ = 12						; size = 4
_set_body PROC						; COMDAT

; 5969 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	edi

; 5970 :   if ( id_type(id) == FACET )

	mov	edi, DWORD PTR _id$[ebp]
	mov	eax, edi
	shr	eax, 29					; 0000001dH
	cmp	eax, 2
	jne	SHORT $LN38@set_body

; 5971 :   {
; 5972 :     set_facet_body(id,b_id);

	mov	eax, DWORD PTR _b_id$[ebp]
	push	eax
	push	edi
	call	_set_facet_body
	add	esp, 8
	pop	edi

; 6100 :     }
; 6101 :   }
; 6102 : } /* end set_body() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN38@set_body:

; 5973 : 
; 5974 :     return;
; 5975 :   }
; 5976 : 
; 5977 :   /* STRING model only hereafter! */
; 5978 : 
; 5979 :   if ( (id_type(id) != EDGE) || (web.representation != STRING) )

	cmp	eax, 1
	jne	SHORT $LN36@set_body
	cmp	DWORD PTR _web+624, eax
	je	SHORT $LN37@set_body
$LN36@set_body:

; 5980 :   { sprintf(errmsg,"Trying to set body of wrong type element.\n");

	push	OFFSET ??_C@_0CL@EOCLCGCK@Trying?5to?5set?5body?5of?5wrong?5type@
	push	OFFSET _errmsg
	call	_sprintf

; 5981 :     kb_error(2056,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2056					; 00000808H
	call	_kb_error
	add	esp, 20					; 00000014H
$LN37@set_body:

; 5982 :   }
; 5983 :   if ( !valid_id(b_id) )

	mov	eax, DWORD PTR _b_id$[ebp]
	push	ebx
	push	esi
	test	eax, 268435456				; 10000000H
	jne	$LN35@set_body

; 5984 :   { facetedge_id fe,fe_id,next_fe,prev_fe;
; 5985 :     facet_id f_id;
; 5986 :     body_id bb_id;
; 5987 : 
; 5988 :     /* unsetting edge body, so dissolving facetedge */
; 5989 : 
; 5990 :     fe_id = get_edge_fe(id);

	mov	ecx, DWORD PTR _web+124
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv807[ebp], eax
	mov	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	jne	SHORT $LN48@set_body
	xor	esi, esi
	jmp	SHORT $LN49@set_body
$LN48@set_body:
	mov	eax, DWORD PTR [eax+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN47@set_body
	xor	eax, 134217728				; 08000000H
$LN47@set_body:
	mov	esi, eax
$LN49@set_body:

; 5991 :     f_id = get_fe_facet(fe_id);

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN52@set_body
	mov	ebx, DWORD PTR _NULLFACET
	jmp	SHORT $LN51@set_body
$LN52@set_body:
	mov	eax, DWORD PTR _web+460
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	ebx, DWORD PTR [ecx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN51@set_body
	xor	ebx, 134217728				; 08000000H
$LN51@set_body:
	mov	DWORD PTR _f_id$93431[ebp], ebx

; 5992 :     if ( !valid_id(f_id) ) return;

	test	ebx, 268435456				; 10000000H
	je	$LN97@set_body

; 5993 :     if ( inverted(f_id) ) 

	test	ebx, 134217728				; 08000000H
	je	SHORT $LN33@set_body

; 5994 :     { fe_id = get_next_facet(fe_id);

	push	esi
	call	_get_next_facet
	mov	esi, eax

; 5995 :       f_id = get_fe_facet(fe_id);

	push	esi
	call	_get_fe_facet
	mov	ebx, eax
	add	esp, 8
	mov	DWORD PTR _f_id$93431[ebp], ebx
$LN33@set_body:

; 5996 :     } 
; 5997 :     if ( !valid_id(f_id) ) return;

	test	ebx, 268435456				; 10000000H
	je	$LN97@set_body

; 5998 :     if ( inverted(f_id) ) return; 

	test	ebx, 134217728				; 08000000H
	jne	$LN97@set_body

; 5999 : 
; 6000 :     /* check for being at beginning or end of edge arc */
; 6001 :     fe = fe_id;
; 6002 :     if ( valid_id(get_next_edge(fe)) && valid_id(get_prev_edge(fe)) )

	push	esi
	mov	edi, esi
	call	_get_next_edge
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	$LN25@set_body
	push	esi
	call	_get_prev_edge
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	$LN25@set_body
$LL29@set_body:

; 6003 :     { /* check for full loop */
; 6004 :       do { fe = get_next_edge(fe); }

	push	edi
	call	_get_next_edge
	mov	edi, eax
	add	esp, 4

; 6005 :       while ( valid_id(fe) && !equal_id(fe,fe_id) );

	test	edi, 268435456				; 10000000H
	je	SHORT $LN100@set_body
	cmp	edi, esi
	jne	SHORT $LL29@set_body

; 6006 :       if ( !valid_id(fe) )

	test	edi, 268435456				; 10000000H
	jne	SHORT $LN25@set_body
$LN100@set_body:

; 6007 :       { if ( verbose_flag )

	cmp	DWORD PTR _verbose_flag, 0
	je	$LN97@set_body

; 6008 :         { sprintf(msg,"Not unbodying edge %s since would make facet two arcs.\n",
; 6009 :             ELNAME(id));

	test	DWORD PTR _id$[ebp], 268435456		; 10000000H
	je	SHORT $LN41@set_body
	mov	edx, DWORD PTR tv807[ebp]
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN42@set_body
$LN41@set_body:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN42@set_body:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0DI@EMDFOILH@Not?5unbodying?5edge?5?$CFs?5since?5woul@
	push	eax
	call	_sprintf

; 6010 :           outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebx
	pop	edi

; 6100 :     }
; 6101 :   }
; 6102 : } /* end set_body() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@set_body:

; 6011 :         }
; 6012 :         return;
; 6013 :       }
; 6014 :     }
; 6015 :     /* Okay, ready to party. */
; 6016 :     if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN22@set_body

; 6017 :     { bb_id = get_facet_body(f_id);

	push	ebx
	call	_get_facet_body
	add	esp, 4

; 6018 :       if ( valid_id(bb_id)  )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN22@set_body

; 6019 :       { unapply_method(id,get_body_volmeth(bb_id));

	mov	edx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+412]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_unapply_method
	add	esp, 8
$LN22@set_body:

; 6020 :       }
; 6021 :     }
; 6022 :     next_fe = get_next_edge(fe_id);

	push	esi
	call	_get_next_edge

; 6023 :     prev_fe = get_prev_edge(fe_id);

	push	esi
	mov	ebx, eax
	call	_get_prev_edge

; 6024 :     if ( valid_id(next_fe) ) 

	mov	edi, ebx
	shr	edi, 28					; 0000001cH
	add	esp, 8
	and	edi, 1
	mov	DWORD PTR _prev_fe$93430[ebp], eax
	je	SHORT $LN21@set_body

; 6025 :     { set_prev_edge(next_fe,NULLID);

	push	0
	push	ebx
	call	_set_prev_edge

; 6026 :       set_facet_fe(f_id,next_fe);

	mov	eax, DWORD PTR _f_id$93431[ebp]
	push	ebx
	push	eax
	call	_set_facet_fe
	add	esp, 16					; 00000010H
$LN21@set_body:

; 6027 :     }
; 6028 :     if ( valid_id(prev_fe) )

	mov	eax, DWORD PTR _prev_fe$93430[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN20@set_body

; 6029 :       set_next_edge(prev_fe,NULLID);

	push	0
	push	eax
	call	_set_next_edge
	jmp	SHORT $LN101@set_body
$LN20@set_body:

; 6030 :     else if ( !valid_id(next_fe) ) 

	test	edi, edi
	jne	SHORT $LN18@set_body

; 6031 :       set_facet_fe(f_id,NULLID);

	mov	ecx, DWORD PTR _f_id$93431[ebp]
	push	edi
	push	ecx
	call	_set_facet_fe
$LN101@set_body:
	add	esp, 8
$LN18@set_body:

; 6032 :     if ( valid_id(get_next_facet(fe_id)) )

	push	esi
	call	_get_next_facet
	add	esp, 4
	test	eax, 268435456				; 10000000H
	je	SHORT $LN17@set_body

; 6033 :       set_edge_fe(id,get_next_facet(fe_id));

	push	esi
	call	_get_next_facet
	mov	edx, DWORD PTR _id$[ebp]
	push	eax
	push	edx
	call	_set_edge_fe
	add	esp, 12					; 0000000cH
$LN17@set_body:

; 6034 :     set_next_facet(get_prev_facet(fe_id),get_next_facet(fe_id));

	push	esi
	call	_get_next_facet
	add	esp, 4
	push	eax
	push	esi
	call	_get_prev_facet
	add	esp, 4
	push	eax
	call	_set_next_facet

; 6035 :     set_prev_facet(get_next_facet(fe_id),get_prev_facet(fe_id));

	push	esi
	call	_get_prev_facet
	add	esp, 12					; 0000000cH
	push	eax
	push	esi
	call	_get_next_facet
	add	esp, 4
	push	eax
	call	_set_prev_facet

; 6036 :     free_element(fe_id);

	push	esi
	call	_free_element
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebx
	pop	edi

; 6100 :     }
; 6101 :   }
; 6102 : } /* end set_body() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@set_body:

; 6037 :   }
; 6038 :   else /* valid id */
; 6039 :   { /* string model */
; 6040 :     facet_id f_id = get_body_facet(b_id);

	and	eax, 134217727				; 07ffffffH
	add	eax, eax
	lea	esi, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [esi+eax]
	mov	edi, DWORD PTR [ecx+400]

; 6041 :     facetedge_id efe,eefe,fe,start_fe;
; 6042 :     facetedge_id newfe;
; 6043 :     body_id bb_id;
; 6044 :     int inserted_flag=0;  /* whether a linkup made */
; 6045 : 
; 6046 :     if ( !valid_id(f_id) )

	mov	eax, edi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	DWORD PTR _f_id$93469[ebp], edi
	mov	DWORD PTR _inserted_flag$93476[ebp], 0
	mov	DWORD PTR tv890[ebp], eax
	jne	SHORT $LN15@set_body

; 6047 :     { sprintf(errmsg,
; 6048 :             "Need to set the body's facet before assigning edges.\n");

	push	OFFSET ??_C@_0DG@HFHJDECL@Need?5to?5set?5the?5body?8s?5facet?5bef@
	push	OFFSET _errmsg
	call	_sprintf

; 6049 :       kb_error(2057,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2057					; 00000809H
	call	_kb_error
	add	esp, 20					; 00000014H
$LN15@set_body:

; 6050 :     }
; 6051 :     if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN14@set_body

; 6052 :     { bb_id = get_facet_body(f_id);

	push	edi
	call	_get_facet_body
	add	esp, 4

; 6053 :       if ( valid_id(bb_id) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN95@set_body

; 6054 :       { unapply_method(id,get_body_volmeth(bb_id));

	mov	edx, DWORD PTR _web+348
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+412]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_unapply_method
	add	esp, 8
$LN95@set_body:

; 6055 :       }
; 6056 :       apply_method_num(id,get_body_volmeth(b_id));

	mov	eax, DWORD PTR _web+348
	mov	ecx, DWORD PTR [esi+eax]
	mov	edx, DWORD PTR [ecx+412]
	mov	eax, DWORD PTR _id$[ebp]
	push	edx
	push	eax
	call	_apply_method_num
	add	esp, 8
$LN14@set_body:

; 6057 :     }
; 6058 :     newfe = new_facetedge(f_id,id);

	mov	edi, DWORD PTR _id$[ebp]
	mov	ecx, DWORD PTR _f_id$93469[ebp]
	push	edi
	push	ecx
	call	_new_facetedge

; 6059 :     efe = get_edge_fe(id);

	mov	edx, DWORD PTR _web+124
	mov	ebx, eax
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	DWORD PTR tv807[ebp], eax
	mov	eax, DWORD PTR [edx+eax*4]
	add	esp, 8
	mov	DWORD PTR _newfe$93474[ebp], ebx
	test	eax, eax
	jne	SHORT $LN60@set_body
	xor	esi, esi
	jmp	SHORT $LN61@set_body
$LN60@set_body:
	mov	eax, DWORD PTR [eax+28]
	test	edi, 134217728				; 08000000H
	je	SHORT $LN59@set_body
	xor	eax, 134217728				; 08000000H
$LN59@set_body:
	mov	esi, eax
$LN61@set_body:

; 6060 :     if ( valid_id(get_fe_facet(efe)) )

	mov	eax, esi
	shr	eax, 28					; 0000001cH
	and	eax, 1
	jne	SHORT $LN64@set_body
	mov	ecx, DWORD PTR _NULLFACET
	jmp	SHORT $LN63@set_body
$LN64@set_body:
	mov	edx, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [ecx+24]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN63@set_body
	xor	ecx, 134217728				; 08000000H
$LN63@set_body:
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN12@set_body

; 6061 :     { eefe = get_next_facet(efe);

	push	esi
	call	_get_next_facet

; 6062 :       set_next_facet(efe,newfe);

	push	ebx
	push	esi
	mov	edi, eax
	call	_set_next_facet

; 6063 :       set_next_facet(newfe,eefe);

	push	edi
	push	ebx
	call	_set_next_facet

; 6064 :       set_prev_facet(eefe,newfe);

	push	ebx
	push	edi
	call	_set_prev_facet

; 6065 :       set_prev_facet(newfe,efe);

	push	esi
	push	ebx
	call	_set_prev_facet
	add	esp, 36					; 00000024H

; 6066 :     }
; 6067 :     else

	jmp	SHORT $LN11@set_body
$LN12@set_body:

; 6068 :     { if (valid_id(efe)) free_element(efe);

	test	eax, eax
	je	SHORT $LN10@set_body
	push	esi
	call	_free_element
	add	esp, 4
$LN10@set_body:

; 6069 :       set_next_facet(newfe,newfe);

	push	ebx
	push	ebx
	call	_set_next_facet

; 6070 :       set_prev_facet(newfe,newfe);

	push	ebx
	push	ebx
	call	_set_prev_facet

; 6071 :       set_edge_fe(id,newfe);

	push	ebx
	push	edi
	call	_set_edge_fe
	add	esp, 24					; 00000018H
$LN11@set_body:

; 6072 :     }
; 6073 :     /* see if can place at head or end of chain */
; 6074 :     fe = start_fe = get_facet_fe(f_id);

	cmp	DWORD PTR tv890[ebp], 0
	mov	eax, DWORD PTR _f_id$93469[ebp]
	jne	SHORT $LN68@set_body
	xor	esi, esi
	jmp	SHORT $LN67@set_body
$LN68@set_body:
	mov	ecx, DWORD PTR _web+236
	mov	edx, eax
	and	edx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	esi, DWORD PTR [edx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN67@set_body
	xor	esi, 134217728				; 08000000H
$LN67@set_body:
	mov	DWORD PTR _start_fe$93473[ebp], esi

; 6075 :     if ( !valid_id(fe) )

	test	esi, 268435456				; 10000000H
	jne	SHORT $LN9@set_body

; 6076 :     { /* naked facet */
; 6077 :       set_facet_fe(f_id,newfe); inserted_flag = 1;

	push	ebx
	push	eax
	call	_set_facet_fe
	add	esp, 8
	pop	esi
	pop	ebx
	pop	edi

; 6100 :     }
; 6101 :   }
; 6102 : } /* end set_body() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@set_body:

; 6078 :     }
; 6079 :     else
; 6080 :     { if ( !valid_id(get_prev_edge(fe)) )

	push	esi
	call	_get_prev_edge

; 6081 :       { if ( equal_id(get_fe_tailv(fe),get_edge_headv(id)) )

	mov	edi, DWORD PTR _web+460
	add	esp, 4
	test	eax, 268435456				; 10000000H
	jne	SHORT $LL5@set_body
	mov	eax, DWORD PTR _start_fe$93473[ebp]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+ecx*4]
	and	eax, 134217728				; 08000000H
	xor	eax, DWORD PTR [edx+20]
	push	eax
	call	_get_edge_tailv
	mov	ebx, eax
	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	call	_get_edge_headv
	add	esp, 8
	cmp	ebx, eax

; 6082 :         { set_next_edge(newfe,fe); set_prev_edge(fe,newfe); 

	mov	ebx, DWORD PTR _newfe$93474[ebp]
	jne	SHORT $LL5@set_body
	mov	edi, DWORD PTR _start_fe$93473[ebp]
	push	edi
	push	ebx
	call	_set_next_edge
	push	ebx
	push	edi
	call	_set_prev_edge

; 6083 :           set_facet_fe(f_id,newfe); inserted_flag = 1;

	mov	ecx, DWORD PTR _f_id$93469[ebp]
	push	ebx
	push	ecx
	call	_set_facet_fe
	mov	edi, DWORD PTR _web+460
	add	esp, 24					; 00000018H
	mov	DWORD PTR _inserted_flag$93476[ebp], 1
$LL5@set_body:

; 6084 :         }
; 6085 :       }
; 6086 :       while ( valid_id(get_next_edge(fe)) &&
; 6087 :                         !equal_id(get_next_edge(fe),start_fe) )

	mov	edx, esi
	shr	edx, 27					; 0000001bH
	and	edx, 1
	je	SHORT $LN74@set_body
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+eax*4]
	mov	ecx, DWORD PTR [eax+28]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN73@set_body
$LN74@set_body:
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+ecx*4]
	mov	ecx, DWORD PTR [eax+32]
$LN73@set_body:
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN4@set_body
	test	edx, edx
	je	SHORT $LN78@set_body
	mov	ecx, DWORD PTR [eax+28]
	xor	ecx, 134217728				; 08000000H
	jmp	SHORT $LN77@set_body
$LN78@set_body:
	mov	ecx, DWORD PTR [eax+32]
$LN77@set_body:

; 6088 :            fe = get_next_edge(fe);

	mov	ebx, DWORD PTR _newfe$93474[ebp]
	cmp	ecx, DWORD PTR _start_fe$93473[ebp]
	je	SHORT $LN4@set_body
	test	edx, edx
	je	SHORT $LN82@set_body
	mov	esi, DWORD PTR [eax+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LL5@set_body
$LN82@set_body:
	mov	esi, DWORD PTR [eax+32]
	jmp	SHORT $LL5@set_body
$LN4@set_body:

; 6089 :       if ( !valid_id(get_next_edge(fe)) )

	push	esi
	call	_get_next_edge
	add	esp, 4
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN2@set_body

; 6090 :       { if ( equal_id(get_fe_headv(fe),get_edge_tailv(id)) )

	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+edx*4]
	mov	ecx, esi
	and	ecx, 134217728				; 08000000H
	xor	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_get_edge_headv
	mov	edx, DWORD PTR _id$[ebp]
	push	edx
	mov	edi, eax
	call	_get_edge_tailv
	add	esp, 8
	cmp	edi, eax
	jne	SHORT $LN2@set_body

; 6091 :         { set_next_edge(fe,newfe); set_prev_edge(newfe,fe); 

	push	ebx
	push	esi
	call	_set_next_edge
	push	esi
	push	ebx
	call	_set_prev_edge
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebx
	pop	edi

; 6100 :     }
; 6101 :   }
; 6102 : } /* end set_body() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@set_body:

; 6092 :           inserted_flag = 1;
; 6093 :         }
; 6094 :       }
; 6095 :     }
; 6096 :     if ( !inserted_flag ) 

	cmp	DWORD PTR _inserted_flag$93476[ebp], 0
	jne	$LN97@set_body

; 6097 :     { sprintf(errmsg,"Could not link edge %s onto facet %s chain.\n",
; 6098 :            ELNAME(id),ELNAME1(f_id));

	cmp	DWORD PTR tv890[ebp], 0
	je	SHORT $LN43@set_body
	mov	eax, DWORD PTR _f_id$93469[ebp]
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN44@set_body
$LN43@set_body:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN44@set_body:
	test	DWORD PTR _id$[ebp], 268435456		; 10000000H
	je	SHORT $LN45@set_body
	mov	eax, DWORD PTR tv807[ebp]
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN46@set_body
$LN45@set_body:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN46@set_body:
	push	esi
	push	eax
	push	OFFSET ??_C@_0CN@BIPLPNAL@Could?5not?5link?5edge?5?$CFs?5onto?5face@
	push	OFFSET _errmsg
	call	_sprintf

; 6099 :       kb_error(2058,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2058					; 0000080aH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN97@set_body:
	pop	esi
	pop	ebx
	pop	edi

; 6100 :     }
; 6101 :   }
; 6102 : } /* end set_body() */

	mov	esp, ebp
	pop	ebp
	ret	0
_set_body ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@BICBNOL@Using?5MKL?4?5?$AA@		; `string'
PUBLIC	??_C@_0L@JKJMIGOC@?$CIwas?5MKL?$CJ?6?$AA@	; `string'
PUBLIC	??_C@_0CJ@BBPOLAAA@Using?5Metis?5ordering?5in?5ysmp?5fac@ ; `string'
PUBLIC	??_C@_0BD@PLMHICLH@?$CIwas?5alt?5min?5deg?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0N@GCFHHGHB@Using?5YSMP?4?5?$AA@		; `string'
PUBLIC	??_C@_0N@GFPJKKAK@?$CIwas?5metis?$CJ?6?$AA@	; `string'
PUBLIC	??_C@_0M@NJDJPBGM@?$CIwas?5YSMP?$CJ?6?$AA@	; `string'
PUBLIC	??_C@_0CB@OBBIKMDC@Using?5alternate?5minimal?5degree?4?5@ ; `string'
PUBLIC	_change_hessian_functions
EXTRN	_mkl_solve_multi:PROC
EXTRN	_mkl_solve:PROC
EXTRN	_mkl_factor:PROC
EXTRN	_metis_order:PROC
EXTRN	_ysmp_solve_multi:PROC
EXTRN	_ysmp_solve:PROC
EXTRN	_ysmp_factor:PROC
EXTRN	_sp_CHinvC:PROC
EXTRN	_sp_CHinvC_func:DWORD
EXTRN	_sp_ordering_func:DWORD
EXTRN	_xmd_solve_multi:PROC
EXTRN	_sp_solve_multi_func:DWORD
EXTRN	_xmd_solve:PROC
EXTRN	_sp_solve_func:DWORD
EXTRN	_xmd_factor:PROC
EXTRN	_sp_factor_func:DWORD
EXTRN	_BK_hess_project_setup:PROC
EXTRN	_sp_hess_project_setup_func:DWORD
EXTRN	_bk_constraint_setup:PROC
EXTRN	_sp_constraint_setup_func:DWORD
EXTRN	_bk_AIJ_setup:PROC
EXTRN	_sp_AIJ_setup_func:DWORD
EXTRN	_bk_mul:PROC
EXTRN	_sp_mul_func:DWORD
;	COMDAT ??_C@_0M@BICBNOL@Using?5MKL?4?5?$AA@
CONST	SEGMENT
??_C@_0M@BICBNOL@Using?5MKL?4?5?$AA@ DB 'Using MKL. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JKJMIGOC@?$CIwas?5MKL?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0L@JKJMIGOC@?$CIwas?5MKL?$CJ?6?$AA@ DB '(was MKL)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@BBPOLAAA@Using?5Metis?5ordering?5in?5ysmp?5fac@
CONST	SEGMENT
??_C@_0CJ@BBPOLAAA@Using?5Metis?5ordering?5in?5ysmp?5fac@ DB 'Using Metis'
	DB	' ordering in ysmp factoring. ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PLMHICLH@?$CIwas?5alt?5min?5deg?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BD@PLMHICLH@?$CIwas?5alt?5min?5deg?$CJ?6?$AA@ DB '(was alt min deg'
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GCFHHGHB@Using?5YSMP?4?5?$AA@
CONST	SEGMENT
??_C@_0N@GCFHHGHB@Using?5YSMP?4?5?$AA@ DB 'Using YSMP. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GFPJKKAK@?$CIwas?5metis?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0N@GFPJKKAK@?$CIwas?5metis?$CJ?6?$AA@ DB '(was metis)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJDJPBGM@?$CIwas?5YSMP?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0M@NJDJPBGM@?$CIwas?5YSMP?$CJ?6?$AA@ DB '(was YSMP)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OBBIKMDC@Using?5alternate?5minimal?5degree?4?5@
CONST	SEGMENT
??_C@_0CB@OBBIKMDC@Using?5alternate?5minimal?5degree?4?5@ DB 'Using alter'
	DB	'nate minimal degree. ', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _change_hessian_functions
_TEXT	SEGMENT
_oldh$ = 8						; size = 4
_newh$ = 12						; size = 4
_change_hessian_functions PROC				; COMDAT

; 6114 : {

	push	ebp
	mov	ebp, esp

; 6115 :   if ( oldh == newh ) return;

	mov	eax, DWORD PTR _newh$[ebp]
	push	esi
	mov	esi, DWORD PTR _oldh$[ebp]
	cmp	esi, eax
	je	$LN32@change_hes

; 6116 :   switch ( newh )

	cmp	eax, 3
	ja	$LN34@change_hes
	jmp	DWORD PTR $LN37@change_hes[eax*4]
$LN28@change_hes:

; 6117 :   { case MINDEG_FACTORING:
; 6118 :       {
; 6119 :          sp_mul_func = bk_mul;
; 6120 :          sp_AIJ_setup_func= bk_AIJ_setup;
; 6121 :          sp_constraint_setup_func = bk_constraint_setup;
; 6122 :          sp_hess_project_setup_func= BK_hess_project_setup;
; 6123 :          sp_factor_func = xmd_factor;
; 6124 :          sp_solve_func = xmd_solve;
; 6125 :          sp_solve_multi_func = xmd_solve_multi;
; 6126 :          sp_ordering_func = NULL;
; 6127 :          sp_CHinvC_func = sp_CHinvC;
; 6128 :          outstring("Using alternate minimal degree. ");

	push	OFFSET ??_C@_0CB@OBBIKMDC@Using?5alternate?5minimal?5degree?4?5@
	mov	DWORD PTR _sp_mul_func, OFFSET _bk_mul
	mov	DWORD PTR _sp_AIJ_setup_func, OFFSET _bk_AIJ_setup
	mov	DWORD PTR _sp_constraint_setup_func, OFFSET _bk_constraint_setup
	mov	DWORD PTR _sp_hess_project_setup_func, OFFSET _BK_hess_project_setup
	mov	DWORD PTR _sp_factor_func, OFFSET _xmd_factor
	mov	DWORD PTR _sp_solve_func, OFFSET _xmd_solve
	mov	DWORD PTR _sp_solve_multi_func, OFFSET _xmd_solve_multi
	mov	DWORD PTR _sp_ordering_func, 0
	mov	DWORD PTR _sp_CHinvC_func, OFFSET _sp_CHinvC
	call	_outstring
	add	esp, 4

; 6129 :          switch ( oldh ) 

	cmp	esi, 3
	ja	$LN34@change_hes
	jmp	DWORD PTR $LN38@change_hes[esi*4]
$LN25@change_hes:

; 6130 :          {  case YSMP_FACTORING: outstring("(was YSMP)\n"); break;

	push	OFFSET ??_C@_0M@NJDJPBGM@?$CIwas?5YSMP?$CJ?6?$AA@

; 6195 :          {  case YSMP_FACTORING: outstring("(was YSMP)\n"); break;
; 6196 :             case MINDEG_FACTORING: outstring("(was alt min deg)\n"); break;
; 6197 :             case METIS_FACTORING: outstring("(was metis)\n"); break;
; 6198 :             case MKL_FACTORING: outstring("(was MKL)\n"); break;

	call	_outstring

; 6199 :          }
; 6200 :       }
; 6201 :       break;
; 6202 :  
; 6203 :   }
; 6204 :   ysmp_flag = newh;

	mov	eax, DWORD PTR _newh$[ebp]
	add	esp, 4
	mov	DWORD PTR _ysmp_flag, eax
	pop	esi

; 6205 : }  /* end change_hessian_functions() */

	pop	ebp
	ret	0
$LN23@change_hes:

; 6131 :             case MINDEG_FACTORING: outstring("(was alt min deg)\n"); break;
; 6132 :             case METIS_FACTORING: outstring("(was metis)\n"); break;

	push	OFFSET ??_C@_0N@GFPJKKAK@?$CIwas?5metis?$CJ?6?$AA@

; 6195 :          {  case YSMP_FACTORING: outstring("(was YSMP)\n"); break;
; 6196 :             case MINDEG_FACTORING: outstring("(was alt min deg)\n"); break;
; 6197 :             case METIS_FACTORING: outstring("(was metis)\n"); break;
; 6198 :             case MKL_FACTORING: outstring("(was MKL)\n"); break;

	call	_outstring

; 6199 :          }
; 6200 :       }
; 6201 :       break;
; 6202 :  
; 6203 :   }
; 6204 :   ysmp_flag = newh;

	mov	eax, DWORD PTR _newh$[ebp]
	add	esp, 4
	mov	DWORD PTR _ysmp_flag, eax
	pop	esi

; 6205 : }  /* end change_hessian_functions() */

	pop	ebp
	ret	0
$LN21@change_hes:

; 6133 :             case MKL_FACTORING: outstring("(was MKL)\n"); break;
; 6134 :          }
; 6135 :       }
; 6136 :       break;
; 6137 :      case YSMP_FACTORING:
; 6138 :       { 
; 6139 :          sp_mul_func = bk_mul;
; 6140 :          sp_AIJ_setup_func= bk_AIJ_setup;
; 6141 :          sp_constraint_setup_func = bk_constraint_setup;
; 6142 :          sp_hess_project_setup_func= BK_hess_project_setup;
; 6143 :          sp_factor_func = ysmp_factor;
; 6144 :          sp_CHinvC_func = sp_CHinvC;
; 6145 :          sp_solve_func = ysmp_solve;
; 6146 :          sp_solve_multi_func = ysmp_solve_multi;
; 6147 :          sp_ordering_func = NULL;
; 6148 :          outstring("Using YSMP. ");

	push	OFFSET ??_C@_0N@GCFHHGHB@Using?5YSMP?4?5?$AA@
	mov	DWORD PTR _sp_mul_func, OFFSET _bk_mul
	mov	DWORD PTR _sp_AIJ_setup_func, OFFSET _bk_AIJ_setup
	mov	DWORD PTR _sp_constraint_setup_func, OFFSET _bk_constraint_setup
	mov	DWORD PTR _sp_hess_project_setup_func, OFFSET _BK_hess_project_setup
	mov	DWORD PTR _sp_factor_func, OFFSET _ysmp_factor
	mov	DWORD PTR _sp_CHinvC_func, OFFSET _sp_CHinvC
	mov	DWORD PTR _sp_solve_func, OFFSET _ysmp_solve
	mov	DWORD PTR _sp_solve_multi_func, OFFSET _ysmp_solve_multi
	mov	DWORD PTR _sp_ordering_func, 0
	call	_outstring
	add	esp, 4

; 6149 :          switch ( oldh ) 

	cmp	esi, 3
	ja	$LN34@change_hes
	jmp	DWORD PTR $LN39@change_hes[esi*4]
$LN17@change_hes:

; 6150 :          {  case YSMP_FACTORING: outstring("(was YSMP)\n"); break;
; 6151 :             case MINDEG_FACTORING: outstring("(was alt min deg)\n"); break;

	push	OFFSET ??_C@_0BD@PLMHICLH@?$CIwas?5alt?5min?5deg?$CJ?6?$AA@

; 6195 :          {  case YSMP_FACTORING: outstring("(was YSMP)\n"); break;
; 6196 :             case MINDEG_FACTORING: outstring("(was alt min deg)\n"); break;
; 6197 :             case METIS_FACTORING: outstring("(was metis)\n"); break;
; 6198 :             case MKL_FACTORING: outstring("(was MKL)\n"); break;

	call	_outstring

; 6199 :          }
; 6200 :       }
; 6201 :       break;
; 6202 :  
; 6203 :   }
; 6204 :   ysmp_flag = newh;

	mov	eax, DWORD PTR _newh$[ebp]
	add	esp, 4
	mov	DWORD PTR _ysmp_flag, eax
	pop	esi

; 6205 : }  /* end change_hessian_functions() */

	pop	ebp
	ret	0
$LN14@change_hes:

; 6152 :             case METIS_FACTORING: outstring("(was metis)\n"); break;
; 6153 :             case MKL_FACTORING: outstring("(was MKL)\n"); break;
; 6154 :          }
; 6155 :       }
; 6156 :       break;
; 6157 :     case METIS_FACTORING:
; 6158 :      {
; 6159 :          sp_mul_func = bk_mul;
; 6160 :          sp_AIJ_setup_func= bk_AIJ_setup;
; 6161 :          sp_constraint_setup_func = bk_constraint_setup;
; 6162 :          sp_hess_project_setup_func= BK_hess_project_setup;
; 6163 :          sp_factor_func = ysmp_factor;
; 6164 :          sp_CHinvC_func = sp_CHinvC;
; 6165 :          sp_solve_func = ysmp_solve;
; 6166 :          sp_solve_multi_func = ysmp_solve_multi;
; 6167 : /*
; 6168 : tree stuff not working
; 6169 :          sp_factor_func = tree_factor;
; 6170 :          sp_solve_func = tree_solve;
; 6171 :          sp_solve_multi_func = tree_solve_multi;
; 6172 : */
; 6173 :          sp_ordering_func = metis_order;
; 6174 :          outstring("Using Metis ordering in ysmp factoring. ");

	push	OFFSET ??_C@_0CJ@BBPOLAAA@Using?5Metis?5ordering?5in?5ysmp?5fac@
	mov	DWORD PTR _sp_mul_func, OFFSET _bk_mul
	mov	DWORD PTR _sp_AIJ_setup_func, OFFSET _bk_AIJ_setup
	mov	DWORD PTR _sp_constraint_setup_func, OFFSET _bk_constraint_setup
	mov	DWORD PTR _sp_hess_project_setup_func, OFFSET _BK_hess_project_setup
	mov	DWORD PTR _sp_factor_func, OFFSET _ysmp_factor
	mov	DWORD PTR _sp_CHinvC_func, OFFSET _sp_CHinvC
	mov	DWORD PTR _sp_solve_func, OFFSET _ysmp_solve
	mov	DWORD PTR _sp_solve_multi_func, OFFSET _ysmp_solve_multi
	mov	DWORD PTR _sp_ordering_func, OFFSET _metis_order
	call	_outstring
	add	esp, 4

; 6175 :          switch ( oldh ) 

	cmp	esi, 3
	ja	SHORT $LN12@change_hes
	jmp	DWORD PTR $LN40@change_hes[esi*4]
$LN11@change_hes:

; 6176 :          {  case YSMP_FACTORING: outstring("(was YSMP)\n"); break;

	push	OFFSET ??_C@_0M@NJDJPBGM@?$CIwas?5YSMP?$CJ?6?$AA@
	jmp	SHORT $LN36@change_hes
$LN10@change_hes:

; 6177 :             case MINDEG_FACTORING: outstring("(was alt min deg)\n"); break;

	push	OFFSET ??_C@_0BD@PLMHICLH@?$CIwas?5alt?5min?5deg?$CJ?6?$AA@
	jmp	SHORT $LN36@change_hes
$LN9@change_hes:

; 6178 :             case METIS_FACTORING: outstring("(was metis)\n"); break;

	push	OFFSET ??_C@_0N@GFPJKKAK@?$CIwas?5metis?$CJ?6?$AA@
	jmp	SHORT $LN36@change_hes
$LN8@change_hes:

; 6179 :             case MKL_FACTORING: outstring("(was MKL)\n"); break;

	push	OFFSET ??_C@_0L@JKJMIGOC@?$CIwas?5MKL?$CJ?6?$AA@
$LN36@change_hes:
	call	_outstring
	add	esp, 4
$LN12@change_hes:

; 6180 :          }
; 6181 :      }
; 6182 :      case MKL_FACTORING:
; 6183 :       { 
; 6184 :          sp_mul_func = bk_mul;
; 6185 :          sp_AIJ_setup_func= bk_AIJ_setup;
; 6186 :          sp_constraint_setup_func = bk_constraint_setup;
; 6187 :          sp_hess_project_setup_func= BK_hess_project_setup;
; 6188 :          sp_factor_func = mkl_factor;
; 6189 :          sp_CHinvC_func = sp_CHinvC;
; 6190 :          sp_solve_func = mkl_solve;
; 6191 :          sp_solve_multi_func = mkl_solve_multi;
; 6192 :          sp_ordering_func = NULL;
; 6193 :          outstring("Using MKL. ");

	push	OFFSET ??_C@_0M@BICBNOL@Using?5MKL?4?5?$AA@
	mov	DWORD PTR _sp_mul_func, OFFSET _bk_mul
	mov	DWORD PTR _sp_AIJ_setup_func, OFFSET _bk_AIJ_setup
	mov	DWORD PTR _sp_constraint_setup_func, OFFSET _bk_constraint_setup
	mov	DWORD PTR _sp_hess_project_setup_func, OFFSET _BK_hess_project_setup
	mov	DWORD PTR _sp_factor_func, OFFSET _mkl_factor
	mov	DWORD PTR _sp_CHinvC_func, OFFSET _sp_CHinvC
	mov	DWORD PTR _sp_solve_func, OFFSET _mkl_solve
	mov	DWORD PTR _sp_solve_multi_func, OFFSET _mkl_solve_multi
	mov	DWORD PTR _sp_ordering_func, 0
	call	_outstring
	add	esp, 4

; 6194 :          switch ( oldh ) 

	cmp	esi, 3
	ja	SHORT $LN34@change_hes
	jmp	DWORD PTR $LN41@change_hes[esi*4]
$LN1@change_hes:

; 6195 :          {  case YSMP_FACTORING: outstring("(was YSMP)\n"); break;
; 6196 :             case MINDEG_FACTORING: outstring("(was alt min deg)\n"); break;
; 6197 :             case METIS_FACTORING: outstring("(was metis)\n"); break;
; 6198 :             case MKL_FACTORING: outstring("(was MKL)\n"); break;

	push	OFFSET ??_C@_0L@JKJMIGOC@?$CIwas?5MKL?$CJ?6?$AA@
	call	_outstring
	add	esp, 4
$LN34@change_hes:

; 6199 :          }
; 6200 :       }
; 6201 :       break;
; 6202 :  
; 6203 :   }
; 6204 :   ysmp_flag = newh;

	mov	eax, DWORD PTR _newh$[ebp]
	mov	DWORD PTR _ysmp_flag, eax
$LN32@change_hes:
	pop	esi

; 6205 : }  /* end change_hessian_functions() */

	pop	ebp
	ret	0
$LN37@change_hes:
	DD	$LN28@change_hes
	DD	$LN21@change_hes
	DD	$LN14@change_hes
	DD	$LN12@change_hes
$LN38@change_hes:
	DD	$LN17@change_hes
	DD	$LN25@change_hes
	DD	$LN23@change_hes
	DD	$LN1@change_hes
$LN39@change_hes:
	DD	$LN17@change_hes
	DD	$LN25@change_hes
	DD	$LN23@change_hes
	DD	$LN1@change_hes
$LN40@change_hes:
	DD	$LN10@change_hes
	DD	$LN11@change_hes
	DD	$LN9@change_hes
	DD	$LN8@change_hes
$LN41@change_hes:
	DD	$LN17@change_hes
	DD	$LN25@change_hes
	DD	$LN23@change_hes
	DD	$LN1@change_hes
_change_hessian_functions ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@EPFFHJGJ@?$CIappears?5to?5be?5corrupt?5node?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0CG@KKIFLOID@Bad?5expression?5eval?5node?5type?5?$CFd@ ; `string'
PUBLIC	??_C@_0DL@CGAPACAK@make_thread_lists?3?5stage?5and?5pro@ ; `string'
PUBLIC	??_C@_0CI@BCKCAMJI@Bunch?9Kaufman?5version?5of?5minimal@ ; `string'
PUBLIC	??_C@_0CD@FMGOOMLP@This?5Evolver?5not?5enabled?5for?5MKL@ ; `string'
PUBLIC	??_C@_0CK@FPPJMDP@Linear?5interpolation?5metric?5with@ ; `string'
PUBLIC	??_C@_0CM@HLDCELF@Squared?5gradient?5minimization?5wi@ ; `string'
PUBLIC	??_C@_0L@EAHJADDM@?$CIwas?5OFF?$CJ?6?$AA@	; `string'
PUBLIC	??_C@_09HOELGAGH@?$CIwas?5ON?$CJ?6?$AA@		; `string'
PUBLIC	??_C@_04CCBBDIMF@OFF?4?$AA@			; `string'
PUBLIC	??_C@_03GMMPMBGO@ON?4?$AA@			; `string'
PUBLIC	??_C@_0BH@JOOMOIMF@Using?5quantities?5only?5?$AA@ ; `string'
PUBLIC	??_C@_0CN@GJOHMOIJ@Not?5using?5metric?5to?5convert?5form@ ; `string'
PUBLIC	??_C@_0CJ@IHPJGNJA@Converting?5form?5to?5vector?5using?5@ ; `string'
PUBLIC	??_C@_0DI@BIMKBCLE@CLIPPED?5mode?5has?5no?5effect?5since@ ; `string'
PUBLIC	??_C@_0CN@JFJCLEGG@There?5are?5no?5bodies?5to?5display?5c@ ; `string'
PUBLIC	??_C@_0BP@EAFIIJC@Too?5many?5warnings?5suppressed?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@FDJMMAJJ@Merged?5bodies?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@HMCCKFKD@New?5bodies?3?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0CD@POBIGEFP@Text?5id?5must?5be?5between?51?5and?5?$CFd@ ; `string'
PUBLIC	??_C@_0BJ@MHNCMPKC@Too?5many?5display?5texts?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@DCKMBCPP@Vertex?5averaging?5done?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@FCMLGNJI@div_normal_curvature?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BJ@NMGOBDGL@div_normal_curvature?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0CM@KAJBDCJO@Div_normal_curvature?5only?5for?5di@ ; `string'
PUBLIC	??_C@_0BG@NDPCJIMM@normal_curvature?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BF@FLINIKLP@normal_curvature?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0CI@LJHBFOKD@Normal_curvature?5only?5for?5dimens@ ; `string'
PUBLIC	??_C@_0BE@NKFGCFPK@effective_area?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BD@EJHMJHLD@effective_area?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0CG@IOBGAJKP@effective_area?5only?5for?5dimensio@ ; `string'
PUBLIC	??_C@_0BH@LECDGDFK@Ambient?5pressure?5OFF?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DA@JMHNCEHN@Ambient?5pressure?5ON?$DL?5ambient?5pre@ ; `string'
PUBLIC	??_C@_0BA@OMDNEEOJ@show?5outer?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0P@CBFHHCBJ@show?5outer?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BA@OCCIDMFK@show?5inner?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0P@OPKHPDBB@show?5inner?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BB@DGBIGPKN@Autodisplay?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BA@GEMEOGHC@Autodisplay?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0P@IPLABJGP@Diffusion?5OFF?4?$AA@		; `string'
PUBLIC	??_C@_0BJ@NLHBFEJL@Enter?5target?5size?5?$CI?$CFg?$CJ?3?5?$AA@ ; `string'
PUBLIC	??_C@_0BM@EIKAOGMF@Homothety?5adjustment?5is?5?$CFs?4?$AA@ ; `string'
PUBLIC	??_C@_03MPPIHBHJ@OFF?$AA@			; `string'
PUBLIC	??_C@_02BFICIOJL@ON?$AA@			; `string'
PUBLIC	??_C@_0CF@KHOFMLFP@Cannot?5do?5homothety?5without?5bodi@ ; `string'
PUBLIC	??_C@_0BE@IMCDPOAN@Increase?5check?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BD@IPGDEDIG@Increase?5check?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BB@IPOGGIKD@Runge?9Kutta?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BA@PMBHOBAE@Runge?9Kutta?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BN@DLJCKBBD@Tolerance?5must?5be?5positive?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@	; `string'
PUBLIC	??_C@_0DG@GCIBKAME@Illegal?5index?3?5view_matrix?$FL?$CFd?$FN?$FL?$CF@ ; `string'
PUBLIC	??_C@_0BI@GDCBHHFG@Zoom?5vertex?5not?5found?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@DENHLHAI@Zoom?5vertex?5?$CFd?5not?5found?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DA@ICIFPLG@Changing?5datatype?5of?5array?5?8?$CFs?8?4@ ; `string'
PUBLIC	??_C@_0P@BKJHBGLB@New?5edges?3?5?$CFd?6?$AA@	; `string'
PUBLIC	??_C@_0BH@FJOMOHLK@Model?5already?5LINEAR?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CK@JMIEKNGL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5L@ ; `string'
PUBLIC	??_C@_0CL@FEBBPANL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5Q@ ; `string'
PUBLIC	??_C@_0BK@PABEINCB@Model?5already?5QUADRATIC?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@BFEEPGEG@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@ ; `string'
PUBLIC	??_C@_0CL@IKOBFHOD@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@ ; `string'
PUBLIC	??_C@_0EE@FNJALPPL@Bad?5model?5choice?4?5Legal?3?51?5?$CIline@ ; `string'
PUBLIC	??_C@_0DC@KLMKCJCH@Changing?5to?5LAGRANGE?5?$CFd?5model?4?5?$CI@ ; `string'
PUBLIC	??_C@_0CN@NAGKEEOG@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@ ; `string'
PUBLIC	??_C@_0CK@JBOLHCFI@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@ ; `string'
PUBLIC	??_C@_0BE@EJALKLLC@Gravity?5is?5now?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0DC@FCBICJJI@Gravity?5is?5now?5ON?5with?5gravitati@ ; `string'
PUBLIC	??_C@_0CB@HABEDKHM@Scale?5optimizing?5with?5bound?5?$CFg?4?6@ ; `string'
PUBLIC	??_C@_0BE@KHLJFDIK@Scale?5fixed?5at?5?$CFg?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@LHJNONFJ@Deleted?5edges?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@ENNEDDMF@Skinny?5triangles?5weeded?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0O@KKGGCNAE@Diffusion?5ON?4?$AA@		; `string'
PUBLIC	__real@3e45798ee2308c3a
PUBLIC	??_C@_0BN@KADAPAAJ@Number?5of?5edges?5notched?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0DC@JKPEEAKK@refine?5edge?5ee?5where?5max?$CIee?4vert@ ; `string'
PUBLIC	??_C@_0BO@FEKICMHJ@Notching?5angle?5not?5positive?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DG@KANBCPFA@Notching?5not?5implemented?5for?5sim@ ; `string'
PUBLIC	??_C@_02PHMGELLB@?6?6?$AA@			; `string'
PUBLIC	??_C@_02HAOIJKIC@?$CFc?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_08GPHOBFCD@?$CF20?415g?6?$AA@		; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0EE@BIPFCNNO@binary_printf?5format?5string?5has?5@ ; `string'
PUBLIC	??_C@_0EF@OOJIKBOM@binary_printf?3?5you?5must?5set?5?8big@ ; `string'
PUBLIC	??_C@_0EA@GNCLKEFD@Format?5string?5has?5?$CFd?5formats?0?5bu@ ; `string'
PUBLIC	??_C@_0BO@PHJFLEKB@Illegal?5format?5specifier?3?5?$CFn?6?$AA@ ; `string'
PUBLIC	??_C@_05PPNJJAGI@?$CINaN?$CJ?$AA@		; `string'
PUBLIC	__real@7e37e43c8800759c
PUBLIC	__real@fe37e43c8800759c
PUBLIC	__real@54b249ad2594c37d
PUBLIC	??_C@_06LHGEHABH@?$CINULL?$CJ?$AA@		; `string'
PUBLIC	??_C@_0CL@KCHMNGLN@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$DL?5nnode?9@ ; `string'
PUBLIC	??_C@_0CK@DDEBKHJG@Possibly?5?$CF?5not?5followed?5by?5legal@ ; `string'
PUBLIC	??_C@_0DL@PCELCLJI@Argument?5?$CFd?3?5String?5format?5does?5@ ; `string'
PUBLIC	??_C@_04FAGILPDO@?$CF?40s?$AA@			; `string'
PUBLIC	??_C@_05NIOJGFPH@?$CF0?40s?$AA@			; `string'
PUBLIC	??_C@_0O@MLENCFID@Set?5png?5name?$DN?$AA@	; `string'
PUBLIC	??_C@_0BA@LLDLGANG@Set?5png?5prefix?$DN?$AA@	; `string'
PUBLIC	??_C@_0M@EMICKKLA@Saving?5png?6?$AA@		; `string'
PUBLIC	??_C@_0CO@GFMHNHBN@1?4?5?$CFs?3?5?$CF17?415g?5energy?3?5?$CF17?415g?5?5@ ; `string'
PUBLIC	??_C@_0EA@BBCBJJDC@interpolation?5of?5boundary?5parame@ ; `string'
PUBLIC	??_C@_0CK@NNHEBOBN@interpolation?5of?5boundary?5parame@ ; `string'
PUBLIC	??_C@_0BM@JFPGPFKD@Hessian?5by?5differences?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BL@DGFOJMBA@Hessian?5by?5differences?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0DG@FNHPJGDA@Hessian_diff?5not?5implemented?5for@ ; `string'
PUBLIC	??_C@_0BD@FJEPDOCE@hessian_quiet?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BD@DBDGMAIK@hessian_quiet?5?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BI@DNMJIMAC@hessian_normal_one?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BI@FFLAHCKM@hessian_normal_one?5?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0DP@GODKPABP@HESSIAN_NORMAL_ONE?5only?5for?5STRI@ ; `string'
PUBLIC	??_C@_0BL@HLBKECJE@hessian_double_normal?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BL@BDGDLMDK@hessian_double_normal?5?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0BJ@FGBJHBNH@hessian_normal_perp?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BJ@DOGAIPHJ@hessian_normal_perp?5?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0BM@JNLHDNMC@hessian_special_normal?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BL@BKKLNAFN@hessian_special_normal?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0CI@CDHDEEDF@hessian_special_normal_vector?5no@ ; `string'
PUBLIC	??_C@_0BE@GEJIPBCC@hessian_normal?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BE@MOBAPIM@hessian_normal?5?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BC@EMGJHHB@Sobolev?5area?5mode?$AA@	; `string'
PUBLIC	??_C@_0BC@IPOHGFDM@bezier_basis?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BC@OHJOJLJC@bezier_basis?5?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BB@EHCKFCGI@mpi_local_bodies?$AA@	; `string'
PUBLIC	??_C@_09PJOICEHA@mpi_debug?$AA@			; `string'
PUBLIC	??_C@_0O@EKBDJBFN@little_endian?$AA@		; `string'
PUBLIC	??_C@_0L@HGLBMAAF@big_endian?$AA@		; `string'
PUBLIC	??_C@_0L@NBNMFCPF@pop_enjoin?$AA@		; `string'
PUBLIC	??_C@_0M@PDGIDHIC@pop_disjoin?$AA@		; `string'
PUBLIC	??_C@_0M@FHCBDAPB@pop_to_face?$AA@		; `string'
PUBLIC	??_C@_0M@CAFGBCMP@pop_to_edge?$AA@		; `string'
PUBLIC	??_C@_0BC@PCBOIGLG@full_bounding_box?$AA@	; `string'
PUBLIC	??_C@_0N@CPNIHMEN@smooth?5graph?$AA@		; `string'
PUBLIC	??_C@_0BA@PMMMILEF@K?5altitude?5mode?$AA@	; `string'
PUBLIC	??_C@_0BG@DMGKDBMO@Kraynik?5pop?5edge?5mode?$AA@ ; `string'
PUBLIC	??_C@_0BI@FLPPIDJA@Kraynik?5pop?5vertex?5mode?$AA@ ; `string'
PUBLIC	??_C@_0BF@IOAHFOPJ@Circular?5arc?5drawing?$AA@	; `string'
PUBLIC	??_C@_0BA@CLHENHLJ@visibility?5test?$AA@	; `string'
PUBLIC	??_C@_0BD@CFDHHPOD@sparse?5constraints?$AA@	; `string'
PUBLIC	??_C@_0BC@DOMBLPMO@augmented?5Hessian?$AA@	; `string'
PUBLIC	??_C@_0CG@ECALEFFC@This?5Evolver?5not?5compiled?5with?5B@ ; `string'
PUBLIC	??_C@_0BB@DNFIILFK@Break?5on?5warning?$AA@	; `string'
PUBLIC	??_C@_0BE@BDGKJNKH@Break?5after?5warning?$AA@	; `string'
PUBLIC	??_C@_0L@OOMCHPBN@RGB?5colors?$AA@		; `string'
PUBLIC	??_C@_0BE@GOKADGNC@Dirichlet?5area?5mode?$AA@	; `string'
PUBLIC	??_C@_0N@GLKAJGNE@QuietGo?5OFF?4?$AA@		; `string'
PUBLIC	??_C@_0M@LECGJNII@QuietGo?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0BA@FHIDEKKO@?5?5?$CI?$CFs?5not?5set?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0M@MFKIHKAF@?5?5?$CI?$CFs?3?5?$CFg?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0M@GPOBHEAO@zener_coeff?$AA@		; `string'
PUBLIC	??_C@_0L@BBPCCDGD@?5?$CIwas?5off?$CJ?$AA@	; `string'
PUBLIC	??_C@_09MIGIKFMF@?5?$CIwas?5on?$CJ?$AA@		; `string'
PUBLIC	??_C@_0BA@GBNDBAOB@Zener_drag?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0P@MHAOIPAG@Zener_drag?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0BE@BJAHIEEH@Volgrads_every?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BD@BEFDILEO@Volgrads_every?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BD@CJLDGBEG@rotate_lights?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BC@BFEJGDKB@rotate_lights?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0O@OLHNPOHO@backcull?5OFF?4?$AA@		; `string'
PUBLIC	??_C@_0N@MCJPMBN@backcull?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0P@DNBOACGN@clip_view?5OFF?4?$AA@		; `string'
PUBLIC	??_C@_0O@LJHGAHLN@clip_view?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0BA@IOBHBMAO@slice_view?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0P@NGBCEKEF@slice_view?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0BE@CPAMODLH@star_finagling?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BD@BMHOINOE@star_finagling?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BE@ENOCFBBI@force_deletion?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BD@CPNBPNLI@force_deletion?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0CA@IKPAIAFC@view_transforms_use_unique?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BP@OKKIADMD@view_transforms_use_unique?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0BE@NLKJDFAI@detorus_sticky?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BD@GNBNGDPC@detorus_sticky?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BO@OKHCNJJN@function_quantity_sparse?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BN@NIHPBJFM@function_quantity_sparse?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0P@HOGKKAKM@QuietLoad?5OFF?4?$AA@		; `string'
PUBLIC	??_C@_0O@KEDNKMNF@QuietLoad?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0L@FBKEFKCC@Quiet?5OFF?4?$AA@		; `string'
PUBLIC	??_C@_09FLLKFOJ@Quiet?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0N@POKCPLOD@Verbose?5OFF?4?$AA@		; `string'
PUBLIC	??_C@_0M@JABCIEA@Verbose?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0N@IGCELFFA@torus_filled?$AA@		; `string'
PUBLIC	??_C@_0DM@HAMHICGC@torus_filled?5is?5invalid?5toggle?5b@ ; `string'
PUBLIC	??_C@_0M@FKFJNJHN@septum_flag?$AA@		; `string'
PUBLIC	??_C@_0P@BMEBABFE@show_all_edges?$AA@		; `string'
PUBLIC	??_C@_0BC@IOPGAMGF@show_bounding_box?$AA@	; `string'
PUBLIC	??_C@_0N@ECHDFDIC@ps_labelflag?$AA@		; `string'
PUBLIC	??_C@_0N@JJEIJGBI@crossingflag?$AA@		; `string'
PUBLIC	??_C@_0M@NAKIPJII@ps_gridflag?$AA@		; `string'
PUBLIC	??_C@_0P@EJEJKKN@force_edgeswap?$AA@		; `string'
PUBLIC	??_C@_0M@LOFHKFBI@ps_cmykflag?$AA@		; `string'
PUBLIC	??_C@_0N@PDJMPNAK@ps_colorflag?$AA@		; `string'
PUBLIC	??_C@_0BE@PABNDBOD@show_all_quantities?$AA@	; `string'
PUBLIC	??_C@_0BI@NLHBLELH@Area?5normalization?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BH@LFJMNMPC@Area?5normalization?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0BM@ELOHAFKC@Conjugate?5gradient?5now?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0DN@IGNPBNFB@Fixed?5scale?5is?5ON?$CB?5Not?5a?5good?5id@ ; `string'
PUBLIC	??_C@_0BL@JMDAFIPN@Conjugate?5gradient?5now?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0CG@NBBBJCB@Polak?9Ribiere?5conjugate?5gradient@ ; `string'
PUBLIC	??_C@_0CF@DJCKCFC@Polak?9Ribiere?5conjugate?5gradient@ ; `string'
PUBLIC	??_C@_0O@HAOGCDPC@jiggling?5OFF?4?$AA@		; `string'
PUBLIC	??_C@_0N@PDDGMANN@jiggling?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0BA@ILJCGNII@Keylogfile?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0P@FDDENPIC@Keylogfile?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0N@JKAGEBIA@Logfile?5OFF?4?$AA@		; `string'
PUBLIC	??_C@_0M@MGBDILFJ@Logfile?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0O@LDDNFFJB@geomview?5OFF?4?$AA@		; `string'
PUBLIC	??_C@_0N@CEMOACCA@geomview?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0O@HKDJJHHO@geompipe?5OFF?4?$AA@		; `string'
PUBLIC	??_C@_0N@CMCMGLFD@geompipe?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0BF@CBFBFNPC@assume_oriented?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BE@JKEIPKOM@assume_oriented?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BG@IBDCGPFP@h_inverse_metric?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BF@PDJICPAM@h_inverse_metric?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BG@OPPOGKDN@approx_curvature?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BF@FEJLKKJL@approx_curvature?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0O@OJIMPIFF@old_area?5OFF?4?$AA@		; `string'
PUBLIC	??_C@_0N@JALMNNNO@old_area?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0BC@NBPBOIPD@Autochopping?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0DE@BNGJBEEG@Set?5autochop?5length?5with?5?5AUTOCH@ ; `string'
PUBLIC	??_C@_0CB@HOOMNLNJ@Autochopping?5ON?4?5Chop?5length?5?$CFg?5@ ; `string'
PUBLIC	??_C@_0BN@BCKOLDII@Immediate?5autopop?5mode?5OFF?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@ILBHGCJG@Immediate?5autopop?5mode?5ON?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@KFBMCIKD@Autopop?5quartic?5mode?5OFF?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@IENAHCOI@Autopop?5quartic?5mode?5ON?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@OAFHPFJG@Number?5of?5vertices?5popped?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@KKHKLGGG@Autopopping?5OFF?4?6?$AA@	; `string'
PUBLIC	??_C@_0BB@OCLHIDKB@Autopopping?5ON?4?6?$AA@	; `string'
PUBLIC	??_C@_0CA@PIHNBFDB@Squared?5Gaussian?5curvature?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BP@GAFKOFAF@Squared?5Gaussian?5curvature?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0CG@GCABNAHH@Enter?5unit?5normal?5weight?5factor?$CI@ ; `string'
PUBLIC	??_C@_0BI@PPEAKFND@Unit?5normal?5motion?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BH@DACOBOAB@Unit?5normal?5motion?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0BH@LDBBFNCP@Transform?5showing?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BG@IMGLMCA@Transform?5showing?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BA@MMAAEFMG@Estimation?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0P@HDNDOOGM@Estimation?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0BN@OMIPPGDJ@Force?5positive?5definite?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BM@JDOFKCBJ@Force?5positive?5definite?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0BA@MFIJFNML@Autorecalc?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0P@EMIHMIGA@Autorecalc?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0BN@FPPHODPN@Mean?5curvature?5integral?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BM@INIKEIOB@Mean?5curvature?5integral?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0BF@FAPOAGGN@Post?9projection?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BE@IEJGOMKI@Post?9projection?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0CF@EFADNMIL@Conformal?5edge?5square?5curvature?5@ ; `string'
PUBLIC	??_C@_0CE@KDGBEDPF@Conformal?5edge?5square?5curvature?5@ ; `string'
PUBLIC	??_C@_0BI@BCLOFPDG@Boundary?5curvature?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BH@HGFHNLIB@Boundary?5curvature?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0BL@GMEPNJMN@Edge?5square?5curvature?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BK@DGKNJNIM@Edge?5square?5curvature?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0BK@LLFAACBP@Geomview?5binary?5mode?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BJ@CEKEKBGN@Geomview?5binary?5mode?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0BK@NBLNNAOK@Self?5similarity?5mode?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BJ@HJFGKGHM@Self?5similarity?5mode?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0BH@NNAJHAMG@Metric?5conversion?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BG@HLONLCLH@Metric?5conversion?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0BI@ODCIPKND@Constraint?5pinning?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BH@DEBAHMFA@Constraint?5pinning?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0BC@KPMAPKLM@4D?5graphics?5?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BB@LFAAENHB@4D?5graphics?5?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BD@DHLHFHDN@Normal?5motion?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BC@BAINHADD@Normal?5motion?5ON?4?$AA@	; `string'
PUBLIC	_localstack$GSCopy$
PUBLIC	_update_display_flag$GSCopy$
PUBLIC	_recalc_flag$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_more_other_stuff
EXTRN	_file_no_used:DWORD
EXTRN	_tokname:PROC
EXTRN	_make_thread_lists:PROC
EXTRN	_v_partition_stage_attr:DWORD
EXTRN	_threadflag:DWORD
EXTRN	_min_square_grad_flag:DWORD
EXTRN	_cmapname:BYTE
EXTRN	_do_dump:PROC
EXTRN	_burchard:PROC
EXTRN	_alice:PROC
EXTRN	_warnings_suppressed:BYTE
EXTRN	_warnings_suppressed_count:DWORD
EXTRN	_calc_content:PROC
EXTRN	_merge_bodies:PROC
EXTRN	_rebody:PROC
EXTRN	_display_text_count:DWORD
EXTRN	_text_chunks:BYTE
EXTRN	_vertex_average:PROC
EXTRN	_long_jiggle:PROC
EXTRN	_square_curvature_flag:DWORD
EXTRN	_normflag:DWORD
EXTRN	_extrapolate:PROC
EXTRN	_memory_report:PROC
EXTRN	_homothety_target:QWORD
EXTRN	_meth_inst_list:DWORD
EXTRN	_set_body_fixvol:PROC
EXTRN	_view:DWORD
EXTRN	_zoom_vertex:PROC
EXTRN	_valid_element:PROC
EXTRN	_datatype_size:BYTE
EXTRN	_graphics_title3:BYTE
EXTRN	_graphics_title3_global:DWORD
EXTRN	_graphics_title2:BYTE
EXTRN	_graphics_title2_global:DWORD
EXTRN	_set_graphics_title:PROC
EXTRN	_graphics_title:BYTE
EXTRN	_graphics_title_global:DWORD
EXTRN	__imp__SetConsoleTitleA@4:PROC
EXTRN	_console_title:BYTE
EXTRN	_console_title_global:DWORD
EXTRN	_KB_realloc:PROC
EXTRN	_articulate:PROC
EXTRN	_display_file:PROC
EXTRN	_lagrange_to_linear:PROC
EXTRN	_quad_to_linear:PROC
EXTRN	_lagrange_to_quad:PROC
EXTRN	_linear_to_quad:PROC
EXTRN	_lagrange_to_lagrange:PROC
EXTRN	_quad_to_lagrange:PROC
EXTRN	_linear_to_lagrange:PROC
EXTRN	_gravity_quantity_num:DWORD
EXTRN	_edgeweed:PROC
EXTRN	_metis_vertex_order:PROC
EXTRN	_metis_partition_body:PROC
EXTRN	_metis_partition_dual:PROC
EXTRN	_metis_partition_plain:PROC
EXTRN	_energy_init:DWORD
EXTRN	_areaweed:PROC
EXTRN	_create_pressure_quant:PROC
EXTRN	_add_outside:PROC
EXTRN	_ridge_notcher:PROC
EXTRN	_command:PROC
EXTRN	_exit:PROC
EXTRN	_jiggle:PROC
EXTRN	_display:PROC
EXTRN	_print_express:PROC
EXTRN	_single_redefine:BYTE
EXTRN	_fwrite:PROC
EXTRN	__setmode:PROC
EXTRN	__fileno:PROC
EXTRN	_fflush:PROC
EXTRN	_outfd:DWORD
EXTRN	_temp_free:PROC
EXTRN	_isalpha:PROC
EXTRN	_kb_temp_realloc:PROC
EXTRN	_kb_strstr:PROC
EXTRN	_kb_temp_calloc:PROC
EXTRN	_erroutstring:PROC
EXTRN	_png_dir:BYTE
EXTRN	_png_full_name:BYTE
EXTRN	_png_name:BYTE
EXTRN	_png_prefix:BYTE
EXTRN	_TakeScreenshot:PROC
EXTRN	_levolvertemp:DWORD
EXTRN	_strncmp:PROC
EXTRN	_evolver_version:DWORD
EXTRN	_strchr:PROC
EXTRN	_warning_messages:DWORD
EXTRN	_datafilename:BYTE
EXTRN	_transform_expr:BYTE
EXTRN	_eigenprobe_command:PROC
EXTRN	_areaname:DWORD
EXTRN	_vgrad_end:PROC
EXTRN	_move_vertices:PROC
EXTRN	_calc_all_grads:PROC
EXTRN	_lanczos_command:PROC
EXTRN	_ritz_command:PROC
EXTRN	_count_fixed_vol:PROC
EXTRN	_hessian_special_normal_expr:BYTE
EXTRN	_bezier_to_lagrange:PROC
EXTRN	_lagrange_to_bezier:PROC
EXTRN	_gauss_lagrange_setup:PROC
EXTRN	_gauss_lagrange:BYTE
EXTRN	_maxgaussorder:BYTE
EXTRN	_circular_arc_flag:DWORD
EXTRN	_convert_to_quantities:PROC
EXTRN	_lookup_global:PROC
EXTRN	_rotate_lights_flag:DWORD
EXTRN	_clip_coeff_set_flag:DWORD
EXTRN	_slice_coeff_set_flag:DWORD
EXTRN	_star_finagling:DWORD
EXTRN	_force_deletion:DWORD
EXTRN	_calc_energy:PROC
EXTRN	_file_names:DWORD
EXTRN	_reset_conj_grad:PROC
EXTRN	_stop_keylogfile:PROC
EXTRN	_start_keylogfile:PROC
EXTRN	_keylogfile_flag:DWORD
EXTRN	_stop_logfile:PROC
EXTRN	_start_logfile:PROC
EXTRN	_geompipe_flag:DWORD
EXTRN	_set_v_constraint_map:PROC
EXTRN	_ps_file_name:BYTE
EXTRN	_torus_display_mode:DWORD
EXTRN	_do_gfile:PROC
EXTRN	_strncpy:PROC
EXTRN	_pix_file_name:BYTE
EXTRN	_simplex_delaunay_test:PROC
EXTRN	_edgepop_film:PROC
EXTRN	_verpop_str:PROC
EXTRN	_stability_test:PROC
EXTRN	_const_expr:PROC
EXTRN	_prompt:PROC
EXTRN	_deturck_factor:QWORD
EXTRN	_recalc:PROC
EXTRN	_update_display:PROC
EXTRN	_end_normal_motion:PROC
EXTRN	_begin_normal_motion:PROC
EXTRN	_wrap_vertex:PROC
EXTRN	_get_ordinal_id:PROC
EXTRN	_win_get_thread_data:PROC
EXTRN	_thread_data_key:DWORD
EXTRN	_floor:PROC
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0BO@EPFFHJGJ@?$CIappears?5to?5be?5corrupt?5node?$CJ?6?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
CONST	SEGMENT
??_C@_0BO@EPFFHJGJ@?$CIappears?5to?5be?5corrupt?5node?$CJ?6?$AA@ DB '(app'
	DB	'ears to be corrupt node)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KKIFLOID@Bad?5expression?5eval?5node?5type?5?$CFd@
CONST	SEGMENT
??_C@_0CG@KKIFLOID@Bad?5expression?5eval?5node?5type?5?$CFd@ DB 'Bad expr'
	DB	'ession eval node type %d: %s.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@CGAPACAK@make_thread_lists?3?5stage?5and?5pro@
CONST	SEGMENT
??_C@_0DL@CGAPACAK@make_thread_lists?3?5stage?5and?5pro@ DB 'make_thread_'
	DB	'lists: stage and proc attributes don''t exist.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BCKCAMJI@Bunch?9Kaufman?5version?5of?5minimal@
CONST	SEGMENT
??_C@_0CI@BCKCAMJI@Bunch?9Kaufman?5version?5of?5minimal@ DB 'Bunch-Kaufma'
	DB	'n version of minimal degree', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FMGOOMLP@This?5Evolver?5not?5enabled?5for?5MKL@
CONST	SEGMENT
??_C@_0CD@FMGOOMLP@This?5Evolver?5not?5enabled?5for?5MKL@ DB 'This Evolve'
	DB	'r not enabled for MKL.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FPPJMDP@Linear?5interpolation?5metric?5with@
CONST	SEGMENT
??_C@_0CK@FPPJMDP@Linear?5interpolation?5metric?5with@ DB 'Linear interpo'
	DB	'lation metric with Hessian ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HLDCELF@Squared?5gradient?5minimization?5wi@
CONST	SEGMENT
??_C@_0CM@HLDCELF@Squared?5gradient?5minimization?5wi@ DB 'Squared gradie'
	DB	'nt minimization with Hessian ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EAHJADDM@?$CIwas?5OFF?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0L@EAHJADDM@?$CIwas?5OFF?$CJ?6?$AA@ DB '(was OFF)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HOELGAGH@?$CIwas?5ON?$CJ?6?$AA@
CONST	SEGMENT
??_C@_09HOELGAGH@?$CIwas?5ON?$CJ?6?$AA@ DB '(was ON)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CCBBDIMF@OFF?4?$AA@
CONST	SEGMENT
??_C@_04CCBBDIMF@OFF?4?$AA@ DB 'OFF.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GMMPMBGO@ON?4?$AA@
CONST	SEGMENT
??_C@_03GMMPMBGO@ON?4?$AA@ DB 'ON.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JOOMOIMF@Using?5quantities?5only?5?$AA@
CONST	SEGMENT
??_C@_0BH@JOOMOIMF@Using?5quantities?5only?5?$AA@ DB 'Using quantities on'
	DB	'ly ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GJOHMOIJ@Not?5using?5metric?5to?5convert?5form@
CONST	SEGMENT
??_C@_0CN@GJOHMOIJ@Not?5using?5metric?5to?5convert?5form@ DB 'Not using m'
	DB	'etric to convert form to vector.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IHPJGNJA@Converting?5form?5to?5vector?5using?5@
CONST	SEGMENT
??_C@_0CJ@IHPJGNJA@Converting?5form?5to?5vector?5using?5@ DB 'Converting '
	DB	'form to vector using metric.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@BIMKBCLE@CLIPPED?5mode?5has?5no?5effect?5since@
CONST	SEGMENT
??_C@_0DI@BIMKBCLE@CLIPPED?5mode?5has?5no?5effect?5since@ DB 'CLIPPED mod'
	DB	'e has no effect since torus model not used.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JFJCLEGG@There?5are?5no?5bodies?5to?5display?5c@
CONST	SEGMENT
??_C@_0CN@JFJCLEGG@There?5are?5no?5bodies?5to?5display?5c@ DB 'There are '
	DB	'no bodies to display connectedly.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EAFIIJC@Too?5many?5warnings?5suppressed?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@EAFIIJC@Too?5many?5warnings?5suppressed?4?6?$AA@ DB 'Too many w'
	DB	'arnings suppressed.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FDJMMAJJ@Merged?5bodies?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BD@FDJMMAJJ@Merged?5bodies?3?5?$CFd?6?$AA@ DB 'Merged bodies: %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HMCCKFKD@New?5bodies?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BA@HMCCKFKD@New?5bodies?3?5?$CFd?6?$AA@ DB 'New bodies: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@POBIGEFP@Text?5id?5must?5be?5between?51?5and?5?$CFd@
CONST	SEGMENT
??_C@_0CD@POBIGEFP@Text?5id?5must?5be?5between?51?5and?5?$CFd@ DB 'Text i'
	DB	'd must be between 1 and %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MHNCMPKC@Too?5many?5display?5texts?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@MHNCMPKC@Too?5many?5display?5texts?4?6?$AA@ DB 'Too many displa'
	DB	'y texts.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DCKMBCPP@Vertex?5averaging?5done?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@DCKMBCPP@Vertex?5averaging?5done?4?6?$AA@ DB 'Vertex averaging '
	DB	'done.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FCMLGNJI@div_normal_curvature?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BK@FCMLGNJI@div_normal_curvature?5OFF?4?$AA@ DB 'div_normal_curvat'
	DB	'ure OFF.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NMGOBDGL@div_normal_curvature?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BJ@NMGOBDGL@div_normal_curvature?5ON?4?$AA@ DB 'div_normal_curvatu'
	DB	're ON.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@KAJBDCJO@Div_normal_curvature?5only?5for?5di@
CONST	SEGMENT
??_C@_0CM@KAJBDCJO@Div_normal_curvature?5only?5for?5di@ DB 'Div_normal_cu'
	DB	'rvature only for dimension 3.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NDPCJIMM@normal_curvature?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BG@NDPCJIMM@normal_curvature?5OFF?4?$AA@ DB 'normal_curvature OFF.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FLINIKLP@normal_curvature?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BF@FLINIKLP@normal_curvature?5ON?4?$AA@ DB 'normal_curvature ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LJHBFOKD@Normal_curvature?5only?5for?5dimens@
CONST	SEGMENT
??_C@_0CI@LJHBFOKD@Normal_curvature?5only?5for?5dimens@ DB 'Normal_curvat'
	DB	'ure only for dimension 3.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NKFGCFPK@effective_area?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BE@NKFGCFPK@effective_area?5OFF?4?$AA@ DB 'effective_area OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EJHMJHLD@effective_area?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BD@EJHMJHLD@effective_area?5ON?4?$AA@ DB 'effective_area ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IOBGAJKP@effective_area?5only?5for?5dimensio@
CONST	SEGMENT
??_C@_0CG@IOBGAJKP@effective_area?5only?5for?5dimensio@ DB 'effective_are'
	DB	'a only for dimension 3.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LECDGDFK@Ambient?5pressure?5OFF?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@LECDGDFK@Ambient?5pressure?5OFF?4?6?$AA@ DB 'Ambient pressure O'
	DB	'FF.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JMHNCEHN@Ambient?5pressure?5ON?$DL?5ambient?5pre@
CONST	SEGMENT
??_C@_0DA@JMHNCEHN@Ambient?5pressure?5ON?$DL?5ambient?5pre@ DB 'Ambient p'
	DB	'ressure ON; ambient pressure = %2.15g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OMDNEEOJ@show?5outer?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BA@OMDNEEOJ@show?5outer?5OFF?4?$AA@ DB 'show outer OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CBFHHCBJ@show?5outer?5ON?4?$AA@
CONST	SEGMENT
??_C@_0P@CBFHHCBJ@show?5outer?5ON?4?$AA@ DB 'show outer ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OCCIDMFK@show?5inner?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BA@OCCIDMFK@show?5inner?5OFF?4?$AA@ DB 'show inner OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OPKHPDBB@show?5inner?5ON?4?$AA@
CONST	SEGMENT
??_C@_0P@OPKHPDBB@show?5inner?5ON?4?$AA@ DB 'show inner ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DGBIGPKN@Autodisplay?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BB@DGBIGPKN@Autodisplay?5OFF?4?$AA@ DB 'Autodisplay OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GEMEOGHC@Autodisplay?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BA@GEMEOGHC@Autodisplay?5ON?4?$AA@ DB 'Autodisplay ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IPLABJGP@Diffusion?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0P@IPLABJGP@Diffusion?5OFF?4?$AA@ DB 'Diffusion OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NLHBFEJL@Enter?5target?5size?5?$CI?$CFg?$CJ?3?5?$AA@
CONST	SEGMENT
??_C@_0BJ@NLHBFEJL@Enter?5target?5size?5?$CI?$CFg?$CJ?3?5?$AA@ DB 'Enter '
	DB	'target size (%g): ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EIKAOGMF@Homothety?5adjustment?5is?5?$CFs?4?$AA@
CONST	SEGMENT
??_C@_0BM@EIKAOGMF@Homothety?5adjustment?5is?5?$CFs?4?$AA@ DB 'Homothety '
	DB	'adjustment is %s.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MPPIHBHJ@OFF?$AA@
CONST	SEGMENT
??_C@_03MPPIHBHJ@OFF?$AA@ DB 'OFF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BFICIOJL@ON?$AA@
CONST	SEGMENT
??_C@_02BFICIOJL@ON?$AA@ DB 'ON', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KHOFMLFP@Cannot?5do?5homothety?5without?5bodi@
CONST	SEGMENT
??_C@_0CF@KHOFMLFP@Cannot?5do?5homothety?5without?5bodi@ DB 'Cannot do ho'
	DB	'mothety without bodies.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IMCDPOAN@Increase?5check?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BE@IMCDPOAN@Increase?5check?5OFF?4?$AA@ DB 'Increase check OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IPGDEDIG@Increase?5check?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BD@IPGDEDIG@Increase?5check?5ON?4?$AA@ DB 'Increase check ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IPOGGIKD@Runge?9Kutta?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BB@IPOGGIKD@Runge?9Kutta?5OFF?4?$AA@ DB 'Runge-Kutta OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PMBHOBAE@Runge?9Kutta?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BA@PMBHOBAE@Runge?9Kutta?5ON?4?$AA@ DB 'Runge-Kutta ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DLJCKBBD@Tolerance?5must?5be?5positive?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@DLJCKBBD@Tolerance?5must?5be?5positive?4?6?$AA@ DB 'Tolerance m'
	DB	'ust be positive.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@
CONST	SEGMENT
??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@ DB 'Division by zero.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@GCIBKAME@Illegal?5index?3?5view_matrix?$FL?$CFd?$FN?$FL?$CF@
CONST	SEGMENT
??_C@_0DG@GCIBKAME@Illegal?5index?3?5view_matrix?$FL?$CFd?$FN?$FL?$CF@ DB 'I'
	DB	'llegal index: view_matrix[%d][%d] (must be 1 to %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GDCBHHFG@Zoom?5vertex?5not?5found?4?6?$AA@
CONST	SEGMENT
??_C@_0BI@GDCBHHFG@Zoom?5vertex?5not?5found?4?6?$AA@ DB 'Zoom vertex not '
	DB	'found.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DENHLHAI@Zoom?5vertex?5?$CFd?5not?5found?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@DENHLHAI@Zoom?5vertex?5?$CFd?5not?5found?4?6?$AA@ DB 'Zoom vert'
	DB	'ex %d not found.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@ICIFPLG@Changing?5datatype?5of?5array?5?8?$CFs?8?4@
CONST	SEGMENT
??_C@_0DA@ICIFPLG@Changing?5datatype?5of?5array?5?8?$CFs?8?4@ DB 'Changin'
	DB	'g datatype of array ''%s''.  Data zeroed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BKJHBGLB@New?5edges?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0P@BKJHBGLB@New?5edges?3?5?$CFd?6?$AA@ DB 'New edges: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FJOMOHLK@Model?5already?5LINEAR?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@FJOMOHLK@Model?5already?5LINEAR?4?6?$AA@ DB 'Model already LINE'
	DB	'AR.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JMIEKNGL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5L@
CONST	SEGMENT
??_C@_0CK@JMIEKNGL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5L@ DB 'Changin'
	DB	'g to LINEAR model. (was LAGRANGE)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FEBBPANL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5Q@
CONST	SEGMENT
??_C@_0CL@FEBBPANL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5Q@ DB 'Changin'
	DB	'g to LINEAR model. (was QUADRATIC)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PABEINCB@Model?5already?5QUADRATIC?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@PABEINCB@Model?5already?5QUADRATIC?4?6?$AA@ DB 'Model already Q'
	DB	'UADRATIC.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BFEEPGEG@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@
CONST	SEGMENT
??_C@_0CN@BFEEPGEG@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@ DB 'Changing'
	DB	' to QUADRATIC model. (was LAGRANGE)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IKOBFHOD@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@
CONST	SEGMENT
??_C@_0CL@IKOBFHOD@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@ DB 'Changing'
	DB	' to QUADRATIC model. (was LINEAR)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@FNJALPPL@Bad?5model?5choice?4?5Legal?3?51?5?$CIline@
CONST	SEGMENT
??_C@_0EE@FNJALPPL@Bad?5model?5choice?4?5Legal?3?51?5?$CIline@ DB 'Bad mo'
	DB	'del choice. Legal: 1 (linear), 2 (quadratic), > 2 (Lagrange)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@KLMKCJCH@Changing?5to?5LAGRANGE?5?$CFd?5model?4?5?$CI@
CONST	SEGMENT
??_C@_0DC@KLMKCJCH@Changing?5to?5LAGRANGE?5?$CFd?5model?4?5?$CI@ DB 'Chan'
	DB	'ging to LAGRANGE %d model. (was LAGRANGE %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NAGKEEOG@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@
CONST	SEGMENT
??_C@_0CN@NAGKEEOG@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@ DB 'Changing'
	DB	' to LAGRANGE model. (was QUADRATIC)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JBOLHCFI@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@
CONST	SEGMENT
??_C@_0CK@JBOLHCFI@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@ DB 'Changing'
	DB	' to LAGRANGE model. (was LINEAR)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EJALKLLC@Gravity?5is?5now?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BE@EJALKLLC@Gravity?5is?5now?5OFF?4?$AA@ DB 'Gravity is now OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@FCBICJJI@Gravity?5is?5now?5ON?5with?5gravitati@
CONST	SEGMENT
??_C@_0DC@FCBICJJI@Gravity?5is?5now?5ON?5with?5gravitati@ DB 'Gravity is '
	DB	'now ON with gravitational constant %g.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HABEDKHM@Scale?5optimizing?5with?5bound?5?$CFg?4?6@
CONST	SEGMENT
??_C@_0CB@HABEDKHM@Scale?5optimizing?5with?5bound?5?$CFg?4?6@ DB 'Scale o'
	DB	'ptimizing with bound %g.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KHLJFDIK@Scale?5fixed?5at?5?$CFg?4?6?$AA@
CONST	SEGMENT
??_C@_0BE@KHLJFDIK@Scale?5fixed?5at?5?$CFg?4?6?$AA@ DB 'Scale fixed at %g'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LHJNONFJ@Deleted?5edges?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BD@LHJNONFJ@Deleted?5edges?3?5?$CFd?6?$AA@ DB 'Deleted edges: %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ENNEDDMF@Skinny?5triangles?5weeded?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BN@ENNEDDMF@Skinny?5triangles?5weeded?3?5?$CFd?6?$AA@ DB 'Skinny t'
	DB	'riangles weeded: %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KKGGCNAE@Diffusion?5ON?4?$AA@
CONST	SEGMENT
??_C@_0O@KKGGCNAE@Diffusion?5ON?4?$AA@ DB 'Diffusion ON.', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3e45798ee2308c3a
CONST	SEGMENT
__real@3e45798ee2308c3a DQ 03e45798ee2308c3ar	; 1e-008
CONST	ENDS
;	COMDAT ??_C@_0BN@KADAPAAJ@Number?5of?5edges?5notched?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BN@KADAPAAJ@Number?5of?5edges?5notched?3?5?$CFd?6?$AA@ DB 'Number '
	DB	'of edges notched: %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@JKPEEAKK@refine?5edge?5ee?5where?5max?$CIee?4vert@
CONST	SEGMENT
??_C@_0DC@JKPEEAKK@refine?5edge?5ee?5where?5max?$CIee?4vert@ DB 'refine e'
	DB	'dge ee where max(ee.vertex,dihedral) > %f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FEKICMHJ@Notching?5angle?5not?5positive?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@FEKICMHJ@Notching?5angle?5not?5positive?4?6?$AA@ DB 'Notching a'
	DB	'ngle not positive.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KANBCPFA@Notching?5not?5implemented?5for?5sim@
CONST	SEGMENT
??_C@_0DG@KANBCPFA@Notching?5not?5implemented?5for?5sim@ DB 'Notching not'
	DB	' implemented for simplex representation.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02PHMGELLB@?6?6?$AA@
CONST	SEGMENT
??_C@_02PHMGELLB@?6?6?$AA@ DB 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HAOIJKIC@?$CFc?$AA@
CONST	SEGMENT
??_C@_02HAOIJKIC@?$CFc?$AA@ DB '%c', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08GPHOBFCD@?$CF20?415g?6?$AA@
CONST	SEGMENT
??_C@_08GPHOBFCD@?$CF20?415g?6?$AA@ DB '%20.15g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@BIPFCNNO@binary_printf?5format?5string?5has?5@
CONST	SEGMENT
??_C@_0EE@BIPFCNNO@binary_printf?5format?5string?5has?5@ DB 'binary_print'
	DB	'f format string has unrecognized format character ''%c''', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@OOJIKBOM@binary_printf?3?5you?5must?5set?5?8big@
CONST	SEGMENT
??_C@_0EF@OOJIKBOM@binary_printf?3?5you?5must?5set?5?8big@ DB 'binary_pri'
	DB	'ntf: you must set ''big_endian'' or ''little_endian'' toggles'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@GNCLKEFD@Format?5string?5has?5?$CFd?5formats?0?5bu@
CONST	SEGMENT
??_C@_0EA@GNCLKEFD@Format?5string?5has?5?$CFd?5formats?0?5bu@ DB 'Format '
	DB	'string has %d formats, but there are only %d arguments.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PHJFLEKB@Illegal?5format?5specifier?3?5?$CFn?6?$AA@
CONST	SEGMENT
??_C@_0BO@PHJFLEKB@Illegal?5format?5specifier?3?5?$CFn?6?$AA@ DB 'Illegal'
	DB	' format specifier: %n', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PPNJJAGI@?$CINaN?$CJ?$AA@
CONST	SEGMENT
??_C@_05PPNJJAGI@?$CINaN?$CJ?$AA@ DB '(NaN)', 00H	; `string'
CONST	ENDS
;	COMDAT __real@7e37e43c8800759c
CONST	SEGMENT
__real@7e37e43c8800759c DQ 07e37e43c8800759cr	; 1e+300
CONST	ENDS
;	COMDAT __real@fe37e43c8800759c
CONST	SEGMENT
__real@fe37e43c8800759c DQ 0fe37e43c8800759cr	; -1e+300
CONST	ENDS
;	COMDAT __real@54b249ad2594c37d
CONST	SEGMENT
__real@54b249ad2594c37d DQ 054b249ad2594c37dr	; 1e+100
CONST	ENDS
;	COMDAT ??_C@_06LHGEHABH@?$CINULL?$CJ?$AA@
CONST	SEGMENT
??_C@_06LHGEHABH@?$CINULL?$CJ?$AA@ DB '(NULL)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KCHMNGLN@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$DL?5nnode?9@
CONST	SEGMENT
??_C@_0CL@KCHMNGLN@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$DL?5nnode?9@ DB '('
	DB	'source file %s, line %d; nnode->type %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DDEBKHJG@Possibly?5?$CF?5not?5followed?5by?5legal@
CONST	SEGMENT
??_C@_0CK@DDEBKHJG@Possibly?5?$CF?5not?5followed?5by?5legal@ DB 'Possibly'
	DB	' % not followed by legal format?', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@PCELCLJI@Argument?5?$CFd?3?5String?5format?5does?5@
CONST	SEGMENT
??_C@_0DL@PCELCLJI@Argument?5?$CFd?3?5String?5format?5does?5@ DB 'Argumen'
	DB	't %d: String format does not have string argument.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FAGILPDO@?$CF?40s?$AA@
CONST	SEGMENT
??_C@_04FAGILPDO@?$CF?40s?$AA@ DB '%.0s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NIOJGFPH@?$CF0?40s?$AA@
CONST	SEGMENT
??_C@_05NIOJGFPH@?$CF0?40s?$AA@ DB '%0.0s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLENCFID@Set?5png?5name?$DN?$AA@
CONST	SEGMENT
??_C@_0O@MLENCFID@Set?5png?5name?$DN?$AA@ DB 'Set png name=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LLDLGANG@Set?5png?5prefix?$DN?$AA@
CONST	SEGMENT
??_C@_0BA@LLDLGANG@Set?5png?5prefix?$DN?$AA@ DB 'Set png prefix=', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EMICKKLA@Saving?5png?6?$AA@
CONST	SEGMENT
??_C@_0M@EMICKKLA@Saving?5png?6?$AA@ DB 'Saving png', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GFMHNHBN@1?4?5?$CFs?3?5?$CF17?415g?5energy?3?5?$CF17?415g?5?5@
CONST	SEGMENT
??_C@_0CO@GFMHNHBN@1?4?5?$CFs?3?5?$CF17?415g?5energy?3?5?$CF17?415g?5?5@ DB '1'
	DB	'. %s: %17.15g energy: %17.15g  stepsize: %g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@BBCBJJDC@interpolation?5of?5boundary?5parame@
CONST	SEGMENT
??_C@_0EA@BBCBJJDC@interpolation?5of?5boundary?5parame@ DB 'interpolation'
	DB	' of boundary parameters OFF (using extrapolation).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NNHEBOBN@interpolation?5of?5boundary?5parame@
CONST	SEGMENT
??_C@_0CK@NNHEBOBN@interpolation?5of?5boundary?5parame@ DB 'interpolation'
	DB	' of boundary parameters  ON.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JFPGPFKD@Hessian?5by?5differences?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BM@JFPGPFKD@Hessian?5by?5differences?5OFF?4?$AA@ DB 'Hessian by di'
	DB	'fferences OFF.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DGFOJMBA@Hessian?5by?5differences?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BL@DGFOJMBA@Hessian?5by?5differences?5ON?4?$AA@ DB 'Hessian by dif'
	DB	'ferences ON.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@FNHPJGDA@Hessian_diff?5not?5implemented?5for@
CONST	SEGMENT
??_C@_0DG@FNHPJGDA@Hessian_diff?5not?5implemented?5for@ DB 'Hessian_diff '
	DB	'not implemented for constrained quants.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FJEPDOCE@hessian_quiet?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BD@FJEPDOCE@hessian_quiet?5OFF?4?$AA@ DB 'hessian_quiet OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DBDGMAIK@hessian_quiet?5?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BD@DBDGMAIK@hessian_quiet?5?5ON?4?$AA@ DB 'hessian_quiet  ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DNMJIMAC@hessian_normal_one?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BI@DNMJIMAC@hessian_normal_one?5OFF?4?$AA@ DB 'hessian_normal_one '
	DB	'OFF.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FFLAHCKM@hessian_normal_one?5?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BI@FFLAHCKM@hessian_normal_one?5?5ON?4?$AA@ DB 'hessian_normal_one'
	DB	'  ON.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@GODKPABP@HESSIAN_NORMAL_ONE?5only?5for?5STRI@
CONST	SEGMENT
??_C@_0DP@GODKPABP@HESSIAN_NORMAL_ONE?5only?5for?5STRI@ DB 'HESSIAN_NORMA'
	DB	'L_ONE only for STRING or SOAPFILM hypersurfaces.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HLBKECJE@hessian_double_normal?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BL@HLBKECJE@hessian_double_normal?5OFF?4?$AA@ DB 'hessian_double_n'
	DB	'ormal OFF.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BDGDLMDK@hessian_double_normal?5?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BL@BDGDLMDK@hessian_double_normal?5?5ON?4?$AA@ DB 'hessian_double_'
	DB	'normal  ON.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FGBJHBNH@hessian_normal_perp?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BJ@FGBJHBNH@hessian_normal_perp?5OFF?4?$AA@ DB 'hessian_normal_per'
	DB	'p OFF.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DOGAIPHJ@hessian_normal_perp?5?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BJ@DOGAIPHJ@hessian_normal_perp?5?5ON?4?$AA@ DB 'hessian_normal_pe'
	DB	'rp  ON.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JNLHDNMC@hessian_special_normal?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BM@JNLHDNMC@hessian_special_normal?5OFF?4?$AA@ DB 'hessian_special'
	DB	'_normal OFF.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BKKLNAFN@hessian_special_normal?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BL@BKKLNAFN@hessian_special_normal?5ON?4?$AA@ DB 'hessian_special_'
	DB	'normal ON.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CDHDEEDF@hessian_special_normal_vector?5no@
CONST	SEGMENT
??_C@_0CI@CDHDEEDF@hessian_special_normal_vector?5no@ DB 'hessian_special'
	DB	'_normal_vector not set.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GEJIPBCC@hessian_normal?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BE@GEJIPBCC@hessian_normal?5OFF?4?$AA@ DB 'hessian_normal OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MOBAPIM@hessian_normal?5?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BE@MOBAPIM@hessian_normal?5?5ON?4?$AA@ DB 'hessian_normal  ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EMGJHHB@Sobolev?5area?5mode?$AA@
CONST	SEGMENT
??_C@_0BC@EMGJHHB@Sobolev?5area?5mode?$AA@ DB 'Sobolev area mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IPOHGFDM@bezier_basis?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BC@IPOHGFDM@bezier_basis?5OFF?4?$AA@ DB 'bezier_basis OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OHJOJLJC@bezier_basis?5?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BC@OHJOJLJC@bezier_basis?5?5ON?4?$AA@ DB 'bezier_basis  ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EHCKFCGI@mpi_local_bodies?$AA@
CONST	SEGMENT
??_C@_0BB@EHCKFCGI@mpi_local_bodies?$AA@ DB 'mpi_local_bodies', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PJOICEHA@mpi_debug?$AA@
CONST	SEGMENT
??_C@_09PJOICEHA@mpi_debug?$AA@ DB 'mpi_debug', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EKBDJBFN@little_endian?$AA@
CONST	SEGMENT
??_C@_0O@EKBDJBFN@little_endian?$AA@ DB 'little_endian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HGLBMAAF@big_endian?$AA@
CONST	SEGMENT
??_C@_0L@HGLBMAAF@big_endian?$AA@ DB 'big_endian', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NBNMFCPF@pop_enjoin?$AA@
CONST	SEGMENT
??_C@_0L@NBNMFCPF@pop_enjoin?$AA@ DB 'pop_enjoin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PDGIDHIC@pop_disjoin?$AA@
CONST	SEGMENT
??_C@_0M@PDGIDHIC@pop_disjoin?$AA@ DB 'pop_disjoin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FHCBDAPB@pop_to_face?$AA@
CONST	SEGMENT
??_C@_0M@FHCBDAPB@pop_to_face?$AA@ DB 'pop_to_face', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CAFGBCMP@pop_to_edge?$AA@
CONST	SEGMENT
??_C@_0M@CAFGBCMP@pop_to_edge?$AA@ DB 'pop_to_edge', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PCBOIGLG@full_bounding_box?$AA@
CONST	SEGMENT
??_C@_0BC@PCBOIGLG@full_bounding_box?$AA@ DB 'full_bounding_box', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CPNIHMEN@smooth?5graph?$AA@
CONST	SEGMENT
??_C@_0N@CPNIHMEN@smooth?5graph?$AA@ DB 'smooth graph', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PMMMILEF@K?5altitude?5mode?$AA@
CONST	SEGMENT
??_C@_0BA@PMMMILEF@K?5altitude?5mode?$AA@ DB 'K altitude mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DMGKDBMO@Kraynik?5pop?5edge?5mode?$AA@
CONST	SEGMENT
??_C@_0BG@DMGKDBMO@Kraynik?5pop?5edge?5mode?$AA@ DB 'Kraynik pop edge mod'
	DB	'e', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FLPPIDJA@Kraynik?5pop?5vertex?5mode?$AA@
CONST	SEGMENT
??_C@_0BI@FLPPIDJA@Kraynik?5pop?5vertex?5mode?$AA@ DB 'Kraynik pop vertex'
	DB	' mode', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IOAHFOPJ@Circular?5arc?5drawing?$AA@
CONST	SEGMENT
??_C@_0BF@IOAHFOPJ@Circular?5arc?5drawing?$AA@ DB 'Circular arc drawing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CLHENHLJ@visibility?5test?$AA@
CONST	SEGMENT
??_C@_0BA@CLHENHLJ@visibility?5test?$AA@ DB 'visibility test', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CFDHHPOD@sparse?5constraints?$AA@
CONST	SEGMENT
??_C@_0BD@CFDHHPOD@sparse?5constraints?$AA@ DB 'sparse constraints', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DOMBLPMO@augmented?5Hessian?$AA@
CONST	SEGMENT
??_C@_0BC@DOMBLPMO@augmented?5Hessian?$AA@ DB 'augmented Hessian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@ECALEFFC@This?5Evolver?5not?5compiled?5with?5B@
CONST	SEGMENT
??_C@_0CG@ECALEFFC@This?5Evolver?5not?5compiled?5with?5B@ DB 'This Evolve'
	DB	'r not compiled with BLAS.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DNFIILFK@Break?5on?5warning?$AA@
CONST	SEGMENT
??_C@_0BB@DNFIILFK@Break?5on?5warning?$AA@ DB 'Break on warning', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BDGKJNKH@Break?5after?5warning?$AA@
CONST	SEGMENT
??_C@_0BE@BDGKJNKH@Break?5after?5warning?$AA@ DB 'Break after warning', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OOMCHPBN@RGB?5colors?$AA@
CONST	SEGMENT
??_C@_0L@OOMCHPBN@RGB?5colors?$AA@ DB 'RGB colors', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GOKADGNC@Dirichlet?5area?5mode?$AA@
CONST	SEGMENT
??_C@_0BE@GOKADGNC@Dirichlet?5area?5mode?$AA@ DB 'Dirichlet area mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GLKAJGNE@QuietGo?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0N@GLKAJGNE@QuietGo?5OFF?4?$AA@ DB 'QuietGo OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LECGJNII@QuietGo?5ON?4?$AA@
CONST	SEGMENT
??_C@_0M@LECGJNII@QuietGo?5ON?4?$AA@ DB 'QuietGo ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FHIDEKKO@?5?5?$CI?$CFs?5not?5set?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BA@FHIDEKKO@?5?5?$CI?$CFs?5not?5set?$CJ?6?$AA@ DB '  (%s not set)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MFKIHKAF@?5?5?$CI?$CFs?3?5?$CFg?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0M@MFKIHKAF@?5?5?$CI?$CFs?3?5?$CFg?$CJ?6?$AA@ DB '  (%s: %g)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPOBHEAO@zener_coeff?$AA@
CONST	SEGMENT
??_C@_0M@GPOBHEAO@zener_coeff?$AA@ DB 'zener_coeff', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BBPCCDGD@?5?$CIwas?5off?$CJ?$AA@
CONST	SEGMENT
??_C@_0L@BBPCCDGD@?5?$CIwas?5off?$CJ?$AA@ DB ' (was off)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MIGIKFMF@?5?$CIwas?5on?$CJ?$AA@
CONST	SEGMENT
??_C@_09MIGIKFMF@?5?$CIwas?5on?$CJ?$AA@ DB ' (was on)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GBNDBAOB@Zener_drag?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BA@GBNDBAOB@Zener_drag?5OFF?4?$AA@ DB 'Zener_drag OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MHAOIPAG@Zener_drag?5ON?4?$AA@
CONST	SEGMENT
??_C@_0P@MHAOIPAG@Zener_drag?5ON?4?$AA@ DB 'Zener_drag ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BJAHIEEH@Volgrads_every?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BE@BJAHIEEH@Volgrads_every?5OFF?4?$AA@ DB 'Volgrads_every OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BEFDILEO@Volgrads_every?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BD@BEFDILEO@Volgrads_every?5ON?4?$AA@ DB 'Volgrads_every ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CJLDGBEG@rotate_lights?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BD@CJLDGBEG@rotate_lights?5OFF?4?$AA@ DB 'rotate_lights OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BFEJGDKB@rotate_lights?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BC@BFEJGDKB@rotate_lights?5ON?4?$AA@ DB 'rotate_lights ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OLHNPOHO@backcull?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0O@OLHNPOHO@backcull?5OFF?4?$AA@ DB 'backcull OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MCJPMBN@backcull?5ON?4?$AA@
CONST	SEGMENT
??_C@_0N@MCJPMBN@backcull?5ON?4?$AA@ DB 'backcull ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DNBOACGN@clip_view?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0P@DNBOACGN@clip_view?5OFF?4?$AA@ DB 'clip_view OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LJHGAHLN@clip_view?5ON?4?$AA@
CONST	SEGMENT
??_C@_0O@LJHGAHLN@clip_view?5ON?4?$AA@ DB 'clip_view ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IOBHBMAO@slice_view?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BA@IOBHBMAO@slice_view?5OFF?4?$AA@ DB 'slice_view OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NGBCEKEF@slice_view?5ON?4?$AA@
CONST	SEGMENT
??_C@_0P@NGBCEKEF@slice_view?5ON?4?$AA@ DB 'slice_view ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CPAMODLH@star_finagling?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BE@CPAMODLH@star_finagling?5OFF?4?$AA@ DB 'star_finagling OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BMHOINOE@star_finagling?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BD@BMHOINOE@star_finagling?5ON?4?$AA@ DB 'star_finagling ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ENOCFBBI@force_deletion?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BE@ENOCFBBI@force_deletion?5OFF?4?$AA@ DB 'force_deletion OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CPNBPNLI@force_deletion?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BD@CPNBPNLI@force_deletion?5ON?4?$AA@ DB 'force_deletion ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IKPAIAFC@view_transforms_use_unique?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0CA@IKPAIAFC@view_transforms_use_unique?5OFF?4?$AA@ DB 'view_transf'
	DB	'orms_use_unique OFF.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OKKIADMD@view_transforms_use_unique?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BP@OKKIADMD@view_transforms_use_unique?5ON?4?$AA@ DB 'view_transfo'
	DB	'rms_use_unique ON.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NLKJDFAI@detorus_sticky?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BE@NLKJDFAI@detorus_sticky?5OFF?4?$AA@ DB 'detorus_sticky OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GNBNGDPC@detorus_sticky?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BD@GNBNGDPC@detorus_sticky?5ON?4?$AA@ DB 'detorus_sticky ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OKHCNJJN@function_quantity_sparse?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BO@OKHCNJJN@function_quantity_sparse?5OFF?4?$AA@ DB 'function_quan'
	DB	'tity_sparse OFF.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NIHPBJFM@function_quantity_sparse?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BN@NIHPBJFM@function_quantity_sparse?5ON?4?$AA@ DB 'function_quant'
	DB	'ity_sparse ON.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HOGKKAKM@QuietLoad?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0P@HOGKKAKM@QuietLoad?5OFF?4?$AA@ DB 'QuietLoad OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KEDNKMNF@QuietLoad?5ON?4?$AA@
CONST	SEGMENT
??_C@_0O@KEDNKMNF@QuietLoad?5ON?4?$AA@ DB 'QuietLoad ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FBKEFKCC@Quiet?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0L@FBKEFKCC@Quiet?5OFF?4?$AA@ DB 'Quiet OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FLLKFOJ@Quiet?5ON?4?$AA@
CONST	SEGMENT
??_C@_09FLLKFOJ@Quiet?5ON?4?$AA@ DB 'Quiet ON.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@POKCPLOD@Verbose?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0N@POKCPLOD@Verbose?5OFF?4?$AA@ DB 'Verbose OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JABCIEA@Verbose?5ON?4?$AA@
CONST	SEGMENT
??_C@_0M@JABCIEA@Verbose?5ON?4?$AA@ DB 'Verbose ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IGCELFFA@torus_filled?$AA@
CONST	SEGMENT
??_C@_0N@IGCELFFA@torus_filled?$AA@ DB 'torus_filled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@HAMHICGC@torus_filled?5is?5invalid?5toggle?5b@
CONST	SEGMENT
??_C@_0DM@HAMHICGC@torus_filled?5is?5invalid?5toggle?5b@ DB 'torus_filled'
	DB	' is invalid toggle because not in torus model.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FKFJNJHN@septum_flag?$AA@
CONST	SEGMENT
??_C@_0M@FKFJNJHN@septum_flag?$AA@ DB 'septum_flag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BMEBABFE@show_all_edges?$AA@
CONST	SEGMENT
??_C@_0P@BMEBABFE@show_all_edges?$AA@ DB 'show_all_edges', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IOPGAMGF@show_bounding_box?$AA@
CONST	SEGMENT
??_C@_0BC@IOPGAMGF@show_bounding_box?$AA@ DB 'show_bounding_box', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ECHDFDIC@ps_labelflag?$AA@
CONST	SEGMENT
??_C@_0N@ECHDFDIC@ps_labelflag?$AA@ DB 'ps_labelflag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JJEIJGBI@crossingflag?$AA@
CONST	SEGMENT
??_C@_0N@JJEIJGBI@crossingflag?$AA@ DB 'crossingflag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NAKIPJII@ps_gridflag?$AA@
CONST	SEGMENT
??_C@_0M@NAKIPJII@ps_gridflag?$AA@ DB 'ps_gridflag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EJEJKKN@force_edgeswap?$AA@
CONST	SEGMENT
??_C@_0P@EJEJKKN@force_edgeswap?$AA@ DB 'force_edgeswap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LOFHKFBI@ps_cmykflag?$AA@
CONST	SEGMENT
??_C@_0M@LOFHKFBI@ps_cmykflag?$AA@ DB 'ps_cmykflag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PDJMPNAK@ps_colorflag?$AA@
CONST	SEGMENT
??_C@_0N@PDJMPNAK@ps_colorflag?$AA@ DB 'ps_colorflag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PABNDBOD@show_all_quantities?$AA@
CONST	SEGMENT
??_C@_0BE@PABNDBOD@show_all_quantities?$AA@ DB 'show_all_quantities', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NLHBLELH@Area?5normalization?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BI@NLHBLELH@Area?5normalization?5OFF?4?$AA@ DB 'Area normalization'
	DB	' OFF.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LFJMNMPC@Area?5normalization?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BH@LFJMNMPC@Area?5normalization?5ON?4?$AA@ DB 'Area normalization '
	DB	'ON.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@ELOHAFKC@Conjugate?5gradient?5now?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BM@ELOHAFKC@Conjugate?5gradient?5now?5OFF?4?$AA@ DB 'Conjugate gra'
	DB	'dient now OFF.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@ DB '('
	DB	'source file %s, line %d)', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@IGNPBNFB@Fixed?5scale?5is?5ON?$CB?5Not?5a?5good?5id@
CONST	SEGMENT
??_C@_0DN@IGNPBNFB@Fixed?5scale?5is?5ON?$CB?5Not?5a?5good?5id@ DB 'Fixed '
	DB	'scale is ON! Not a good idea with conjugate gradient.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@JMDAFIPN@Conjugate?5gradient?5now?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BL@JMDAFIPN@Conjugate?5gradient?5now?5ON?4?$AA@ DB 'Conjugate grad'
	DB	'ient now ON.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NBBBJCB@Polak?9Ribiere?5conjugate?5gradient@
CONST	SEGMENT
??_C@_0CG@NBBBJCB@Polak?9Ribiere?5conjugate?5gradient@ DB 'Polak-Ribiere '
	DB	'conjugate gradient OFF.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DJCKCFC@Polak?9Ribiere?5conjugate?5gradient@
CONST	SEGMENT
??_C@_0CF@DJCKCFC@Polak?9Ribiere?5conjugate?5gradient@ DB 'Polak-Ribiere '
	DB	'conjugate gradient ON.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HAOGCDPC@jiggling?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0O@HAOGCDPC@jiggling?5OFF?4?$AA@ DB 'jiggling OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PDDGMANN@jiggling?5ON?4?$AA@
CONST	SEGMENT
??_C@_0N@PDDGMANN@jiggling?5ON?4?$AA@ DB 'jiggling ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ILJCGNII@Keylogfile?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BA@ILJCGNII@Keylogfile?5OFF?4?$AA@ DB 'Keylogfile OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FDDENPIC@Keylogfile?5ON?4?$AA@
CONST	SEGMENT
??_C@_0P@FDDENPIC@Keylogfile?5ON?4?$AA@ DB 'Keylogfile ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JKAGEBIA@Logfile?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0N@JKAGEBIA@Logfile?5OFF?4?$AA@ DB 'Logfile OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MGBDILFJ@Logfile?5ON?4?$AA@
CONST	SEGMENT
??_C@_0M@MGBDILFJ@Logfile?5ON?4?$AA@ DB 'Logfile ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LDDNFFJB@geomview?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0O@LDDNFFJB@geomview?5OFF?4?$AA@ DB 'geomview OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CEMOACCA@geomview?5ON?4?$AA@
CONST	SEGMENT
??_C@_0N@CEMOACCA@geomview?5ON?4?$AA@ DB 'geomview ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HKDJJHHO@geompipe?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0O@HKDJJHHO@geompipe?5OFF?4?$AA@ DB 'geompipe OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CMCMGLFD@geompipe?5ON?4?$AA@
CONST	SEGMENT
??_C@_0N@CMCMGLFD@geompipe?5ON?4?$AA@ DB 'geompipe ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CBFBFNPC@assume_oriented?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BF@CBFBFNPC@assume_oriented?5OFF?4?$AA@ DB 'assume_oriented OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JKEIPKOM@assume_oriented?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BE@JKEIPKOM@assume_oriented?5ON?4?$AA@ DB 'assume_oriented ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IBDCGPFP@h_inverse_metric?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BG@IBDCGPFP@h_inverse_metric?5OFF?4?$AA@ DB 'h_inverse_metric OFF.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PDJICPAM@h_inverse_metric?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BF@PDJICPAM@h_inverse_metric?5ON?4?$AA@ DB 'h_inverse_metric ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OPPOGKDN@approx_curvature?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BG@OPPOGKDN@approx_curvature?5OFF?4?$AA@ DB 'approx_curvature OFF.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FEJLKKJL@approx_curvature?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BF@FEJLKKJL@approx_curvature?5ON?4?$AA@ DB 'approx_curvature ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OJIMPIFF@old_area?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0O@OJIMPIFF@old_area?5OFF?4?$AA@ DB 'old_area OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JALMNNNO@old_area?5ON?4?$AA@
CONST	SEGMENT
??_C@_0N@JALMNNNO@old_area?5ON?4?$AA@ DB 'old_area ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NBPBOIPD@Autochopping?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BC@NBPBOIPD@Autochopping?5OFF?4?$AA@ DB 'Autochopping OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@BNGJBEEG@Set?5autochop?5length?5with?5?5AUTOCH@
CONST	SEGMENT
??_C@_0DE@BNGJBEEG@Set?5autochop?5length?5with?5?5AUTOCH@ DB 'Set autocho'
	DB	'p length with  AUTOCHOP_LENGTH := value', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HOOMNLNJ@Autochopping?5ON?4?5Chop?5length?5?$CFg?5@
CONST	SEGMENT
??_C@_0CB@HOOMNLNJ@Autochopping?5ON?4?5Chop?5length?5?$CFg?5@ DB 'Autocho'
	DB	'pping ON. Chop length %g ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BCKOLDII@Immediate?5autopop?5mode?5OFF?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@BCKOLDII@Immediate?5autopop?5mode?5OFF?4?6?$AA@ DB 'Immediate a'
	DB	'utopop mode OFF.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@ILBHGCJG@Immediate?5autopop?5mode?5ON?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@ILBHGCJG@Immediate?5autopop?5mode?5ON?4?6?$AA@ DB 'Immediate au'
	DB	'topop mode ON.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KFBMCIKD@Autopop?5quartic?5mode?5OFF?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@KFBMCIKD@Autopop?5quartic?5mode?5OFF?4?6?$AA@ DB 'Autopop quart'
	DB	'ic mode OFF.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IENAHCOI@Autopop?5quartic?5mode?5ON?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@IENAHCOI@Autopop?5quartic?5mode?5ON?4?6?$AA@ DB 'Autopop quarti'
	DB	'c mode ON.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OAFHPFJG@Number?5of?5vertices?5popped?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BP@OAFHPFJG@Number?5of?5vertices?5popped?3?5?$CFd?6?$AA@ DB 'Numbe'
	DB	'r of vertices popped: %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KKHKLGGG@Autopopping?5OFF?4?6?$AA@
CONST	SEGMENT
??_C@_0BC@KKHKLGGG@Autopopping?5OFF?4?6?$AA@ DB 'Autopopping OFF.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OCLHIDKB@Autopopping?5ON?4?6?$AA@
CONST	SEGMENT
??_C@_0BB@OCLHIDKB@Autopopping?5ON?4?6?$AA@ DB 'Autopopping ON.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PIHNBFDB@Squared?5Gaussian?5curvature?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0CA@PIHNBFDB@Squared?5Gaussian?5curvature?5OFF?4?$AA@ DB 'Squared G'
	DB	'aussian curvature OFF.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GAFKOFAF@Squared?5Gaussian?5curvature?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BP@GAFKOFAF@Squared?5Gaussian?5curvature?5ON?4?$AA@ DB 'Squared Ga'
	DB	'ussian curvature ON.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GCABNAHH@Enter?5unit?5normal?5weight?5factor?$CI@
CONST	SEGMENT
??_C@_0CG@GCABNAHH@Enter?5unit?5normal?5weight?5factor?$CI@ DB 'Enter uni'
	DB	't normal weight factor(%g): ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PPEAKFND@Unit?5normal?5motion?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BI@PPEAKFND@Unit?5normal?5motion?5OFF?4?$AA@ DB 'Unit normal motio'
	DB	'n OFF.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DACOBOAB@Unit?5normal?5motion?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BH@DACOBOAB@Unit?5normal?5motion?5ON?4?$AA@ DB 'Unit normal motion'
	DB	' ON.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LDBBFNCP@Transform?5showing?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BH@LDBBFNCP@Transform?5showing?5OFF?4?$AA@ DB 'Transform showing O'
	DB	'FF.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IMGLMCA@Transform?5showing?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BG@IMGLMCA@Transform?5showing?5ON?4?$AA@ DB 'Transform showing ON.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MMAAEFMG@Estimation?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BA@MMAAEFMG@Estimation?5OFF?4?$AA@ DB 'Estimation OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HDNDOOGM@Estimation?5ON?4?$AA@
CONST	SEGMENT
??_C@_0P@HDNDOOGM@Estimation?5ON?4?$AA@ DB 'Estimation ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OMIPPGDJ@Force?5positive?5definite?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BN@OMIPPGDJ@Force?5positive?5definite?5OFF?4?$AA@ DB 'Force positi'
	DB	've definite OFF.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JDOFKCBJ@Force?5positive?5definite?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BM@JDOFKCBJ@Force?5positive?5definite?5ON?4?$AA@ DB 'Force positiv'
	DB	'e definite ON.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MFIJFNML@Autorecalc?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BA@MFIJFNML@Autorecalc?5OFF?4?$AA@ DB 'Autorecalc OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMIHMIGA@Autorecalc?5ON?4?$AA@
CONST	SEGMENT
??_C@_0P@EMIHMIGA@Autorecalc?5ON?4?$AA@ DB 'Autorecalc ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FPPHODPN@Mean?5curvature?5integral?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BN@FPPHODPN@Mean?5curvature?5integral?5OFF?4?$AA@ DB 'Mean curvatu'
	DB	're integral OFF.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@INIKEIOB@Mean?5curvature?5integral?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BM@INIKEIOB@Mean?5curvature?5integral?5ON?4?$AA@ DB 'Mean curvatur'
	DB	'e integral ON.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FAPOAGGN@Post?9projection?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BF@FAPOAGGN@Post?9projection?5OFF?4?$AA@ DB 'Post-projection OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IEJGOMKI@Post?9projection?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BE@IEJGOMKI@Post?9projection?5ON?4?$AA@ DB 'Post-projection ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@EFADNMIL@Conformal?5edge?5square?5curvature?5@
CONST	SEGMENT
??_C@_0CF@EFADNMIL@Conformal?5edge?5square?5curvature?5@ DB 'Conformal ed'
	DB	'ge square curvature OFF.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KDGBEDPF@Conformal?5edge?5square?5curvature?5@
CONST	SEGMENT
??_C@_0CE@KDGBEDPF@Conformal?5edge?5square?5curvature?5@ DB 'Conformal ed'
	DB	'ge square curvature ON.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BCLOFPDG@Boundary?5curvature?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BI@BCLOFPDG@Boundary?5curvature?5OFF?4?$AA@ DB 'Boundary curvature'
	DB	' OFF.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HGFHNLIB@Boundary?5curvature?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BH@HGFHNLIB@Boundary?5curvature?5ON?4?$AA@ DB 'Boundary curvature '
	DB	'ON.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GMEPNJMN@Edge?5square?5curvature?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BL@GMEPNJMN@Edge?5square?5curvature?5OFF?4?$AA@ DB 'Edge square cu'
	DB	'rvature OFF.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DGKNJNIM@Edge?5square?5curvature?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BK@DGKNJNIM@Edge?5square?5curvature?5ON?4?$AA@ DB 'Edge square cur'
	DB	'vature ON.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LLFAACBP@Geomview?5binary?5mode?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BK@LLFAACBP@Geomview?5binary?5mode?5OFF?4?$AA@ DB 'Geomview binary'
	DB	' mode OFF.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CEKEKBGN@Geomview?5binary?5mode?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BJ@CEKEKBGN@Geomview?5binary?5mode?5ON?4?$AA@ DB 'Geomview binary '
	DB	'mode ON.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NBLNNAOK@Self?5similarity?5mode?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BK@NBLNNAOK@Self?5similarity?5mode?5OFF?4?$AA@ DB 'Self similarity'
	DB	' mode OFF.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HJFGKGHM@Self?5similarity?5mode?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BJ@HJFGKGHM@Self?5similarity?5mode?5ON?4?$AA@ DB 'Self similarity '
	DB	'mode ON.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NNAJHAMG@Metric?5conversion?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BH@NNAJHAMG@Metric?5conversion?5OFF?4?$AA@ DB 'Metric conversion O'
	DB	'FF.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HLONLCLH@Metric?5conversion?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BG@HLONLCLH@Metric?5conversion?5ON?4?$AA@ DB 'Metric conversion ON'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ODCIPKND@Constraint?5pinning?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BI@ODCIPKND@Constraint?5pinning?5OFF?4?$AA@ DB 'Constraint pinning'
	DB	' OFF.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DEBAHMFA@Constraint?5pinning?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BH@DEBAHMFA@Constraint?5pinning?5ON?4?$AA@ DB 'Constraint pinning '
	DB	'ON.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KPMAPKLM@4D?5graphics?5?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BC@KPMAPKLM@4D?5graphics?5?5OFF?4?$AA@ DB '4D graphics  OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LFAAENHB@4D?5graphics?5?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BB@LFAAENHB@4D?5graphics?5?5ON?4?$AA@ DB '4D graphics  ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DHLHFHDN@Normal?5motion?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BD@DHLHFHDN@Normal?5motion?5OFF?4?$AA@ DB 'Normal motion OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BAINHADD@Normal?5motion?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BC@BAINHADD@Normal?5motion?5ON?4?$AA@ DB 'Normal motion ON.', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\evalmore.c
CONST	ENDS
;	COMDAT _more_other_stuff
_TEXT	SEGMENT
_x$92436 = -2084					; size = 4
_text_size$92898 = -2084				; size = 8
tv10403 = -2076						; size = 4
_c$92401 = -2076					; size = 4
_yspot$92899 = -2072					; size = 8
_x$92426 = -2072					; size = 8
_m$92415 = -2064					; size = 2
tv8608 = -2064						; size = 4
tv7227 = -2064						; size = 4
tv7182 = -2064						; size = 4
_text$92896 = -2064					; size = 4
tv10032 = -2060						; size = 4
_buf$92418 = -2060					; size = 2
tv10005 = -2058						; size = 2
_array_info$92662 = -2056				; size = 4
_n$ = -2056						; size = 4
_size$92653 = -2052					; size = 4
_td$ = -2052						; size = 4
_different_size$92663 = -2048				; size = 4
_buf$92439 = -2048					; size = 4
_sp$92303 = -2048					; size = 4
_itemsize$92659 = -2044					; size = 4
_byte_reverse$92365 = -2044				; size = 4
_msgspot$92302 = -2044					; size = 4
_dim$92652 = -2040					; size = 4
_buf$92408 = -2040					; size = 4
_newmsgsize$92279 = -2040				; size = 4
tv10114 = -2036						; size = 4
_formatcount$92280 = -2036				; size = 4
tv10255 = -2032						; size = 4
_localstack$GSCopy$ = -2032				; size = 4
tv3759 = -2032						; size = 4
_i$92749 = -2032					; size = 4
_newoff$92701 = -2032					; size = 4
_s$92603 = -2032					; size = 4
_m$92405 = -2032					; size = 4
_update_display_flag$GSCopy$ = -2028			; size = 4
_oldoff$92696 = -2028					; size = 4
_pointercount$92660 = -2028				; size = 4
_sp$92378 = -2028					; size = 4
_ss$92310 = -2028					; size = 4
_f$92307 = -2028					; size = 4
_s$ = -2028						; size = 4
tv10324 = -2024						; size = 4
tv10002 = -2024						; size = 4
tv6673 = -2024						; size = 4
tv6670 = -2024						; size = 4
_recalc_flag$GSCopy$ = -2024				; size = 4
tv3787 = -2024						; size = 4
_k$92751 = -2024					; size = 4
_vnum$92727 = -2024					; size = 4
_od$92709 = -2024					; size = 4
_p$92703 = -2024					; size = 4
_s$92594 = -2024					; size = 4
_nnode$92384 = -2024					; size = 4
_nnode$92309 = -2024					; size = 4
_old$ = -2024						; size = 4
tv10154 = -2020						; size = 4
tv10059 = -2020						; size = 4
_oldarray$92661 = -2020					; size = 4
_g$92656 = -2016					; size = 4
_formatcount$92364 = -2016				; size = 4
_newmsg$92278 = -2016					; size = 4
_response$ = -2012					; size = 1000
_format$92363 = -1012					; size = 1000
_format$92277 = -1012					; size = 1000
tv10000 = -12						; size = 8
tv7426 = -12						; size = 8
_xspot$92900 = -12					; size = 8
_v$92808 = -12						; size = 8
_v$92796 = -12						; size = 8
_v$92782 = -12						; size = 8
_value$92753 = -12					; size = 8
_buf$92428 = -12					; size = 8
_ltime$92246 = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_node$ = 8						; size = 4
_recalc_flag$ = 12					; size = 4
_update_display_flag$ = 16				; size = 4
_q_id$ = 20						; size = 4
_localstack$ = 24					; size = 4
_localbase$ = 28					; size = 4
_more_other_stuff PROC					; COMDAT

; 2922 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 2084				; 00000824H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5141 :            break;

	mov	eax, DWORD PTR _recalc_flag$[ebp]
	mov	ecx, DWORD PTR _update_display_flag$[ebp]
	mov	edx, DWORD PTR _localstack$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _node$[ebp]
	push	esi
	mov	DWORD PTR _recalc_flag$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _thread_data_key
	push	edi
	mov	edi, DWORD PTR _localbase$[ebp]
	push	eax
	mov	DWORD PTR _update_display_flag$GSCopy$[ebp], ecx
	mov	DWORD PTR _localstack$GSCopy$[ebp], edx
	call	_win_get_thread_data
	mov	esi, eax
	mov	eax, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [eax-10548]
	add	esp, 4
	mov	DWORD PTR _td$[ebp], esi
	cmp	ecx, 214				; 000000d6H
	ja	$LN3@more_other

; 2923 :   char response[1000];
; 2924 :   int old; /* old state of toggle */
; 2925 :   int n,i;
; 2926 :   char *s;
; 2927 :   int oldquiet; /* old state of quiet_flag */
; 2928 : 
; 2929 :   struct thread_data *td = GET_THREAD_DATA;
; 2930 :   #define newstack  (td->eval_stack)
; 2931 :   #define stackmax  (td->eval_stack_size)
; 2932 :   #define stacktop  (td->stack_top)
; 2933 :   #define this_frame ((struct eval_frame*)(newstack + td->frame_spot))
; 2934 : 
; 2935 :   switch ( node->type )

	jmp	DWORD PTR $LN1434@more_other[ecx*4]
$LN625@more_other:

; 2936 :   {
; 2937 :     case WRAP_VERTEX_NODE:
; 2938 :          { vertex_id v_id = get_ordinal_id(VERTEX,(int)(stacktop[-1])-1);

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx-8]
	call	__ftol2_sse
	dec	eax
	push	eax
	push	0
	call	_get_ordinal_id

; 2939 :            int wrap = (int)(stacktop[0]);

	mov	ebx, DWORD PTR [esi+48]
	fld	QWORD PTR [ebx]
	add	esp, 8
	mov	edi, eax
	call	__ftol2_sse

; 2940 : 
; 2941 :            stacktop -= 2;

	add	ebx, -16				; fffffff0H
	mov	DWORD PTR [esi+48], ebx

; 2942 :            if ( !web.symmetry_flag || !wrap ) break;

	cmp	DWORD PTR _web+856, 0
	je	$LN626@more_other
	test	eax, eax
	je	$LN626@more_other

; 2943 :            wrap_vertex(v_id,wrap);

	push	eax
	push	edi
	call	_wrap_vertex

; 2944 :            *update_display_flag = 1;

	mov	edx, DWORD PTR _update_display_flag$GSCopy$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	mov	DWORD PTR [edx], 1
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN622@more_other:

; 2945 :          }
; 2946 :          break;
; 2947 : 
; 2948 :     case NORMAL_MOTION_NODE:
; 2949 :          old = normal_motion_flag;

	mov	esi, DWORD PTR _normal_motion_flag

; 2950 :          normal_motion_flag = (node->op1.toggle_state==ON_) ? 1 : 0; 

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _normal_motion_flag, eax

; 2951 :          outstring(normal_motion_flag ? "Normal motion ON.":
; 2952 :                                           "Normal motion OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BC@BAINHADD@Normal?5motion?5ON?4?$AA@
	jne	SHORT $LN631@more_other
	mov	eax, OFFSET ??_C@_0BD@DHLHFHDN@Normal?5motion?5OFF?4?$AA@
$LN631@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 2953 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN633@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN633@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 2954 :          if ( normal_motion_flag )

	cmp	DWORD PTR _normal_motion_flag, 0
	je	SHORT $LN621@more_other

; 2955 :              begin_normal_motion();

	call	_begin_normal_motion
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN621@more_other:

; 2956 :          else end_normal_motion();

	call	_end_normal_motion
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN619@more_other:

; 2957 :          break;
; 2958 : 
; 2959 :     case VIEW_4D_NODE: 
; 2960 :          old = view_4D_flag;

	mov	esi, DWORD PTR _view_4D_flag

; 2961 :          view_4D_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _view_4D_flag, eax

; 2962 :          outstring(view_4D_flag ? "4D graphics  ON." :
; 2963 :                                             "4D graphics  OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BB@LFAAENHB@4D?5graphics?5?5ON?4?$AA@
	jne	SHORT $LN635@more_other
	mov	eax, OFFSET ??_C@_0BC@KPMAPKLM@4D?5graphics?5?5OFF?4?$AA@
$LN635@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 2964 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN637@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN637@more_other:
	push	eax
	call	_outstring
	add	esp, 4
$LN1425@more_other:

; 2965 :          update_display();

	call	_update_display
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN618@more_other:

; 2966 :          break;
; 2967 :      
; 2968 :     case PINNING_NODE: 
; 2969 :          old = check_pinning_flag;

	mov	esi, DWORD PTR _check_pinning_flag

; 2970 :          check_pinning_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _check_pinning_flag, eax

; 2971 :          outstring(check_pinning_flag ? "Constraint pinning ON." :
; 2972 :                                             "Constraint pinning OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BH@DEBAHMFA@Constraint?5pinning?5ON?4?$AA@
	jne	SHORT $LN639@more_other
	mov	eax, OFFSET ??_C@_0BI@ODCIPKND@Constraint?5pinning?5OFF?4?$AA@
$LN639@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 2973 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN641@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN641@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN617@more_other:

; 2974 :          break;
; 2975 :      
; 2976 :     case METRIC_CONVERSION_NODE: 
; 2977 :          old = metric_convert_flag;

	mov	esi, DWORD PTR _metric_convert_flag

; 2978 :          metric_convert_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _metric_convert_flag, eax

; 2979 :          outstring(metric_convert_flag ? "Metric conversion ON." :
; 2980 :                                             "Metric conversion OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BG@HLONLCLH@Metric?5conversion?5ON?4?$AA@
	jne	SHORT $LN643@more_other
	mov	eax, OFFSET ??_C@_0BH@NNAJHAMG@Metric?5conversion?5OFF?4?$AA@
$LN643@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 2981 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN645@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN645@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN616@more_other:

; 2982 :          break;
; 2983 :      
; 2984 : 
; 2985 :     case SELF_SIMILAR_NODE: 
; 2986 :          old = self_similar_flag;

	mov	esi, DWORD PTR _self_similar_flag

; 2987 :          self_similar_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _self_similar_flag, eax

; 2988 :          outstring(self_similar_flag ? "Self similarity mode ON." :
; 2989 :                                             "Self similarity mode OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BJ@HJFGKGHM@Self?5similarity?5mode?5ON?4?$AA@
	jne	SHORT $LN647@more_other
	mov	eax, OFFSET ??_C@_0BK@NBLNNAOK@Self?5similarity?5mode?5OFF?4?$AA@
$LN647@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 2990 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN649@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN649@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN615@more_other:

; 2991 :          break;
; 2992 : 
; 2993 :     case GV_BINARY_NODE: 
; 2994 :          old = gv_binary_flag;

	mov	esi, DWORD PTR _gv_binary_flag

; 2995 :          gv_binary_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _gv_binary_flag, eax

; 2996 :          outstring(gv_binary_flag ? "Geomview binary mode ON." :
; 2997 :                                             "Geomview binary mode OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BJ@CEKEKBGN@Geomview?5binary?5mode?5ON?4?$AA@
	jne	SHORT $LN651@more_other
	mov	eax, OFFSET ??_C@_0BK@LLFAACBP@Geomview?5binary?5mode?5OFF?4?$AA@
$LN651@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 2998 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN653@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN653@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN614@more_other:

; 2999 :          break;
; 3000 :      
; 3001 :     case KUSNER_NODE: 
; 3002 :          old = kusner_flag;

	mov	esi, DWORD PTR _kusner_flag

; 3003 :          kusner_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H

; 3004 :          conf_edge_curv_flag = 0;

	mov	DWORD PTR _conf_edge_curv_flag, 0
	sete	al
	mov	DWORD PTR _kusner_flag, eax

; 3005 :          outstring(kusner_flag ? "Edge square curvature ON." :
; 3006 :                                             "Edge square curvature OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BK@DGKNJNIM@Edge?5square?5curvature?5ON?4?$AA@
	jne	SHORT $LN655@more_other
	mov	eax, OFFSET ??_C@_0BL@GMEPNJMN@Edge?5square?5curvature?5OFF?4?$AA@
$LN655@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3007 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN657@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN657@more_other:
	push	eax
$LN1412@more_other:
	call	_outstring
	add	esp, 4
$LN1427@more_other:

; 3008 :          recalc();

	call	_recalc
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN613@more_other:

; 3009 :          break;
; 3010 :      
; 3011 :     case BOUNDARY_CURVATURE_NODE: 
; 3012 :          old = boundary_curvature_flag;

	mov	esi, DWORD PTR _boundary_curvature_flag

; 3013 :          boundary_curvature_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _boundary_curvature_flag, eax

; 3014 :          outstring(boundary_curvature_flag ? "Boundary curvature ON." :
; 3015 :                                             "Boundary curvature OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BH@HGFHNLIB@Boundary?5curvature?5ON?4?$AA@
	jne	SHORT $LN655@more_other
	mov	eax, OFFSET ??_C@_0BI@BCLOFPDG@Boundary?5curvature?5OFF?4?$AA@

; 3016 :          outstring(old?" (was on)\n":" (was off)\n");
; 3017 :          recalc();
; 3018 :          break;

	jmp	SHORT $LN655@more_other
$LN612@more_other:

; 3019 :      
; 3020 :     case CONF_EDGE_SQCURV_NODE: 
; 3021 :          old = conf_edge_curv_flag;

	mov	esi, DWORD PTR _conf_edge_curv_flag

; 3022 :          conf_edge_curv_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H

; 3023 :          kusner_flag = 0;

	mov	DWORD PTR _kusner_flag, 0
	sete	al
	mov	DWORD PTR _conf_edge_curv_flag, eax

; 3024 :          outstring(conf_edge_curv_flag ? 
; 3025 :                 "Conformal edge square curvature ON." :
; 3026 :                 "Conformal edge square curvature OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0CE@KDGBEDPF@Conformal?5edge?5square?5curvature?5@
	jne	$LN655@more_other
	mov	eax, OFFSET ??_C@_0CF@EFADNMIL@Conformal?5edge?5square?5curvature?5@

; 3027 :          outstring(old?" (was on)\n":" (was off)\n");
; 3028 :          recalc();
; 3029 :          break;

	jmp	$LN655@more_other
$LN611@more_other:

; 3030 : 
; 3031 :     case POST_PROJECT_NODE: 
; 3032 :          old = post_project_flag;

	mov	esi, DWORD PTR _post_project_flag

; 3033 :          post_project_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _post_project_flag, eax

; 3034 :          outstring(post_project_flag ? "Post-projection ON." :
; 3035 :                 "Post-projection OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BE@IEJGOMKI@Post?9projection?5ON?4?$AA@
	jne	SHORT $LN667@more_other
	mov	eax, OFFSET ??_C@_0BF@FAPOAGGN@Post?9projection?5OFF?4?$AA@
$LN667@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3036 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN669@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN669@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN610@more_other:

; 3037 :          break;
; 3038 : 
; 3039 :     case MEAN_CURV_INT_NODE: 
; 3040 :          old = mean_curv_int_flag;

	mov	esi, DWORD PTR _mean_curv_int_flag

; 3041 :          mean_curv_int_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _mean_curv_int_flag, eax

; 3042 :          outstring(mean_curv_int_flag ? "Mean curvature integral ON." :
; 3043 :                 "Mean curvature integral OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BM@INIKEIOB@Mean?5curvature?5integral?5ON?4?$AA@
	jne	SHORT $LN671@more_other
	mov	eax, OFFSET ??_C@_0BN@FPPHODPN@Mean?5curvature?5integral?5OFF?4?$AA@
$LN671@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3044 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN673@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN673@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN609@more_other:

; 3045 :          break;
; 3046 : 
; 3047 :     case AUTORECALC_NODE: 
; 3048 :          old = autorecalc_flag;

	mov	esi, DWORD PTR _autorecalc_flag

; 3049 :          autorecalc_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _autorecalc_flag, eax

; 3050 :          outstring(autorecalc_flag ? "Autorecalc ON." : "Autorecalc OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0P@EMIHMIGA@Autorecalc?5ON?4?$AA@
	jne	SHORT $LN675@more_other
	mov	eax, OFFSET ??_C@_0BA@MFIJFNML@Autorecalc?5OFF?4?$AA@
$LN675@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3051 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN677@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN677@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN608@more_other:

; 3052 :          break;
; 3053 : 
; 3054 :     case FORCE_POS_DEF_NODE: 
; 3055 :          old = make_pos_def_flag;

	mov	esi, DWORD PTR _make_pos_def_flag

; 3056 :          make_pos_def_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _make_pos_def_flag, eax

; 3057 :          outstring(make_pos_def_flag ? "Force positive definite ON." : 
; 3058 :                 "Force positive definite OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BM@JDOFKCBJ@Force?5positive?5definite?5ON?4?$AA@
	jne	SHORT $LN679@more_other
	mov	eax, OFFSET ??_C@_0BN@OMIPPGDJ@Force?5positive?5definite?5OFF?4?$AA@
$LN679@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3059 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN681@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN681@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN607@more_other:

; 3060 :          break;
; 3061 : 
; 3062 :     case ESTIMATE_NODE: 
; 3063 :          old = estimate_flag;

	mov	esi, DWORD PTR _estimate_flag

; 3064 :          estimate_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _estimate_flag, eax

; 3065 :          outstring(estimate_flag ? "Estimation ON." : "Estimation OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0P@HDNDOOGM@Estimation?5ON?4?$AA@
	jne	SHORT $LN683@more_other
	mov	eax, OFFSET ??_C@_0BA@MMAAEFMG@Estimation?5OFF?4?$AA@
$LN683@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3066 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN685@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN685@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN606@more_other:

; 3067 :          break;
; 3068 : 
; 3069 :     case TRANSFORMS_NODE: 
; 3070 :          old = transforms_flag;

	mov	esi, DWORD PTR _transforms_flag

; 3071 :          transforms_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _transforms_flag, eax

; 3072 :          outstring(transforms_flag ? "Transform showing ON." : 
; 3073 :                                     "Transform showing OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BG@IMGLMCA@Transform?5showing?5ON?4?$AA@
	jne	$LN635@more_other
	mov	eax, OFFSET ??_C@_0BH@LDBBFNCP@Transform?5showing?5OFF?4?$AA@

; 3074 :          outstring(old?" (was on)\n":" (was off)\n");
; 3075 :          update_display();
; 3076 :          break;

	jmp	$LN635@more_other
$LN605@more_other:

; 3077 : 
; 3078 :     case DETURCK_NODE:
; 3079 :          old = unit_normal_flag;

	mov	esi, DWORD PTR _unit_normal_flag

; 3080 :          unit_normal_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al

; 3081 :          outstring(sqgauss_flag ? "Unit normal motion ON." :
; 3082 :                                             "Unit normal motion OFF.");

	cmp	DWORD PTR _sqgauss_flag, 0
	mov	DWORD PTR _unit_normal_flag, eax
	mov	eax, OFFSET ??_C@_0BH@DACOBOAB@Unit?5normal?5motion?5ON?4?$AA@
	jne	SHORT $LN691@more_other
	mov	eax, OFFSET ??_C@_0BI@PPEAKFND@Unit?5normal?5motion?5OFF?4?$AA@
$LN691@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3083 :          if ( unit_normal_flag )

	cmp	DWORD PTR _unit_normal_flag, 0
	je	SHORT $LN604@more_other

; 3084 :               { sprintf(msg,"Enter unit normal weight factor(%g): ",
; 3085 :                          (DOUBLE)deturck_factor);

	fld	QWORD PTR _deturck_factor
	mov	ecx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CG@GCABNAHH@Enter?5unit?5normal?5weight?5factor?$CI@
	push	ecx
	call	_sprintf

; 3086 :                  prompt(msg,response,sizeof(response));

	mov	eax, DWORD PTR _msg
	push	1000					; 000003e8H
	lea	edx, DWORD PTR _response$[ebp]
	push	edx
	push	eax
	call	_prompt

; 3087 :                  const_expr(response,&deturck_factor);

	lea	ecx, DWORD PTR _response$[ebp]
	push	OFFSET _deturck_factor
	push	ecx
	call	_const_expr
	add	esp, 36					; 00000024H
$LN604@more_other:

; 3088 :               }
; 3089 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN693@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN693@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN603@more_other:

; 3090 :          break;
; 3091 : 
; 3092 :     case SQGAUSS_NODE: 
; 3093 :          old = sqgauss_flag;

	mov	esi, DWORD PTR _sqgauss_flag

; 3094 :          sqgauss_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _sqgauss_flag, eax

; 3095 :          outstring(sqgauss_flag ? "Squared Gaussian curvature ON." :
; 3096 :                                             "Squared Gaussian curvature OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BP@GAFKOFAF@Squared?5Gaussian?5curvature?5ON?4?$AA@
	jne	$LN655@more_other
	mov	eax, OFFSET ??_C@_0CA@PIHNBFDB@Squared?5Gaussian?5curvature?5OFF?4?$AA@

; 3097 :          outstring(old?" (was on)\n":" (was off)\n");
; 3098 :          recalc();
; 3099 :          break;

	jmp	$LN655@more_other
$LN602@more_other:

; 3100 : 
; 3101 :     case STABILITY_TEST_NODE: 
; 3102 :          stability_test();

	call	_stability_test
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN601@more_other:

; 3103 :          break;
; 3104 : 
; 3105 :     case AUTOPOP_NODE: 
; 3106 :          old = autopop_flag;

	mov	esi, DWORD PTR _autopop_flag

; 3107 :          autopop_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _autopop_flag, eax

; 3108 :          outstring(autopop_flag ? "Autopopping ON.\n" : "Autopopping OFF.\n");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BB@OCLHIDKB@Autopopping?5ON?4?6?$AA@
	jne	SHORT $LN699@more_other
	mov	eax, OFFSET ??_C@_0BC@KKHKLGGG@Autopopping?5OFF?4?6?$AA@
$LN699@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3109 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN701@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN701@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3110 :          if ( autopop_flag )

	cmp	DWORD PTR _autopop_flag, 0
	je	$LN626@more_other

; 3111 :             { n = 0; 
; 3112 :               if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN599@more_other

; 3113 :                  sprintf(msg,"Number of vertices popped: %d\n",
; 3114 :                     web.vertex_pop_count = n=verpop_str());

	call	_verpop_str
	mov	edx, DWORD PTR _msg
	mov	esi, eax
	push	esi
	push	OFFSET ??_C@_0BP@OAFHPFJG@Number?5of?5vertices?5popped?3?5?$CFd?6?$AA@
	push	edx

; 3115 :               else

	jmp	SHORT $LN1406@more_other
$LN599@more_other:

; 3116 :                  sprintf(msg,"Number of vertices popped: %d\n",
; 3117 :                             web.vertex_pop_count = n = edgepop_film());

	call	_edgepop_film
	mov	esi, eax
	mov	eax, DWORD PTR _msg
	push	esi
	push	OFFSET ??_C@_0BP@OAFHPFJG@Number?5of?5vertices?5popped?3?5?$CFd?6?$AA@
	push	eax
$LN1406@more_other:
	mov	DWORD PTR _web+5476, esi
	call	_sprintf

; 3118 :               outstring(msg);

	mov	ecx, DWORD PTR _msg
	add	esp, 12					; 0000000cH
	push	ecx
	call	_outstring
	add	esp, 4

; 3119 :               if ( n > 0 ) recalc();

	test	esi, esi
	jle	$LN626@more_other

; 3120 :             }
; 3121 :          break;

	jmp	$LN1427@more_other
$LN596@more_other:

; 3122 : 
; 3123 :     case AUTOPOP_QUARTIC_NODE: 
; 3124 :          old = autopop_quartic_flag;

	mov	esi, DWORD PTR _autopop_quartic_flag

; 3125 :          autopop_quartic_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _autopop_quartic_flag, eax

; 3126 :          outstring(autopop_quartic_flag ? "Autopop quartic mode ON.\n" :
; 3127 :             "Autopop quartic mode OFF.\n");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BK@IENAHCOI@Autopop?5quartic?5mode?5ON?4?6?$AA@
	jne	SHORT $LN703@more_other
	mov	eax, OFFSET ??_C@_0BL@KFBMCIKD@Autopop?5quartic?5mode?5OFF?4?6?$AA@
$LN703@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3128 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN705@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN705@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN595@more_other:

; 3129 :          break;
; 3130 : 
; 3131 :     case IMMEDIATE_AUTOPOP_NODE: 
; 3132 :          old = immediate_autopop_flag;

	mov	esi, DWORD PTR _immediate_autopop_flag

; 3133 :          immediate_autopop_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _immediate_autopop_flag, eax

; 3134 :          outstring(immediate_autopop_flag ? "Immediate autopop mode ON.\n" :
; 3135 :              "Immediate autopop mode OFF.\n");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BM@ILBHGCJG@Immediate?5autopop?5mode?5ON?4?6?$AA@
	jne	SHORT $LN707@more_other
	mov	eax, OFFSET ??_C@_0BN@BCKOLDII@Immediate?5autopop?5mode?5OFF?4?6?$AA@
$LN707@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3136 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN709@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN709@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN594@more_other:

; 3137 :          break;
; 3138 : 
; 3139 :     case AUTOCHOP_NODE:
; 3140 :          old = autochop_flag;

	mov	esi, DWORD PTR _autochop_flag

; 3141 :          autochop_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _autochop_flag, eax

; 3142 :          if ( autochop_flag )

	test	eax, eax
	je	SHORT $LN593@more_other

; 3143 :          { 
; 3144 :            sprintf(msg,"Autochopping ON. Chop length %g ",(DOUBLE)autochop_length);

	fld	QWORD PTR _autochop_length
	mov	edx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CB@HOOMNLNJ@Autochopping?5ON?4?5Chop?5length?5?$CFg?5@
	push	edx
	call	_sprintf

; 3145 :            outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H

; 3146 :            outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN711@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN711@more_other:
	push	eax
	call	_outstring

; 3147 :            outstring("Set autochop length with  AUTOCHOP_LENGTH := value\n");

	push	OFFSET ??_C@_0DE@BNGJBEEG@Set?5autochop?5length?5with?5?5AUTOCH@
	call	_outstring
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN593@more_other:

; 3148 :          }
; 3149 :          else 
; 3150 :          { outstring("Autochopping OFF.");

	push	OFFSET ??_C@_0BC@NBPBOIPD@Autochopping?5OFF?4?$AA@
	call	_outstring
	add	esp, 4

; 3151 :            outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN713@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN713@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN591@more_other:

; 3152 :          }
; 3153 :          break;
; 3154 : 
; 3155 :     case UTEST_NODE: 
; 3156 :          simplex_delaunay_test();

	call	_simplex_delaunay_test
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN590@more_other:

; 3157 :          break;
; 3158 : 
; 3159 :     case OLD_AREA_NODE: 
; 3160 :          old = old_area_flag;

	mov	esi, DWORD PTR _old_area_flag

; 3161 :          old_area_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _old_area_flag, eax

; 3162 :          outstring(old_area_flag ? "old_area ON." : "old_area OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0N@JALMNNNO@old_area?5ON?4?$AA@
	jne	SHORT $LN715@more_other
	mov	eax, OFFSET ??_C@_0O@OJIMPIFF@old_area?5OFF?4?$AA@
$LN715@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3163 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN717@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN717@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN589@more_other:

; 3164 :          break;
; 3165 : 
; 3166 :     case APPROX_CURV_NODE: 
; 3167 :          old = approx_curve_flag;

	mov	esi, DWORD PTR _approx_curve_flag

; 3168 :          approx_curve_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _approx_curve_flag, eax

; 3169 :          outstring(approx_curve_flag ? "approx_curvature ON." :
; 3170 :                                             "approx_curvature OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BF@FEJLKKJL@approx_curvature?5ON?4?$AA@
	jne	SHORT $LN719@more_other
	mov	eax, OFFSET ??_C@_0BG@OPPOGKDN@approx_curvature?5OFF?4?$AA@
$LN719@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3171 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN721@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN721@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN588@more_other:

; 3172 :          break;
; 3173 : 
; 3174 :     case H_INVERSE_METRIC_NODE: 
; 3175 :          old = web.h_inverse_metric_flag;

	mov	esi, DWORD PTR _web+812

; 3176 :          web.h_inverse_metric_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _web+812, eax

; 3177 :          outstring(web.h_inverse_metric_flag ? "h_inverse_metric ON." :
; 3178 :                                             "h_inverse_metric OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BF@PDJICPAM@h_inverse_metric?5ON?4?$AA@
	jne	SHORT $LN723@more_other
	mov	eax, OFFSET ??_C@_0BG@IBDCGPFP@h_inverse_metric?5OFF?4?$AA@
$LN723@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3179 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN725@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN725@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN587@more_other:

; 3180 :          break;
; 3181 : 
; 3182 :     case ASSUME_ORIENTED_NODE: 
; 3183 :          old = assume_oriented_flag;

	mov	esi, DWORD PTR _assume_oriented_flag

; 3184 :          assume_oriented_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _assume_oriented_flag, eax

; 3185 :          outstring(assume_oriented_flag ? "assume_oriented ON." :
; 3186 :                                             "assume_oriented OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BE@JKEIPKOM@assume_oriented?5ON?4?$AA@
	jne	SHORT $LN727@more_other
	mov	eax, OFFSET ??_C@_0BF@CBFBFNPC@assume_oriented?5OFF?4?$AA@
$LN727@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3187 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN729@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN729@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN586@more_other:

; 3188 :          break;
; 3189 : 
; 3190 :     case OOGLFILE_NODE:
; 3191 :          strncpy(pix_file_name,*(char**)(stacktop--),sizeof(pix_file_name));

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [eax]
	push	1000					; 000003e8H
	push	ecx
	add	eax, -8					; fffffff8H
	push	OFFSET _pix_file_name
	mov	DWORD PTR [esi+48], eax
	call	_strncpy

; 3192 :          do_gfile('2',pix_file_name);

	push	OFFSET _pix_file_name
	push	50					; 00000032H
	call	_do_gfile
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN585@more_other:

; 3193 :          break;
; 3194 : 
; 3195 :     case BINARY_OFF_FILE_NODE:
; 3196 :          strncpy(pix_file_name,*(char**)(stacktop--),sizeof(pix_file_name));

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [eax]
	push	1000					; 000003e8H
	push	ecx
	add	eax, -8					; fffffff8H
	push	OFFSET _pix_file_name
	mov	DWORD PTR [esi+48], eax
	call	_strncpy

; 3197 :          do_gfile('7',pix_file_name);

	push	OFFSET _pix_file_name
	push	55					; 00000037H
	call	_do_gfile
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN584@more_other:

; 3198 :          break;
; 3199 : 
; 3200 :     case POSTSCRIPT_NODE:
; 3201 :          if ( ps_colorflag < 0 )  ps_colorflag = 0 ;

	xor	eax, eax
	cmp	DWORD PTR _ps_colorflag, eax
	jge	SHORT $LN583@more_other
	mov	DWORD PTR _ps_colorflag, eax
$LN583@more_other:

; 3202 :          if ( gridflag < 0 ) gridflag = 0;

	cmp	DWORD PTR _gridflag, eax
	jge	SHORT $LN582@more_other
	mov	DWORD PTR _gridflag, eax
$LN582@more_other:

; 3203 :          if ( crossingflag < 0 ) crossingflag = 0;

	cmp	DWORD PTR _crossingflag, eax
	jge	SHORT $LN581@more_other
	mov	DWORD PTR _crossingflag, eax
$LN581@more_other:

; 3204 :          if ( labelflag < 0 ) labelflag = 0;

	cmp	DWORD PTR _labelflag, eax
	jge	SHORT $LN580@more_other
	mov	DWORD PTR _labelflag, eax
$LN580@more_other:

; 3205 :          if ( torus_display_mode == TORUS_DEFAULT_MODE ) 

	cmp	DWORD PTR _torus_display_mode, eax
	jne	SHORT $LN579@more_other

; 3206 :          { torus_display_mode = TORUS_RAW_MODE;

	mov	DWORD PTR _torus_display_mode, 1

; 3207 :            web.torus_body_flag = 0; 

	mov	DWORD PTR _web+804, eax

; 3208 :            web.torus_clip_flag = 0; 

	mov	DWORD PTR _web+800, eax
$LN579@more_other:

; 3209 :          }
; 3210 :          strncpy(ps_file_name,*(char**)(stacktop--),sizeof(ps_file_name));

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [eax]
	push	1000					; 000003e8H
	push	ecx
	add	eax, -8					; fffffff8H
	push	OFFSET _ps_file_name
	mov	DWORD PTR [esi+48], eax
	call	_strncpy

; 3211 :          do_gfile('3',ps_file_name);

	push	OFFSET _ps_file_name
	push	51					; 00000033H
	call	_do_gfile
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN578@more_other:

; 3212 :          break;
; 3213 : 
; 3214 :     case SET_CONSTRAINT_GLOBAL_NODE:
; 3215 :          { int connum = (int)(*stacktop--);

	mov	edi, DWORD PTR [esi+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	mov	ebx, eax

; 3216 :            struct constraint *con = get_constraint(connum);

	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	edi, -8					; fffffff8H
	mov	DWORD PTR [esi+48], edi
	add	eax, DWORD PTR _web+652

; 3217 :            if ( !(con->attr & GLOBAL) )

	xor	esi, esi
	mov	edx, DWORD PTR [eax+32]
	mov	edi, DWORD PTR [eax+36]
	mov	ecx, edx
	and	ecx, 4
	or	ecx, esi
	jne	$LN626@more_other

; 3218 :            { vertex_id v_id;
; 3219 :              con->attr |= GLOBAL;

	or	edx, 4
	mov	DWORD PTR [eax+32], edx
	mov	DWORD PTR [eax+36], edi

; 3220 :              web.con_global_map[web.con_global_count++] = (conmap_t)connum;

	mov	ecx, DWORD PTR _web+748
	mov	DWORD PTR _web[ecx*4+656], ebx

; 3221 :              FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+48
	inc	DWORD PTR _web+748
	test	ecx, 268435456				; 10000000H
	je	$LN626@more_other
	mov	edi, DWORD PTR _web+12
	npad	2
$LL576@more_other:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [edi+esi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN575@more_other

; 3222 :                 set_v_constraint_map(v_id,connum);

	push	ebx
	push	ecx
	call	_set_v_constraint_map
	mov	edi, DWORD PTR _web+12
	add	esp, 8
$LN575@more_other:

; 3221 :              FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR [edi+esi]
	mov	ecx, DWORD PTR [edx]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL576@more_other
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN571@more_other:

; 3223 :            }
; 3224 :          }
; 3225 :          break;              
; 3226 : 
; 3227 :     case UNSET_CONSTRAINT_GLOBAL_NODE:
; 3228 :          { unsigned int connum = (int)(*stacktop--);

	mov	ecx, DWORD PTR [esi+48]
	fnstcw	WORD PTR tv10005[ebp]
	movzx	eax, WORD PTR tv10005[ebp]
	fld	QWORD PTR [ecx]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv10002[ebp], eax
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR [esi+48], ecx
	fldcw	WORD PTR tv10002[ebp]
	fistp	QWORD PTR tv10000[ebp]
	mov	edx, DWORD PTR tv10000[ebp]

; 3229 :            struct constraint *con = get_constraint(connum);

	mov	eax, edx
	and	eax, 1073741823				; 3fffffffH
	fldcw	WORD PTR tv10005[ebp]
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 3230 :            con->attr &= ~GLOBAL;

	mov	ecx, DWORD PTR [eax+36]
	and	DWORD PTR [eax+32], -5			; fffffffbH
	mov	DWORD PTR [eax+36], ecx

; 3231 :            for ( i = 0 ; i < web.con_global_count ; i++ )

	mov	ecx, DWORD PTR _web+748
	xor	eax, eax
	test	ecx, ecx
	jle	$LN626@more_other
	npad	5
$LL570@more_other:

; 3232 :              if ( web.con_global_map[i] == connum )

	cmp	DWORD PTR _web[eax*4+656], edx
	je	SHORT $LN1044@more_other

; 3231 :            for ( i = 0 ; i < web.con_global_count ; i++ )

	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL570@more_other
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1044@more_other:

; 3233 :              { web.con_global_map[i] = 
; 3234 :                     web.con_global_map[--web.con_global_count]; 

	dec	ecx
	pop	edi
	mov	DWORD PTR _web+748, ecx
	mov	edx, DWORD PTR _web[ecx*4+656]
	pop	esi
	mov	DWORD PTR _web[eax*4+656], edx
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN566@more_other:

; 3235 :                break;
; 3236 :              }
; 3237 :          }
; 3238 :          break;
; 3239 : 
; 3240 :     case SET_CONSTRAINT_NAME_GLOBAL_NODE:
; 3241 :          { int connum = node->op3.connum;

	mov	ebx, DWORD PTR [ebx+140]

; 3242 :            struct constraint *con = get_constraint(connum);

	mov	eax, ebx
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 3243 :            if ( !(con->attr & GLOBAL) )

	xor	edi, edi
	mov	edx, DWORD PTR [eax+32]
	mov	esi, DWORD PTR [eax+36]
	mov	ecx, edx
	and	ecx, 4
	or	ecx, edi
	jne	$LN626@more_other

; 3244 :            { vertex_id v_id;
; 3245 :              con->attr |= GLOBAL;

	or	edx, 4
	mov	DWORD PTR [eax+32], edx
	mov	DWORD PTR [eax+36], esi

; 3246 :              web.con_global_map[web.con_global_count++] = (conmap_t)connum;

	mov	eax, DWORD PTR _web+748
	mov	DWORD PTR _web[eax*4+656], ebx

; 3247 :              FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR _web+48
	inc	DWORD PTR _web+748
	test	ecx, 268435456				; 10000000H
	je	$LN626@more_other
	mov	edi, DWORD PTR _web+12
$LL564@more_other:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN563@more_other

; 3248 :                 set_v_constraint_map(v_id,connum);

	push	ebx
	push	ecx
	call	_set_v_constraint_map
	mov	edi, DWORD PTR _web+12
	add	esp, 8
$LN563@more_other:

; 3247 :              FOR_ALL_VERTICES(v_id)

	mov	ecx, DWORD PTR [esi+edi]
	mov	ecx, DWORD PTR [ecx]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL564@more_other
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN559@more_other:

; 3249 :            }
; 3250 :          }
; 3251 :          break;              
; 3252 : 
; 3253 :     case UNSET_CONSTRAINT_NAME_GLOBAL_NODE:
; 3254 :          { unsigned int connum = node->op3.connum;

	mov	ebx, DWORD PTR [ebx+140]

; 3255 :            struct constraint *con = get_constraint(connum);

	mov	eax, ebx
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	add	eax, DWORD PTR _web+652

; 3256 :            con->attr &= ~GLOBAL;

	mov	edx, DWORD PTR [eax+36]
	and	DWORD PTR [eax+32], -5			; fffffffbH
	mov	DWORD PTR [eax+36], edx

; 3257 :            for ( i = 0 ; i < web.con_global_count ; i++ )

	mov	ecx, DWORD PTR _web+748
	xor	eax, eax
	test	ecx, ecx
	jle	$LN626@more_other
$LL558@more_other:

; 3258 :              if ( web.con_global_map[i] == connum )

	cmp	DWORD PTR _web[eax*4+656], ebx
	je	SHORT $LN1045@more_other

; 3257 :            for ( i = 0 ; i < web.con_global_count ; i++ )

	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL558@more_other
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1045@more_other:

; 3259 :              { web.con_global_map[i] = 
; 3260 :                     web.con_global_map[--web.con_global_count]; 

	dec	ecx
	pop	edi
	mov	DWORD PTR _web+748, ecx
	mov	ecx, DWORD PTR _web[ecx*4+656]
	pop	esi
	mov	DWORD PTR _web[eax*4+656], ecx
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN554@more_other:

; 3261 :                break;
; 3262 :              }
; 3263 :          }
; 3264 :          break;
; 3265 : 
; 3266 :     case GEOMPIPE_NODE:  /* to command */
; 3267 :          old = geompipe_flag;
; 3268 :          do_gfile('C',*(char**)(stacktop--));

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	add	eax, -8					; fffffff8H
	push	67					; 00000043H
	mov	DWORD PTR [esi+48], eax
	call	_do_gfile
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN553@more_other:

; 3269 :          break;
; 3270 : 
; 3271 :     case GEOMPIPE_TOGGLE_NODE: 
; 3272 :          old = geompipe_flag;

	mov	esi, DWORD PTR _geompipe_flag

; 3273 :          do_gfile((node->op1.toggle_state==ON_) ? 'A' : 'B',NULL);

	xor	edx, edx
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	push	0
	setne	dl
	add	edx, 65					; 00000041H
	push	edx
	call	_do_gfile
	add	esp, 8

; 3274 :          outstring(geompipe_flag ? "geompipe ON." :
; 3275 :                                             "geompipe OFF.");

	cmp	DWORD PTR _geompipe_flag, 0
	mov	eax, OFFSET ??_C@_0N@CMCMGLFD@geompipe?5ON?4?$AA@
	jne	SHORT $LN731@more_other
	mov	eax, OFFSET ??_C@_0O@HKDJJHHO@geompipe?5OFF?4?$AA@
$LN731@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3276 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN733@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN733@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN552@more_other:

; 3277 :          break;
; 3278 : 
; 3279 :     case GEOMVIEW_TOGGLE_NODE: 
; 3280 :          old = geomview_flag;

	mov	esi, DWORD PTR _geomview_flag

; 3281 :          if ( !geomview_flag && (node->op1.toggle_state==ON_) )

	test	esi, esi
	jne	SHORT $LN1124@more_other
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	jne	SHORT $LN734@more_other

; 3282 :              do_gfile( '8',NULL);

	push	esi
	push	56					; 00000038H
	jmp	SHORT $LN1407@more_other
$LN1124@more_other:

; 3283 :          else if ( geomview_flag && !(node->op1.toggle_state==ON_) )

	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	je	SHORT $LN549@more_other

; 3284 :              do_gfile( '9',NULL);

	push	0
	push	57					; 00000039H
$LN1407@more_other:
	call	_do_gfile
	add	esp, 8
$LN549@more_other:

; 3285 :          outstring(geomview_flag ? "geomview ON." :
; 3286 :                                             "geomview OFF.");

	cmp	DWORD PTR _geomview_flag, 0
	mov	eax, OFFSET ??_C@_0N@CEMOACCA@geomview?5ON?4?$AA@
	jne	SHORT $LN735@more_other
$LN734@more_other:
	mov	eax, OFFSET ??_C@_0O@LDDNFFJB@geomview?5OFF?4?$AA@
$LN735@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3287 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN737@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN737@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN548@more_other:

; 3288 :          break;
; 3289 : 
; 3290 :     case LOGFILE_TOGGLE_NODE:
; 3291 :          old = logfile_flag;

	mov	esi, DWORD PTR _logfile_flag

; 3292 :          if ( !logfile_flag && (node->op1.toggle_state==ON_) )

	test	esi, esi
	jne	SHORT $LN1123@more_other
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	jne	SHORT $LN738@more_other

; 3293 :              start_logfile(NULL);

	push	esi
	call	_start_logfile
	add	esp, 4
	jmp	SHORT $LN545@more_other
$LN1123@more_other:

; 3294 :          else if ( logfile_flag && (node->op1.toggle_state!=ON_) )

	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	je	SHORT $LN545@more_other

; 3295 :              stop_logfile();

	call	_stop_logfile
$LN545@more_other:

; 3296 :          outstring(logfile_flag ? "Logfile ON." :
; 3297 :                                             "Logfile OFF.");

	cmp	DWORD PTR _logfile_flag, 0
	mov	eax, OFFSET ??_C@_0M@MGBDILFJ@Logfile?5ON?4?$AA@
	jne	SHORT $LN739@more_other
$LN738@more_other:
	mov	eax, OFFSET ??_C@_0N@JKAGEBIA@Logfile?5OFF?4?$AA@
$LN739@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3298 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN741@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN741@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN544@more_other:

; 3299 :          break;
; 3300 : 
; 3301 :     case KEYLOGFILE_TOGGLE_NODE:
; 3302 :          old = keylogfile_flag;

	mov	esi, DWORD PTR _keylogfile_flag

; 3303 :          if ( !keylogfile_flag && (node->op1.toggle_state==ON_) )

	test	esi, esi
	jne	SHORT $LN1122@more_other
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	jne	SHORT $LN742@more_other

; 3304 :              start_keylogfile(NULL);

	push	esi
	call	_start_keylogfile
	add	esp, 4
	jmp	SHORT $LN541@more_other
$LN1122@more_other:

; 3305 :          else if ( keylogfile_flag && (node->op1.toggle_state!=ON_) )

	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	je	SHORT $LN541@more_other

; 3306 :              stop_keylogfile();

	call	_stop_keylogfile
$LN541@more_other:

; 3307 :          outstring(keylogfile_flag ? "Keylogfile ON." :
; 3308 :                                             "Keylogfile OFF.");

	cmp	DWORD PTR _keylogfile_flag, 0
	mov	eax, OFFSET ??_C@_0P@FDDENPIC@Keylogfile?5ON?4?$AA@
	jne	SHORT $LN743@more_other
$LN742@more_other:
	mov	eax, OFFSET ??_C@_0BA@ILJCGNII@Keylogfile?5OFF?4?$AA@
$LN743@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3309 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN745@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN745@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN540@more_other:

; 3310 :          break;
; 3311 : 
; 3312 :     case JIGGLE_TOGGLE_NODE: 
; 3313 :          old = web.jiggle_flag;

	mov	esi, DWORD PTR _web+900

; 3314 :          web.jiggle_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _web+900, eax

; 3315 :          outstring(web.jiggle_flag ? "jiggling ON." :
; 3316 :                                             "jiggling OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0N@PDDGMANN@jiggling?5ON?4?$AA@
	jne	SHORT $LN747@more_other
	mov	eax, OFFSET ??_C@_0O@HAOGCDPC@jiggling?5OFF?4?$AA@
$LN747@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3317 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN749@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN749@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN539@more_other:

; 3318 :          break;
; 3319 : 
; 3320 :     case RIBIERE_CG_NODE: 
; 3321 :          old = ribiere_flag;

	mov	esi, DWORD PTR _ribiere_flag

; 3322 :          ribiere_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _ribiere_flag, eax

; 3323 :          outstring(ribiere_flag ? "Polak-Ribiere conjugate gradient ON." :
; 3324 :                                             "Polak-Ribiere conjugate gradient OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0CF@DJCKCFC@Polak?9Ribiere?5conjugate?5gradient@
	jne	SHORT $LN751@more_other
	mov	eax, OFFSET ??_C@_0CG@NBBBJCB@Polak?9Ribiere?5conjugate?5gradient@
$LN751@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3325 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN753@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN753@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3326 :          reset_conj_grad();

	call	_reset_conj_grad
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN538@more_other:

; 3327 :          break;
; 3328 : 
; 3329 :     case CONJ_GRAD_NODE:
; 3330 :          old = conj_grad_flag;

	mov	esi, DWORD PTR _conj_grad_flag

; 3331 :          conj_grad_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _conj_grad_flag, eax

; 3332 :          reset_conj_grad();

	call	_reset_conj_grad

; 3333 :          if ( conj_grad_flag )

	cmp	DWORD PTR _conj_grad_flag, 0
	je	$LN537@more_other

; 3334 :          { 
; 3335 :            outstring("Conjugate gradient now ON.");

	push	OFFSET ??_C@_0BL@JMDAFIPN@Conjugate?5gradient?5now?5ON?4?$AA@
	call	_outstring
	add	esp, 4

; 3336 :            outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN755@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN755@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3337 :            if ( web.motion_flag )

	cmp	DWORD PTR _web+852, 0
	je	$LN626@more_other

; 3338 :            { sprintf(errmsg,
; 3339 :               "Fixed scale is ON! Not a good idea with conjugate gradient.\n");

	push	OFFSET ??_C@_0DN@IGNPBNFB@Fixed?5scale?5is?5ON?$CB?5Not?5a?5good?5id@
	push	OFFSET _errmsg
	call	_sprintf

; 3340 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 3341 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1128@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1128@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 3342 :              kb_error(1223,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1223					; 000004c7H
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN537@more_other:

; 3343 :            }
; 3344 :          }
; 3345 :          else
; 3346 :          { 
; 3347 :            outstring("Conjugate gradient now OFF.");

	push	OFFSET ??_C@_0BM@ELOHAFKC@Conjugate?5gradient?5now?5OFF?4?$AA@
	call	_outstring
	add	esp, 4

; 3348 :            outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN757@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN757@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN534@more_other:

; 3349 :          }
; 3350 :          break;
; 3351 : 
; 3352 :     case MEAN_CURV_NODE:
; 3353 :          web.norm_check_flag = 0; /* default OFF */
; 3354 :          old = web.area_norm_flag;

	mov	esi, DWORD PTR _web+876

; 3355 :          web.area_norm_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	mov	DWORD PTR _web+880, 0
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _web+876, eax

; 3356 :          if ( web.area_norm_flag ) 

	test	eax, eax
	je	SHORT $LN533@more_other

; 3357 :             { outstring("Area normalization ON.");

	push	OFFSET ??_C@_0BH@LFJMNMPC@Area?5normalization?5ON?4?$AA@

; 3358 :             }
; 3359 :          else

	jmp	SHORT $LN1408@more_other
$LN533@more_other:

; 3360 :             { outstring("Area normalization OFF.");

	push	OFFSET ??_C@_0BI@NLHBLELH@Area?5normalization?5OFF?4?$AA@
$LN1408@more_other:
	call	_outstring
	add	esp, 4

; 3361 :             }
; 3362 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN759@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN759@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3363 :          calc_energy();  /* to make sure vertex areas set */

	call	_calc_energy
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN531@more_other:

; 3364 :          break;
; 3365 : 
; 3366 : 
; 3367 :     case SHOW_ALL_QUANTITIES_NODE: 
; 3368 :           flip_toggle(&show_all_quantities,node->op1.toggle_state,"show_all_quantities");

	mov	ecx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BE@PABNDBOD@show_all_quantities?$AA@
	push	ecx
	push	OFFSET _show_all_quantities
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN530@more_other:

; 3369 :           break;
; 3370 :     case PSCOLORFLAG_NODE: 
; 3371 :           flip_toggle(&ps_colorflag,node->op1.toggle_state,"ps_colorflag");

	mov	edx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0N@PDJMPNAK@ps_colorflag?$AA@
	push	edx
	push	OFFSET _ps_colorflag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN529@more_other:

; 3372 :           break;
; 3373 :     case PS_CMYKFLAG_NODE: 
; 3374 :           flip_toggle(&ps_cmykflag,node->op1.toggle_state,"ps_cmykflag");

	mov	eax, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0M@LOFHKFBI@ps_cmykflag?$AA@
	push	eax
	push	OFFSET _ps_cmykflag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN528@more_other:

; 3375 :           break;
; 3376 :     case FORCE_EDGESWAP_NODE:
; 3377 :            flip_toggle(&force_edgeswap_flag,node->op1.toggle_state,"force_edgeswap");

	mov	ecx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0P@EJEJKKN@force_edgeswap?$AA@
	push	ecx
	push	OFFSET _force_edgeswap_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN527@more_other:

; 3378 :           break;
; 3379 :     case GRIDFLAG_NODE:
; 3380 :           flip_toggle(&gridflag,node->op1.toggle_state,"ps_gridflag");

	mov	edx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0M@NAKIPJII@ps_gridflag?$AA@
	push	edx
	push	OFFSET _gridflag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN526@more_other:

; 3381 :           break;
; 3382 :     case CROSSINGFLAG_NODE: 
; 3383 :           flip_toggle(&crossingflag,node->op1.toggle_state,"crossingflag");

	mov	eax, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0N@JJEIJGBI@crossingflag?$AA@
	push	eax
	push	OFFSET _crossingflag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN525@more_other:

; 3384 :           break;
; 3385 :     case LABELFLAG_NODE:
; 3386 :           flip_toggle(&labelflag,node->op1.toggle_state,"ps_labelflag");

	mov	ecx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0N@ECHDFDIC@ps_labelflag?$AA@
	push	ecx
	push	OFFSET _labelflag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN524@more_other:

; 3387 :           break;
; 3388 :     case BOX_FLAG_NODE:
; 3389 :           flip_toggle(&box_flag,node->op1.toggle_state,"show_bounding_box");

	mov	edx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BC@IOPGAMGF@show_bounding_box?$AA@
	push	edx
	push	OFFSET _box_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH

; 3390 :           update_display();
; 3391 :           break;

	jmp	$LN1425@more_other
$LN523@more_other:

; 3392 :    case SHOW_ALL_EDGES_NODE:
; 3393 :           flip_toggle(&edgeshow_flag,node->op1.toggle_state,"show_all_edges");

	mov	eax, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0P@BMEBABFE@show_all_edges?$AA@
	push	eax
	push	OFFSET _edgeshow_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH

; 3394 :           update_display();
; 3395 :           break;

	jmp	$LN1425@more_other
$LN522@more_other:

; 3396 :     case SEPTUM_FLAG_NODE:
; 3397 :           flip_toggle(&septum_flag,node->op1.toggle_state,"septum_flag");

	mov	ecx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0M@FKFJNJHN@septum_flag?$AA@
	push	ecx
	push	OFFSET _septum_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN521@more_other:

; 3398 :           break;
; 3399 :     case TORUS_FILLED_NODE:
; 3400 :           if ( !web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	jne	SHORT $LN520@more_other

; 3401 :           { 
; 3402 :             sprintf(errmsg,
; 3403 :              "torus_filled is invalid toggle because not in torus model.\n");

	push	OFFSET ??_C@_0DM@HAMHICGC@torus_filled?5is?5invalid?5toggle?5b@
	push	OFFSET _errmsg
	call	_sprintf

; 3404 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 3405 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1129@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1129@more_other
	mov	ecx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 3406 :             kb_error(2042,errmsg, WARNING);

	push	2
	push	OFFSET _errmsg
	push	2042					; 000007faH
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN520@more_other:

; 3407 :             break;
; 3408 :           }
; 3409 :           flip_toggle(&web.full_flag,node->op1.toggle_state,"torus_filled");

	mov	eax, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0N@IGCELFFA@torus_filled?$AA@
	push	eax
	push	OFFSET _web+864
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN519@more_other:

; 3410 :           break;
; 3411 : 
; 3412 :     case VERBOSE_NODE:
; 3413 :          old = verbose_flag;

	mov	esi, DWORD PTR _verbose_flag

; 3414 :          verbose_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _verbose_flag, eax

; 3415 :          outstring(verbose_flag ? "Verbose ON." : "Verbose OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0M@JABCIEA@Verbose?5ON?4?$AA@
	jne	SHORT $LN761@more_other
	mov	eax, OFFSET ??_C@_0N@POKCPLOD@Verbose?5OFF?4?$AA@
$LN761@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3416 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN763@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN763@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN518@more_other:

; 3417 :          break;
; 3418 : 
; 3419 :     case QUIET_NODE:
; 3420 :          old = quiet_flag;

	mov	esi, DWORD PTR _quiet_flag

; 3421 :          quiet_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _quiet_flag, eax

; 3422 :          outstring(quiet_flag ? "Quiet ON." : "Quiet OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_09FLLKFOJ@Quiet?5ON?4?$AA@
	jne	SHORT $LN765@more_other
	mov	eax, OFFSET ??_C@_0L@FBKEFKCC@Quiet?5OFF?4?$AA@
$LN765@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3423 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN767@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN767@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN517@more_other:

; 3424 :          break;
; 3425 : 
; 3426 :     case QUIETLOAD_NODE:
; 3427 :          old = quiet_load_flag;

	mov	esi, DWORD PTR _quiet_load_flag

; 3428 :          quiet_load_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _quiet_load_flag, eax

; 3429 :          outstring(quiet_load_flag ? "QuietLoad ON." : "QuietLoad OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0O@KEDNKMNF@QuietLoad?5ON?4?$AA@
	jne	SHORT $LN769@more_other
	mov	eax, OFFSET ??_C@_0P@HOGKKAKM@QuietLoad?5OFF?4?$AA@
$LN769@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3430 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN771@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN771@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN516@more_other:

; 3431 :          break;
; 3432 : 
; 3433 :     case FUNCTION_QUANTITY_SPARSE_NODE:
; 3434 :          old = quantity_function_sparse_flag;

	mov	esi, DWORD PTR _quantity_function_sparse_flag

; 3435 :          quantity_function_sparse_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _quantity_function_sparse_flag, eax

; 3436 :          outstring(quantity_function_sparse_flag ?
; 3437 :             "function_quantity_sparse ON." : "function_quantity_sparse OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BN@NIHPBJFM@function_quantity_sparse?5ON?4?$AA@
	jne	SHORT $LN773@more_other
	mov	eax, OFFSET ??_C@_0BO@OKHCNJJN@function_quantity_sparse?5OFF?4?$AA@
$LN773@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3438 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN775@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN775@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN515@more_other:

; 3439 :          break;
; 3440 : 
; 3441 :     case DETORUS_STICKY_NODE:
; 3442 :          old = detorus_sticky;

	mov	esi, DWORD PTR _detorus_sticky

; 3443 :          detorus_sticky = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _detorus_sticky, eax

; 3444 :          outstring(detorus_sticky ?
; 3445 :             "detorus_sticky ON." : "detorus_sticky OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BD@GNBNGDPC@detorus_sticky?5ON?4?$AA@
	jne	SHORT $LN777@more_other
	mov	eax, OFFSET ??_C@_0BE@NLKJDFAI@detorus_sticky?5OFF?4?$AA@
$LN777@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3446 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN779@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN779@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN514@more_other:

; 3447 :          break;
; 3448 : 
; 3449 :     case VIEW_TRANSFORMS_USE_UNIQUE_NODE:
; 3450 :          old = view_transforms_unique_point_flag;

	mov	esi, DWORD PTR _view_transforms_unique_point_flag

; 3451 :          view_transforms_unique_point_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _view_transforms_unique_point_flag, eax

; 3452 :          outstring(view_transforms_unique_point_flag ?
; 3453 :             "view_transforms_use_unique ON." : "view_transforms_use_unique OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BP@OKKIADMD@view_transforms_use_unique?5ON?4?$AA@
	jne	SHORT $LN781@more_other
	mov	eax, OFFSET ??_C@_0CA@IKPAIAFC@view_transforms_use_unique?5OFF?4?$AA@
$LN781@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3454 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN783@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN783@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN513@more_other:

; 3455 :          break;
; 3456 : 
; 3457 :     case FORCE_DELETION_NODE:
; 3458 :          old = force_deletion;

	mov	esi, DWORD PTR _force_deletion

; 3459 :          force_deletion = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _force_deletion, eax

; 3460 :          outstring(force_deletion ?
; 3461 :             "force_deletion ON." : "force_deletion OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BD@CPNBPNLI@force_deletion?5ON?4?$AA@
	jne	SHORT $LN785@more_other
	mov	eax, OFFSET ??_C@_0BE@ENOCFBBI@force_deletion?5OFF?4?$AA@
$LN785@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3462 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN787@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN787@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN512@more_other:

; 3463 :          break;
; 3464 : 
; 3465 :     case STAR_FINAGLING_NODE:
; 3466 :          old = star_finagling;

	mov	esi, DWORD PTR _star_finagling

; 3467 :          star_finagling = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _star_finagling, eax

; 3468 :          outstring(star_finagling ?
; 3469 :             "star_finagling ON." : "star_finagling OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BD@BMHOINOE@star_finagling?5ON?4?$AA@
	jne	SHORT $LN789@more_other
	mov	eax, OFFSET ??_C@_0BE@CPAMODLH@star_finagling?5OFF?4?$AA@
$LN789@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3470 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN791@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN791@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN511@more_other:

; 3471 :          break;
; 3472 : 
; 3473 :     case SLICE_VIEW_NODE:
; 3474 :          old = slice_view_flag;

	mov	esi, DWORD PTR _slice_view_flag

; 3475 :          slice_coeff_set_flag = 1;
; 3476 :          slice_view_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	mov	DWORD PTR _slice_coeff_set_flag, 1
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _slice_view_flag, eax

; 3477 :          outstring(slice_view_flag ? "slice_view ON." : "slice_view OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0P@NGBCEKEF@slice_view?5ON?4?$AA@
	jne	$LN635@more_other
	mov	eax, OFFSET ??_C@_0BA@IOBHBMAO@slice_view?5OFF?4?$AA@

; 3478 :          outstring(old?" (was on)\n":" (was off)\n");
; 3479 :          update_display();
; 3480 :          break;

	jmp	$LN635@more_other
$LN510@more_other:

; 3481 : 
; 3482 :     case CLIP_VIEW_NODE:
; 3483 :          old = clip_view_flag;

	mov	esi, DWORD PTR _clip_view_flag

; 3484 :          clip_coeff_set_flag = 1;
; 3485 :          clip_view_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	mov	DWORD PTR _clip_coeff_set_flag, 1
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _clip_view_flag, eax

; 3486 :          outstring(clip_view_flag ? "clip_view ON." : "clip_view OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0O@LJHGAHLN@clip_view?5ON?4?$AA@
	jne	$LN635@more_other
	mov	eax, OFFSET ??_C@_0P@DNBOACGN@clip_view?5OFF?4?$AA@

; 3487 :          outstring(old?" (was on)\n":" (was off)\n");
; 3488 :          update_display();
; 3489 :          break;

	jmp	$LN635@more_other
$LN509@more_other:

; 3490 : 
; 3491 :     case BACKCULL_NODE:
; 3492 :          old = backcull_flag;

	mov	esi, DWORD PTR _backcull_flag

; 3493 :          backcull_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _backcull_flag, eax

; 3494 :          outstring(backcull_flag ? "backcull ON." : "backcull OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0N@MCJPMBN@backcull?5ON?4?$AA@
	jne	$LN635@more_other
	mov	eax, OFFSET ??_C@_0O@OLHNPOHO@backcull?5OFF?4?$AA@

; 3495 :          outstring(old?" (was on)\n":" (was off)\n");
; 3496 :          update_display();
; 3497 :          break;

	jmp	$LN635@more_other
$LN508@more_other:

; 3498 : 
; 3499 :     case ROTATE_LIGHTS_NODE:
; 3500 :          old = rotate_lights_flag;

	mov	esi, DWORD PTR _rotate_lights_flag

; 3501 :          rotate_lights_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _rotate_lights_flag, eax

; 3502 :          outstring(rotate_lights_flag ? "rotate_lights ON." : "rotate_lights OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BC@BFEJGDKB@rotate_lights?5ON?4?$AA@
	jne	$LN635@more_other
	mov	eax, OFFSET ??_C@_0BD@CJLDGBEG@rotate_lights?5OFF?4?$AA@

; 3503 :          outstring(old?" (was on)\n":" (was off)\n");
; 3504 :          update_display();
; 3505 :          break;

	jmp	$LN635@more_other
$LN507@more_other:

; 3506 : 
; 3507 :     case VOLGRADS_EVERY_NODE:
; 3508 :          old = volgrads_every_flag;

	mov	esi, DWORD PTR _volgrads_every_flag

; 3509 :          volgrads_every_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _volgrads_every_flag, eax

; 3510 :          outstring(volgrads_every_flag ? "Volgrads_every ON." : "Volgrads_every OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BD@BEFDILEO@Volgrads_every?5ON?4?$AA@
	jne	SHORT $LN809@more_other
	mov	eax, OFFSET ??_C@_0BE@BJAHIEEH@Volgrads_every?5OFF?4?$AA@
$LN809@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3511 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN811@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN811@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN506@more_other:

; 3512 :          break;
; 3513 : 
; 3514 :     case ZENER_DRAG_NODE:
; 3515 :          old = zener_drag_flag;

	mov	esi, DWORD PTR _zener_drag_flag

; 3516 :          zener_drag_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _zener_drag_flag, eax

; 3517 :          outstring(zener_drag_flag ? "Zener_drag ON." : "Zener_drag OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0P@MHAOIPAG@Zener_drag?5ON?4?$AA@
	jne	SHORT $LN813@more_other
	mov	eax, OFFSET ??_C@_0BA@GBNDBAOB@Zener_drag?5OFF?4?$AA@
$LN813@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3518 :          outstring(old?" (was on)":" (was off)");

	mov	eax, OFFSET ??_C@_09MIGIKFMF@?5?$CIwas?5on?$CJ?$AA@
	test	esi, esi
	jne	SHORT $LN815@more_other
	mov	eax, OFFSET ??_C@_0L@BBPCCDGD@?5?$CIwas?5off?$CJ?$AA@
$LN815@more_other:
	push	eax
	call	_outstring

; 3519 :          { int zd = lookup_global(ZENER_COEFF_NAME);

	push	OFFSET ??_C@_0M@GPOBHEAO@zener_coeff?$AA@
	call	_lookup_global
	add	esp, 8

; 3520 :             if ( zd >= 0 ) 

	test	eax, eax
	js	$LN505@more_other

; 3521 :               sprintf (msg,"  (%s: %g)\n",ZENER_COEFF_NAME,(double)globals(zd)->value.real);

	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	and	eax, 16777215				; 00ffffffH
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN820@more_other
	mov	ecx, DWORD PTR _web+5652
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
	jmp	SHORT $LN817@more_other
$LN820@more_other:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN818@more_other
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edi]
	jmp	SHORT $LN817@more_other
$LN818@more_other:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN816@more_other
	mov	ecx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN817@more_other
$LN816@more_other:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN817@more_other:
	fld	QWORD PTR [eax+64]
	mov	edx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0M@GPOBHEAO@zener_coeff?$AA@
	push	OFFSET ??_C@_0M@MFKIHKAF@?5?5?$CI?$CFs?3?5?$CFg?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 3523 :             outstring(msg);

	mov	ecx, DWORD PTR _msg
	add	esp, 20					; 00000014H
	push	ecx
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN505@more_other:

; 3522 :             else sprintf(msg,"  (%s not set)\n",ZENER_COEFF_NAME);

	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0M@GPOBHEAO@zener_coeff?$AA@
	push	OFFSET ??_C@_0BA@FHIDEKKO@?5?5?$CI?$CFs?5not?5set?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 3523 :             outstring(msg);

	mov	ecx, DWORD PTR _msg
	add	esp, 12					; 0000000cH
	push	ecx
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN503@more_other:

; 3524 :          }
; 3525 :          break;
; 3526 : 
; 3527 :     case QUIETGO_NODE:
; 3528 :          old = quiet_go_flag;

	mov	esi, DWORD PTR _quiet_go_flag

; 3529 :          quiet_go_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _quiet_go_flag, eax

; 3530 :          outstring(quiet_go_flag ? "QuietGo ON." : "QuietGo OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0M@LECGJNII@QuietGo?5ON?4?$AA@
	jne	SHORT $LN823@more_other
	mov	eax, OFFSET ??_C@_0N@GLKAJGNE@QuietGo?5OFF?4?$AA@
$LN823@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3531 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN825@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN825@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN502@more_other:

; 3532 :          break;
; 3533 : 
; 3534 :     case DIRICHLET_MODE_NODE:
; 3535 :          if ( !everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN501@more_other

; 3536 :           { convert_to_quantities();

	call	_convert_to_quantities

; 3537 :             recalc();

	call	_recalc
$LN501@more_other:

; 3538 :           }
; 3539 :          flip_toggle(&dirichlet_flag,node->op1.toggle_state,"Dirichlet area mode");

	mov	edx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BE@GOKADGNC@Dirichlet?5area?5mode?$AA@
	push	edx
	push	OFFSET _dirichlet_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 3540 :          sobolev_flag = 0;

	mov	DWORD PTR _sobolev_flag, 0
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN500@more_other:

; 3541 :          break;
; 3542 : 
; 3543 :     case RGB_COLORS_FLAG_NODE:
; 3544 :          flip_toggle(&rgb_colors_flag,node->op1.toggle_state,"RGB colors");

	mov	eax, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0L@OOMCHPBN@RGB?5colors?$AA@
	push	eax
	push	OFFSET _rgb_colors_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH

; 3545 :          update_display();
; 3546 :          break;

	jmp	$LN1425@more_other
$LN499@more_other:

; 3547 : 
; 3548 :     case BREAK_AFTER_WARNING_NODE:
; 3549 :          flip_toggle(&break_after_warning,node->op1.toggle_state,
; 3550 :           "Break after warning");

	mov	ecx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BE@BDGKJNKH@Break?5after?5warning?$AA@
	push	ecx
	push	OFFSET _break_after_warning
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN498@more_other:

; 3551 :          break;
; 3552 : 
; 3553 :     case BREAK_ON_WARNING_NODE:
; 3554 :          flip_toggle(&break_on_warning,node->op1.toggle_state,
; 3555 :           "Break on warning");

	mov	edx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BB@DNFIILFK@Break?5on?5warning?$AA@
	push	edx
	push	OFFSET _break_on_warning
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN497@more_other:

; 3556 :          break;
; 3557 : 
; 3558 :     case BLAS_FLAG_NODE:
; 3559 : #ifdef BLAS
; 3560 :          flip_toggle(&blas_flag,node->op1.toggle_state,"using BLAS");
; 3561 : #else
; 3562 :          sprintf(errmsg,"This Evolver not compiled with BLAS.\n");

	push	OFFSET ??_C@_0CG@ECALEFFC@This?5Evolver?5not?5compiled?5with?5B@
	push	OFFSET _errmsg
	call	_sprintf

; 3563 :          sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 3564 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL1130@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1130@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 3565 :          kb_error(2472,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2472					; 000009a8H
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN496@more_other:

; 3566 : #endif
; 3567 :          break;
; 3568 : 
; 3569 :     case AUGMENTED_HESSIAN_NODE:
; 3570 :          flip_toggle(&augmented_hessian_flag,node->op1.toggle_state,
; 3571 :              "augmented Hessian");

	mov	ecx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BC@DOMBLPMO@augmented?5Hessian?$AA@
	push	ecx
	push	OFFSET _augmented_hessian_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH

; 3572 :          if ( augmented_hessian_flag )

	cmp	DWORD PTR _augmented_hessian_flag, 0
	je	$LN626@more_other

; 3573 :          { if ( !sparse_constraints_flag )

	cmp	DWORD PTR _sparse_constraints_flag, 0
	jne	$LN626@more_other

; 3574 :              flip_toggle(&sparse_constraints_flag,node->op1.toggle_state,
; 3575 :                 "sparse constraints");

	mov	edx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BD@CFDHHPOD@sparse?5constraints?$AA@
	push	edx
	push	OFFSET _sparse_constraints_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN493@more_other:

; 3576 :          }
; 3577 :          break;
; 3578 : 
; 3579 :     case SPARSE_CONSTRAINTS_NODE:
; 3580 :          flip_toggle(&sparse_constraints_flag,node->op1.toggle_state,
; 3581 :                 "sparse constraints");

	mov	eax, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BD@CFDHHPOD@sparse?5constraints?$AA@
	push	eax
	push	OFFSET _sparse_constraints_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH

; 3582 :          if ( !sparse_constraints_flag && augmented_hessian_flag )

	cmp	DWORD PTR _sparse_constraints_flag, 0
	jne	$LN626@more_other
	cmp	DWORD PTR _augmented_hessian_flag, 0
	je	$LN626@more_other

; 3583 :            flip_toggle(&augmented_hessian_flag,node->op1.toggle_state,
; 3584 :              "augmented Hessian");

	mov	ecx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BC@DOMBLPMO@augmented?5Hessian?$AA@
	push	ecx
	push	OFFSET _augmented_hessian_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN491@more_other:

; 3585 :          break;
; 3586 : 
; 3587 :     case VISIBILITY_TEST_NODE:
; 3588 :          flip_toggle(&visibility_test,node->op1.toggle_state,"visibility test");

	mov	edx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BA@CLHENHLJ@visibility?5test?$AA@
	push	edx
	push	OFFSET _visibility_test
	call	_flip_toggle
	add	esp, 12					; 0000000cH

; 3589 :          update_display();
; 3590 :          break;

	jmp	$LN1425@more_other
$LN490@more_other:

; 3591 : 
; 3592 :     case CIRCULAR_ARC_DRAW_NODE:
; 3593 :          flip_toggle(&circular_arc_flag,node->op1.toggle_state,"Circular arc drawing");

	mov	eax, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BF@IOAHFOPJ@Circular?5arc?5drawing?$AA@
	push	eax
	push	OFFSET _circular_arc_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN489@more_other:

; 3594 :          break;
; 3595 : 
; 3596 :     case KRAYNIKPOPVERTEX_FLAG_NODE:
; 3597 :          flip_toggle(&kraynikpopvertex_flag,node->op1.toggle_state,"Kraynik pop vertex mode");

	mov	ecx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BI@FLPPIDJA@Kraynik?5pop?5vertex?5mode?$AA@
	push	ecx
	push	OFFSET _kraynikpopvertex_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN488@more_other:

; 3598 :          break;
; 3599 : 
; 3600 :     case KRAYNIKPOPEDGE_FLAG_NODE:
; 3601 :          flip_toggle(&kraynikpopedge_flag,node->op1.toggle_state,"Kraynik pop edge mode");

	mov	edx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BG@DMGKDBMO@Kraynik?5pop?5edge?5mode?$AA@
	push	edx
	push	OFFSET _kraynikpopedge_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN487@more_other:

; 3602 :          break;
; 3603 : 
; 3604 :     case K_ALTITUDE_FLAG_NODE:
; 3605 :          flip_toggle(&K_altitude_flag,node->op1.toggle_state,"K altitude mode");

	mov	eax, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BA@PMMMILEF@K?5altitude?5mode?$AA@
	push	eax
	push	OFFSET _K_altitude_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN486@more_other:

; 3606 :          break;
; 3607 : 
; 3608 :     case SMOOTH_GRAPH_NODE:
; 3609 :          flip_toggle(&smooth_graph_flag,node->op1.toggle_state,"smooth graph");

	mov	ecx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0N@CPNIHMEN@smooth?5graph?$AA@
	push	ecx
	push	OFFSET _smooth_graph_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH

; 3610 :          update_display();
; 3611 :          break;

	jmp	$LN1425@more_other
$LN485@more_other:

; 3612 : 
; 3613 :     case FULL_BOUNDING_BOX_NODE:
; 3614 :          flip_toggle(&full_bounding_box_flag,node->op1.toggle_state,
; 3615 :            "full_bounding_box");

	mov	edx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BC@PCBOIGLG@full_bounding_box?$AA@
	push	edx
	push	OFFSET _full_bounding_box_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH

; 3616 :          update_display();
; 3617 :          break;

	jmp	$LN1425@more_other
$LN484@more_other:

; 3618 : 
; 3619 :     case POP_TO_EDGE_NODE:
; 3620 :          flip_toggle(&pop_to_edge_flag,node->op1.toggle_state,"pop_to_edge");

	mov	eax, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0M@CAFGBCMP@pop_to_edge?$AA@
	push	eax
	push	OFFSET _pop_to_edge_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH

; 3621 :          if ( pop_to_edge_flag ) pop_to_face_flag = 0;

	cmp	DWORD PTR _pop_to_edge_flag, 0
	je	$LN626@more_other
	pop	edi
	pop	esi
	mov	DWORD PTR _pop_to_face_flag, 0
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN482@more_other:

; 3622 :          break;
; 3623 : 
; 3624 :     case POP_TO_FACE_NODE:
; 3625 :          flip_toggle(&pop_to_face_flag,node->op1.toggle_state,"pop_to_face");

	mov	ecx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0M@FHCBDAPB@pop_to_face?$AA@
	push	ecx
	push	OFFSET _pop_to_face_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH

; 3626 :          if ( pop_to_face_flag ) pop_to_edge_flag = 0;

	cmp	DWORD PTR _pop_to_face_flag, 0
	je	$LN626@more_other
	pop	edi
	pop	esi
	mov	DWORD PTR _pop_to_edge_flag, 0
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN480@more_other:

; 3627 :          break;
; 3628 : 
; 3629 :     case POP_DISJOIN_NODE:
; 3630 :          flip_toggle(&pop_disjoin_flag,node->op1.toggle_state,"pop_disjoin");

	mov	edx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0M@PDGIDHIC@pop_disjoin?$AA@
	push	edx
	push	OFFSET _pop_disjoin_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH

; 3631 :          if ( pop_disjoin_flag )

	cmp	DWORD PTR _pop_disjoin_flag, 0
	je	$LN626@more_other

; 3632 :            pop_enjoin_flag = 0;

	pop	edi
	pop	esi
	mov	DWORD PTR _pop_enjoin_flag, 0
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN478@more_other:

; 3633 :          break;
; 3634 : 
; 3635 :     case POP_ENJOIN_NODE:
; 3636 :          flip_toggle(&pop_enjoin_flag,node->op1.toggle_state,"pop_enjoin");

	mov	eax, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0L@NBNMFCPF@pop_enjoin?$AA@
	push	eax
	push	OFFSET _pop_enjoin_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH

; 3637 :          if ( pop_enjoin_flag )

	cmp	DWORD PTR _pop_enjoin_flag, 0
	je	$LN626@more_other

; 3638 :            pop_disjoin_flag = 0;

	pop	edi
	pop	esi
	mov	DWORD PTR _pop_disjoin_flag, 0
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN476@more_other:

; 3639 :          break;
; 3640 : 
; 3641 :     case BIG_ENDIAN_NODE:
; 3642 :          flip_toggle(&big_endian_flag,node->op1.toggle_state,"big_endian");

	mov	ecx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0L@HGLBMAAF@big_endian?$AA@
	push	ecx
	push	OFFSET _big_endian_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH

; 3643 :          if ( big_endian_flag )

	cmp	DWORD PTR _big_endian_flag, 0
	je	$LN626@more_other

; 3644 :            little_endian_flag = 0;

	pop	edi
	pop	esi
	mov	DWORD PTR _little_endian_flag, 0
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN474@more_other:

; 3645 :          break;
; 3646 : 
; 3647 :     case LITTLE_ENDIAN_NODE:
; 3648 :          flip_toggle(&little_endian_flag,node->op1.toggle_state,
; 3649 :              "little_endian");

	mov	edx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0O@EKBDJBFN@little_endian?$AA@
	push	edx
	push	OFFSET _little_endian_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH

; 3650 :          if ( little_endian_flag )

	cmp	DWORD PTR _little_endian_flag, 0
	je	$LN626@more_other

; 3651 :            big_endian_flag = 0;

	pop	edi
	pop	esi
	mov	DWORD PTR _big_endian_flag, 0
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN472@more_other:

; 3652 :          break;
; 3653 : 
; 3654 :     case MPI_DEBUG_NODE:
; 3655 :          flip_toggle(&mpi_debug,node->op1.toggle_state,"mpi_debug");

	mov	eax, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_09PJOICEHA@mpi_debug?$AA@
	push	eax
	push	OFFSET _mpi_debug
	call	_flip_toggle
	add	esp, 12					; 0000000cH

; 3656 :          update_display();
; 3657 :          #ifdef MPI_EVOLVER
; 3658 :          mpi_synch_mpi_debug();
; 3659 :          #endif
; 3660 :          break;

	jmp	$LN1425@more_other
$LN471@more_other:

; 3661 : 
; 3662 :     case MPI_LOCAL_BODIES_NODE:
; 3663 :          flip_toggle(&mpi_debug,node->op1.toggle_state,"mpi_local_bodies");

	mov	ecx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BB@EHCKFCGI@mpi_local_bodies?$AA@
	push	ecx
	push	OFFSET _mpi_debug
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN470@more_other:

; 3664 :          break;
; 3665 : 
; 3666 : 
; 3667 :     case BEZIER_BASIS_NODE:
; 3668 :        { int dim,k;
; 3669 :          old = bezier_flag;

	mov	esi, DWORD PTR _bezier_flag

; 3670 :          bezier_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	mov	DWORD PTR _old$[ebp], esi
	sete	al
	mov	DWORD PTR _bezier_flag, eax

; 3671 :          outstring(bezier_flag ? "bezier_basis  ON." :
; 3672 :              "bezier_basis OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BC@OHJOJLJC@bezier_basis?5?5ON?4?$AA@
	jne	SHORT $LN827@more_other
	mov	eax, OFFSET ??_C@_0BC@IPOHGFDM@bezier_basis?5OFF?4?$AA@
$LN827@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3673 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN829@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN829@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3674 :          /* wipe old polynomials and reinitialize */
; 3675 :          for ( dim = 1 ; dim < MAXCOORD ; dim++ )

	mov	esi, 1
$LL469@more_other:

; 3676 :            for ( k = 1 ; k <= maxgaussorder[dim] ; k++ )

	mov	ebx, 1
	cmp	DWORD PTR _maxgaussorder[esi*4], ebx
	jl	SHORT $LN468@more_other
	mov	edi, 32					; 00000020H
$LL466@more_other:
	mov	edx, DWORD PTR _gauss_lagrange[esi*4]
	add	edx, edi

; 3677 :            { struct gauss_lag *gl = &gauss_lagrange[dim][k];
; 3678 :              if ( gl == NULL ) continue;

	je	SHORT $LN465@more_other

; 3679 :              gauss_lagrange_setup(dim,web.lagrange_order,k); 

	mov	eax, DWORD PTR _web+632
	push	ebx
	push	eax
	push	esi
	call	_gauss_lagrange_setup
	add	esp, 12					; 0000000cH
$LN465@more_other:

; 3676 :            for ( k = 1 ; k <= maxgaussorder[dim] ; k++ )

	inc	ebx
	add	edi, 32					; 00000020H
	cmp	ebx, DWORD PTR _maxgaussorder[esi*4]
	jle	SHORT $LL466@more_other
$LN468@more_other:

; 3674 :          /* wipe old polynomials and reinitialize */
; 3675 :          for ( dim = 1 ; dim < MAXCOORD ; dim++ )

	inc	esi
	cmp	esi, 6
	jl	SHORT $LL469@more_other

; 3680 :            }
; 3681 :          if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	jne	$LN1427@more_other

; 3682 :          { if ( !old && bezier_flag )

	cmp	DWORD PTR _old$[ebp], 0
	jne	SHORT $LN1121@more_other
	cmp	DWORD PTR _bezier_flag, 0
	je	$LN1427@more_other

; 3683 :              lagrange_to_bezier();

	call	_lagrange_to_bezier

; 3684 :            if ( old && !bezier_flag )

	jmp	$LN1427@more_other
$LN1121@more_other:
	cmp	DWORD PTR _bezier_flag, 0
	jne	$LN1427@more_other

; 3685 :              bezier_to_lagrange();

	call	_bezier_to_lagrange

; 3686 :          }
; 3687 :          recalc();
; 3688 :          break;

	jmp	$LN1427@more_other
$LN459@more_other:

; 3689 :        }
; 3690 : 
; 3691 :     case SOBOLEV_MODE_NODE:
; 3692 :          if ( !everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	jne	SHORT $LN458@more_other

; 3693 :           { convert_to_quantities();

	call	_convert_to_quantities

; 3694 :             recalc();

	call	_recalc
$LN458@more_other:

; 3695 :           }
; 3696 :          flip_toggle(&dirichlet_flag,node->op1.toggle_state,"Sobolev area mode");

	mov	ecx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0BC@EMGJHHB@Sobolev?5area?5mode?$AA@
	push	ecx
	push	OFFSET _dirichlet_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi

; 3697 :          dirichlet_flag = 0;

	mov	DWORD PTR _dirichlet_flag, 0
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN457@more_other:

; 3698 :          break;
; 3699 : 
; 3700 : 
; 3701 :     case HESSIAN_NORMAL_NODE:
; 3702 :          old = hessian_normal_flag;

	mov	esi, DWORD PTR _hessian_normal_flag

; 3703 :          hessian_normal_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _hessian_normal_flag, eax

; 3704 :          outstring(hessian_normal_flag ? "hessian_normal  ON." :
; 3705 :              "hessian_normal OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BE@MOBAPIM@hessian_normal?5?5ON?4?$AA@
	jne	SHORT $LN831@more_other
	mov	eax, OFFSET ??_C@_0BE@GEJIPBCC@hessian_normal?5OFF?4?$AA@
$LN831@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3706 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN833@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN833@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN456@more_other:

; 3707 :          break;
; 3708 : 
; 3709 :     case HESSIAN_SPECIAL_NORMAL_NODE:
; 3710 :          old = hessian_special_normal_flag;

	mov	esi, DWORD PTR _hessian_special_normal_flag

; 3711 :          if ( node->op1.toggle_state == ON_ && 
; 3712 :                  hessian_special_normal_expr[0].start == NULL )

	mov	edi, 15000				; 00003a98H
	cmp	DWORD PTR [ebx+32], edi
	jne	SHORT $LN455@more_other
	cmp	DWORD PTR _hessian_special_normal_expr, 0
	jne	SHORT $LN455@more_other

; 3713 :          { sprintf(errmsg,"hessian_special_normal_vector not set.\n");

	push	OFFSET ??_C@_0CI@CDHDEEDF@hessian_special_normal_vector?5no@
	push	OFFSET _errmsg
	call	_sprintf

; 3714 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 3715 :                                 file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1131@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1131@more_other
	mov	ecx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 3716 :             kb_error(3835,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3835					; 00000efbH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN455@more_other:

; 3717 :          }
; 3718 :          hessian_special_normal_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], edi
	sete	al
	mov	DWORD PTR _hessian_special_normal_flag, eax

; 3719 :          outstring(hessian_special_normal_flag ? "hessian_special_normal ON." :
; 3720 :              "hessian_special_normal OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BL@BKKLNAFN@hessian_special_normal?5ON?4?$AA@
	jne	SHORT $LN835@more_other
	mov	eax, OFFSET ??_C@_0BM@JNLHDNMC@hessian_special_normal?5OFF?4?$AA@
$LN835@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3721 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN837@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN837@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN454@more_other:

; 3722 :          break;
; 3723 : 
; 3724 :     case HESSIAN_NORMAL_PERP_NODE:
; 3725 :          old = hessian_normal_perp_flag;

	mov	esi, DWORD PTR _hessian_normal_perp_flag

; 3726 :          hessian_normal_perp_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _hessian_normal_perp_flag, eax

; 3727 :          outstring(hessian_normal_perp_flag ? "hessian_normal_perp  ON." :
; 3728 :              "hessian_normal_perp OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BJ@DOGAIPHJ@hessian_normal_perp?5?5ON?4?$AA@
	jne	SHORT $LN839@more_other
	mov	eax, OFFSET ??_C@_0BJ@FGBJHBNH@hessian_normal_perp?5OFF?4?$AA@
$LN839@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3729 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN841@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN841@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN453@more_other:

; 3730 :          break;
; 3731 : 
; 3732 : 
; 3733 :     case HESSIAN_DOUBLE_NORMAL_NODE:
; 3734 :          old = hessian_double_normal_flag;

	mov	esi, DWORD PTR _hessian_double_normal_flag

; 3735 :          hessian_double_normal_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _hessian_double_normal_flag, eax

; 3736 :          outstring(hessian_double_normal_flag ? "hessian_double_normal  ON." :
; 3737 :              "hessian_double_normal OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BL@BDGDLMDK@hessian_double_normal?5?5ON?4?$AA@
	jne	SHORT $LN843@more_other
	mov	eax, OFFSET ??_C@_0BL@HLBKECJE@hessian_double_normal?5OFF?4?$AA@
$LN843@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3738 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN845@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN845@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN452@more_other:

; 3739 :          break;
; 3740 : 
; 3741 :     case HESSIAN_NORMAL_ONE_NODE:
; 3742 :          if ( node->op1.toggle_state==ON_ && 
; 3743 :          ((web.representation == SIMPLEX) || (SDIM - web.dimension > 1)))

	mov	edi, 15000				; 00003a98H
	cmp	DWORD PTR [ebx+32], edi
	jne	SHORT $LN451@more_other
	cmp	DWORD PTR _web+624, 3
	je	SHORT $LN450@more_other
	mov	eax, DWORD PTR _web+616
	sub	eax, DWORD PTR _web+620
	cmp	eax, 1
	jle	SHORT $LN451@more_other
$LN450@more_other:

; 3744 :          {  sprintf(errmsg,
; 3745 :             "HESSIAN_NORMAL_ONE only for STRING or SOAPFILM hypersurfaces.\n");

	push	OFFSET ??_C@_0DP@GODKPABP@HESSIAN_NORMAL_ONE?5only?5for?5STRI@
	push	OFFSET _errmsg
	call	_sprintf

; 3746 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 3747 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1132@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1132@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 3748 :             kb_error(2043,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2043					; 000007fbH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN451@more_other:

; 3749 :          }
; 3750 :          old = hessian_normal_one_flag;

	mov	esi, DWORD PTR _hessian_normal_one_flag

; 3751 :          hessian_normal_one_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], edi
	sete	al
	mov	DWORD PTR _hessian_normal_one_flag, eax

; 3752 :          outstring(hessian_normal_one_flag ? "hessian_normal_one  ON." :
; 3753 :              "hessian_normal_one OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BI@FFLAHCKM@hessian_normal_one?5?5ON?4?$AA@
	jne	SHORT $LN847@more_other
	mov	eax, OFFSET ??_C@_0BI@DNMJIMAC@hessian_normal_one?5OFF?4?$AA@
$LN847@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3754 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN849@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN849@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN449@more_other:

; 3755 :          break;
; 3756 : 
; 3757 :     case HESSIAN_QUIET_NODE:
; 3758 :          old = hessian_quiet_flag;

	mov	esi, DWORD PTR _hessian_quiet_flag

; 3759 :          hessian_quiet_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _hessian_quiet_flag, eax

; 3760 :          outstring(hessian_quiet_flag ? "hessian_quiet  ON." :
; 3761 :              "hessian_quiet OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BD@DBDGMAIK@hessian_quiet?5?5ON?4?$AA@
	jne	SHORT $LN851@more_other
	mov	eax, OFFSET ??_C@_0BD@FJEPDOCE@hessian_quiet?5OFF?4?$AA@
$LN851@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3762 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN853@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN853@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN448@more_other:

; 3763 :          break;
; 3764 : 
; 3765 :     case HESSIAN_DIFF_NODE:
; 3766 :          old = hessian_by_diff_flag;
; 3767 :          if ( !web.pressure_flag && count_fixed_vol() )

	cmp	DWORD PTR _web+868, 0
	mov	esi, DWORD PTR _hessian_by_diff_flag
	jne	SHORT $LN447@more_other
	call	_count_fixed_vol
	test	eax, eax
	je	SHORT $LN447@more_other

; 3768 :          {  sprintf(errmsg,
; 3769 :                "Hessian_diff not implemented for constrained quants.\n");

	push	OFFSET ??_C@_0DG@FNHPJGDA@Hessian_diff?5not?5implemented?5for@
	push	OFFSET _errmsg
	call	_sprintf

; 3770 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 3771 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1133@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1133@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 3772 :             kb_error(3902,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3902					; 00000f3eH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN447@more_other:

; 3773 :          }
; 3774 :          hessian_by_diff_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _hessian_by_diff_flag, eax

; 3775 :          outstring(hessian_by_diff_flag ? "Hessian by differences ON." :
; 3776 :                                             "Hessian by differences OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BL@DGFOJMBA@Hessian?5by?5differences?5ON?4?$AA@
	jne	SHORT $LN855@more_other
	mov	eax, OFFSET ??_C@_0BM@JFPGPFKD@Hessian?5by?5differences?5OFF?4?$AA@
$LN855@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3777 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN857@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN857@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN446@more_other:

; 3778 :          break;
; 3779 : 
; 3780 :     case INTERP_BDRY_PARAM_NODE:
; 3781 :          old = interp_bdry_param;

	mov	esi, DWORD PTR _interp_bdry_param

; 3782 :          interp_bdry_param = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _interp_bdry_param, eax

; 3783 :          outstring(interp_bdry_param ? "interpolation of boundary parameters  ON." :
; 3784 :              "interpolation of boundary parameters OFF (using extrapolation).");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0CK@NNHEBOBN@interpolation?5of?5boundary?5parame@
	jne	SHORT $LN859@more_other
	mov	eax, OFFSET ??_C@_0EA@BBCBJJDC@interpolation?5of?5boundary?5parame@
$LN859@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 3785 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN861@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN861@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN445@more_other:

; 3786 :          break;
; 3787 : 
; 3788 :     case RITZ_NODE:
; 3789 :       { int krydim;  /* Krylov subspace dimension */
; 3790 :          krydim = (int)*(stacktop--);

	mov	edi, DWORD PTR [esi+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse

; 3791 :          ritz_command(*(stacktop--),krydim);

	fld	QWORD PTR [edi-8]
	push	eax
	sub	esp, 8
	add	edi, -16				; fffffff0H
	fstp	QWORD PTR [esp]
	mov	DWORD PTR [esi+48], edi
	call	_ritz_command
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN444@more_other:

; 3792 :       }
; 3793 :       break;
; 3794 : 
; 3795 :     
; 3796 :     case LANCZOS_NODE:
; 3797 :       { int krydim;  /* Krylov subspace dimension */
; 3798 :          if ( node->right ) krydim = (int)*(stacktop--);

	cmp	DWORD PTR [ebx+8], 0
	je	SHORT $LN443@more_other
	mov	edi, DWORD PTR [esi+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	add	edi, -8					; fffffff8H
	mov	DWORD PTR [esi+48], edi
	jmp	SHORT $LN442@more_other
$LN443@more_other:

; 3799 :          else krydim = 100;

	mov	eax, 100				; 00000064H
$LN442@more_other:

; 3800 :          lanczos_command(*(stacktop--),krydim);

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx]
	push	eax
	add	ecx, -8					; fffffff8H
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR [esi+48], ecx
	call	_lanczos_command
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN441@more_other:

; 3801 :       }
; 3802 :       break;
; 3803 : 
; 3804 :     case MOVE_NODE:
; 3805 :          calc_all_grads(CALC_VOLGRADS);

	push	2
	call	_calc_all_grads

; 3806 :          move_vertices(ACTUAL_MOVE,*(stacktop--));

	mov	eax, DWORD PTR [esi+48]
	fld	QWORD PTR [eax]
	push	ecx
	add	eax, -8					; fffffff8H
	fstp	QWORD PTR [esp]
	push	1
	mov	DWORD PTR [esi+48], eax
	call	_move_vertices

; 3807 :          vgrad_end();

	call	_vgrad_end

; 3808 : #ifdef FLOAT128
; 3809 :          sprintf(msg,"1.  energy: %*.*Qg  stepsize: %g\n",DWIDTH,DPREC,
; 3810 :             web.total_energy,(DOUBLE)stacktop[1]);
; 3811 : #elif defined(LONGDOUBLE)
; 3812 :          sprintf(msg,"1.  energy: %*.*Lg  stepsize: %g\n",DWIDTH,DPREC,
; 3813 :             web.total_energy,(DOUBLE)stacktop[1]);
; 3814 : #else
; 3815 :          sprintf(msg,"1. %s: %17.15g energy: %17.15g  stepsize: %g\n",
; 3816 :             areaname,web.total_area,web.total_energy,stacktop[1]);

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx+8]
	mov	edx, DWORD PTR _areaname
	mov	eax, DWORD PTR _msg
	sub	esp, 12					; 0000000cH
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR _web+1240
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _web+992
	fstp	QWORD PTR [esp]
	push	edx
	push	OFFSET ??_C@_0CO@GFMHNHBN@1?4?5?$CFs?3?5?$CF17?415g?5energy?3?5?$CF17?415g?5?5@
	push	eax
	call	_sprintf

; 3817 : #endif 
; 3818 :          outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 40					; 00000028H

; 3819 :          update_display();
; 3820 :          break;

	jmp	$LN1425@more_other
$LN440@more_other:

; 3821 : 
; 3822 :     case EIGENPROBE_NODE:
; 3823 :       { int iters;
; 3824 :          if ( node->right ) iters = (int)*(stacktop--);

	cmp	DWORD PTR [ebx+8], 0
	je	SHORT $LN439@more_other
	mov	edi, DWORD PTR [esi+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	add	edi, -8					; fffffff8H
	mov	DWORD PTR [esi+48], edi
	jmp	SHORT $LN438@more_other
$LN439@more_other:

; 3825 :          else iters = 0;

	xor	eax, eax
$LN438@more_other:

; 3826 :          eigenprobe_command(*(stacktop--),iters);

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx]
	push	eax
	add	ecx, -8					; fffffff8H
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR [esi+48], ecx
	call	_eigenprobe_command
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN437@more_other:

; 3827 :       }
; 3828 :       break;
; 3829 : 
; 3830 :     case SET_NO_DUMP_NODE:
; 3831 :       { if ( node->op2.intval )

	cmp	DWORD PTR [ebx+136], 0

; 3832 :           globals(node->op1.name_id)->flags2 |= NO_DUMP_BIT;

	mov	ebx, DWORD PTR [ebx+32]
	mov	eax, ebx
	je	$LN436@more_other
	and	eax, -16777216				; ff000000H
	and	ebx, 16777215				; 00ffffffH
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN866@more_other
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+ebx*4]
	mov	ebx, DWORD PTR [eax+ecx]
	or	DWORD PTR [ebx+196], 1
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN866@more_other:

; 3832 :           globals(node->op1.name_id)->flags2 |= NO_DUMP_BIT;

	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN864@more_other
	imul	ebx, 224				; 000000e0H
	add	ebx, DWORD PTR [edi]
	pop	edi
	or	DWORD PTR [ebx+196], 1
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN864@more_other:

; 3832 :           globals(node->op1.name_id)->flags2 |= NO_DUMP_BIT;

	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN862@more_other
	mov	edx, DWORD PTR _web+5656
	mov	ebx, DWORD PTR [edx+ebx*4]
	or	DWORD PTR [ebx+196], 1
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN862@more_other:

; 3832 :           globals(node->op1.name_id)->flags2 |= NO_DUMP_BIT;

	mov	eax, DWORD PTR _web+5652
	mov	edx, DWORD PTR _dymem
	lea	ecx, DWORD PTR [eax+ebx*4]
	mov	ebx, DWORD PTR [ecx+edx]
	or	DWORD PTR [ebx+196], 1
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN436@more_other:

; 3833 :         else
; 3834 :           globals(node->op1.name_id)->flags2 &= ~NO_DUMP_BIT;

	and	eax, -16777216				; ff000000H
	and	ebx, 16777215				; 00ffffffH
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN872@more_other
	mov	eax, DWORD PTR _web+5652
	mov	edx, DWORD PTR _dymem
	lea	ecx, DWORD PTR [eax+ebx*4]
	mov	ebx, DWORD PTR [ecx+edx]
	and	DWORD PTR [ebx+196], -2			; fffffffeH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN872@more_other:

; 3833 :         else
; 3834 :           globals(node->op1.name_id)->flags2 &= ~NO_DUMP_BIT;

	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN870@more_other
	imul	ebx, 224				; 000000e0H
	add	ebx, DWORD PTR [edi]
	pop	edi
	and	DWORD PTR [ebx+196], -2			; fffffffeH
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN870@more_other:

; 3833 :         else
; 3834 :           globals(node->op1.name_id)->flags2 &= ~NO_DUMP_BIT;

	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN868@more_other
	mov	eax, DWORD PTR _web+5656
	mov	ebx, DWORD PTR [eax+ebx*4]
	and	DWORD PTR [ebx+196], -2			; fffffffeH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN868@more_other:

; 3833 :         else
; 3834 :           globals(node->op1.name_id)->flags2 &= ~NO_DUMP_BIT;

	mov	ecx, DWORD PTR _web+5652
	mov	eax, DWORD PTR _dymem
	lea	edx, DWORD PTR [ecx+ebx*4]
	mov	ebx, DWORD PTR [edx+eax]
	and	DWORD PTR [ebx+196], -2			; fffffffeH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN433@more_other:

; 3835 :       }
; 3836 :       break;
; 3837 : 
; 3838 :     case EXPRLIST_NODE:
; 3839 :              break;  /* leave expression on stack */
; 3840 :  
; 3841 :     case GET_TRANSFORM_EXPR_NODE: /* put ptr in both halves for 32-bit */
; 3842 :        { int pp = (sizeof(REAL))/sizeof(char*);
; 3843 :          int nn;
; 3844 :          ++stacktop;

	add	DWORD PTR [esi+48], 8

; 3845 :          for ( nn = 0 ; nn < pp  ; nn++ ) 
; 3846 :                 ((char **)stacktop)[nn] = transform_expr;

	mov	ecx, DWORD PTR [esi+48]
	mov	DWORD PTR [ecx], OFFSET _transform_expr
	mov	edx, DWORD PTR [esi+48]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+4], OFFSET _transform_expr
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN429@more_other:

; 3847 :        }
; 3848 :        break;
; 3849 : 
; 3850 :     case DATAFILENAME_NODE: /* put ptr in both halves for 32-bit */
; 3851 :        { int pp = (sizeof(REAL))/sizeof(char*);
; 3852 :          int nn;
; 3853 :          ++stacktop;

	add	DWORD PTR [esi+48], 8

; 3854 :          for ( nn = 0 ; nn < pp  ; nn++ ) 
; 3855 :                ((char **)stacktop)[nn] = datafilename;

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax], OFFSET _datafilename
	mov	ecx, DWORD PTR [esi+48]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+4], OFFSET _datafilename
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN425@more_other:

; 3856 :        }
; 3857 :        break;
; 3858 : 
; 3859 :     case WARNING_MESSAGES_NODE: /* put ptr in both halves for 32-bit */
; 3860 :        { int pp = (sizeof(REAL))/sizeof(char*);
; 3861 :          int nn;
; 3862 :          ++stacktop;

	add	DWORD PTR [esi+48], 8

; 3863 :          for ( nn = 0 ; nn < pp  ; nn++ ) 
; 3864 :                ((char **)stacktop)[nn] = warning_messages;

	mov	edx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR _warning_messages
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR [esi+48]
	mov	edx, DWORD PTR _warning_messages
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+4], edx
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN421@more_other:

; 3865 :        }
; 3866 :        break;
; 3867 : 
; 3868 : 
; 3869 :     case QUOTATION_NODE: /* put ptr in both halves for 32-bit */
; 3870 :        { int pp = (sizeof(REAL))/sizeof(char*);
; 3871 :          int nn;
; 3872 :          *++stacktop = 0.0;

	add	DWORD PTR [esi+48], 8
	fldz
	mov	eax, DWORD PTR [esi+48]
	fstp	QWORD PTR [eax]

; 3873 :          for ( nn = 0 ; nn < pp  ; nn++ ) 
; 3874 :                  ((char **)stacktop)[nn] = node->op1.string;

	mov	ecx, DWORD PTR [ebx+32]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [ebx+32]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx+4], eax
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN417@more_other:

; 3875 :        }
; 3876 :        break;
; 3877 : 
; 3878 :     case DATE_AND_TIME_NODE:
; 3879 :        { time_t ltime;
; 3880 :          time(&ltime);

	lea	ecx, DWORD PTR _ltime$92246[ebp]
	push	ecx
	call	__time64

; 3881 :          *(char**)(++stacktop) = ctime(&ltime); 

	add	DWORD PTR [esi+48], 8
	mov	edi, DWORD PTR [esi+48]
	lea	edx, DWORD PTR _ltime$92246[ebp]
	push	edx
	call	__ctime64
	mov	DWORD PTR [edi], eax

; 3882 :          if ( strchr(*(char**)stacktop,'\n') ) 

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [eax]
	push	10					; 0000000aH
	push	ecx
	call	_strchr
	add	esp, 16					; 00000010H
	test	eax, eax
	je	$LN626@more_other

; 3883 :             *strchr(*(char**)stacktop,'\n') = 0;

	mov	edx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [edx]
	push	10					; 0000000aH
	push	eax
	call	_strchr
	add	esp, 8
	pop	edi
	pop	esi
	mov	BYTE PTR [eax], 0
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN415@more_other:

; 3884 :          break;
; 3885 :        }
; 3886 : 
; 3887 :     case EVOLVER_VERSION_NODE:
; 3888 :          *(char**)(++stacktop) = evolver_version; 

	add	DWORD PTR [esi+48], 8
	mov	esi, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR _evolver_version
	pop	edi
	mov	DWORD PTR [esi], ecx
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN414@more_other:

; 3889 :          break;
; 3890 :       
; 3891 : 
; 3892 :     case PRINTFHEAD_NODE:
; 3893 :     case BINARY_PRINTFHEAD_NODE:
; 3894 :           if ( node->op1.string ) s = node->op1.string;

	mov	ebx, DWORD PTR [ebx+32]
	test	ebx, ebx
	je	SHORT $LN413@more_other
	mov	edi, ebx
	jmp	SHORT $LN412@more_other
$LN413@more_other:

; 3895 :           else s = *(char**)(stacktop--);

	mov	eax, DWORD PTR [esi+48]
	mov	edi, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [esi+48], eax
$LN412@more_other:

; 3896 :           oldquiet = quiet_flag; quiet_flag = 0;
; 3897 :           sprintf(msg,s);

	mov	edx, DWORD PTR _msg
	mov	ebx, DWORD PTR _quiet_flag
	push	edi
	push	edx
	mov	DWORD PTR _quiet_flag, 0
	call	_sprintf

; 3898 :           outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring

; 3899 : #ifdef __L_EVOLVER__
; 3900 : 		  levolvertemp = strncmp("Saving png\n", s, 10); /* comparing characters before new line*/

	push	10					; 0000000aH
	push	edi
	push	OFFSET ??_C@_0M@EMICKKLA@Saving?5png?6?$AA@
	call	_strncmp
	add	esp, 24					; 00000018H
	mov	DWORD PTR _levolvertemp, eax

; 3901 : 		  if ( levolvertemp==0 )

	test	eax, eax
	jne	SHORT $LN411@more_other

; 3902 : 			  TakeScreenshot(0);

	push	eax
	call	_TakeScreenshot
	add	esp, 4
	pop	edi
	pop	esi

; 3933 : 					  }
; 3934 : 				  }
; 3935 : 			  }			
; 3936 : 		  }
; 3937 : #endif
; 3938 :           quiet_flag = oldquiet;

	mov	DWORD PTR _quiet_flag, ebx
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN411@more_other:

; 3903 : 		  else
; 3904 : 		  {
; 3905 : 			  levolvertemp = strncmp("Set png prefix=", s, 15); 

	push	15					; 0000000fH
	push	edi
	push	OFFSET ??_C@_0BA@LLDLGANG@Set?5png?5prefix?$DN?$AA@
	call	_strncmp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _levolvertemp, eax

; 3906 : 			  if ( levolvertemp==0 )

	test	eax, eax
	jne	SHORT $LN409@more_other

; 3907 : 			  {
; 3908 : 				  strcpy(png_prefix, s+15);

	lea	eax, DWORD PTR [edi+15]
	mov	edx, OFFSET _png_prefix
	sub	edx, eax
$LL874@more_other:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL874@more_other

; 3909 : 				  /* Erase unneeded new line character if present in filename */
; 3910 : 				  levolvertemp = strlen(png_prefix);

	mov	eax, OFFSET _png_prefix
	lea	edx, DWORD PTR [eax+1]
$LL1134@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1134@more_other
	sub	eax, edx
	mov	DWORD PTR _levolvertemp, eax

; 3911 : 				  if ( levolvertemp > 0 && png_prefix[levolvertemp - 1] == '\n' )

	test	eax, eax
	jle	$LN403@more_other
	cmp	BYTE PTR _png_prefix[eax-1], 10		; 0000000aH
	jne	$LN403@more_other

; 3933 : 					  }
; 3934 : 				  }
; 3935 : 			  }			
; 3936 : 		  }
; 3937 : #endif
; 3938 :           quiet_flag = oldquiet;

	pop	edi
	pop	esi
	mov	DWORD PTR _quiet_flag, ebx
	mov	BYTE PTR _png_prefix[eax-1], cl
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN409@more_other:

; 3912 : 					  png_prefix[levolvertemp - 1] = '\0' ;
; 3913 : 			  }
; 3914 : 			  else
; 3915 : 			  {
; 3916 : 				  levolvertemp = strncmp("Set png name=", s, 13); 

	push	13					; 0000000dH
	push	edi
	push	OFFSET ??_C@_0O@MLENCFID@Set?5png?5name?$DN?$AA@
	call	_strncmp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _levolvertemp, eax

; 3917 : 				  if ( levolvertemp==0 )

	test	eax, eax
	jne	$LN403@more_other

; 3918 : 				  {
; 3919 : 					  strcpy(png_name, s+13);

	lea	eax, DWORD PTR [edi+13]
	mov	edx, OFFSET _png_name
	sub	edx, eax
	npad	7
$LL875@more_other:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL875@more_other

; 3920 : 					  /* Erase unneeded new line character if present in filename */
; 3921 : 					  levolvertemp = strlen(png_name);

	mov	eax, OFFSET _png_name
	lea	edx, DWORD PTR [eax+1]
$LL1135@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1135@more_other
	sub	eax, edx
	mov	DWORD PTR _levolvertemp, eax

; 3922 : 					  if ( levolvertemp > 0 && png_name[levolvertemp - 1] == '\n' )

	test	eax, eax
	jle	SHORT $LN405@more_other
	cmp	BYTE PTR _png_name[eax-1], 10		; 0000000aH
	jne	SHORT $LN405@more_other

; 3923 : 						  png_name[levolvertemp - 1] = '\0' ;

	mov	BYTE PTR _png_name[eax-1], cl
$LN405@more_other:

; 3924 : 
; 3925 : 					  if ( png_name[0] == '\0' )

	cmp	BYTE PTR _png_name, 0
	jne	SHORT $LN404@more_other

; 3933 : 					  }
; 3934 : 				  }
; 3935 : 			  }			
; 3936 : 		  }
; 3937 : #endif
; 3938 :           quiet_flag = oldquiet;

	pop	edi
	pop	esi
	mov	DWORD PTR _quiet_flag, ebx
	mov	BYTE PTR _png_full_name, 0
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN404@more_other:

; 3926 : 					  {
; 3927 : 						  png_full_name[0] = '\0';
; 3928 : 					  }
; 3929 : 					  else
; 3930 : 					  {
; 3931 : 						  strcpy(png_full_name, png_dir); 

	xor	eax, eax
	npad	4
$LL876@more_other:
	mov	cl, BYTE PTR _png_dir[eax]
	mov	BYTE PTR _png_full_name[eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL876@more_other

; 3932 : 						  strcat(png_full_name, png_name);

	mov	eax, OFFSET _png_name
	mov	edx, eax
$LL1136@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1136@more_other
	mov	edi, OFFSET _png_full_name
	sub	eax, edx
	dec	edi
$LL1137@more_other:
	mov	cl, BYTE PTR [edi+1]
	inc	edi
	test	cl, cl
	jne	SHORT $LL1137@more_other
	mov	ecx, eax
	shr	ecx, 2
	mov	esi, edx
	rep movsd
	mov	ecx, eax
	and	ecx, 3
	rep movsb
$LN403@more_other:

; 3933 : 					  }
; 3934 : 				  }
; 3935 : 			  }			
; 3936 : 		  }
; 3937 : #endif
; 3938 :           quiet_flag = oldquiet;

	pop	edi
	pop	esi
	mov	DWORD PTR _quiet_flag, ebx
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN402@more_other:

; 3939 :           break;
; 3940 : 
; 3941 :     case ERRPRINTFHEAD_NODE:
; 3942 :           if ( node->op1.string ) s = node->op1.string;

	mov	ebx, DWORD PTR [ebx+32]
	test	ebx, ebx
	je	SHORT $LN401@more_other
	mov	ecx, ebx
	jmp	SHORT $LN400@more_other
$LN401@more_other:

; 3943 :           else s = *(char**)(stacktop--);

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [esi+48], eax
$LN400@more_other:

; 3944 :           sprintf(errmsg,s);

	push	ecx
	push	OFFSET _errmsg
	call	_sprintf

; 3945 :           erroutstring(errmsg);

	push	OFFSET _errmsg
	call	_erroutstring
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN399@more_other:

; 3946 :           break;
; 3947 : 
; 3948 :     case SPRINTFHEAD_NODE:
; 3949 :           if ( node->op1.string )

	cmp	DWORD PTR [ebx+32], 0
	je	$LN626@more_other

; 3950 :              *(char **)(++stacktop) = node->op1.string;

	add	DWORD PTR [esi+48], 8
	mov	esi, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [ebx+32]
	pop	edi
	mov	DWORD PTR [esi], ecx
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN397@more_other:

; 3951 :           /* else already on stack */
; 3952 :           break;
; 3953 : 
; 3954 :     case PRINTF_NODE:
; 3955 :     case ERRPRINTF_NODE:
; 3956 :     case SPRINTF_NODE:
; 3957 :      { char format[1000];
; 3958 :        char *newmsg;
; 3959 :        int newmsgsize;
; 3960 :        int formatcount = 0;
; 3961 : 
; 3962 :        newmsgsize = 1000;
; 3963 :        newmsg = temp_calloc(1,newmsgsize);

	push	3963					; 00000f7bH
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	push	1000					; 000003e8H
	push	1
	mov	DWORD PTR _formatcount$92280[ebp], 0
	mov	DWORD PTR _newmsgsize$92279[ebp], 1000	; 000003e8H
	call	_kb_temp_calloc

; 3964 : 
; 3965 :        n = node[node->right].op1.argcount;

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR _newmsg$92278[ebp], eax
	imul	edx, 168				; 000000a8H

; 3966 :        if ( node[node->left].op1.string ) 

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [edx+ebx+32]
	imul	eax, 168				; 000000a8H
	mov	eax, DWORD PTR [eax+ebx+32]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _n$[ebp], ecx
	test	eax, eax
	je	SHORT $LN396@more_other

; 3967 :            s = node[node->left].op1.string;

	mov	edi, eax
	mov	DWORD PTR _s$[ebp], eax

; 3968 :        else

	jmp	SHORT $LN1015@more_other
$LN396@more_other:

; 3969 :            s = *(char**)(stacktop-n);

	mov	edx, DWORD PTR [esi+48]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	sub	edx, ecx
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR _s$[ebp], edi
$LN1015@more_other:

; 3970 :        /* remove old string munges */
; 3971 :        { char *p,*c;
; 3972 :           /* strip %0.0s from format string */
; 3973 :           while ( (c = strstr(s,"%0.0s")) != NULL )

	push	OFFSET ??_C@_05NIOJGFPH@?$CF0?40s?$AA@
	push	edi
	call	_kb_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1017@more_other
$LL394@more_other:

; 3974 :           {  for ( p = c+5 ; *p ; c++,p++ ) *c = *p;

	mov	cl, BYTE PTR [eax+5]
	lea	edx, DWORD PTR [eax+5]
	test	cl, cl
	je	SHORT $LN390@more_other
	npad	4
$LL392@more_other:
	inc	edx
	mov	BYTE PTR [eax], cl
	mov	cl, BYTE PTR [edx]
	inc	eax
	test	cl, cl
	jne	SHORT $LL392@more_other
$LN390@more_other:

; 3970 :        /* remove old string munges */
; 3971 :        { char *p,*c;
; 3972 :           /* strip %0.0s from format string */
; 3973 :           while ( (c = strstr(s,"%0.0s")) != NULL )

	push	OFFSET ??_C@_05NIOJGFPH@?$CF0?40s?$AA@
	push	edi

; 3975 :               *c = 0;

	mov	BYTE PTR [eax], 0
	call	_kb_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL394@more_other
$LN1017@more_other:

; 3976 :           }
; 3977 :           while ( (c = strstr(s,"%.0s")) != NULL )

	push	OFFSET ??_C@_04FAGILPDO@?$CF?40s?$AA@
	push	edi
	call	_kb_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN388@more_other
$LL389@more_other:

; 3978 :           {  for ( p = c+4 ; *p ; c++,p++ ) *c = *p;

	mov	cl, BYTE PTR [eax+4]
	lea	edx, DWORD PTR [eax+4]
	test	cl, cl
	je	SHORT $LN385@more_other
	npad	5
$LL387@more_other:
	inc	edx
	mov	BYTE PTR [eax], cl
	mov	cl, BYTE PTR [edx]
	inc	eax
	test	cl, cl
	jne	SHORT $LL387@more_other
$LN385@more_other:

; 3976 :           }
; 3977 :           while ( (c = strstr(s,"%.0s")) != NULL )

	push	OFFSET ??_C@_04FAGILPDO@?$CF?40s?$AA@
	push	edi

; 3979 :               *c = 0;

	mov	BYTE PTR [eax], 0
	call	_kb_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL389@more_other
$LN388@more_other:

; 3986 :           char *sp = s;

	mov	ecx, DWORD PTR _s$[ebp]

; 3987 :           
; 3988 :           while ( *sp )

	cmp	BYTE PTR [ecx], 0
	mov	edi, DWORD PTR _newmsg$92278[ebp]
	mov	eax, DWORD PTR _n$[ebp]
	mov	DWORD PTR _msgspot$92302[ebp], edi
	mov	DWORD PTR _sp$92303[ebp], ecx
	je	$LN383@more_other

; 3980 :           }
; 3981 :        }
; 3982 : 
; 3983 :        /* new way, parse through format string */
; 3984 : 
; 3985 :        {  char *msgspot = newmsg; 

	neg	eax
	add	eax, eax
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv10032[ebp], 1
	mov	DWORD PTR tv10059[ebp], eax
	npad	2
$LL384@more_other:

; 3989 :           { char *f = format; /* for one format */
; 3990 :             int nn;
; 3991 :             struct treenode *nnode;
; 3992 :             char *ss;
; 3993 :             
; 3994 :             if ( (msgspot-newmsg) > (newmsgsize-500) )

	mov	edx, DWORD PTR _newmsgsize$92279[ebp]
	lea	eax, DWORD PTR _format$92277[ebp]
	mov	DWORD PTR _f$92307[ebp], eax
	mov	eax, edi
	sub	eax, DWORD PTR _newmsg$92278[ebp]
	add	edx, -500				; fffffe0cH
	mov	DWORD PTR tv6670[ebp], eax
	cmp	eax, edx
	jle	SHORT $LN382@more_other

; 3995 :             { size_t len = msgspot-newmsg;
; 3996 :               newmsg = temp_realloc(newmsg,2*newmsgsize);

	mov	edi, DWORD PTR _newmsgsize$92279[ebp]
	mov	eax, DWORD PTR _newmsg$92278[ebp]
	push	3996					; 00000f9cH
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	add	edi, edi
	push	edi
	push	eax
	call	_kb_temp_realloc

; 3997 :               newmsgsize *= 2;
; 3998 :               msgspot = newmsg + len;

	mov	ecx, DWORD PTR _sp$92303[ebp]
	mov	DWORD PTR _newmsgsize$92279[ebp], edi
	mov	edi, DWORD PTR tv6670[ebp]
	add	esp, 16					; 00000010H
	add	edi, eax
	mov	DWORD PTR _newmsg$92278[ebp], eax
	mov	DWORD PTR _msgspot$92302[ebp], edi
$LN382@more_other:

; 3999 :             }
; 4000 :             if ( *sp != '%' ) 

	mov	dl, BYTE PTR [ecx]
	cmp	dl, 37					; 00000025H
	je	SHORT $LN381@more_other

; 4001 :             { *(msgspot++) = *(sp++); 

	mov	BYTE PTR [edi], dl
	inc	edi
	inc	ecx
	mov	DWORD PTR _sp$92303[ebp], ecx

; 4002 :               continue; 

	jmp	$LN1409@more_other
$LN381@more_other:

; 4003 :             }
; 4004 :  
; 4005 :             /* now have % */
; 4006 : 
; 4007 :             /* check for %%, which reduces to % */
; 4008 :             if ( sp[1] == '%' )

	cmp	BYTE PTR [ecx+1], 37			; 00000025H
	jne	SHORT $LL379@more_other

; 4009 :             { *(msgspot++) = *(sp++); 

	mov	BYTE PTR [edi], 37			; 00000025H
	inc	edi

; 4010 :               (sp++); 

	add	ecx, 2
	mov	DWORD PTR _sp$92303[ebp], ecx

; 4011 :               continue; 

	jmp	$LN1409@more_other
	npad	6
$LL379@more_other:

; 4012 :             }
; 4013 : 
; 4014 :             /* find format character */
; 4015 :             while ( *sp && !isalpha(*sp) ) 

	movsx	edx, dl
	push	edx
	call	_isalpha

; 4016 :               *(f++) = *(sp++);

	mov	ecx, DWORD PTR _f$92307[ebp]
	add	esp, 4
	test	eax, eax
	mov	eax, DWORD PTR _sp$92303[ebp]
	jne	SHORT $LN378@more_other
	movzx	edx, BYTE PTR [eax]
	inc	eax
	mov	BYTE PTR [ecx], dl
	mov	dl, BYTE PTR [eax]
	inc	ecx
	mov	DWORD PTR _f$92307[ebp], ecx
	mov	DWORD PTR _sp$92303[ebp], eax
	test	dl, dl
	jne	SHORT $LL379@more_other
$LN378@more_other:

; 4017 : 
; 4018 :             *(f++) = *(sp++); /* copy format character */

	mov	dl, BYTE PTR [eax]
	inc	eax
	mov	BYTE PTR [ecx], dl
	mov	DWORD PTR _sp$92303[ebp], eax

; 4019 :             *f = 0; /* null terminator */
; 4020 :              switch ( f[-1] )

	movsx	eax, BYTE PTR [ecx]
	add	eax, -69				; ffffffbbH
	mov	BYTE PTR [ecx+1], 0
	cmp	eax, 51					; 00000033H
	ja	$LN360@more_other
	movzx	eax, BYTE PTR $LN1138@more_other[eax]
	jmp	DWORD PTR $LN1435@more_other[eax*4]
$LN375@more_other:

; 4024 :                  for ( nn = 0 ; nn <= formatcount ; nn++ )

	cmp	DWORD PTR _formatcount$92280[ebp], 0
	mov	eax, ebx
	jl	SHORT $LN372@more_other

; 4021 :              { case 's':
; 4022 :                  /* check that really have a string argument */
; 4023 :                  nnode = node;

	mov	ecx, DWORD PTR tv10032[ebp]
$LL1260@more_other:

; 4025 :                    nnode += nnode->right;

	mov	edx, DWORD PTR [eax+8]
	imul	edx, 168				; 000000a8H
	add	eax, edx
	dec	ecx
	jne	SHORT $LL1260@more_other
$LN372@more_other:

; 4026 :                  nnode += nnode->left;

	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 168				; 000000a8H
	add	eax, ecx

; 4027 :                  if ( !(nnode->flags &  HAS_STRING) && 
; 4028 :                        !(nnode->datatype == STRING_TYPE) &&
; 4029 :                         !(nnode->type == STRINGGLOBAL_NODE) &&
; 4030 :                           !(nnode->type == PERM_STRINGGLOBAL_NODE) &&
; 4031 :                            !(nnode->type == SPRINTFHEAD_NODE)  &&
; 4032 :                            !(nnode->type == DATE_AND_TIME_NODE)  &&
; 4033 :                            !(nnode->type == EVOLVER_VERSION_NODE) &&
; 4034 :                            !(nnode->type == DATAFILENAME_NODE))  

	test	BYTE PTR [eax+24], 32			; 00000020H
	mov	DWORD PTR _nnode$92309[ebp], eax
	jne	$LN371@more_other
	cmp	DWORD PTR [eax+20], 11			; 0000000bH
	je	$LN371@more_other
	mov	eax, DWORD PTR [eax]
	cmp	eax, 10103				; 00002777H
	je	$LN371@more_other
	cmp	eax, 10105				; 00002779H
	je	$LN371@more_other
	cmp	eax, 10665				; 000029a9H
	je	$LN371@more_other
	cmp	eax, 10660				; 000029a4H
	je	$LN371@more_other
	cmp	eax, 10661				; 000029a5H
	je	$LN371@more_other
	cmp	eax, 10657				; 000029a1H
	je	$LN371@more_other

; 4035 :                   {  sprintf(errmsg,
; 4036 :                      "Argument %d: String format does not have string argument.\n",
; 4037 :                         formatcount+1);

	mov	edx, DWORD PTR tv10032[ebp]
	push	edx
	push	OFFSET ??_C@_0DL@PCELCLJI@Argument?5?$CFd?3?5String?5format?5does?5@
	push	OFFSET _errmsg
	call	_sprintf

; 4038 :                      strcat(errmsg,"Possibly % not followed by legal format?\n");

	mov	edi, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	dec	edi
$LL1261@more_other:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL1261@more_other
	mov	ecx, 10					; 0000000aH
	mov	esi, OFFSET ??_C@_0CK@DDEBKHJG@Possibly?5?$CF?5not?5followed?5by?5legal@
	rep movsd

; 4039 :                      sprintf(errmsg+strlen(errmsg),"(source file %s, line %d; nnode->type %d)\n",
; 4040 :                         file_names[node->file_no],node->line_no,nnode->type);

	mov	eax, OFFSET _errmsg
	movsw
	lea	edx, DWORD PTR [eax+1]
$LL1262@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1262@more_other
	mov	ecx, DWORD PTR _nnode$92309[ebp]
	sub	eax, edx
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ebx+12]
	push	edx
	mov	edx, DWORD PTR [ebx+16]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0CL@KCHMNGLN@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$DL?5nnode?9@
	push	eax
	call	_sprintf

; 4041 :                      kb_error(3111,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3111					; 00000c27H
	call	_kb_error
	mov	esi, DWORD PTR _td$[ebp]
	mov	edi, DWORD PTR _msgspot$92302[ebp]
	add	esp, 32					; 00000020H
$LN371@more_other:

; 4042 :                   }
; 4043 :                  ss = *(char**)(stacktop-n+1+formatcount);

	mov	ecx, DWORD PTR [esi+48]
	mov	edx, DWORD PTR tv10059[ebp]
	mov	eax, DWORD PTR [ecx+edx+8]
	mov	DWORD PTR _ss$92310[ebp], eax

; 4044 :                  if ( ss == NULL ) ss = "(NULL)";

	test	eax, eax
	jne	SHORT $LN1022@more_other
	mov	eax, OFFSET ??_C@_06LHGEHABH@?$CINULL?$CJ?$AA@
	mov	DWORD PTR _ss$92310[ebp], eax
$LN1022@more_other:

; 4045 :                  while ( (int)(msgspot-newmsg+strlen(ss))
; 4046 :                           > (int)(newmsgsize-10) )

	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL1263@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1263@more_other
	mov	ecx, DWORD PTR _newmsgsize$92279[ebp]
	sub	eax, edx
	sub	eax, DWORD PTR _newmsg$92278[ebp]
	add	ecx, -10				; fffffff6H
	add	eax, edi
	cmp	eax, ecx
	jle	SHORT $LN368@more_other
	npad	2
$LL369@more_other:

; 4047 :                  { size_t len = msgspot-newmsg;
; 4048 :                    newmsg = temp_realloc(newmsg,2*newmsgsize);

	mov	eax, DWORD PTR _newmsgsize$92279[ebp]
	mov	ecx, DWORD PTR _newmsg$92278[ebp]
	push	4048					; 00000fd0H
	add	eax, eax
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	push	eax
	push	ecx
	sub	edi, ecx
	mov	DWORD PTR tv6673[ebp], eax
	call	_kb_temp_realloc

; 4049 :                    newmsgsize *= 2;

	mov	edx, DWORD PTR tv6673[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR _newmsg$92278[ebp], eax

; 4050 :                    msgspot = newmsg + len;

	add	edi, eax
	mov	eax, DWORD PTR _ss$92310[ebp]
	mov	DWORD PTR _newmsgsize$92279[ebp], edx
	lea	ecx, DWORD PTR [eax+1]
$LL1265@more_other:

; 4045 :                  while ( (int)(msgspot-newmsg+strlen(ss))
; 4046 :                           > (int)(newmsgsize-10) )

	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL1265@more_other
	sub	eax, ecx
	sub	eax, DWORD PTR _newmsg$92278[ebp]
	mov	ecx, DWORD PTR _newmsgsize$92279[ebp]
	add	eax, edi
	add	ecx, -10				; fffffff6H
	cmp	eax, ecx
	jg	SHORT $LL369@more_other
$LN368@more_other:

; 4051 :                  } 
; 4052 :                  sprintf(msgspot,format,ss);

	mov	edx, DWORD PTR _ss$92310[ebp]
	push	edx
	lea	eax, DWORD PTR _format$92277[ebp]
	push	eax
	push	edi
	call	_sprintf

; 4053 :                  ++formatcount;

	add	DWORD PTR tv10059[ebp], 8
	mov	eax, 1
	add	DWORD PTR _formatcount$92280[ebp], eax
	add	esp, 12					; 0000000cH
	add	DWORD PTR tv10032[ebp], eax

; 4054 :                  break;

	jmp	$LN376@more_other
$LN367@more_other:

; 4055 :                case 'd': case 'u': case 'o': case 'x': case 'X': case 'p': case 'c':
; 4056 :                  sprintf(msgspot,format,(int)(*(stacktop-n+ ++formatcount)));

	mov	eax, DWORD PTR tv10059[ebp]
	mov	ecx, 1
	add	DWORD PTR _formatcount$92280[ebp], ecx
	add	DWORD PTR tv10032[ebp], ecx
	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx+eax+8]
	add	eax, 8
	mov	DWORD PTR tv10059[ebp], eax
	call	__ftol2_sse
	push	eax
	lea	edx, DWORD PTR _format$92277[ebp]
	push	edx
	push	edi
	call	_sprintf
	add	esp, 12					; 0000000cH

; 4057 :                  break;

	jmp	$LN376@more_other
$LN366@more_other:

; 4058 :                case 'f': case 'g': case 'e': case 'E': case 'G':
; 4059 :                  if ( fabs(*(stacktop-n+ (formatcount+1))) > 1e100 )

	mov	eax, DWORD PTR tv10059[ebp]
	mov	edx, DWORD PTR [esi+48]
	fld	QWORD PTR [eax+edx+8]
	fabs
	fcomp	QWORD PTR __real@54b249ad2594c37d
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN365@more_other

; 4060 :                     f[-1] = 'g'; /* prevent buffer overflow */

	mov	BYTE PTR [ecx], 103			; 00000067H
$LN365@more_other:

; 4061 : #ifdef FLOAT128
; 4062 :                  f[0] = f[-1]; f[-1] = 'Q'; f[1] = 0;
; 4063 : #elif defined(LONGDOUBLE)
; 4064 :                  f[0] = f[-1]; f[-1] = 'L'; f[1] = 0;
; 4065 : #endif
; 4066 :                  ++formatcount;

	mov	ecx, DWORD PTR tv10059[ebp]

; 4067 :                  if ( !is_finite(*(stacktop-n + formatcount)) )

	fld	QWORD PTR __real@fe37e43c8800759c
	fcomp	QWORD PTR [ecx+edx+8]
	inc	DWORD PTR _formatcount$92280[ebp]
	inc	DWORD PTR tv10032[ebp]
	add	ecx, 8
	mov	DWORD PTR tv10059[ebp], ecx
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN363@more_other
	fld	QWORD PTR __real@7e37e43c8800759c
	fcomp	QWORD PTR [ecx+edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN363@more_other

; 4069 :                  else
; 4070 :                     sprintf(msgspot,format,(*(stacktop-n + formatcount)));

	fld	QWORD PTR [ecx+edx]
	sub	esp, 8
	lea	edx, DWORD PTR _format$92277[ebp]
	fstp	QWORD PTR [esp]
	push	edx
	push	edi
	call	_sprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN376@more_other
$LN363@more_other:

; 4068 :                     strcat(msgspot,"(NaN)");  

	lea	eax, DWORD PTR [edi-1]
$LL1266@more_other:
	mov	cl, BYTE PTR [eax+1]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1266@more_other
	mov	ecx, DWORD PTR ??_C@_05PPNJJAGI@?$CINaN?$CJ?$AA@
	mov	DWORD PTR [eax], ecx
	mov	dx, WORD PTR ??_C@_05PPNJJAGI@?$CINaN?$CJ?$AA@+4
	mov	WORD PTR [eax+4], dx

; 4071 :                  break;

	jmp	SHORT $LN376@more_other
$LN361@more_other:

; 4072 : 
; 4073 :                case 'n': 
; 4074 :                  kb_error(5434,"Illegal format specifier: %n\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0BO@PHJFLEKB@Illegal?5format?5specifier?3?5?$CFn?6?$AA@
	push	5434					; 0000153aH
	call	_kb_error
	add	esp, 12					; 0000000cH

; 4075 :                  break;

	jmp	SHORT $LN376@more_other
$LN360@more_other:

; 4076 : 
; 4077 :                default: 
; 4078 :                  sprintf(msgspot,format,0,0,0,0);  /* unrecognized */

	push	0
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _format$92277[ebp]
	push	eax
	push	edi
	call	_sprintf
	add	esp, 24					; 00000018H
$LN376@more_other:

; 4079 :              }
; 4080 :              msgspot += strlen(msgspot);

	mov	eax, edi
	lea	edx, DWORD PTR [eax+1]
$LL1267@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1267@more_other
	mov	ecx, DWORD PTR _sp$92303[ebp]
	sub	eax, edx
	add	edi, eax
$LN1409@more_other:
	cmp	BYTE PTR [ecx], 0
	mov	DWORD PTR _msgspot$92302[ebp], edi
	jne	$LL384@more_other

; 3987 :           
; 3988 :           while ( *sp )

	mov	eax, DWORD PTR _n$[ebp]
$LN383@more_other:

; 4081 :           }
; 4082 :           if ( formatcount > n )

	cmp	DWORD PTR _formatcount$92280[ebp], eax
	jle	SHORT $LN359@more_other

; 4083 :           { sprintf(errmsg,
; 4084 :             "Format string has %d formats, but there are only %d arguments.\n",
; 4085 :               formatcount,n);

	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _formatcount$92280[ebp]
	push	ecx
	push	edx
	push	OFFSET ??_C@_0EA@GNCLKEFD@Format?5string?5has?5?$CFd?5formats?0?5bu@
	push	OFFSET _errmsg
	call	_sprintf

; 4086 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4087 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL1268@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1268@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 4088 :             kb_error(2044,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2044					; 000007fcH
	call	_kb_error
	mov	eax, DWORD PTR _n$[ebp]
	add	esp, 28					; 0000001cH
$LN359@more_other:

; 4089 :           }
; 4090 :          *msgspot = 0;   /* null terminator */
; 4091 :          stacktop -= n; /* pop args */

	neg	eax
	add	eax, eax
	add	eax, eax
	mov	BYTE PTR [edi], 0
	add	eax, eax
	add	DWORD PTR [esi+48], eax

; 4092 :        }
; 4093 : 
; 4094 :        if ( node[node->left].op1.string == NULL ) stacktop--;

	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [esi+48]
	imul	ecx, 168				; 000000a8H
	cmp	DWORD PTR [ecx+ebx+32], 0
	jne	SHORT $LN358@more_other
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [esi+48], eax
$LN358@more_other:

; 4095 :        if ( node->type == PRINTF_NODE )

	mov	ebx, DWORD PTR [ebx]
	cmp	ebx, 10666				; 000029aaH
	jne	SHORT $LN357@more_other

; 4096 :        { int old_flag = quiet_flag;
; 4097 :          quiet_flag = 0;
; 4098 :          outstring(newmsg);

	mov	edx, DWORD PTR _newmsg$92278[ebp]
	mov	esi, DWORD PTR _quiet_flag
	push	edx
	mov	DWORD PTR _quiet_flag, 0
	call	_outstring

; 4107 :        }
; 4108 :        temp_free(newmsg);

	mov	ecx, DWORD PTR _newmsg$92278[ebp]
	add	esp, 4
	push	ecx
	mov	DWORD PTR _quiet_flag, esi
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN357@more_other:

; 4099 :          quiet_flag = old_flag;
; 4100 :        }
; 4101 :        else if ( node->type == ERRPRINTF_NODE )
; 4102 :           erroutstring(newmsg);

	mov	eax, DWORD PTR _newmsg$92278[ebp]
	cmp	ebx, 10667				; 000029abH
	jne	SHORT $LN355@more_other
	push	eax
	call	_erroutstring

; 4107 :        }
; 4108 :        temp_free(newmsg);

	mov	ecx, DWORD PTR _newmsg$92278[ebp]
	add	esp, 4
	push	ecx
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN355@more_other:

; 4103 :        else /* SPRINTF_ */
; 4104 :        { char *str = mycalloc(strlen(newmsg)+2,1);

	lea	edx, DWORD PTR [eax+1]
$LL1269@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1269@more_other
	push	4104					; 00001008H
	sub	eax, edx
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	add	eax, 2
	push	1
	push	eax
	call	_kb_calloc

; 4105 :          strcpy(str,newmsg);

	mov	ecx, DWORD PTR _newmsg$92278[ebp]
	mov	edi, eax
	add	esp, 16					; 00000010H
	sub	edi, ecx
$LL1270@more_other:
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [ecx+edi], dl
	inc	ecx
	test	dl, dl
	jne	SHORT $LL1270@more_other

; 4106 :          *(char **)(++stacktop) = str;

	add	DWORD PTR [esi+48], 8

; 4107 :        }
; 4108 :        temp_free(newmsg);

	mov	ecx, DWORD PTR _newmsg$92278[ebp]
	mov	esi, DWORD PTR [esi+48]
	push	ecx
	mov	DWORD PTR [esi], eax
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN353@more_other:

; 4109 :           
; 4110 :       }
; 4111 :      break;
; 4112 : 
; 4113 :     case BINARY_PRINTF_NODE:
; 4114 :      { char format[1000];
; 4115 :        int formatcount = 0;

	xor	edi, edi
	mov	DWORD PTR _formatcount$92364[ebp], edi

; 4116 :        int byte_reverse = 0;

	mov	DWORD PTR _byte_reverse$92365[ebp], edi

; 4117 :        int test_int = 0x0124567;
; 4118 : 
; 4119 :        if ( !big_endian_flag && !little_endian_flag )

	cmp	DWORD PTR _big_endian_flag, edi
	jne	SHORT $LN1125@more_other
	cmp	DWORD PTR _little_endian_flag, edi
	jne	SHORT $LN351@more_other

; 4120 :        { sprintf(errmsg, "binary_printf: you must set 'big_endian' or 'little_endian' toggles.");

	push	OFFSET ??_C@_0EF@OOJIKBOM@binary_printf?3?5you?5must?5set?5?8big@
	push	OFFSET _errmsg
	call	_sprintf

; 4121 :          sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4122 :                                 file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL1271@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1271@more_other
	mov	ecx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4123 :          kb_error(1935,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1935					; 0000078fH
	call	_kb_error
	add	esp, 28					; 0000001cH

; 4124 :        }
; 4125 :        if ( big_endian_flag && (*(char*)&test_int)==0x67)

	cmp	DWORD PTR _big_endian_flag, edi
	je	SHORT $LN351@more_other
$LN1125@more_other:

; 4126 :          byte_reverse = 1;

	mov	DWORD PTR _byte_reverse$92365[ebp], 1
$LN351@more_other:

; 4127 :        if ( little_endian_flag && (*(char*)&test_int)==0x01)
; 4128 :          byte_reverse = 1;
; 4129 : 
; 4130 : #ifdef WIN32
; 4131 :        fflush(outfd);

	mov	eax, DWORD PTR _outfd
	push	eax
	call	_fflush

; 4132 :        _setmode(_fileno(outfd),_O_BINARY);

	mov	ecx, DWORD PTR _outfd
	add	esp, 4
	push	32768					; 00008000H
	push	ecx
	call	__fileno
	add	esp, 4
	push	eax
	call	__setmode

; 4133 : #endif
; 4134 :        n = node[node->right].op1.argcount;
; 4135 :        if ( node[node->left].op1.string ) 

	mov	eax, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ebx+8]
	imul	eax, 168				; 000000a8H
	mov	eax, DWORD PTR [eax+ebx+32]
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [edx+ebx+32]
	add	esp, 8
	mov	DWORD PTR _n$[ebp], ecx
	cmp	eax, edi

; 4136 :            s = node[node->left].op1.string;
; 4137 :        else

	jne	SHORT $LN348@more_other

; 4138 :            s = *(char**)(stacktop-n);

	mov	edx, DWORD PTR [esi+48]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	sub	edx, ecx
	mov	eax, DWORD PTR [edx]
$LN348@more_other:

; 4144 :           
; 4145 :           while ( *sp )

	cmp	BYTE PTR [eax], 0
	mov	DWORD PTR _sp$92378[ebp], eax
	je	$LN346@more_other

; 4139 : 
; 4140 :        /* parse through format string */
; 4141 : 
; 4142 :        {  char *msgspot=NULL; 
; 4143 :           char *sp = s;

	mov	eax, DWORD PTR _n$[ebp]
	neg	eax
	add	eax, eax
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv10114[ebp], 1
	mov	DWORD PTR tv10154[ebp], eax
	npad	6
$LL347@more_other:

; 4146 :           { char *f = format; /* for one format */
; 4147 :             int nn;
; 4148 :             struct treenode *nnode;
; 4149 :                     
; 4150 :             if ( *sp != '%' )

	mov	edi, DWORD PTR _sp$92378[ebp]
	mov	al, BYTE PTR [edi]
	lea	esi, DWORD PTR _format$92363[ebp]
	cmp	al, 37					; 00000025H
	je	SHORT $LL344@more_other

; 4151 :             { fwrite(sp,1,1,outfd);

	mov	eax, DWORD PTR _outfd
	push	eax
	push	1
	push	1
	push	edi
	call	_fwrite
	add	esp, 16					; 00000010H

; 4152 :               sp++; 

	inc	edi
	mov	DWORD PTR _sp$92378[ebp], edi

; 4153 :               continue; 

	jmp	$LN340@more_other
$LL344@more_other:

; 4154 :             }
; 4155 :  
; 4156 :             while ( *sp && (!isalpha(*sp) || *sp=='l') )

	movsx	ecx, al
	push	ecx
	call	_isalpha
	add	esp, 4
	test	eax, eax
	je	SHORT $LN342@more_other
	cmp	BYTE PTR [edi], 108			; 0000006cH
	jne	SHORT $LN343@more_other
$LN342@more_other:

; 4157 :               *(f++) = *(sp++);

	mov	dl, BYTE PTR [edi]
	mov	al, BYTE PTR [edi+1]
	inc	edi
	mov	BYTE PTR [esi], dl
	inc	esi
	test	al, al
	jne	SHORT $LL344@more_other
$LN343@more_other:

; 4158 :             *(f++) = *(sp++); /* copy format character */

	mov	al, BYTE PTR [edi]
	mov	BYTE PTR [esi], al
	mov	edx, 1

; 4159 :             *f = 0; /* null terminator */
; 4160 :              switch ( f[-1] )

	movsx	eax, BYTE PTR [esi+edx-1]
	add	esi, edx
	add	edi, edx
	lea	ecx, DWORD PTR [eax-69]
	mov	DWORD PTR _sp$92378[ebp], edi
	mov	BYTE PTR [esi], 0
	cmp	ecx, 51					; 00000033H
	ja	$LN307@more_other
	movzx	ecx, BYTE PTR $LN1148@more_other[ecx]
	jmp	DWORD PTR $LN1436@more_other[ecx*4]
$LN339@more_other:

; 4164 :                  for ( nn = 0 ; nn <= formatcount ; nn++ )

	cmp	DWORD PTR _formatcount$92364[ebp], 0
	mov	eax, ebx
	jl	SHORT $LN336@more_other

; 4161 :              { case 's':
; 4162 :                  /* check that really have a string argument */
; 4163 :                  nnode = node;

	mov	ecx, DWORD PTR tv10114[ebp]
	npad	7
$LL1274@more_other:

; 4165 :                    nnode += nnode->right;

	mov	esi, DWORD PTR [eax+8]
	imul	esi, 168				; 000000a8H
	add	eax, esi
	sub	ecx, edx
	jne	SHORT $LL1274@more_other
$LN336@more_other:

; 4166 :                  nnode += nnode->left;

	mov	edx, DWORD PTR [eax+4]
	imul	edx, 168				; 000000a8H
	add	eax, edx

; 4167 :                  if ( !(nnode->flags &  HAS_STRING) && 
; 4168 :                         !(nnode->type == STRINGGLOBAL_NODE) &&
; 4169 :                           !(nnode->type == PERM_STRINGGLOBAL_NODE) &&
; 4170 :                            !(nnode->type == SPRINTFHEAD_NODE)  &&
; 4171 :                            !(nnode->type == DATE_AND_TIME_NODE)  &&
; 4172 :                            !(nnode->type == DATAFILENAME_NODE))  

	test	BYTE PTR [eax+24], 32			; 00000020H
	mov	DWORD PTR _nnode$92384[ebp], eax
	jne	$LN335@more_other
	mov	eax, DWORD PTR [eax]
	cmp	eax, 10103				; 00002777H
	je	$LN335@more_other
	cmp	eax, 10105				; 00002779H
	je	$LN335@more_other
	cmp	eax, 10665				; 000029a9H
	je	$LN335@more_other
	cmp	eax, 10660				; 000029a4H
	je	$LN335@more_other
	cmp	eax, 10657				; 000029a1H
	je	$LN335@more_other

; 4173 :                   {  sprintf(errmsg,
; 4174 :                      "Argument %d: String format does not have string argument.\n",
; 4175 :                         formatcount+1);

	mov	ecx, DWORD PTR tv10114[ebp]
	push	ecx
	push	OFFSET ??_C@_0DL@PCELCLJI@Argument?5?$CFd?3?5String?5format?5does?5@
	push	OFFSET _errmsg
	call	_sprintf

; 4176 :                      strcat(errmsg,"Possibly % not followed by legal format?\n");

	mov	edi, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	dec	edi
$LL1275@more_other:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL1275@more_other
	mov	ecx, 10					; 0000000aH
	mov	esi, OFFSET ??_C@_0CK@DDEBKHJG@Possibly?5?$CF?5not?5followed?5by?5legal@
	rep movsd

; 4177 :                      sprintf(errmsg+strlen(errmsg),"(source file %s, line %d; nnode->type %d)\n",
; 4178 :                         file_names[node->file_no],node->line_no,nnode->type);

	mov	eax, OFFSET _errmsg
	movsw
	lea	edx, DWORD PTR [eax+1]
$LL1276@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1276@more_other
	sub	eax, edx
	mov	edx, DWORD PTR _nnode$92384[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR [ebx+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0CL@KCHMNGLN@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$DL?5nnode?9@
	push	edx
	call	_sprintf

; 4179 :                      kb_error(3212,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3212					; 00000c8cH
	call	_kb_error
	add	esp, 32					; 00000020H
$LN335@more_other:

; 4180 :                   }
; 4181 :                  msgspot = *(char**)(stacktop-n+ ++formatcount);

	mov	eax, DWORD PTR tv10154[ebp]
	mov	ecx, DWORD PTR _td$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	esi, DWORD PTR [eax+edx+8]
	add	eax, 8
	mov	edi, 1
	add	DWORD PTR _formatcount$92364[ebp], edi
	add	DWORD PTR tv10114[ebp], edi
	mov	DWORD PTR tv10154[ebp], eax

; 4182 :                  fwrite(msgspot,1,strlen(msgspot),outfd);

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL1277@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1277@more_other
	mov	ecx, DWORD PTR _outfd
	push	ecx
	sub	eax, edx
	push	eax
	push	edi
	push	esi
	call	_fwrite
	add	esp, 16					; 00000010H

; 4183 :                  break;

	jmp	$LN340@more_other
$LN334@more_other:

; 4184 :                case 'c': /* one byte */
; 4185 :                  { int c = (int)*(stacktop-n+ ++formatcount);

	add	DWORD PTR _formatcount$92364[ebp], edx
	add	DWORD PTR tv10114[ebp], edx
	mov	eax, DWORD PTR tv10154[ebp]
	mov	edx, DWORD PTR _td$[ebp]
	mov	ecx, DWORD PTR [edx+48]
	fld	QWORD PTR [ecx+eax+8]
	add	eax, 8
	mov	DWORD PTR tv10154[ebp], eax
	call	__ftol2_sse

; 4186 :                    fwrite(&c,1,1,outfd);

	mov	edx, DWORD PTR _outfd
	push	edx
	push	1
	mov	DWORD PTR _c$92401[ebp], eax
	lea	eax, DWORD PTR _c$92401[ebp]
	push	1
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H

; 4187 :                  }
; 4188 :                  break;

	jmp	$LN340@more_other
$LN333@more_other:

; 4189 :                case 'd': case 'u': case 'o': case 'x': case 'X': case 'p':
; 4190 :                  if ( f[-2] == 'l' )
; 4191 :                  { int m = (int)*(stacktop-n+ ++formatcount);

	mov	eax, DWORD PTR tv10154[ebp]
	add	DWORD PTR _formatcount$92364[ebp], edx
	add	DWORD PTR tv10114[ebp], edx
	mov	ecx, DWORD PTR _td$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	fld	QWORD PTR [edx+eax+8]
	add	eax, 8
	cmp	BYTE PTR [esi-2], 108			; 0000006cH
	mov	DWORD PTR tv10154[ebp], eax
	jne	SHORT $LN332@more_other
	call	__ftol2_sse

; 4192 :                    if ( byte_reverse )

	cmp	DWORD PTR _byte_reverse$92365[ebp], 0
	mov	DWORD PTR _m$92405[ebp], eax
	je	SHORT $LN331@more_other

; 4193 :                    { char buf[4];
; 4194 :                      for ( i = 0 ; i < 4 ; i++ )
; 4195 :                        buf[i] = ((char*)&m)[4-1-i];

	mov	cl, BYTE PTR _m$92405[ebp+3]
	mov	dl, BYTE PTR _m$92405[ebp+2]
	mov	BYTE PTR _buf$92408[ebp+2], ah
	mov	BYTE PTR _buf$92408[ebp+3], al

; 4196 :                      fwrite(buf,4,1,outfd);

	mov	eax, DWORD PTR _outfd
	push	eax
	push	1
	mov	BYTE PTR _buf$92408[ebp], cl
	lea	ecx, DWORD PTR _buf$92408[ebp]
	push	4
	push	ecx
	mov	BYTE PTR _buf$92408[ebp+1], dl
	call	_fwrite
	add	esp, 16					; 00000010H

; 4197 :                    }
; 4198 :                    else 

	jmp	$LN340@more_other
$LN331@more_other:

; 4199 :                      fwrite(&m,4,1,outfd);

	mov	edx, DWORD PTR _outfd
	push	edx
	push	1
	lea	eax, DWORD PTR _m$92405[ebp]
	push	4
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H

; 4200 :                  }
; 4201 :                  else /* 2-byte short */

	jmp	$LN340@more_other
$LN332@more_other:

; 4202 :                  { short m = (short)*(stacktop-n+ ++formatcount);

	call	__ftol2_sse

; 4203 :                    if ( byte_reverse )

	cmp	DWORD PTR _byte_reverse$92365[ebp], 0
	movzx	eax, ax
	mov	DWORD PTR _m$92415[ebp], eax
	je	SHORT $LN325@more_other

; 4204 :                    { char buf[2];
; 4205 :                      for ( i = 0 ; i < 2 ; i++ )
; 4206 :                        buf[i] = ((char*)&m)[2-1-i];

	mov	BYTE PTR _buf$92418[ebp], ah
	mov	BYTE PTR _buf$92418[ebp+1], al

; 4207 :                      fwrite(buf,2,1,outfd);

	mov	eax, DWORD PTR _outfd
	push	eax
	push	1
	lea	ecx, DWORD PTR _buf$92418[ebp]
	push	2
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 4208 :                    }
; 4209 :                    else 

	jmp	$LN340@more_other
$LN325@more_other:

; 4210 :                      fwrite(&m,2,1,outfd);

	mov	edx, DWORD PTR _outfd
	push	edx
	push	1
	lea	eax, DWORD PTR _m$92415[ebp]
	push	2
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H

; 4211 :                  }
; 4212 :                  break;

	jmp	$LN340@more_other
$LN320@more_other:

; 4213 :                case 'f': case 'g': case 'e': case 'E': case 'G':
; 4214 :                  if ( f[-2] == 'l' )
; 4215 :                  { /* 8-byte double */
; 4216 :                    double x = *(stacktop-n+ ++formatcount);

	mov	eax, DWORD PTR tv10154[ebp]
	add	DWORD PTR _formatcount$92364[ebp], edx
	add	DWORD PTR tv10114[ebp], edx
	mov	ecx, DWORD PTR _td$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	add	eax, 8
	cmp	BYTE PTR [esi-2], 108			; 0000006cH
	mov	DWORD PTR tv10154[ebp], eax
	jne	$LN319@more_other

; 4217 :                    if ( byte_reverse )

	cmp	DWORD PTR _byte_reverse$92365[ebp], 0
	fld	QWORD PTR [eax+ecx]
	fstp	QWORD PTR _x$92426[ebp]
	je	SHORT $LN318@more_other

; 4218 :                    { char buf[8];
; 4219 :                      int i;
; 4220 :                      for ( i = 0 ; i < 8 ; i++ )
; 4221 :                        buf[i] = ((char*)&x)[7-i];

	movzx	eax, BYTE PTR _x$92426[ebp+7]
	movzx	ecx, BYTE PTR _x$92426[ebp+6]
	mov	BYTE PTR _buf$92428[ebp], al
	movzx	eax, BYTE PTR _x$92426[ebp+5]
	mov	BYTE PTR _buf$92428[ebp+1], cl
	movzx	ecx, BYTE PTR _x$92426[ebp+4]
	mov	BYTE PTR _buf$92428[ebp+2], al
	movzx	eax, BYTE PTR _x$92426[ebp+3]
	mov	BYTE PTR _buf$92428[ebp+3], cl
	movzx	ecx, BYTE PTR _x$92426[ebp+2]
	mov	BYTE PTR _buf$92428[ebp+4], al
	movzx	eax, BYTE PTR _x$92426[ebp+1]
	mov	BYTE PTR _buf$92428[ebp+5], cl
	movzx	ecx, BYTE PTR _x$92426[ebp]
	mov	BYTE PTR _buf$92428[ebp+6], al

; 4222 :                      fwrite(buf,8,1,outfd);

	mov	eax, DWORD PTR _outfd
	push	eax
	push	edx
	mov	BYTE PTR _buf$92428[ebp+7], cl
	lea	ecx, DWORD PTR _buf$92428[ebp]
	push	8
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 4223 :                    }
; 4224 :                    else 

	jmp	$LN340@more_other
$LN318@more_other:

; 4225 :                      fwrite(&x,8,1,outfd);

	mov	eax, DWORD PTR _outfd
	push	eax
	push	edx
	lea	ecx, DWORD PTR _x$92426[ebp]
	push	8
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 4226 :                  }
; 4227 :                  else /* 4-byte float */

	jmp	$LN340@more_other
$LN319@more_other:

; 4228 :                  { float x = (float)*(stacktop-n+ ++formatcount);
; 4229 :                    if ( byte_reverse )

	cmp	DWORD PTR _byte_reverse$92365[ebp], 0
	fld	QWORD PTR [ecx+eax]
	fstp	DWORD PTR _x$92436[ebp]
	je	SHORT $LN312@more_other

; 4230 :                    { char buf[4];
; 4231 :                      int i;
; 4232 :                      for ( i = 0 ; i < 4 ; i++ )
; 4233 :                        buf[i] = ((char*)&x)[4-i];

	movzx	eax, BYTE PTR _x$92436[ebp+4]
	movzx	ecx, BYTE PTR _x$92436[ebp+3]
	mov	BYTE PTR _buf$92439[ebp], al
	movzx	eax, BYTE PTR _x$92436[ebp+2]
	mov	BYTE PTR _buf$92439[ebp+1], cl
	movzx	ecx, BYTE PTR _x$92436[ebp+1]
	mov	BYTE PTR _buf$92439[ebp+2], al

; 4234 :                      fwrite(buf,4,1,outfd);

	mov	eax, DWORD PTR _outfd
	push	eax
	push	edx
	mov	BYTE PTR _buf$92439[ebp+3], cl
	lea	ecx, DWORD PTR _buf$92439[ebp]
	push	4
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 4235 :                    }
; 4236 :                    else 

	jmp	SHORT $LN340@more_other
$LN312@more_other:

; 4237 :                      fwrite(&x,4,1,outfd);

	mov	eax, DWORD PTR _outfd
	push	eax
	push	edx
	lea	ecx, DWORD PTR _x$92436[ebp]
	push	4
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 4238 :                  }
; 4239 :                  break;

	jmp	SHORT $LN340@more_other
$LN307@more_other:

; 4240 : 
; 4241 : 
; 4242 :                default: 
; 4243 :                  sprintf(errmsg,"binary_printf format string has unrecognized format character '%c'\n",f[-1]);

	push	eax
	push	OFFSET ??_C@_0EE@BIPFCNNO@binary_printf?5format?5string?5has?5@
	push	OFFSET _errmsg
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN340@more_other:

; 4144 :           
; 4145 :           while ( *sp )

	mov	edx, DWORD PTR _sp$92378[ebp]
	cmp	BYTE PTR [edx], 0
	jne	$LL347@more_other
$LN346@more_other:

; 4244 :                  break;  /* unrecognized */
; 4245 :              }
; 4246 :           }
; 4247 :           if ( formatcount > n )

	mov	eax, DWORD PTR _formatcount$92364[ebp]
	mov	esi, DWORD PTR _n$[ebp]
	cmp	eax, esi
	jle	SHORT $LN306@more_other

; 4248 :           { sprintf(errmsg,
; 4249 :             "Format string has %d formats, but there are only %d arguments.\n",
; 4250 :               formatcount,n);

	push	esi
	push	eax
	push	OFFSET ??_C@_0EA@GNCLKEFD@Format?5string?5has?5?$CFd?5formats?0?5bu@
	push	OFFSET _errmsg
	call	_sprintf

; 4251 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4252 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL1278@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1278@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 4253 :             kb_error(4023,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4023					; 00000fb7H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN306@more_other:

; 4254 :           }
; 4255 :          stacktop -= n; /* pop args */

	mov	eax, DWORD PTR _td$[ebp]
	neg	esi
	add	esi, esi
	add	esi, esi
	add	esi, esi
	add	DWORD PTR [eax+48], esi

; 4256 :        }
; 4257 :        if ( node[node->left].op1.string == NULL ) stacktop--;

	mov	edx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [eax+48]
	imul	edx, 168				; 000000a8H
	cmp	DWORD PTR [edx+ebx+32], 0
	jne	SHORT $LN305@more_other
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR [eax+48], ecx
$LN305@more_other:

; 4258 : #ifdef WIN32
; 4259 :        fflush(outfd);

	mov	eax, DWORD PTR _outfd
	push	eax
	call	_fflush

; 4260 :        _setmode(_fileno(outfd),_O_TEXT);

	mov	ecx, DWORD PTR _outfd
	add	esp, 4
	push	16384					; 00004000H
	push	ecx
	call	__fileno
	add	esp, 4
	push	eax
	call	__setmode
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN304@more_other:

; 4261 : #endif
; 4262 :       }
; 4263 :      break;
; 4264 : 
; 4265 :     case PRINT_NODE: /* verb */
; 4266 :           if ( node[node->left].datatype == STRING_TYPE )

	mov	edx, DWORD PTR [ebx+4]

; 4267 :           { char *s = *(char**)(stacktop--);

	mov	eax, DWORD PTR [esi+48]
	imul	edx, 168				; 000000a8H
	cmp	DWORD PTR [edx+ebx+20], 11		; 0000000bH
	jne	SHORT $LN303@more_other
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H

; 4268 :             sprintf(msg,"%s\n",s);

	push	ecx
	mov	DWORD PTR [esi+48], eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 4269 :           }
; 4270 :           else

	jmp	SHORT $LN302@more_other
$LN303@more_other:

; 4271 :           {
; 4272 : #ifdef FLOAT128
; 4273 :             sprintf(msg,"%*.*Qg\n",DWIDTH,DPREC,*(stacktop--));
; 4274 : #elif defined(LONGDOUBLE)
; 4275 :             sprintf(msg,"%*.*Lg\n",DWIDTH,DPREC,*(stacktop--));
; 4276 : #else
; 4277 :             sprintf(msg,"%20.15g\n",*(stacktop--));

	fld	QWORD PTR [eax]
	sub	esp, 8
	add	eax, -8					; fffffff8H
	fstp	QWORD PTR [esp]
	mov	DWORD PTR [esi+48], eax
	mov	ecx, DWORD PTR _msg
	push	OFFSET ??_C@_08GPHOBFCD@?$CF20?415g?6?$AA@
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN302@more_other:

; 4278 : #endif 
; 4279 :           }
; 4280 :           oldquiet = quiet_flag; quiet_flag = 0;
; 4281 :           outstring(msg);

	mov	edx, DWORD PTR _msg
	mov	esi, DWORD PTR _quiet_flag
	push	edx
	mov	DWORD PTR _quiet_flag, 0
	call	_outstring
	add	esp, 4
	pop	edi

; 4282 :           quiet_flag = oldquiet;

	mov	DWORD PTR _quiet_flag, esi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN301@more_other:

; 4283 :           break;
; 4284 : 
; 4285 :     case STRPRINT_NODE: /* verb */
; 4286 :           oldquiet = quiet_flag; quiet_flag = 0;

	mov	edi, DWORD PTR _quiet_flag
	mov	DWORD PTR _quiet_flag, 0

; 4287 :           s = *(char**)(stacktop--);

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H

; 4288 :           outstring(s);

	push	ecx
	mov	DWORD PTR _s$[ebp], ecx
	mov	DWORD PTR [esi+48], eax
	call	_outstring

; 4289 :           outstring("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_outstring

; 4290 :           quiet_flag = oldquiet;   

	mov	DWORD PTR _quiet_flag, edi

; 4291 :           if ( node->left && (node[node->left].flags & DEALLOCATE_POINTER) )

	mov	eax, DWORD PTR [ebx+4]
	add	esp, 8
	test	eax, eax
	je	$LN626@more_other
	imul	eax, 168				; 000000a8H
	test	DWORD PTR [eax+ebx+24], 1024		; 00000400H
	je	$LN626@more_other

; 4292 :             myfree(s);

	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	call	_myfree
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN299@more_other:

; 4293 :           break;
; 4294 : 
; 4295 :     case PRINT_LETTER_NODE:
; 4296 :          oldquiet = quiet_flag; quiet_flag = 0;

	mov	esi, DWORD PTR _quiet_flag
	mov	DWORD PTR _quiet_flag, 0

; 4297 :          if ( single_redefine[node->op1.letter].start )

	mov	ebx, DWORD PTR [ebx+32]
	mov	ecx, ebx
	imul	ecx, 104				; 00000068H
	cmp	DWORD PTR _single_redefine[ecx], 0
	lea	eax, DWORD PTR _single_redefine[ecx]
	je	SHORT $LN298@more_other

; 4298 :             outstring(print_express(&single_redefine[node->op1.name_id],'X'));

	push	88					; 00000058H
	push	eax
	call	_print_express
	push	eax
	call	_outstring
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN297@more_other
$LN298@more_other:

; 4299 :          else { sprintf(msg,"%c",node->op1.letter); outstring(msg);}

	mov	edx, DWORD PTR _msg
	push	ebx
	push	OFFSET ??_C@_02HAOIJKIC@?$CFc?$AA@
	push	edx
	call	_sprintf
	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
$LN297@more_other:

; 4300 :          outstring("\n\n");

	push	OFFSET ??_C@_02PHMGELLB@?6?6?$AA@
	call	_outstring
	add	esp, 4
	pop	edi

; 4301 :          quiet_flag = oldquiet;   

	mov	DWORD PTR _quiet_flag, esi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN296@more_other:

; 4302 :          break;
; 4303 : 
; 4304 :     case PRINT_PROCEDURE_NODE:
; 4305 :          oldquiet = quiet_flag; quiet_flag = 0;

	mov	esi, DWORD PTR _quiet_flag
	mov	DWORD PTR _quiet_flag, 0

; 4306 :          outstring(print_express(&globals(node->op1.name_id)->value.proc,'X'));

	mov	ebx, DWORD PTR [ebx+32]
	mov	eax, ebx
	and	eax, -16777216				; ff000000H
	and	ebx, 16777215				; 00ffffffH
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN882@more_other
	mov	ecx, DWORD PTR _web+5652
	mov	eax, DWORD PTR _dymem
	lea	edx, DWORD PTR [ecx+ebx*4]
	mov	ebx, DWORD PTR [edx+eax]
	jmp	SHORT $LN879@more_other
$LN882@more_other:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN880@more_other
	imul	ebx, 224				; 000000e0H
	add	ebx, DWORD PTR [edi]
	jmp	SHORT $LN879@more_other
$LN880@more_other:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN878@more_other
	mov	ecx, DWORD PTR _web+5656
	mov	ebx, DWORD PTR [ecx+ebx*4]
	jmp	SHORT $LN879@more_other
$LN878@more_other:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+ebx*4]
	mov	ebx, DWORD PTR [eax+ecx]
$LN879@more_other:
	push	88					; 00000058H
	add	ebx, 64					; 00000040H
	push	ebx
$LN1428@more_other:
	call	_print_express
	push	eax
	call	_outstring

; 4307 :          outstring("\n\n");

	push	OFFSET ??_C@_02PHMGELLB@?6?6?$AA@
	call	_outstring
	add	esp, 16					; 00000010H
$LN1429@more_other:

; 4308 :          quiet_flag = oldquiet;   

	pop	edi
	mov	DWORD PTR _quiet_flag, esi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN295@more_other:

; 4309 :          break;
; 4310 : 
; 4311 :     case PRINT_PERM_PROCEDURE_NODE:
; 4312 :          oldquiet = quiet_flag; quiet_flag = 0;

	mov	esi, DWORD PTR _quiet_flag

; 4313 :          outstring(print_express(&perm_globals(node->op1.name_id)->value.proc,'X'));

	mov	eax, DWORD PTR _web+5656
	mov	DWORD PTR _quiet_flag, 0
	mov	edx, DWORD PTR [ebx+32]
	and	edx, 16777215				; 00ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	push	88					; 00000058H
	add	ecx, 64					; 00000040H
	push	ecx

; 4314 :          outstring("\n\n");
; 4315 :          quiet_flag = oldquiet;   
; 4316 :          break;

	jmp	SHORT $LN1428@more_other
$LN294@more_other:

; 4317 : 
; 4318 :     case EXPRINT_PROCEDURE_NODE:
; 4319 :          oldquiet = quiet_flag; quiet_flag = 0;

	mov	esi, DWORD PTR _quiet_flag
	mov	DWORD PTR _quiet_flag, 0

; 4320 :          outstring(globals(node->op1.name_id)->attr.procstuff.proc_text);

	mov	ebx, DWORD PTR [ebx+32]
	mov	eax, ebx
	and	eax, -16777216				; ff000000H
	and	ebx, 16777215				; 00ffffffH
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN888@more_other
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+ebx*4]
	mov	ebx, DWORD PTR [eax+ecx]
	jmp	SHORT $LN885@more_other
$LN888@more_other:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN886@more_other
	imul	ebx, 224				; 000000e0H
	add	ebx, DWORD PTR [edi]
	jmp	SHORT $LN885@more_other
$LN886@more_other:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN884@more_other
	mov	edx, DWORD PTR _web+5656
	mov	ebx, DWORD PTR [edx+ebx*4]
	jmp	SHORT $LN885@more_other
$LN884@more_other:
	mov	eax, DWORD PTR _web+5652
	mov	edx, DWORD PTR _dymem
	lea	ecx, DWORD PTR [eax+ebx*4]
	mov	ebx, DWORD PTR [ecx+edx]
$LN885@more_other:
	mov	eax, DWORD PTR [ebx+180]
	push	eax
	call	_outstring

; 4321 :          outstring("\n\n");

	push	OFFSET ??_C@_02PHMGELLB@?6?6?$AA@
	call	_outstring
	add	esp, 8

; 4322 :          quiet_flag = oldquiet;   
; 4323 :          break;

	jmp	$LN1429@more_other
$LN293@more_other:

; 4324 : 
; 4325 :     case EPRINT_NODE: /* print and pass on value inside expression */
; 4326 : #ifdef FLOAT128
; 4327 :           sprintf(msg,"%*.*Qg\n",DWIDTH,DPREC,*stacktop);
; 4328 : #elif defined(LONGDOUBLE)
; 4329 :           sprintf(msg,"%*.*Lg\n",DWIDTH,DPREC,*stacktop);
; 4330 : #else
; 4331 :           sprintf(msg,"%20.15g\n",*stacktop);

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx]
	mov	edx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_08GPHOBFCD@?$CF20?415g?6?$AA@
	push	edx
	call	_sprintf

; 4332 : #endif 
; 4333 :           oldquiet = quiet_flag; quiet_flag = 0;
; 4334 :           outstring(msg);

	mov	eax, DWORD PTR _msg
	mov	esi, DWORD PTR _quiet_flag
	push	eax
	mov	DWORD PTR _quiet_flag, 0
	call	_outstring
	add	esp, 20					; 00000014H

; 4335 :           quiet_flag = oldquiet;   
; 4336 :           break;

	jmp	$LN1429@more_other
$LN292@more_other:

; 4337 : 
; 4338 :     case SHOWQ_NODE:
; 4339 :          go_display_flag = 1;

	mov	DWORD PTR _go_display_flag, 1

; 4340 :          display();

	call	_display
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN291@more_other:

; 4341 :          break;
; 4342 : 
; 4343 :     case SET_THICKEN_NODE:
; 4344 :       thickness = *(stacktop--);

	mov	eax, DWORD PTR [esi+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	pop	edi
	fstp	QWORD PTR _thickness
	mov	DWORD PTR [esi+48], eax
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN290@more_other:

; 4345 :       break;
; 4346 : 
; 4347 :     case JIGGLE_NODE:
; 4348 :       web.temperature = *(stacktop--);

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx]
	fstp	QWORD PTR _web+1576
	add	DWORD PTR [esi+48], -8			; fffffff8H

; 4349 :       jiggle();

	call	_jiggle

; 4350 :       recalc();
; 4351 :       break;

	jmp	$LN1427@more_other
$LN289@more_other:

; 4352 :     
; 4353 :     case QUIT_NODE:
; 4354 :       exit((int)floor(*stacktop));

	mov	edx, DWORD PTR [esi+48]
	fld	QWORD PTR [edx]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	push	eax
	call	_exit
$LN1446@more_other:
$LN288@more_other:

; 4355 :       break;
; 4356 : 
; 4357 :     case NOTCH_NODE:
; 4358 :       if ( web.representation == SIMPLEX )

	cmp	DWORD PTR _web+624, 3
	jne	SHORT $LN287@more_other

; 4359 :       { sprintf(errmsg,"Notching not implemented for simplex representation.\n");

	push	OFFSET ??_C@_0DG@KANBCPFA@Notching?5not?5implemented?5for?5sim@
	push	OFFSET _errmsg
	call	_sprintf

; 4360 :         sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4361 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL1279@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1279@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 4362 :         kb_error(1224,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1224					; 000004c8H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN287@more_other:

; 4363 :       }
; 4364 :       web.max_angle = *(stacktop--);

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx]
	fstp	QWORD PTR _web+1568
	add	DWORD PTR [esi+48], -8			; fffffff8H

; 4365 :       if ( web.max_angle <= 0.0 )

	fldz
	fld	QWORD PTR _web+1568
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jp	SHORT $LN286@more_other

; 4366 :       {  sprintf(errmsg,"Notching angle not positive.\n");

	push	OFFSET ??_C@_0BO@FEKICMHJ@Notching?5angle?5not?5positive?4?6?$AA@
	fstp	ST(0)
	push	OFFSET _errmsg
	call	_sprintf

; 4367 :          sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4368 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL1280@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1280@more_other
	mov	ecx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4369 :          kb_error(1225,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1225					; 000004c9H
	call	_kb_error
	fld	QWORD PTR _web+1568
	add	esp, 28					; 0000001cH
$LN286@more_other:

; 4370 :       }
; 4371 :       if ( web.representation == STRING )
; 4372 :         { sprintf(msg,"refine edge ee where max(ee.vertex,dihedral) > %f",
; 4373 :               (DOUBLE)web.max_angle);

	sub	esp, 8
	cmp	DWORD PTR _web+624, 1
	fstp	QWORD PTR [esp]
	jne	SHORT $LN285@more_other
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0DC@JKPEEAKK@refine?5edge?5ee?5where?5max?$CIee?4vert@
	push	eax
	call	_sprintf

; 4374 :           command(msg,NO_HISTORY);

	mov	ecx, DWORD PTR _msg
	push	0
	push	ecx
	call	_command

; 4375 :           web.notch_count = web.edge_refine_count;

	mov	edx, DWORD PTR _web+5444
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	mov	DWORD PTR _web+5516, edx
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN285@more_other:

; 4376 :         }
; 4377 :       else 
; 4378 :         { web.notch_count = ridge_notcher(web.max_angle);

	call	_ridge_notcher

; 4379 :           sprintf(msg,"Number of edges notched: %d\n",web.notch_count);

	push	eax
	mov	DWORD PTR _web+5516, eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0BN@KADAPAAJ@Number?5of?5edges?5notched?3?5?$CFd?6?$AA@
	push	eax
	call	_sprintf

; 4380 :           outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 24					; 00000018H

; 4381 :           recalc();
; 4382 :         }
; 4383 :       break;

	jmp	$LN1427@more_other
$LN283@more_other:

; 4384 : 
; 4385 :     case SET_AUTOCHOP_NODE:
; 4386 :       autochop_length = *(stacktop--);

	mov	eax, DWORD PTR [esi+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	pop	edi
	fstp	QWORD PTR _autochop_length
	mov	DWORD PTR [esi+48], eax
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN282@more_other:

; 4387 :       break;
; 4388 : 
; 4389 :     case SET_AMBIENT_PRESSURE_NODE:
; 4390 :       web.pressure = *(stacktop--);

	mov	edx, DWORD PTR [esi+48]
	fld	QWORD PTR [edx]
	fstp	QWORD PTR _web+1536
	add	DWORD PTR [esi+48], -8			; fffffff8H

; 4391 :       if ( web.pressure > 0.00000001 )

	fld	QWORD PTR __real@3e45798ee2308c3a
	fcomp	QWORD PTR _web+1536
	fnstsw	ax
	test	ah, 5
	jp	$LN281@more_other

; 4392 :          {  body_id b_id;
; 4393 :             if ( !web.full_flag && !valid_id(web.outside_body) )

	cmp	DWORD PTR _web+864, 0
	jne	SHORT $LN1258@more_other
	test	DWORD PTR _web+1504, 268435456		; 10000000H
	jne	SHORT $LN1258@more_other

; 4394 :                               add_outside();

	call	_add_outside
$LN1258@more_other:

; 4395 :             web.projection_flag = 0;
; 4396 :             web.pressure_flag = 1;
; 4397 :             if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	mov	DWORD PTR _web+872, 0
	mov	DWORD PTR _web+868, 1
	je	$LN1427@more_other

; 4398 :             { FOR_ALL_BODIES(b_id) 

	mov	ecx, DWORD PTR _web+384
	test	ecx, 268435456				; 10000000H
	je	$LN1427@more_other
	mov	edi, DWORD PTR _web+348
	npad	4
$LL1281@more_other:
	mov	esi, ecx
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+edi]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN277@more_other

; 4399 :                 create_pressure_quant(b_id);

	push	ecx
	call	_create_pressure_quant
	mov	edi, DWORD PTR _web+348
	add	esp, 4
$LN277@more_other:

; 4398 :             { FOR_ALL_BODIES(b_id) 

	mov	eax, DWORD PTR [esi+edi]
	mov	ecx, DWORD PTR [eax]
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LL1281@more_other

; 4400 :             }
; 4401 :          }
; 4402 :       else

	jmp	$LN1427@more_other
$LN281@more_other:

; 4403 :          {
; 4404 :             web.projection_flag = 1;

	mov	DWORD PTR _web+872, 1

; 4405 :             web.pressure_flag = 0;

	mov	DWORD PTR _web+868, 0

; 4406 :          }
; 4407 :       recalc();
; 4408 :       break;

	jmp	$LN1427@more_other
$LN272@more_other:

; 4409 : 
; 4410 :     case SET_DIFFUSION_NODE:
; 4411 :          old = web.diffusion_flag;
; 4412 :          web.diffusion_const = *(stacktop--);

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx]
	mov	edi, DWORD PTR _web+780
	fstp	QWORD PTR _web+784
	add	DWORD PTR [esi+48], -8			; fffffff8H

; 4413 :          web.diffusion_flag = 1;
; 4414 :          outstring(web.diffusion_flag ? "Diffusion ON." :
; 4415 :                                             "Diffusion OFF.");

	push	OFFSET ??_C@_0O@KKGGCNAE@Diffusion?5ON?4?$AA@
	mov	DWORD PTR _web+780, 1
	call	_outstring
	add	esp, 4

; 4416 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	edi, edi
	jne	SHORT $LN893@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN893@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN271@more_other:

; 4417 :          break;
; 4418 : 
; 4419 :     case AREAWEED_NODE:
; 4420 :          sprintf(msg,"Skinny triangles weeded: %d\n",
; 4421 :               web.facet_delete_count = areaweed(*(stacktop--)));

	mov	eax, DWORD PTR [esi+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR [esi+48], eax
	call	_areaweed
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BN@ENNEDDMF@Skinny?5triangles?5weeded?3?5?$CFd?6?$AA@
	push	edx
	mov	DWORD PTR _web+5440, eax
	call	_sprintf

; 4422 :          outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 24					; 00000018H

; 4423 :          energy_init = 0;

	mov	DWORD PTR _energy_init, 0

; 4424 :          recalc();
; 4425 :          break;

	jmp	$LN1427@more_other
$LN270@more_other:

; 4426 : 
; 4427 :     case METIS_NODE:
; 4428 :     case KMETIS_NODE:
; 4429 : /*
; 4430 :          metis_partition_dual((int)(*(stacktop--)),node->type);
; 4431 : */
; 4432 :          metis_partition_plain((int)(*(stacktop--)),node->type);

	mov	edi, DWORD PTR [esi+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	add	edi, -8					; fffffff8H
	mov	DWORD PTR [esi+48], edi
	mov	ecx, DWORD PTR [ebx]
	push	ecx
	push	eax
	call	_metis_partition_plain
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN269@more_other:

; 4433 :          break;
; 4434 : 
; 4435 :     case METIS_READJUST_NODE:
; 4436 :          metis_partition_dual((int)(*(stacktop--)),METIS_READJUST);

	mov	edi, DWORD PTR [esi+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	push	23					; 00000017H
	add	edi, -8					; fffffff8H
	push	eax
	mov	DWORD PTR [esi+48], edi
	call	_metis_partition_dual
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN268@more_other:

; 4437 : /*
; 4438 :          metis_partition_plain((int)(*(stacktop--)),METIS_READJUST);
; 4439 : */
; 4440 :          break;
; 4441 : 
; 4442 :     case BODY_METIS_NODE:
; 4443 :          metis_partition_body((int)(*(stacktop--)),METIS_MODE);

	mov	edi, DWORD PTR [esi+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	push	15002					; 00003a9aH
	add	edi, -8					; fffffff8H
	push	eax
	mov	DWORD PTR [esi+48], edi
	call	_metis_partition_body
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN267@more_other:

; 4444 :          break;
; 4445 : 
; 4446 :     case OMETIS_NODE:
; 4447 :          if ( node->left )

	cmp	DWORD PTR [ebx+4], 0
	je	SHORT $LN266@more_other

; 4448 :             metis_vertex_order((int)(*(stacktop--)));

	mov	edi, DWORD PTR [esi+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	add	edi, -8					; fffffff8H
	push	eax
	mov	DWORD PTR [esi+48], edi
	call	_metis_vertex_order
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN266@more_other:

; 4449 :          else metis_vertex_order(100);

	push	100					; 00000064H
	call	_metis_vertex_order
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN264@more_other:

; 4450 :          break;
; 4451 : 
; 4452 :     case EDGEWEED_NODE:
; 4453 :          sprintf(msg,"Deleted edges: %d\n",
; 4454 :               web.edge_delete_count = edgeweed(*(stacktop--)));

	mov	eax, DWORD PTR [esi+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR [esi+48], eax
	call	_edgeweed
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BD@LHJNONFJ@Deleted?5edges?3?5?$CFd?6?$AA@
	push	edx
	mov	DWORD PTR _web+5436, eax
	call	_sprintf

; 4455 :          outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 24					; 00000018H

; 4456 :          recalc();
; 4457 :          break;

	jmp	$LN1427@more_other
$LN263@more_other:

; 4458 : 
; 4459 :     case OPTIMIZE_NODE:
; 4460 :          web.motion_flag = (node->op1.toggle_state==ON_) ? 0 : 1;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	setne	al

; 4461 :          if ( web.motion_flag )
; 4462 :             sprintf(msg,"Scale fixed at %g.\n",(DOUBLE)web.scale);

	sub	esp, 8
	mov	DWORD PTR _web+852, eax
	test	eax, eax
	je	SHORT $LN262@more_other
	fld	QWORD PTR _web+1512
	mov	ecx, DWORD PTR _msg
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BE@KHLJFDIK@Scale?5fixed?5at?5?$CFg?4?6?$AA@
	push	ecx
	jmp	SHORT $LN1410@more_other
$LN262@more_other:

; 4463 :          else sprintf(msg,"Scale optimizing with bound %g.\n",(DOUBLE)web.maxscale);

	fld	QWORD PTR _web+1528
	mov	edx, DWORD PTR _msg
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CB@HABEDKHM@Scale?5optimizing?5with?5bound?5?$CFg?4?6@
	push	edx
$LN1410@more_other:
	call	_sprintf

; 4464 :          outstring(msg);

	mov	eax, DWORD PTR _msg
	add	esp, 16					; 00000010H
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN260@more_other:

; 4465 :          break;
; 4466 : 
; 4467 :     case SET_OPTIMIZE_NODE:
; 4468 :          web.maxscale = *(stacktop--);

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx]
	fstp	QWORD PTR _web+1528
	add	DWORD PTR [esi+48], -8			; fffffff8H

; 4469 :          web.motion_flag = 0;
; 4470 :          sprintf(msg,"Scale optimizing with bound %g.\n",(DOUBLE)web.maxscale);

	fld	QWORD PTR _web+1528
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR _web+852, 0
	push	OFFSET ??_C@_0CB@HABEDKHM@Scale?5optimizing?5with?5bound?5?$CFg?4?6@
$LN1430@more_other:
	mov	edx, DWORD PTR _msg
	push	edx
	call	_sprintf

; 4471 :          outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN259@more_other:

; 4472 :          break;
; 4473 : 
; 4474 :     case SET_SCALE_NODE:
; 4475 :          web.scale = *(stacktop--);

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx]
	fstp	QWORD PTR _web+1512
	add	DWORD PTR [esi+48], -8			; fffffff8H

; 4476 :          web.motion_flag = 1;
; 4477 :          sprintf(msg,"Scale fixed at %g.\n",(DOUBLE)web.scale);

	fld	QWORD PTR _web+1512
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR _web+852, 1
	push	OFFSET ??_C@_0BE@KHLJFDIK@Scale?5fixed?5at?5?$CFg?4?6?$AA@

; 4478 :          outstring(msg);
; 4479 :          break;

	jmp	SHORT $LN1430@more_other
$LN258@more_other:

; 4480 : 
; 4481 :     case SET_GRAVITY_NODE:
; 4482 :          switch ( node->op1.assigntype )

	mov	eax, DWORD PTR [ebx+32]
	add	eax, -30001				; ffff8acfH
	cmp	eax, 4
	ja	SHORT $LN256@more_other
	jmp	DWORD PTR $LN1437@more_other[eax*4]
$LN255@more_other:

; 4483 :          { case ASSIGN_OP: web.grav_const = *(stacktop--); break;

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx]
	jmp	SHORT $LN1411@more_other
$LN254@more_other:

; 4484 :            case PLUSASSIGN_OP: web.grav_const += *(stacktop--); break;

	mov	edx, DWORD PTR [esi+48]
	fld	QWORD PTR [edx]
	fadd	QWORD PTR _web+832
	jmp	SHORT $LN1411@more_other
$LN253@more_other:

; 4485 :            case SUBASSIGN_OP: web.grav_const -= *(stacktop--); break;

	mov	eax, DWORD PTR [esi+48]
	fld	QWORD PTR _web+832
	fsub	QWORD PTR [eax]
	jmp	SHORT $LN1411@more_other
$LN252@more_other:

; 4486 :            case MULTASSIGN_OP: web.grav_const *= *(stacktop--); break;

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx]
	fmul	QWORD PTR _web+832
	jmp	SHORT $LN1411@more_other
$LN251@more_other:

; 4487 :            case DIVASSIGN_OP: web.grav_const /= *(stacktop--); break;

	mov	edx, DWORD PTR [esi+48]
	fld	QWORD PTR _web+832
	fdiv	QWORD PTR [edx]
$LN1411@more_other:
	fstp	QWORD PTR _web+832
	add	DWORD PTR [esi+48], -8			; fffffff8H
$LN256@more_other:

; 4488 :          }
; 4489 :          old = web.gravflag;
; 4490 :          if ( web.grav_const != 0.0 )

	fld	QWORD PTR _web+832
	mov	esi, DWORD PTR _web+824
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN1327@more_other

; 4491 :          { web.gravflag = 1;
; 4492 :            sprintf(msg,"Gravity is now ON with gravitational constant %g.",
; 4493 :               (DOUBLE)web.grav_const);

	mov	eax, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0DC@FCBICJJI@Gravity?5is?5now?5ON?5with?5gravitati@
	push	eax
	mov	DWORD PTR _web+824, 1
	call	_sprintf
	add	esp, 16					; 00000010H

; 4494 :          }
; 4495 :          else

	jmp	SHORT $LN249@more_other
$LN1327@more_other:

; 4496 :          { web.gravflag = 0;
; 4497 :            sprintf(msg,"Gravity is now OFF.");

	mov	ecx, DWORD PTR _msg
	fstp	ST(0)
	push	OFFSET ??_C@_0BE@EJALKLLC@Gravity?5is?5now?5OFF?4?$AA@
	push	ecx
	mov	DWORD PTR _web+824, 0
	call	_sprintf
	add	esp, 8
$LN249@more_other:

; 4498 :          }
; 4499 :          if (gravity_quantity_num >= 0 )

	mov	eax, DWORD PTR _gravity_quantity_num
	test	eax, eax
	js	SHORT $LN248@more_other

; 4500 :            GEN_QUANT(gravity_quantity_num)->modulus =
; 4501 :                               web.gravflag ? web.grav_const : 0.0;

	cmp	DWORD PTR _web+824, 0
	je	SHORT $LN894@more_other
	fld	QWORD PTR _web+832
	jmp	SHORT $LN895@more_other
$LN894@more_other:
	fldz
$LN895@more_other:
	mov	edx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H
	fstp	QWORD PTR [eax+edx+176]
$LN248@more_other:

; 4502 :          outstring(msg);

	mov	eax, DWORD PTR _msg

; 4503 :          outstring(old?" (was on)\n":" (was off)\n");
; 4504 :          recalc();
; 4505 :          break;

	jmp	$LN655@more_other
$LN247@more_other:

; 4506 : 
; 4507 :     case SET_MODEL_NODE:
; 4508 :          switch ( (int)*(stacktop--) )

	mov	edi, DWORD PTR [esi+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	dec	eax
	lea	ecx, DWORD PTR [edi-8]
	mov	DWORD PTR [esi+48], ecx
	je	$LN244@more_other
	dec	eax
	je	$LN239@more_other

; 4532 :             default: 
; 4533 :                  if ( stacktop[1] > 2. )

	fld	QWORD PTR __real@4000000000000000
	fcomp	QWORD PTR [ecx+8]
	fnstsw	ax
	test	ah, 5
	jp	$LN233@more_other

; 4534 :                  { if ( web.modeltype == LINEAR )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 1
	jne	SHORT $LN232@more_other

; 4535 :                    { outstring("Changing to LAGRANGE model. (was LINEAR)\n");

	push	OFFSET ??_C@_0CK@JBOLHCFI@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@
	call	_outstring

; 4536 :                      linear_to_lagrange((int)stacktop[1]); 

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx+8]
	call	__ftol2_sse
	push	eax
	call	_linear_to_lagrange
	add	esp, 8
	jmp	$LN1427@more_other
$LN232@more_other:

; 4537 :                    }
; 4538 :                    else if ( web.modeltype == QUADRATIC )

	cmp	eax, 2
	jne	SHORT $LN230@more_other

; 4539 :                    { outstring("Changing to LAGRANGE model. (was QUADRATIC)\n");

	push	OFFSET ??_C@_0CN@NAGKEEOG@Changing?5to?5LAGRANGE?5model?4?5?$CIwas@
	call	_outstring

; 4540 :                      quad_to_lagrange((int)stacktop[1]); 

	mov	edx, DWORD PTR [esi+48]
	fld	QWORD PTR [edx+8]
	call	__ftol2_sse
	push	eax
	call	_quad_to_lagrange
	add	esp, 8

; 4541 :                    }
; 4542 :                    else 

	jmp	$LN1427@more_other
$LN230@more_other:

; 4543 :                    { sprintf(msg,
; 4544 :                        "Changing to LAGRANGE %d model. (was LAGRANGE %d)\n",
; 4545 :                            (int)stacktop[1],web.lagrange_order);

	mov	eax, DWORD PTR _web+632
	fld	QWORD PTR [ecx+8]
	push	eax
	call	__ftol2_sse
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0DC@KLMKCJCH@Changing?5to?5LAGRANGE?5?$CFd?5model?4?5?$CI@
	push	ecx
	call	_sprintf

; 4546 :                      outstring(msg); 

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 4547 :                      lagrange_to_lagrange((int)stacktop[1]); 

	mov	eax, DWORD PTR [esi+48]
	fld	QWORD PTR [eax+8]
	call	__ftol2_sse
	push	eax
	call	_lagrange_to_lagrange
	add	esp, 24					; 00000018H

; 4548 :                    }
; 4549 :                  }
; 4550 :                  else

	jmp	$LN1427@more_other
$LN233@more_other:

; 4551 :             {  sprintf(errmsg,
; 4552 :         "Bad model choice. Legal: 1 (linear), 2 (quadratic), > 2 (Lagrange)\n");

	push	OFFSET ??_C@_0EE@FNJALPPL@Bad?5model?5choice?4?5Legal?3?51?5?$CIline@
	push	OFFSET _errmsg
	call	_sprintf

; 4553 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4554 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1282@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1282@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 4555 :             kb_error(1230,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1230					; 000004ceH
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	$LN1427@more_other
$LN239@more_other:

; 4520 :                  break;
; 4521 :             case QUADRATIC: 
; 4522 :                 if ( web.modeltype == LINEAR )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 1
	jne	SHORT $LN238@more_other

; 4523 :                  { outstring("Changing to QUADRATIC model. (was LINEAR)\n");

	push	OFFSET ??_C@_0CL@IKOBFHOD@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@
	call	_outstring
	add	esp, 4

; 4524 :                    linear_to_quad();  

	call	_linear_to_quad
	jmp	$LN1427@more_other
$LN238@more_other:

; 4525 :                 }
; 4526 :                 else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	SHORT $LN236@more_other

; 4527 :                 { outstring("Changing to QUADRATIC model. (was LAGRANGE)\n");

	push	OFFSET ??_C@_0CN@BFEEPGEG@Changing?5to?5QUADRATIC?5model?4?5?$CIwa@
	call	_outstring
	add	esp, 4

; 4528 :                     lagrange_to_quad(); 

	call	_lagrange_to_quad
	jmp	$LN1427@more_other
$LN236@more_other:

; 4529 :                 }
; 4530 :                 else outstring("Model already QUADRATIC.\n");

	push	OFFSET ??_C@_0BK@PABEINCB@Model?5already?5QUADRATIC?4?6?$AA@

; 4531 :                  break;

	jmp	$LN1412@more_other
$LN244@more_other:

; 4509 :          { 
; 4510 :             case LINEAR: 
; 4511 :                 if ( web.modeltype == QUADRATIC )

	mov	eax, DWORD PTR _web+628
	cmp	eax, 2
	jne	SHORT $LN243@more_other

; 4512 :                 { outstring("Changing to LINEAR model. (was QUADRATIC)\n");

	push	OFFSET ??_C@_0CL@FEBBPANL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5Q@
	call	_outstring
	add	esp, 4

; 4513 :                   quad_to_linear(); 

	call	_quad_to_linear
	jmp	$LN1427@more_other
$LN243@more_other:

; 4514 :                 }
; 4515 :                 else if ( web.modeltype == LAGRANGE )

	cmp	eax, 3
	jne	SHORT $LN241@more_other

; 4516 :                  { outstring("Changing to LINEAR model. (was LAGRANGE)\n");

	push	OFFSET ??_C@_0CK@JMIEKNGL@Changing?5to?5LINEAR?5model?4?5?$CIwas?5L@
	call	_outstring
	add	esp, 4

; 4517 :                    lagrange_to_linear(); 

	call	_lagrange_to_linear
	jmp	$LN1427@more_other
$LN241@more_other:

; 4518 :                  }
; 4519 :                  else outstring("Model already LINEAR.\n");

	push	OFFSET ??_C@_0BH@FJOMOHLK@Model?5already?5LINEAR?4?6?$AA@

; 4556 :            }
; 4557 :          }
; 4558 :          recalc();
; 4559 :          break;

	jmp	$LN1412@more_other
$LN227@more_other:

; 4560 : 
; 4561 :     case INVOKE_P_MENU_NODE:
; 4562 :          display_file((int)*(stacktop--));

	mov	edi, DWORD PTR [esi+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	add	edi, -8					; fffffff8H
	push	eax
	mov	DWORD PTR [esi+48], edi
	call	_display_file
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN226@more_other:

; 4563 :          break;
; 4564 : 
; 4565 :     case EDGEDIVIDE_NODE:
; 4566 :          sprintf(msg,"New edges: %d\n",
; 4567 :              web.edge_refine_count = articulate(*(stacktop--)));

	mov	eax, DWORD PTR [esi+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR [esi+48], eax
	call	_articulate
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0P@BKJHBGLB@New?5edges?3?5?$CFd?6?$AA@
	push	ecx
	mov	DWORD PTR _web+5444, eax
	call	_sprintf

; 4568 :          outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 24					; 00000018H

; 4569 :          recalc();
; 4570 :             break;

	jmp	$LN1427@more_other
$LN225@more_other:

; 4571 : 
; 4572 :     case SET_SGLOBAL_NODE:
; 4573 :        { struct global *g = globals(node->op1.name_id);

	mov	eax, DWORD PTR [ebx+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	and	eax, 16777215				; 00ffffffH
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN902@more_other
	mov	ecx, DWORD PTR _web+5652
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	edi, DWORD PTR [edx+eax]
	jmp	SHORT $LN899@more_other
$LN902@more_other:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN900@more_other
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edi]
	mov	edi, eax
	jmp	SHORT $LN899@more_other
$LN900@more_other:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN898@more_other
	mov	ecx, DWORD PTR _web+5656
	mov	edi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN899@more_other
$LN898@more_other:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [eax+ecx]
$LN899@more_other:

; 4574 :          char *s,**ss;
; 4575 : 
; 4576 :          s = *(char**)(stacktop--);         

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [esi+48], eax

; 4577 :          if ( g->flags & GLOB_LOCALVAR )

	test	DWORD PTR [edi+192], 524288		; 00080000H
	mov	DWORD PTR _s$92594[ebp], ecx
	je	SHORT $LN224@more_other

; 4578 :          { ss = (char**)(localstack+g->value.offset); 

	mov	edx, DWORD PTR [edi+64]
	mov	eax, DWORD PTR _localstack$GSCopy$[ebp]
	lea	esi, DWORD PTR [eax+edx*8]

; 4579 :            *ss = temp_realloc(*ss,(s?strlen(s):0)+1);

	test	ecx, ecx
	je	SHORT $LN904@more_other
	mov	eax, ecx
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL1283@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1283@more_other
	sub	eax, edx
	jmp	SHORT $LN905@more_other
$LN904@more_other:
	xor	eax, eax
$LN905@more_other:
	mov	ecx, DWORD PTR [esi]
	push	4579					; 000011e3H
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	inc	eax
	push	eax
	push	ecx
	call	_kb_temp_realloc

; 4580 :          }
; 4581 :          else 

	jmp	SHORT $LN1413@more_other
$LN224@more_other:

; 4582 :          { ss = &(g->value.string);

	lea	esi, DWORD PTR [edi+64]

; 4583 :            *ss = kb_realloc(*ss,(s?strlen(s):0)+1);

	test	ecx, ecx
	je	SHORT $LN906@more_other
	mov	eax, ecx
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL1284@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1284@more_other
	sub	eax, edx
	jmp	SHORT $LN907@more_other
$LN906@more_other:
	xor	eax, eax
$LN907@more_other:
	mov	edx, DWORD PTR [esi]
	push	4583					; 000011e7H
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	inc	eax
	push	eax
	push	edx
	call	_KB_realloc
$LN1413@more_other:

; 4584 :          }
; 4585 :          strcpy(*ss,s);

	mov	ecx, DWORD PTR _s$92594[ebp]
	mov	DWORD PTR [esi], eax
	add	esp, 16					; 00000010H
	mov	edx, eax
	npad	2
$LL1285@more_other:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL1285@more_other

; 4586 :          g->flags |= STRINGVAL;

	or	DWORD PTR [edi+192], 8192		; 00002000H

; 4587 :          if ( node->left && (node[node->left].flags & DEALLOCATE_POINTER) )

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	$LN626@more_other
	imul	eax, 168				; 000000a8H
	test	DWORD PTR [eax+ebx+24], 1024		; 00000400H
	je	$LN626@more_other

; 4588 :            myfree(s);  // for sprintf source of right side

	mov	eax, DWORD PTR _s$92594[ebp]
	push	eax
	call	_myfree
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN221@more_other:

; 4589 :        } break;
; 4590 : 
; 4591 :     case SET_PERM_SGLOBAL_NODE:
; 4592 :        { struct global *g = perm_globals(node->op1.name_id);

	mov	ecx, DWORD PTR [ebx+32]
	mov	edx, DWORD PTR _web+5656
	and	ecx, 16777215				; 00ffffffH
	mov	edi, DWORD PTR [edx+ecx*4]

; 4593 :          char *s;
; 4594 :          if ( g->value.string && !(g->flags & INTERNAL_NAME) ) 

	mov	eax, DWORD PTR [edi+64]
	test	eax, eax
	je	SHORT $LN220@more_other
	test	DWORD PTR [edi+192], 4194304		; 00400000H
	jne	SHORT $LN220@more_other

; 4595 :              free(g->value.string);

	push	eax
	call	_free
	add	esp, 4
$LN220@more_other:

; 4596 :          s = *(char**)(stacktop--);

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR _s$92603[ebp], ecx
	mov	DWORD PTR [esi+48], eax

; 4597 :          if ( s )

	test	ecx, ecx
	je	$LN219@more_other

; 4598 :          { if ( !(g->flags & INTERNAL_NAME) )

	test	DWORD PTR [edi+192], 4194304		; 00400000H
	jne	SHORT $LN218@more_other

; 4599 :               g->value.string = calloc(strlen(s)+1,sizeof(char));

	mov	eax, ecx
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL1286@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1286@more_other
	sub	eax, edx
	inc	eax
	push	1
	push	eax
	call	_calloc
	add	esp, 8
	mov	DWORD PTR [edi+64], eax
$LN218@more_other:

; 4600 :            strcpy(g->value.string,s);

	mov	ecx, DWORD PTR _s$92603[ebp]
	mov	edx, DWORD PTR [edi+64]
$LL1287@more_other:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	inc	ecx
	inc	edx
	test	al, al
	jne	SHORT $LL1287@more_other

; 4601 :            #ifdef WIN32
; 4602 :            if ( node->op1.name_id == console_title_global )

	mov	eax, DWORD PTR [ebx+32]
	cmp	eax, DWORD PTR _console_title_global
	jne	SHORT $LN217@more_other

; 4603 :              SetConsoleTitleA(console_title);

	push	OFFSET _console_title
	call	DWORD PTR __imp__SetConsoleTitleA@4
$LN217@more_other:

; 4604 :            #endif
; 4605 :            if ( node->op1.name_id == graphics_title_global )

	mov	eax, DWORD PTR [ebx+32]
	cmp	eax, DWORD PTR _graphics_title_global
	jne	SHORT $LN216@more_other

; 4606 :              set_graphics_title(1, graphics_title);

	push	OFFSET _graphics_title
	push	1
	call	_set_graphics_title
	jmp	SHORT $LN1414@more_other
$LN216@more_other:

; 4607 :            else if ( node->op1.name_id == graphics_title2_global )

	cmp	eax, DWORD PTR _graphics_title2_global
	jne	SHORT $LN214@more_other

; 4608 :              set_graphics_title(2, graphics_title2);

	push	OFFSET _graphics_title2
	push	2
	call	_set_graphics_title
	jmp	SHORT $LN1414@more_other
$LN214@more_other:

; 4609 :            else if ( node->op1.name_id == graphics_title3_global )

	cmp	eax, DWORD PTR _graphics_title3_global
	jne	SHORT $LN211@more_other

; 4610 :              set_graphics_title(3, graphics_title3);         

	push	OFFSET _graphics_title3
	push	3
	call	_set_graphics_title

; 4611 :          }
; 4612 :          else 

	jmp	SHORT $LN1414@more_other
$LN219@more_other:

; 4613 :          { g->value.string = calloc(1,sizeof(char));  /* empty */

	push	1
	push	1
	call	_calloc
	mov	DWORD PTR [edi+64], eax
$LN1414@more_other:
	add	esp, 8
$LN211@more_other:

; 4614 :          } 
; 4615 :          if ( node->left && (node[node->left].flags & DEALLOCATE_POINTER) )

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN210@more_other
	imul	eax, 168				; 000000a8H
	test	DWORD PTR [eax+ebx+24], 1024		; 00000400H
	je	SHORT $LN210@more_other

; 4616 :            myfree(s);

	mov	ecx, DWORD PTR _s$92603[ebp]
	push	ecx
	call	_myfree
	add	esp, 4
$LN210@more_other:

; 4617 : 
; 4618 :          g->flags |= STRINGVAL;

	or	DWORD PTR [edi+192], 8192		; 00002000H
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN209@more_other:

; 4619 :        } break;
; 4620 : 
; 4621 : 
; 4622 :     case SET_PARAM_SCALE_NODE:
; 4623 :        { struct global *g = globals(node->op1.name_id);

	mov	eax, DWORD PTR [ebx+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	and	eax, 16777215				; 00ffffffH
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN914@more_other
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
	jmp	SHORT $LN911@more_other
$LN914@more_other:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN912@more_other
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edi]
	jmp	SHORT $LN911@more_other
$LN912@more_other:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN910@more_other
	mov	edx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN911@more_other
$LN910@more_other:
	mov	ecx, DWORD PTR _web+5652
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
$LN911@more_other:

; 4624 :          REAL value = *(stacktop--);

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx]
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR [esi+48], ecx

; 4625 :          switch ( node->op2.assigntype )

	mov	ecx, DWORD PTR [ebx+136]
	add	ecx, -30001				; ffff8acfH
	cmp	ecx, 4
	ja	$LN1342@more_other
	jmp	DWORD PTR $LN1438@more_other[ecx*4]
$LN205@more_other:

; 4626 :          { case ASSIGN_OP: g->attr.varstuff.pscale = value; break;
; 4627 :            case PLUSASSIGN_OP: g->attr.varstuff.pscale += value; break;

	fadd	QWORD PTR [eax+176]
	pop	edi
	pop	esi
	pop	ebx

; 4630 :            case DIVASSIGN_OP: g->attr.varstuff.pscale /= value; break;

	fstp	QWORD PTR [eax+176]

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN204@more_other:

; 4628 :            case SUBASSIGN_OP: g->attr.varstuff.pscale -= value; break;

	fsubr	QWORD PTR [eax+176]
	pop	edi
	pop	esi
	pop	ebx

; 4630 :            case DIVASSIGN_OP: g->attr.varstuff.pscale /= value; break;

	fstp	QWORD PTR [eax+176]

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN203@more_other:

; 4629 :            case MULTASSIGN_OP: g->attr.varstuff.pscale *= value; break;

	fmul	QWORD PTR [eax+176]
	pop	edi
	pop	esi
	pop	ebx

; 4630 :            case DIVASSIGN_OP: g->attr.varstuff.pscale /= value; break;

	fstp	QWORD PTR [eax+176]

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN202@more_other:

; 4630 :            case DIVASSIGN_OP: g->attr.varstuff.pscale /= value; break;

	fdivr	QWORD PTR [eax+176]
$LN206@more_other:
	pop	edi
	fstp	QWORD PTR [eax+176]
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN201@more_other:

; 4631 :          } 
; 4632 :          break;
; 4633 :        }
; 4634 : 
; 4635 :     case SET_DELTA_NODE:
; 4636 :        { struct global *g = globals(node->op1.name_id);

	mov	eax, DWORD PTR [ebx+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	and	eax, 16777215				; 00ffffffH
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN920@more_other
	mov	ecx, DWORD PTR _web+5652
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [edx+eax]
	jmp	SHORT $LN917@more_other
$LN920@more_other:
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN918@more_other
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edi]
	jmp	SHORT $LN917@more_other
$LN918@more_other:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN916@more_other
	mov	ecx, DWORD PTR _web+5656
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN917@more_other
$LN916@more_other:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]
$LN917@more_other:

; 4637 :          REAL value = *(stacktop--);

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx]
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR [esi+48], ecx

; 4638 :          switch ( node->op2.assigntype )

	mov	ecx, DWORD PTR [ebx+136]
	add	ecx, -30001				; ffff8acfH
	cmp	ecx, 4
	ja	$LN1342@more_other
	jmp	DWORD PTR $LN1439@more_other[ecx*4]
$LN197@more_other:

; 4639 :          { case ASSIGN_OP: g->attr.varstuff.delta = value; break;
; 4640 :            case PLUSASSIGN_OP: g->attr.varstuff.delta += value; break;

	fadd	QWORD PTR [eax+168]
	pop	edi
	pop	esi
	pop	ebx

; 4643 :            case DIVASSIGN_OP: g->attr.varstuff.delta /= value; break;

	fstp	QWORD PTR [eax+168]

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN196@more_other:

; 4641 :            case SUBASSIGN_OP: g->attr.varstuff.delta -= value; break;

	fsubr	QWORD PTR [eax+168]
	pop	edi
	pop	esi
	pop	ebx

; 4643 :            case DIVASSIGN_OP: g->attr.varstuff.delta /= value; break;

	fstp	QWORD PTR [eax+168]

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN195@more_other:

; 4642 :            case MULTASSIGN_OP: g->attr.varstuff.delta *= value; break;

	fmul	QWORD PTR [eax+168]
	pop	edi
	pop	esi
	pop	ebx

; 4643 :            case DIVASSIGN_OP: g->attr.varstuff.delta /= value; break;

	fstp	QWORD PTR [eax+168]

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN194@more_other:

; 4643 :            case DIVASSIGN_OP: g->attr.varstuff.delta /= value; break;

	fdivr	QWORD PTR [eax+168]
$LN198@more_other:
	pop	edi
	fstp	QWORD PTR [eax+168]
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN193@more_other:

; 4644 :          } 
; 4645 :          break;
; 4646 :        }
; 4647 : 
; 4648 :     case SET_ON_ASSIGN_CALL_NODE:
; 4649 :        { struct global *g = globals(node->op1.name_id);

	mov	eax, DWORD PTR [ebx+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	and	eax, 16777215				; 00ffffffH
	cmp	ecx, 268435456				; 10000000H
	jne	SHORT $LN926@more_other
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx]

; 4650 :          g->attr.varstuff.on_assign_call = node->op2.name_id;

	mov	ecx, DWORD PTR [ebx+136]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+188], ecx
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN926@more_other:

; 4644 :          } 
; 4645 :          break;
; 4646 :        }
; 4647 : 
; 4648 :     case SET_ON_ASSIGN_CALL_NODE:
; 4649 :        { struct global *g = globals(node->op1.name_id);

	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN924@more_other

; 4650 :          g->attr.varstuff.on_assign_call = node->op2.name_id;

	mov	ecx, DWORD PTR [ebx+136]
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edi]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+188], ecx
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN924@more_other:

; 4644 :          } 
; 4645 :          break;
; 4646 :        }
; 4647 : 
; 4648 :     case SET_ON_ASSIGN_CALL_NODE:
; 4649 :        { struct global *g = globals(node->op1.name_id);

	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN922@more_other
	mov	edx, DWORD PTR _web+5656

; 4650 :          g->attr.varstuff.on_assign_call = node->op2.name_id;

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [edx+eax*4]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+188], ecx
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN922@more_other:

; 4644 :          } 
; 4645 :          break;
; 4646 :        }
; 4647 : 
; 4648 :     case SET_ON_ASSIGN_CALL_NODE:
; 4649 :        { struct global *g = globals(node->op1.name_id);

	mov	ecx, DWORD PTR _web+5652
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem

; 4650 :          g->attr.varstuff.on_assign_call = node->op2.name_id;

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [edx+eax]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+188], ecx
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN191@more_other:

; 4651 :          break;
; 4652 :        }
; 4653 :  
; 4654 : 
; 4655 :     case DEFINE_IDENT_NODE: break;
; 4656 : 
; 4657 :     case DEFINE_ARRAY_NODE:
; 4658 :           { int dim,size,i; 
; 4659 :             struct treenode *nnode = node;
; 4660 :             struct global *g = globals(node->op1.name_id);

	mov	eax, DWORD PTR [ebx+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN928@more_other
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN930@more_other
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [edi]
	mov	DWORD PTR _g$92656[ebp], eax
	jmp	SHORT $LN929@more_other
$LN930@more_other:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN928@more_other
	mov	ecx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _g$92656[ebp], eax
	jmp	SHORT $LN929@more_other
$LN928@more_other:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, DWORD PTR _dymem
	and	eax, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [eax+ecx]
	mov	eax, edx
	mov	DWORD PTR _g$92656[ebp], edx
$LN929@more_other:

; 4661 :             int itemsize;
; 4662 :             int pointercount;
; 4663 :             struct array *oldarray;
; 4664 :             struct array **array_info;
; 4665 :             int different_size;
; 4666 : 
; 4667 :             if ( g->flags & GLOB_LOCALVAR )

	test	DWORD PTR [eax+192], 524288		; 00080000H
	je	SHORT $LN190@more_other

; 4668 :             { localbase->flags |= LL_HAS_ARRAY;

	or	DWORD PTR [edi+20], 1

; 4669 :               array_info = (struct array **)(localstack+g->value.offset);

	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _localstack$GSCopy$[ebp]
	lea	ecx, DWORD PTR [edx+ecx*8]
	jmp	SHORT $LN1415@more_other
$LN190@more_other:

; 4670 :             }
; 4671 :             else array_info = &(g->attr.arrayptr);

	lea	ecx, DWORD PTR [eax+168]
$LN1415@more_other:

; 4672 :             
; 4673 :             oldarray = *array_info;

	mov	edi, DWORD PTR [ecx]

; 4674 :             itemsize = datatype_size[node->op2.valtype];
; 4675 :             pointercount = 0;
; 4676 :             different_size = oldarray ? 0 : 1;
; 4677 :             for ( size = 1, dim=0 ; dim < g->attr.arrayptr->dim ; dim++ ) 

	mov	eax, DWORD PTR [eax+168]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _array_info$92662[ebp], ecx
	mov	ecx, DWORD PTR [ebx+136]
	mov	ecx, DWORD PTR _datatype_size[ecx*4]
	xor	edx, edx
	mov	DWORD PTR _itemsize$92659[ebp], ecx
	xor	ecx, ecx
	cmp	edi, ecx
	sete	dl
	mov	DWORD PTR _oldarray$92661[ebp], edi
	mov	DWORD PTR _pointercount$92660[ebp], ecx
	mov	DWORD PTR _size$92653[ebp], 1
	mov	DWORD PTR _dim$92652[ebp], ecx
	mov	DWORD PTR _different_size$92663[ebp], edx
	cmp	eax, ecx
	jle	SHORT $LN186@more_other

; 4672 :             
; 4673 :             oldarray = *array_info;

	mov	ecx, edi
	mov	edi, DWORD PTR [esi+48]
	lea	edx, DWORD PTR [eax*8]
	add	ecx, 24					; 00000018H
	sub	edi, edx
	mov	DWORD PTR tv10255[ebp], ecx
	add	edi, 8
	mov	DWORD PTR tv3787[ebp], eax

; 4674 :             itemsize = datatype_size[node->op2.valtype];
; 4675 :             pointercount = 0;
; 4676 :             different_size = oldarray ? 0 : 1;
; 4677 :             for ( size = 1, dim=0 ; dim < g->attr.arrayptr->dim ; dim++ ) 

	mov	DWORD PTR _dim$92652[ebp], eax
	npad	6
$LL1288@more_other:

; 4678 :             { int dimsize;
; 4679 :               pointercount += size;

	mov	eax, DWORD PTR _size$92653[ebp]

; 4680 :               dimsize = (int)stacktop[1-g->attr.arrayptr->dim+dim];

	fld	QWORD PTR [edi]
	add	DWORD PTR _pointercount$92660[ebp], eax
	call	__ftol2_sse

; 4681 :               size *= dimsize;

	mov	ecx, eax
	imul	ecx, DWORD PTR _size$92653[ebp]

; 4682 :               if ( oldarray && (dimsize != oldarray->sizes[dim]) )

	cmp	DWORD PTR _oldarray$92661[ebp], 0
	mov	DWORD PTR _size$92653[ebp], ecx
	je	SHORT $LN187@more_other
	mov	edx, DWORD PTR tv10255[ebp]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN187@more_other

; 4683 :                 different_size = 1;

	mov	DWORD PTR _different_size$92663[ebp], 1
$LN187@more_other:

; 4674 :             itemsize = datatype_size[node->op2.valtype];
; 4675 :             pointercount = 0;
; 4676 :             different_size = oldarray ? 0 : 1;
; 4677 :             for ( size = 1, dim=0 ; dim < g->attr.arrayptr->dim ; dim++ ) 

	add	DWORD PTR tv10255[ebp], 4
	add	edi, 8
	dec	DWORD PTR tv3787[ebp]
	jne	SHORT $LL1288@more_other
$LN186@more_other:

; 4684 :             }
; 4685 :             if ( oldarray && (oldarray->datatype != node->op2.valtype) )

	mov	eax, DWORD PTR _oldarray$92661[ebp]
	test	eax, eax
	je	$LN184@more_other
	mov	eax, DWORD PTR [eax+8]
	cmp	eax, DWORD PTR [ebx+136]
	je	$LN184@more_other

; 4686 :             { different_size = 1;
; 4687 :               if ( oldarray->datatype )

	test	eax, eax
	je	SHORT $LN183@more_other

; 4688 :               { sprintf(errmsg,"Changing datatype of array '%s'.  Data zeroed.\n",g->name);

	mov	eax, DWORD PTR _g$92656[ebp]
	push	eax
	push	OFFSET ??_C@_0DA@ICIFPLG@Changing?5datatype?5of?5array?5?8?$CFs?8?4@
	push	OFFSET _errmsg
	call	_sprintf

; 4689 :                 sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4690 :                    file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1289@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1289@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 4691 :                 kb_error(4822,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	4822					; 000012d6H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN183@more_other:

; 4692 :               }
; 4693 :               oldarray = NULL;  // zero out data instead of converting

	mov	DWORD PTR _oldarray$92661[ebp], 0
$LN182@more_other:

; 4697 :               break;  // no need to do anything
; 4698 :             }
; 4699 :            
; 4700 :             if ( g->flags & GLOB_LOCALVAR )
; 4701 :               *array_info = (struct array*)temp_calloc( 
; 4702 :                 sizeof(struct array)+dim*sizeof(int)
; 4703 :                    + (size+1)*itemsize+pointercount*sizeof(REAL*),1);  /* extra for alignment */

	mov	eax, DWORD PTR _dim$92652[ebp]
	mov	ecx, DWORD PTR _g$92656[ebp]
	add	eax, DWORD PTR _pointercount$92660[ebp]
	test	DWORD PTR [ecx+192], 524288		; 00080000H
	je	SHORT $LN181@more_other
	mov	ecx, DWORD PTR _size$92653[ebp]
	inc	ecx
	imul	ecx, DWORD PTR _itemsize$92659[ebp]
	push	4703					; 0000125fH
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	lea	edx, DWORD PTR [ecx+eax*4+56]
	push	1
	push	edx
	call	_kb_temp_calloc
	mov	edi, DWORD PTR _array_info$92662[ebp]
	mov	DWORD PTR [edi], eax

; 4704 :             else /* nonlocal */

	jmp	SHORT $LN1416@more_other
$LN184@more_other:

; 4694 :             }
; 4695 :             if ( !different_size )

	cmp	DWORD PTR _different_size$92663[ebp], 0
	jne	SHORT $LN182@more_other

; 4696 :             { stacktop -= dim;

	mov	eax, DWORD PTR _dim$92652[ebp]
	neg	eax
	add	eax, eax
	add	eax, eax
	add	eax, eax
	add	DWORD PTR [esi+48], eax
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN181@more_other:

; 4705 :               *array_info = (struct array*)mycalloc( 
; 4706 :                 sizeof(struct array)+dim*sizeof(int)
; 4707 :                            + (size+1)*itemsize+pointercount*sizeof(REAL*),1);  /* extra for alignment */

	mov	edx, DWORD PTR _size$92653[ebp]
	inc	edx
	imul	edx, DWORD PTR _itemsize$92659[ebp]
	push	4707					; 00001263H
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	lea	eax, DWORD PTR [edx+eax*4+56]
	push	1
	push	eax
	call	_kb_calloc
	mov	ecx, DWORD PTR _array_info$92662[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edi, ecx
$LN1416@more_other:

; 4708 :             (*array_info)->dim = dim;

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR _dim$92652[ebp]
	mov	DWORD PTR [edx+4], eax

; 4709 :             (*array_info)->itemsize = itemsize;

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _itemsize$92659[ebp]
	mov	DWORD PTR [ecx+12], edx

; 4710 :             (*array_info)->datatype = node->op2.valtype;

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ebx+136]
	mov	DWORD PTR [ecx+8], edx

; 4711 :             (*array_info)->datacount = size;

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR _size$92653[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ecx+16], edx

; 4712 :             for ( i=0, nnode = node ; i < dim ; nnode += nnode->left, i++ ) 

	test	eax, eax
	jle	SHORT $LN177@more_other

; 4708 :             (*array_info)->dim = dim;

	mov	ebx, eax
	neg	ebx
	add	ebx, ebx
	add	ebx, ebx
	mov	DWORD PTR tv10324[ebp], 24		; 00000018H
	add	ebx, ebx
	mov	DWORD PTR tv3759[ebp], eax
	npad	2
$LL1290@more_other:

; 4713 :               (*array_info)->sizes[i] = (int)stacktop[1-dim+i];

	mov	eax, DWORD PTR [esi+48]
	fld	QWORD PTR [ebx+eax+8]
	call	__ftol2_sse
	mov	ecx, DWORD PTR tv10324[ebp]
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [ecx+edx], eax
	add	ecx, 4
	add	ebx, 8
	dec	DWORD PTR tv3759[ebp]
	mov	DWORD PTR tv10324[ebp], ecx
	jne	SHORT $LL1290@more_other
$LN177@more_other:

; 4714 :             stacktop -= dim;

	mov	ebx, DWORD PTR _dim$92652[ebp]
	mov	eax, ebx
	neg	eax
	add	eax, eax
	add	eax, eax
	add	eax, eax
	add	DWORD PTR [esi+48], eax

; 4715 :             (*array_info)->datastart = sizeof(struct array) + dim*sizeof(int);  

	mov	edx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [ebx*4+56]
	mov	DWORD PTR [edx+20], ecx

; 4716 :             /* guarantee bus alignment */
; 4717 :             if ( (*array_info)->datastart % itemsize )

	mov	edi, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR _itemsize$92659[ebp]
	xor	edx, edx
	div	ecx
	test	edx, edx
	je	SHORT $LN176@more_other

; 4718 :               (*array_info)->datastart = 
; 4719 :                  (*array_info)->datastart + itemsize - 
; 4720 :                     ((*array_info)->datastart % itemsize ); 

	mov	esi, DWORD PTR [edi+20]
	xor	edx, edx
	mov	eax, esi
	div	ecx
	sub	ecx, edx
	add	ecx, esi
	mov	DWORD PTR [edi+20], ecx
$LN176@more_other:

; 4721 : 
; 4722 :             /* copy old data */ 
; 4723 :             if ( oldarray )

	cmp	DWORD PTR _oldarray$92661[ebp], 0
	je	$LN172@more_other

; 4724 :             { int oldoff,n;
; 4725 :               for ( oldoff = 0 ; oldoff < oldarray->datacount ; oldoff ++ )

	mov	eax, DWORD PTR _oldarray$92661[ebp]
	cmp	DWORD PTR [eax+16], 0
	mov	DWORD PTR _oldoff$92696[ebp], 0
	jle	$LN172@more_other
	dec	ebx
	mov	DWORD PTR tv7182[ebp], ebx
	npad	5
$LL1291@more_other:

; 4726 :               { int newoff = 0;
; 4727 :                 int prod = 1;
; 4728 :                 int p,pp;
; 4729 :                 p = oldoff;
; 4730 :                 for ( n = dim-1 ; n >= 0 ; n-- )

	mov	ebx, DWORD PTR tv7182[ebp]
	mov	eax, DWORD PTR _oldoff$92696[ebp]
	mov	DWORD PTR _newoff$92701[ebp], 0
	mov	esi, 1
	test	ebx, ebx
	js	SHORT $LN169@more_other
	mov	ecx, DWORD PTR _array_info$92662[ebp]
	mov	edx, DWORD PTR _oldarray$92661[ebp]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, edx
	lea	edi, DWORD PTR [edx+ebx*4+24]
	mov	DWORD PTR tv10403[ebp], ecx
	jmp	SHORT $LN171@more_other
	npad	5
$LL1247@more_other:
	mov	eax, DWORD PTR _p$92703[ebp]
$LN171@more_other:

; 4731 :                 { int nd = (*array_info)->sizes[n];

	mov	edx, DWORD PTR tv10403[ebp]
	mov	ecx, DWORD PTR [edx+edi]

; 4732 :                   int od = oldarray->sizes[n];

	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR _od$92709[ebp], edx

; 4733 :                   if ( od == 0 ) goto skip;

	test	edx, edx
	je	SHORT $skip$92711

; 4734 :                   pp = p % od;

	cdq
	idiv	DWORD PTR _od$92709[ebp]

; 4735 :                   p  = p / od;

	mov	DWORD PTR _p$92703[ebp], eax

; 4736 :                   if ( pp >= nd ) goto skip;

	cmp	edx, ecx
	jge	SHORT $skip$92711

; 4737 :                   newoff += prod*pp;

	imul	edx, esi

; 4738 :                   prod *= nd; 

	imul	esi, ecx
	add	DWORD PTR _newoff$92701[ebp], edx
	sub	edi, 4
	dec	ebx
	jns	SHORT $LL1247@more_other
$LN169@more_other:

; 4739 :                 }
; 4740 :                 memcpy((char*)(*array_info)+(*array_info)->datastart
; 4741 :                           + newoff*(*array_info)->itemsize,
; 4742 :                         (char*)oldarray+oldarray->datastart
; 4743 :                            + oldoff*oldarray->itemsize,
; 4744 :                          oldarray->itemsize);

	mov	edx, DWORD PTR _oldarray$92661[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _array_info$92662[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR _oldoff$92696[ebp]
	push	ecx
	imul	esi, ecx
	mov	ecx, DWORD PTR [eax+12]
	imul	ecx, DWORD PTR _newoff$92701[ebp]
	add	esi, DWORD PTR [edx+20]
	add	ecx, DWORD PTR [eax+20]
	add	esi, edx
	add	ecx, eax
	push	esi
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$skip$92711:

; 4724 :             { int oldoff,n;
; 4725 :               for ( oldoff = 0 ; oldoff < oldarray->datacount ; oldoff ++ )

	mov	eax, DWORD PTR _oldoff$92696[ebp]
	mov	edx, DWORD PTR _oldarray$92661[ebp]
	inc	eax
	mov	DWORD PTR _oldoff$92696[ebp], eax
	cmp	eax, DWORD PTR [edx+16]
	jl	$LL1291@more_other
$LN172@more_other:

; 4745 : skip: ;
; 4746 :               }
; 4747 :             }
; 4748 :             
; 4749 :             if ( g->flags & GLOB_LOCALVAR )

	mov	eax, DWORD PTR _g$92656[ebp]
	test	DWORD PTR [eax+192], 524288		; 00080000H
	je	SHORT $LN166@more_other

; 4750 :               temp_free((char*)oldarray);

	mov	ecx, DWORD PTR _oldarray$92661[ebp]
	push	ecx
	call	_temp_free
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN166@more_other:

; 4751 :             else 
; 4752 :               myfree((char*)oldarray);

	mov	edx, DWORD PTR _oldarray$92661[ebp]
	push	edx
	call	_myfree
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN164@more_other:

; 4753 :            } 
; 4754 :            break;
; 4755 :          
; 4756 :     case SET_ELEMENT_GLOBAL_NODE:
; 4757 :        { struct global *g = globals(node->op1.name_id);

	mov	ebx, DWORD PTR [ebx+32]
	mov	eax, ebx
	and	eax, -16777216				; ff000000H
	and	ebx, 16777215				; 00ffffffH
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN938@more_other
	mov	eax, DWORD PTR _web+5652
	mov	edx, DWORD PTR _dymem
	lea	ecx, DWORD PTR [eax+ebx*4]
	mov	ebx, DWORD PTR [ecx+edx]

; 4758 :          g->value.id = *(element_id*)(stacktop--);

	mov	ecx, DWORD PTR [esi+48]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ebx+64], edx
	add	DWORD PTR [esi+48], -8			; fffffff8H
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN938@more_other:

; 4753 :            } 
; 4754 :            break;
; 4755 :          
; 4756 :     case SET_ELEMENT_GLOBAL_NODE:
; 4757 :        { struct global *g = globals(node->op1.name_id);

	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN936@more_other

; 4758 :          g->value.id = *(element_id*)(stacktop--);

	mov	ecx, DWORD PTR [esi+48]
	imul	ebx, 224				; 000000e0H
	add	ebx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ebx+64], edx
	add	DWORD PTR [esi+48], -8			; fffffff8H
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN936@more_other:

; 4753 :            } 
; 4754 :            break;
; 4755 :          
; 4756 :     case SET_ELEMENT_GLOBAL_NODE:
; 4757 :        { struct global *g = globals(node->op1.name_id);

	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN934@more_other

; 4758 :          g->value.id = *(element_id*)(stacktop--);

	mov	ecx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR _web+5656
	mov	ebx, DWORD PTR [eax+ebx*4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ebx+64], edx
	add	DWORD PTR [esi+48], -8			; fffffff8H
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN934@more_other:

; 4753 :            } 
; 4754 :            break;
; 4755 :          
; 4756 :     case SET_ELEMENT_GLOBAL_NODE:
; 4757 :        { struct global *g = globals(node->op1.name_id);

	mov	ecx, DWORD PTR _web+5652
	mov	eax, DWORD PTR _dymem
	lea	edx, DWORD PTR [ecx+ebx*4]

; 4758 :          g->value.id = *(element_id*)(stacktop--);

	mov	ecx, DWORD PTR [esi+48]
	mov	ebx, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ebx+64], edx
	add	DWORD PTR [esi+48], -8			; fffffff8H
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN163@more_other:

; 4759 :          break;
; 4760 :        } 
; 4761 :           
; 4762 : 
; 4763 :     case ZOOM_NODE:
; 4764 :             if ( node->left ) /* have vertex number */

	cmp	DWORD PTR [ebx+4], 0
	je	$LN162@more_other

; 4765 :               { vertex_id v_id;
; 4766 :                  int vnum;
; 4767 :                  int found = 0;
; 4768 :                  web.zoom_radius = *(stacktop--);

	mov	eax, DWORD PTR [esi+48]
	fld	QWORD PTR [eax]
	fstp	QWORD PTR _web+984
	mov	edi, DWORD PTR [esi+48]

; 4769 :                  vnum = (int)*(stacktop--);

	fld	QWORD PTR [edi-8]
	call	__ftol2_sse
	add	edi, -16				; fffffff0H
	mov	DWORD PTR [esi+48], edi

; 4770 :                  FOR_ALL_VERTICES(v_id)

	mov	edi, DWORD PTR _web+48
	mov	esi, edi
	shr	esi, 28					; 0000001cH
	and	esi, 1
	mov	DWORD PTR _vnum$92727[ebp], eax
	je	SHORT $LN1127@more_other
	npad	4
$LL1292@more_other:
	mov	ecx, DWORD PTR _web+12
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv7227[ebp], eax
	and	ecx, 1
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN160@more_other

; 4771 :                  { if ( vnum == (ordinal(v_id)+1) )

	test	esi, esi
	jne	SHORT $LN941@more_other
	or	edx, -1
$LN941@more_other:
	inc	edx
	cmp	DWORD PTR _vnum$92727[ebp], edx
	je	SHORT $LN1048@more_other
$LN160@more_other:

; 4770 :                  FOR_ALL_VERTICES(v_id)

	mov	edx, DWORD PTR tv7227[ebp]
	mov	edi, DWORD PTR [edx]
	mov	esi, edi
	shr	esi, 28					; 0000001cH
	and	esi, 1
	jne	SHORT $LL1292@more_other
$LN1127@more_other:

; 4775 :                  { sprintf(errmsg,"Zoom vertex %d not found.\n",vnum);

	mov	eax, DWORD PTR _vnum$92727[ebp]
	push	eax
	push	OFFSET ??_C@_0BL@DENHLHAI@Zoom?5vertex?5?$CFd?5not?5found?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4776 :                    sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4777 :                      file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1293@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1293@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 4778 :                    kb_error(1231,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1231					; 000004cfH

; 4779 :                  }

	jmp	SHORT $LN1417@more_other
$LN1048@more_other:

; 4772 :                    { web.zoom_v = v_id; found = 1; break; }

	mov	DWORD PTR _web+976, edi

; 4773 :                  }
; 4774 :                  if ( !found )

	jmp	SHORT $LN1244@more_other
$LN162@more_other:

; 4780 :               }
; 4781 :             else if ( !valid_element(web.zoom_v) )

	mov	ecx, DWORD PTR _web+976
	push	ecx
	call	_valid_element
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1244@more_other

; 4782 :                  { sprintf(errmsg,"Zoom vertex not found.\n");

	push	OFFSET ??_C@_0BI@GDCBHHFG@Zoom?5vertex?5not?5found?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4783 :                    sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4784 :                      file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1294@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1294@more_other
	mov	ecx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4785 :                    kb_error(1232,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1232					; 000004d0H
$LN1417@more_other:
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1244@more_other:

; 4786 :                  }
; 4787 : 
; 4788 :             zoom_vertex(web.zoom_v,web.zoom_radius);

	fld	QWORD PTR _web+984
	mov	eax, DWORD PTR _web+976
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	call	_zoom_vertex
	add	esp, 12					; 0000000cH

; 4789 :             /* resize(); */
; 4790 :             recalc();
; 4791 :             break;

	jmp	$LN1427@more_other
$LN151@more_other:

; 4792 : 
; 4793 :     case VIEW_MATRIX_LVALUE_NODE: break;  /* just to hold indices */
; 4794 : 
; 4795 :     case SET_VIEW_MATRIX_NODE:
; 4796 :       { int i = (int)(stacktop[-2]);

	mov	edi, DWORD PTR [esi+48]
	fld	QWORD PTR [edi-16]
	call	__ftol2_sse

; 4797 :         int k = (int)(stacktop[-1]);

	fld	QWORD PTR [edi-8]
	mov	DWORD PTR _i$92749[ebp], eax
	call	__ftol2_sse

; 4798 :         REAL value = *stacktop;

	fld	QWORD PTR [edi]

; 4799 :         stacktop -= 3;

	add	edi, -24				; ffffffe8H
	fst	QWORD PTR _value$92753[ebp]
	mov	DWORD PTR [esi+48], edi

; 4800 :          if ( (k < 1) || (k > SDIM+1) || (i < 1) || (i > SDIM+1) )

	mov	ecx, DWORD PTR _web+616
	mov	esi, DWORD PTR _i$92749[ebp]
	mov	DWORD PTR _k$92751[ebp], eax
	cmp	eax, 1
	jl	SHORT $LN1349@more_other
	mov	edi, DWORD PTR _k$92751[ebp]
	lea	eax, DWORD PTR [ecx+1]
	cmp	edi, eax
	jg	SHORT $LN1355@more_other
	cmp	esi, 1
	jl	SHORT $LN1355@more_other
	cmp	esi, eax
	jle	SHORT $LN150@more_other
	jmp	SHORT $LN1355@more_other
$LN1349@more_other:
	mov	edi, eax
$LN1355@more_other:

; 4801 :          { sprintf(errmsg,
; 4802 :              "Illegal index: view_matrix[%d][%d] (must be 1 to %d)\n",i,k,SDIM);

	push	ecx
	fstp	ST(0)
	push	edi
	push	esi
	push	OFFSET ??_C@_0DG@GCIBKAME@Illegal?5index?3?5view_matrix?$FL?$CFd?$FN?$FL?$CF@
	push	OFFSET _errmsg
	call	_sprintf

; 4803 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4804 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR [eax+1]
$LL1295@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1295@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 4805 :             kb_error(2049,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2049					; 00000801H
	call	_kb_error
	fld	QWORD PTR _value$92753[ebp]
	add	esp, 28					; 0000001cH
$LN150@more_other:

; 4806 :          }
; 4807 :          i--;k--;  /* convert to 0 based indexing */
; 4808 :          switch ( node->op2.assigntype )

	mov	eax, DWORD PTR [ebx+136]
	add	eax, -30001				; ffff8acfH
	cmp	eax, 4
	ja	$LN1363@more_other
	jmp	DWORD PTR $LN1440@more_other[eax*4]
$LN146@more_other:

; 4809 :          { case ASSIGN_OP: view[i][k] = value; break;

	mov	ecx, DWORD PTR _view
	mov	edx, DWORD PTR [ecx+esi*4-4]

; 4821 :          } 
; 4822 :          *update_display_flag = 1;

	mov	eax, DWORD PTR _update_display_flag$GSCopy$[ebp]
	fstp	QWORD PTR [edx+edi*8-8]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN145@more_other:

; 4810 :            case PLUSASSIGN_OP: view[i][k] += value; break;

	mov	eax, DWORD PTR _view
	mov	ecx, DWORD PTR [eax+esi*4-4]
	fadd	QWORD PTR [ecx+edi*8-8]

; 4821 :          } 
; 4822 :          *update_display_flag = 1;

	mov	eax, DWORD PTR _update_display_flag$GSCopy$[ebp]
	lea	edi, DWORD PTR [ecx+edi*8-8]
	fstp	QWORD PTR [edi]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN144@more_other:

; 4811 :            case SUBASSIGN_OP: view[i][k] -= value; break;

	mov	edx, DWORD PTR _view
	mov	eax, DWORD PTR [edx+esi*4-4]
	fsubr	QWORD PTR [eax+edi*8-8]
	lea	edi, DWORD PTR [eax+edi*8-8]

; 4821 :          } 
; 4822 :          *update_display_flag = 1;

	mov	eax, DWORD PTR _update_display_flag$GSCopy$[ebp]
	fstp	QWORD PTR [edi]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN143@more_other:

; 4812 :            case MULTASSIGN_OP: view[i][k] *= value; break;

	mov	ecx, DWORD PTR _view
	mov	edx, DWORD PTR [ecx+esi*4-4]
	fmul	QWORD PTR [edx+edi*8-8]

; 4821 :          } 
; 4822 :          *update_display_flag = 1;

	mov	eax, DWORD PTR _update_display_flag$GSCopy$[ebp]
	lea	edi, DWORD PTR [edx+edi*8-8]
	fstp	QWORD PTR [edi]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN142@more_other:

; 4813 :            case DIVASSIGN_OP: 
; 4814 :                if ( value == 0.0 )

	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN141@more_other

; 4815 :                { sprintf(errmsg,"Division by zero.\n");

	push	OFFSET ??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@
	fstp	ST(0)
	push	OFFSET _errmsg
	call	_sprintf

; 4816 :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4817 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL1296@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1296@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 4818 :                  kb_error(2565,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2565					; 00000a05H
	call	_kb_error
	fld	QWORD PTR _value$92753[ebp]
	add	esp, 28					; 0000001cH
$LN141@more_other:

; 4819 :                }
; 4820 :                view[i][k] /= value; break;

	mov	ecx, DWORD PTR _view
	mov	edx, DWORD PTR [ecx+esi*4-4]
	fdivr	QWORD PTR [edx+edi*8-8]
	lea	edi, DWORD PTR [edx+edi*8-8]

; 4821 :          } 
; 4822 :          *update_display_flag = 1;

	mov	eax, DWORD PTR _update_display_flag$GSCopy$[ebp]
	fstp	QWORD PTR [edi]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1363@more_other:

; 4821 :          } 
; 4822 :          *update_display_flag = 1;

	mov	eax, DWORD PTR _update_display_flag$GSCopy$[ebp]
	fstp	ST(0)
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN140@more_other:

; 4823 :       }
; 4824 :       break;
; 4825 : 
; 4826 : 
; 4827 :     case SET_QTARGET_NODE:
; 4828 :       { struct gen_quant *q = GEN_QUANT(node->op1.quant_id);

	mov	edi, DWORD PTR [ebx+32]

; 4829 :          switch ( node->op2.assigntype )

	mov	eax, DWORD PTR [ebx+136]
	imul	edi, 368				; 00000170H
	add	edi, DWORD PTR _gen_quant_list
	add	eax, -30001				; ffff8acfH
	cmp	eax, 4
	ja	$LN138@more_other
	jmp	DWORD PTR $LN1441@more_other[eax*4]
$LN137@more_other:

; 4830 :          { case ASSIGN_OP: q->target = *(stacktop--); break;

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx]
	jmp	$LN1418@more_other
$LN136@more_other:

; 4831 :            case PLUSASSIGN_OP: q->target += *(stacktop--); break;

	mov	edx, DWORD PTR [esi+48]
	fld	QWORD PTR [edx]
	fadd	QWORD PTR [edi+144]
	jmp	$LN1418@more_other
$LN135@more_other:

; 4832 :            case SUBASSIGN_OP: q->target -= *(stacktop--); break;

	mov	eax, DWORD PTR [esi+48]
	fld	QWORD PTR [edi+144]
	fsub	QWORD PTR [eax]
	jmp	$LN1418@more_other
$LN134@more_other:

; 4833 :            case MULTASSIGN_OP: q->target *= *(stacktop--); break;

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx]
	fmul	QWORD PTR [edi+144]
	jmp	SHORT $LN1418@more_other
$LN133@more_other:

; 4834 :            case DIVASSIGN_OP:
; 4835 :                if ( *stacktop == 0.0 )

	mov	edx, DWORD PTR [esi+48]
	fld	QWORD PTR [edx]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN132@more_other

; 4836 :                { sprintf(errmsg,"Division by zero.\n");

	push	OFFSET ??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4837 :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4838 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL1297@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1297@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 4839 :                  kb_error(2588,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2588					; 00000a1cH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN132@more_other:

; 4840 :                }
; 4841 :                q->target /= *(stacktop--); 

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [edi+144]
	fdiv	QWORD PTR [ecx]
$LN1418@more_other:
	fstp	QWORD PTR [edi+144]
	add	DWORD PTR [esi+48], -8			; fffffff8H
$LN138@more_other:

; 4842 :                break;
; 4843 :          } 
; 4844 :          if ( valid_id(q->b_id) )

	mov	eax, DWORD PTR [edi+216]
	test	eax, 268435456				; 10000000H
	je	$LN626@more_other

; 4845 :               set_body_fixvol(q->b_id,q->target);

	fld	QWORD PTR [edi+144]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	call	_set_body_fixvol
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN130@more_other:

; 4846 :       }
; 4847 :       break;
; 4848 : 
; 4849 :     case SET_QMODULUS_NODE:
; 4850 :       { REAL v = GEN_QUANT(node->op1.quant_id)->modulus;

	mov	edx, DWORD PTR [ebx+32]
	mov	eax, DWORD PTR _gen_quant_list
	imul	edx, 368				; 00000170H
	fld	QWORD PTR [edx+eax+176]

; 4851 :          switch ( node->op2.assigntype )

	mov	eax, DWORD PTR [ebx+136]
	add	eax, -30001				; ffff8acfH
	fst	QWORD PTR _v$92782[ebp]
	cmp	eax, 4
	ja	$LN128@more_other
	jmp	DWORD PTR $LN1442@more_other[eax*4]
$LN1375@more_other:

; 4852 :          { case ASSIGN_OP: v = *(stacktop--); break;

	mov	eax, DWORD PTR [esi+48]

; 4862 :                }
; 4863 :               v /= *(stacktop--); 

	fstp	ST(0)
	fld	QWORD PTR [eax]
	jmp	$LN1419@more_other
$LN126@more_other:

; 4853 :            case PLUSASSIGN_OP: v += *(stacktop--); break;

	mov	eax, DWORD PTR [esi+48]
	fadd	QWORD PTR [eax]
	jmp	$LN1419@more_other
$LN125@more_other:

; 4854 :            case SUBASSIGN_OP: v -= *(stacktop--); break;

	mov	eax, DWORD PTR [esi+48]
	fsub	QWORD PTR [eax]
	jmp	SHORT $LN1419@more_other
$LN124@more_other:

; 4855 :            case MULTASSIGN_OP: v *= *(stacktop--); break;

	mov	eax, DWORD PTR [esi+48]
	fmul	QWORD PTR [eax]
	jmp	SHORT $LN1419@more_other
$LN123@more_other:

; 4856 :            case DIVASSIGN_OP: 
; 4857 :               if ( *stacktop == 0.0 )

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [ecx]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN122@more_other

; 4858 :                { sprintf(errmsg,"Division by zero.\n");

	push	OFFSET ??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@
	fstp	ST(0)
	push	OFFSET _errmsg
	call	_sprintf

; 4859 :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4860 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL1298@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1298@more_other
	mov	ecx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4861 :                  kb_error(2589,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2589					; 00000a1dH
	call	_kb_error
	fld	QWORD PTR _v$92782[ebp]
	add	esp, 28					; 0000001cH
$LN122@more_other:

; 4862 :                }
; 4863 :               v /= *(stacktop--); 

	mov	eax, DWORD PTR [esi+48]
	fdiv	QWORD PTR [eax]
$LN1419@more_other:
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [esi+48], eax
$LN128@more_other:

; 4864 :               break;
; 4865 :          } 
; 4866 :         GEN_QUANT(node->op1.quant_id)->modulus = v;

	mov	eax, DWORD PTR [ebx+32]
	mov	ecx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H
	pop	edi
	pop	esi
	fstp	QWORD PTR [eax+ecx+176]
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN121@more_other:

; 4867 :      }
; 4868 :      break;
; 4869 : 
; 4870 :     case SET_QTOLERANCE_NODE:
; 4871 :       if ( *stacktop <= 0.0 )

	fldz
	mov	edx, DWORD PTR [esi+48]
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN120@more_other

; 4872 :       { sprintf(errmsg,"Tolerance must be positive.\n");

	push	OFFSET ??_C@_0BN@DLJCKBBD@Tolerance?5must?5be?5positive?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4873 :         sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4874 :                                 file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL1299@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1299@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 4875 :          kb_error(2050,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2050					; 00000802H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN120@more_other:

; 4876 :       }
; 4877 :       { REAL v = GEN_QUANT(node->op1.quant_id)->tolerance;

	mov	ecx, DWORD PTR [ebx+32]

; 4878 :          switch ( node->op2.assigntype )

	mov	eax, DWORD PTR [ebx+136]
	imul	ecx, 368				; 00000170H
	mov	edx, DWORD PTR _gen_quant_list
	add	eax, -30001				; ffff8acfH
	fld	QWORD PTR [ecx+edx+184]
	fst	QWORD PTR _v$92796[ebp]
	cmp	eax, 4
	ja	$LN118@more_other
	jmp	DWORD PTR $LN1443@more_other[eax*4]
$LN1386@more_other:

; 4879 :          { case ASSIGN_OP: v = *(stacktop--); break;

	mov	eax, DWORD PTR [esi+48]

; 4889 :                }
; 4890 :              v /= *(stacktop--); 

	fstp	ST(0)
	fld	QWORD PTR [eax]
	jmp	$LN1420@more_other
$LN116@more_other:

; 4880 :            case PLUSASSIGN_OP: v += *(stacktop--); break;

	mov	eax, DWORD PTR [esi+48]
	fadd	QWORD PTR [eax]
	jmp	$LN1420@more_other
$LN115@more_other:

; 4881 :            case SUBASSIGN_OP: v -= *(stacktop--); break;

	mov	eax, DWORD PTR [esi+48]
	fsub	QWORD PTR [eax]
	jmp	SHORT $LN1420@more_other
$LN114@more_other:

; 4882 :            case MULTASSIGN_OP: v *= *(stacktop--); break;

	mov	eax, DWORD PTR [esi+48]
	fmul	QWORD PTR [eax]
	jmp	SHORT $LN1420@more_other
$LN113@more_other:

; 4883 :            case DIVASSIGN_OP:
; 4884 :              if ( *stacktop == 0.0 )

	mov	eax, DWORD PTR [esi+48]
	fld	QWORD PTR [eax]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN112@more_other

; 4885 :                { sprintf(errmsg,"Division by zero.\n");

	push	OFFSET ??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@
	fstp	ST(0)
	push	OFFSET _errmsg
	call	_sprintf

; 4886 :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4887 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1300@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1300@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 4888 :                  kb_error(2487,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2487					; 000009b7H
	call	_kb_error
	fld	QWORD PTR _v$92796[ebp]
	add	esp, 28					; 0000001cH
$LN112@more_other:

; 4889 :                }
; 4890 :              v /= *(stacktop--); 

	mov	eax, DWORD PTR [esi+48]
	fdiv	QWORD PTR [eax]
$LN1420@more_other:
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [esi+48], eax
$LN118@more_other:

; 4891 :              break;
; 4892 :          } 
; 4893 :         GEN_QUANT(node->op1.quant_id)->tolerance = v;

	mov	ecx, DWORD PTR [ebx+32]
	mov	edx, DWORD PTR _gen_quant_list
	imul	ecx, 368				; 00000170H
	pop	edi
	pop	esi
	fstp	QWORD PTR [ecx+edx+184]
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN111@more_other:

; 4894 :      }
; 4895 :      break;
; 4896 : 
; 4897 :     case SET_MMODULUS_NODE:
; 4898 :       { REAL v = METH_INSTANCE(node->op1.meth_id)->modulus;

	mov	eax, DWORD PTR [ebx+32]
	mov	ecx, DWORD PTR _meth_inst_list
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	fld	QWORD PTR [eax+ecx+304]

; 4899 :          switch ( node->op2.assigntype )

	mov	eax, DWORD PTR [ebx+136]
	add	eax, -30001				; ffff8acfH
	fst	QWORD PTR _v$92808[ebp]
	cmp	eax, 4
	ja	$LN109@more_other
	jmp	DWORD PTR $LN1444@more_other[eax*4]
$LN1397@more_other:

; 4900 :          { case ASSIGN_OP: v = *(stacktop--); break;

	mov	eax, DWORD PTR [esi+48]

; 4910 :                }
; 4911 :              v /= *(stacktop--); 

	fstp	ST(0)
	fld	QWORD PTR [eax]
	jmp	$LN1421@more_other
$LN107@more_other:

; 4901 :            case PLUSASSIGN_OP: v += *(stacktop--); break;

	mov	eax, DWORD PTR [esi+48]
	fadd	QWORD PTR [eax]
	jmp	$LN1421@more_other
$LN106@more_other:

; 4902 :            case SUBASSIGN_OP: v -= *(stacktop--); break;

	mov	eax, DWORD PTR [esi+48]
	fsub	QWORD PTR [eax]
	jmp	$LN1421@more_other
$LN105@more_other:

; 4903 :            case MULTASSIGN_OP: v *= *(stacktop--); break;

	mov	eax, DWORD PTR [esi+48]
	fmul	QWORD PTR [eax]
	jmp	SHORT $LN1421@more_other
$LN104@more_other:

; 4904 :            case DIVASSIGN_OP:
; 4905 :              if ( *stacktop == 0.0 )

	mov	edx, DWORD PTR [esi+48]
	fld	QWORD PTR [edx]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN103@more_other

; 4906 :                { sprintf(errmsg,"Division by zero.\n");

	push	OFFSET ??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@
	fstp	ST(0)
	push	OFFSET _errmsg
	call	_sprintf

; 4907 :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4908 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1301@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1301@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 4909 :                  kb_error(2488,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2488					; 000009b8H
	call	_kb_error
	fld	QWORD PTR _v$92808[ebp]
	add	esp, 28					; 0000001cH
$LN103@more_other:

; 4910 :                }
; 4911 :              v /= *(stacktop--); 

	mov	eax, DWORD PTR [esi+48]
	fdiv	QWORD PTR [eax]
$LN1421@more_other:
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [esi+48], eax
$LN109@more_other:

; 4912 :              break;
; 4913 :          } 
; 4914 :         METH_INSTANCE(node->op1.meth_id)->modulus = v;

	mov	eax, DWORD PTR [ebx+32]
	mov	ecx, DWORD PTR _meth_inst_list
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	pop	edi
	pop	esi
	fstp	QWORD PTR [eax+ecx+304]
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN102@more_other:

; 4915 :      }
; 4916 :      break;
; 4917 : 
; 4918 :     case SET_QVOLCONST_NODE:
; 4919 :       { struct gen_quant *q =
; 4920 :              GEN_QUANT(node->op1.quant_id);

	mov	edi, DWORD PTR [ebx+32]

; 4921 :          switch ( node->op2.assigntype )

	mov	eax, DWORD PTR [ebx+136]
	imul	edi, 368				; 00000170H
	add	edi, DWORD PTR _gen_quant_list
	add	eax, -30001				; ffff8acfH
	cmp	eax, 4
	ja	$LN100@more_other
	jmp	DWORD PTR $LN1445@more_other[eax*4]
$LN99@more_other:

; 4922 :          { case ASSIGN_OP: q->volconst = *(stacktop--); break;

	mov	edx, DWORD PTR [esi+48]
	fld	QWORD PTR [edx]
	jmp	$LN1422@more_other
$LN98@more_other:

; 4923 :            case PLUSASSIGN_OP: q->volconst += *(stacktop--); break;

	mov	eax, DWORD PTR [esi+48]
	fld	QWORD PTR [eax]
	fadd	QWORD PTR [edi+208]
	jmp	$LN1422@more_other
$LN97@more_other:

; 4924 :            case SUBASSIGN_OP: q->volconst -= *(stacktop--); break;

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [edi+208]
	fsub	QWORD PTR [ecx]
	jmp	$LN1422@more_other
$LN96@more_other:

; 4925 :            case MULTASSIGN_OP: q->volconst *= *(stacktop--); break;

	mov	edx, DWORD PTR [esi+48]
	fld	QWORD PTR [edx]
	fmul	QWORD PTR [edi+208]
	jmp	SHORT $LN1422@more_other
$LN95@more_other:

; 4926 :            case DIVASSIGN_OP:
; 4927 :              if ( *stacktop == 0.0 )

	mov	eax, DWORD PTR [esi+48]
	fld	QWORD PTR [eax]
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN94@more_other

; 4928 :                { sprintf(errmsg,"Division by zero.\n");

	push	OFFSET ??_C@_0BD@KKBNAHFA@Division?5by?5zero?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 4929 :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4930 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1302@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1302@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 4931 :                  kb_error(2489,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2489					; 000009b9H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN94@more_other:

; 4932 :                }
; 4933 :              q->volconst /= *(stacktop--); 

	mov	ecx, DWORD PTR [esi+48]
	fld	QWORD PTR [edi+208]
	fdiv	QWORD PTR [ecx]
$LN1422@more_other:
	fstp	QWORD PTR [edi+208]
	add	DWORD PTR [esi+48], -8			; fffffff8H
$LN100@more_other:

; 4934 :              break;
; 4935 :          } 
; 4936 :          if ( valid_id(q->b_id) )

	mov	eax, DWORD PTR [edi+216]
	test	eax, 268435456				; 10000000H
	je	$LN626@more_other

; 4937 :               set_body_volconst(q->b_id,q->volconst);

	fld	QWORD PTR [edi+208]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	eax
	call	_set_body_volconst
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN92@more_other:

; 4938 :       }
; 4939 :     break;
; 4940 : 
; 4941 :     case RUNGE_KUTTA_NODE:
; 4942 :          old = runge_kutta_flag;

	mov	esi, DWORD PTR _runge_kutta_flag

; 4943 :          runge_kutta_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _runge_kutta_flag, eax

; 4944 :          outstring(runge_kutta_flag ? "Runge-Kutta ON." :
; 4945 :                                             "Runge-Kutta OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BA@PMBHOBAE@Runge?9Kutta?5ON?4?$AA@
	jne	SHORT $LN943@more_other
	mov	eax, OFFSET ??_C@_0BB@IPOGGIKD@Runge?9Kutta?5OFF?4?$AA@
$LN943@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 4946 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN945@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN945@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN91@more_other:

; 4947 :          break;
; 4948 : 
; 4949 :     case CHECK_INCREASE_NODE: 
; 4950 :          old = check_increase_flag;

	mov	esi, DWORD PTR _check_increase_flag

; 4951 :          check_increase_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _check_increase_flag, eax

; 4952 :          outstring(check_increase_flag?"Increase check ON.":
; 4953 :                           "Increase check OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BD@IPGDEDIG@Increase?5check?5ON?4?$AA@
	jne	SHORT $LN947@more_other
	mov	eax, OFFSET ??_C@_0BE@IMCDPOAN@Increase?5check?5OFF?4?$AA@
$LN947@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 4954 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN949@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN949@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN90@more_other:

; 4955 :          break;
; 4956 : 
; 4957 :     case HOMOTHETY_NODE:
; 4958 :          old = web.homothety;

	mov	esi, DWORD PTR _web+904

; 4959 :          web.homothety = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _web+904, eax

; 4960 :          if ( web.homothety && (web.skel[BODY].count == 0) )

	test	eax, eax
	je	$LN950@more_other
	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN89@more_other

; 4961 :           { web.homothety = 0;
; 4962 :             sprintf(errmsg,"Cannot do homothety without bodies.\n");

	push	OFFSET ??_C@_0CF@KHOFMLFP@Cannot?5do?5homothety?5without?5bodi@
	push	OFFSET _errmsg
	mov	DWORD PTR _web+904, 0
	call	_sprintf

; 4963 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 4964 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL1303@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1303@more_other
	mov	ecx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 4965 :             kb_error(1233,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1233					; 000004d1H
	call	_kb_error
	mov	eax, DWORD PTR _web+904
	add	esp, 28					; 0000001cH
$LN89@more_other:

; 4966 :           }
; 4967 :          sprintf(msg,"Homothety adjustment is %s.",
; 4968 :                           web.homothety ? "ON" : "OFF");

	test	eax, eax
	mov	eax, OFFSET ??_C@_02BFICIOJL@ON?$AA@
	jne	SHORT $LN951@more_other
$LN950@more_other:
	mov	eax, OFFSET ??_C@_03MPPIHBHJ@OFF?$AA@
$LN951@more_other:
	push	eax
	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0BM@EIKAOGMF@Homothety?5adjustment?5is?5?$CFs?4?$AA@
	push	eax
	call	_sprintf

; 4969 :          outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 16					; 00000010H

; 4970 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN953@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN953@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 4971 :          if ( web.homothety )

	cmp	DWORD PTR _web+904, 0
	je	$LN626@more_other

; 4972 :             { sprintf(msg,"Enter target size (%g): ",(DOUBLE)homothety_target);

	fld	QWORD PTR _homothety_target
	mov	edx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BJ@NLHBFEJL@Enter?5target?5size?5?$CI?$CFg?$CJ?3?5?$AA@
	push	edx
	call	_sprintf

; 4973 :               prompt(msg,response,sizeof(response));

	mov	ecx, DWORD PTR _msg
	push	1000					; 000003e8H
	lea	eax, DWORD PTR _response$[ebp]
	push	eax
	push	ecx
	call	_prompt

; 4974 :               const_expr(response,&homothety_target);

	lea	edx, DWORD PTR _response$[ebp]
	push	OFFSET _homothety_target
	push	edx
	call	_const_expr
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN87@more_other:

; 4975 :             }
; 4976 :          break;
; 4977 : 
; 4978 :     case COUNTS_NODE: /* report count of elements and status */
; 4979 :          memory_report();

	call	_memory_report
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN86@more_other:

; 4980 :          break;
; 4981 : 
; 4982 :     case EXTRAPOLATE_NODE: extrapolate(); break;

	call	_extrapolate
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN85@more_other:

; 4983 : 
; 4984 :     case DIFFUSION_NODE: /* Set diffusion */
; 4985 :          old = web.diffusion_flag;

	mov	esi, DWORD PTR _web+780

; 4986 :          web.diffusion_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _web+780, eax

; 4987 :          outstring(web.diffusion_flag ? "Diffusion ON." :
; 4988 :                                             "Diffusion OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0O@KKGGCNAE@Diffusion?5ON?4?$AA@
	jne	SHORT $LN955@more_other
	mov	eax, OFFSET ??_C@_0P@IPLABJGP@Diffusion?5OFF?4?$AA@
$LN955@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 4989 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN957@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN957@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN84@more_other:

; 4990 :             break;
; 4991 : 
; 4992 :     case AUTODISPLAY_NODE: 
; 4993 :       old = go_display_flag;

	mov	esi, DWORD PTR _go_display_flag

; 4994 :       go_display_flag = (node->op1.toggle_state == ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _go_display_flag, eax

; 4995 :       outstring(go_display_flag ? "Autodisplay ON." :
; 4996 :                                             "Autodisplay OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BA@GEMEOGHC@Autodisplay?5ON?4?$AA@
	jne	SHORT $LN959@more_other
	mov	eax, OFFSET ??_C@_0BB@DGBIGPKN@Autodisplay?5OFF?4?$AA@
$LN959@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 4997 :       outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN961@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN961@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 4998 :       if ( go_display_flag ) update_display();

	cmp	DWORD PTR _go_display_flag, 0
	je	$LN626@more_other

; 4999 :       break;

	jmp	$LN1425@more_other
$LN82@more_other:

; 5000 : 
; 5001 :     case SHOW_INNER_NODE: 
; 5002 :       old = innerflag;

	mov	esi, DWORD PTR _innerflag

; 5003 :       innerflag = (node->op1.toggle_state == ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _innerflag, eax

; 5004 :       outstring(innerflag ? "show inner ON." : "show inner OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0P@OPKHPDBB@show?5inner?5ON?4?$AA@
	jne	$LN635@more_other
	mov	eax, OFFSET ??_C@_0BA@OCCIDMFK@show?5inner?5OFF?4?$AA@

; 5005 :       outstring(old?" (was on)\n":" (was off)\n");
; 5006 :       update_display();
; 5007 :       break;

	jmp	$LN635@more_other
$LN81@more_other:

; 5008 : 
; 5009 :     case SHOW_OUTER_NODE: 
; 5010 :       old = outerflag;

	mov	esi, DWORD PTR _outerflag

; 5011 :       outerflag = (node->op1.toggle_state == ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _outerflag, eax

; 5012 :       outstring(outerflag ? "show outer ON." : "show outer OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0P@CBFHHCBJ@show?5outer?5ON?4?$AA@
	jne	$LN635@more_other
	mov	eax, OFFSET ??_C@_0BA@OMDNEEOJ@show?5outer?5OFF?4?$AA@

; 5013 :       outstring(old?" (was on)\n":" (was off)\n");
; 5014 :       update_display();
; 5015 :       break;

	jmp	$LN635@more_other
$LN80@more_other:

; 5016 : 
; 5017 :     case INTERP_NORMALS_NODE: 
; 5018 :       normflag = (node->op1.toggle_state == ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	pop	edi
	sete	al
	pop	esi
	pop	ebx
	mov	DWORD PTR _normflag, eax

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN79@more_other:

; 5019 :       break;
; 5020 : 
; 5021 :     case COLORMAP_NODE: 
; 5022 :       colorflag = (node->op1.toggle_state == ON_) ? 1 : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	pop	edi
	sete	cl
	pop	esi
	pop	ebx
	mov	DWORD PTR _colorflag, ecx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN78@more_other:

; 5023 :       break;
; 5024 : 
; 5025 :     case AMBIENT_PRESSURE_NODE: 
; 5026 :       web.pressure_flag = (node->op1.toggle_state == ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _web+868, eax

; 5027 :       if ( web.pressure_flag)

	test	eax, eax
	je	SHORT $LN77@more_other

; 5028 :        { if ( !web.full_flag && !valid_id(web.outside_body) )

	cmp	DWORD PTR _web+864, 0
	jne	SHORT $LN76@more_other
	test	DWORD PTR _web+1504, 268435456		; 10000000H
	jne	SHORT $LN76@more_other

; 5029 :              add_outside();

	call	_add_outside
$LN76@more_other:

; 5030 :          web.projection_flag = 0;
; 5031 :          sprintf(msg,"Ambient pressure ON; ambient pressure = %2.15g\n",
; 5032 :                     (double)web.pressure);

	fld	QWORD PTR _web+1536
	mov	edx, DWORD PTR _msg
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0DA@JMHNCEHN@Ambient?5pressure?5ON?$DL?5ambient?5pre@
	push	edx
	mov	DWORD PTR _web+872, 0
	call	_sprintf
	add	esp, 16					; 00000010H

; 5033 :        }
; 5034 :       else

	jmp	SHORT $LN75@more_other
$LN77@more_other:

; 5035 :        {
; 5036 :          web.projection_flag = 1;
; 5037 :          sprintf(msg,"Ambient pressure OFF.\n");

	mov	eax, DWORD PTR _msg
	push	OFFSET ??_C@_0BH@LECDGDFK@Ambient?5pressure?5OFF?4?6?$AA@
	push	eax
	mov	DWORD PTR _web+872, 1
	call	_sprintf
	add	esp, 8
$LN75@more_other:

; 5038 :        }
; 5039 :       calc_energy();

	call	_calc_energy

; 5040 :       outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@more_other:

; 5041 :       break;
; 5042 : 
; 5043 :     case EFFECTIVE_AREA_NODE:
; 5044 :          if ( SDIM > 3 )

	cmp	DWORD PTR _web+616, 3
	jle	SHORT $LN73@more_other

; 5045 :          { sprintf(errmsg,"effective_area only for dimension 3.\n");

	push	OFFSET ??_C@_0CG@IOBGAJKP@effective_area?5only?5for?5dimensio@
	push	OFFSET _errmsg
	call	_sprintf

; 5046 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 5047 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL1304@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1304@more_other
	mov	ecx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 5048 :            kb_error(2051,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2051					; 00000803H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN73@more_other:

; 5049 :          }
; 5050 :          old = effective_area_flag;

	mov	esi, DWORD PTR _effective_area_flag

; 5051 :          effective_area_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _effective_area_flag, eax

; 5052 :          outstring(effective_area_flag ? "effective_area ON." :
; 5053 :                                             "effective_area OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BD@EJHMJHLD@effective_area?5ON?4?$AA@
	jne	SHORT $LN971@more_other
	mov	eax, OFFSET ??_C@_0BE@NKFGCFPK@effective_area?5OFF?4?$AA@
$LN971@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 5054 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN973@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN973@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 5055 :          if ( effective_area_flag ) web.area_norm_flag = 1;

	cmp	DWORD PTR _effective_area_flag, 0
	je	SHORT $LN72@more_other
	mov	DWORD PTR _web+876, 1
$LN72@more_other:

; 5056 :          if ( square_curvature_flag ) calc_energy();

	cmp	DWORD PTR _square_curvature_flag, 0
	je	$LN626@more_other
	call	_calc_energy
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN70@more_other:

; 5057 :          break;
; 5058 : 
; 5059 :     case NORMAL_CURVATURE_NODE:
; 5060 :          if ( SDIM != 3 )

	cmp	DWORD PTR _web+616, 3
	je	SHORT $LN69@more_other

; 5061 :          { sprintf(errmsg,"Normal_curvature only for dimension 3.\n");

	push	OFFSET ??_C@_0CI@LJHBFOKD@Normal_curvature?5only?5for?5dimens@
	push	OFFSET _errmsg
	call	_sprintf

; 5062 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 5063 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL1305@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1305@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 5064 :            kb_error(2052,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2052					; 00000804H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN69@more_other:

; 5065 :          }
; 5066 :          old = normal_curvature_flag;

	mov	esi, DWORD PTR _normal_curvature_flag

; 5067 :          normal_curvature_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _normal_curvature_flag, eax

; 5068 :          outstring(normal_curvature_flag ? "normal_curvature ON." :
; 5069 :                                             "normal_curvature OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BF@FLINIKLP@normal_curvature?5ON?4?$AA@
	jne	SHORT $LN975@more_other
	mov	eax, OFFSET ??_C@_0BG@NDPCJIMM@normal_curvature?5OFF?4?$AA@
$LN975@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 5070 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN977@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN977@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 5071 :          if ( square_curvature_flag ) calc_energy();
; 5072 :          break;

	jmp	$LN72@more_other
$LN67@more_other:

; 5073 : 
; 5074 :     case DIV_NORMAL_CURVATURE_NODE:
; 5075 :          if ( SDIM != 3 )

	cmp	DWORD PTR _web+616, 3
	je	SHORT $LN66@more_other

; 5076 :          { sprintf(errmsg,"Div_normal_curvature only for dimension 3.\n");

	push	OFFSET ??_C@_0CM@KAJBDCJO@Div_normal_curvature?5only?5for?5di@
	push	OFFSET _errmsg
	call	_sprintf

; 5077 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 5078 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL1306@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1306@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 5079 :            kb_error(2053,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2053					; 00000805H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN66@more_other:

; 5080 :          }
; 5081 :          old = div_normal_curvature_flag;

	mov	esi, DWORD PTR _div_normal_curvature_flag

; 5082 :          div_normal_curvature_flag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _div_normal_curvature_flag, eax

; 5083 :          outstring(div_normal_curvature_flag ? "div_normal_curvature ON." :
; 5084 :                                             "div_normal_curvature OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BJ@NMGOBDGL@div_normal_curvature?5ON?4?$AA@
	jne	SHORT $LN979@more_other
	mov	eax, OFFSET ??_C@_0BK@FCMLGNJI@div_normal_curvature?5OFF?4?$AA@
$LN979@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 5085 :          outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN981@more_other
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN981@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 5086 :          if ( square_curvature_flag ) calc_energy();
; 5087 :          break;

	jmp	$LN72@more_other
$LN64@more_other:

; 5088 : 
; 5089 :     case LONG_JIGGLE_NODE: 
; 5090 :          long_jiggle();

	call	_long_jiggle
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@more_other:

; 5091 :          break;
; 5092 : 
; 5093 :     case RAW_VERAVG_NODE:
; 5094 :          vertex_average(NOVOLKEEP);

	push	0
	call	_vertex_average

; 5095 :          recalc();

	call	_recalc

; 5096 :          outstring("Vertex averaging done.\n");

	push	OFFSET ??_C@_0BI@DCKMBCPP@Vertex?5averaging?5done?4?6?$AA@
	call	_outstring
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@more_other:

; 5097 :          break;
; 5098 : 
; 5099 :     case RAWEST_VERAVG_NODE:
; 5100 :          vertex_average(RAWEST);

	push	2
	call	_vertex_average

; 5101 :          recalc();

	call	_recalc

; 5102 :          outstring("Vertex averaging done.\n");

	push	OFFSET ??_C@_0BI@DCKMBCPP@Vertex?5averaging?5done?4?6?$AA@
	call	_outstring
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN60@more_other:

; 5103 :          break;
; 5104 : 
; 5105 :     case TEXT_SPOT_NODE: /* just accumulate arguments */
; 5106 :     case TEXT_SIZE_NODE:
; 5107 :          break;
; 5108 : 
; 5109 :     case DISPLAY_TEXT_NODE:
; 5110 :          { char *text = *(char**)(stacktop--);

	mov	eax, DWORD PTR [esi+48]

; 5111 :            REAL text_size = *(stacktop--);

	fld	QWORD PTR [eax-8]
	mov	ecx, DWORD PTR [eax]
	fstp	QWORD PTR _text_size$92898[ebp]

; 5112 :            REAL yspot = *(stacktop--);
; 5113 :            REAL xspot = *(stacktop--);

	add	eax, -32				; ffffffe0H
	fld	QWORD PTR [eax+16]
	mov	DWORD PTR [esi+48], eax
	fstp	QWORD PTR _yspot$92899[ebp]
	mov	DWORD PTR _text$92896[ebp], ecx
	fld	QWORD PTR [eax+8]

; 5114 : 
; 5115 :            int length = (int)strlen(text);

	mov	eax, ecx
	fstp	QWORD PTR _xspot$92900[ebp]
	lea	edx, DWORD PTR [eax+1]
$LL1307@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1307@more_other
	sub	eax, edx

; 5116 :            int text_id;
; 5117 :            
; 5118 :            for ( text_id = 0 ; text_id < MAXTEXTS ; text_id++ )

	xor	edi, edi
	mov	ecx, OFFSET _text_chunks
$LL1308@more_other:

; 5119 :            { if ( text_chunks[text_id].text == NULL )

	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN1049@more_other

; 5116 :            int text_id;
; 5117 :            
; 5118 :            for ( text_id = 0 ; text_id < MAXTEXTS ; text_id++ )

	add	ecx, 32					; 00000020H
	inc	edi
	cmp	ecx, OFFSET _text_chunks+3200
	jl	SHORT $LL1308@more_other

; 5193 :              if ( warnings_suppressed[i] == wnum )

	jmp	SHORT $LN57@more_other
$LN1049@more_other:

; 5120 :              { text_chunks[text_id].text =
; 5121 :                  (char*)mycalloc(length+1,1);

	push	5121					; 00001401H
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	inc	eax
	push	1
	push	eax
	call	_kb_calloc
	mov	ecx, edi
	add	esp, 16					; 00000010H
	shl	ecx, 5
	mov	DWORD PTR _text_chunks[ecx], eax
$LN57@more_other:

; 5122 :                break;
; 5123 :              }
; 5124 :            }
; 5125 :              
; 5126 :            if ( text_id >= MAXTEXTS-1 )

	cmp	edi, 99					; 00000063H
	jl	SHORT $LN55@more_other

; 5127 :            { sprintf(errmsg,"Too many display texts.\n");

	push	OFFSET ??_C@_0BJ@MHNCMPKC@Too?5many?5display?5texts?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 5128 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 5129 :                                 file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1309@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1309@more_other
	mov	ecx, DWORD PTR [ebx+16]
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 5130 :              kb_error(4998,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	4998					; 00001386H
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN55@more_other:

; 5131 :              break;
; 5132 :            }
; 5133 :            
; 5134 :            strcpy(text_chunks[text_id].text,text);

	mov	edx, DWORD PTR _text$92896[ebp]
	mov	eax, edi
	shl	eax, 5
	mov	ebx, DWORD PTR _text_chunks[eax]
$LL1310@more_other:
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [ebx], cl
	inc	edx
	inc	ebx
	test	cl, cl
	jne	SHORT $LL1310@more_other

; 5135 :            text_chunks[text_id].start_x = xspot;

	fld	QWORD PTR _xspot$92900[ebp]

; 5136 :            text_chunks[text_id].start_y = yspot;
; 5137 :            text_chunks[text_id].vsize = text_size;
; 5138 :            display_text_count++;

	inc	DWORD PTR _display_text_count
	fstp	QWORD PTR _text_chunks[eax+8]
	fld	QWORD PTR _yspot$92899[ebp]
	fstp	QWORD PTR _text_chunks[eax+16]
	fld	QWORD PTR _text_size$92898[ebp]
	fstp	QWORD PTR _text_chunks[eax+24]

; 5139 :            *(++stacktop) = text_id+1;

	add	DWORD PTR [esi+48], 8
	mov	esi, DWORD PTR [esi+48]

; 5140 :            *recalc_flag = 1;

	mov	eax, DWORD PTR _recalc_flag$GSCopy$[ebp]
	inc	edi
	mov	DWORD PTR tv8608[ebp], edi
	fild	DWORD PTR tv8608[ebp]
	pop	edi
	fstp	QWORD PTR [esi]
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@more_other:

; 5142 :          }
; 5143 :            
; 5144 :     case DELETE_TEXT_NODE:
; 5145 :       { int text_id = (int)*(stacktop--) - 1;

	mov	eax, DWORD PTR [esi+48]
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	mov	edi, eax
	dec	edi
	mov	eax, DWORD PTR [esi+48]
	lea	eax, DWORD PTR [eax-8]
	mov	DWORD PTR [esi+48], eax

; 5146 :         if ( (text_id < 0) || (text_id >= MAXTEXTS) )

	js	SHORT $LN52@more_other
	cmp	edi, 100				; 00000064H
	jl	SHORT $LN1257@more_other
$LN52@more_other:

; 5147 :         { sprintf(errmsg,"Text id must be between 1 and %d.\n",MAXTEXTS);

	push	100					; 00000064H
	push	OFFSET ??_C@_0CD@POBIGEFP@Text?5id?5must?5be?5between?51?5and?5?$CFd@
	push	OFFSET _errmsg
	call	_sprintf

; 5148 :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 5149 :                                 file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1311@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1311@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 5150 :           kb_error(7543,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	7543					; 00001d77H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1257@more_other:

; 5151 :         }
; 5152 :         if ( text_chunks[text_id].text )

	shl	edi, 5
	mov	eax, DWORD PTR _text_chunks[edi]
	lea	edi, DWORD PTR _text_chunks[edi]
	test	eax, eax
	je	$LN626@more_other

; 5153 :         { myfree(text_chunks[text_id].text);

	push	eax
	call	_myfree

; 5154 :           text_chunks[text_id].text = NULL;
; 5155 :           display_text_count--;
; 5156 :           *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	add	esp, 4
	dec	DWORD PTR _display_text_count
	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@more_other:

; 5157 :         }
; 5158 :         break;  
; 5159 :       }
; 5160 :       
; 5161 :     case REBODY_NODE:
; 5162 :       { body_id b_id;
; 5163 :         sprintf(msg,"New bodies: %d\n",rebody());

	call	_rebody
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BA@HMCCKFKD@New?5bodies?3?5?$CFd?6?$AA@
	push	edx
	call	_sprintf

; 5164 :         outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring

; 5165 :         sprintf(msg,"Merged bodies: %d\n",merge_bodies());

	call	_merge_bodies
	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0BD@FDJMMAJJ@Merged?5bodies?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf

; 5166 :         outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 5167 :         calc_content(Q_FIXED|Q_INFO);

	push	6
	call	_calc_content
	fstp	ST(0)

; 5168 :         FOR_ALL_BODIES(b_id)

	mov	edi, DWORD PTR _web+384
	add	esp, 36					; 00000024H
	test	edi, 268435456				; 10000000H
	je	$LN626@more_other
	mov	ebx, DWORD PTR _web+348
$LL1312@more_other:
	mov	esi, edi
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ebx]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR tv7426[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	je	SHORT $LN48@more_other

; 5169 :             if ( get_battr(b_id) & FIXEDVOL )  

	and	ecx, 32					; 00000020H
	xor	eax, eax
	or	ecx, eax
	je	SHORT $LN48@more_other

; 5170 :               set_body_fixvol(b_id,get_body_volume(b_id));

	push	edi
	call	_get_body_volume
	push	ecx
	fstp	QWORD PTR [esp]
	push	edi
	call	_set_body_fixvol
	mov	ebx, DWORD PTR _web+348
	add	esp, 12					; 0000000cH
$LN48@more_other:

; 5168 :         FOR_ALL_BODIES(b_id)

	mov	ecx, DWORD PTR [esi+ebx]
	mov	edi, DWORD PTR [ecx]
	test	edi, 268435456				; 10000000H
	jne	SHORT $LL1312@more_other
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@more_other:

; 5171 :          break;
; 5172 :       } 
; 5173 : 
; 5174 :     case SUPPRESS_WARNING_NODE:
; 5175 :         { int wnum = (int)*(stacktop--);

	mov	edi, DWORD PTR [esi+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	add	edi, -8					; fffffff8H
	mov	DWORD PTR [esi+48], edi

; 5176 :           // check for existing suppression
; 5177 :           for ( i = 0 ; i < warnings_suppressed_count ; i++ )

	mov	edx, DWORD PTR _warnings_suppressed_count
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN1050@more_other
$LL1313@more_other:

; 5178 :             if ( warnings_suppressed[i] == wnum )

	cmp	DWORD PTR _warnings_suppressed[ecx*4], eax
	je	SHORT $LN1050@more_other

; 5176 :           // check for existing suppression
; 5177 :           for ( i = 0 ; i < warnings_suppressed_count ; i++ )

	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LL1313@more_other
$LN1050@more_other:

; 5179 :               break;
; 5180 :           if ( i == warnings_suppressed_count )

	cmp	ecx, edx
	jne	$LN626@more_other

; 5181 :           { // need to install new suppression
; 5182 :             if ( warnings_suppressed_count < MAXSUPPRESS )

	cmp	edx, 100				; 00000064H
	jge	SHORT $LN37@more_other

; 5183 :               warnings_suppressed[warnings_suppressed_count++] = wnum;

	pop	edi
	mov	DWORD PTR _warnings_suppressed[edx*4], eax
	inc	edx
	pop	esi
	mov	DWORD PTR _warnings_suppressed_count, edx
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@more_other:

; 5184 :             else
; 5185 :               kb_error(4535,"Too many warnings suppressed.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0BP@EAFIIJC@Too?5many?5warnings?5suppressed?4?6?$AA@
	push	4535					; 000011b7H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@more_other:

; 5186 :           }
; 5187 :         }
; 5188 :         break;
; 5189 : 
; 5190 :     case UNSUPPRESS_WARNING_NODE:
; 5191 :         { int wnum = (int)*(stacktop--);

	mov	edi, DWORD PTR [esi+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	add	edi, -8					; fffffff8H
	mov	DWORD PTR [esi+48], edi

; 5192 :            for ( i = 0 ; i < warnings_suppressed_count ; i++ )

	mov	edx, DWORD PTR _warnings_suppressed_count
	xor	ecx, ecx
	test	edx, edx
	jle	$LN626@more_other
$LL1314@more_other:

; 5193 :              if ( warnings_suppressed[i] == wnum )

	cmp	DWORD PTR _warnings_suppressed[ecx*4], eax
	je	SHORT $LN1051@more_other

; 5192 :            for ( i = 0 ; i < warnings_suppressed_count ; i++ )

	inc	ecx
	cmp	ecx, edx
	jl	SHORT $LL1314@more_other
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1051@more_other:

; 5194 :                { warnings_suppressed[i] = 
; 5195 :                       warnings_suppressed[--warnings_suppressed_count];

	dec	edx
	pop	edi
	mov	DWORD PTR _warnings_suppressed_count, edx
	mov	edx, DWORD PTR _warnings_suppressed[edx*4]
	pop	esi
	mov	DWORD PTR _warnings_suppressed[ecx*4], edx
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@more_other:

; 5196 :                  break;
; 5197 :                }          
; 5198 :          }
; 5199 :          break; 
; 5200 : 
; 5201 :     case ALICE_NODE:      
; 5202 :          alice();

	call	_alice
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN29@more_other:

; 5203 :          break;
; 5204 : 
; 5205 :     case BURCHARD_NODE:      
; 5206 :          burchard(node->op1.maxsteps);

	mov	eax, DWORD PTR [ebx+32]
	push	eax
	call	_burchard
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@more_other:

; 5207 :          break;
; 5208 : 
; 5209 :     case DUMP_NODE:
; 5210 :          if ( node->left ) do_dump(*(char**)(stacktop--));

	cmp	DWORD PTR [ebx+4], 0
	je	SHORT $LN27@more_other
	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	push	ecx
	mov	DWORD PTR [esi+48], eax
	call	_do_dump
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@more_other:

; 5211 :          else do_dump(NULL);

	push	0
	call	_do_dump
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@more_other:

; 5212 :          break;
; 5213 : 
; 5214 :     case SET_COLORMAP_NODE:
; 5215 :          strncpy(cmapname,*(char**)(stacktop--),sizeof(cmapname));

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [eax]
	push	1000					; 000003e8H
	push	ecx
	add	eax, -8					; fffffff8H
	push	OFFSET _cmapname
	mov	DWORD PTR [esi+48], eax
	call	_strncpy
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@more_other:

; 5216 :          break;
; 5217 : 
; 5218 :     case RAW_CELLS_NODE: 
; 5219 :          web.torus_body_flag = 0; web.torus_clip_flag = 0;

	xor	eax, eax
	mov	DWORD PTR _web+804, eax
	mov	DWORD PTR _web+800, eax

; 5220 :          torus_display_mode = TORUS_RAW_MODE;

	mov	DWORD PTR _torus_display_mode, 1

; 5221 :          update_display();
; 5222 :          break;

	jmp	$LN1425@more_other
$LN23@more_other:

; 5223 : 
; 5224 :     case CONNECTED_CELLS_NODE: 
; 5225 :          if ( web.skel[BODY].count == 0 )

	cmp	DWORD PTR _web+400, 0
	jne	SHORT $LN22@more_other

; 5226 :          {  sprintf(errmsg,"There are no bodies to display connectedly.\n");

	push	OFFSET ??_C@_0CN@JFJCLEGG@There?5are?5no?5bodies?5to?5display?5c@
	push	OFFSET _errmsg
	call	_sprintf

; 5227 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 5228 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL1315@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1315@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 5229 :             kb_error(1234,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	1234					; 000004d2H
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@more_other:

; 5230 :          }
; 5231 :          else { web.torus_body_flag = 1; web.torus_clip_flag = 0; 

	mov	DWORD PTR _web+804, 1
	mov	DWORD PTR _web+800, 0

; 5232 :                   torus_display_mode = TORUS_CONNECTED_MODE;

	mov	DWORD PTR _torus_display_mode, 2

; 5233 :                   update_display(); }
; 5234 :          break;

	jmp	$LN1425@more_other
$LN20@more_other:

; 5235 : 
; 5236 :     case CLIPPED_CELLS_NODE:
; 5237 :          if ( !web.torus_flag && !web.torus_display_period ) 

	cmp	DWORD PTR _web+860, 0
	jne	SHORT $LN19@more_other
	cmp	DWORD PTR _web+1620, 0
	jne	SHORT $LN19@more_other

; 5238 :          {  sprintf(errmsg,
; 5239 :                "CLIPPED mode has no effect since torus model not used.\n");

	push	OFFSET ??_C@_0DI@BIMKBCLE@CLIPPED?5mode?5has?5no?5effect?5since@
	push	OFFSET _errmsg
	call	_sprintf

; 5240 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 5241 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL1316@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1316@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 5242 :             kb_error(1254,errmsg, WARNING);

	push	2
	push	OFFSET _errmsg
	push	1254					; 000004e6H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN19@more_other:

; 5243 :          }
; 5244 :          torus_display_mode = TORUS_CLIPPED_MODE;

	mov	DWORD PTR _torus_display_mode, 3

; 5245 :          web.torus_body_flag = 0; web.torus_clip_flag = 1;

	mov	DWORD PTR _web+804, 0
	mov	DWORD PTR _web+800, 1

; 5246 :          update_display();
; 5247 :          break;

	jmp	$LN1425@more_other
$LN18@more_other:

; 5248 : 
; 5249 :     case THICKEN_NODE: 
; 5250 :       thickenflag = (node->op1.toggle_state == ON_) ? 1 : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	cl
	mov	DWORD PTR _thickenflag, ecx

; 5251 :          update_display();
; 5252 :          break;

	jmp	$LN1425@more_other
$LN17@more_other:

; 5253 : 
; 5254 :     case METRIC_CONVERT_NODE:
; 5255 :          metric_convert_flag = (node->op1.toggle_state == ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _metric_convert_flag, eax

; 5256 :          if ( metric_convert_flag )

	test	eax, eax
	je	SHORT $LN16@more_other

; 5257 :              outstring("Converting form to vector using metric.\n");

	push	OFFSET ??_C@_0CJ@IHPJGNJA@Converting?5form?5to?5vector?5using?5@
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@more_other:

; 5258 :          else outstring("Not using metric to convert form to vector.\n");

	push	OFFSET ??_C@_0CN@GJOHMOIJ@Not?5using?5metric?5to?5convert?5form@
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@more_other:

; 5259 :          break;
; 5260 : 
; 5261 :     case QUANTITIES_ONLY_NODE:
; 5262 :          old = quantities_only_flag;

	mov	esi, DWORD PTR _quantities_only_flag

; 5263 :          quantities_only_flag = (node->op1.toggle_state == ON_) ? 1 : 0;

	xor	edx, edx
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H

; 5264 :          outstring("Using quantities only ");

	push	OFFSET ??_C@_0BH@JOOMOIMF@Using?5quantities?5only?5?$AA@
	sete	dl
	mov	DWORD PTR _quantities_only_flag, edx
	call	_outstring
	add	esp, 4

; 5265 :          outstring(quantities_only_flag ? "ON.": "OFF.");

	cmp	DWORD PTR _quantities_only_flag, 0
	mov	eax, OFFSET ??_C@_03GMMPMBGO@ON?4?$AA@
	jne	SHORT $LN984@more_other
	mov	eax, OFFSET ??_C@_04CCBBDIMF@OFF?4?$AA@
$LN984@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 5266 :          outstring(old ? "(was ON)\n" : "(was OFF)\n");

	mov	eax, OFFSET ??_C@_09HOELGAGH@?$CIwas?5ON?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN986@more_other
	mov	eax, OFFSET ??_C@_0L@EAHJADDM@?$CIwas?5OFF?$CJ?6?$AA@
$LN986@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@more_other:

; 5267 :          break;
; 5268 : 
; 5269 :     case SQUARED_GRADIENT_NODE:
; 5270 :          old = min_square_grad_flag;

	mov	esi, DWORD PTR _min_square_grad_flag

; 5271 :          min_square_grad_flag = (node->op1.toggle_state == ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H

; 5272 :          outstring("Squared gradient minimization with Hessian ");

	push	OFFSET ??_C@_0CM@HLDCELF@Squared?5gradient?5minimization?5wi@
	sete	al
	mov	DWORD PTR _min_square_grad_flag, eax
	call	_outstring
	add	esp, 4

; 5273 :          outstring(min_square_grad_flag ? "ON.": "OFF.");

	cmp	DWORD PTR _min_square_grad_flag, 0
	mov	eax, OFFSET ??_C@_03GMMPMBGO@ON?4?$AA@
	jne	SHORT $LN988@more_other
	mov	eax, OFFSET ??_C@_04CCBBDIMF@OFF?4?$AA@
$LN988@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 5274 :          outstring(old ? "(was ON)\n" : "(was OFF)\n");

	mov	eax, OFFSET ??_C@_09HOELGAGH@?$CIwas?5ON?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN990@more_other
	mov	eax, OFFSET ??_C@_0L@EAHJADDM@?$CIwas?5OFF?$CJ?6?$AA@
$LN990@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@more_other:

; 5275 :          break;
; 5276 : 
; 5277 :     case LINEAR_METRIC_NODE:
; 5278 :          old = hessian_linear_metric_flag;

	mov	esi, DWORD PTR _hessian_linear_metric_flag

; 5279 :          hessian_linear_metric_flag = (node->op1.toggle_state == ON_) ? 1 : 0;

	xor	ecx, ecx
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H

; 5280 :          outstring("Linear interpolation metric with Hessian ");

	push	OFFSET ??_C@_0CK@FPPJMDP@Linear?5interpolation?5metric?5with@
	sete	cl
	mov	DWORD PTR _hessian_linear_metric_flag, ecx
	call	_outstring
	add	esp, 4

; 5281 :          outstring(hessian_linear_metric_flag ? "ON.": "OFF.");

	cmp	DWORD PTR _hessian_linear_metric_flag, 0
	mov	eax, OFFSET ??_C@_03GMMPMBGO@ON?4?$AA@
	jne	SHORT $LN992@more_other
	mov	eax, OFFSET ??_C@_04CCBBDIMF@OFF?4?$AA@
$LN992@more_other:
	push	eax
	call	_outstring
	add	esp, 4

; 5282 :          outstring(old ? "(was ON)\n" : "(was OFF)\n");

	mov	eax, OFFSET ??_C@_09HOELGAGH@?$CIwas?5ON?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN994@more_other
	mov	eax, OFFSET ??_C@_0L@EAHJADDM@?$CIwas?5OFF?$CJ?6?$AA@
$LN994@more_other:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@more_other:

; 5283 :          break;
; 5284 : 
; 5285 :     case MKL_NODE:
; 5286 : #ifndef MKL
; 5287 :       kb_error(7761,"This Evolver not enabled for MKL.\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CD@FMGOOMLP@This?5Evolver?5not?5enabled?5for?5MKL@
	push	7761					; 00001e51H
	call	_kb_error

; 5288 : #endif
; 5289 :       old = ysmp_flag;

	mov	eax, DWORD PTR _ysmp_flag

; 5290 :       ysmp_flag = 
; 5291 :           (node->op1.toggle_state == ON_) ? MKL_FACTORING : MINDEG_FACTORING;

	xor	ecx, ecx
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	setne	cl
	dec	ecx
	and	ecx, 3

; 5292 :       change_hessian_functions(old,ysmp_flag);

	push	ecx
	push	eax
	mov	DWORD PTR _ysmp_flag, ecx
	call	_change_hessian_functions
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@more_other:

; 5293 :       break;
; 5294 : 
; 5295 :     case YSMP_NODE: 
; 5296 :       old = ysmp_flag;

	mov	eax, DWORD PTR _ysmp_flag

; 5297 :       ysmp_flag = 
; 5298 :           (node->op1.toggle_state == ON_) ? YSMP_FACTORING : MINDEG_FACTORING;

	xor	ecx, ecx
	cmp	DWORD PTR [ebx+32], 15000		; 00003a98H
	sete	cl

; 5299 :       change_hessian_functions(old,ysmp_flag);

	push	ecx
	push	eax
	mov	DWORD PTR _ysmp_flag, ecx
	call	_change_hessian_functions
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@more_other:

; 5300 :       break;
; 5301 : 
; 5302 :     case METIS_FACTOR_NODE:
; 5303 :          old = ysmp_flag;

	mov	eax, DWORD PTR _ysmp_flag

; 5304 : #ifndef METIS 
; 5305 :          kb_error(2055,"This Evolver not compiled with METIS.\n",RECOVERABLE);
; 5306 : #else
; 5307 :          ysmp_flag = METIS_FACTORING;
; 5308 :          change_hessian_functions(old,ysmp_flag);

	push	2
	push	eax
	mov	DWORD PTR _ysmp_flag, 2
	call	_change_hessian_functions
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@more_other:

; 5309 : #endif
; 5310 :          break;
; 5311 : 
; 5312 :     case BUNCH_KAUFMAN_NODE:
; 5313 :           flip_toggle(&BK_flag,node->op1.toggle_state,
; 5314 :                  "Bunch-Kaufman version of minimal degree");

	mov	edx, DWORD PTR [ebx+32]
	push	OFFSET ??_C@_0CI@BCKCAMJI@Bunch?9Kaufman?5version?5of?5minimal@
	push	edx
	push	OFFSET _BK_flag
	call	_flip_toggle
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@more_other:

; 5315 :              break;
; 5316 : 
; 5317 :     case SET_PROC_END_NODE:
; 5318 :     case SET_FUNC_END_NODE:
; 5319 :     case SET_PERM_PROC_END_NODE:
; 5320 :     case SHOW_END_NODE:
; 5321 :     case ELSE_NODE:
; 5322 :     case COND_ELSE_NODE:
; 5323 :          /* just a continue node */
; 5324 :          break;
; 5325 : 
; 5326 :     case MAKE_THREAD_LISTS_NODE:
; 5327 :          if ( !threadflag )

	cmp	DWORD PTR _threadflag, 0
	je	$LN626@more_other

; 5328 :            break;
; 5329 :          if ( v_partition_stage_attr < 0 )

	cmp	DWORD PTR _v_partition_stage_attr, 0
	jge	SHORT $LN4@more_other

; 5330 :          { sprintf(errmsg,"make_thread_lists: stage and proc attributes don't exist.\n"); 

	push	OFFSET ??_C@_0DL@CGAPACAK@make_thread_lists?3?5stage?5and?5pro@
	push	OFFSET _errmsg
	call	_sprintf

; 5331 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 5332 :                                 file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL1317@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1317@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 5333 :             kb_error(5822,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5822					; 000016beH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN4@more_other:

; 5334 :          }
; 5335 :          make_thread_lists();

	call	_make_thread_lists
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@more_other:

; 5336 :          break;
; 5337 : 
; 5338 :     default:
; 5339 :             sprintf(errmsg,"Bad expression eval node type %d: %s.",
; 5340 :                 node->type,tokname(node->type));

	push	eax
	call	_tokname
	mov	ecx, DWORD PTR [ebx]
	push	eax
	push	ecx
	push	OFFSET ??_C@_0CG@KKIFLOID@Bad?5expression?5eval?5node?5type?5?$CFd@
	push	OFFSET _errmsg
	call	_sprintf

; 5341 :             if ( node->file_no >= 0 && node->file_no <= file_no_used )

	mov	edx, DWORD PTR [ebx+16]
	add	esp, 20					; 00000014H
	test	edx, edx
	js	SHORT $LN2@more_other
	cmp	edx, DWORD PTR _file_no_used
	jg	SHORT $LN2@more_other

; 5342 :               sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 5343 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	lea	esi, DWORD PTR [eax+1]
$LL1318@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1318@more_other
	mov	ecx, DWORD PTR [ebx+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	sub	eax, esi
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 5344 :             else

	jmp	SHORT $LN1@more_other
$LN2@more_other:

; 5345 :               sprintf(errmsg+strlen(errmsg),"(appears to be corrupt node)\n");

	mov	eax, OFFSET _errmsg
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL1319@more_other:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1319@more_other
	sub	eax, edx
	lea	ecx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BO@EPFFHJGJ@?$CIappears?5to?5be?5corrupt?5node?$CJ?6?$AA@
	push	ecx
	call	_sprintf
	add	esp, 8
$LN1@more_other:

; 5346 :             kb_error(1235,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1235					; 000004d3H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1342@more_other:

; 4638 :          switch ( node->op2.assigntype )

	fstp	ST(0)
$LN626@more_other:

; 5347 : 
; 5348 :             break;
; 5349 : 
; 5350 :   }
; 5351 : 
; 5352 : } /* end more_other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1405@more_other:
	npad	3
$LN1434@more_other:
	DD	$LN625@more_other
	DD	$LN622@more_other
	DD	$LN619@more_other
	DD	$LN618@more_other
	DD	$LN617@more_other
	DD	$LN616@more_other
	DD	$LN615@more_other
	DD	$LN614@more_other
	DD	$LN613@more_other
	DD	$LN612@more_other
	DD	$LN611@more_other
	DD	$LN610@more_other
	DD	$LN609@more_other
	DD	$LN608@more_other
	DD	$LN607@more_other
	DD	$LN606@more_other
	DD	$LN605@more_other
	DD	$LN603@more_other
	DD	$LN602@more_other
	DD	$LN601@more_other
	DD	$LN596@more_other
	DD	$LN595@more_other
	DD	$LN594@more_other
	DD	$LN591@more_other
	DD	$LN590@more_other
	DD	$LN589@more_other
	DD	$LN588@more_other
	DD	$LN587@more_other
	DD	$LN586@more_other
	DD	$LN585@more_other
	DD	$LN584@more_other
	DD	$LN578@more_other
	DD	$LN571@more_other
	DD	$LN566@more_other
	DD	$LN559@more_other
	DD	$LN554@more_other
	DD	$LN553@more_other
	DD	$LN552@more_other
	DD	$LN548@more_other
	DD	$LN544@more_other
	DD	$LN540@more_other
	DD	$LN539@more_other
	DD	$LN538@more_other
	DD	$LN534@more_other
	DD	$LN531@more_other
	DD	$LN530@more_other
	DD	$LN529@more_other
	DD	$LN528@more_other
	DD	$LN527@more_other
	DD	$LN526@more_other
	DD	$LN525@more_other
	DD	$LN524@more_other
	DD	$LN523@more_other
	DD	$LN522@more_other
	DD	$LN521@more_other
	DD	$LN519@more_other
	DD	$LN518@more_other
	DD	$LN517@more_other
	DD	$LN516@more_other
	DD	$LN515@more_other
	DD	$LN514@more_other
	DD	$LN513@more_other
	DD	$LN512@more_other
	DD	$LN511@more_other
	DD	$LN510@more_other
	DD	$LN509@more_other
	DD	$LN508@more_other
	DD	$LN507@more_other
	DD	$LN506@more_other
	DD	$LN503@more_other
	DD	$LN502@more_other
	DD	$LN500@more_other
	DD	$LN499@more_other
	DD	$LN498@more_other
	DD	$LN497@more_other
	DD	$LN496@more_other
	DD	$LN493@more_other
	DD	$LN491@more_other
	DD	$LN490@more_other
	DD	$LN489@more_other
	DD	$LN488@more_other
	DD	$LN487@more_other
	DD	$LN486@more_other
	DD	$LN485@more_other
	DD	$LN484@more_other
	DD	$LN482@more_other
	DD	$LN480@more_other
	DD	$LN478@more_other
	DD	$LN476@more_other
	DD	$LN474@more_other
	DD	$LN472@more_other
	DD	$LN471@more_other
	DD	$LN470@more_other
	DD	$LN459@more_other
	DD	$LN457@more_other
	DD	$LN456@more_other
	DD	$LN454@more_other
	DD	$LN453@more_other
	DD	$LN452@more_other
	DD	$LN449@more_other
	DD	$LN448@more_other
	DD	$LN446@more_other
	DD	$LN445@more_other
	DD	$LN444@more_other
	DD	$LN441@more_other
	DD	$LN440@more_other
	DD	$LN437@more_other
	DD	$LN626@more_other
	DD	$LN433@more_other
	DD	$LN429@more_other
	DD	$LN425@more_other
	DD	$LN421@more_other
	DD	$LN417@more_other
	DD	$LN415@more_other
	DD	$LN414@more_other
	DD	$LN414@more_other
	DD	$LN402@more_other
	DD	$LN399@more_other
	DD	$LN397@more_other
	DD	$LN397@more_other
	DD	$LN397@more_other
	DD	$LN353@more_other
	DD	$LN304@more_other
	DD	$LN301@more_other
	DD	$LN299@more_other
	DD	$LN296@more_other
	DD	$LN295@more_other
	DD	$LN294@more_other
	DD	$LN293@more_other
	DD	$LN292@more_other
	DD	$LN291@more_other
	DD	$LN290@more_other
	DD	$LN289@more_other
	DD	$LN288@more_other
	DD	$LN283@more_other
	DD	$LN282@more_other
	DD	$LN272@more_other
	DD	$LN271@more_other
	DD	$LN270@more_other
	DD	$LN270@more_other
	DD	$LN269@more_other
	DD	$LN268@more_other
	DD	$LN267@more_other
	DD	$LN264@more_other
	DD	$LN263@more_other
	DD	$LN260@more_other
	DD	$LN259@more_other
	DD	$LN258@more_other
	DD	$LN247@more_other
	DD	$LN227@more_other
	DD	$LN226@more_other
	DD	$LN225@more_other
	DD	$LN221@more_other
	DD	$LN209@more_other
	DD	$LN201@more_other
	DD	$LN193@more_other
	DD	$LN626@more_other
	DD	$LN191@more_other
	DD	$LN164@more_other
	DD	$LN163@more_other
	DD	$LN626@more_other
	DD	$LN151@more_other
	DD	$LN140@more_other
	DD	$LN130@more_other
	DD	$LN121@more_other
	DD	$LN111@more_other
	DD	$LN102@more_other
	DD	$LN92@more_other
	DD	$LN91@more_other
	DD	$LN90@more_other
	DD	$LN87@more_other
	DD	$LN86@more_other
	DD	$LN85@more_other
	DD	$LN84@more_other
	DD	$LN82@more_other
	DD	$LN81@more_other
	DD	$LN80@more_other
	DD	$LN79@more_other
	DD	$LN78@more_other
	DD	$LN74@more_other
	DD	$LN70@more_other
	DD	$LN67@more_other
	DD	$LN64@more_other
	DD	$LN63@more_other
	DD	$LN62@more_other
	DD	$LN626@more_other
	DD	$LN626@more_other
	DD	$LN60@more_other
	DD	$LN54@more_other
	DD	$LN50@more_other
	DD	$LN43@more_other
	DD	$LN35@more_other
	DD	$LN30@more_other
	DD	$LN29@more_other
	DD	$LN28@more_other
	DD	$LN25@more_other
	DD	$LN24@more_other
	DD	$LN23@more_other
	DD	$LN20@more_other
	DD	$LN18@more_other
	DD	$LN17@more_other
	DD	$LN14@more_other
	DD	$LN13@more_other
	DD	$LN12@more_other
	DD	$LN11@more_other
	DD	$LN10@more_other
	DD	$LN9@more_other
	DD	$LN8@more_other
	DD	$LN626@more_other
	DD	$LN626@more_other
	DD	$LN626@more_other
	DD	$LN626@more_other
	DD	$LN626@more_other
	DD	$LN626@more_other
	DD	$LN6@more_other
$LN1435@more_other:
	DD	$LN366@more_other
	DD	$LN367@more_other
	DD	$LN361@more_other
	DD	$LN375@more_other
	DD	$LN360@more_other
$LN1138@more_other:
	DB	0
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	1
	DB	1
	DB	4
	DB	4
	DB	3
	DB	4
	DB	1
	DB	4
	DB	4
	DB	1
$LN1436@more_other:
	DD	$LN320@more_other
	DD	$LN333@more_other
	DD	$LN334@more_other
	DD	$LN339@more_other
	DD	$LN307@more_other
$LN1148@more_other:
	DB	0
	DB	4
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	1
	DB	0
	DB	0
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	1
	DB	4
	DB	4
	DB	3
	DB	4
	DB	1
	DB	4
	DB	4
	DB	1
$LN1437@more_other:
	DD	$LN255@more_other
	DD	$LN254@more_other
	DD	$LN253@more_other
	DD	$LN252@more_other
	DD	$LN251@more_other
$LN1438@more_other:
	DD	$LN206@more_other
	DD	$LN205@more_other
	DD	$LN204@more_other
	DD	$LN203@more_other
	DD	$LN202@more_other
$LN1439@more_other:
	DD	$LN198@more_other
	DD	$LN197@more_other
	DD	$LN196@more_other
	DD	$LN195@more_other
	DD	$LN194@more_other
$LN1440@more_other:
	DD	$LN146@more_other
	DD	$LN145@more_other
	DD	$LN144@more_other
	DD	$LN143@more_other
	DD	$LN142@more_other
$LN1441@more_other:
	DD	$LN137@more_other
	DD	$LN136@more_other
	DD	$LN135@more_other
	DD	$LN134@more_other
	DD	$LN133@more_other
$LN1442@more_other:
	DD	$LN1375@more_other
	DD	$LN126@more_other
	DD	$LN125@more_other
	DD	$LN124@more_other
	DD	$LN123@more_other
$LN1443@more_other:
	DD	$LN1386@more_other
	DD	$LN116@more_other
	DD	$LN115@more_other
	DD	$LN114@more_other
	DD	$LN113@more_other
$LN1444@more_other:
	DD	$LN1397@more_other
	DD	$LN107@more_other
	DD	$LN106@more_other
	DD	$LN105@more_other
	DD	$LN104@more_other
$LN1445@more_other:
	DD	$LN99@more_other
	DD	$LN98@more_other
	DD	$LN97@more_other
	DD	$LN96@more_other
	DD	$LN95@more_other
_more_other_stuff ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@NIHPBBFE@Facet?5shading?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BC@NNLDDHA@Facet?5shading?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BC@CKPMKGL@Facet?5colors?5OFF?4?$AA@	; `string'
PUBLIC	??_C@_0BB@LNLINMBL@Facet?5colors?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0N@CPEDIFLO@Gravity?5OFF?4?$AA@		; `string'
PUBLIC	??_C@_0M@FDBIIEOE@Gravity?5ON?4?$AA@		; `string'
PUBLIC	??_C@_0DD@EDPMNIFD@View_transforms?5index?53?5is?5?$CFd?0?5m@ ; `string'
PUBLIC	??_C@_0DD@CAPLABHH@View_transforms?5index?52?5is?5?$CFd?0?5m@ ; `string'
PUBLIC	??_C@_0EE@EHAPANAL@View_transforms?5index?51?5is?5?$CFd?0?5m@ ; `string'
PUBLIC	??_C@_0DE@LMFKCPDC@View_transforms?5index?53?5is?5?$CFd?0?5m@ ; `string'
PUBLIC	??_C@_0DE@IADKMMDK@View_transforms?5index?52?5is?5?$CFd?0?5m@ ; `string'
PUBLIC	??_C@_0DE@MEJLOJCC@View_transforms?5index?51?5is?5?$CFd?0?5m@ ; `string'
PUBLIC	??_C@_0DB@NGHECIGG@Invalid?5index?5?$CFd?5to?5view_transfo@ ; `string'
PUBLIC	??_C@_0CB@MNEAHDFA@Try?5using?5?2?2?5or?5?1?5instead?5of?5?2?4?6@ ; `string'
PUBLIC	??_C@_0BO@IGMMDLLJ@Unable?5to?5change?5directory?4?5?6?$AA@ ; `string'
PUBLIC	??_C@_0DG@BOMEKDIH@Node_exec?5node?5number?5must?5be?50?5@ ; `string'
PUBLIC	??_C@_0DI@NLJAFAOJ@?8Repartition?8?5command?5only?5imple@ ; `string'
PUBLIC	??_C@_0BA@PJAKDOFJ@Keylogfile?5ON?4?6?$AA@	; `string'
PUBLIC	??_C@_0N@OIJOBCFB@Logfile?5ON?4?6?$AA@		; `string'
PUBLIC	??_C@_0CA@COCFHENO@Everything?5already?5quantities?4?6?$AA@ ; `string'
PUBLIC	??_C@_07INNMNHPJ@cmd?4exe?$AA@			; `string'
PUBLIC	??_C@_0CE@IICCDGHH@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@ ; `string'
PUBLIC	??_C@_0CF@BNMONBF@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@ ; `string'
PUBLIC	??_C@_0CO@BCOCKICC@Can?8t?5do?5hessian_menu?5in?5a?5hessi@ ; `string'
PUBLIC	__real@4059000000000000
PUBLIC	__real@4024000000000000
PUBLIC	??_C@_0DA@CLPAALJF@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@ ; `string'
PUBLIC	??_C@_0DL@CFEHCEG@Index?5?$CFd?5of?5attribute?5?$CFs?5is?5?$CFd?$DL?5@ ; `string'
PUBLIC	??_C@_0BI@PIKEDNEI@?1?1Element?5attributes?3?5?6?$AA@ ; `string'
PUBLIC	??_C@_0CE@NHFFMKDI@Invalid?5boundary?5for?5list_bounda@ ; `string'
PUBLIC	??_C@_0CI@PKIAGMJH@Invalid?5constraint?5for?5list_cons@ ; `string'
PUBLIC	??_C@_0BG@NBOBGBMF@Memory?5debugging?5OFF?4?$AA@ ; `string'
PUBLIC	??_C@_0BF@CFOHIJHM@Memory?5debugging?5ON?4?$AA@	; `string'
PUBLIC	??_C@_0BO@JPGBDDG@Iteration?5debugging?5was?5OFF?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@PPPHNHDI@Iteration?5debugging?5was?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_09CJAKNOCL@Now?5OFF?4?6?$AA@		; `string'
PUBLIC	??_C@_08EBFKAJLG@Now?5ON?4?6?$AA@		; `string'
PUBLIC	??_C@_0BJ@HGBGHBJE@YACC?5debugging?5was?5OFF?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@PFCHHHCD@YACC?5debugging?5was?5ON?4?$AA@ ; `string'
PUBLIC	??_C@_0BG@OELPOHFE@Cannot?5open?5pipe?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_02DPNLHKJD@a?$CL?$AA@			; `string'
PUBLIC	??_C@_0CC@OOOIOPJB@Cannot?5open?5redirection?5file?5?$CFs?4@ ; `string'
PUBLIC	??_C@_01MCMALHOG@a?$AA@				; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_04CGKAJBAP@?$CFd?$CJ?5?$AA@		; `string'
PUBLIC	??_C@_0N@MHAJCLKO@No?5history?4?6?$AA@		; `string'
PUBLIC	??_C@_0BL@HJMLIBGL@Can?8t?5do?5edge?5bodies?5yet?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@MDLPGBBO@Can?8t?5do?5vertex?5bodies?5yet?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DD@COJNEPDA@Internal?5error?3?5Body?5?$CFs?5facet?5li@ ; `string'
PUBLIC	??_C@_0BK@NEDLACAF@Can?8t?5do?5body?5edges?5yet?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@ELJFOBHK@Can?8t?5do?5body?5vertices?5yet?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DA@ILOKBJND@Must?5unset?5body?5target?5before?5fi@ ; `string'
PUBLIC	??_C@_0CM@LOBMMHIB@Illegal?5assignment?5operation?5on?5@ ; `string'
PUBLIC	??_C@_0DE@BJDJNOGD@Illegal?5assignment?5operation?5on?5@ ; `string'
PUBLIC	??_C@_0DH@FJKAPFJE@Illegal?5assignment?5operation?5on?5@ ; `string'
PUBLIC	??_C@_0BM@NMEKOFHC@Unhandled?5SET?5attribute?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0CM@OKNEOKD@Invalid?5body?5in?5SET?5FRONTBODY?5or@ ; `string'
PUBLIC	??_C@_0BL@HILFJHDF@Parameter?5index?5too?5high?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@EMPMINAB@Parameter?5number?5is?5?$CFd?$DL?5maximum?5@ ; `string'
PUBLIC	??_C@_0DF@OFFNPKIE@Trying?5to?5set?5coordinate?5?$CFd?0?5in?5@ ; `string'
PUBLIC	??_C@_0CM@JDJHHBGC@Cannot?5have?5negative?5?$CCoriginal?$CC?5@ ; `string'
PUBLIC	??_C@_0CA@CHBGMBCP@Bad?5element?5type?5for?5boundary?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@DOCLDLLN@?$CFs?5?$CFs?5already?5on?5a?5different?5bou@ ; `string'
PUBLIC	??_C@_0EF@DIFGONKI@Cannot?5put?5?$CFs?5?$CFs?5on?5a?5boundary?5s@ ; `string'
PUBLIC	??_C@_0BL@HEGGOIJJ@Boundary?5?$CFd?5is?5not?5valid?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DL@HKDGADPO@Cannot?5set?5constraint?5on?5?$CFs?5?$CFs?5s@ ; `string'
PUBLIC	??_C@_0CA@KOHHCGIN@Illegal?5constraint?5number?3?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DA@GLPHHFLM@Must?5unset?5body?5pressure?5before?5@ ; `string'
PUBLIC	??_C@_0DA@FHCLKLI@Attribute?5?$CFs?5index?5?$CFd?5is?5?$CFd?$DL?5mus@ ; `string'
PUBLIC	??_C@_0DF@MPPJKLHD@Attribute?5?$CFs?5index?5?$CFd?5is?5?$CFd?$DL?5max@ ; `string'
PUBLIC	??_C@_0CP@PBCCHLA@?$CFs?5now?5nonoptimizing?5parameter?4?5@ ; `string'
PUBLIC	??_C@_0CL@GKIDDEHI@?$CFs?5now?5nonoptimizing?5parameter?4?5@ ; `string'
PUBLIC	??_C@_0CO@ONDCODFB@?$GA?$CFs?$GA?5not?5found?5in?5optimizing?5par@ ; `string'
PUBLIC	??_C@_0CM@NFHEKMBO@?$CFs?5now?5optimizing?5parameter?4?5?$CIal@ ; `string'
PUBLIC	??_C@_0CI@PPHECMJA@?$CFs?5now?5optimizing?5parameter?4?5?$CIwa@ ; `string'
PUBLIC	??_C@_0FC@MEEGBMH@Too?5many?5optimizing?5parameters?4?5@ ; `string'
PUBLIC	??_C@_0CO@MBFAENFA@Cannot?5unfix?5?$CC?$CFs?$CC?5since?5it?5is?5no@ ; `string'
PUBLIC	??_C@_0CG@FGOFACKJ@Cannot?5set?5body?5volume?5to?5CONSER@ ; `string'
PUBLIC	??_C@_0CD@KDCNGGGN@Cannot?5set?5body?5volume?5to?5ENERGY@ ; `string'
PUBLIC	??_C@_0BJ@MMPMCFA@Improper?5period?5number?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BM@IOIDOPMA@Torus?5model?5not?5in?5effect?4?6?$AA@ ; `string'
PUBLIC	??_C@_0DA@HKAAECNL@Internal?3?5illegal?5internal?5varia@ ; `string'
PUBLIC	??_C@_0CK@JFPJNFDP@Illegal?5value?5?$CFd?5for?5bounding_bo@ ; `string'
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@bff8000000000000
PUBLIC	??_C@_0CM@LNECKOD@Brightness?5is?5?$CFf?$DL?5must?5be?5betwee@ ; `string'
PUBLIC	??_C@_0BO@NGJPCAH@hessian_epsilon?5is?5negative?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@FGOHOBPD@Cannot?5set?5random?4?5Set?5random_se@ ; `string'
PUBLIC	??_C@_0DF@BLDOGNO@Inverse_periods?5index?5?$CFd?$DL?5must?5b@ ; `string'
PUBLIC	??_C@_0DD@IFKBFEBP@Torus_periods?5index?5?$CFd?$DL?5must?5be?5@ ; `string'
PUBLIC	??_C@_0CJ@HAIANMOD@Invalid?5second?5facet?5?$CFd?5in?5facet@ ; `string'
PUBLIC	??_C@_0CI@KHCNGIHE@Invalid?5first?5facet?5?$CFd?5in?5facet_@ ; `string'
PUBLIC	??_C@_0CH@CHOJCNFH@Invalid?5second?5edge?5?$CFd?5in?5edge_m@ ; `string'
PUBLIC	??_C@_0CG@ELHCLELH@Invalid?5first?5edge?5?$CFd?5in?5edge_me@ ; `string'
PUBLIC	??_C@_0CL@ODOEFJO@Invalid?5second?5vertex?5?$CFd?5in?5vert@ ; `string'
PUBLIC	??_C@_0CK@PMDCPJHL@Invalid?5first?5vertex?5?$CFd?5in?5verte@ ; `string'
PUBLIC	??_C@_0DN@FPFBNAIB@Inconsistency?5in?5first?5edge?5tail@ ; `string'
PUBLIC	??_C@_0EI@EGODMHEI@Inconsistency?3?5edge?5?$CFs?5tail?5vert@ ; `string'
PUBLIC	??_C@_0BP@JHAMAKO@Invalid?5edge?5?$CFg?5in?5new_facet?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@CBNNHBLA@Invalid?5vertex?5?$CFd?5in?5new_facet?4?6@ ; `string'
PUBLIC	??_C@_0CF@JBFABPPP@Invalid?5head?5vertex?5?$CFd?5in?5new_ed@ ; `string'
PUBLIC	??_C@_0CF@HPFGDKML@Invalid?5tail?5vertex?5?$CFd?5in?5new_ed@ ; `string'
PUBLIC	??_C@_0CN@EHLNHEIH@Paused?$DL?5hit?5RETURN?5to?5continue?0?5@ ; `string'
PUBLIC	??_C@_0EB@BDNHEIPM@Paused?$DL?5Select?5OpenGL?5Window?0?5ty@ ; `string'
PUBLIC	_localbase$GSCopy$
PUBLIC	_localstack$GSCopy$
PUBLIC	_q_id$GSCopy$
PUBLIC	_node$GSCopy$
PUBLIC	_recalc_flag$GSCopy$
PUBLIC	_update_display_flag$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_other_stuff
EXTRN	_iterate:PROC
EXTRN	_transform_gen_expr:PROC
EXTRN	_calc_view_transform_gens:PROC
EXTRN	_generate_transforms:PROC
EXTRN	_view_transforms:DWORD
EXTRN	_read_transforms:PROC
EXTRN	_transform_parity:DWORD
EXTRN	_transform_colors:DWORD
EXTRN	_exec_file:PROC
EXTRN	_warning_messages_new:DWORD
EXTRN	_read_depth:DWORD
EXTRN	__chdir:PROC
EXTRN	_system:PROC
EXTRN	_identcase:PROC
EXTRN	_geomview_command:PROC
EXTRN	_show_volumes:PROC
EXTRN	_run_checks:PROC
EXTRN	_view_transform:PROC
EXTRN	__spawnlp:PROC
EXTRN	_hessian_auto:PROC
EXTRN	_hessian_menu:PROC
EXTRN	_hessian_subshell_flag:DWORD
EXTRN	_hessian_saddle:PROC
EXTRN	_hessian_seek:PROC
EXTRN	_sobolev:PROC
EXTRN	_dirichlet:PROC
EXTRN	_print_array:PROC
EXTRN	_list_attributes:PROC
EXTRN	_list_procedures:PROC
EXTRN	_list_boundary:PROC
EXTRN	_list_constraint:PROC
EXTRN	_list_method_instance:PROC
EXTRN	_list_quantity:PROC
EXTRN	_bottom_dump:PROC
EXTRN	_top_dump:PROC
EXTRN	_close_graphics:DWORD
EXTRN	__pclose:PROC
EXTRN	_broken_pipe_flag:DWORD
EXTRN	__popen:PROC
EXTRN	_erroutfd:DWORD
EXTRN	_fclose:PROC
EXTRN	_perror:PROC
EXTRN	_fopen:PROC
EXTRN	_l_redirect:DWORD
EXTRN	_history_offsets:BYTE
EXTRN	_history_number:DWORD
EXTRN	_history_count:DWORD
EXTRN	_history_space:DWORD
EXTRN	_expand_attribute:PROC
EXTRN	_get_next_body_facet:PROC
EXTRN	_get_vertex_first_facet:PROC
EXTRN	_facet_alpha:QWORD
EXTRN	_fixup_edge_content_meths:PROC
EXTRN	_fixup_vertex_content_meths:PROC
EXTRN	_eval:PROC
EXTRN	_eval_stack_trace:BYTE
EXTRN	_eval_stack_trace_spot:DWORD
EXTRN	_V_BOUNDARY_ATTR:DWORD
EXTRN	_E_BOUNDARY_ATTR:DWORD
EXTRN	_F_BOUNDARY_ATTR:DWORD
EXTRN	_project_v_constr:PROC
EXTRN	_set_e_constraint_map:PROC
EXTRN	_set_f_constraint_map:PROC
EXTRN	_typenames:BYTE
EXTRN	_opacity_attr:DWORD
EXTRN	_set_body_volume:PROC
EXTRN	_F_PHASE_ATTR:DWORD
EXTRN	_B_PHASE_ATTR:DWORD
EXTRN	_pressure_set_flag:DWORD
EXTRN	_parallel_update_flag:BYTE
EXTRN	_optparam:BYTE
EXTRN	_optparamcount:DWORD
EXTRN	_web_timestamp:DWORD
EXTRN	_graph_timestamp:DWORD
EXTRN	_calc_quants:PROC
EXTRN	_skinny:PROC
EXTRN	_tordup:PROC
EXTRN	_get_name_arrayptr:PROC
EXTRN	_set_scroll_size:PROC
EXTRN	_maxclipy:QWORD
EXTRN	_minclipy:QWORD
EXTRN	_maxclipx:QWORD
EXTRN	_minclipx:QWORD
EXTRN	_user_thickness_flag:DWORD
EXTRN	_gauss_setup:PROC
EXTRN	_set_by_user_gauss_2D:DWORD
EXTRN	_set_by_user_gauss_1D:DWORD
EXTRN	_kb_initr:PROC
EXTRN	_srand48:PROC
EXTRN	_srand:PROC
EXTRN	_gap_quantity_num:DWORD
EXTRN	_merge_facet:PROC
EXTRN	_merge_edge:PROC
EXTRN	_merge_vertex:PROC
EXTRN	_new_body_id:DWORD
EXTRN	_new_body:PROC
EXTRN	_new_facet_id:DWORD
EXTRN	_need_fe_reorder_flag:DWORD
EXTRN	_recalc_facet_area:PROC
EXTRN	_face_triangulate:PROC
EXTRN	_fe_reorder:PROC
EXTRN	_new_facet:PROC
EXTRN	_new_edge_id:DWORD
EXTRN	_new_edge:PROC
EXTRN	_facet_crosscut:PROC
EXTRN	_new_vertex_id:DWORD
EXTRN	_new_vertex:PROC
EXTRN	_keyword_help:PROC
EXTRN	_my_fgets:PROC
EXTRN	_msgmax:DWORD
EXTRN	___iob_func:PROC
EXTRN	_getOpenGL_key:PROC
EXTRN	_setOpenGL_key:PROC
EXTRN	_l_evolver_mode:DWORD
EXTRN	_reset_profiling:PROC
EXTRN	_print_profiling:PROC
EXTRN	_flush_counts:PROC
EXTRN	_reset_counts:PROC
EXTRN	_mem_list_dump:PROC
EXTRN	_renumber_all:PROC
EXTRN	_reorder_storage:PROC
EXTRN	_simplex_to_fe:PROC
EXTRN	_memset:PROC
;	COMDAT ??_C@_0BD@NIHPBBFE@Facet?5shading?5OFF?4?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\sys\stat.inl
CONST	SEGMENT
??_C@_0BD@NIHPBBFE@Facet?5shading?5OFF?4?$AA@ DB 'Facet shading OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NNLDDHA@Facet?5shading?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BC@NNLDDHA@Facet?5shading?5ON?4?$AA@ DB 'Facet shading ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CKPMKGL@Facet?5colors?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BC@CKPMKGL@Facet?5colors?5OFF?4?$AA@ DB 'Facet colors OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LNLINMBL@Facet?5colors?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BB@LNLINMBL@Facet?5colors?5ON?4?$AA@ DB 'Facet colors ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CPEDIFLO@Gravity?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0N@CPEDIFLO@Gravity?5OFF?4?$AA@ DB 'Gravity OFF.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FDBIIEOE@Gravity?5ON?4?$AA@
CONST	SEGMENT
??_C@_0M@FDBIIEOE@Gravity?5ON?4?$AA@ DB 'Gravity ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EDPMNIFD@View_transforms?5index?53?5is?5?$CFd?0?5m@
CONST	SEGMENT
??_C@_0DD@EDPMNIFD@View_transforms?5index?53?5is?5?$CFd?0?5m@ DB 'View_tr'
	DB	'ansforms index 3 is %d, must be at most 4.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@CAPLABHH@View_transforms?5index?52?5is?5?$CFd?0?5m@
CONST	SEGMENT
??_C@_0DD@CAPLABHH@View_transforms?5index?52?5is?5?$CFd?0?5m@ DB 'View_tr'
	DB	'ansforms index 2 is %d, must be at most 4.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@EHAPANAL@View_transforms?5index?51?5is?5?$CFd?0?5m@
CONST	SEGMENT
??_C@_0EE@EHAPANAL@View_transforms?5index?51?5is?5?$CFd?0?5m@ DB 'View_tr'
	DB	'ansforms index 1 is %d, must be at most transform_count %d.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@LMFKCPDC@View_transforms?5index?53?5is?5?$CFd?0?5m@
CONST	SEGMENT
??_C@_0DE@LMFKCPDC@View_transforms?5index?53?5is?5?$CFd?0?5m@ DB 'View_tr'
	DB	'ansforms index 3 is %d, must be at least 1.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IADKMMDK@View_transforms?5index?52?5is?5?$CFd?0?5m@
CONST	SEGMENT
??_C@_0DE@IADKMMDK@View_transforms?5index?52?5is?5?$CFd?0?5m@ DB 'View_tr'
	DB	'ansforms index 2 is %d, must be at least 1.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@MEJLOJCC@View_transforms?5index?51?5is?5?$CFd?0?5m@
CONST	SEGMENT
??_C@_0DE@MEJLOJCC@View_transforms?5index?51?5is?5?$CFd?0?5m@ DB 'View_tr'
	DB	'ansforms index 1 is %d, must be at least 1.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@NGHECIGG@Invalid?5index?5?$CFd?5to?5view_transfo@
CONST	SEGMENT
??_C@_0DB@NGHECIGG@Invalid?5index?5?$CFd?5to?5view_transfo@ DB 'Invalid i'
	DB	'ndex %d to view_transform_swap_colors.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MNEAHDFA@Try?5using?5?2?2?5or?5?1?5instead?5of?5?2?4?6@
CONST	SEGMENT
??_C@_0CB@MNEAHDFA@Try?5using?5?2?2?5or?5?1?5instead?5of?5?2?4?6@ DB 'Try'
	DB	' using \\ or / instead of \.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IGMMDLLJ@Unable?5to?5change?5directory?4?5?6?$AA@
CONST	SEGMENT
??_C@_0BO@IGMMDLLJ@Unable?5to?5change?5directory?4?5?6?$AA@ DB 'Unable to'
	DB	' change directory. ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@BOMEKDIH@Node_exec?5node?5number?5must?5be?50?5@
CONST	SEGMENT
??_C@_0DG@BOMEKDIH@Node_exec?5node?5number?5must?5be?50?5@ DB 'Node_exec '
	DB	'node number must be 0 for non-MPI Evolver.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@NLJAFAOJ@?8Repartition?8?5command?5only?5imple@
CONST	SEGMENT
??_C@_0DI@NLJAFAOJ@?8Repartition?8?5command?5only?5imple@ DB '''Repartiti'
	DB	'on'' command only implemented in MPI Evolver.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PJAKDOFJ@Keylogfile?5ON?4?6?$AA@
CONST	SEGMENT
??_C@_0BA@PJAKDOFJ@Keylogfile?5ON?4?6?$AA@ DB 'Keylogfile ON.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OIJOBCFB@Logfile?5ON?4?6?$AA@
CONST	SEGMENT
??_C@_0N@OIJOBCFB@Logfile?5ON?4?6?$AA@ DB 'Logfile ON.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@COCFHENO@Everything?5already?5quantities?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@COCFHENO@Everything?5already?5quantities?4?6?$AA@ DB 'Everythin'
	DB	'g already quantities.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07INNMNHPJ@cmd?4exe?$AA@
CONST	SEGMENT
??_C@_07INNMNHPJ@cmd?4exe?$AA@ DB 'cmd.exe', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@IICCDGHH@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@
CONST	SEGMENT
??_C@_0CE@IICCDGHH@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@ DB '%'
	DB	'3d. %s: %#17.15g energy: %#17.15g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BNMONBF@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@
CONST	SEGMENT
??_C@_0CF@BNMONBF@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@ DB '%'
	DB	'3d. %s: %#17.15g energy: %#17.15g ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BCOCKICC@Can?8t?5do?5hessian_menu?5in?5a?5hessi@
CONST	SEGMENT
??_C@_0CO@BCOCKICC@Can?8t?5do?5hessian_menu?5in?5a?5hessi@ DB 'Can''t do '
	DB	'hessian_menu in a hessian subshell.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT ??_C@_0DA@CLPAALJF@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@
CONST	SEGMENT
??_C@_0DA@CLPAALJF@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@ DB '%'
	DB	'3d. %s: %#17.15g energy: %#17.15g  scale: %#g', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@CFEHCEG@Index?5?$CFd?5of?5attribute?5?$CFs?5is?5?$CFd?$DL?5@
CONST	SEGMENT
??_C@_0DL@CFEHCEG@Index?5?$CFd?5of?5attribute?5?$CFs?5is?5?$CFd?$DL?5@ DB 'I'
	DB	'ndex %d of attribute %s is %d; exceeds declared size, %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PIKEDNEI@?1?1Element?5attributes?3?5?6?$AA@
CONST	SEGMENT
??_C@_0BI@PIKEDNEI@?1?1Element?5attributes?3?5?6?$AA@ DB '//Element attri'
	DB	'butes: ', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NHFFMKDI@Invalid?5boundary?5for?5list_bounda@
CONST	SEGMENT
??_C@_0CE@NHFFMKDI@Invalid?5boundary?5for?5list_bounda@ DB 'Invalid bound'
	DB	'ary for list_boundary.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PKIAGMJH@Invalid?5constraint?5for?5list_cons@
CONST	SEGMENT
??_C@_0CI@PKIAGMJH@Invalid?5constraint?5for?5list_cons@ DB 'Invalid const'
	DB	'raint for list_constraint.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NBOBGBMF@Memory?5debugging?5OFF?4?$AA@
CONST	SEGMENT
??_C@_0BG@NBOBGBMF@Memory?5debugging?5OFF?4?$AA@ DB 'Memory debugging OFF'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CFOHIJHM@Memory?5debugging?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BF@CFOHIJHM@Memory?5debugging?5ON?4?$AA@ DB 'Memory debugging ON.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JPGBDDG@Iteration?5debugging?5was?5OFF?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@JPGBDDG@Iteration?5debugging?5was?5OFF?4?6?$AA@ DB 'Iteration d'
	DB	'ebugging was OFF.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PPPHNHDI@Iteration?5debugging?5was?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BM@PPPHNHDI@Iteration?5debugging?5was?5ON?4?$AA@ DB 'Iteration deb'
	DB	'ugging was ON.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09CJAKNOCL@Now?5OFF?4?6?$AA@
CONST	SEGMENT
??_C@_09CJAKNOCL@Now?5OFF?4?6?$AA@ DB 'Now OFF.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EBFKAJLG@Now?5ON?4?6?$AA@
CONST	SEGMENT
??_C@_08EBFKAJLG@Now?5ON?4?6?$AA@ DB 'Now ON.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HGBGHBJE@YACC?5debugging?5was?5OFF?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@HGBGHBJE@YACC?5debugging?5was?5OFF?4?6?$AA@ DB 'YACC debugging '
	DB	'was OFF.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PFCHHHCD@YACC?5debugging?5was?5ON?4?$AA@
CONST	SEGMENT
??_C@_0BH@PFCHHHCD@YACC?5debugging?5was?5ON?4?$AA@ DB 'YACC debugging was'
	DB	' ON.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OELPOHFE@Cannot?5open?5pipe?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0BG@OELPOHFE@Cannot?5open?5pipe?5?$CFs?4?6?$AA@ DB 'Cannot open pip'
	DB	'e %s.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNLHKJD@a?$CL?$AA@
CONST	SEGMENT
??_C@_02DPNLHKJD@a?$CL?$AA@ DB 'a+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@OOOIOPJB@Cannot?5open?5redirection?5file?5?$CFs?4@
CONST	SEGMENT
??_C@_0CC@OOOIOPJB@Cannot?5open?5redirection?5file?5?$CFs?4@ DB 'Cannot o'
	DB	'pen redirection file %s.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT
??_C@_01MCMALHOG@a?$AA@ DB 'a', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CGKAJBAP@?$CFd?$CJ?5?$AA@
CONST	SEGMENT
??_C@_04CGKAJBAP@?$CFd?$CJ?5?$AA@ DB '%d) ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MHAJCLKO@No?5history?4?6?$AA@
CONST	SEGMENT
??_C@_0N@MHAJCLKO@No?5history?4?6?$AA@ DB 'No history.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HJMLIBGL@Can?8t?5do?5edge?5bodies?5yet?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@HJMLIBGL@Can?8t?5do?5edge?5bodies?5yet?4?6?$AA@ DB 'Can''t do e'
	DB	'dge bodies yet.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MDLPGBBO@Can?8t?5do?5vertex?5bodies?5yet?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@MDLPGBBO@Can?8t?5do?5vertex?5bodies?5yet?4?6?$AA@ DB 'Can''t do'
	DB	' vertex bodies yet.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@COJNEPDA@Internal?5error?3?5Body?5?$CFs?5facet?5li@
CONST	SEGMENT
??_C@_0DD@COJNEPDA@Internal?5error?3?5Body?5?$CFs?5facet?5li@ DB 'Interna'
	DB	'l error: Body %s facet list is not closed.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@NEDLACAF@Can?8t?5do?5body?5edges?5yet?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@NEDLACAF@Can?8t?5do?5body?5edges?5yet?4?6?$AA@ DB 'Can''t do bo'
	DB	'dy edges yet.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ELJFOBHK@Can?8t?5do?5body?5vertices?5yet?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@ELJFOBHK@Can?8t?5do?5body?5vertices?5yet?4?6?$AA@ DB 'Can''t do'
	DB	' body vertices yet.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@ILOKBJND@Must?5unset?5body?5target?5before?5fi@
CONST	SEGMENT
??_C@_0DA@ILOKBJND@Must?5unset?5body?5target?5before?5fi@ DB 'Must unset '
	DB	'body target before fixing pressure.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LOBMMHIB@Illegal?5assignment?5operation?5on?5@
CONST	SEGMENT
??_C@_0CM@LOBMMHIB@Illegal?5assignment?5operation?5on?5@ DB 'Illegal assi'
	DB	'gnment operation on attribute.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@BJDJNOGD@Illegal?5assignment?5operation?5on?5@
CONST	SEGMENT
??_C@_0DE@BJDJNOGD@Illegal?5assignment?5operation?5on?5@ DB 'Illegal assi'
	DB	'gnment operation on pointer attribute.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FJKAPFJE@Illegal?5assignment?5operation?5on?5@
CONST	SEGMENT
??_C@_0DH@FJKAPFJE@Illegal?5assignment?5operation?5on?5@ DB 'Illegal assi'
	DB	'gnment operation on element id attribute.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NMEKOFHC@Unhandled?5SET?5attribute?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BM@NMEKOFHC@Unhandled?5SET?5attribute?5?$CFd?6?$AA@ DB 'Unhandled '
	DB	'SET attribute %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@OKNEOKD@Invalid?5body?5in?5SET?5FRONTBODY?5or@
CONST	SEGMENT
??_C@_0CM@OKNEOKD@Invalid?5body?5in?5SET?5FRONTBODY?5or@ DB 'Invalid body'
	DB	' in SET FRONTBODY or BACKBODY.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HILFJHDF@Parameter?5index?5too?5high?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@HILFJHDF@Parameter?5index?5too?5high?4?6?$AA@ DB 'Parameter ind'
	DB	'ex too high.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EMPMINAB@Parameter?5number?5is?5?$CFd?$DL?5maximum?5@
CONST	SEGMENT
??_C@_0CI@EMPMINAB@Parameter?5number?5is?5?$CFd?$DL?5maximum?5@ DB 'Param'
	DB	'eter number is %d; maximum is %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@OFFNPKIE@Trying?5to?5set?5coordinate?5?$CFd?0?5in?5@
CONST	SEGMENT
??_C@_0DF@OFFNPKIE@Trying?5to?5set?5coordinate?5?$CFd?0?5in?5@ DB 'Trying'
	DB	' to set coordinate %d, in space dimension %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@JDJHHBGC@Cannot?5have?5negative?5?$CCoriginal?$CC?5@
CONST	SEGMENT
??_C@_0CM@JDJHHBGC@Cannot?5have?5negative?5?$CCoriginal?$CC?5@ DB 'Cannot'
	DB	' have negative "original" attribute.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CHBGMBCP@Bad?5element?5type?5for?5boundary?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@CHBGMBCP@Bad?5element?5type?5for?5boundary?4?6?$AA@ DB 'Bad ele'
	DB	'ment type for boundary.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DOCLDLLN@?$CFs?5?$CFs?5already?5on?5a?5different?5bou@
CONST	SEGMENT
??_C@_0CI@DOCLDLLN@?$CFs?5?$CFs?5already?5on?5a?5different?5bou@ DB '%s %'
	DB	's already on a different boundary.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@DIFGONKI@Cannot?5put?5?$CFs?5?$CFs?5on?5a?5boundary?5s@
CONST	SEGMENT
??_C@_0EF@DIFGONKI@Cannot?5put?5?$CFs?5?$CFs?5on?5a?5boundary?5s@ DB 'Can'
	DB	'not put %s %s on a boundary since it is already on a constrai'
	DB	'nt.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HEGGOIJJ@Boundary?5?$CFd?5is?5not?5valid?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@HEGGOIJJ@Boundary?5?$CFd?5is?5not?5valid?4?6?$AA@ DB 'Boundary '
	DB	'%d is not valid.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HKDGADPO@Cannot?5set?5constraint?5on?5?$CFs?5?$CFs?5s@
CONST	SEGMENT
??_C@_0DL@HKDGADPO@Cannot?5set?5constraint?5on?5?$CFs?5?$CFs?5s@ DB 'Cann'
	DB	'ot set constraint on %s %s since it is on a boundary.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KOHHCGIN@Illegal?5constraint?5number?3?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@KOHHCGIN@Illegal?5constraint?5number?3?5?$CFd?4?6?$AA@ DB 'Ille'
	DB	'gal constraint number: %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@GLPHHFLM@Must?5unset?5body?5pressure?5before?5@
CONST	SEGMENT
??_C@_0DA@GLPHHFLM@Must?5unset?5body?5pressure?5before?5@ DB 'Must unset '
	DB	'body pressure before fixing target.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@FHCLKLI@Attribute?5?$CFs?5index?5?$CFd?5is?5?$CFd?$DL?5mus@
CONST	SEGMENT
??_C@_0DA@FHCLKLI@Attribute?5?$CFs?5index?5?$CFd?5is?5?$CFd?$DL?5mus@ DB 'A'
	DB	'ttribute %s index %d is %d; must be positive.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@MPPJKLHD@Attribute?5?$CFs?5index?5?$CFd?5is?5?$CFd?$DL?5max@
CONST	SEGMENT
??_C@_0DF@MPPJKLHD@Attribute?5?$CFs?5index?5?$CFd?5is?5?$CFd?$DL?5max@ DB 'A'
	DB	'ttribute %s index %d is %d; maximum is %d (in %s).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@PBCCHLA@?$CFs?5now?5nonoptimizing?5parameter?4?5@
CONST	SEGMENT
??_C@_0CP@PBCCHLA@?$CFs?5now?5nonoptimizing?5parameter?4?5@ DB '%s now no'
	DB	'noptimizing parameter. (already was)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GKIDDEHI@?$CFs?5now?5nonoptimizing?5parameter?4?5@
CONST	SEGMENT
??_C@_0CL@GKIDDEHI@?$CFs?5now?5nonoptimizing?5parameter?4?5@ DB '%s now n'
	DB	'onoptimizing parameter. (was not)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@ONDCODFB@?$GA?$CFs?$GA?5not?5found?5in?5optimizing?5par@
CONST	SEGMENT
??_C@_0CO@ONDCODFB@?$GA?$CFs?$GA?5not?5found?5in?5optimizing?5par@ DB '`%'
	DB	's` not found in optimizing parameter list.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NFHEKMBO@?$CFs?5now?5optimizing?5parameter?4?5?$CIal@
CONST	SEGMENT
??_C@_0CM@NFHEKMBO@?$CFs?5now?5optimizing?5parameter?4?5?$CIal@ DB '%s no'
	DB	'w optimizing parameter. (already was)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PPHECMJA@?$CFs?5now?5optimizing?5parameter?4?5?$CIwa@
CONST	SEGMENT
??_C@_0CI@PPHECMJA@?$CFs?5now?5optimizing?5parameter?4?5?$CIwa@ DB '%s no'
	DB	'w optimizing parameter. (was not)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@MEEGBMH@Too?5many?5optimizing?5parameters?4?5@
CONST	SEGMENT
??_C@_0FC@MEEGBMH@Too?5many?5optimizing?5parameters?4?5@ DB 'Too many opt'
	DB	'imizing parameters.  Increase MAXOPTPARAM in extern.h and rec'
	DB	'ompile.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@MBFAENFA@Cannot?5unfix?5?$CC?$CFs?$CC?5since?5it?5is?5no@
CONST	SEGMENT
??_C@_0CO@MBFAENFA@Cannot?5unfix?5?$CC?$CFs?$CC?5since?5it?5is?5no@ DB 'C'
	DB	'annot unfix "%s" since it is not type REAL.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FGOFACKJ@Cannot?5set?5body?5volume?5to?5CONSER@
CONST	SEGMENT
??_C@_0CG@FGOFACKJ@Cannot?5set?5body?5volume?5to?5CONSER@ DB 'Cannot set '
	DB	'body volume to CONSERVED.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KDCNGGGN@Cannot?5set?5body?5volume?5to?5ENERGY@
CONST	SEGMENT
??_C@_0CD@KDCNGGGN@Cannot?5set?5body?5volume?5to?5ENERGY@ DB 'Cannot set '
	DB	'body volume to ENERGY.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MMPMCFA@Improper?5period?5number?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@MMPMCFA@Improper?5period?5number?4?6?$AA@ DB 'Improper period n'
	DB	'umber.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IOIDOPMA@Torus?5model?5not?5in?5effect?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@IOIDOPMA@Torus?5model?5not?5in?5effect?4?6?$AA@ DB 'Torus model'
	DB	' not in effect.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HKAAECNL@Internal?3?5illegal?5internal?5varia@
CONST	SEGMENT
??_C@_0DA@HKAAECNL@Internal?3?5illegal?5internal?5varia@ DB 'Internal: il'
	DB	'legal internal variable number %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JFPJNFDP@Illegal?5value?5?$CFd?5for?5bounding_bo@
CONST	SEGMENT
??_C@_0CK@JFPJNFDP@Illegal?5value?5?$CFd?5for?5bounding_bo@ DB 'Illegal v'
	DB	'alue %d for bounding_box_color.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@bff8000000000000
CONST	SEGMENT
__real@bff8000000000000 DQ 0bff8000000000000r	; -1.5
CONST	ENDS
;	COMDAT ??_C@_0CM@LNECKOD@Brightness?5is?5?$CFf?$DL?5must?5be?5betwee@
CONST	SEGMENT
??_C@_0CM@LNECKOD@Brightness?5is?5?$CFf?$DL?5must?5be?5betwee@ DB 'Bright'
	DB	'ness is %f; must be between 0 and 1.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NGJPCAH@hessian_epsilon?5is?5negative?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BO@NGJPCAH@hessian_epsilon?5is?5negative?$CB?6?$AA@ DB 'hessian_ep'
	DB	'silon is negative!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@FGOHOBPD@Cannot?5set?5random?4?5Set?5random_se@
CONST	SEGMENT
??_C@_0CN@FGOHOBPD@Cannot?5set?5random?4?5Set?5random_se@ DB 'Cannot set '
	DB	'random. Set random_seed instead.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BLDOGNO@Inverse_periods?5index?5?$CFd?$DL?5must?5b@
CONST	SEGMENT
??_C@_0DF@BLDOGNO@Inverse_periods?5index?5?$CFd?$DL?5must?5b@ DB 'Inverse'
	DB	'_periods index %d; must be between 1 and %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IFKBFEBP@Torus_periods?5index?5?$CFd?$DL?5must?5be?5@
CONST	SEGMENT
??_C@_0DD@IFKBFEBP@Torus_periods?5index?5?$CFd?$DL?5must?5be?5@ DB 'Torus'
	DB	'_periods index %d; must be between 1 and %d.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HAIANMOD@Invalid?5second?5facet?5?$CFd?5in?5facet@
CONST	SEGMENT
??_C@_0CJ@HAIANMOD@Invalid?5second?5facet?5?$CFd?5in?5facet@ DB 'Invalid '
	DB	'second facet %d in facet_merge.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KHCNGIHE@Invalid?5first?5facet?5?$CFd?5in?5facet_@
CONST	SEGMENT
??_C@_0CI@KHCNGIHE@Invalid?5first?5facet?5?$CFd?5in?5facet_@ DB 'Invalid '
	DB	'first facet %d in facet_merge.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CHOJCNFH@Invalid?5second?5edge?5?$CFd?5in?5edge_m@
CONST	SEGMENT
??_C@_0CH@CHOJCNFH@Invalid?5second?5edge?5?$CFd?5in?5edge_m@ DB 'Invalid '
	DB	'second edge %d in edge_merge.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@ELHCLELH@Invalid?5first?5edge?5?$CFd?5in?5edge_me@
CONST	SEGMENT
??_C@_0CG@ELHCLELH@Invalid?5first?5edge?5?$CFd?5in?5edge_me@ DB 'Invalid '
	DB	'first edge %d in edge_merge.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@ODOEFJO@Invalid?5second?5vertex?5?$CFd?5in?5vert@
CONST	SEGMENT
??_C@_0CL@ODOEFJO@Invalid?5second?5vertex?5?$CFd?5in?5vert@ DB 'Invalid s'
	DB	'econd vertex %d in vertex_merge.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PMDCPJHL@Invalid?5first?5vertex?5?$CFd?5in?5verte@
CONST	SEGMENT
??_C@_0CK@PMDCPJHL@Invalid?5first?5vertex?5?$CFd?5in?5verte@ DB 'Invalid '
	DB	'first vertex %d in vertex_merge.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@FPFBNAIB@Inconsistency?5in?5first?5edge?5tail@
CONST	SEGMENT
??_C@_0DN@FPFBNAIB@Inconsistency?5in?5first?5edge?5tail@ DB 'Inconsistenc'
	DB	'y in first edge tail vertex and last edge head.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@EGODMHEI@Inconsistency?3?5edge?5?$CFs?5tail?5vert@
CONST	SEGMENT
??_C@_0EI@EGODMHEI@Inconsistency?3?5edge?5?$CFs?5tail?5vert@ DB 'Inconsis'
	DB	'tency: edge %s tail vertex %s disagrees with previous head %s'
	DB	'.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JHAMAKO@Invalid?5edge?5?$CFg?5in?5new_facet?4?6?$AA@
CONST	SEGMENT
??_C@_0BP@JHAMAKO@Invalid?5edge?5?$CFg?5in?5new_facet?4?6?$AA@ DB 'Invali'
	DB	'd edge %g in new_facet.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CBNNHBLA@Invalid?5vertex?5?$CFd?5in?5new_facet?4?6@
CONST	SEGMENT
??_C@_0CB@CBNNHBLA@Invalid?5vertex?5?$CFd?5in?5new_facet?4?6@ DB 'Invalid'
	DB	' vertex %d in new_facet.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@JBFABPPP@Invalid?5head?5vertex?5?$CFd?5in?5new_ed@
CONST	SEGMENT
??_C@_0CF@JBFABPPP@Invalid?5head?5vertex?5?$CFd?5in?5new_ed@ DB 'Invalid '
	DB	'head vertex %d in new_edge.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HPFGDKML@Invalid?5tail?5vertex?5?$CFd?5in?5new_ed@
CONST	SEGMENT
??_C@_0CF@HPFGDKML@Invalid?5tail?5vertex?5?$CFd?5in?5new_ed@ DB 'Invalid '
	DB	'tail vertex %d in new_edge.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EHLNHEIH@Paused?$DL?5hit?5RETURN?5to?5continue?0?5@
CONST	SEGMENT
??_C@_0CN@EHLNHEIH@Paused?$DL?5hit?5RETURN?5to?5continue?0?5@ DB 'Paused;'
	DB	' hit RETURN to continue, b to break: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@BDNHEIPM@Paused?$DL?5Select?5OpenGL?5Window?0?5ty@
CONST	SEGMENT
??_C@_0EB@BDNHEIPM@Paused?$DL?5Select?5OpenGL?5Window?0?5ty@ DB 'Paused; '
	DB	'Select OpenGL Window, type F3 to continue, F7 to break: ', 00H ; `string'
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\evalmore.c
CONST	ENDS
;	COMDAT _other_stuff
_TEXT	SEGMENT
tv14771 = -108						; size = 4
tv9899 = -108						; size = 4
_assign_type$90764 = -108				; size = 4
_old_fe$89948 = -108					; size = 4
tv12315 = -104						; size = 8
tv12295 = -104						; size = 8
tv11712 = -104						; size = 8
tv11701 = -104						; size = 8
tv11691 = -104						; size = 8
tv11681 = -104						; size = 8
tv11671 = -104						; size = 8
tv11625 = -104						; size = 8
tv11614 = -104						; size = 8
tv11604 = -104						; size = 8
tv11594 = -104						; size = 8
tv11584 = -104						; size = 8
tv11128 = -104						; size = 8
_scale$ = -104						; size = 8
_oldvalue$91256 = -104					; size = 8
_oldvalue$91192 = -104					; size = 8
_p$91094 = -104						; size = 8
_v$91077 = -104						; size = 8
_v$91061 = -104						; size = 8
_density$91006 = -104					; size = 8
_p$90502 = -104						; size = 8
_v$90494 = -104						; size = 8
_v$90487 = -104						; size = 8
_density$90452 = -104					; size = 8
_oldvalue$90114 = -104					; size = 8
tv12498 = -100						; size = 4
tv10666 = -100						; size = 4
tv10585 = -100						; size = 4
tv10517 = -100						; size = 4
tv10466 = -100						; size = 4
tv9439 = -100						; size = 4
_node$GSCopy$ = -100					; size = 4
_k$91714 = -100						; size = 4
_k$91698 = -100						; size = 4
_oldquiet$ = -100					; size = 4
_one$91470 = -100					; size = 4
_maxcount$91434 = -100					; size = 4
tv13189 = -96						; size = 4
tv10077 = -96						; size = 4
tv10055 = -96						; size = 4
tv9908 = -96						; size = 4
tv9261 = -96						; size = 4
_inx$91622 = -96					; size = 4
_datastart$91595 = -96					; size = 4
_counter$91433 = -96					; size = 4
tv4226 = -96						; size = 4
tv4197 = -96						; size = 4
_j$90789 = -96						; size = 4
_j$90405 = -96						; size = 4
_f1$90080 = -96						; size = 4
_e1$90063 = -96						; size = 4
_v_id2$90044 = -96					; size = 4
_v2$90046 = -96						; size = 4
_v$90016 = -96						; size = 4
_hv$89951 = -96						; size = 4
_v_id1$89930 = -96					; size = 4
_v1$89933 = -96						; size = 4
_v1$89920 = -96						; size = 4
_oldvalue$91062 = -92					; size = 8
_oldvalue$91007 = -92					; size = 8
_oldvcon$90488 = -92					; size = 8
tv12466 = -88						; size = 4
tv12464 = -88						; size = 4
tv12462 = -88						; size = 4
tv12460 = -88						; size = 4
tv12317 = -88						; size = 4
tv12307 = -88						; size = 4
tv12305 = -88						; size = 4
tv12297 = -88						; size = 4
tv12287 = -88						; size = 4
tv12285 = -88						; size = 4
tv11714 = -88						; size = 4
tv11703 = -88						; size = 4
tv11693 = -88						; size = 4
tv11683 = -88						; size = 4
tv11673 = -88						; size = 4
tv11627 = -88						; size = 4
tv11616 = -88						; size = 4
tv11606 = -88						; size = 4
tv11596 = -88						; size = 4
tv11586 = -88						; size = 4
tv11574 = -88						; size = 4
tv11572 = -88						; size = 4
tv11563 = -88						; size = 4
tv11561 = -88						; size = 4
tv11553 = -88						; size = 4
tv11551 = -88						; size = 4
tv11543 = -88						; size = 4
tv11541 = -88						; size = 4
tv11530 = -88						; size = 4
tv11528 = -88						; size = 4
tv11443 = -88						; size = 4
tv11441 = -88						; size = 4
tv11432 = -88						; size = 4
tv11430 = -88						; size = 4
tv11422 = -88						; size = 4
tv11420 = -88						; size = 4
tv11412 = -88						; size = 4
tv11410 = -88						; size = 4
tv11402 = -88						; size = 4
tv11400 = -88						; size = 4
tv11130 = -88						; size = 4
tv10462 = -88						; size = 4
tv9910 = -88						; size = 4
tv9792 = -88						; size = 4
tv9749 = -88						; size = 4
tv9743 = -88						; size = 4
tv9741 = -88						; size = 4
tv9682 = -88						; size = 4
tv9676 = -88						; size = 4
tv8938 = -88						; size = 4
_start_f$91432 = -88					; size = 4
_xx$91249 = -88						; size = 4
_spot$90780 = -88					; size = 4
_xx$90734 = -88						; size = 4
_x$90601 = -88						; size = 4
_spot$90396 = -88					; size = 4
_f2$90078 = -88						; size = 4
_e2$90061 = -88						; size = 4
_fe$ = -88						; size = 4
tv14491 = -84						; size = 4
_localstack$GSCopy$ = -84				; size = 4
_size$91621 = -84					; size = 4
_boundary$91238 = -84					; size = 4
_boundary$90723 = -84					; size = 4
_tv$89950 = -84						; size = 4
_f_id$ = -84						; size = 4
_k$ = -84						; size = 4
tv14588 = -80						; size = 4
tv14430 = -80						; size = 4
tv14338 = -80						; size = 4
tv14284 = -80						; size = 4
tv10053 = -80						; size = 4
_q_id$GSCopy$ = -80					; size = 4
_i$91718 = -80						; size = 4
_offset$91610 = -80					; size = 4
_param$91244 = -80					; size = 4
_param$90729 = -80					; size = 4
_f_id1$90077 = -80					; size = 4
_e_id1$90060 = -80					; size = 4
_v_id2$89929 = -80					; size = 4
_i$ = -80						; size = 4
_recalc_flag$GSCopy$ = -76				; size = 4
_id$ = -76						; size = 4
tv9707 = -72						; size = 4
_n$ = -72						; size = 4
_localbase$GSCopy$ = -68				; size = 4
tv566 = -68						; size = 4
_edge_fe$89997 = -68					; size = 4
tv12320 = -66						; size = 2
tv12310 = -66						; size = 2
tv12300 = -66						; size = 2
tv12290 = -66						; size = 2
tv11717 = -66						; size = 2
tv11706 = -66						; size = 2
tv11696 = -66						; size = 2
tv11686 = -66						; size = 2
tv11676 = -66						; size = 2
tv11630 = -66						; size = 2
tv11619 = -66						; size = 2
tv11609 = -66						; size = 2
tv11599 = -66						; size = 2
tv11589 = -66						; size = 2
tv11577 = -66						; size = 2
tv11566 = -66						; size = 2
tv11556 = -66						; size = 2
tv11546 = -66						; size = 2
tv11533 = -66						; size = 2
tv11446 = -66						; size = 2
tv11435 = -66						; size = 2
tv11425 = -66						; size = 2
tv11415 = -66						; size = 2
tv11405 = -66						; size = 2
tv11133 = -66						; size = 2
tv9747 = -65						; size = 1
tv9745 = -65						; size = 1
tv9739 = -65						; size = 1
tv9737 = -65						; size = 1
tv9126 = -64						; size = 4
_update_display_flag$GSCopy$ = -64			; size = 4
tv6226 = -64						; size = 4
_j$91716 = -64						; size = 4
_part$91608 = -64					; size = 4
_pnum$91282 = -64					; size = 4
_pnum$91255 = -64					; size = 4
tv4401 = -64						; size = 4
tv4090 = -64						; size = 4
_con$91120 = -64					; size = 4
_ext$90779 = -64					; size = 4
_pnum$90716 = -64					; size = 4
_dim$90701 = -64					; size = 4
_bdry$90545 = -64					; size = 4
_con$90515 = -64					; size = 4
_ext$90395 = -64					; size = 4
_j$ = -64						; size = 4
_f_id2$90076 = -64					; size = 4
_e_id2$90059 = -64					; size = 4
_v_id1$90045 = -64					; size = 4
_e_id$89949 = -64					; size = 4
tv169 = -64						; size = 4
tv151 = -64						; size = 4
tv133 = -64						; size = 4
tv83 = -64						; size = 4
_v2$89931 = -64						; size = 4
_f1$89922 = -64						; size = 4
_kludge$91589 = -60					; size = 56
_st$91516 = -52						; size = 48
_st$91492 = -52						; size = 48
_x$89908 = -52						; size = 48
_newsizes$91475 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_node$ = 8						; size = 4
_recalc_flag$ = 12					; size = 4
_update_display_flag$ = 16				; size = 4
_q_id$ = 20						; size = 4
_localstack$ = 24					; size = 4
_localbase$ = 28					; size = 4
_other_stuff PROC					; COMDAT

; 65   : { int i,j,n,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2871 :           break;
; 2872 : 
; 2873 :        default:
; 2874 :           more_other_stuff(node,recalc_flag,
; 2875 :               update_display_flag,q_id,localstack,localbase);

	mov	ecx, DWORD PTR _update_display_flag$[ebp]
	mov	eax, DWORD PTR _recalc_flag$[ebp]
	mov	edx, DWORD PTR _localstack$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _q_id$[ebp]
	mov	DWORD PTR _update_display_flag$GSCopy$[ebp], ecx
	mov	ecx, DWORD PTR _thread_data_key
	push	edi
	mov	edi, DWORD PTR _node$[ebp]
	mov	DWORD PTR _recalc_flag$GSCopy$[ebp], eax
	mov	eax, DWORD PTR _localbase$[ebp]
	push	ecx
	mov	DWORD PTR _node$GSCopy$[ebp], edi
	mov	DWORD PTR _q_id$GSCopy$[ebp], esi
	mov	DWORD PTR _localstack$GSCopy$[ebp], edx
	mov	DWORD PTR _localbase$GSCopy$[ebp], eax
	call	_win_get_thread_data
	mov	ebx, eax
	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax-10387]
	add	esp, 4
	cmp	ecx, 160				; 000000a0H
	ja	$LN1@other_stuf

; 66   :   char *s,*h;
; 67   :   REAL scale;
; 68   :   int old; /* old state of toggle */
; 69   :   int oldquiet; /* old state of quiet_flag */
; 70   :   element_id id,fe,f_id,b_id;
; 71   : #ifdef __L_EVOLVER__
; 72   :   unsigned OpenGL_key;
; 73   : #endif
; 74   : 
; 75   : 
; 76   : 
; 77   : 
; 78   :   struct thread_data *td = GET_THREAD_DATA;
; 79   :   #define newstack  (td->eval_stack)
; 80   :   #define stackmax  (td->eval_stack_size)
; 81   :   #define stacktop  (td->stack_top)
; 82   :   #define this_frame ((struct eval_frame*)(newstack + td->frame_spot))
; 83   : 
; 84   :   switch ( node->type ) 

	jmp	DWORD PTR $LN1633@other_stuf[ecx*4]
$LN854@other_stuf:

; 85   :   {
; 86   :     case CONSTRAINT_FIXED_NODE:
; 87   :       { int connum = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 88   :         struct constraint *con = get_constraint(connum);

	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	lea	ecx, DWORD PTR [esi-8]
	mov	DWORD PTR [ebx+48], ecx

; 89   :         (*++stacktop) = !(con->attr & (NONPOSITIVE|NONNEGATIVE));

	mov	edx, DWORD PTR _web+652
	mov	eax, DWORD PTR [eax+edx+32]
	and	eax, 3
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv83[ebp], 1
	je	SHORT $LN860@other_stuf
	mov	DWORD PTR tv83[ebp], edx
$LN860@other_stuf:
	fild	DWORD PTR tv83[ebp]
	pop	edi
	lea	eax, DWORD PTR [ecx+8]
	pop	esi
	mov	DWORD PTR [ebx+48], eax
	fstp	QWORD PTR [eax]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN853@other_stuf:

; 90   :         break;
; 91   :       }
; 92   :     case CONSTRAINT_NONPOSITIVE_NODE:
; 93   :       { int connum = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 94   :         struct constraint *con = get_constraint(connum);

	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	lea	ecx, DWORD PTR [esi-8]
	mov	DWORD PTR [ebx+48], ecx

; 95   :         (*++stacktop) = !!(con->attr & NONPOSITIVE);

	mov	edx, DWORD PTR _web+652
	mov	eax, DWORD PTR [eax+edx+32]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv133[ebp], 1
	jne	SHORT $LN862@other_stuf
	mov	DWORD PTR tv133[ebp], edx
$LN862@other_stuf:
	fild	DWORD PTR tv133[ebp]
	pop	edi
	lea	eax, DWORD PTR [ecx+8]
	pop	esi
	mov	DWORD PTR [ebx+48], eax
	fstp	QWORD PTR [eax]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN852@other_stuf:

; 96   :         break;
; 97   :       }
; 98   :     case CONSTRAINT_NONNEGATIVE_NODE:
; 99   :       { int connum = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 100  :         struct constraint *con = get_constraint(connum);

	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	lea	ecx, DWORD PTR [esi-8]
	mov	DWORD PTR [ebx+48], ecx

; 101  :         (*++stacktop) = !!(con->attr & NONNEGATIVE);

	mov	edx, DWORD PTR _web+652
	mov	eax, DWORD PTR [eax+edx+32]
	and	eax, 2
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv151[ebp], 1
	jne	SHORT $LN864@other_stuf
	mov	DWORD PTR tv151[ebp], edx
$LN864@other_stuf:
	fild	DWORD PTR tv151[ebp]
	pop	edi
	lea	eax, DWORD PTR [ecx+8]
	pop	esi
	mov	DWORD PTR [ebx+48], eax
	fstp	QWORD PTR [eax]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN851@other_stuf:

; 102  :         break;
; 103  :       }
; 104  :     case CONSTRAINT_NORMAL_NODE:
; 105  :       { int connum = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 106  :         struct constraint *con = get_constraint(connum);

	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	lea	ecx, DWORD PTR [esi-8]
	mov	DWORD PTR [ebx+48], ecx

; 107  :         (*++stacktop) = !!(con->attr & NONPOSITIVE);

	mov	edx, DWORD PTR _web+652
	mov	eax, DWORD PTR [eax+edx+32]
	and	eax, 1
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv169[ebp], 1
	jne	SHORT $LN866@other_stuf
	mov	DWORD PTR tv169[ebp], edx
$LN866@other_stuf:
	fild	DWORD PTR tv169[ebp]
	pop	edi
	lea	eax, DWORD PTR [ecx+8]
	pop	esi
	mov	DWORD PTR [ebx+48], eax
	fstp	QWORD PTR [eax]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN850@other_stuf:

; 108  :         break;
; 109  :       }
; 110  :     case SIMPLEX_TO_FE_NODE:
; 111  :        simplex_to_fe(); break; 

	call	_simplex_to_fe
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN849@other_stuf:

; 112  :        
; 113  :     case REORDER_STORAGE_NODE:
; 114  :        reorder_storage(); break;

	call	_reorder_storage
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN848@other_stuf:

; 115  : 
; 116  :     case RENUMBER_ALL_NODE:
; 117  :        renumber_all(); break;

	call	_renumber_all
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN847@other_stuf:

; 118  : 
; 119  :     case DUMP_MEMLIST_NODE:
; 120  :        mem_list_dump(); break;

	call	_mem_list_dump
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN846@other_stuf:

; 121  : 
; 122  :     case VIEW_MATRIX_NODE:
; 123  :        i = (int)(*(stacktop--));

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 124  :        k = (int)(*(stacktop--));

	fld	QWORD PTR [esi-8]
	mov	DWORD PTR _i$[ebp], eax
	call	__ftol2_sse
	add	esi, -16				; fffffff0H
	mov	DWORD PTR [ebx+48], esi

; 125  :        if ( (k < 1) || (k > SDIM+1) || (i < 1) || (i > SDIM+1) )

	mov	edx, DWORD PTR _web+616
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, 1
	jl	SHORT $LN1215@other_stuf
	lea	ecx, DWORD PTR [edx+1]
	cmp	eax, ecx
	jg	SHORT $LN1215@other_stuf
	mov	esi, DWORD PTR _i$[ebp]
	cmp	esi, 1
	jl	SHORT $LN844@other_stuf
	cmp	esi, ecx
	jle	SHORT $LN845@other_stuf
	jmp	SHORT $LN844@other_stuf
$LN1215@other_stuf:
	mov	esi, DWORD PTR _i$[ebp]
$LN844@other_stuf:

; 126  :        { sprintf(errmsg,
; 127  :            "Illegal index: view_matrix[%d][%d] (must be 1 to %d)\n",k,i,SDIM);

	push	edx
	push	esi
	push	eax
	push	OFFSET ??_C@_0DG@GCIBKAME@Illegal?5index?3?5view_matrix?$FL?$CFd?$FN?$FL?$CF@
	push	OFFSET _errmsg
	call	_sprintf

; 128  :          sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 129  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL1093@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1093@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 130  :          kb_error(2008,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2008					; 000007d8H
	call	_kb_error
	mov	eax, DWORD PTR _k$[ebp]
	add	esp, 28					; 0000001cH
$LN845@other_stuf:

; 131  :        }
; 132  :        *(++stacktop) = view[k-1][i-1];

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR _view
	mov	edx, DWORD PTR [ecx+eax*4-4]
	mov	ebx, DWORD PTR [ebx+48]
	fld	QWORD PTR [edx+esi*8-8]
	pop	edi
	fstp	QWORD PTR [ebx]
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN843@other_stuf:

; 133  :        break;
; 134  : 
; 135  :     case RESET_COUNTS_NODE:
; 136  :        reset_counts();

	call	_reset_counts
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN842@other_stuf:

; 137  :        break;
; 138  : 
; 139  :     case FLUSH_COUNTS_NODE:
; 140  :        flush_counts();

	call	_flush_counts
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN841@other_stuf:

; 141  :        break;
; 142  : 
; 143  :     case PRINT_PROFILING_NODE:
; 144  :        print_profiling();

	call	_print_profiling
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN840@other_stuf:

; 145  :        break;
; 146  : 
; 147  :     case RESET_PROFILING_NODE:
; 148  :        reset_profiling();

	call	_reset_profiling
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN839@other_stuf:

; 149  :        break;
; 150  : 
; 151  :     case PAUSE_NODE:
; 152  : #ifdef __L_EVOLVER__
; 153  :        if ( l_evolver_mode )

	cmp	DWORD PTR _l_evolver_mode, 0
	je	SHORT $LN838@other_stuf

; 154  :        {
; 155  : 		  outstring("Paused; Select OpenGL Window, type F3 to continue, F7 to break: ");       

	push	OFFSET ??_C@_0EB@BDNHEIPM@Paused?$DL?5Select?5OpenGL?5Window?0?5ty@
	call	_outstring
	add	esp, 4

; 156  :           setOpenGL_key();

	call	_setOpenGL_key
	npad	3
$LL837@other_stuf:

; 157  : 		  do {OpenGL_key = getOpenGL_key();} while ( OpenGL_key == LEVOLVER_WAITING_FOR_OPENGL_KEYPRESS);

	call	_getOpenGL_key
	test	eax, eax
	je	SHORT $LL837@other_stuf

; 158  : 		  if (OpenGL_key == LEVOLVER_BREAK_OPENGL_KEYPRESS)

	cmp	eax, 2
$LN1602@other_stuf:
	jne	$LN855@other_stuf

; 159  :              breakflag = BREAKFULL;

	pop	edi
	pop	esi
	mov	DWORD PTR _breakflag, 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN838@other_stuf:

; 160  : 		  break;
; 161  : 	   }
; 162  : #endif
; 163  :        outstring("Paused; hit RETURN to continue, b to break: ");

	push	OFFSET ??_C@_0CN@EHLNHEIH@Paused?$DL?5hit?5RETURN?5to?5continue?0?5@
	call	_outstring

; 164  :        my_fgets(msg,msgmax,stdin);

	call	___iob_func
	mov	ecx, DWORD PTR _msg
	push	eax
	mov	eax, DWORD PTR _msgmax
	push	eax
	push	ecx
	call	_my_fgets

; 165  :        if ( msg[0] == 'b' ) 

	mov	edx, DWORD PTR _msg
	add	esp, 16					; 00000010H
	cmp	BYTE PTR [edx], 98			; 00000062H

; 166  :           breakflag = BREAKFULL;
; 167  :        break;

	jmp	SHORT $LN1602@other_stuf
$LN832@other_stuf:

; 168  : 
; 169  :     case HELP_KEYWORD_NODE:
; 170  :        keyword_help(node->op1.string);

	mov	eax, DWORD PTR [edi+32]
	push	eax
	call	_keyword_help
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN831@other_stuf:

; 171  :        break;
; 172  :   
; 173  :     case CREATE_VERTEX_NODE:
; 174  :      { vertex_id v_id;
; 175  :        REAL x[MAXCOORD];
; 176  :        for ( i = SDIM-1 ; i >= 0 ; i-- ) x[i] = *(stacktop--);

	mov	edx, DWORD PTR _web+616
	dec	edx
	js	SHORT $LN1090@other_stuf
	lea	esi, DWORD PTR [edx+1]
	cmp	esi, 4
	jl	SHORT $LC1091@other_stuf
	mov	eax, DWORD PTR [ebx+48]
	shr	esi, 2
	mov	edi, esi
	neg	edi
	lea	ecx, DWORD PTR _x$89908[ebp+edx*8-16]
	lea	edx, DWORD PTR [edx+edi*4]
	npad	4
$LL1092@other_stuf:
	fld	QWORD PTR [eax]
	sub	eax, 32					; 00000020H
	fstp	QWORD PTR [ecx+16]
	sub	ecx, 32					; 00000020H
	dec	esi
	fld	QWORD PTR [eax+24]
	fstp	QWORD PTR [ecx+40]
	fld	QWORD PTR [eax+16]
	fstp	QWORD PTR [ecx+32]
	fld	QWORD PTR [eax+8]
	fstp	QWORD PTR [ecx+24]
	jne	SHORT $LL1092@other_stuf
	mov	DWORD PTR [ebx+48], eax
$LC1091@other_stuf:
	test	edx, edx
	js	SHORT $LN1090@other_stuf
	mov	eax, DWORD PTR [ebx+48]
	npad	6
$LC830@other_stuf:
	fld	QWORD PTR [eax]
	sub	eax, 8
	dec	edx
	fstp	QWORD PTR _x$89908[ebp+edx*8+8]
	jns	SHORT $LC830@other_stuf
	mov	DWORD PTR [ebx+48], eax
$LN1090@other_stuf:

; 177  :        v_id = new_vertex(x,NULLID);

	lea	ecx, DWORD PTR _x$89908[ebp]
	push	0
	push	ecx
	call	_new_vertex
	add	esp, 8

; 178  :        new_vertex_id = ordinal(v_id) + 1;

	test	eax, 268435456				; 10000000H
	je	SHORT $LN867@other_stuf
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN868@other_stuf
$LN867@other_stuf:
	or	ecx, -1
$LN868@other_stuf:

; 179  :        set_original(v_id,new_vertex_id);

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	inc	ecx
	mov	DWORD PTR _new_vertex_id, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+20], ecx

; 180  :        *(++stacktop) = (REAL)new_vertex_id;

	add	DWORD PTR [ebx+48], 8
	mov	ebx, DWORD PTR [ebx+48]
	fild	DWORD PTR _new_vertex_id

; 181  :        *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	fstp	QWORD PTR [ebx]
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN827@other_stuf:

; 182  :        break;
; 183  :      }
; 184  : 
; 185  :     case FACET_CROSSCUT_NODE:
; 186  :       {
; 187  :         int v2 = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 188  :         int v1 = (int)(*stacktop--);

	fld	QWORD PTR [esi-8]

; 189  :         int f1 = (int)(*stacktop--);
; 190  :         edge_id new_edge_id = facet_crosscut(get_ordinal_id(FACET,f1-1),
; 191  :                     get_ordinal_id(VERTEX,v1-1), get_ordinal_id(VERTEX,v2-1));

	lea	edi, DWORD PTR [eax-1]
	call	__ftol2_sse
	fld	QWORD PTR [esi-16]
	mov	DWORD PTR _v1$89920[ebp], eax
	call	__ftol2_sse
	push	edi
	add	esi, -24				; ffffffe8H
	push	0
	mov	DWORD PTR _f1$89922[ebp], eax
	mov	DWORD PTR [ebx+48], esi
	call	_get_ordinal_id
	mov	edx, DWORD PTR _v1$89920[ebp]
	add	esp, 8
	push	eax
	dec	edx
	push	edx
	push	0
	call	_get_ordinal_id
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _f1$89922[ebp]
	dec	eax
	push	eax
	push	2
	call	_get_ordinal_id
	add	esp, 8
	push	eax
	call	_facet_crosscut
	add	esp, 12					; 0000000cH

; 192  :         *(++stacktop) = (REAL)(ordinal(new_edge_id)+1);

	test	eax, 268435456				; 10000000H
	je	SHORT $LN869@other_stuf
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN870@other_stuf
$LN869@other_stuf:
	or	eax, -1
$LN870@other_stuf:
	add	DWORD PTR [ebx+48], 8
	mov	ebx, DWORD PTR [ebx+48]

; 193  :         *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	inc	eax
	mov	DWORD PTR tv13189[ebp], eax
	fild	DWORD PTR tv13189[ebp]
	pop	edi
	pop	esi
	fstp	QWORD PTR [ebx]
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN826@other_stuf:

; 194  :         break;
; 195  :       }
; 196  : 
; 197  :     case CREATE_EDGE_NODE:
; 198  :       { vertex_id v_id2; 
; 199  :         vertex_id v_id1; 
; 200  :         int v2 = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 201  :         int v1 = (int)(*stacktop--);

	fld	QWORD PTR [esi-8]
	mov	DWORD PTR _v2$89931[ebp], eax
	call	__ftol2_sse

; 202  :         edge_id e_id;
; 203  :         v_id2 = get_ordinal_id(VERTEX,v2-1); 

	mov	edx, DWORD PTR _v2$89931[ebp]
	dec	edx
	push	edx
	add	esi, -16				; fffffff0H
	push	0
	mov	DWORD PTR _v1$89933[ebp], eax
	mov	DWORD PTR [ebx+48], esi
	call	_get_ordinal_id

; 204  :         v_id1 = get_ordinal_id(VERTEX,v1-1); 

	mov	esi, DWORD PTR _v1$89933[ebp]
	mov	DWORD PTR _v_id2$89929[ebp], eax
	lea	eax, DWORD PTR [esi-1]
	push	eax
	push	0
	call	_get_ordinal_id
	add	esp, 16					; 00000010H
	mov	DWORD PTR _v_id1$89930[ebp], eax

; 205  :         if ( !valid_id(v_id1) )

	test	eax, 268435456				; 10000000H
	jne	SHORT $LN1218@other_stuf

; 206  :         { sprintf(errmsg,"Invalid tail vertex %d in new_edge.\n",v1);

	push	esi
	push	OFFSET ??_C@_0CF@HPFGDKML@Invalid?5tail?5vertex?5?$CFd?5in?5new_ed@
	push	OFFSET _errmsg
	call	_sprintf

; 207  :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 208  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1094@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1094@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 209  :           kb_error(2009,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2009					; 000007d9H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1218@other_stuf:

; 210  :         }
; 211  :         if ( !valid_id(v_id2) )

	mov	esi, DWORD PTR _v_id2$89929[ebp]
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN824@other_stuf

; 212  :         { sprintf(errmsg,"Invalid head vertex %d in new_edge.\n",v2);

	mov	ecx, DWORD PTR _v2$89931[ebp]
	push	ecx
	push	OFFSET ??_C@_0CF@JBFABPPP@Invalid?5head?5vertex?5?$CFd?5in?5new_ed@
	push	OFFSET _errmsg
	call	_sprintf

; 213  :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 214  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL1095@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1095@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 215  :           kb_error(2010,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2010					; 000007daH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN824@other_stuf:

; 216  :         }
; 217  :         e_id = new_edge(v_id1,v_id2,NULLID);

	mov	eax, DWORD PTR _v_id1$89930[ebp]
	push	0
	push	esi
	push	eax
	call	_new_edge
	add	esp, 12					; 0000000cH

; 218  :         new_edge_id = ordinal(e_id)+1;

	test	eax, 268435456				; 10000000H
	je	SHORT $LN871@other_stuf
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN872@other_stuf
$LN871@other_stuf:
	or	ecx, -1
$LN872@other_stuf:

; 219  :         set_original(e_id,new_edge_id);

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	inc	ecx
	mov	DWORD PTR _new_edge_id, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+20], ecx

; 220  :         *(++stacktop) = (REAL)new_edge_id;

	add	DWORD PTR [ebx+48], 8
	mov	ebx, DWORD PTR [ebx+48]
	fild	DWORD PTR _new_edge_id

; 221  :         *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	fstp	QWORD PTR [ebx]
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN823@other_stuf:

; 222  :       }
; 223  :       break;
; 224  : 
; 225  :     case CREATE_FACET_NODE:
; 226  :     { facetedge_id old_fe = NULLID;
; 227  :        edge_id e_id;
; 228  :        vertex_id tv,hv;
; 229  : #define ORD_ID(id) ((id)<0 ? inverse_id(get_ordinal_id(EDGE,-1-(id)))  : \
; 230  :                                    get_ordinal_id(EDGE,(id)-1))
; 231  :        f_id = NULLID;
; 232  :        fe = NULLID; 
; 233  :        if ( (web.representation == STRING) || (web.representation == SOAPFILM) )

	mov	ecx, DWORD PTR _web+624
	xor	eax, eax
	mov	DWORD PTR _old_fe$89948[ebp], eax
	mov	DWORD PTR _fe$[ebp], eax
	cmp	ecx, 1
	je	$LN821@other_stuf
	cmp	ecx, 2
	je	$LN821@other_stuf

; 317  :        }
; 318  :        else if ( web.representation == SIMPLEX )

	cmp	ecx, 3
	jne	$LN795@other_stuf

; 319  :        {  vertex_id *v;
; 320  :           n = node[node->left].op1.argcount; /* size of edge list */

	mov	edx, DWORD PTR [edi+4]
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [edx+edi+32]
	mov	DWORD PTR _n$[ebp], ecx

; 321  :           for ( i = 0 ; i < n ; i++ )

	cmp	ecx, eax
	jle	$LN792@other_stuf

; 319  :        {  vertex_id *v;
; 320  :           n = node[node->left].op1.argcount; /* size of edge list */

	xor	esi, esi
	mov	DWORD PTR tv6226[ebp], ecx
$LL794@other_stuf:

; 322  :             if ( !valid_id(get_ordinal_id(VERTEX,(int)stacktop[-i]-1) ) )

	mov	eax, DWORD PTR [ebx+48]
	sub	eax, esi
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	dec	eax
	push	eax
	push	0
	call	_get_ordinal_id
	add	esp, 8
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN793@other_stuf

; 323  :                { sprintf(msg,"Invalid vertex %d in new_facet.\n",(int)stacktop[-i]);

	mov	ecx, DWORD PTR [ebx+48]
	sub	ecx, esi
	fld	QWORD PTR [ecx]
	call	__ftol2_sse
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0CB@CBNNHBLA@Invalid?5vertex?5?$CFd?5in?5new_facet?4?6@
	push	edx
	call	_sprintf

; 324  :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 325  :                       file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL1096@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1096@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 326  :                  kb_error(2014,msg,RECOVERABLE);

	mov	ecx, DWORD PTR _msg
	push	1
	push	ecx
	push	2014					; 000007deH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN793@other_stuf:

; 321  :           for ( i = 0 ; i < n ; i++ )

	add	esi, 8
	dec	DWORD PTR tv6226[ebp]
	jne	$LL794@other_stuf
$LN792@other_stuf:

; 327  :                }
; 328  :           f_id = new_facet();

	call	_new_facet

; 329  :           v = get_facet_vertices(f_id);

	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR _web+328
	mov	DWORD PTR _f_id$[ebp], eax
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [ecx+edx+304]

; 330  :           for ( i = 0 ; i < n ; i++ ) v[i] = get_ordinal_id(VERTEX,(int)stacktop[-n+i+1]-1);

	xor	edi, edi
	mov	DWORD PTR _v$90016[ebp], eax
	cmp	DWORD PTR _n$[ebp], edi
	jle	$LN797@other_stuf

; 327  :                }
; 328  :           f_id = new_facet();

	mov	esi, DWORD PTR _n$[ebp]
	neg	esi
	add	esi, esi
	add	esi, esi
	add	esi, esi
	npad	1
$LL790@other_stuf:

; 330  :           for ( i = 0 ; i < n ; i++ ) v[i] = get_ordinal_id(VERTEX,(int)stacktop[-n+i+1]-1);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi+eax+8]
	call	__ftol2_sse
	dec	eax
	push	eax
	push	0
	call	_get_ordinal_id
	mov	ecx, DWORD PTR _v$90016[ebp]
	mov	DWORD PTR [ecx+edi*4], eax
	inc	edi
	add	esp, 8
	add	esi, 8
	cmp	edi, DWORD PTR _n$[ebp]
	jl	SHORT $LL790@other_stuf

; 331  :           stacktop -= n; /* pop id's */

	jmp	$LN797@other_stuf
$LN821@other_stuf:

; 234  :        { n = node[node->left].op1.argcount; /* size of edge list */

	mov	edx, DWORD PTR [edi+4]
	imul	edx, 168				; 000000a8H
	mov	ecx, DWORD PTR [edx+edi+32]
	mov	DWORD PTR _n$[ebp], ecx

; 235  :          for ( i = 0 ; i < n ; i++ ) 

	cmp	ecx, eax
	jle	$LN818@other_stuf

; 234  :        { n = node[node->left].op1.argcount; /* size of edge list */

	xor	esi, esi
	mov	DWORD PTR tv4090[ebp], ecx
	npad	7
$LL820@other_stuf:

; 236  :            if ( !valid_id(ORD_ID((int)(stacktop[-i]))) )

	mov	eax, DWORD PTR [ebx+48]
	sub	eax, esi
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	test	eax, eax
	jns	SHORT $LN873@other_stuf
	or	ecx, -1
	sub	ecx, eax
	push	ecx
	push	1
	call	_get_ordinal_id
	add	esp, 8
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN874@other_stuf
$LN873@other_stuf:
	dec	eax
	push	eax
	push	1
	call	_get_ordinal_id
	add	esp, 8
$LN874@other_stuf:
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN819@other_stuf

; 237  :            { sprintf(msg,"Invalid edge %g in new_facet.\n",(double)stacktop[-i]);

	mov	edx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR _msg
	sub	edx, esi
	fld	QWORD PTR [edx]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0BP@JHAMAKO@Invalid?5edge?5?$CFg?5in?5new_facet?4?6?$AA@
	push	eax
	call	_sprintf

; 238  :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 239  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL1097@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1097@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 240  :              kb_error(2011,msg,RECOVERABLE);

	mov	ecx, DWORD PTR _msg
	push	1
	push	ecx
	push	2011					; 000007dbH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN819@other_stuf:

; 235  :          for ( i = 0 ; i < n ; i++ ) 

	add	esi, 8
	dec	DWORD PTR tv4090[ebp]
	jne	$LL820@other_stuf
$LN818@other_stuf:

; 241  :            }
; 242  :          /* check continuity */
; 243  :          i = 1-n;
; 244  :          e_id = ORD_ID((int)(stacktop[i]));

	mov	edx, DWORD PTR [ebx+48]
	mov	eax, 1
	sub	eax, DWORD PTR _n$[ebp]
	fld	QWORD PTR [edx+eax*8]
	mov	DWORD PTR _i$[ebp], eax
	call	__ftol2_sse
	test	eax, eax
	jns	SHORT $LN875@other_stuf
	or	ecx, -1
	sub	ecx, eax
	push	ecx
	push	1
	call	_get_ordinal_id
	add	esp, 8
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN876@other_stuf
$LN875@other_stuf:
	dec	eax
	push	eax
	push	1
	call	_get_ordinal_id
	add	esp, 8
$LN876@other_stuf:

; 245  :          hv = get_edge_headv(e_id);

	push	eax
	call	_get_edge_headv
	mov	esi, eax

; 246  :          for ( i++ ; i <= 0 ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	add	esp, 4
	test	eax, eax
	jg	$LN1204@other_stuf

; 245  :          hv = get_edge_headv(e_id);

	mov	edx, eax
	lea	eax, DWORD PTR [edx*8]
	mov	DWORD PTR tv14284[ebp], eax
	npad	1
$LL816@other_stuf:

; 247  :          { e_id = ORD_ID((int)(stacktop[i]));

	mov	ecx, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR tv14284[ebp]
	fld	QWORD PTR [edx+ecx]
	call	__ftol2_sse
	test	eax, eax
	jns	SHORT $LN877@other_stuf
	or	ecx, -1
	sub	ecx, eax
	push	ecx
	push	1
	call	_get_ordinal_id
	add	esp, 8
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN1583@other_stuf
$LN877@other_stuf:
	dec	eax
	push	eax
	push	1
	call	_get_ordinal_id
	add	esp, 8
$LN1583@other_stuf:

; 248  :            tv = get_edge_tailv(e_id);

	mov	edx, eax
	push	edx
	mov	DWORD PTR _e_id$89949[ebp], eax
	call	_get_edge_tailv
	add	esp, 4
	mov	DWORD PTR _tv$89950[ebp], eax

; 249  :            if ( !equal_id(hv,tv) )

	cmp	esi, eax
	je	$LN813@other_stuf

; 250  :            { sprintf(errmsg,
; 251  :                "Inconsistency: edge %s tail vertex %s disagrees with previous head %s.\n",
; 252  :                            ELNAME(e_id),ELNAME1(tv),ELNAME2(hv));

	test	esi, 268435456				; 10000000H
	je	SHORT $LN879@other_stuf
	and	esi, 134217727				; 07ffffffH
	inc	esi
	push	esi
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+60
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv566[ebp], OFFSET _elnames+60
	jmp	SHORT $LN880@other_stuf
$LN879@other_stuf:
	mov	DWORD PTR tv566[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN880@other_stuf:
	test	DWORD PTR _tv$89950[ebp], 268435456	; 10000000H
	je	SHORT $LN881@other_stuf
	mov	eax, DWORD PTR _tv$89950[ebp]
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames+30
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	esi, OFFSET _elnames+30
	jmp	SHORT $LN882@other_stuf
$LN881@other_stuf:
	mov	esi, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN882@other_stuf:
	mov	eax, DWORD PTR _e_id$89949[ebp]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN883@other_stuf
	and	eax, 134217727				; 07ffffffH
	inc	eax
	push	eax
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN884@other_stuf
$LN883@other_stuf:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN884@other_stuf:
	mov	ecx, DWORD PTR tv566[ebp]
	push	ecx
	push	esi
	push	eax
	push	OFFSET ??_C@_0EI@EGODMHEI@Inconsistency?3?5edge?5?$CFs?5tail?5vert@
	push	OFFSET _errmsg
	call	_sprintf

; 253  :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 254  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR [eax+1]
$LL1098@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1098@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 255  :              kb_error(2012,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2012					; 000007dcH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN813@other_stuf:

; 256  :            }
; 257  :            hv = get_edge_headv(e_id);

	mov	eax, DWORD PTR _e_id$89949[ebp]
	push	eax
	call	_get_edge_headv
	mov	esi, eax
	mov	eax, DWORD PTR tv14284[ebp]
	add	eax, 8
	add	esp, 4
	mov	DWORD PTR tv14284[ebp], eax
	test	eax, eax
	jle	$LL816@other_stuf
$LN1204@other_stuf:

; 258  :          }
; 259  :          if ( web.representation == SOAPFILM)

	cmp	DWORD PTR _web+624, 2
	jne	$LN1206@other_stuf

; 260  :          {
; 261  :            e_id = ORD_ID((int)(stacktop[0]));

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	call	__ftol2_sse
	test	eax, eax
	jns	SHORT $LN885@other_stuf
	or	edx, -1
	sub	edx, eax
	push	edx
	push	1
	call	_get_ordinal_id
	add	esp, 8
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN886@other_stuf
$LN885@other_stuf:
	dec	eax
	push	eax
	push	1
	call	_get_ordinal_id
	add	esp, 8
$LN886@other_stuf:

; 262  :            hv = get_edge_headv(e_id);

	push	eax
	call	_get_edge_headv

; 263  :            e_id = ORD_ID((int)(stacktop[1-n]));

	mov	esi, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR [ebx+48]
	mov	DWORD PTR _hv$89951[ebp], eax
	lea	eax, DWORD PTR [esi*8]
	sub	ecx, eax
	fld	QWORD PTR [ecx+8]
	add	esp, 4
	call	__ftol2_sse
	test	eax, eax
	jns	SHORT $LN887@other_stuf
	or	edx, -1
	sub	edx, eax
	push	edx
	push	1
	call	_get_ordinal_id
	add	esp, 8
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN888@other_stuf
$LN887@other_stuf:
	dec	eax
	push	eax
	push	1
	call	_get_ordinal_id
	add	esp, 8
$LN888@other_stuf:

; 264  :            tv = get_edge_tailv(e_id);

	push	eax
	call	_get_edge_tailv
	add	esp, 4

; 265  :            if ( !equal_id(hv,tv) ) 

	cmp	DWORD PTR _hv$89951[ebp], eax
	je	SHORT $LN1226@other_stuf

; 266  :            { sprintf(errmsg,
; 267  :              "Inconsistency in first edge tail vertex and last edge head.\n");

	push	OFFSET ??_C@_0DN@FPFBNAIB@Inconsistency?5in?5first?5edge?5tail@
	push	OFFSET _errmsg
	call	_sprintf

; 268  :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 269  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL1099@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1099@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 270  :              kb_error(2013,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2013					; 000007ddH
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	SHORT $LN1226@other_stuf
$LN1206@other_stuf:
	mov	esi, DWORD PTR _n$[ebp]
$LN1226@other_stuf:

; 271  :            }
; 272  :          }
; 273  :          f_id = new_facet();

	call	_new_facet

; 274  :          set_original(f_id,f_id);

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	add	ecx, ecx
	add	ecx, ecx
	mov	edx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _f_id$[ebp], eax
	mov	DWORD PTR tv9126[ebp], ecx
	mov	DWORD PTR [edx+20], eax

; 275  :          for ( i = 0 ; i < n ; i++ ) 

	test	esi, esi
	jle	$LN1207@other_stuf

; 271  :            }
; 272  :          }
; 273  :          f_id = new_facet();

	mov	eax, esi
	neg	eax
	add	eax, eax
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv14338[ebp], eax
	mov	DWORD PTR tv4197[ebp], esi
	npad	9
$LL810@other_stuf:

; 276  :          { facetedge_id edge_fe;
; 277  :            e_id = ORD_ID((int)(stacktop[i-n+1]));

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR tv14338[ebp]
	fld	QWORD PTR [ecx+eax+8]
	call	__ftol2_sse
	test	eax, eax
	jns	SHORT $LN889@other_stuf
	or	edx, -1
	sub	edx, eax
	push	edx
	push	1
	call	_get_ordinal_id
	mov	esi, eax
	add	esp, 8
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN890@other_stuf
$LN889@other_stuf:
	dec	eax
	push	eax
	push	1
	call	_get_ordinal_id
	add	esp, 8
	mov	esi, eax
$LN890@other_stuf:

; 278  :            fe = new_facetedge(f_id,e_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	esi
	push	eax
	call	_new_facetedge

; 279  :            if ( !valid_id(get_facet_fe(f_id)) )

	mov	ecx, DWORD PTR _f_id$[ebp]
	push	ecx
	mov	edi, eax
	call	_get_facet_fe
	add	esp, 12					; 0000000cH

; 280  :               set_facet_fe(f_id,fe);

	push	edi
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN807@other_stuf
	mov	edx, DWORD PTR _f_id$[ebp]
	push	edx
	call	_set_facet_fe
	add	esp, 8

; 281  :            else

	jmp	SHORT $LN806@other_stuf
$LN807@other_stuf:

; 282  :            { set_next_edge(old_fe,fe);

	mov	eax, DWORD PTR _old_fe$89948[ebp]
	push	eax
	call	_set_next_edge

; 283  :              set_prev_edge(fe,old_fe);

	mov	ecx, DWORD PTR _old_fe$89948[ebp]
	push	ecx
	push	edi
	call	_set_prev_edge
	add	esp, 16					; 00000010H
$LN806@other_stuf:

; 284  :            }
; 285  :            old_fe = fe;
; 286  :            /* add to edge facet list, and get in geometric order */
; 287  :            edge_fe = get_edge_fe(e_id);

	mov	eax, DWORD PTR _web+124
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _old_fe$89948[ebp], edi
	test	eax, eax
	je	SHORT $LN1006@other_stuf
$LN1007@other_stuf:
	mov	eax, DWORD PTR [eax+28]
	test	esi, 134217728				; 08000000H
	je	SHORT $LN1006@other_stuf
	xor	eax, 134217728				; 08000000H
$LN1006@other_stuf:
	mov	DWORD PTR _edge_fe$89997[ebp], eax

; 288  :            if ( valid_id(edge_fe) )

	test	eax, 268435456				; 10000000H
	je	SHORT $LN805@other_stuf

; 289  :            { /* insert in chain */
; 290  :              set_next_facet(fe,get_next_facet(edge_fe));

	mov	ecx, DWORD PTR _web+460
	test	eax, 134217728				; 08000000H
	je	SHORT $LN1011@other_stuf
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN1010@other_stuf
$LN1011@other_stuf:
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+40]
$LN1010@other_stuf:
	push	eax
	push	edi
	call	_set_next_facet

; 291  :              set_prev_facet(fe,edge_fe);

	mov	esi, DWORD PTR _edge_fe$89997[ebp]
	push	esi
	push	edi
	call	_set_prev_facet

; 292  :              set_prev_facet(get_next_facet(fe),fe);

	mov	ecx, DWORD PTR _web+460
	mov	eax, edi
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+eax*4]
	add	esp, 16					; 00000010H
	test	edi, 134217728				; 08000000H
	je	SHORT $LN1015@other_stuf
	mov	eax, DWORD PTR [edx+36]
	xor	eax, 134217728				; 08000000H
	jmp	SHORT $LN1014@other_stuf
$LN1015@other_stuf:
	mov	eax, DWORD PTR [edx+40]
$LN1014@other_stuf:
	push	edi
	push	eax
	call	_set_prev_facet

; 293  :              set_next_facet(edge_fe,fe);

	push	edi
	push	esi
	call	_set_next_facet
	add	esp, 16					; 00000010H

; 294  :            }
; 295  :            else

	jmp	SHORT $LN809@other_stuf
$LN805@other_stuf:

; 296  :            { set_next_facet(fe,fe);

	push	edi
	push	edi
	call	_set_next_facet

; 297  :              set_prev_facet(fe,fe);

	push	edi
	push	edi
	call	_set_prev_facet

; 298  :              set_edge_fe(e_id,fe);      /* link edge to rest of world */

	push	edi
	push	esi
	call	_set_edge_fe
	add	esp, 24					; 00000018H
$LN809@other_stuf:

; 275  :          for ( i = 0 ; i < n ; i++ ) 

	add	DWORD PTR tv14338[ebp], 8
	dec	DWORD PTR tv4197[ebp]
	jne	$LL810@other_stuf
	mov	ecx, DWORD PTR tv9126[ebp]
	mov	eax, DWORD PTR _f_id$[ebp]
	jmp	SHORT $LN808@other_stuf
$LN1207@other_stuf:
	mov	edi, DWORD PTR _fe$[ebp]
$LN808@other_stuf:

; 299  :            }
; 300  :          }
; 301  :          if ( equal_id(get_fe_tailv(get_facet_fe(f_id)),get_fe_headv(fe)) )

	mov	edx, eax
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	DWORD PTR tv9261[ebp], edx
	jne	SHORT $LN1019@other_stuf
	xor	esi, esi
	jmp	SHORT $LN1018@other_stuf
$LN1019@other_stuf:
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ecx+edx]
	mov	esi, DWORD PTR [ecx+28]
	test	eax, 134217728				; 08000000H
	je	SHORT $LN1018@other_stuf
	xor	esi, 134217728				; 08000000H
$LN1018@other_stuf:
	mov	eax, DWORD PTR _web+460
	mov	edx, edi
	and	edx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, edi
	and	edx, 134217728				; 08000000H
	xor	edx, DWORD PTR [ecx+20]
	push	edx
	call	_get_edge_headv
	mov	edx, DWORD PTR _web+460
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	esi, 134217728				; 08000000H
	xor	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR tv9749[ebp], eax
	push	esi
	call	_get_edge_tailv

; 302  :          {
; 303  :            set_next_edge(fe,get_facet_fe(f_id));  /* close up ring */

	mov	esi, DWORD PTR tv9261[ebp]
	add	esp, 8
	cmp	eax, DWORD PTR tv9749[ebp]
	jne	SHORT $LN803@other_stuf
	test	esi, esi
	jne	SHORT $LN1027@other_stuf
	xor	eax, eax
	jmp	SHORT $LN1026@other_stuf
$LN1027@other_stuf:
	test	DWORD PTR _f_id$[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR tv9126[ebp]
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [ecx+28]
	je	SHORT $LN1026@other_stuf
	xor	eax, 134217728				; 08000000H
$LN1026@other_stuf:
	push	eax
	push	edi
	call	_set_next_edge
	add	esp, 8

; 304  :            set_prev_edge(get_facet_fe(f_id),fe);

	test	esi, esi
	jne	SHORT $LN1031@other_stuf
	xor	eax, eax
	jmp	SHORT $LN1030@other_stuf
$LN1031@other_stuf:
	test	DWORD PTR _f_id$[ebp], 134217728	; 08000000H
	mov	eax, DWORD PTR tv9126[ebp]
	mov	edx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [eax+edx]
	mov	eax, DWORD PTR [ecx+28]
	je	SHORT $LN1030@other_stuf
	xor	eax, 134217728				; 08000000H
$LN1030@other_stuf:
	push	edi
	push	eax
	call	_set_prev_edge
	add	esp, 8
$LN803@other_stuf:

; 305  :          }
; 306  :          if ( web.representation == SOAPFILM ) 

	cmp	DWORD PTR _web+624, 2
	jne	$LN797@other_stuf

; 307  :           { fe = get_facet_fe(f_id);

	test	esi, esi
	je	SHORT $LN1034@other_stuf
$LN1035@other_stuf:
	test	DWORD PTR _f_id$[ebp], 134217728	; 08000000H
	mov	edx, DWORD PTR _web+236
	mov	eax, DWORD PTR tv9126[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	esi, DWORD PTR [ecx+28]
	je	SHORT $LN1034@other_stuf
	xor	esi, 134217728				; 08000000H
$LN1034@other_stuf:

; 308  :             for ( i = 0 ; i < n ; i++,fe = get_next_edge(fe) )

	cmp	DWORD PTR _n$[ebp], 0
	jle	SHORT $LN799@other_stuf
	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR tv4226[ebp], edx
	npad	8
$LL1038@other_stuf:

; 309  :                 fe_reorder(get_fe_edge(fe));

	mov	eax, DWORD PTR _web+460
	mov	edi, esi
	and	edi, 134217727				; 07ffffffH
	add	edi, edi
	add	edi, edi
	mov	ecx, DWORD PTR [eax+edi]
	mov	edx, esi
	and	edx, 134217728				; 08000000H
	xor	edx, DWORD PTR [ecx+20]
	push	edx
	call	_fe_reorder
	add	esp, 4
	test	esi, 134217728				; 08000000H
	je	SHORT $LN1039@other_stuf

; 308  :             for ( i = 0 ; i < n ; i++,fe = get_next_edge(fe) )

	mov	eax, DWORD PTR _web+460
	mov	ecx, DWORD PTR [eax+edi]
	mov	esi, DWORD PTR [ecx+28]
	xor	esi, 134217728				; 08000000H
	jmp	SHORT $LN1078@other_stuf
$LN1039@other_stuf:
	mov	edx, DWORD PTR _web+460
	mov	eax, DWORD PTR [edx+edi]
	mov	esi, DWORD PTR [eax+32]
$LN1078@other_stuf:
	dec	DWORD PTR tv4226[ebp]
	jne	SHORT $LL1038@other_stuf
$LN799@other_stuf:

; 310  :             if ( n > 3 ) face_triangulate(f_id,n);

	cmp	DWORD PTR _n$[ebp], 3
	jle	SHORT $LN1205@other_stuf
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _f_id$[ebp]
	push	ecx
	push	edx
	call	_face_triangulate
	add	esp, 8
$LN1205@other_stuf:

; 311  :             recalc_facet_area(f_id);

	mov	eax, DWORD PTR _f_id$[ebp]
	push	eax
	call	_recalc_facet_area
	add	esp, 4

; 312  :           }
; 313  :          if ( web.representation == SOAPFILM ) 

	cmp	DWORD PTR _web+624, 2
	jne	SHORT $LN797@other_stuf

; 314  :            need_fe_reorder_flag = 1;

	mov	DWORD PTR _need_fe_reorder_flag, 1
$LN797@other_stuf:

; 315  : 
; 316  :           stacktop -= n; /* pop id's */

	mov	eax, DWORD PTR _n$[ebp]
	neg	eax
	add	eax, eax
	add	eax, eax
	add	eax, eax
	add	DWORD PTR [ebx+48], eax
	mov	eax, DWORD PTR _f_id$[ebp]
$LN795@other_stuf:

; 332  :        }
; 333  :     }
; 334  :     new_facet_id = ordinal(f_id) + 1;

	test	eax, 268435456				; 10000000H
	je	SHORT $LN891@other_stuf
	and	eax, 134217727				; 07ffffffH
	jmp	SHORT $LN892@other_stuf
$LN891@other_stuf:
	or	eax, -1
$LN892@other_stuf:

; 335  :     *(++stacktop) = (REAL)new_facet_id;
; 336  :     *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	inc	eax
	mov	DWORD PTR _new_facet_id, eax
	add	DWORD PTR [ebx+48], 8
	fild	DWORD PTR _new_facet_id
	mov	ebx, DWORD PTR [ebx+48]
	pop	edi
	fstp	QWORD PTR [ebx]
	pop	esi
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN787@other_stuf:

; 337  :     break;
; 338  : 
; 339  :     case CREATE_BODY_NODE:
; 340  :        { body_id b_id = new_body();

	call	_new_body

; 341  :           new_body_id = ordinal(b_id) + 1;

	test	eax, 268435456				; 10000000H
	je	SHORT $LN893@other_stuf
	mov	ecx, eax
	and	ecx, 134217727				; 07ffffffH
	jmp	SHORT $LN894@other_stuf
$LN893@other_stuf:
	or	ecx, -1
$LN894@other_stuf:

; 342  :           set_original(b_id,new_body_id);

	mov	edx, eax
	shr	edx, 29					; 0000001dH
	imul	edx, 112				; 00000070H
	mov	edx, DWORD PTR _web[edx+12]
	inc	ecx
	mov	DWORD PTR _new_body_id, ecx
	and	eax, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax+20], ecx

; 343  :           *(++stacktop) = (REAL)new_body_id;

	add	DWORD PTR [ebx+48], 8
	mov	ebx, DWORD PTR [ebx+48]
	fild	DWORD PTR _new_body_id

; 344  :        }
; 345  :        *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	fstp	QWORD PTR [ebx]
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN786@other_stuf:

; 346  :        break;
; 347  : 
; 348  : 
; 349  :     case MERGE_VERTEX_NODE:
; 350  :       { vertex_id v_id2; 
; 351  :         vertex_id v_id1; 
; 352  :         int v2 = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 353  :         int v1 = (int)(*stacktop--);

	fld	QWORD PTR [esi-8]
	mov	DWORD PTR _v2$90046[ebp], eax
	lea	eax, DWORD PTR [esi-8]
	mov	DWORD PTR tv8938[ebp], eax
	call	__ftol2_sse
	mov	edx, DWORD PTR tv8938[ebp]
	add	edx, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], edx

; 354  :         v_id2 = get_ordinal_id(VERTEX,v2-1); 

	mov	ebx, DWORD PTR _v2$90046[ebp]
	mov	esi, eax
	lea	eax, DWORD PTR [ebx-1]
	push	eax
	push	0
	call	_get_ordinal_id

; 355  :         v_id1 = get_ordinal_id(VERTEX,v1-1); 

	lea	ecx, DWORD PTR [esi-1]
	push	ecx
	push	0
	mov	DWORD PTR _v_id2$90044[ebp], eax
	call	_get_ordinal_id
	add	esp, 16					; 00000010H
	mov	DWORD PTR _v_id1$90045[ebp], eax

; 356  :         if ( (v1==0) || !valid_id(v_id1) )

	test	esi, esi
	je	SHORT $LN784@other_stuf
	test	eax, 268435456				; 10000000H
	jne	SHORT $LN785@other_stuf
$LN784@other_stuf:

; 357  :         { sprintf(errmsg,"Invalid first vertex %d in vertex_merge.\n",v1);

	push	esi
	push	OFFSET ??_C@_0CK@PMDCPJHL@Invalid?5first?5vertex?5?$CFd?5in?5verte@
	push	OFFSET _errmsg
	call	_sprintf

; 358  :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 359  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL1100@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1100@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 360  :           kb_error(3886,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3886					; 00000f2eH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN785@other_stuf:

; 361  :         }
; 362  :         if ( (v2==0) || !valid_id(v_id2) )

	test	ebx, ebx
	je	SHORT $LN782@other_stuf
	test	DWORD PTR _v_id2$90044[ebp], 268435456	; 10000000H
	jne	SHORT $LN1223@other_stuf
$LN782@other_stuf:

; 363  :         { sprintf(errmsg,"Invalid second vertex %d in vertex_merge.\n",v2);

	push	ebx
	push	OFFSET ??_C@_0CL@ODOEFJO@Invalid?5second?5vertex?5?$CFd?5in?5vert@
	push	OFFSET _errmsg
	call	_sprintf

; 364  :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 365  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1101@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1101@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 366  :           kb_error(3916,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3916					; 00000f4cH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1223@other_stuf:

; 367  :         }
; 368  :         merge_vertex(v_id1,v_id2);

	mov	ecx, DWORD PTR _v_id2$90044[ebp]
	mov	edx, DWORD PTR _v_id1$90045[ebp]
	push	ecx
	push	edx
	call	_merge_vertex

; 369  :         *recalc_flag = 1;

	mov	eax, DWORD PTR _recalc_flag$GSCopy$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN781@other_stuf:

; 370  :       }
; 371  :       break;
; 372  : 
; 373  :     case MERGE_EDGE_NODE:
; 374  :       { edge_id e_id2; 
; 375  :         edge_id e_id1; 
; 376  :         int e2 = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 377  :         int e1 = (int)(*stacktop--);

	fld	QWORD PTR [esi-8]
	mov	DWORD PTR _e2$90061[ebp], eax
	call	__ftol2_sse
	mov	DWORD PTR _e1$90063[ebp], eax
	add	esi, -16				; fffffff0H
	mov	DWORD PTR [ebx+48], esi

; 378  :         e_id2 = get_ordinal_id(EDGE,abs(e2)-1); 

	mov	ebx, DWORD PTR _e2$90061[ebp]
	mov	eax, ebx
	cdq
	xor	eax, edx
	sub	eax, edx
	dec	eax
	push	eax
	push	1
	call	_get_ordinal_id
	add	esp, 8
	mov	DWORD PTR _e_id2$90059[ebp], eax

; 379  :         if ( e2 < 0 )  invert(e_id2);

	test	ebx, ebx
	jns	SHORT $LN780@other_stuf
	xor	DWORD PTR _e_id2$90059[ebp], 134217728	; 08000000H
$LN780@other_stuf:

; 380  :         e_id1 = get_ordinal_id(EDGE,abs(e1)-1); 

	mov	esi, DWORD PTR _e1$90063[ebp]
	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	dec	eax
	push	eax
	push	1
	call	_get_ordinal_id
	add	esp, 8
	mov	DWORD PTR _e_id1$90060[ebp], eax

; 381  :         if ( e1 < 0 ) invert(e_id1);

	test	esi, esi
	jns	SHORT $LN1584@other_stuf
	xor	DWORD PTR _e_id1$90060[ebp], 134217728	; 08000000H

; 382  :         if ( (e1==0) ||!valid_id(e_id1) )

	test	esi, esi
$LN1584@other_stuf:
	je	SHORT $LN777@other_stuf
	test	DWORD PTR _e_id1$90060[ebp], 268435456	; 10000000H
	jne	SHORT $LN778@other_stuf
$LN777@other_stuf:

; 383  :         { sprintf(errmsg,"Invalid first edge %d in edge_merge.\n",e1);

	push	esi
	push	OFFSET ??_C@_0CG@ELHCLELH@Invalid?5first?5edge?5?$CFd?5in?5edge_me@
	push	OFFSET _errmsg
	call	_sprintf

; 384  :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 385  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL1102@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1102@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 386  :           kb_error(3878,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3878					; 00000f26H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN778@other_stuf:

; 387  :         }
; 388  :         if ( (e2==0) || !valid_id(e_id2) )

	test	ebx, ebx
	je	SHORT $LN775@other_stuf
	test	DWORD PTR _e_id2$90059[ebp], 268435456	; 10000000H
	jne	SHORT $LN1225@other_stuf
$LN775@other_stuf:

; 389  :         { sprintf(errmsg,"Invalid second edge %d in edge_merge.\n",e2);

	push	ebx
	push	OFFSET ??_C@_0CH@CHOJCNFH@Invalid?5second?5edge?5?$CFd?5in?5edge_m@
	push	OFFSET _errmsg
	call	_sprintf

; 390  :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 391  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1103@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1103@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 392  :           kb_error(3912,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3912					; 00000f48H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1225@other_stuf:

; 393  :         }
; 394  :         merge_edge(e_id1,e_id2);

	mov	ecx, DWORD PTR _e_id2$90059[ebp]
	mov	edx, DWORD PTR _e_id1$90060[ebp]
	push	ecx
	push	edx
	call	_merge_edge

; 395  :         *recalc_flag = 1;

	mov	eax, DWORD PTR _recalc_flag$GSCopy$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN774@other_stuf:

; 396  :       }
; 397  :       break;
; 398  : 
; 399  :     case MERGE_FACET_NODE:
; 400  :       { facet_id f_id2; 
; 401  :         facet_id f_id1; 
; 402  :         int f2 = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 403  :         int f1 = (int)(*stacktop--);

	fld	QWORD PTR [esi-8]
	mov	DWORD PTR _f2$90078[ebp], eax
	call	__ftol2_sse
	mov	DWORD PTR _f1$90080[ebp], eax
	add	esi, -16				; fffffff0H
	mov	DWORD PTR [ebx+48], esi

; 404  :         f_id2 = get_ordinal_id(FACET,abs(f2)-1); 

	mov	ebx, DWORD PTR _f2$90078[ebp]
	mov	eax, ebx
	cdq
	xor	eax, edx
	sub	eax, edx
	dec	eax
	push	eax
	push	2
	call	_get_ordinal_id
	add	esp, 8
	mov	DWORD PTR _f_id2$90076[ebp], eax

; 405  :         if ( f2 < 0 ) invert(f_id2);

	test	ebx, ebx
	jns	SHORT $LN773@other_stuf
	xor	DWORD PTR _f_id2$90076[ebp], 134217728	; 08000000H
$LN773@other_stuf:

; 406  :         f_id1 = get_ordinal_id(FACET,abs(f1)-1); 

	mov	esi, DWORD PTR _f1$90080[ebp]
	mov	eax, esi
	cdq
	xor	eax, edx
	sub	eax, edx
	dec	eax
	push	eax
	push	2
	call	_get_ordinal_id
	add	esp, 8
	mov	DWORD PTR _f_id1$90077[ebp], eax

; 407  :         if ( f1 < 0 ) invert(f_id1);

	test	esi, esi
	jns	SHORT $LN1585@other_stuf
	xor	DWORD PTR _f_id1$90077[ebp], 134217728	; 08000000H

; 408  :         if ( (f1==0) || !valid_id(f_id1) )

	test	esi, esi
$LN1585@other_stuf:
	je	SHORT $LN770@other_stuf
	test	DWORD PTR _f_id1$90077[ebp], 268435456	; 10000000H
	jne	SHORT $LN771@other_stuf
$LN770@other_stuf:

; 409  :         { sprintf(errmsg,"Invalid first facet %d in facet_merge.\n",f1);

	push	esi
	push	OFFSET ??_C@_0CI@KHCNGIHE@Invalid?5first?5facet?5?$CFd?5in?5facet_@
	push	OFFSET _errmsg
	call	_sprintf

; 410  :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 411  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL1104@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1104@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 412  :           kb_error(3880,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3880					; 00000f28H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN771@other_stuf:

; 413  :         }
; 414  :         if ( (f2==0) || !valid_id(f_id2) )

	test	ebx, ebx
	je	SHORT $LN768@other_stuf
	test	DWORD PTR _f_id2$90076[ebp], 268435456	; 10000000H
	jne	SHORT $LN1222@other_stuf
$LN768@other_stuf:

; 415  :         { sprintf(errmsg,"Invalid second facet %d in facet_merge.\n",f2);

	push	ebx
	push	OFFSET ??_C@_0CJ@HAIANMOD@Invalid?5second?5facet?5?$CFd?5in?5facet@
	push	OFFSET _errmsg
	call	_sprintf

; 416  :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 417  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1105@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1105@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 418  :           kb_error(3879,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3879					; 00000f27H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1222@other_stuf:

; 419  :         }
; 420  :         merge_facet(f_id1,f_id2);

	mov	ecx, DWORD PTR _f_id2$90076[ebp]
	mov	edx, DWORD PTR _f_id1$90077[ebp]
	push	ecx
	push	edx
	call	_merge_facet

; 421  :         *recalc_flag = 1;

	mov	eax, DWORD PTR _recalc_flag$GSCopy$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN767@other_stuf:

; 422  :       }
; 423  :       break;
; 424  : 
; 425  :     case GET_TORUS_PERIODS_NODE:
; 426  :          j = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 427  :          i = (int)(*stacktop--);

	fld	QWORD PTR [esi-8]
	mov	DWORD PTR _j$[ebp], eax
	call	__ftol2_sse
	add	esi, -16				; fffffff0H
	mov	DWORD PTR [ebx+48], esi

; 428  :          if ( (j<1) || (j > SDIM))

	mov	esi, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR _i$[ebp], eax
	cmp	esi, 1
	jl	SHORT $LN765@other_stuf
	cmp	esi, ecx
	jle	SHORT $LN766@other_stuf
$LN765@other_stuf:

; 429  :          { sprintf(errmsg,
; 430  :               "Torus_periods index %d; must be between 1 and %d.\n",j,SDIM);

	push	ecx
	push	esi
	push	OFFSET ??_C@_0DD@IFKBFEBP@Torus_periods?5index?5?$CFd?$DL?5must?5be?5@
	push	OFFSET _errmsg
	call	_sprintf

; 431  :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 432  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	4
$LL1106@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1106@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 433  :            kb_error(2015,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2015					; 000007dfH
	call	_kb_error
	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR _i$[ebp]
	add	esp, 28					; 0000001cH
$LN766@other_stuf:

; 434  :          }
; 435  :          if ((i<1) || (i>SDIM) )

	cmp	eax, 1
	jl	SHORT $LN763@other_stuf
	cmp	eax, ecx
	jle	SHORT $LN764@other_stuf
$LN763@other_stuf:

; 436  :          { sprintf(errmsg,
; 437  :               "Torus_periods index %d; must be between 1 and %d.\n",i,SDIM);

	push	ecx
	push	eax
	push	OFFSET ??_C@_0DD@IFKBFEBP@Torus_periods?5index?5?$CFd?$DL?5must?5be?5@
	push	OFFSET _errmsg
	call	_sprintf

; 438  :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 439  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL1107@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1107@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 440  :            kb_error(2016,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2016					; 000007e0H
	call	_kb_error
	mov	eax, DWORD PTR _i$[ebp]
	add	esp, 28					; 0000001cH
$LN764@other_stuf:

; 441  :          }
; 442  :          *++stacktop = web.torus_period[i-1][j-1]; /* 1-based indexing */

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR _web+1608
	mov	edx, DWORD PTR [ecx+eax*4-4]
	mov	ebx, DWORD PTR [ebx+48]
	fld	QWORD PTR [edx+esi*8-8]
	pop	edi
	fstp	QWORD PTR [ebx]
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN762@other_stuf:

; 443  :          break;
; 444  : 
; 445  :     case GET_INVERSE_PERIODS_NODE:
; 446  :          j = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 447  :          i = (int)(*stacktop--);

	fld	QWORD PTR [esi-8]
	mov	DWORD PTR _j$[ebp], eax
	call	__ftol2_sse
	add	esi, -16				; fffffff0H
	mov	DWORD PTR [ebx+48], esi

; 448  :          if ( (j<1) || (j > SDIM) )

	mov	esi, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR _i$[ebp], eax
	cmp	esi, 1
	jl	SHORT $LN760@other_stuf
	cmp	esi, ecx
	jle	SHORT $LN761@other_stuf
$LN760@other_stuf:

; 449  :          { sprintf(errmsg,
; 450  :               "Inverse_periods index %d; must be between 1 and %d.\n",j,SDIM);

	push	ecx
	push	esi
	push	OFFSET ??_C@_0DF@BLDOGNO@Inverse_periods?5index?5?$CFd?$DL?5must?5b@
	push	OFFSET _errmsg
	call	_sprintf

; 451  :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 452  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL1108@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1108@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 453  :            kb_error(2017,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2017					; 000007e1H
	call	_kb_error
	mov	ecx, DWORD PTR _web+616
	mov	eax, DWORD PTR _i$[ebp]
	add	esp, 28					; 0000001cH
$LN761@other_stuf:

; 454  :          }
; 455  :          if ( (i<1) || (i>SDIM) )

	cmp	eax, 1
	jl	SHORT $LN758@other_stuf
	cmp	eax, ecx
	jle	SHORT $LN759@other_stuf
$LN758@other_stuf:

; 456  :          { sprintf(errmsg,
; 457  :               "Inverse_periods index %d; must be between 1 and %d.\n",i,SDIM);

	push	ecx
	push	eax
	push	OFFSET ??_C@_0DF@BLDOGNO@Inverse_periods?5index?5?$CFd?$DL?5must?5b@
	push	OFFSET _errmsg
	call	_sprintf

; 458  :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 459  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL1109@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1109@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 460  :            kb_error(2018,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2018					; 000007e2H
	call	_kb_error
	mov	eax, DWORD PTR _i$[ebp]
	add	esp, 28					; 0000001cH
$LN759@other_stuf:

; 461  :          }
; 462  :          *++stacktop = web.inverse_periods[i-1][j-1]; /* 1-based indexing */

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR _web+1612
	mov	edx, DWORD PTR [ecx+eax*4-4]
	mov	ebx, DWORD PTR [ebx+48]
	fld	QWORD PTR [edx+esi*8-8]
	pop	edi
	fstp	QWORD PTR [ebx]
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN757@other_stuf:

; 463  :          break;
; 464  : 
; 465  :     case SET_GAP_CONSTANT_NODE:
; 466  :        web.spring_constant = *(stacktop--); 

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	fstp	QWORD PTR _web+1584
	add	DWORD PTR [ebx+48], -8			; fffffff8H

; 467  :        if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN756@other_stuf

; 468  :                GEN_QUANT(gap_quantity_num)->modulus = web.spring_constant;

	mov	ecx, DWORD PTR _gap_quantity_num
	fld	QWORD PTR _web+1584
	mov	edx, DWORD PTR _gen_quant_list
	imul	ecx, 368				; 00000170H
	fstp	QWORD PTR [ecx+edx+176]
$LN756@other_stuf:

; 469  :        if ( web.spring_constant == 0.0 ) web.convex_flag = 0;

	fld	QWORD PTR _web+1584
	mov	DWORD PTR _web+840, 0
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN754@other_stuf

; 470  :        else web.convex_flag = 1;

	mov	DWORD PTR _web+840, 1
$LN754@other_stuf:

; 471  :        *recalc_flag = 1;

	mov	eax, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN753@other_stuf:

; 472  :        break;
; 473  : 
; 474  :     case GET_INTERNAL_NODE:
; 475  :        *++stacktop = get_internal_variable(node->op1.name_id);

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR [edi+32]
	mov	ebx, DWORD PTR [ebx+48]
	push	ecx
	call	_get_internal_variable
	fstp	QWORD PTR [ebx]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN752@other_stuf:

; 476  :           break;
; 477  :   
; 478  :     case SET_INTERNAL_NODE:
; 479  :     { REAL oldvalue=0.0;
; 480  :       REAL val; 
; 481  :       /* get old value */
; 482  :       switch(node->op1.name_id)

	mov	ecx, DWORD PTR [edi+32]
	fldz
	mov	eax, ecx
	fst	QWORD PTR _oldvalue$90114[ebp]
	mov	esi, -8					; fffffff8H
	cmp	eax, 1877				; 00000755H
	jg	$LN895@other_stuf
	je	$LN711@other_stuf
	sub	eax, 1610				; 0000064aH
	cmp	eax, 251				; 000000fbH
	ja	$LN1448@other_stuf
	movzx	edx, BYTE PTR $LN1110@other_stuf[eax]
	jmp	DWORD PTR $LN1634@other_stuf[edx*4]
$LN740@other_stuf:

; 496  :         case V_TOLERANCE: oldvalue = web.tolerance; break;

	fld	QWORD PTR _web+752
	jmp	$LN750@other_stuf
$LN735@other_stuf:

; 502  :         case V_HESS_EPSILON: oldvalue = hessian_epsilon; break;

	fld	QWORD PTR _hessian_epsilon
	jmp	$LN750@other_stuf
$LN729@other_stuf:

; 509  :         case V_SCALE_SCALE: oldvalue = web.scale_scale; break;

	fld	QWORD PTR _web+1520
	jmp	$LN750@other_stuf
$LN728@other_stuf:

; 510  :         case V_SCALE: oldvalue = web.scale; break;

	fld	QWORD PTR _web+1512
	jmp	$LN750@other_stuf
$LN726@other_stuf:

; 512  :         case V_TIME: oldvalue = total_time; break;

	fld	QWORD PTR _total_time
	jmp	$LN750@other_stuf
$LN716@other_stuf:

; 523  :         case V_PICKVNUM: oldvalue = pickvnum; break;

	fild	DWORD PTR _pickvnum
	jmp	$LN750@other_stuf
$LN715@other_stuf:

; 524  :         case V_PICKENUM: oldvalue = pickenum; break;

	fild	DWORD PTR _pickenum
	jmp	$LN750@other_stuf
$LN714@other_stuf:

; 525  :         case V_PICKFNUM: oldvalue = pickfnum; break;

	fild	DWORD PTR _pickfnum
	jmp	$LN750@other_stuf
$LN713@other_stuf:

; 526  :         case V_JIG_TEMP: oldvalue = web.temperature; break;

	fld	QWORD PTR _web+1576
	jmp	$LN750@other_stuf
$LN712@other_stuf:

; 527  :         case V_LINEAR_METRIC_MIX: oldvalue = linear_metric_mix; break;

	fld	QWORD PTR _linear_metric_mix
	jmp	$LN750@other_stuf
$LN710@other_stuf:

; 529  :         case V_QUADRATIC_METRIC_MIX: 
; 530  :               oldvalue = quadratic_metric_mix; break;

	fld	QWORD PTR _quadratic_metric_mix
	jmp	$LN750@other_stuf
$LN709@other_stuf:

; 531  :         case V_RANDOM_SEED: oldvalue = random_seed;break;

	fild	DWORD PTR _random_seed
	jmp	$LN750@other_stuf
$LN707@other_stuf:

; 539  :         case V_INTEGRAL_ORDER: oldvalue = web.gauss2D_order; break;

	fild	DWORD PTR _web+1596
	jmp	$LN750@other_stuf
$LN706@other_stuf:

; 540  :         case V_INTEGRAL_ORDER_1D: oldvalue = web.gauss1D_order; break;

	fild	DWORD PTR _web+1592
	jmp	$LN750@other_stuf
$LN711@other_stuf:

; 528  :         case V_GAP_CONSTANT: oldvalue = web.spring_constant; break;

	fld	QWORD PTR _web+1584
	jmp	$LN750@other_stuf
$LN895@other_stuf:

; 476  :           break;
; 477  :   
; 478  :     case SET_INTERNAL_NODE:
; 479  :     { REAL oldvalue=0.0;
; 480  :       REAL val; 
; 481  :       /* get old value */
; 482  :       switch(node->op1.name_id)

	cmp	eax, 2268				; 000008dcH
	jg	$LN896@other_stuf
	je	$LN720@other_stuf
	sub	eax, 1878				; 00000756H
	cmp	eax, 238				; 000000eeH
	ja	$LN1448@other_stuf
	movzx	eax, BYTE PTR $LN1111@other_stuf[eax]
	jmp	DWORD PTR $LN1635@other_stuf[eax*4]
$LN747@other_stuf:

; 489  :         case V_PS_LABELSIZE:  oldvalue = ps_labelsize; break;

	fld	QWORD PTR _ps_labelsize
	jmp	$LN750@other_stuf
$LN746@other_stuf:

; 490  :         case V_PS_STRINGWIDTH: oldvalue = ps_stringwidth; break;

	fld	QWORD PTR _ps_stringwidth
	jmp	$LN750@other_stuf
$LN745@other_stuf:

; 491  :         case V_PS_FIXEDEDGEWIDTH: oldvalue = ps_fixededgewidth; break;

	fld	QWORD PTR _ps_fixededgewidth
	jmp	$LN750@other_stuf
$LN744@other_stuf:

; 492  :         case V_PS_TRIPLEEDGEWIDTH: oldvalue = ps_tripleedgewidth; break;

	fld	QWORD PTR _ps_tripleedgewidth
	jmp	$LN750@other_stuf
$LN743@other_stuf:

; 493  :         case V_PS_CONEDGEWIDTH: oldvalue = ps_conedgewidth; break;

	fld	QWORD PTR _ps_conedgewidth
	jmp	$LN750@other_stuf
$LN742@other_stuf:

; 494  :         case V_PS_BAREEDGEWIDTH: oldvalue = ps_bareedgewidth; break;

	fld	QWORD PTR _ps_bareedgewidth
	jmp	$LN750@other_stuf
$LN741@other_stuf:

; 495  :         case V_PS_GRIDEDGEWIDTH: oldvalue = ps_gridedgewidth; break;

	fld	QWORD PTR _ps_gridedgewidth
	jmp	$LN750@other_stuf
$LN739@other_stuf:

; 497  :         case V_LAST_ERROR: oldvalue = last_error; break;

	fild	DWORD PTR _last_error
	jmp	$LN750@other_stuf
$LN738@other_stuf:

; 498  :         case V_BRIGHTNESS: oldvalue = brightness; break;

	fld	QWORD PTR _brightness
	jmp	$LN750@other_stuf
$LN737@other_stuf:

; 499  :         case V_BACKGROUND: oldvalue = background_color; break;

	fild	DWORD PTR _background_color
	jmp	$LN750@other_stuf
$LN736@other_stuf:

; 500  :         case V_TARGET_TOLERANCE: oldvalue = web.target_tolerance;

	fld	QWORD PTR _web+760

; 501  :               break;

	jmp	$LN750@other_stuf
$LN733@other_stuf:

; 504  :         case V_THICKNESS: oldvalue = thickness; break;

	fld	QWORD PTR _thickness
	jmp	$LN750@other_stuf
$LN732@other_stuf:

; 505  :         case V_HESSIAN_SLANT_CUTOFF: oldvalue = hessian_slant_cutoff; break;

	fld	QWORD PTR _hessian_slant_cutoff
	jmp	$LN750@other_stuf
$LN731@other_stuf:

; 506  :         case V_AMBIENT_PRESSURE: oldvalue = web.pressure; break;

	fld	QWORD PTR _web+1536
	jmp	$LN750@other_stuf
$LN730@other_stuf:

; 507  :         case V_DIFFUSION: oldvalue = web.diffusion_const;

	fld	QWORD PTR _web+784

; 508  :             web.diffusion_flag = 1; break;

	mov	DWORD PTR _web+780, 1
	jmp	$LN750@other_stuf
$LN727@other_stuf:

; 511  :         case V_SCALE_LIMIT: oldvalue = web.maxscale; break;

	fld	QWORD PTR _web+1528
	jmp	$LN750@other_stuf
$LN1398@other_stuf:

; 532  :         case V_RANDOM: 
; 533  :              sprintf(errmsg,"Cannot set random. Set random_seed instead.\n");

	push	OFFSET ??_C@_0CN@FGOHOBPD@Cannot?5set?5random?4?5Set?5random_se@
	fstp	ST(0)
	push	OFFSET _errmsg
	call	_sprintf

; 534  :              stacktop--;
; 535  :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 536  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	add	DWORD PTR [ebx+48], esi
	lea	edx, DWORD PTR [eax+1]
$LL1112@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1112@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 537  :              kb_error(2019,errmsg, WARNING);

	push	2
	push	OFFSET _errmsg
	push	2019					; 000007e3H

; 538  :              break;

	jmp	$LN1586@other_stuf
$LN720@other_stuf:

; 519  :         case V_MINDEG_DEBUG_LEVEL: oldvalue = mindeg_debug_level; break;

	fild	DWORD PTR _mindeg_debug_level
	jmp	$LN750@other_stuf
$LN896@other_stuf:

; 476  :           break;
; 477  :   
; 478  :     case SET_INTERNAL_NODE:
; 479  :     { REAL oldvalue=0.0;
; 480  :       REAL val; 
; 481  :       /* get old value */
; 482  :       switch(node->op1.name_id)

	cmp	eax, 2308				; 00000904H
	jg	SHORT $LN897@other_stuf
	je	SHORT $LN748@other_stuf
	sub	eax, 2269				; 000008ddH
	cmp	eax, 34					; 00000022H
	ja	$LN1448@other_stuf
	movzx	edx, BYTE PTR $LN1113@other_stuf[eax]
	jmp	DWORD PTR $LN1636@other_stuf[edx*4]
$LN721@other_stuf:

; 517  :         case V_STRING_CURVE_TOLERANCE: oldvalue = string_curve_tolerance;

	fld	QWORD PTR _string_curve_tolerance

; 518  :              break;

	jmp	$LN750@other_stuf
$LN719@other_stuf:

; 520  :         case V_MINDEG_MARGIN: oldvalue = mindeg_margin; break;

	fild	DWORD PTR _mindeg_margin
	jmp	$LN750@other_stuf
$LN718@other_stuf:

; 521  :         case V_MINDEG_MIN_REGION_SIZE: oldvalue = mindeg_min_region_size; break;

	fild	DWORD PTR _mindeg_min_region_size
	jmp	$LN750@other_stuf
$LN717@other_stuf:

; 522  :         case V_WINDOW_ASPECT_RATIO: oldvalue = window_aspect_ratio; break;

	fld	QWORD PTR _window_aspect_ratio
	jmp	$LN750@other_stuf
$LN704@other_stuf:

; 541  :         case V_INTEGRAL_ORDER_2D: oldvalue = web.gauss2D_order; break;
; 542  :         case V_AUTOCHOP_LENGTH: oldvalue = autochop_length; break;

	fld	QWORD PTR _autochop_length
	jmp	$LN750@other_stuf
$LN748@other_stuf:

; 488  :         case V_DETORUS_EPSILON: oldvalue = dt_eps; break;

	fld	QWORD PTR _dt_eps
	jmp	$LN750@other_stuf
$LN897@other_stuf:

; 476  :           break;
; 477  :   
; 478  :     case SET_INTERNAL_NODE:
; 479  :     { REAL oldvalue=0.0;
; 480  :       REAL val; 
; 481  :       /* get old value */
; 482  :       switch(node->op1.name_id)

	cmp	eax, 10415				; 000028afH
	jg	SHORT $LN898@other_stuf
	je	SHORT $LN734@other_stuf
	cmp	eax, 2309				; 00000905H
	jne	SHORT $LN1448@other_stuf

; 483  :       {
; 484  : #ifdef MPI_EVOLVER
; 485  :         case V_CORONA_STATE : oldvalue = mpi_corona_state; break;
; 486  : #endif
; 487  :         case V_BOUNDING_BOX_COLOR: oldvalue = bounding_box_color; break;

	fild	DWORD PTR _bounding_box_color
	jmp	$LN750@other_stuf
$LN734@other_stuf:

; 503  :         case GRAV_CONST_NODE: oldvalue = web.grav_const; break;

	fld	QWORD PTR _web+832
	jmp	$LN750@other_stuf
$LN898@other_stuf:

; 476  :           break;
; 477  :   
; 478  :     case SET_INTERNAL_NODE:
; 479  :     { REAL oldvalue=0.0;
; 480  :       REAL val; 
; 481  :       /* get old value */
; 482  :       switch(node->op1.name_id)

	cmp	eax, 35080				; 00008908H
	jg	SHORT $LN1448@other_stuf
	je	SHORT $LN734@other_stuf
	sub	eax, 10416				; 000028b0H
	cmp	eax, 3
	ja	SHORT $LN1448@other_stuf
	jmp	DWORD PTR $LN1637@other_stuf[eax*4]
$LN725@other_stuf:

; 513  :         case V_CHECK_COUNT_NODE: oldvalue = check_count; break;

	fild	DWORD PTR _check_count
	jmp	SHORT $LN750@other_stuf
$LN724@other_stuf:

; 514  :         case V_VISIBILITY_DEBUG_NODE: oldvalue = visdebuglevel; break;

	fild	DWORD PTR _visdebuglevel
	jmp	SHORT $LN750@other_stuf
$LN723@other_stuf:

; 515  :         case V_SCROLLBUFFERSIZE_NODE: oldvalue = scrollbuffersize; break;

	fild	DWORD PTR _scrollbuffersize
	jmp	SHORT $LN750@other_stuf
$LN722@other_stuf:

; 516  :         case V_BREAKFLAG_NODE: oldvalue = breakflag; break;

	fild	DWORD PTR _breakflag
	jmp	SHORT $LN750@other_stuf
$LN1448@other_stuf:

; 543  :         case GRAV_CONST_TOK: oldvalue = web.grav_const; break;
; 544  :         default: 
; 545  :              sprintf(errmsg,"Internal: illegal variable number %d.\n",
; 546  :                  node->op1.name_id);

	push	ecx
	fstp	ST(0)
	push	OFFSET ??_C@_0CH@IJFNOCFF@Internal?3?5illegal?5variable?5numbe@
	push	OFFSET _errmsg
	call	_sprintf

; 547  :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 548  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL1114@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1114@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 549  :              kb_error(1209,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1209					; 000004b9H
$LN1586@other_stuf:
	call	_kb_error
	fldz
	fld	QWORD PTR _oldvalue$90114[ebp]
	add	esp, 28					; 0000001cH
$LN750@other_stuf:

; 550  :       }
; 551  :       val = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax

; 552  :       switch ( node->op2.assigntype )

	mov	eax, DWORD PTR [edi+136]
	add	eax, -30002				; ffff8aceH
	cmp	eax, 3
	ja	SHORT $LN1262@other_stuf
	jmp	DWORD PTR $LN1638@other_stuf[eax*4]
$LN698@other_stuf:

; 553  :       {    case ASSIGN_OP:    break;
; 554  :            case PLUSASSIGN_OP: val +=  oldvalue; break;

	faddp	ST(1), ST(0)
	jmp	SHORT $LN700@other_stuf
$LN697@other_stuf:

; 555  :            case SUBASSIGN_OP: val = oldvalue - val; break;

	fsubp	ST(1), ST(0)
	jmp	SHORT $LN700@other_stuf
$LN696@other_stuf:

; 556  :            case MULTASSIGN_OP: val = oldvalue * val; break;

	fmulp	ST(1), ST(0)
	jmp	SHORT $LN700@other_stuf
$LN695@other_stuf:

; 557  :            case DIVASSIGN_OP: val = oldvalue / val; break;

	fdivp	ST(1), ST(0)
	jmp	SHORT $LN700@other_stuf
$LN1262@other_stuf:
	fstp	ST(1)
$LN700@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	mov	ecx, DWORD PTR [edi+32]
	mov	eax, ecx
	cmp	eax, 1877				; 00000755H
	jg	$LN908@other_stuf
	je	$LN1271@other_stuf
	sub	eax, 1610				; 0000064aH
	cmp	eax, 251				; 000000fbH
	ja	$LN1364@other_stuf
	movzx	edx, BYTE PTR $LN1115@other_stuf[eax]
	jmp	DWORD PTR $LN1639@other_stuf[edx*4]
$LN1291@other_stuf:
	pop	edi
	fstp	ST(1)
	pop	esi

; 569  :                  break;
; 570  :            case V_TOLERANCE: web.tolerance = val; break;

	fstp	QWORD PTR _web+752
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN673@other_stuf:

; 600  :               break;
; 601  :            case V_HESS_EPSILON: hessian_epsilon = val;

	fst	QWORD PTR _hessian_epsilon

; 602  :              if ( hessian_epsilon < 0.0 )

	fcompp
	fnstsw	ax
	test	ah, 5
	jp	$LN855@other_stuf

; 603  :              { sprintf(errmsg,"hessian_epsilon is negative!\n");

	push	OFFSET ??_C@_0BO@NGJPCAH@hessian_epsilon?5is?5negative?$CB?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 604  :                sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 605  :                    file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1116@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1116@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 606  :                kb_error(2558,errmsg, WARNING);

	push	2
	push	OFFSET _errmsg
	push	2558					; 000009feH
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1289@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 625  :            case V_SCALE_SCALE: web.scale_scale = val; break;           

	fstp	QWORD PTR _web+1520
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1288@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 626  :            case V_SCALE: web.scale = val; break;

	fstp	QWORD PTR _web+1512
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1287@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 629  :            case V_TIME: total_time = val; break;

	fstp	QWORD PTR _total_time
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1286@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)

; 655  :            case V_PICKVNUM: pickvnum = (int)val; break;

	call	__ftol2_sse
	pop	edi
	pop	esi
	mov	DWORD PTR _pickvnum, eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1285@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)

; 656  :            case V_PICKENUM: pickenum = (int)val; break;

	call	__ftol2_sse
	pop	edi
	pop	esi
	mov	DWORD PTR _pickenum, eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1284@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)

; 657  :            case V_PICKFNUM: pickfnum = (int)val; break;

	call	__ftol2_sse
	pop	edi
	pop	esi
	mov	DWORD PTR _pickfnum, eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1283@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 658  :            case V_JIG_TEMP: web.temperature = val; break;

	fstp	QWORD PTR _web+1576
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1282@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 667  :                  break;
; 668  :            case V_LINEAR_METRIC_MIX: linear_metric_mix=val; break;

	fstp	QWORD PTR _linear_metric_mix
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1281@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 671  :            case V_QUADRATIC_METRIC_MIX: 
; 672  :                  quadratic_metric_mix=val; break;

	fstp	QWORD PTR _quadratic_metric_mix
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1280@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)

; 673  :            case V_RANDOM_SEED: random_seed = (int)val;

	call	__ftol2_sse

; 674  :                  srand(random_seed); srand48(random_seed); 

	push	eax
	mov	DWORD PTR _random_seed, eax
	call	_srand
	mov	ecx, DWORD PTR _random_seed
	push	ecx
	call	_srand48

; 675  :                  kb_initr(random_seed); break;

	mov	edx, DWORD PTR _random_seed
	push	edx
	call	_kb_initr

; 829  :           unset_attr(q->b_id,FIXEDVOL);

	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1279@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)

; 682  :            case V_INTEGRAL_ORDER: 
; 683  :                  web.gauss1D_order = (int)val;

	call	__ftol2_sse
	mov	DWORD PTR _web+1592, eax

; 684  :                  set_by_user_gauss_1D = web.gauss1D_order;

	mov	DWORD PTR _set_by_user_gauss_1D, eax

; 685  :                  web.gauss2D_order = (int)val;

	mov	DWORD PTR _web+1596, eax

; 686  :                  set_by_user_gauss_2D = web.gauss2D_order;

	mov	DWORD PTR _set_by_user_gauss_2D, eax

; 687  :                  gauss_setup();

	call	_gauss_setup

; 688  :                  if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	jne	SHORT $LN1228@other_stuf

; 689  :                  { gauss_lagrange_setup(
; 690  :                       (web.dimension==1)?1:web.dimension-1,
; 691  :                           web.lagrange_order,web.gauss1D_order);

	mov	eax, DWORD PTR _web+620
	cmp	eax, 1
	jne	SHORT $LN904@other_stuf
	jmp	SHORT $LN905@other_stuf
$LN904@other_stuf:
	dec	eax
$LN905@other_stuf:
	mov	ecx, DWORD PTR _web+1592
	mov	edx, DWORD PTR _web+632
	push	ecx
	push	edx
	push	eax
	call	_gauss_lagrange_setup

; 692  :                    gauss_lagrange_setup(web.dimension,
; 693  :                       web.lagrange_order,web.gauss2D_order);

	mov	eax, DWORD PTR _web+1596
	mov	ecx, DWORD PTR _web+632
	mov	edx, DWORD PTR _web+620
	push	eax
	push	ecx
	push	edx
	call	_gauss_lagrange_setup
	add	esp, 24					; 00000018H
$LN1228@other_stuf:

; 694  :                  }
; 695  :                  *recalc_flag = 1;

	mov	eax, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1278@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)

; 696  :                  break;
; 697  :            case V_INTEGRAL_ORDER_1D: 
; 698  :                  web.gauss1D_order = (int)val;

	call	__ftol2_sse

; 699  :                  set_by_user_gauss_1D = web.gauss1D_order;
; 700  :                  if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	mov	DWORD PTR _web+1592, eax
	mov	DWORD PTR _set_by_user_gauss_1D, eax
	jne	SHORT $LN1229@other_stuf

; 701  :                      gauss_lagrange_setup(
; 702  :                       (web.dimension==1)?1:web.dimension-1,
; 703  :                           web.lagrange_order,web.gauss1D_order);

	mov	ecx, DWORD PTR _web+620
	cmp	ecx, 1
	jne	SHORT $LN906@other_stuf
	jmp	SHORT $LN907@other_stuf
$LN906@other_stuf:
	dec	ecx
$LN907@other_stuf:
	mov	edx, DWORD PTR _web+632
	push	eax
	push	edx
	push	ecx
	call	_gauss_lagrange_setup
	add	esp, 12					; 0000000cH
$LN1229@other_stuf:

; 704  :                  gauss_setup();

	call	_gauss_setup

; 705  :                  *recalc_flag = 1;

	mov	eax, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1277@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)

; 706  :                  break;
; 707  :            case V_INTEGRAL_ORDER_2D: 
; 708  :                  web.gauss2D_order = (int)val;

	call	__ftol2_sse
	mov	DWORD PTR _web+1596, eax

; 709  :                  set_by_user_gauss_2D = web.gauss2D_order;

	mov	DWORD PTR _set_by_user_gauss_2D, eax

; 710  :                  gauss_setup();

	call	_gauss_setup

; 711  :                  if ( web.modeltype == LAGRANGE )

	cmp	DWORD PTR _web+628, 3
	jne	SHORT $LN628@other_stuf

; 712  :                    gauss_lagrange_setup(web.dimension,
; 713  :                       web.lagrange_order,web.gauss2D_order);

	mov	ecx, DWORD PTR _web+1596
	mov	edx, DWORD PTR _web+632
	mov	eax, DWORD PTR _web+620
	push	ecx
	push	edx
	push	eax
	call	_gauss_lagrange_setup
	add	esp, 12					; 0000000cH
$LN628@other_stuf:

; 714  :                  *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1271@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 669  :            case V_GAP_CONSTANT: web.spring_constant = val; break;

	fstp	QWORD PTR _web+1584
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN908@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	cmp	eax, 2268				; 000008dcH
	jg	$LN909@other_stuf
	je	$LN1296@other_stuf
	sub	eax, 1878				; 00000756H
	cmp	eax, 238				; 000000eeH
	ja	$LN1364@other_stuf
	movzx	edx, BYTE PTR $LN1117@other_stuf[eax]
	jmp	DWORD PTR $LN1640@other_stuf[edx*4]
$LN1318@other_stuf:
	pop	edi
	fstp	ST(1)
	pop	esi

; 571  :            case V_PS_LABELSIZE: ps_labelsize = val; break;

	fstp	QWORD PTR _ps_labelsize
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1317@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 572  :            case V_PS_STRINGWIDTH: ps_stringwidth = val; break;

	fstp	QWORD PTR _ps_stringwidth
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1316@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 573  :            case V_PS_FIXEDEDGEWIDTH: ps_fixededgewidth = val; break;

	fstp	QWORD PTR _ps_fixededgewidth
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1315@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 574  :            case V_PS_TRIPLEEDGEWIDTH: ps_tripleedgewidth = val; break;

	fstp	QWORD PTR _ps_tripleedgewidth
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1314@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 575  :            case V_PS_CONEDGEWIDTH: ps_conedgewidth = val; break;

	fstp	QWORD PTR _ps_conedgewidth
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1313@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 576  :            case V_PS_BAREEDGEWIDTH: ps_bareedgewidth = val; break;

	fstp	QWORD PTR _ps_bareedgewidth
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1312@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 577  :            case V_PS_GRIDEDGEWIDTH: ps_gridedgewidth = val; break;

	fstp	QWORD PTR _ps_gridedgewidth
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN679@other_stuf:

; 578  : #ifdef MPI_EVOLVER
; 579  :            case V_CORONA_STATE: mpi_set_corona((int)val); break;
; 580  : #else
; 581  :            case V_CORONA_STATE: ; break;
; 582  :          
; 583  : #endif
; 584  :            case V_BRIGHTNESS: 
; 585  :              if ( (val < 0.0) || (val > 1.0) )

	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jnp	SHORT $LN677@other_stuf
	fld1
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN677@other_stuf

; 591  :              }
; 592  :              else { brightness = val; update_display(); }

	fstp	QWORD PTR _brightness
	call	_update_display
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN677@other_stuf:

; 586  :              { sprintf(errmsg,"Brightness is %f; must be between 0 and 1.\n",
; 587  :                     (DOUBLE)val);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_0CM@LNECKOD@Brightness?5is?5?$CFf?$DL?5must?5be?5betwee@
	push	OFFSET _errmsg
	call	_sprintf

; 588  :                sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 589  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL1118@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1118@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 590  :                kb_error(2020,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2020					; 000007e4H
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1310@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)

; 593  :                  break;
; 594  :            case V_BACKGROUND:
; 595  :              background_color = (int)val; 

	call	__ftol2_sse
	mov	DWORD PTR _background_color, eax

; 596  :              update_display();

	call	_update_display
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1309@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 597  :              break;
; 598  : 
; 599  :            case V_TARGET_TOLERANCE: web.target_tolerance = val;

	fstp	QWORD PTR _web+760
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1308@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 618  :              break;
; 619  : 
; 620  :            case V_DIFFUSION: web.diffusion_const = val; break;

	fstp	QWORD PTR _web+784
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1307@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 621  :            case V_AMBIENT_PRESSURE: web.pressure = val; break;

	fstp	QWORD PTR _web+1536
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1306@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 622  :            case V_HESSIAN_SLANT_CUTOFF: hessian_slant_cutoff = val; break;

	fstp	QWORD PTR _hessian_slant_cutoff
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1305@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)

; 623  :            case V_THICKNESS: thickness = val; user_thickness_flag = 1;

	mov	DWORD PTR _user_thickness_flag, 1
	fstp	QWORD PTR _thickness

; 624  :                   update_display();break;

	call	_update_display
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1304@other_stuf:
	pop	edi

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)
	pop	esi

; 627  :            case V_SCALE_LIMIT: web.maxscale = val; break;

	fstp	QWORD PTR _web+1528
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1303@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)

; 628  :            case V_LAST_ERROR: last_error = (int)val; break;

	call	__ftol2_sse
	pop	edi
	pop	esi
	mov	DWORD PTR _last_error, eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1302@other_stuf:

; 676  :            case V_RANDOM: sprintf(errmsg,
; 677  :                     "Cannot set random. Set random_seed instead.\n"); 

	push	OFFSET ??_C@_0CN@FGOHOBPD@Cannot?5set?5random?4?5Set?5random_se@
	fstp	ST(0)
	push	OFFSET _errmsg
	fstp	ST(0)
	call	_sprintf

; 678  :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 679  :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1119@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1119@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 680  :                  kb_error(2021,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2021					; 000007e5H
	call	_kb_error
	add	esp, 28					; 0000001cH

; 681  :                 stacktop--; break;

	add	DWORD PTR [ebx+48], esi
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1296@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(1)

; 637  :            case V_MINDEG_DEBUG_LEVEL: mindeg_debug_level = (int)val; break;

	call	__ftol2_sse
	pop	edi
	pop	esi
	mov	DWORD PTR _mindeg_debug_level, eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN909@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	cmp	eax, 2308				; 00000904H
	jg	$LN910@other_stuf
	fstp	ST(1)
	je	$LN643@other_stuf
	sub	eax, 2269				; 000008ddH
	cmp	eax, 34					; 00000022H
	ja	$LN1372@other_stuf
	movzx	edx, BYTE PTR $LN1120@other_stuf[eax]
	jmp	DWORD PTR $LN1641@other_stuf[edx*4]
$LN654@other_stuf:

; 635  :            case V_STRING_CURVE_TOLERANCE: string_curve_tolerance = val; 

	fstp	QWORD PTR _string_curve_tolerance

; 636  :                 update_display();break;

	call	_update_display
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN652@other_stuf:

; 638  :            case V_MINDEG_MARGIN: mindeg_margin = (int)val; break;

	call	__ftol2_sse
	pop	edi
	pop	esi
	mov	DWORD PTR _mindeg_margin, eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN651@other_stuf:

; 639  :            case V_MINDEG_MIN_REGION_SIZE: mindeg_min_region_size = (int)val; break;

	call	__ftol2_sse
	pop	edi
	pop	esi
	mov	DWORD PTR _mindeg_min_region_size, eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN650@other_stuf:

; 640  :            case V_WINDOW_ASPECT_RATIO: 
; 641  :              window_aspect_ratio = (REAL)val;

	fst	QWORD PTR _window_aspect_ratio

; 642  :              if ( window_aspect_ratio <= 1.0 ) 

	fld1
	fcomp	ST(1)
	fnstsw	ax

; 643  :              { minclipx = -1.5/window_aspect_ratio; 

	fld	QWORD PTR __real@bff8000000000000
	test	ah, 1
	jne	SHORT $LN649@other_stuf
	fld	ST(0)
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR _minclipx

; 644  :                maxclipx = 1.5/window_aspect_ratio;

	fld	QWORD PTR __real@3ff8000000000000
	fld	ST(0)
	fdivrp	ST(3), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR _maxclipx

; 645  :                minclipy = -1.5; 

	fstp	QWORD PTR _minclipy

; 652  :                maxclipy = 1.5*window_aspect_ratio;

	fstp	QWORD PTR _maxclipy

; 653  :              }
; 654  :              update_display(); break;

	call	_update_display
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN649@other_stuf:

; 646  :                maxclipy = 1.5;
; 647  :              }
; 648  :              else
; 649  :              { minclipx = -1.5; 

	fst	QWORD PTR _minclipx

; 650  :                maxclipx = 1.5;

	fld	QWORD PTR __real@3ff8000000000000
	fst	QWORD PTR _maxclipx

; 651  :                minclipy = -1.5*window_aspect_ratio; 

	fld	ST(2)
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _minclipy

; 652  :                maxclipy = 1.5*window_aspect_ratio;

	fmulp	ST(1), ST(0)
	fstp	QWORD PTR _maxclipy

; 653  :              }
; 654  :              update_display(); break;

	call	_update_display
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN637@other_stuf:
	pop	edi

; 670  :            case V_AUTOCHOP_LENGTH: autochop_length = val; break;

	fstp	QWORD PTR _autochop_length
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN643@other_stuf:
	pop	edi

; 659  :            case V_DETORUS_EPSILON: dt_eps = val; break;

	fstp	QWORD PTR _dt_eps
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN910@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	cmp	eax, 10415				; 000028afH
	jg	$LN911@other_stuf
	je	SHORT $LN671@other_stuf
	fstp	ST(1)
	cmp	eax, 2309				; 00000905H
	jne	$LN1372@other_stuf

; 660  :            case V_BOUNDING_BOX_COLOR: 
; 661  :                  if ( ((int)val < BLACK) || ((int)val > WHITE) )

	call	__ftol2_sse
	mov	edi, eax
	test	edi, edi
	js	SHORT $LN640@other_stuf
	cmp	edi, 15					; 0000000fH
	jle	SHORT $LN641@other_stuf
$LN640@other_stuf:

; 662  :                  { sprintf(errmsg, "Illegal value %d for bounding_box_color.\n",(int)val);

	push	edi
	push	OFFSET ??_C@_0CK@JFPJNFDP@Illegal?5value?5?$CFd?5for?5bounding_bo@
	push	OFFSET _errmsg
	call	_sprintf

; 663  :                    kb_error(3037,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3037					; 00000bddH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN641@other_stuf:

; 664  :                  }
; 665  :                  bounding_box_color = (int)val;

	mov	DWORD PTR _bounding_box_color, edi

; 666  :                  update_display(); 

	call	_update_display
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN671@other_stuf:

; 607  :              }
; 608  :              break;
; 609  : 
; 610  :            case GRAV_CONST_NODE: web.grav_const = val; 

	fst	QWORD PTR _web+832

; 611  :              if ( web.grav_const != 0.0 )

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN670@other_stuf

; 612  :                web.gravflag = 1;

	mov	eax, 1

; 613  :              else

	jmp	SHORT $LN1588@other_stuf
$LN670@other_stuf:

; 614  :                web.gravflag = 0;

	xor	eax, eax
$LN1588@other_stuf:

; 615  :              if (gravity_quantity_num >= 0 )

	mov	ecx, DWORD PTR _gravity_quantity_num
	mov	DWORD PTR _web+824, eax
	test	ecx, ecx
	js	$LN1357@other_stuf

; 616  :                GEN_QUANT(gravity_quantity_num)->modulus =
; 617  :                               web.gravflag ? web.grav_const : 0.0;

	test	eax, eax
	je	SHORT $LN1360@other_stuf
	fstp	ST(1)
	jmp	SHORT $LN903@other_stuf
$LN1360@other_stuf:
	fstp	ST(0)
$LN903@other_stuf:
	mov	eax, DWORD PTR _gen_quant_list
	imul	ecx, 368				; 00000170H
	pop	edi
	pop	esi
	fstp	QWORD PTR [ecx+eax+176]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN911@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	cmp	eax, 35080				; 00008908H
	jg	$LN1364@other_stuf
	je	$LN692@other_stuf
	sub	eax, 10416				; 000028b0H
	fstp	ST(1)
	cmp	eax, 3
	ja	$LN1372@other_stuf
	jmp	DWORD PTR $LN1642@other_stuf[eax*4]
$LN658@other_stuf:

; 630  :            case V_CHECK_COUNT_NODE: check_count = (int)val; break;

	call	__ftol2_sse
	pop	edi
	pop	esi
	mov	DWORD PTR _check_count, eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN657@other_stuf:

; 631  :            case V_VISIBILITY_DEBUG_NODE: visdebuglevel = (int)val; break;

	call	__ftol2_sse
	pop	edi
	pop	esi
	mov	DWORD PTR _visdebuglevel, eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN656@other_stuf:

; 632  :            case V_SCROLLBUFFERSIZE_NODE: scrollbuffersize = (int)val;

	call	__ftol2_sse

; 633  :                 set_scroll_size(scrollbuffersize); break;

	push	eax
	mov	DWORD PTR _scrollbuffersize, eax
	call	_set_scroll_size
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN655@other_stuf:

; 634  :            case V_BREAKFLAG_NODE: breakflag = (int)val; break;

	call	__ftol2_sse
	pop	edi
	pop	esi
	mov	DWORD PTR _breakflag, eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN692@other_stuf:

; 560  :       {    case GRAV_CONST_TOK: web.grav_const = val;

	fst	QWORD PTR _web+832

; 561  :                 if ( web.grav_const != 0.0 )

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN691@other_stuf

; 562  :                   web.gravflag = 1;

	mov	eax, 1

; 563  :                 else

	jmp	SHORT $LN1589@other_stuf
$LN691@other_stuf:

; 564  :                   web.gravflag = 0;

	xor	eax, eax
$LN1589@other_stuf:

; 565  :                 if (gravity_quantity_num >= 0 )

	mov	ecx, DWORD PTR _gravity_quantity_num
	mov	DWORD PTR _web+824, eax
	test	ecx, ecx
	js	SHORT $LN1382@other_stuf

; 566  :                    GEN_QUANT(gravity_quantity_num)->modulus =
; 567  :                               web.gravflag ? web.grav_const : 0.0;

	test	eax, eax
	je	SHORT $LN1385@other_stuf
	fstp	ST(1)
	jmp	SHORT $LN901@other_stuf
$LN1385@other_stuf:
	fstp	ST(0)
$LN901@other_stuf:
	mov	edx, DWORD PTR _gen_quant_list
	imul	ecx, 368				; 00000170H

; 568  :                 *recalc_flag = 1;

	mov	eax, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	fstp	QWORD PTR [ecx+edx+176]
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1382@other_stuf:

; 568  :                 *recalc_flag = 1;

	mov	eax, DWORD PTR _recalc_flag$GSCopy$[ebp]
	fstp	ST(0)
	pop	edi
	fstp	ST(0)
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1364@other_stuf:

; 558  :       }
; 559  :       switch(node->op1.name_id)

	fstp	ST(0)
$LN1372@other_stuf:

; 715  :                  break;
; 716  :            default: 
; 717  :                sprintf(errmsg,"Internal: illegal internal variable number %d.\n",
; 718  :                   node->op1.name_id);

	push	ecx
	fstp	ST(0)
	push	OFFSET ??_C@_0DA@HKAAECNL@Internal?3?5illegal?5internal?5varia@
	push	OFFSET _errmsg
	call	_sprintf

; 719  :                sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 720  :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1121@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1121@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 721  :                kb_error(1114,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1114					; 0000045aH
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN626@other_stuf:

; 722  :    
; 723  :       }
; 724  :       break;
; 725  :     } /* end SET_INTERNAL_ */
; 726  : 
; 727  :     case SIZEOF_ATTR_NODE:
; 728  :       *++stacktop = (REAL)EXTRAS(node->op2.eltype)[node->op1.extranum].array_spec.datacount;

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR [edi+136]
	mov	edx, DWORD PTR [edi+32]
	imul	ecx, 112				; 00000070H
	mov	eax, DWORD PTR _web[ecx+104]
	imul	edx, 240				; 000000f0H
	mov	ecx, DWORD PTR _dymem
	mov	ebx, DWORD PTR [ebx+48]
	add	eax, edx
	pop	edi
	pop	esi
	fild	DWORD PTR [eax+ecx+88]
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN625@other_stuf:

; 729  :        break;
; 730  : 
; 731  :     case SIZEOF_ARRAY_NODE:
; 732  :       *++stacktop = (REAL)get_name_arrayptr(node->op1.name_id,localstack,localbase)->datacount;

	mov	edx, DWORD PTR _localbase$GSCopy$[ebp]
	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR _localstack$GSCopy$[ebp]
	mov	ecx, DWORD PTR [edi+32]
	mov	ebx, DWORD PTR [ebx+48]
	push	edx
	push	eax
	push	ecx
	call	_get_name_arrayptr
	fild	DWORD PTR [eax+16]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN624@other_stuf:

; 733  :        break;
; 734  : 
; 735  :     case SIZEOF_STRING_NODE:
; 736  :      { char *s = *(char**)stacktop;

	mov	ebx, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [ebx]

; 737  :        *stacktop = s ? (REAL)strlen(s) : 0;

	test	edx, edx
	je	SHORT $LN913@other_stuf
	mov	eax, edx
	lea	esi, DWORD PTR [eax+1]
$LL1122@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1122@other_stuf
	sub	eax, esi
	mov	DWORD PTR tv12498[ebp], eax
	fild	DWORD PTR tv12498[ebp]
	jns	SHORT $LN914@other_stuf
	fadd	QWORD PTR __real@41f0000000000000
	jmp	SHORT $LN914@other_stuf
$LN913@other_stuf:
	fldz
$LN914@other_stuf:
	fstp	QWORD PTR [ebx]

; 738  :        if ( node->left && (node[node->left].flags & DEALLOCATE_POINTER) )

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	$LN855@other_stuf
	imul	eax, 168				; 000000a8H
	test	DWORD PTR [eax+edi+24], 1024		; 00000400H
	je	$LN855@other_stuf

; 739  :          myfree(s);

	push	edx
	call	_myfree
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN622@other_stuf:

; 740  :        break;
; 741  :      }
; 742  : 
; 743  :     case TORDUP_NODE:
; 744  :        i = (int)*(stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], esi

; 745  :        if ( ! web.torus_flag )

	cmp	DWORD PTR _web+860, 0
	jne	SHORT $LN621@other_stuf

; 746  :        { outstring("Torus model not in effect.\n");

	push	OFFSET ??_C@_0BM@IOIDOPMA@Torus?5model?5not?5in?5effect?4?6?$AA@
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN621@other_stuf:

; 747  :          break;
; 748  :        }
; 749  :        if ( i < 1 || i > SDIM ) outstring("Improper period number.\n");

	cmp	eax, 1
	jl	SHORT $LN619@other_stuf
	cmp	eax, DWORD PTR _web+616
	jg	SHORT $LN619@other_stuf

; 750  :        else tordup(i-1);

	dec	eax
	push	eax
	call	_tordup
	add	esp, 4

; 751  :        recalc();

	call	_recalc
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN619@other_stuf:

; 747  :          break;
; 748  :        }
; 749  :        if ( i < 1 || i > SDIM ) outstring("Improper period number.\n");

	push	OFFSET ??_C@_0BJ@MMPMCFA@Improper?5period?5number?4?6?$AA@
	call	_outstring
	add	esp, 4
$LN92@other_stuf:

; 751  :        recalc();

	call	_recalc
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN617@other_stuf:

; 752  :        break;
; 753  :      
; 754  :     case SKINNY_NODE:
; 755  :        sprintf(msg,"New edges: %d\n",web.facet_refine_count = skinny(*(stacktop--)));

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR [ebx+48], eax
	call	_skinny
	mov	edx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0P@BKJHBGLB@New?5edges?3?5?$CFd?6?$AA@
	push	edx
	mov	DWORD PTR _web+5448, eax
	call	_sprintf

; 756  :        outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 24					; 00000018H

; 757  :        recalc();

	call	_recalc
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN616@other_stuf:

; 758  :        break;
; 759  : 
; 760  :     case PUSHQPRESSURE_NODE:
; 761  :      *++stacktop = GEN_QUANT(node->op1.quant_id)->pressure;

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR [edi+32]
	mov	edx, DWORD PTR _gen_quant_list
	imul	ecx, 368				; 00000170H
	mov	ebx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx+edx+192]
	pop	edi
	pop	esi
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN615@other_stuf:

; 762  :           break;
; 763  :     case PUSHQTARGET_NODE:
; 764  :      *++stacktop = GEN_QUANT(node->op1.quant_id)->target;

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [edi+32]
	mov	ecx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H
	mov	ebx, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax+ecx+144]
	pop	edi
	pop	esi
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN614@other_stuf:

; 765  :           break;
; 766  :     case PUSHQMODULUS_NODE:
; 767  :      *++stacktop = GEN_QUANT(node->op1.quant_id)->modulus;

	add	DWORD PTR [ebx+48], 8
	mov	edx, DWORD PTR [edi+32]
	mov	eax, DWORD PTR _gen_quant_list
	imul	edx, 368				; 00000170H
	mov	ebx, DWORD PTR [ebx+48]
	fld	QWORD PTR [edx+eax+176]
	pop	edi
	pop	esi
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN613@other_stuf:

; 768  :           break;
; 769  :     case PUSHQTOLERANCE_NODE:
; 770  :      *++stacktop = GEN_QUANT(node->op1.quant_id)->tolerance;

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR [edi+32]
	mov	edx, DWORD PTR _gen_quant_list
	imul	ecx, 368				; 00000170H
	mov	ebx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx+edx+184]
	pop	edi
	pop	esi
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN612@other_stuf:

; 771  :           break;
; 772  :     case PUSHMMODULUS_NODE:
; 773  :      *++stacktop = METH_INSTANCE(node->op1.meth_id)->modulus;

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [edi+32]
	mov	ecx, DWORD PTR _meth_inst_list
	mov	ebx, DWORD PTR [ebx+48]
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	eax, 2928				; 00000b70H
	pop	edi
	pop	esi
	fld	QWORD PTR [eax+ecx+304]
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN611@other_stuf:

; 774  :           break;
; 775  :     case PUSHQVALUE_NODE:
; 776  :       { struct gen_quant *q = GEN_QUANT(node->op1.quant_id);

	mov	edi, DWORD PTR [edi+32]
	imul	edi, 368				; 00000170H
	add	edi, DWORD PTR _gen_quant_list

; 777  :         if ( q->timestamp<global_timestamp )

	mov	edx, DWORD PTR [edi+364]
	cmp	edx, DWORD PTR _global_timestamp
	jge	SHORT $LN610@other_stuf

; 778  :                    calc_quants(q->flags&(Q_INFO|Q_ENERGY|Q_FIXED));

	mov	eax, DWORD PTR [edi+136]
	and	eax, 7
	push	eax
	call	_calc_quants
	fstp	ST(0)
	add	esp, 4
$LN610@other_stuf:

; 779  :         *++stacktop = q->value;

	add	DWORD PTR [ebx+48], 8
	fld	QWORD PTR [edi+152]
	mov	ebx, DWORD PTR [ebx+48]
	pop	edi
	fstp	QWORD PTR [ebx]
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN609@other_stuf:

; 780  :       }
; 781  :       break;
; 782  :     case PUSHQFIXED_NODE:
; 783  :      *++stacktop = GEN_QUANT(node->op1.quant_id)->flags & Q_FIXED ? 1:0 ;

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR [edi+32]
	mov	edx, DWORD PTR _gen_quant_list
	imul	ecx, 368				; 00000170H
	mov	eax, DWORD PTR [ecx+edx+136]
	mov	ebx, DWORD PTR [ebx+48]
	shr	eax, 1
	and	eax, 1
	mov	DWORD PTR tv12466[ebp], eax
	pop	edi
	pop	esi
	fild	DWORD PTR tv12466[ebp]
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN608@other_stuf:

; 784  :           break;
; 785  :     case PUSHQENERGY_NODE:
; 786  :      *++stacktop = GEN_QUANT(node->op1.quant_id)->flags & Q_ENERGY ? 1:0 ;

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR [edi+32]
	mov	edx, DWORD PTR _gen_quant_list
	imul	ecx, 368				; 00000170H
	mov	eax, DWORD PTR [ecx+edx+136]
	mov	ebx, DWORD PTR [ebx+48]
	and	eax, 1
	mov	DWORD PTR tv12464[ebp], eax
	pop	edi
	pop	esi
	fild	DWORD PTR tv12464[ebp]
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN607@other_stuf:

; 787  :           break;
; 788  :     case PUSHQINFO_ONLY_NODE:
; 789  :      *++stacktop = GEN_QUANT(node->op1.quant_id)->flags & Q_INFO ? 1:0 ;

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR [edi+32]
	mov	edx, DWORD PTR _gen_quant_list
	imul	ecx, 368				; 00000170H
	mov	eax, DWORD PTR [ecx+edx+136]
	mov	ebx, DWORD PTR [ebx+48]
	shr	eax, 2
	and	eax, 1
	mov	DWORD PTR tv12462[ebp], eax
	pop	edi
	pop	esi
	fild	DWORD PTR tv12462[ebp]
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN606@other_stuf:

; 790  :           break;
; 791  :     case PUSHQCONSERVED_NODE:
; 792  :      *++stacktop = GEN_QUANT(node->op1.quant_id)->flags & Q_CONSERVED ? 1:0 ;

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR [edi+32]
	mov	edx, DWORD PTR _gen_quant_list
	imul	ecx, 368				; 00000170H
	mov	eax, DWORD PTR [ecx+edx+136]
	mov	ebx, DWORD PTR [ebx+48]
	shr	eax, 3
	and	eax, 1
	mov	DWORD PTR tv12460[ebp], eax
	pop	edi
	pop	esi
	fild	DWORD PTR tv12460[ebp]
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN605@other_stuf:

; 793  :           break;
; 794  : 
; 795  :     case PUSHMVALUE_NODE:
; 796  :       { struct method_instance *q 
; 797  :               = METH_INSTANCE(node->op1.meth_id);

	mov	eax, DWORD PTR [edi+32]
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx
	imul	esi, 2928				; 00000b70H
	add	esi, DWORD PTR _meth_inst_list

; 798  :         if ((q->timestamp<graph_timestamp) || (q->timestamp<web_timestamp))

	mov	eax, DWORD PTR [esi+2924]
	cmp	eax, DWORD PTR _graph_timestamp
	jl	SHORT $LN603@other_stuf
	cmp	eax, DWORD PTR _web_timestamp
	jge	SHORT $LN604@other_stuf
$LN603@other_stuf:

; 799  :                    calc_quants((Q_INFO|Q_ENERGY|Q_FIXED));

	push	7
	call	_calc_quants
	fstp	ST(0)
	add	esp, 4
$LN604@other_stuf:

; 800  :         *++stacktop = q->value;

	add	DWORD PTR [ebx+48], 8
	fld	QWORD PTR [esi+312]
	mov	ebx, DWORD PTR [ebx+48]
	pop	edi
	fstp	QWORD PTR [ebx]
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN602@other_stuf:

; 801  :       }
; 802  :       break;
; 803  : 
; 804  :     case PUSHQVOLCONST_NODE:
; 805  :       *++stacktop = GEN_QUANT(node->op1.quant_id)->volconst;

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR [edi+32]
	mov	edx, DWORD PTR _gen_quant_list
	imul	ecx, 368				; 00000170H
	mov	ebx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx+edx+208]
	pop	edi
	pop	esi
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN601@other_stuf:

; 806  :       break;
; 807  :   
; 808  :     case PUSH_NAMED_QUANTITY_NODE:
; 809  :     case PUSH_METHOD_INSTANCE_NODE:
; 810  :        *++stacktop = (REAL)node->op1.quant_id;

	add	DWORD PTR [ebx+48], 8
	fild	DWORD PTR [edi+32]
	mov	ebx, DWORD PTR [ebx+48]
	pop	edi
	pop	esi
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN600@other_stuf:

; 811  :        break;
; 812  :     
; 813  :     case FIX_QUANTITY_NODE: case SET_Q_FIXED_NODE:
; 814  :     { struct gen_quant *q = GEN_QUANT(node->op1.quant_id);

	mov	edi, DWORD PTR [edi+32]
	imul	edi, 368				; 00000170H
	add	edi, DWORD PTR _gen_quant_list

; 815  :       q->flags &= ~(Q_ENERGY|Q_INFO|Q_CONSERVED);

	mov	eax, DWORD PTR [edi+136]
	and	eax, -14				; fffffff2H

; 816  :       q->flags |= Q_FIXED;

	or	eax, 2
	mov	DWORD PTR [edi+136], eax

; 817  :       if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN855@other_stuf

; 818  :         if ( valid_id(q->b_id) )

	mov	edi, DWORD PTR [edi+216]
	test	edi, 268435456				; 10000000H
	je	$LN855@other_stuf

; 819  :           set_attr(q->b_id,FIXEDVOL);

	push	0
	push	32					; 00000020H
	push	edi
$LN1603@other_stuf:
	call	_set_attr
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN597@other_stuf:

; 820  :     }
; 821  :     break;
; 822  : 
; 823  :     case UNFIX_QUANTITY_NODE:
; 824  :     { struct gen_quant *q = GEN_QUANT(node->op1.quant_id);

	mov	edi, DWORD PTR [edi+32]
	imul	edi, 368				; 00000170H
	add	edi, DWORD PTR _gen_quant_list

; 825  :       q->flags &= ~(Q_ENERGY|Q_FIXED|Q_CONSERVED);

	mov	ecx, DWORD PTR [edi+136]
	and	ecx, -12				; fffffff4H

; 826  :       q->flags |= Q_INFO;

	or	ecx, 4
	mov	DWORD PTR [edi+136], ecx
$LN1604@other_stuf:

; 827  :       if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN855@other_stuf

; 828  :         if ( valid_id(q->b_id) )

	mov	edi, DWORD PTR [edi+216]
	test	edi, 268435456				; 10000000H
	je	$LN855@other_stuf

; 829  :           unset_attr(q->b_id,FIXEDVOL);

	push	0
	push	32					; 00000020H
	push	edi
$LN460@other_stuf:
	call	_unset_attr
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN594@other_stuf:

; 830  :     }
; 831  :     break;
; 832  : 
; 833  :     case SET_Q_INFO_NODE:
; 834  :     { struct gen_quant *q = GEN_QUANT(node->op1.quant_id);

	mov	edi, DWORD PTR [edi+32]
	imul	edi, 368				; 00000170H
	add	edi, DWORD PTR _gen_quant_list

; 835  :       q->flags &= ~(Q_ENERGY|Q_FIXED|Q_CONSERVED);

	mov	edx, DWORD PTR [edi+136]
	and	edx, -12				; fffffff4H

; 836  :       q->flags |= Q_INFO;

	or	edx, 4
	mov	DWORD PTR [edi+136], edx

; 837  :       if ( everything_quantities_flag )
; 838  :         if ( valid_id(q->b_id) )
; 839  :           unset_attr(q->b_id,FIXEDVOL);
; 840  :     }
; 841  :     break;

	jmp	SHORT $LN1604@other_stuf
$LN591@other_stuf:

; 842  : 
; 843  :     case SET_Q_ENERGY_NODE:
; 844  :     { struct gen_quant *q = GEN_QUANT(node->op1.quant_id);

	mov	esi, DWORD PTR [edi+32]
	imul	esi, 368				; 00000170H
	add	esi, DWORD PTR _gen_quant_list

; 845  :       if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN589@other_stuf

; 846  :         if ( valid_id(q->b_id) )

	test	DWORD PTR [esi+216], 268435456		; 10000000H
	je	SHORT $LN589@other_stuf

; 847  :         { sprintf(errmsg,"Cannot set body volume to ENERGY.\n");

	push	OFFSET ??_C@_0CD@KDCNGGGN@Cannot?5set?5body?5volume?5to?5ENERGY@
	push	OFFSET _errmsg
	call	_sprintf

; 848  :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 849  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1123@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1123@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 850  :           kb_error(2416,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2416					; 00000970H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN589@other_stuf:

; 851  :         }
; 852  :       q->flags &= ~(Q_FIXED|Q_INFO|Q_CONSERVED);

	mov	ecx, DWORD PTR [esi+136]
	and	ecx, -15				; fffffff1H

; 853  :       q->flags |= Q_ENERGY;

	or	ecx, 1
	pop	edi
	mov	DWORD PTR [esi+136], ecx
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN588@other_stuf:

; 854  :     }
; 855  :     break;
; 856  : 
; 857  :     case SET_Q_CONSERVED_NODE:
; 858  :     { struct gen_quant *q = GEN_QUANT(node->op1.quant_id);

	mov	esi, DWORD PTR [edi+32]
	imul	esi, 368				; 00000170H
	add	esi, DWORD PTR _gen_quant_list

; 859  :       if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN586@other_stuf

; 860  :         if ( valid_id(q->b_id) )

	test	DWORD PTR [esi+216], 268435456		; 10000000H
	je	SHORT $LN586@other_stuf

; 861  :         { sprintf(errmsg,"Cannot set body volume to CONSERVED.\n");

	push	OFFSET ??_C@_0CG@FGOFACKJ@Cannot?5set?5body?5volume?5to?5CONSER@
	push	OFFSET _errmsg
	call	_sprintf

; 862  :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 863  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1124@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1124@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 864  :           kb_error(2546,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2546					; 000009f2H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN586@other_stuf:

; 865  :         }
; 866  :       q->flags &= ~(Q_FIXED|Q_INFO|Q_ENERGY);

	mov	eax, DWORD PTR [esi+136]
	and	eax, -8					; fffffff8H

; 867  :       q->flags |= Q_CONSERVED;

	or	eax, 8
	pop	edi
	mov	DWORD PTR [esi+136], eax
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN585@other_stuf:

; 868  :     }
; 869  :     break;
; 870  : 
; 871  : 
; 872  :     case UNFIX_PARAMETER_NODE: 
; 873  :     { struct global *p = globals(node->op1.name_id);

	mov	eax, DWORD PTR [edi+32]
	mov	ecx, eax
	and	ecx, -16777216				; ff000000H
	cmp	ecx, 268435456				; 10000000H
	je	SHORT $LN915@other_stuf
	cmp	ecx, 805306368				; 30000000H
	jne	SHORT $LN917@other_stuf
	mov	ecx, DWORD PTR _localbase$GSCopy$[ebp]
	and	eax, 16777215				; 00ffffffH
	imul	eax, 224				; 000000e0H
	add	eax, DWORD PTR [ecx]
	mov	esi, eax
	jmp	SHORT $LN916@other_stuf
$LN917@other_stuf:
	cmp	ecx, 536870912				; 20000000H
	jne	SHORT $LN915@other_stuf
	mov	edx, DWORD PTR _web+5656
	and	eax, 16777215				; 00ffffffH
	mov	esi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN916@other_stuf
$LN915@other_stuf:
	mov	ecx, DWORD PTR _web+5652
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [edx+eax]
$LN916@other_stuf:

; 874  :       int old = p->flags & OPTIMIZING_PARAMETER;

	mov	ebx, 32768				; 00008000H
	test	DWORD PTR [esi+192], ebx

; 875  :       if ( !old )

	jne	$LN584@other_stuf

; 876  :       { if ( p->type != REAL_TYPE )

	cmp	DWORD PTR [esi+200], 1
	je	SHORT $LN583@other_stuf

; 877  :         { sprintf(errmsg,"Cannot unfix \"%s\" since it is not type REAL.\n",
; 878  :             p->name);

	push	esi
	push	OFFSET ??_C@_0CO@MBFAENFA@Cannot?5unfix?5?$CC?$CFs?$CC?5since?5it?5is?5no@
	push	OFFSET _errmsg
	call	_sprintf

; 879  :           kb_error(4124,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4124					; 0000101cH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN583@other_stuf:

; 880  :         }
; 881  :         if ( optparamcount >= MAXOPTPARAM-1 )

	cmp	DWORD PTR _optparamcount, 99		; 00000063H
	jl	SHORT $LN582@other_stuf

; 882  :         { sprintf(errmsg,"Too many optimizing parameters.  Increase MAXOPTPARAM in extern.h and recompile.\n");

	push	OFFSET ??_C@_0FC@MEEGBMH@Too?5many?5optimizing?5parameters?4?5@
	push	OFFSET _errmsg
	call	_sprintf

; 883  :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 884  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1125@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1125@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 885  :           kb_error(2022,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2022					; 000007e6H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN582@other_stuf:

; 886  :         }
; 887  :         p->flags |= OPTIMIZING_PARAMETER;

	or	DWORD PTR [esi+192], ebx

; 888  :         memset((char*)&optparam[optparamcount],0,sizeof(struct optparam_t));

	mov	ebx, DWORD PTR _optparamcount
	lea	eax, DWORD PTR [ebx*8]
	sub	eax, ebx
	push	56					; 00000038H
	lea	eax, DWORD PTR _optparam[eax*8]
	push	0
	push	eax
	mov	DWORD PTR tv9676[ebp], eax
	call	_memset

; 889  :         optparam[optparamcount++].pnum = node->op1.name_id;

	mov	ecx, DWORD PTR [edi+32]
	mov	edx, DWORD PTR tv9676[ebp]
	inc	ebx
	add	esp, 12					; 0000000cH

; 890  :         if ( !everything_quantities_flag ) convert_to_quantities();

	cmp	DWORD PTR _everything_quantities_flag, 0
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR _optparamcount, ebx
	jne	SHORT $LN581@other_stuf
	call	_convert_to_quantities
$LN581@other_stuf:

; 891  :         sprintf(msg,"%s now optimizing parameter. (was not)\n",p->name);

	mov	eax, DWORD PTR _msg
	push	esi
	push	OFFSET ??_C@_0CI@PPHECMJA@?$CFs?5now?5optimizing?5parameter?4?5?$CIwa@
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN584@other_stuf:

; 892  :       }
; 893  :       else sprintf(msg,"%s now optimizing parameter. (already was)\n",p->name);

	mov	ecx, DWORD PTR _msg
	push	esi
	push	OFFSET ??_C@_0CM@NFHEKMBO@?$CFs?5now?5optimizing?5parameter?4?5?$CIal@
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN579@other_stuf:

; 894  :       break;
; 895  :     }
; 896  : 
; 897  :     case FIX_PARAMETER_NODE:
; 898  :     { struct global *p = globals(node->op1.name_id);

	mov	ebx, DWORD PTR [edi+32]
	mov	eax, ebx
	and	eax, -16777216				; ff000000H
	cmp	eax, 268435456				; 10000000H
	jne	SHORT $LN925@other_stuf
	mov	eax, DWORD PTR _web+5652
	mov	edx, ebx
	and	edx, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _dymem
	mov	eax, DWORD PTR [ecx+edx]
	jmp	SHORT $LN922@other_stuf
$LN925@other_stuf:
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN923@other_stuf
	mov	ecx, ebx
	and	ecx, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _localbase$GSCopy$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN922@other_stuf
$LN923@other_stuf:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN921@other_stuf
	mov	eax, DWORD PTR _web+5656
	mov	edx, ebx
	and	edx, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN922@other_stuf
$LN921@other_stuf:
	mov	edx, DWORD PTR _web+5652
	mov	ecx, ebx
	and	ecx, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx]
$LN922@other_stuf:

; 899  :       int old = p->flags & OPTIMIZING_PARAMETER;

	mov	edx, DWORD PTR [eax+192]
	test	edx, 32768				; 00008000H

; 900  :       int spot;
; 901  :       if ( old )

	je	$LN578@other_stuf

; 902  :       { for ( spot = 0 ; spot < optparamcount ; spot++ )

	mov	esi, DWORD PTR _optparamcount
	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN1071@other_stuf
	mov	edx, OFFSET _optparam
	npad	4
$LL577@other_stuf:

; 903  :            if ( optparam[spot].pnum == node->op1.name_id ) break;

	cmp	DWORD PTR [edx], ebx
	je	SHORT $LN1220@other_stuf

; 902  :       { for ( spot = 0 ; spot < optparamcount ; spot++ )

	inc	ecx
	add	edx, 56					; 00000038H
	cmp	ecx, esi
	jl	SHORT $LL577@other_stuf
$LN1220@other_stuf:
	mov	edx, DWORD PTR [eax+192]
$LN1071@other_stuf:

; 904  :         if ( spot == optparamcount )
; 905  :         { sprintf(errmsg,"`%s` not found in optimizing parameter list.\n",p->name);

	push	eax
	cmp	ecx, esi
	jne	SHORT $LN573@other_stuf
	push	OFFSET ??_C@_0CO@ONDCODFB@?$GA?$CFs?$GA?5not?5found?5in?5optimizing?5par@
	push	OFFSET _errmsg
	call	_sprintf

; 906  :           sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 907  :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1126@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1126@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 908  :           kb_error(2023,errmsg,WARNING);

	push	2
	push	OFFSET _errmsg
	push	2023					; 000007e7H
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN573@other_stuf:

; 909  :           break;
; 910  :         }
; 911  :         p->flags &= ~OPTIMIZING_PARAMETER;

	and	edx, -32769				; ffff7fffH
	mov	DWORD PTR [eax+192], edx

; 912  :         optparam[spot] = optparam[--optparamcount];

	mov	edx, DWORD PTR _optparamcount

; 913  :         sprintf(msg,"%s now nonoptimizing parameter. (was not)\n",p->name);

	mov	eax, DWORD PTR _msg
	dec	edx
	lea	edi, DWORD PTR [ecx*8]
	lea	esi, DWORD PTR [edx*8]
	sub	edi, ecx
	sub	esi, edx
	push	OFFSET ??_C@_0CL@GKIDDEHI@?$CFs?5now?5nonoptimizing?5parameter?4?5@
	lea	esi, DWORD PTR _optparam[esi*8]
	lea	edi, DWORD PTR _optparam[edi*8]
	mov	ecx, 14					; 0000000eH
	push	eax
	mov	DWORD PTR _optparamcount, edx
	rep movsd
	call	_sprintf
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN578@other_stuf:

; 914  :       }
; 915  :       else sprintf(msg,"%s now nonoptimizing parameter. (already was)\n",p->name);

	mov	ecx, DWORD PTR _msg
	push	eax
	push	OFFSET ??_C@_0CP@PBCCHLA@?$CFs?5now?5nonoptimizing?5parameter?4?5@
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN571@other_stuf:

; 916  :       break;
; 917  :     }
; 918  : 
; 919  :     /* attribute setting in set statements */
; 920  :     case SET_ATTRIBUTE_NODE: 
; 921  :     case SET_ATTRIBUTE_L_NODE: 
; 922  :          if ( node->op1.localnum ) 

	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
	je	SHORT $LN569@other_stuf

; 923  :               id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _localstack$GSCopy$[ebp]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	mov	esi, DWORD PTR [eax+edx*8]
$LN569@other_stuf:

; 924  :          else id = q_id;
; 925  :          parallel_update_flag[id_type(id)] = 1; /* set when element info changed */

	mov	ecx, esi
	shr	ecx, 29					; 0000001dH
	mov	DWORD PTR _parallel_update_flag[ecx*4], 1

; 926  :          switch ( node->op2.attr_kind )

	mov	eax, DWORD PTR [edi+136]
	lea	edx, DWORD PTR [eax-10265]
	mov	DWORD PTR tv9707[ebp], ecx
	cmp	edx, 187				; 000000bbH
	ja	$LN439@other_stuf
	movzx	edx, BYTE PTR $LN1127@other_stuf[edx]
	jmp	DWORD PTR $LN1643@other_stuf[edx*4]
$LN566@other_stuf:

; 927  :          {
; 928  :            case SET_FIXED_NODE: set_attr(id,FIXED); break;

	push	0
	push	64					; 00000040H
	push	esi
	call	_set_attr
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN565@other_stuf:

; 929  :            case SET_TRIPLE_PT_NODE: set_attr(id,TRIPLE_PT); --stacktop; break;

	push	0
	push	524288					; 00080000H
	push	esi
	call	_set_attr
	add	esp, 12					; 0000000cH
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN564@other_stuf:

; 930  :            case SET_TETRA_PT_NODE: set_attr(id,TETRA_PT); --stacktop; break;

	push	0
	push	262144					; 00040000H
	push	esi
	call	_set_attr
	add	esp, 12					; 0000000cH
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN563@other_stuf:

; 931  :            case SET_AXIAL_POINT_NODE: set_attr(id,AXIAL_POINT); --stacktop; break;

	push	0
	push	8388608					; 00800000H
	push	esi
	call	_set_attr
	add	esp, 12					; 0000000cH
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN562@other_stuf:

; 932  :    
; 933  :            case SET_EXTRA_ATTR_NODE:
; 934  :             { struct extra *ext;
; 935  :               int spot; /* index */
; 936  :               n = node->op3.extra_info & ((1<<ESHIFT)-1);

	mov	ecx, DWORD PTR [edi+140]

; 937  :               if ( node->op1.localnum ) 

	mov	eax, DWORD PTR [edi+32]
	and	ecx, 4095				; 00000fffH
	xor	esi, esi
	mov	DWORD PTR _n$[ebp], ecx
	cmp	eax, esi
	je	SHORT $LN561@other_stuf

; 938  :                  id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+eax+216]
	mov	eax, DWORD PTR _localstack$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax+edx*8]
	jmp	SHORT $LN1591@other_stuf
$LN561@other_stuf:

; 939  :               else id = q_id;

	mov	eax, DWORD PTR _q_id$GSCopy$[ebp]
$LN1591@other_stuf:
	mov	DWORD PTR _id$[ebp], eax

; 940  :               ext = EXTRAS(id_type(id)) + n;

	imul	ecx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	shl	edx, 4
	mov	eax, DWORD PTR _web[edx+104]
	add	eax, ecx
	add	eax, DWORD PTR _dymem

; 941  :               /* get index */
; 942  :               spot = 0;
; 943  :               for ( k = 0 ; k < ext->array_spec.dim ; k++ )

	mov	DWORD PTR _k$[ebp], esi
	mov	DWORD PTR _ext$90395[ebp], eax
	cmp	DWORD PTR [eax+76], esi
	jle	$LN557@other_stuf

; 940  :               ext = EXTRAS(id_type(id)) + n;

	add	eax, 96					; 00000060H
	mov	DWORD PTR tv14430[ebp], eax
$LL559@other_stuf:

; 944  :               { int j = (int)(stacktop[-ext->array_spec.dim+k+1]);

	mov	edx, DWORD PTR _ext$90395[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, DWORD PTR [edx+76]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax+ecx*8+8]
	call	__ftol2_sse

; 945  :                 spot *= ext->array_spec.sizes[k];

	mov	ecx, DWORD PTR tv14430[ebp]
	mov	ecx, DWORD PTR [ecx]
	imul	esi, ecx
	mov	DWORD PTR _j$90405[ebp], eax
	mov	DWORD PTR _spot$90396[ebp], esi

; 946  :                 if ( j > ext->array_spec.sizes[k] )

	cmp	eax, ecx
	jle	SHORT $LN1203@other_stuf

; 947  :                 { sprintf(errmsg,
; 948  :                      "Attribute %s index %d is %d; maximum is %d (in %s).\n",
; 949  :                      ext->name,k+1,j,ext->array_spec.sizes[k],ext->name);

	mov	eax, DWORD PTR _ext$90395[ebp]
	mov	edx, DWORD PTR tv14430[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _j$90405[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _k$[ebp]
	push	edx
	inc	ecx
	push	ecx
	push	eax
	push	OFFSET ??_C@_0DF@MPPJKLHD@Attribute?5?$CFs?5index?5?$CFd?5is?5?$CFd?$DL?5max@
	push	OFFSET _errmsg
	call	_sprintf

; 950  :                   sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 951  :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 28					; 0000001cH
	lea	esi, DWORD PTR [eax+1]
	npad	5
$LL1128@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1128@other_stuf
	mov	edx, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 952  :                   kb_error(1210,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1210					; 000004baH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1203@other_stuf:

; 953  :                 }
; 954  :                 if ( j < 1 )

	mov	eax, DWORD PTR _j$90405[ebp]
	cmp	eax, 1
	jge	SHORT $LN555@other_stuf

; 955  :                 { sprintf(errmsg,
; 956  :                      "Attribute %s index %d is %d; must be positive.\n",
; 957  :                         ext->name,k,j); 

	mov	ecx, DWORD PTR _ext$90395[ebp]
	push	eax
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DA@FHCLKLI@Attribute?5?$CFs?5index?5?$CFd?5is?5?$CFd?$DL?5mus@
	push	OFFSET _errmsg
	call	_sprintf

; 958  :                   sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 959  :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL1129@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1129@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 960  :                   kb_error(1129,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1129					; 00000469H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN555@other_stuf:

; 961  :                 }
; 962  :                 spot += (int)(stacktop[-ext->array_spec.dim+k+1]) - 1;

	mov	eax, DWORD PTR _ext$90395[ebp]
	mov	eax, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR [ebx+48]
	sub	ecx, eax
	fld	QWORD PTR [edx+ecx*8+8]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _spot$90396[ebp]
	mov	edx, DWORD PTR _ext$90395[ebp]
	add	DWORD PTR tv14430[ebp], 4
	lea	esi, DWORD PTR [ecx+eax-1]
	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR [edx+76]
	jl	$LL559@other_stuf
$LN557@other_stuf:

; 963  :               }
; 964  :               stacktop -= ext->array_spec.dim;

	mov	eax, DWORD PTR _ext$90395[ebp]
	mov	ecx, DWORD PTR [eax+76]
	neg	ecx
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [ebx+48], ecx

; 965  :    
; 966  :               switch ( ext->type )

	mov	eax, DWORD PTR [eax+68]
	mov	edi, DWORD PTR [ebx+48]
	dec	eax
	cmp	eax, 22					; 00000016H
	ja	$LN855@other_stuf
	movzx	edx, BYTE PTR $LN1130@other_stuf[eax]
	jmp	DWORD PTR $LN1644@other_stuf[edx*4]
$LN552@other_stuf:

; 967  :               { case REAL_TYPE:  ((REAL*)get_extra(id,n))[spot] = *(stacktop--); 

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	push	eax
	push	ecx
	call	_get_extra
	fld	QWORD PTR [edi]
	add	esp, 8
	fstp	QWORD PTR [eax+esi*8]
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN551@other_stuf:

; 968  :                    break;
; 969  :                 case INTEGER_TYPE:
; 970  :                    ((int*)get_extra(id,n))[spot] = (int)*(stacktop--);

	fld	QWORD PTR [edi]
$LN1615@other_stuf:
	call	__ftol2_sse
	mov	edi, eax
$LN1612@other_stuf:
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _id$[ebp]
	push	edx
	push	eax
$LN1614@other_stuf:
	call	_get_extra
	mov	DWORD PTR [eax+esi*4], edi
$LN1623@other_stuf:
	add	esp, 8
$LN1613@other_stuf:
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN550@other_stuf:

; 971  :                    break;
; 972  :                 case ULONG_TYPE:
; 973  :                    ((unsigned long*)get_extra(id,n))[spot] = 
; 974  :                      (unsigned long)*(stacktop--);

	fld	QWORD PTR [edi]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	fnstcw	WORD PTR tv12320[ebp]
	movzx	eax, WORD PTR tv12320[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv12317[ebp], eax
	push	ecx
	push	edx
	fldcw	WORD PTR tv12317[ebp]
	fistp	QWORD PTR tv12315[ebp]
	mov	edi, DWORD PTR tv12315[ebp]
	fldcw	WORD PTR tv12320[ebp]
	call	_get_extra
	add	esp, 8
	mov	DWORD PTR [eax+esi*4], edi
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN549@other_stuf:

; 975  :                    break;
; 976  :                 case USHORT_TYPE:
; 977  :                    ((unsigned short*)get_extra(id,n))[spot] = 
; 978  :                      (unsigned short)*(stacktop--);

	fld	QWORD PTR [edi]
	mov	ecx, DWORD PTR _id$[ebp]
	fnstcw	WORD PTR tv12310[ebp]
	movzx	eax, WORD PTR tv12310[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv12307[ebp], eax
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	fldcw	WORD PTR tv12307[ebp]
	push	ecx
	fistp	DWORD PTR tv12305[ebp]
	mov	di, WORD PTR tv12305[ebp]
	fldcw	WORD PTR tv12310[ebp]
	call	_get_extra
	add	esp, 8
	mov	WORD PTR [eax+esi*2], di
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN548@other_stuf:

; 979  :                    break;
; 980  :                 case UINT_TYPE:
; 981  :                    ((unsigned int*)get_extra(id,n))[spot] = 
; 982  :                      (unsigned int)*(stacktop--);

	fld	QWORD PTR [edi]
	fnstcw	WORD PTR tv12300[ebp]
	movzx	eax, WORD PTR tv12300[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv12297[ebp], eax
	fldcw	WORD PTR tv12297[ebp]
	fistp	QWORD PTR tv12295[ebp]
	mov	edi, DWORD PTR tv12295[ebp]
	fldcw	WORD PTR tv12300[ebp]

; 983  :                    break;

	jmp	$LN1612@other_stuf
$LN547@other_stuf:

; 984  :                 case UCHAR_TYPE:
; 985  :                    ((unsigned char*)get_extra(id,n))[spot] = 
; 986  :                      (unsigned char)*(stacktop--);

	fld	QWORD PTR [edi]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	fnstcw	WORD PTR tv12290[ebp]
	movzx	eax, WORD PTR tv12290[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv12287[ebp], eax
	push	ecx
	push	edx
	fldcw	WORD PTR tv12287[ebp]
	fistp	DWORD PTR tv12285[ebp]
	mov	al, BYTE PTR tv12285[ebp]
	fldcw	WORD PTR tv12290[ebp]
	mov	BYTE PTR tv9747[ebp], al
	call	_get_extra
	mov	cl, BYTE PTR tv9747[ebp]
	mov	BYTE PTR [eax+esi], cl

; 987  :                    break;

	jmp	$LN1623@other_stuf
$LN545@other_stuf:

; 988  :                 case LONG_TYPE:
; 989  :                    ((long int*)get_extra(id,n))[spot] = 
; 990  :                      (long int)*(stacktop--);
; 991  :                    break;
; 992  :                 case SHORT_TYPE:
; 993  :                    ((short*)get_extra(id,n))[spot] = 
; 994  :                      (short)*(stacktop--);

	fld	QWORD PTR [edi]
$LN1617@other_stuf:
	call	__ftol2_sse
	mov	di, ax
$LN1618@other_stuf:
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _id$[ebp]
	push	edx
	push	eax
	call	_get_extra
	mov	WORD PTR [eax+esi*2], di

; 995  :                    break;

	jmp	$LN1623@other_stuf
$LN544@other_stuf:

; 996  :                 case CHAR_TYPE:
; 997  :                    ((char*)get_extra(id,n))[spot] = 
; 998  :                      (char)*(stacktop--);

	fld	QWORD PTR [edi]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	mov	BYTE PTR tv9745[ebp], al
	call	_get_extra
	mov	cl, BYTE PTR tv9745[ebp]
	mov	BYTE PTR [eax+esi], cl

; 999  :                    break;

	jmp	$LN1623@other_stuf
$LN541@other_stuf:

; 1000 :                 case ELEMENTID_TYPE:
; 1001 :                 case VERTEX_TYPE:
; 1002 :                 case EDGE_TYPE:
; 1003 :                 case FACET_TYPE:
; 1004 :                 case BODY_TYPE:
; 1005 :                 case FACETEDGE_TYPE:
; 1006 :                    ((element_id*)get_extra(id,n))[spot] = 
; 1007 :                      *(element_id*)(stacktop--);
; 1008 :                    break;
; 1009 :                 case PTR_TYPE:
; 1010 :                    ((char**)get_extra(id,n))[spot] = 
; 1011 :                      *(char**)(stacktop--);
; 1012 :                    break;
; 1013 :                 case BOUNDARY_TYPE:
; 1014 :                 case CONSTRAINT_TYPE:
; 1015 :                 case QUANTITY_TYPE:
; 1016 :                 case INSTANCE_TYPE:
; 1017 :                 case PROCEDURE_TYPE:
; 1018 :                    ((int*)get_extra(id,n))[spot] = (int)*(stacktop--);

	fld	QWORD PTR [edi]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _id$[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	push	ecx
	call	_get_extra
	add	esp, 8
	mov	DWORD PTR [eax+esi*4], edi
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN540@other_stuf:

; 1019 :                    break;
; 1020 :               }
; 1021 :            }
; 1022 :            break;
; 1023 :    
; 1024 :           case SET_DENSITY_NODE:
; 1025 :           { REAL density = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	fst	QWORD PTR _density$90452[ebp]
	mov	DWORD PTR [ebx+48], eax

; 1026 :               if ( density != 1.0 ) set_attr(id,DENSITY);

	fld	ST(0)
	fld1
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN1216@other_stuf
	push	0
	fstp	ST(0)
	push	16					; 00000010H
	push	esi
	call	_set_attr
	fld	QWORD PTR _density$90452[ebp]
	mov	ecx, DWORD PTR tv9707[ebp]
	add	esp, 12					; 0000000cH
$LN1216@other_stuf:

; 1027 :               switch ( id_type(id) )

	dec	ecx
	je	$LN536@other_stuf
	dec	ecx
	je	SHORT $LN535@other_stuf
	dec	ecx
	jne	$LN1464@other_stuf

; 1031 :                        pressure_set_flag = 0; break;
; 1032 :                    case BODY: set_body_density(id,density);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	esi
	call	_set_body_density

; 1033 :                        web.gravflag = 1;
; 1034 :                        if (gravity_quantity_num >= 0 )

	mov	eax, DWORD PTR _gravity_quantity_num
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _web+824, 1
	test	eax, eax
	js	$LN537@other_stuf

; 1035 :                            GEN_QUANT(gravity_quantity_num)->modulus =
; 1036 :                                  web.grav_const;

	fld	QWORD PTR _web+832
	mov	edx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H

; 1037 :                        break;
; 1038 :                  }
; 1039 :               *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	fstp	QWORD PTR [eax+edx+176]
	pop	esi
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN535@other_stuf:

; 1030 :                    case FACET: set_facet_density(id,density);

	mov	eax, DWORD PTR _web+236
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	fstp	QWORD PTR [ecx+32]

; 1037 :                        break;
; 1038 :                  }
; 1039 :               *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR _pressure_set_flag, 0
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN536@other_stuf:

; 1028 :                  { case EDGE: set_edge_density(id,density); 

	mov	edx, DWORD PTR _web+124

; 1037 :                        break;
; 1038 :                  }
; 1039 :               *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	pop	edi
	fstp	QWORD PTR [eax+40]
	pop	esi
	mov	DWORD PTR _pressure_set_flag, 0
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1464@other_stuf:

; 1029 :                        pressure_set_flag = 0; break;

	fstp	ST(0)
$LN537@other_stuf:

; 1037 :                        break;
; 1038 :                  }
; 1039 :               *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN532@other_stuf:

; 1040 :              }
; 1041 :            break;
; 1042 :    
; 1043 :       case SET_PHASE_NODE:
; 1044 :           { int phase = (int)*(stacktop--);

	mov	edi, DWORD PTR [ebx+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse

; 1045 :               switch ( id_type(id) )

	mov	ecx, DWORD PTR tv9707[ebp]
	add	edi, -8					; fffffff8H
	sub	ecx, 2
	mov	DWORD PTR [ebx+48], edi
	je	SHORT $LN528@other_stuf
	dec	ecx
	jne	SHORT $LN1192@other_stuf

; 1046 :                  { case BODY: set_b_phase(id,phase); break;

	mov	edx, DWORD PTR _B_PHASE_ATTR
	mov	ecx, DWORD PTR _web+440
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _dymem
	add	ecx, edx
	cmp	DWORD PTR [ecx+88], 0
	je	SHORT $LN1192@other_stuf
	mov	edx, DWORD PTR _web+348
	jmp	SHORT $LN1592@other_stuf
$LN528@other_stuf:

; 1047 :                    case FACET: set_f_phase(id,phase); break;

	mov	edx, DWORD PTR _F_PHASE_ATTR
	mov	ecx, DWORD PTR _dymem
	imul	edx, 240				; 000000f0H
	add	edx, DWORD PTR _web+328
	add	ecx, edx
	cmp	DWORD PTR [ecx+88], 0
	je	SHORT $LN1192@other_stuf
	mov	edx, DWORD PTR _web+236
$LN1592@other_stuf:
	mov	ecx, DWORD PTR [ecx+64]
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR [edx+ecx], eax
$LN1192@other_stuf:

; 1048 :                  }
; 1049 :               *recalc_flag = 1;

	mov	edx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN527@other_stuf:

; 1050 :            }
; 1051 :            break;
; 1052 :    
; 1053 :          case SET_VOLCONST_NODE: 
; 1054 :            { REAL v = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H

; 1055 :              REAL oldvcon = get_body_volconst(id);

	push	esi
	fstp	QWORD PTR _v$90487[ebp]
	mov	DWORD PTR [ebx+48], eax
	call	_get_body_volconst
	fstp	QWORD PTR _oldvcon$90488[ebp]

; 1056 :              set_body_volconst(id,v); 

	push	ecx
$LN1624@other_stuf:
	fld	QWORD PTR _v$90487[ebp]
	fstp	QWORD PTR [esp]
	push	esi
	call	_set_body_volconst
	add	esp, 12					; 0000000cH

; 1057 :              set_body_volume(id,get_body_volume(id)+v-oldvcon,SETSTAMP);

	push	1
	push	esi
	call	_get_body_volume
	fadd	QWORD PTR _v$90487[ebp]
	push	ecx
	fsub	QWORD PTR _oldvcon$90488[ebp]
	fstp	QWORD PTR [esp]
	push	esi
	call	_set_body_volume

; 1058 :              set_body_oldvolume(id,get_body_oldvolume(id)+v-oldvcon);

	fld	QWORD PTR _v$90487[ebp]
	mov	eax, DWORD PTR _web+348
	fld	ST(0)
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+eax]
	fadd	QWORD PTR [eax+288]
	add	esp, 16					; 00000010H
	fsub	QWORD PTR _oldvcon$90488[ebp]
	fstp	QWORD PTR [eax+288]

; 1059 :              if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN1467@other_stuf

; 1060 :                GEN_QUANT(get_body_volquant(id))->volconst = v;

	mov	ecx, DWORD PTR _web+348
	mov	edx, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [edx+404]
	mov	ecx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H

; 1061 :              *recalc_flag = 1;

	mov	edx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	fstp	QWORD PTR [eax+ecx+208]
	pop	esi
	mov	DWORD PTR [edx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1467@other_stuf:

; 1061 :              *recalc_flag = 1;

	mov	edx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	fstp	ST(0)
	pop	edi
	pop	esi
	mov	DWORD PTR [edx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN525@other_stuf:

; 1062 :              break;
; 1063 :            }
; 1064 :    
; 1065 :          case SET_TARGET_NODE: 
; 1066 :            { REAL v = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	fstp	QWORD PTR _v$90494[ebp]

; 1067 :              if ( get_attr(id) & PRESSURE )

	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	shl	eax, 4
	mov	edx, DWORD PTR _web[eax+12]
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 2048				; 00000800H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN1193@other_stuf

; 1068 :              { sprintf(errmsg,"Must unset body pressure before fixing target.\n");

	push	OFFSET ??_C@_0DA@GLPHHFLM@Must?5unset?5body?5pressure?5before?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1069 :                sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1070 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1131@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1131@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1071 :                kb_error(2024,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2024					; 000007e8H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1193@other_stuf:

; 1072 :              }
; 1073 :              set_attr(id,FIXEDVOL);

	push	0
	push	32					; 00000020H
	push	esi
	call	_set_attr

; 1074 :              set_body_fixvol(id,v);  /* takes care of quantity */

	fld	QWORD PTR _v$90494[ebp]
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	esi
	call	_set_body_fixvol
	add	esp, 12					; 0000000cH

; 1075 :              reset_conj_grad();

	call	_reset_conj_grad

; 1076 :              *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN523@other_stuf:

; 1077 :              break;
; 1078 :            }
; 1079 :    
; 1080 :            case SET_PRESSURE_NODE: 
; 1081 :            { REAL p = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]

; 1082 :              unset_attr(id,FIXEDVOL); 

	push	0
	add	eax, -8					; fffffff8H
	fstp	QWORD PTR _p$90502[ebp]
	push	32					; 00000020H
	push	esi
	mov	DWORD PTR [ebx+48], eax
	call	_unset_attr

; 1083 :              set_attr(id,PRESSURE);

	push	0
	push	2048					; 00000800H
	push	esi
	call	_set_attr

; 1084 :              web.pressflag = 1;
; 1085 :              set_body_pressure(id,p); 

	fld	QWORD PTR _p$90502[ebp]
	add	esp, 16					; 00000010H
	fstp	QWORD PTR [esp]
	push	esi
	mov	DWORD PTR _web+844, 1
	call	_set_body_pressure
	add	esp, 12					; 0000000cH

; 1086 :              reset_conj_grad();

	call	_reset_conj_grad

; 1087 :              if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	$LN518@other_stuf

; 1088 :              { struct gen_quant *q = GEN_QUANT(get_body_volquant(id));

	mov	edx, DWORD PTR _web+348

; 1089 :                if ( p == 0.0 )

	fld	QWORD PTR _p$90502[ebp]
	and	esi, 134217727				; 07ffffffH
	fld	ST(0)
	mov	eax, DWORD PTR [edx+esi*4]
	fldz
	mov	ecx, DWORD PTR [eax+404]
	fucompp
	imul	ecx, 368				; 00000170H
	fnstsw	ax
	add	ecx, DWORD PTR _gen_quant_list
	test	ah, 68					; 00000044H

; 1091 :                  if ( !(q->flags & Q_INFO) )

	mov	eax, DWORD PTR [ecx+136]
	jp	SHORT $LN521@other_stuf

; 1090 :                { q->modulus = 1.0;

	fstp	ST(0)
	fld1
	fstp	QWORD PTR [ecx+176]

; 1091 :                  if ( !(q->flags & Q_INFO) )

	test	al, 4
	jne	SHORT $LN518@other_stuf

; 1092 :                  { q->flags &= ~(Q_ENERGY|Q_FIXED|Q_CONSERVED);

	and	eax, -12				; fffffff4H

; 1093 :                    q->flags |= Q_INFO;

	or	eax, 4
	pop	edi

; 1100 :                    q->flags |= Q_ENERGY;

	mov	DWORD PTR [ecx+136], eax

; 1101 :                  }
; 1102 :                }
; 1103 :              }
; 1104 :              *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	esi
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN521@other_stuf:

; 1094 :                  }
; 1095 :                }
; 1096 :                else 
; 1097 :                { q->modulus = -p;

	fchs
	fstp	QWORD PTR [ecx+176]

; 1098 :                  if ( !(q->flags & Q_ENERGY ) )

	test	al, 1
	jne	SHORT $LN518@other_stuf

; 1099 :                  { q->flags &= ~(Q_INFO|Q_FIXED|Q_CONSERVED);

	and	eax, -15				; fffffff1H

; 1100 :                    q->flags |= Q_ENERGY;

	or	eax, 1
	mov	DWORD PTR [ecx+136], eax
$LN518@other_stuf:

; 1101 :                  }
; 1102 :                }
; 1103 :              }
; 1104 :              *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN517@other_stuf:

; 1105 :              break;
; 1106 :              }
; 1107 :    
; 1108 :            case SET_OPACITY_NODE:
; 1109 :              *(REAL*)(get_extra(id,opacity_attr)) = *(stacktop)--;

	mov	edx, DWORD PTR _opacity_attr
	push	edx
	push	esi
	call	_get_extra
	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]

; 1110 :              *recalc_flag = 1;

	mov	edx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	add	esp, 8
	fstp	QWORD PTR [eax]
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	pop	edi
	pop	esi
	mov	DWORD PTR [edx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN516@other_stuf:

; 1111 :              break;
; 1112 :    
; 1113 :           case SET_CONSTRAINT_NODE:
; 1114 :            { int con = (int)*(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	mov	ecx, DWORD PTR [ebx+48]
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], ecx

; 1115 :              struct constraint *constr;
; 1116 :              constr = get_constraint(con); 

	mov	ebx, eax
	and	ebx, 1073741823				; 3fffffffH
	imul	ebx, 176				; 000000b0H
	add	ebx, DWORD PTR _web+652
	mov	DWORD PTR _con$90515[ebp], eax

; 1117 :              if ( (con<0) || (con>=web.maxcon) || !(constr->attr & IN_USE))

	test	eax, eax
	js	SHORT $LN1194@other_stuf
	cmp	eax, DWORD PTR _web+644
	jge	SHORT $LN1194@other_stuf
	mov	eax, DWORD PTR [ebx+32]
	and	eax, 32					; 00000020H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN1196@other_stuf
$LN1194@other_stuf:

; 1118 :                { sprintf(errmsg,"Illegal constraint number: %d.\n",con);

	mov	ecx, DWORD PTR _con$90515[ebp]
	push	ecx
	push	OFFSET ??_C@_0CA@KOHHCGIN@Illegal?5constraint?5number?3?5?$CFd?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1119 :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1120 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1132@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1132@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1121 :                  kb_error(1212,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1212					; 000004bcH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1196@other_stuf:

; 1122 :                }
; 1123 :              if ( get_attr(id) & BOUNDARY ) 

	mov	eax, DWORD PTR tv9707[ebp]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	shl	edx, 4
	mov	eax, DWORD PTR _web[edx+12]
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	$LN513@other_stuf

; 1124 :              { sprintf(errmsg,
; 1125 :                  "Cannot set constraint on %s %s since it is on a boundary.\n",
; 1126 :                   typenames[id_type(id)],ELNAME(id));

	test	esi, 268435456				; 10000000H
	je	SHORT $LN931@other_stuf
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN932@other_stuf
$LN931@other_stuf:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN932@other_stuf:
	mov	ecx, DWORD PTR tv9707[ebp]
	mov	edx, DWORD PTR _typenames[ecx*4]
	push	eax
	push	edx
	push	OFFSET ??_C@_0DL@HKDGADPO@Cannot?5set?5constraint?5on?5?$CFs?5?$CFs?5s@
	push	OFFSET _errmsg
	call	_sprintf

; 1127 :                 sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1128 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL1133@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1133@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1129 :                kb_error(4111,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4111					; 0000100fH
$LN1629@other_stuf:
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN513@other_stuf:

; 1130 :              }
; 1131 :               set_attr(id,CONSTRAINT);

	push	0
	push	1024					; 00000400H
	push	esi
	call	_set_attr

; 1132 :               if ( constr->attr & CON_ENERGY )

	mov	eax, DWORD PTR [ebx+32]
	xor	ecx, ecx
	and	eax, 64					; 00000040H
	add	esp, 12					; 0000000cH
	or	eax, ecx
	je	SHORT $LN512@other_stuf

; 1133 :                  set_attr(id, BDRY_ENERGY);

	push	ecx
	push	512					; 00000200H
	push	esi
	call	_set_attr
	add	esp, 12					; 0000000cH
$LN512@other_stuf:

; 1134 :               if ( constr->attr & CON_CONTENT )

	mov	ebx, DWORD PTR [ebx+32]
	xor	eax, eax
	and	ebx, 128				; 00000080H
	or	ebx, eax
	je	SHORT $LN511@other_stuf

; 1135 :                  set_attr(id, BDRY_CONTENT);

	push	eax
	push	4096					; 00001000H
	push	esi
	call	_set_attr
	add	esp, 12					; 0000000cH
$LN511@other_stuf:

; 1136 :               switch ( id_type(id) )

	mov	eax, DWORD PTR tv9707[ebp]
	sub	eax, 0
	je	SHORT $LN508@other_stuf
	dec	eax
	je	SHORT $LN507@other_stuf
	dec	eax
	jne	SHORT $LN509@other_stuf

; 1141 :                    case FACET: set_f_constraint_map(id,con); break;

	mov	ecx, DWORD PTR _con$90515[ebp]
	push	ecx
	push	esi
	call	_set_f_constraint_map

; 1142 :                  }
; 1143 :               *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN507@other_stuf:

; 1139 :                               break;
; 1140 :                    case EDGE: set_e_constraint_map(id,con); break;

	mov	edx, DWORD PTR _con$90515[ebp]
	push	edx
	push	esi
	call	_set_e_constraint_map

; 1142 :                  }
; 1143 :               *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN508@other_stuf:

; 1137 :                  { case VERTEX: set_v_constraint_map(id,con); 

	mov	eax, DWORD PTR _con$90515[ebp]
	push	eax
	push	esi
	call	_set_v_constraint_map

; 1138 :                               project_v_constr(id,ACTUAL_MOVE,RESET_ONESIDEDNESS);

	push	1
	push	1
	push	esi
	call	_project_v_constr
	add	esp, 20					; 00000014H
$LN509@other_stuf:

; 1142 :                  }
; 1143 :               *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN505@other_stuf:

; 1144 :              }
; 1145 :            break;
; 1146 :       
; 1147 :             case SET_BOUNDARY_NODE:
; 1148 :             { struct boundary *bdry;
; 1149 :               k =  (int)*(stacktop--);  /* boundary number */

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	mov	DWORD PTR _k$[ebp], eax

; 1150 :               bdry = web.boundaries+abs(k);

	cdq
	xor	eax, edx
	sub	eax, edx
	mov	ecx, eax
	imul	ecx, 136				; 00000088H
	add	esi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], esi
	add	ecx, DWORD PTR _web+776
	mov	DWORD PTR tv9899[ebp], eax
	mov	DWORD PTR _bdry$90545[ebp], ecx

; 1151 :               if (  (abs(k) >= web.bdrymax) || !(bdry->attr&IN_USE) ) 

	cmp	eax, DWORD PTR _web+768
	jge	SHORT $LN1197@other_stuf
	mov	ecx, DWORD PTR [ecx+32]
	and	ecx, 32					; 00000020H
	xor	eax, eax
	or	ecx, eax
	jne	SHORT $LN1198@other_stuf
$LN1197@other_stuf:

; 1152 :               { sprintf(errmsg,"Boundary %d is not valid.\n",k);

	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	push	OFFSET ??_C@_0BL@HEGGOIJJ@Boundary?5?$CFd?5is?5not?5valid?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1153 :                 kb_error(3374,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3374					; 00000d2eH
	call	_kb_error
	add	esp, 24					; 00000018H
$LN1198@other_stuf:

; 1154 :               }
; 1155 :               if ( get_attr(q_id) & CONSTRAINT )

	mov	ebx, DWORD PTR _q_id$GSCopy$[ebp]
	mov	esi, ebx
	shr	esi, 29					; 0000001dH
	lea	ecx, DWORD PTR [esi*8]
	sub	ecx, esi
	shl	ecx, 4
	mov	eax, DWORD PTR _web[ecx+12]
	lea	ecx, DWORD PTR _web[ecx+12]
	and	ebx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 1024				; 00000400H
	xor	edx, edx
	or	eax, edx
	mov	DWORD PTR tv9908[ebp], esi
	mov	DWORD PTR tv9910[ebp], ecx
	je	$LN1213@other_stuf

; 1156 :               { sprintf(errmsg,"Cannot put %s %s on a boundary since it is already on a constraint.\n",
; 1157 :                 typenames[id_type(q_id)],ELNAME(q_id));

	test	DWORD PTR _q_id$GSCopy$[ebp], 268435456	; 10000000H
	je	SHORT $LN933@other_stuf
	lea	ecx, DWORD PTR [ebx+1]
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN934@other_stuf
$LN933@other_stuf:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN934@other_stuf:
	mov	edx, DWORD PTR _typenames[esi*4]
	push	eax
	push	edx
	push	OFFSET ??_C@_0EF@DIFGONKI@Cannot?5put?5?$CFs?5?$CFs?5on?5a?5boundary?5s@
	push	OFFSET _errmsg
	call	_sprintf

; 1158 :                 sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1159 :                    file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL1134@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1134@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1160 :                 kb_error(6199,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	6199					; 00001837H
	call	_kb_error
	mov	ecx, DWORD PTR tv9910[ebp]
	add	esp, 28					; 0000001cH
$LN1213@other_stuf:

; 1161 :               }
; 1162 : 
; 1163 :               if ( get_attr(q_id) & BOUNDARY )

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+ebx*4]
	mov	eax, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _web+776
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN501@other_stuf

; 1164 :               { struct boundary *qbdry;
; 1165 :                 switch ( id_type(q_id) )

	mov	eax, esi
	sub	eax, ecx
	je	SHORT $LN498@other_stuf
	dec	eax
	je	SHORT $LN497@other_stuf
	dec	eax

; 1169 :                   default:     qbdry = NULL;  /* error message below */

	jne	$LN935@other_stuf

; 1168 :                   case FACET:  qbdry = get_facet_boundary(q_id); break;

	mov	eax, DWORD PTR _F_BOUNDARY_ATTR
	test	eax, eax
	je	$LN935@other_stuf
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	ecx, DWORD PTR _web+236
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, edx
	jmp	SHORT $LN936@other_stuf
$LN497@other_stuf:

; 1167 :                   case EDGE:   qbdry = get_edge_boundary(q_id); break;

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN935@other_stuf
	mov	ecx, DWORD PTR _web+216
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	ecx, DWORD PTR _web+124
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, edx
	jmp	SHORT $LN936@other_stuf
$LN498@other_stuf:

; 1166 :                 { case VERTEX: qbdry = get_boundary(q_id); break;

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN935@other_stuf
	mov	ecx, DWORD PTR _web+104
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+64]
	mov	ecx, DWORD PTR _web+12
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, edx
	jmp	SHORT $LN936@other_stuf
$LN935@other_stuf:
	xor	eax, eax
$LN936@other_stuf:

; 1170 :                 }
; 1171 :                 if ( qbdry == bdry ) break;

	cmp	eax, DWORD PTR _bdry$90545[ebp]
	je	$LN855@other_stuf

; 1172 :                 sprintf(errmsg,"%s %s already on a different boundary.\n",
; 1173 :                    typenames[id_type(q_id)],ELNAME(q_id));

	test	DWORD PTR _q_id$GSCopy$[ebp], 268435456	; 10000000H
	je	SHORT $LN941@other_stuf
	lea	edx, DWORD PTR [ebx+1]
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN942@other_stuf
$LN941@other_stuf:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN942@other_stuf:
	push	eax
	mov	eax, DWORD PTR _typenames[esi*4]
	push	eax
	push	OFFSET ??_C@_0CI@DOCLDLLN@?$CFs?5?$CFs?5already?5on?5a?5different?5bou@
	push	OFFSET _errmsg
	call	_sprintf

; 1174 :                 sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1175 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL1135@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1135@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1176 :                 kb_error(3375,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3375					; 00000d2fH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN501@other_stuf:

; 1177 :               }
; 1178 :               set_attr(q_id,BOUNDARY);

	mov	ecx, DWORD PTR _q_id$GSCopy$[ebp]
	push	0
	push	128					; 00000080H
	push	ecx
	call	_set_attr
	add	esp, 12					; 0000000cH

; 1179 :               if ( k < 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jge	SHORT $LN493@other_stuf

; 1180 :                 set_attr(q_id,NEGBOUNDARY);

	mov	edx, DWORD PTR _q_id$GSCopy$[ebp]
	push	0
	push	256					; 00000100H
	push	edx
	call	_set_attr
	add	esp, 12					; 0000000cH
$LN493@other_stuf:

; 1181 :        
; 1182 :               switch(id_type(q_id))

	sub	esi, 0
	je	$LN490@other_stuf
	dec	esi
	je	$LN483@other_stuf
	dec	esi
	je	SHORT $LN482@other_stuf

; 1200 :                   default: 
; 1201 :                    sprintf(errmsg,"Bad element type for boundary.\n");

	push	OFFSET ??_C@_0CA@CHBGMBCP@Bad?5element?5type?5for?5boundary?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1202 :                    sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1203 :                        file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1136@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1136@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1204 :                    kb_error(3376,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3376					; 00000d30H
	call	_kb_error
	add	esp, 28					; 0000001cH
	jmp	$LN484@other_stuf
$LN482@other_stuf:

; 1197 :                   case FACET:
; 1198 :                    set_facet_boundary_num(q_id,abs(k));

	mov	eax, DWORD PTR _F_BOUNDARY_ATTR
	test	eax, eax
	je	$LN484@other_stuf
	mov	ecx, DWORD PTR _dymem
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _web+328
	mov	edx, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR _web+236
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR tv9899[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 1199 :                    break;

	jmp	$LN484@other_stuf
$LN483@other_stuf:

; 1192 :                     break;
; 1193 :                   }
; 1194 :                   case EDGE:
; 1195 :                    set_edge_boundary_num(q_id,abs(k));

	mov	eax, DWORD PTR _E_BOUNDARY_ATTR
	test	eax, eax
	je	$LN484@other_stuf
	mov	ecx, DWORD PTR _web+216
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR _web+124
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR tv9899[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 1196 :                    break;

	jmp	$LN484@other_stuf
$LN490@other_stuf:

; 1183 :                 { case VERTEX:
; 1184 :                   { REAL *x = get_coord(q_id);

	mov	ecx, DWORD PTR _web+12
	mov	esi, DWORD PTR _dymem
	mov	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+ebx*4]
	mov	eax, DWORD PTR [esi+edx+64]
	add	eax, ecx
	mov	DWORD PTR _x$90601[ebp], eax

; 1185 :                     int n;
; 1186 :                     set_boundary_num(q_id,abs(k));

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN943@other_stuf
	imul	eax, 240				; 000000f0H
	add	eax, esi
	mov	edx, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR tv9899[ebp]
	mov	DWORD PTR [ecx+edx], eax
$LN943@other_stuf:

; 1187 :                     PUSH_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	cmp	eax, 100				; 00000064H
	jl	SHORT $LN489@other_stuf
	xor	eax, eax
$LN489@other_stuf:
	mov	DWORD PTR _eval_stack_trace[eax*4], edi
	inc	eax

; 1188 :                     for ( n = 0 ; n < SDIM ; n++ )

	xor	esi, esi
	mov	DWORD PTR _eval_stack_trace_spot, eax
	cmp	DWORD PTR _web+616, esi
	jle	SHORT $LN486@other_stuf

; 1187 :                     PUSH_TRACE;

	mov	ecx, DWORD PTR _bdry$90545[ebp]
	add	ecx, 48					; 00000030H
	mov	DWORD PTR tv14491[ebp], ecx
	npad	3
$LL1231@other_stuf:

; 1189 :                      if ( bdry->coordf[n]->root != NULL )

	mov	edx, DWORD PTR tv14491[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN487@other_stuf

; 1190 :                       x[n] = eval(bdry->coordf[n],get_param(q_id),q_id,NULL);

	mov	ecx, DWORD PTR _q_id$GSCopy$[ebp]
	mov	edx, DWORD PTR _web+12
	mov	edi, DWORD PTR _web+104
	push	0
	push	ecx
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	edx, DWORD PTR _dymem
	add	ecx, DWORD PTR [edx+edi+544]
	push	ecx
	push	eax
	call	_eval
	mov	eax, DWORD PTR _x$90601[ebp]
	fstp	QWORD PTR [eax+esi*8]
	add	esp, 16					; 00000010H
$LN487@other_stuf:

; 1188 :                     for ( n = 0 ; n < SDIM ; n++ )

	add	DWORD PTR tv14491[ebp], 4
	inc	esi
	cmp	esi, DWORD PTR _web+616
	jl	SHORT $LL1231@other_stuf
	mov	eax, DWORD PTR _eval_stack_trace_spot
$LN486@other_stuf:

; 1191 :                     POP_TRACE;

	test	eax, eax
	jle	SHORT $LN484@other_stuf
	mov	DWORD PTR _eval_stack_trace[eax*4], 0
	dec	eax
	mov	DWORD PTR _eval_stack_trace_spot, eax
$LN484@other_stuf:

; 1205 :                  }
; 1206 :                 if ( bdry->attr & CON_ENERGY )

	mov	ecx, DWORD PTR _bdry$90545[ebp]
	mov	eax, DWORD PTR [ecx+32]
	and	eax, 64					; 00000040H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN480@other_stuf

; 1207 :                    apply_method_num(q_id,bdry->energy_method);

	mov	edx, DWORD PTR _bdry$90545[ebp]
	mov	eax, DWORD PTR [edx+124]
	mov	ecx, DWORD PTR _q_id$GSCopy$[ebp]
	push	eax
	push	ecx
	call	_apply_method_num
	add	esp, 8
$LN480@other_stuf:

; 1208 :                 if ( bdry->attr & CON_CONTENT )

	mov	edx, DWORD PTR _bdry$90545[ebp]
	mov	eax, DWORD PTR [edx+32]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN855@other_stuf

; 1209 :                 { if ( (web.representation == STRING) && (id_type(q_id) == VERTEX) )

	mov	eax, DWORD PTR _web+624
	cmp	eax, 1
	jne	SHORT $LN478@other_stuf
	cmp	DWORD PTR tv9908[ebp], ecx
	jne	$LN855@other_stuf

; 1210 :                     fixup_vertex_content_meths(q_id);

	mov	eax, DWORD PTR _q_id$GSCopy$[ebp]
	push	eax
	call	_fixup_vertex_content_meths
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN478@other_stuf:

; 1211 :                   else if ( (web.representation == SOAPFILM) && (id_type(q_id) == EDGE) )

	cmp	eax, 2
	jne	$LN855@other_stuf
	cmp	DWORD PTR tv9908[ebp], 1
	jne	$LN855@other_stuf

; 1212 :                     fixup_edge_content_meths(q_id);

	mov	ecx, DWORD PTR _q_id$GSCopy$[ebp]
	push	ecx
	call	_fixup_edge_content_meths
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN475@other_stuf:

; 1213 :                 }  
; 1214 :               
; 1215 :                 /* go back to next element generator */
; 1216 :                 node += node->op1.skipsize - 1;  /* back to start of loop */
; 1217 :                 break;
; 1218 :               }
; 1219 :       
; 1220 :            case SET_ORIGINAL_NODE:
; 1221 :              { int orig = (int)*(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	mov	ecx, DWORD PTR [ebx+48]
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], ecx

; 1222 :                if ( orig == 0 )

	test	eax, eax
	jne	SHORT $LN1595@other_stuf

; 1223 :                  set_original(id,NULLID);

	mov	eax, DWORD PTR tv9707[ebp]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	shl	edx, 4
	mov	eax, DWORD PTR _web[edx+12]
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+20], 0
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1595@other_stuf:

; 1224 :                else if ( orig > 0 )

	jle	SHORT $LN472@other_stuf

; 1225 :                  set_original(id,(orig-1) | ((element_id)id_type(id)<<TYPESHIFT) | 
; 1226 :                                                         VALIDMASK );

	lea	edx, DWORD PTR [eax-1]
	mov	eax, esi
	and	eax, -268435456				; f0000000H
	or	edx, eax
	mov	eax, DWORD PTR tv9707[ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 4
	mov	eax, DWORD PTR _web[ecx+12]
	or	edx, 268435456				; 10000000H
	and	esi, 134217727				; 07ffffffH
	mov	ecx, DWORD PTR [eax+esi*4]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+20], edx
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN472@other_stuf:

; 1227 :                else
; 1228 :                { sprintf(errmsg,"Cannot have negative \"original\" attribute.\n");

	push	OFFSET ??_C@_0CM@JDJHHBGC@Cannot?5have?5negative?5?$CCoriginal?$CC?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1229 :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1230 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1137@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1137@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1231 :                  kb_error(5987,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5987					; 00001763H
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN470@other_stuf:

; 1232 :                }
; 1233 :              }
; 1234 :              break;
; 1235 :    
; 1236 :            case SET_COLOR_NODE:
; 1237 :            { int color = (int)*(stacktop--);

	mov	edi, DWORD PTR [ebx+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse

; 1238 :               switch ( id_type(id) )

	mov	ecx, DWORD PTR tv9707[ebp]
	add	edi, -8					; fffffff8H
	dec	ecx
	mov	DWORD PTR [ebx+48], edi
	je	SHORT $LN467@other_stuf
	dec	ecx
	jne	SHORT $LN468@other_stuf

; 1240 :                    case FACET: set_facet_color(id,color); break;

	mov	ecx, DWORD PTR _web+236
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	edx, DWORD PTR [esi+ecx]
	mov	WORD PTR [edx+50], ax
	mov	ecx, DWORD PTR _web+236
	mov	edx, DWORD PTR [esi+ecx]
	pop	edi
	mov	WORD PTR [edx+48], ax

; 1241 :                  }
; 1242 :               *update_display_flag = 1;

	mov	eax, DWORD PTR _update_display_flag$GSCopy$[ebp]
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN467@other_stuf:

; 1239 :                  { case EDGE: set_edge_color(id,color); break;

	mov	ecx, DWORD PTR _web+124
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	WORD PTR [edx+56], ax
$LN468@other_stuf:

; 1241 :                  }
; 1242 :               *update_display_flag = 1;

	mov	eax, DWORD PTR _update_display_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN465@other_stuf:

; 1243 :              }
; 1244 :            break;
; 1245 :    
; 1246 :            case SET_FRONTCOLOR_NODE:
; 1247 :            { int color = (int)*(stacktop--);

	mov	edi, DWORD PTR [ebx+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	add	edi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], edi

; 1248 :               set_facet_frontcolor(id,color);

	mov	ecx, DWORD PTR _web+236
	test	esi, 134217728				; 08000000H
	je	SHORT $LN949@other_stuf
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	pop	edi
	mov	WORD PTR [edx+50], ax

; 1249 :               *update_display_flag = 1;

	mov	eax, DWORD PTR _update_display_flag$GSCopy$[ebp]
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN949@other_stuf:

; 1248 :               set_facet_frontcolor(id,color);

	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	pop	edi
	mov	WORD PTR [edx+48], ax

; 1249 :               *update_display_flag = 1;

	mov	eax, DWORD PTR _update_display_flag$GSCopy$[ebp]
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN464@other_stuf:

; 1250 :              }
; 1251 :              break;
; 1252 :    
; 1253 :           case SET_BACKCOLOR_NODE:
; 1254 :            { int color = (int)*(stacktop--);

	mov	edi, DWORD PTR [ebx+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	add	edi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], edi

; 1255 :               set_facet_backcolor(id,color);

	mov	ecx, DWORD PTR _web+236
	test	esi, 134217728				; 08000000H
	je	SHORT $LN951@other_stuf
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	pop	edi
	mov	WORD PTR [edx+48], ax

; 1256 :               *update_display_flag = 1;

	mov	eax, DWORD PTR _update_display_flag$GSCopy$[ebp]
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN951@other_stuf:

; 1255 :               set_facet_backcolor(id,color);

	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	pop	edi
	mov	WORD PTR [edx+50], ax

; 1256 :               *update_display_flag = 1;

	mov	eax, DWORD PTR _update_display_flag$GSCopy$[ebp]
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN463@other_stuf:

; 1257 :              }
; 1258 :              break;
; 1259 :    
; 1260 :      case SET_WRAP_NODE:
; 1261 :            { int w = (int)*(stacktop--);

	mov	edi, DWORD PTR [ebx+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	add	edi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], edi

; 1262 :              if ( web.symmetry_flag )

	cmp	DWORD PTR _web+856, 0
	je	$LN855@other_stuf

; 1263 :              { set_edge_wrap(id,w);

	push	eax
	push	esi
	call	_set_edge_wrap

; 1264 :                *update_display_flag = 1;

	mov	ecx, DWORD PTR _update_display_flag$GSCopy$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN461@other_stuf:

; 1265 :              }
; 1266 :            }
; 1267 :            break;
; 1268 :    
; 1269 :           case SET_ORIENTATION_NODE:
; 1270 :            { int orient = (int)*(stacktop--);

	mov	edi, DWORD PTR [ebx+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse

; 1271 :              if ( orient < 0 ) 
; 1272 :                set_attr(id,NEGBOUNDARY);

	push	0
	add	edi, -8					; fffffff8H
	push	256					; 00000100H
	mov	DWORD PTR [ebx+48], edi
	push	esi
	test	eax, eax
	jns	$LN460@other_stuf
	jmp	$LN1603@other_stuf
$LN458@other_stuf:

; 1273 :              else unset_attr(id,NEGBOUNDARY);
; 1274 :            }
; 1275 :            break; 
; 1276 :    
; 1277 :           case SET_COORD_NODE: case SET_COORD_1_NODE: 
; 1278 :              if ( node->right ) /* indexed */

	cmp	DWORD PTR [edi+8], 0
	je	$LN457@other_stuf

; 1279 :              { int dim = (int)*(stacktop--)-1;

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	mov	ecx, DWORD PTR [ebx+48]
	add	ecx, -8					; fffffff8H
	dec	eax
	mov	DWORD PTR [ebx+48], ecx

; 1280 :                if ( (dim >= SDIM) || (dim < 0) )

	mov	ecx, DWORD PTR _web+616
	mov	DWORD PTR _dim$90701[ebp], eax
	cmp	eax, ecx
	jge	SHORT $LN455@other_stuf
	test	eax, eax
	jge	SHORT $LN456@other_stuf
$LN455@other_stuf:

; 1281 :                    { sprintf(errmsg,
; 1282 :                       "Trying to set coordinate %d, in space dimension %d.\n",
; 1283 :                            dim+1,SDIM);

	push	ecx
	mov	edx, eax
	inc	edx
	push	edx
	push	OFFSET ??_C@_0DF@OFFNPKIE@Trying?5to?5set?5coordinate?5?$CFd?0?5in?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1284 :                      sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1285 :                           file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL1138@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1138@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1286 :                      kb_error(2026,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2026					; 000007eaH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN456@other_stuf:

; 1287 :                    }
; 1288 :                  get_coord(id)[dim] = *(stacktop--);

	mov	edx, DWORD PTR _web+12
	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	mov	ecx, DWORD PTR _dim$90701[ebp]
	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edx+esi*4]
	mov	edx, DWORD PTR _web+104
	mov	esi, DWORD PTR _dymem
	add	eax, DWORD PTR [esi+edx+64]
	add	DWORD PTR [ebx+48], -8			; fffffff8H

; 1289 :                  *recalc_flag = 1;

	mov	edx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	fstp	QWORD PTR [eax+ecx*8]
	pop	edi
	pop	esi
	mov	DWORD PTR [edx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN457@other_stuf:

; 1290 :                  break;
; 1291 :               }
; 1292 :               /* else fall through */
; 1293 :    
; 1294 :             case SET_COORD_2_NODE:
; 1295 :             case SET_COORD_3_NODE: case SET_COORD_4_NODE: case SET_COORD_5_NODE:
; 1296 :             case SET_COORD_6_NODE: case SET_COORD_7_NODE: case SET_COORD_8_NODE:
; 1297 :               get_coord(id)[node->op2.attr_kind-SET_COORD_1_NODE] = *(stacktop--);

	mov	edx, DWORD PTR _web+12
	mov	edi, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edx+esi*4]
	mov	esi, DWORD PTR _web+104
	add	edx, DWORD PTR [edi+esi+64]
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	pop	edi
	fstp	QWORD PTR [edx+eax*8-82520]

; 1298 :               *recalc_flag = 1;

	mov	eax, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN453@other_stuf:

; 1299 :               break;
; 1300 :    
; 1301 :             case SET_PARAM_NODE: case SET_PARAM_1_NODE: case SET_PARAM_2_NODE:
; 1302 :             case SET_PARAM_3_NODE: case SET_PARAM_4_NODE: case SET_PARAM_5_NODE:
; 1303 :             case SET_PARAM_6_NODE: case SET_PARAM_7_NODE: case SET_PARAM_8_NODE:
; 1304 :               { int pnum;
; 1305 :                 if ( node->right ) pnum = (int)*(stacktop--);

	cmp	DWORD PTR [edi+8], 0
	je	SHORT $LN452@other_stuf
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	mov	DWORD PTR _pnum$90716[ebp], eax
	mov	eax, DWORD PTR [ebx+48]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	jmp	SHORT $LN451@other_stuf
$LN452@other_stuf:

; 1306 :                 else pnum = node->op2.attr_kind-SET_PARAM_1_NODE; 

	add	eax, -10326				; ffffd7aaH
	mov	DWORD PTR _pnum$90716[ebp], eax
$LN451@other_stuf:

; 1307 :                 
; 1308 :                 if ( get_vattr(id) & BOUNDARY )

	mov	edx, DWORD PTR _web+12
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv10053[ebp], eax
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	$LN450@other_stuf

; 1309 :                 { struct boundary *boundary = get_boundary(id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	test	eax, eax
	je	SHORT $LN953@other_stuf
	mov	edx, DWORD PTR _web+104
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+64]
	mov	eax, DWORD PTR [eax+ecx]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	jmp	SHORT $LN1596@other_stuf
$LN953@other_stuf:
	xor	eax, eax
$LN1596@other_stuf:

; 1310 :                   REAL *param = get_param(id);

	mov	ecx, DWORD PTR tv10053[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _dymem
	mov	DWORD PTR tv10077[ebp], edx
	mov	edx, DWORD PTR _web+104
	mov	ecx, DWORD PTR [ecx+edx+544]
	add	ecx, DWORD PTR tv10077[ebp]
	mov	DWORD PTR _boundary$90723[ebp], eax

; 1311 :                   REAL *xx = get_coord(id);
; 1312 :                   
; 1313 :                   if ( pnum > boundary->pcount )

	mov	eax, DWORD PTR [eax+40]
	mov	DWORD PTR _param$90729[ebp], ecx
	mov	ecx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [ecx+edx+64]
	add	ecx, DWORD PTR tv10077[ebp]
	mov	DWORD PTR _xx$90734[ebp], ecx
	cmp	DWORD PTR _pnum$90716[ebp], eax
	jle	SHORT $LN1211@other_stuf

; 1314 :                   { sprintf(errmsg,"Parameter number is %d; maximum is %d.\n",
; 1315 :                          pnum,boundary->pcount);

	push	eax
	mov	eax, DWORD PTR _pnum$90716[ebp]
	push	eax
	push	OFFSET ??_C@_0CI@EMPMINAB@Parameter?5number?5is?5?$CFd?$DL?5maximum?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1316 :                     sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1317 :                          file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL1139@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1139@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1318 :                     kb_error(1149,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1149					; 0000047dH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1211@other_stuf:

; 1319 :                   }
; 1320 :                   param[pnum] = *(stacktop--);

	mov	ecx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR _pnum$90716[ebp]
	fld	QWORD PTR [ecx]
	mov	edx, DWORD PTR _param$90729[ebp]
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	fstp	QWORD PTR [edx+eax*8]

; 1321 :                   PUSH_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	cmp	eax, 100				; 00000064H
	jl	SHORT $LN1232@other_stuf
	xor	eax, eax
$LN1232@other_stuf:
	mov	DWORD PTR _eval_stack_trace[eax*4], edi
	inc	eax

; 1322 :                   for ( k = 0 ; k < SDIM ; k++ )

	xor	edi, edi
	mov	DWORD PTR _eval_stack_trace_spot, eax
	cmp	DWORD PTR _web+616, edi
	jle	SHORT $LN445@other_stuf

; 1321 :                   PUSH_TRACE;

	mov	ebx, DWORD PTR _boundary$90723[ebp]
	add	ebx, 48					; 00000030H
	npad	3
$LL447@other_stuf:

; 1323 :                      xx[k] = eval(boundary->coordf[k],param,id,NULL);

	mov	ecx, DWORD PTR _param$90729[ebp]
	mov	edx, DWORD PTR [ebx]
	push	0
	push	esi
	push	ecx
	push	edx
	call	_eval
	mov	eax, DWORD PTR _xx$90734[ebp]
	fstp	QWORD PTR [eax+edi*8]
	inc	edi
	add	esp, 16					; 00000010H
	add	ebx, 4
	cmp	edi, DWORD PTR _web+616
	jl	SHORT $LL447@other_stuf
$LN1616@other_stuf:

; 1322 :                   for ( k = 0 ; k < SDIM ; k++ )

	mov	eax, DWORD PTR _eval_stack_trace_spot
$LN445@other_stuf:

; 1324 :                   POP_TRACE;

	test	eax, eax
	jle	SHORT $LN1199@other_stuf
	mov	DWORD PTR _eval_stack_trace[eax*4], 0
	dec	eax
	mov	DWORD PTR _eval_stack_trace_spot, eax
$LN1199@other_stuf:

; 1325 :                   *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN450@other_stuf:

; 1326 :                }
; 1327 :                else /* just parking a value probably */ 
; 1328 :                { REAL *param = get_param(id);

	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	esi, DWORD PTR [eax+edx+544]
	add	esi, ecx

; 1329 :                  if ( pnum > web.maxparam )

	mov	ecx, DWORD PTR _pnum$90716[ebp]
	cmp	ecx, DWORD PTR _web+640
	jle	SHORT $LN442@other_stuf

; 1330 :                  { sprintf(errmsg,"Parameter index too high.\n");

	push	OFFSET ??_C@_0BL@HILFJHDF@Parameter?5index?5too?5high?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1331 :                    sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1332 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1140@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1140@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1333 :                    kb_error(6531,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	6531					; 00001983H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN442@other_stuf:

; 1334 :                  }
; 1335 :                  param[pnum] = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	mov	ecx, DWORD PTR _pnum$90716[ebp]
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	fstp	QWORD PTR [esi+ecx*8]
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN441@other_stuf:

; 1336 :                }
; 1337 :               }
; 1338 :               break;
; 1339 :    
; 1340 :              case SET_FRONTBODY_NODE:
; 1341 :              case SET_BACKBODY_NODE:
; 1342 :                b_id = get_ordinal_id(BODY,(int)*(stacktop--)-1);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	mov	ecx, DWORD PTR [ebx+48]
	dec	eax
	push	eax
	add	ecx, -8					; fffffff8H
	push	3
	mov	DWORD PTR [ebx+48], ecx
	call	_get_ordinal_id
	mov	ebx, eax
	add	esp, 8

; 1343 :                if ( b_id && !valid_id(b_id) ) 

	test	ebx, ebx
	je	SHORT $LN1200@other_stuf
	test	ebx, 268435456				; 10000000H
	jne	SHORT $LN1200@other_stuf

; 1344 :                { sprintf(errmsg,"Invalid body in SET FRONTBODY or BACKBODY.\n");

	push	OFFSET ??_C@_0CM@OKNEOKD@Invalid?5body?5in?5SET?5FRONTBODY?5or@
	push	OFFSET _errmsg
	call	_sprintf

; 1345 :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1346 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1141@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1141@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1347 :                  kb_error(2027,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2027					; 000007ebH
$LN1631@other_stuf:
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1200@other_stuf:

; 1348 :                }
; 1349 :                set_body((node->op2.attr_kind==SET_FRONTBODY_NODE?id:inverse_id(id)),b_id);

	cmp	DWORD PTR [edi+136], 10335		; 0000285fH
	je	SHORT $LN956@other_stuf
	xor	esi, 134217728				; 08000000H
$LN956@other_stuf:
	push	ebx
	push	esi
	call	_set_body

; 1350 :                *recalc_flag = 1;

	mov	eax, DWORD PTR _recalc_flag$GSCopy$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN439@other_stuf:

; 1351 :                break;
; 1352 :     
; 1353 :             default: 
; 1354 :                sprintf(errmsg,"Unhandled SET attribute %d\n",node->op2.attr_kind);

	push	eax
	push	OFFSET ??_C@_0BM@NMEKOFHC@Unhandled?5SET?5attribute?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1355 :                sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1356 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1142@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1142@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1357 :                kb_error(2028,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2028					; 000007ecH
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN438@other_stuf:

; 1358 :                break;
; 1359 :    
; 1360 :          } /* end SET_ATTRIBUTE */
; 1361 :          break;
; 1362 : 
; 1363 :     /*****************************
; 1364 :     * assignop attribute values  *
; 1365 :     * for single element assigns *
; 1366 :     *****************************/
; 1367 :     case SET_ATTRIBUTE_A_NODE: 
; 1368 :       { int assign_type = node[1].op1.assigntype;
; 1369 :         if ( node->op1.localnum ) 

	mov	eax, DWORD PTR [edi+32]
	mov	ecx, DWORD PTR [edi+200]
	mov	DWORD PTR _assign_type$90764[ebp], ecx
	test	eax, eax
	je	SHORT $LN436@other_stuf

; 1370 :           id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _localstack$GSCopy$[ebp]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	mov	esi, DWORD PTR [eax+edx*8]
$LN436@other_stuf:

; 1371 :         else id = q_id;
; 1372 :         parallel_update_flag[id_type(id)] = 1; /* set when element info changed */

	mov	ecx, esi
	shr	ecx, 29					; 0000001dH
	mov	DWORD PTR _parallel_update_flag[ecx*4], 1

; 1373 :         switch ( node->op2.attr_kind )

	mov	edx, DWORD PTR [edi+136]
	lea	eax, DWORD PTR [edx-10301]
	mov	DWORD PTR tv9707[ebp], ecx
	cmp	eax, 151				; 00000097H
	ja	$LN207@other_stuf
	movzx	eax, BYTE PTR $LN1143@other_stuf[eax]
	jmp	DWORD PTR $LN1645@other_stuf[eax*4]
$LN433@other_stuf:

; 1374 :         {  /* Those attributes not fitted for arithmetic assignment 
; 1375 :               have error test for that in yexparse() */
; 1376 :    
; 1377 :            case SET_ORIENTATION_NODE:
; 1378 :              if ( *(stacktop--) >= 0.0 )

	mov	ecx, DWORD PTR [ebx+48]
	fldz
	fcomp	QWORD PTR [ecx]

; 1379 :                  unset_attr(id,NEGBOUNDARY);

	push	0
	add	ecx, -8					; fffffff8H
	push	256					; 00000100H
	mov	DWORD PTR [ebx+48], ecx
	push	esi
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	$LN1603@other_stuf
	jmp	$LN460@other_stuf
$LN430@other_stuf:

; 1380 :              else  set_attr(id,NEGBOUNDARY);
; 1381 :              break;
; 1382 :    
; 1383 :            case SET_EXTRA_ATTR_NODE:
; 1384 :            { struct extra *ext;
; 1385 :              int spot; /* index */
; 1386 :              n = node->op3.extra_info & ((1<<ESHIFT)-1);

	mov	ecx, DWORD PTR [edi+140]

; 1387 :              if ( node->op1.localnum ) 

	mov	eax, DWORD PTR [edi+32]
	and	ecx, 4095				; 00000fffH
	xor	esi, esi
	mov	DWORD PTR _n$[ebp], ecx
	cmp	eax, esi
	je	SHORT $LN429@other_stuf

; 1388 :                id = *(element_id*)get_localp(node->op1.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+eax+216]
	mov	eax, DWORD PTR _localstack$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax+edx*8]
	jmp	SHORT $LN1597@other_stuf
$LN429@other_stuf:

; 1389 :              else id = q_id;

	mov	eax, DWORD PTR _q_id$GSCopy$[ebp]
$LN1597@other_stuf:
	mov	DWORD PTR _id$[ebp], eax

; 1390 :              ext = EXTRAS(id_type(id)) + n;

	imul	ecx, 240				; 000000f0H
	shr	eax, 29					; 0000001dH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	shl	edx, 4
	mov	eax, DWORD PTR _web[edx+104]
	add	eax, ecx
	add	eax, DWORD PTR _dymem

; 1391 :               /* get index */
; 1392 :               spot = 0;
; 1393 :               for ( k = 0 ; k < ext->array_spec.dim ; k++ )

	mov	DWORD PTR _k$[ebp], esi
	mov	DWORD PTR _ext$90779[ebp], eax
	cmp	DWORD PTR [eax+76], esi
	jle	$LN425@other_stuf

; 1390 :              ext = EXTRAS(id_type(id)) + n;

	add	eax, 96					; 00000060H
	mov	DWORD PTR tv14588[ebp], eax
$LL427@other_stuf:

; 1394 :               { int j = (int)(stacktop[-ext->array_spec.dim+k+1]);

	mov	edx, DWORD PTR _ext$90779[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, DWORD PTR [edx+76]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax+ecx*8+8]
	call	__ftol2_sse

; 1395 :                 spot *= ext->array_spec.sizes[k];

	mov	ecx, DWORD PTR tv14588[ebp]
	mov	ecx, DWORD PTR [ecx]
	imul	esi, ecx
	mov	DWORD PTR _j$90789[ebp], eax
	mov	DWORD PTR _spot$90780[ebp], esi

; 1396 :                 if ( j > ext->array_spec.sizes[k] )

	cmp	eax, ecx
	jle	SHORT $LN1180@other_stuf

; 1397 :                 { sprintf(errmsg,
; 1398 :                      "Attribute %s index %d is %d; maximum is %d (in %s).\n",
; 1399 :                      ext->name,k+1,j,ext->array_spec.sizes[k],ext->name);

	mov	eax, DWORD PTR _ext$90779[ebp]
	mov	edx, DWORD PTR tv14588[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _j$90789[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _k$[ebp]
	push	edx
	inc	ecx
	push	ecx
	push	eax
	push	OFFSET ??_C@_0DF@MPPJKLHD@Attribute?5?$CFs?5index?5?$CFd?5is?5?$CFd?$DL?5max@
	push	OFFSET _errmsg
	call	_sprintf

; 1400 :                   sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1401 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 28					; 0000001cH
	lea	esi, DWORD PTR [eax+1]
$LL1144@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1144@other_stuf
	mov	edx, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi+16]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	sub	eax, esi
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1402 :                   kb_error(2524,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2524					; 000009dcH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1180@other_stuf:

; 1403 :                 }
; 1404 :                 if ( j < 1 )

	mov	eax, DWORD PTR _j$90789[ebp]
	cmp	eax, 1
	jge	SHORT $LN423@other_stuf

; 1405 :                 { sprintf(errmsg,"Attribute %s index %d is %d; must be positive.\n",
; 1406 :                         ext->name,k,j); 

	mov	ecx, DWORD PTR _ext$90779[ebp]
	push	eax
	mov	eax, DWORD PTR _k$[ebp]
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DA@FHCLKLI@Attribute?5?$CFs?5index?5?$CFd?5is?5?$CFd?$DL?5mus@
	push	OFFSET _errmsg
	call	_sprintf

; 1407 :                   sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1408 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR [eax+1]
$LL1145@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1145@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1409 :                   kb_error(3365,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3365					; 00000d25H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN423@other_stuf:

; 1410 :                 }
; 1411 :                 spot += (int)(stacktop[-ext->array_spec.dim+k+1]) - 1;

	mov	eax, DWORD PTR _ext$90779[ebp]
	mov	eax, DWORD PTR [eax+76]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR [ebx+48]
	sub	ecx, eax
	fld	QWORD PTR [edx+ecx*8+8]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _spot$90780[ebp]
	mov	edx, DWORD PTR _ext$90779[ebp]
	add	DWORD PTR tv14588[ebp], 4
	lea	esi, DWORD PTR [ecx+eax-1]
	mov	eax, DWORD PTR _k$[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR [edx+76]
	jl	$LL427@other_stuf
$LN425@other_stuf:

; 1412 :               }
; 1413 :               stacktop -= ext->array_spec.dim;

	mov	eax, DWORD PTR _ext$90779[ebp]
	mov	ecx, DWORD PTR [eax+76]
	neg	ecx
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [ebx+48], ecx

; 1414 :    
; 1415 :    #define ATTRCASE(type) \
; 1416 :             switch ( assign_type ) \
; 1417 :             { case ASSIGN_OP: \
; 1418 :                 ((type*)get_extra(id,n))[spot] = (type)*(stacktop--); break; \
; 1419 :               case PLUSASSIGN_OP: \
; 1420 :                 ((type*)get_extra(id,n))[spot] += (type)*(stacktop--); break; \
; 1421 :               case SUBASSIGN_OP: \
; 1422 :                 ((type*)get_extra(id,n))[spot] -= (type)*(stacktop--); break; \
; 1423 :               case MULTASSIGN_OP: \
; 1424 :                 ((type*)get_extra(id,n))[spot] *= (type)*(stacktop--); break; \
; 1425 :               case DIVASSIGN_OP: \
; 1426 :                 ((type*)get_extra(id,n))[spot] /= (type)*(stacktop--); break; \
; 1427 :             } 
; 1428 :    
; 1429 :              switch ( ext->type )

	mov	eax, DWORD PTR [eax+68]
	dec	eax
	cmp	eax, 22					; 00000016H
	ja	$LN855@other_stuf
	movzx	edx, BYTE PTR $LN1146@other_stuf[eax]
	jmp	DWORD PTR $LN1646@other_stuf[edx*4]
$LN420@other_stuf:

; 1430 :              { case REAL_TYPE:  
; 1431 :                    switch ( assign_type )

	mov	eax, DWORD PTR _assign_type$90764[ebp]
	add	eax, -30001				; ffff8acfH
	cmp	eax, 4
	ja	$LN855@other_stuf
	jmp	DWORD PTR $LN1647@other_stuf[eax*4]
$LN417@other_stuf:

; 1432 :                    { case ASSIGN_OP:
; 1433 :                        ((REAL*)get_extra(id,n))[spot] = *(stacktop--); break;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	push	eax
	push	ecx
	call	_get_extra
	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	fstp	QWORD PTR [eax+esi*8]
	jmp	$LN1623@other_stuf
$LN416@other_stuf:

; 1434 :                       case PLUSASSIGN_OP:
; 1435 :                        ((REAL*)get_extra(id,n))[spot] += *(stacktop--); break;

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _id$[ebp]
	push	edx
	push	eax
	call	_get_extra
	lea	esi, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	jmp	$LN1623@other_stuf
$LN415@other_stuf:

; 1436 :                       case SUBASSIGN_OP:
; 1437 :                        ((REAL*)get_extra(id,n))[spot] -= *(stacktop--); break;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	fld	QWORD PTR [eax+esi*8]
	lea	esi, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR [ebx+48]
	fsub	QWORD PTR [eax]
	fstp	QWORD PTR [esi]
	jmp	$LN1623@other_stuf
$LN414@other_stuf:

; 1438 :                       case MULTASSIGN_OP:
; 1439 :                        ((REAL*)get_extra(id,n))[spot] *= *(stacktop--); break;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	push	eax
	push	ecx
	call	_get_extra
	lea	esi, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	fmul	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	jmp	$LN1623@other_stuf
$LN413@other_stuf:

; 1440 :                       case DIVASSIGN_OP:
; 1441 :                        ((REAL*)get_extra(id,n))[spot] /= *(stacktop--); break;

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _id$[ebp]
	push	edx
	push	eax
	call	_get_extra
	fld	QWORD PTR [eax+esi*8]
	lea	esi, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR [ebx+48]
	fdiv	QWORD PTR [eax]
	fstp	QWORD PTR [esi]

; 1442 :                    }
; 1443 :                    break;

	jmp	$LN1623@other_stuf
$LN412@other_stuf:

; 1444 :                  case INTEGER_TYPE:
; 1445 :                    switch ( assign_type )

	mov	eax, DWORD PTR _assign_type$90764[ebp]
	add	eax, -30001				; ffff8acfH
	cmp	eax, 4
	ja	$LN855@other_stuf
	jmp	DWORD PTR $LN1648@other_stuf[eax*4]
$LN409@other_stuf:

; 1446 :                    { case ASSIGN_OP:
; 1447 :                        ((int*)get_extra(id,n))[spot] = (int)*(stacktop--); break;

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	mov	edi, eax
	push	edx
	jmp	$LN1614@other_stuf
$LN408@other_stuf:

; 1448 :                       case PLUSASSIGN_OP:
; 1449 :                        ((int*)get_extra(id,n))[spot] += (int)*(stacktop--); break;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	push	eax
	push	ecx
$LN1619@other_stuf:
	call	_get_extra
	lea	esi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	esp, 8
	call	__ftol2_sse
	add	DWORD PTR [esi], eax
	jmp	$LN1613@other_stuf
$LN407@other_stuf:

; 1450 :                       case SUBASSIGN_OP:
; 1451 :                        ((int*)get_extra(id,n))[spot] -= (int)*(stacktop--); break;

	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _id$[ebp]
	push	edx
	push	eax
$LN1621@other_stuf:
	call	_get_extra
	lea	esi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	esp, 8
	call	__ftol2_sse
	sub	DWORD PTR [esi], eax
	jmp	$LN1613@other_stuf
$LN406@other_stuf:

; 1452 :                       case MULTASSIGN_OP:
; 1453 :                        ((int*)get_extra(id,n))[spot] = 
; 1454 :                           (int)(((int*)get_extra(id,n))[spot] * *(stacktop--));break;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	edi, DWORD PTR _id$[ebp]
	push	ecx
	push	edi
	call	_get_extra
	fild	DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	fmul	QWORD PTR [eax]
	call	__ftol2_sse
	mov	edx, DWORD PTR _n$[ebp]
	push	edx
	push	edi
	mov	DWORD PTR tv9743[ebp], eax
	call	_get_extra
	mov	ecx, DWORD PTR tv9743[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [eax+esi*4], ecx
	jmp	$LN1613@other_stuf
$LN405@other_stuf:

; 1455 :                       case DIVASSIGN_OP:
; 1456 :                        ((int*)get_extra(id,n))[spot] = 
; 1457 :                           (int)(((int*)get_extra(id,n))[spot] / *(stacktop--));break;

	mov	eax, DWORD PTR _n$[ebp]
	mov	edi, DWORD PTR _id$[ebp]
	push	eax
	push	edi
	call	_get_extra
	fild	DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	fdiv	QWORD PTR [eax]
	call	__ftol2_sse
	mov	ecx, DWORD PTR _n$[ebp]
	push	ecx
	push	edi
	mov	DWORD PTR tv9741[ebp], eax
	call	_get_extra
	mov	ecx, DWORD PTR tv9741[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [eax+esi*4], ecx

; 1458 :                    }
; 1459 :                    break;

	jmp	$LN1613@other_stuf
$LN404@other_stuf:

; 1460 :    
; 1461 :                  case ULONG_TYPE:
; 1462 :                    ATTRCASE(unsigned long int);

	mov	eax, DWORD PTR _assign_type$90764[ebp]
	add	eax, -30001				; ffff8acfH
	cmp	eax, 4
	ja	$LN855@other_stuf
	jmp	DWORD PTR $LN1649@other_stuf[eax*4]
$LN401@other_stuf:
	mov	eax, DWORD PTR [ebx+48]
	fnstcw	WORD PTR tv11717[ebp]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11717[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11714[ebp], eax
	fldcw	WORD PTR tv11714[ebp]
	fistp	QWORD PTR tv11712[ebp]
	mov	edi, DWORD PTR tv11712[ebp]
	fldcw	WORD PTR tv11717[ebp]
	jmp	$LN1612@other_stuf
$LN400@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	fnstcw	WORD PTR tv11706[ebp]
	lea	esi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11706[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11703[ebp], eax
	add	esp, 8
	fldcw	WORD PTR tv11703[ebp]
	fistp	QWORD PTR tv11701[ebp]
	mov	eax, DWORD PTR tv11701[ebp]
	add	DWORD PTR [esi], eax
	fldcw	WORD PTR tv11706[ebp]
	jmp	$LN1613@other_stuf
$LN399@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	fnstcw	WORD PTR tv11696[ebp]
	lea	esi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11696[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11693[ebp], eax
	add	esp, 8
	fldcw	WORD PTR tv11693[ebp]
	fistp	QWORD PTR tv11691[ebp]
	mov	eax, DWORD PTR tv11691[ebp]
	sub	DWORD PTR [esi], eax
	fldcw	WORD PTR tv11696[ebp]
	jmp	$LN1613@other_stuf
$LN398@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	fnstcw	WORD PTR tv11686[ebp]
	lea	esi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11686[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11683[ebp], eax
	add	esp, 8
	fldcw	WORD PTR tv11683[ebp]
	fistp	QWORD PTR tv11681[ebp]
	mov	eax, DWORD PTR tv11681[ebp]
	imul	eax, DWORD PTR [esi]
	fldcw	WORD PTR tv11686[ebp]
	mov	DWORD PTR [esi], eax
	jmp	$LN1613@other_stuf
$LN397@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	fnstcw	WORD PTR tv11676[ebp]
	lea	esi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11676[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11673[ebp], eax
	mov	eax, DWORD PTR [esi]
	xor	edx, edx
	fldcw	WORD PTR tv11673[ebp]
	add	esp, 8
	fistp	QWORD PTR tv11671[ebp]
	mov	ecx, DWORD PTR tv11671[ebp]
	div	ecx
	fldcw	WORD PTR tv11676[ebp]
	mov	DWORD PTR [esi], eax

; 1463 :                    break;

	jmp	$LN1613@other_stuf
$LN396@other_stuf:

; 1464 :    
; 1465 :                  case LONG_TYPE:
; 1466 :                    ATTRCASE(long int);

	mov	eax, DWORD PTR _assign_type$90764[ebp]
	add	eax, -30001				; ffff8acfH
	cmp	eax, 4
	ja	$LN855@other_stuf
	jmp	DWORD PTR $LN1650@other_stuf[eax*4]
$LN393@other_stuf:
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	jmp	$LN1615@other_stuf
$LN392@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	jmp	$LN1619@other_stuf
$LN391@other_stuf:
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	push	eax
	push	ecx
	jmp	$LN1621@other_stuf
$LN390@other_stuf:
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _id$[ebp]
	push	edx
	push	eax
	call	_get_extra
	lea	esi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	esp, 8
	call	__ftol2_sse
	imul	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi], eax
	jmp	$LN1613@other_stuf
$LN389@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	lea	esi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, eax
	mov	eax, DWORD PTR [esi]
	cdq
	idiv	ecx
	mov	DWORD PTR [esi], eax

; 1467 :                    break;

	jmp	$LN1613@other_stuf
$LN388@other_stuf:

; 1468 :    
; 1469 :                  case UINT_TYPE:
; 1470 :                    ATTRCASE(unsigned int);

	mov	eax, DWORD PTR _assign_type$90764[ebp]
	add	eax, -30001				; ffff8acfH
	cmp	eax, 4
	ja	$LN855@other_stuf
	jmp	DWORD PTR $LN1651@other_stuf[eax*4]
$LN385@other_stuf:
	mov	eax, DWORD PTR [ebx+48]
	fnstcw	WORD PTR tv11630[ebp]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11630[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11627[ebp], eax
	fldcw	WORD PTR tv11627[ebp]
	fistp	QWORD PTR tv11625[ebp]
	mov	edi, DWORD PTR tv11625[ebp]
	fldcw	WORD PTR tv11630[ebp]
	jmp	$LN1612@other_stuf
$LN384@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	fnstcw	WORD PTR tv11619[ebp]
	lea	esi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11619[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11616[ebp], eax
	add	esp, 8
	fldcw	WORD PTR tv11616[ebp]
	fistp	QWORD PTR tv11614[ebp]
	mov	eax, DWORD PTR tv11614[ebp]
	add	DWORD PTR [esi], eax
	fldcw	WORD PTR tv11619[ebp]
	jmp	$LN1613@other_stuf
$LN383@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	fnstcw	WORD PTR tv11609[ebp]
	lea	esi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11609[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11606[ebp], eax
	add	esp, 8
	fldcw	WORD PTR tv11606[ebp]
	fistp	QWORD PTR tv11604[ebp]
	mov	eax, DWORD PTR tv11604[ebp]
	sub	DWORD PTR [esi], eax
	fldcw	WORD PTR tv11609[ebp]
	jmp	$LN1613@other_stuf
$LN382@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	fnstcw	WORD PTR tv11599[ebp]
	lea	esi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11599[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11596[ebp], eax
	add	esp, 8
	fldcw	WORD PTR tv11596[ebp]
	fistp	QWORD PTR tv11594[ebp]
	mov	eax, DWORD PTR tv11594[ebp]
	imul	eax, DWORD PTR [esi]
	fldcw	WORD PTR tv11599[ebp]
	mov	DWORD PTR [esi], eax
	jmp	$LN1613@other_stuf
$LN381@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	fnstcw	WORD PTR tv11589[ebp]
	lea	esi, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11589[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11586[ebp], eax
	mov	eax, DWORD PTR [esi]
	xor	edx, edx
	fldcw	WORD PTR tv11586[ebp]
	add	esp, 8
	fistp	QWORD PTR tv11584[ebp]
	mov	ecx, DWORD PTR tv11584[ebp]
	div	ecx
	fldcw	WORD PTR tv11589[ebp]
	mov	DWORD PTR [esi], eax

; 1471 :                    break;

	jmp	$LN1613@other_stuf
$LN380@other_stuf:

; 1472 :    
; 1473 :                  case UCHAR_TYPE:
; 1474 :                    ATTRCASE(unsigned char);

	mov	eax, DWORD PTR _assign_type$90764[ebp]
	add	eax, -30001				; ffff8acfH
	cmp	eax, 4
	ja	$LN855@other_stuf
	jmp	DWORD PTR $LN1652@other_stuf[eax*4]
$LN377@other_stuf:
	mov	eax, DWORD PTR [ebx+48]
	fnstcw	WORD PTR tv11577[ebp]
	fld	QWORD PTR [eax]
	mov	edx, DWORD PTR _n$[ebp]
	movzx	eax, WORD PTR tv11577[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11574[ebp], eax
	push	edx
	push	ecx
	fldcw	WORD PTR tv11574[ebp]
	fistp	DWORD PTR tv11572[ebp]
	mov	al, BYTE PTR tv11572[ebp]
	fldcw	WORD PTR tv11577[ebp]
	mov	BYTE PTR tv9739[ebp], al
	call	_get_extra
	mov	cl, BYTE PTR tv9739[ebp]
	mov	BYTE PTR [eax+esi], cl
	jmp	$LN1623@other_stuf
$LN376@other_stuf:
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _id$[ebp]
	push	edx
	push	eax
	call	_get_extra
	fnstcw	WORD PTR tv11566[ebp]
	add	esi, eax
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11566[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11563[ebp], eax
	add	esp, 8
	fldcw	WORD PTR tv11563[ebp]
	fistp	DWORD PTR tv11561[ebp]
	mov	cl, BYTE PTR tv11561[ebp]
	add	BYTE PTR [esi], cl
	fldcw	WORD PTR tv11566[ebp]
	jmp	$LN1613@other_stuf
$LN375@other_stuf:
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _id$[ebp]
	push	edx
	push	eax
	call	_get_extra
	fnstcw	WORD PTR tv11556[ebp]
	add	esi, eax
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11556[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11553[ebp], eax
	add	esp, 8
	fldcw	WORD PTR tv11553[ebp]
	fistp	DWORD PTR tv11551[ebp]
	mov	cl, BYTE PTR tv11551[ebp]
	sub	BYTE PTR [esi], cl
	fldcw	WORD PTR tv11556[ebp]
	jmp	$LN1613@other_stuf
$LN374@other_stuf:
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _id$[ebp]
	push	edx
	push	eax
	call	_get_extra
	fnstcw	WORD PTR tv11546[ebp]
	add	esi, eax
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11546[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11543[ebp], eax
	add	esp, 8
	fldcw	WORD PTR tv11543[ebp]
	fistp	DWORD PTR tv11541[ebp]
	mov	al, BYTE PTR tv11541[ebp]
	imul	BYTE PTR [esi]
	fldcw	WORD PTR tv11546[ebp]
	mov	BYTE PTR [esi], al
	jmp	$LN1613@other_stuf
$LN373@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	fnstcw	WORD PTR tv11533[ebp]
	add	esi, eax
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11533[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11530[ebp], eax
	add	esp, 8
	fldcw	WORD PTR tv11530[ebp]
	fistp	DWORD PTR tv11528[ebp]
	mov	al, BYTE PTR tv11528[ebp]
	movzx	ecx, al
	movzx	eax, BYTE PTR [esi]
	fldcw	WORD PTR tv11533[ebp]
	cdq
	idiv	ecx
	mov	BYTE PTR [esi], al

; 1475 :                    break;

	jmp	$LN1613@other_stuf
$LN372@other_stuf:

; 1476 :    
; 1477 :                  case CHAR_TYPE:
; 1478 :                    ATTRCASE(char);

	mov	eax, DWORD PTR _assign_type$90764[ebp]
	add	eax, -30001				; ffff8acfH
	cmp	eax, 4
	ja	$LN855@other_stuf
	jmp	DWORD PTR $LN1653@other_stuf[eax*4]
$LN369@other_stuf:
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	mov	edx, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	push	edx
	push	ecx
	mov	BYTE PTR tv9737[ebp], al
	call	_get_extra
	mov	cl, BYTE PTR tv9737[ebp]
	mov	BYTE PTR [eax+esi], cl
	jmp	$LN1623@other_stuf
$LN368@other_stuf:
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _id$[ebp]
	push	edx
	push	eax
	call	_get_extra
	add	esi, eax
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	esp, 8
	call	__ftol2_sse
	add	BYTE PTR [esi], al
	jmp	$LN1613@other_stuf
$LN367@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	add	esi, eax
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	esp, 8
	call	__ftol2_sse
	sub	BYTE PTR [esi], al
	jmp	$LN1613@other_stuf
$LN366@other_stuf:
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	push	eax
	push	ecx
	call	_get_extra
	add	esi, eax
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	esp, 8
	call	__ftol2_sse
	imul	BYTE PTR [esi]
	mov	BYTE PTR [esi], al
	jmp	$LN1613@other_stuf
$LN365@other_stuf:
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _id$[ebp]
	push	edx
	push	eax
	call	_get_extra
	add	esi, eax
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	esp, 8
	call	__ftol2_sse
	movsx	ecx, al
	movsx	eax, BYTE PTR [esi]
	cdq
	idiv	ecx
	mov	BYTE PTR [esi], al

; 1479 :                    break;

	jmp	$LN1613@other_stuf
$LN364@other_stuf:

; 1480 :    
; 1481 :                  case SHORT_TYPE:
; 1482 :                    ATTRCASE(short int);

	mov	eax, DWORD PTR _assign_type$90764[ebp]
	add	eax, -30001				; ffff8acfH
	cmp	eax, 4
	ja	$LN855@other_stuf
	jmp	DWORD PTR $LN1654@other_stuf[eax*4]
$LN361@other_stuf:
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	jmp	$LN1617@other_stuf
$LN360@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	lea	esi, DWORD PTR [eax+esi*2]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	esp, 8
	call	__ftol2_sse
	add	WORD PTR [esi], ax
	jmp	$LN1613@other_stuf
$LN359@other_stuf:
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	push	eax
	push	ecx
	call	_get_extra
	lea	esi, DWORD PTR [eax+esi*2]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	esp, 8
	call	__ftol2_sse
	sub	WORD PTR [esi], ax
	jmp	$LN1613@other_stuf
$LN358@other_stuf:
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _id$[ebp]
	push	edx
	push	eax
	call	_get_extra
	lea	esi, DWORD PTR [eax+esi*2]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	esp, 8
	call	__ftol2_sse
	imul	ax, WORD PTR [esi]
	mov	WORD PTR [esi], ax
	jmp	$LN1613@other_stuf
$LN357@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	lea	esi, DWORD PTR [eax+esi*2]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	esp, 8
	call	__ftol2_sse
	movsx	ecx, ax
	movsx	eax, WORD PTR [esi]
	cdq
	idiv	ecx
	mov	WORD PTR [esi], ax

; 1483 :                    break;

	jmp	$LN1613@other_stuf
$LN356@other_stuf:

; 1484 :    
; 1485 :                  case USHORT_TYPE:
; 1486 :                    ATTRCASE(unsigned short int);

	mov	eax, DWORD PTR _assign_type$90764[ebp]
	add	eax, -30001				; ffff8acfH
	cmp	eax, 4
	ja	$LN855@other_stuf
	jmp	DWORD PTR $LN1655@other_stuf[eax*4]
$LN353@other_stuf:
	mov	eax, DWORD PTR [ebx+48]
	fnstcw	WORD PTR tv11446[ebp]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11446[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11443[ebp], eax
	fldcw	WORD PTR tv11443[ebp]
	fistp	DWORD PTR tv11441[ebp]
	mov	di, WORD PTR tv11441[ebp]
	fldcw	WORD PTR tv11446[ebp]
	jmp	$LN1618@other_stuf
$LN352@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	fnstcw	WORD PTR tv11435[ebp]
	lea	esi, DWORD PTR [eax+esi*2]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11435[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11432[ebp], eax
	add	esp, 8
	fldcw	WORD PTR tv11432[ebp]
	fistp	DWORD PTR tv11430[ebp]
	mov	ax, WORD PTR tv11430[ebp]
	add	WORD PTR [esi], ax
	fldcw	WORD PTR tv11435[ebp]
	jmp	$LN1613@other_stuf
$LN351@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	fnstcw	WORD PTR tv11425[ebp]
	lea	esi, DWORD PTR [eax+esi*2]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11425[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11422[ebp], eax
	add	esp, 8
	fldcw	WORD PTR tv11422[ebp]
	fistp	DWORD PTR tv11420[ebp]
	mov	ax, WORD PTR tv11420[ebp]
	sub	WORD PTR [esi], ax
	fldcw	WORD PTR tv11425[ebp]
	jmp	$LN1613@other_stuf
$LN350@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	fnstcw	WORD PTR tv11415[ebp]
	lea	esi, DWORD PTR [eax+esi*2]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11415[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11412[ebp], eax
	add	esp, 8
	fldcw	WORD PTR tv11412[ebp]
	fistp	DWORD PTR tv11410[ebp]
	mov	ax, WORD PTR tv11410[ebp]
	imul	ax, WORD PTR [esi]
	fldcw	WORD PTR tv11415[ebp]
	mov	WORD PTR [esi], ax
	jmp	$LN1613@other_stuf
$LN349@other_stuf:
	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	push	ecx
	push	edx
	call	_get_extra
	fnstcw	WORD PTR tv11405[ebp]
	lea	esi, DWORD PTR [eax+esi*2]
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	movzx	eax, WORD PTR tv11405[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11402[ebp], eax
	add	esp, 8
	fldcw	WORD PTR tv11402[ebp]
	fistp	DWORD PTR tv11400[ebp]
	mov	ax, WORD PTR tv11400[ebp]
	movzx	ecx, ax
	movzx	eax, WORD PTR [esi]
	fldcw	WORD PTR tv11405[ebp]
	cdq
	idiv	ecx
	mov	WORD PTR [esi], ax

; 1487 :                    break;

	jmp	$LN1613@other_stuf
$LN348@other_stuf:

; 1488 :    
; 1489 :                  case ELEMENTID_TYPE:
; 1490 :                  case VERTEX_TYPE:
; 1491 :                  case EDGE_TYPE:
; 1492 :                  case FACET_TYPE:
; 1493 :                  case BODY_TYPE:
; 1494 :                  case FACETEDGE_TYPE:
; 1495 :                    switch ( assign_type )

	cmp	DWORD PTR _assign_type$90764[ebp], 30001 ; 00007531H
	je	$LN345@other_stuf

; 1499 :                      default: 
; 1500 :                          { sprintf(errmsg,"Illegal assignment operation on element id attribute.\n");

	push	OFFSET ??_C@_0DH@FJKAPFJE@Illegal?5assignment?5operation?5on?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1501 :                            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1502 :                                 file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1147@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1147@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1503 :                             kb_error(3453, errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3453					; 00000d7dH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN346@other_stuf:

; 1504 :                          }
; 1505 :                    }
; 1506 :    
; 1507 :                  case PTR_TYPE:
; 1508 :                    switch ( assign_type )

	cmp	DWORD PTR _assign_type$90764[ebp], 30001 ; 00007531H
	je	$LN1181@other_stuf

; 1512 :                      default: 
; 1513 :                          { sprintf(errmsg,"Illegal assignment operation on pointer attribute.\n");

	push	OFFSET ??_C@_0DE@BJDJNOGD@Illegal?5assignment?5operation?5on?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1514 :                            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1515 :                                 file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL1148@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1148@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1516 :                            kb_error(3454, errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3454					; 00000d7eH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN341@other_stuf:

; 1517 :                          }
; 1518 :                    }
; 1519 :                  case BOUNDARY_TYPE:
; 1520 :                  case CONSTRAINT_TYPE:
; 1521 :                  case QUANTITY_TYPE:
; 1522 :                  case INSTANCE_TYPE:
; 1523 :                  case PROCEDURE_TYPE:
; 1524 :                    switch ( assign_type )

	cmp	DWORD PTR _assign_type$90764[ebp], 30001 ; 00007531H
	je	$LN335@other_stuf

; 1528 :                      default: 
; 1529 :                          { sprintf(errmsg,"Illegal assignment operation on attribute.\n");

	push	OFFSET ??_C@_0CM@LOBMMHIB@Illegal?5assignment?5operation?5on?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1530 :                            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1531 :                                 file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1149@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1149@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1532 :                            kb_error(3682,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3682					; 00000e62H
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN345@other_stuf:

; 1496 :                    { case ASSIGN_OP:
; 1497 :                        ((element_id*)get_extra(id,n))[spot] = 
; 1498 :                            *(element_id*)(stacktop--); break;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	push	eax
	push	ecx
	call	_get_extra
	mov	ecx, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [ecx]
	add	esp, 8
	mov	DWORD PTR [eax+esi*4], edx
	add	DWORD PTR [ebx+48], -8			; fffffff8H
$LN1181@other_stuf:

; 1509 :                    { case ASSIGN_OP:
; 1510 :                        ((char**)get_extra(id,n))[spot] = 
; 1511 :                            *(char**)(stacktop--); break;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _id$[ebp]
	mov	edi, DWORD PTR [ebx+48]
	push	ecx
	push	edx
	call	_get_extra
	mov	ecx, DWORD PTR [edi]
	add	esp, 8
	mov	DWORD PTR [eax+esi*4], ecx
	add	DWORD PTR [ebx+48], -8			; fffffff8H
$LN335@other_stuf:

; 1525 :                    { case ASSIGN_OP:
; 1526 :                        ((int*)get_extra(id,n))[spot] = 
; 1527 :                            *(int*)(stacktop--); break;

	mov	edi, DWORD PTR [ebx+48]
$LN543@other_stuf:
	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _id$[ebp]
	push	eax
	push	ecx
	call	_get_extra
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [eax+esi*4], edx

; 1533 :                          }
; 1534 :                    }
; 1535 :               }
; 1536 :            }
; 1537 :            break;

	jmp	$LN1623@other_stuf
$LN333@other_stuf:

; 1538 : 
; 1539 :            case SET_DENSITY_NODE:
; 1540 :            { REAL density = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	fst	QWORD PTR _density$91006[ebp]
	mov	DWORD PTR [ebx+48], eax

; 1541 :               REAL oldvalue = 0.0;

	fldz
	fst	QWORD PTR _oldvalue$91007[ebp]

; 1542 :               if ( density != 1.0 ) set_attr(id,DENSITY);

	fld	ST(1)
	fld1
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN1217@other_stuf
	push	0
	fstp	ST(1)
	push	16					; 00000010H
	fstp	ST(0)
	push	esi
	call	_set_attr
	fld	QWORD PTR _oldvalue$91007[ebp]
	fld	QWORD PTR _density$91006[ebp]
	mov	ecx, DWORD PTR tv9707[ebp]
	add	esp, 12					; 0000000cH
	fxch	ST(1)
$LN1217@other_stuf:

; 1543 :               switch ( id_type(id) )

	mov	ebx, DWORD PTR _web+236
	mov	edi, DWORD PTR _web+124
	mov	eax, ecx
	dec	eax
	je	SHORT $LN1476@other_stuf
	dec	eax
	je	SHORT $LN1479@other_stuf
	dec	eax
	jne	SHORT $LN330@other_stuf
	fstp	ST(1)

; 1546 :                    case BODY: oldvalue = get_body_density(id); break;

	push	esi
	fstp	ST(0)
	call	_get_body_density
	fld	QWORD PTR _density$91006[ebp]
	mov	ecx, DWORD PTR tv9707[ebp]
	add	esp, 4
	fxch	ST(1)
$LN330@other_stuf:

; 1547 :                  }
; 1548 :               switch ( assign_type )

	mov	eax, DWORD PTR _assign_type$90764[ebp]
	add	eax, -30002				; ffff8aceH
	cmp	eax, 3
	ja	SHORT $LN1487@other_stuf
	jmp	DWORD PTR $LN1656@other_stuf[eax*4]
$LN1479@other_stuf:

; 1545 :                    case FACET: oldvalue = get_facet_density(id); break;

	mov	eax, esi
	fstp	ST(0)
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+eax*4]
	fld	QWORD PTR [edx+32]
	jmp	SHORT $LN330@other_stuf
$LN1476@other_stuf:

; 1544 :                  { case EDGE: oldvalue = get_edge_density(id); break;

	mov	eax, esi
	fstp	ST(0)
	and	eax, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edx+40]
	jmp	SHORT $LN330@other_stuf
$LN323@other_stuf:

; 1549 :                  { case ASSIGN_OP: break;
; 1550 :                    case PLUSASSIGN_OP: density += oldvalue; break;

	faddp	ST(1), ST(0)
	jmp	SHORT $LN325@other_stuf
$LN322@other_stuf:

; 1551 :                    case SUBASSIGN_OP: density = oldvalue - density; break;

	fsubrp	ST(1), ST(0)
	jmp	SHORT $LN325@other_stuf
$LN321@other_stuf:

; 1552 :                    case MULTASSIGN_OP: density *= oldvalue; break;

	fmulp	ST(1), ST(0)
	jmp	SHORT $LN325@other_stuf
$LN320@other_stuf:

; 1553 :                    case DIVASSIGN_OP: density = oldvalue / density; break;

	fdivrp	ST(1), ST(0)
	jmp	SHORT $LN325@other_stuf
$LN1487@other_stuf:
	fstp	ST(0)
$LN325@other_stuf:

; 1554 :                  }
; 1555 :               switch ( id_type(id) )

	dec	ecx
	je	SHORT $LN317@other_stuf
	dec	ecx
	je	SHORT $LN316@other_stuf
	dec	ecx
	jne	$LN1464@other_stuf

; 1560 :                    case BODY: set_body_density(id,density);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	esi
	call	_set_body_density

; 1561 :                        web.gravflag = 1;
; 1562 :                        if (gravity_quantity_num >= 0 )

	mov	eax, DWORD PTR _gravity_quantity_num
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _web+824, 1
	test	eax, eax
	js	$LN537@other_stuf

; 1563 :                            GEN_QUANT(gravity_quantity_num)->modulus =
; 1564 :                                  web.grav_const;

	fld	QWORD PTR _web+832
	mov	ecx, DWORD PTR _gen_quant_list
	imul	eax, 368				; 00000170H
	fstp	QWORD PTR [eax+ecx+176]

; 1565 :                        break;

	jmp	$LN537@other_stuf
$LN316@other_stuf:

; 1558 :                    case FACET: set_facet_density(id,density);

	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ebx+esi*4]
	fstp	QWORD PTR [edx+32]

; 1559 :                        pressure_set_flag = 0; break;

	mov	DWORD PTR _pressure_set_flag, 0
	jmp	$LN537@other_stuf
$LN317@other_stuf:

; 1556 :                  { case EDGE: set_edge_density(id,density); 

	and	esi, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [edi+esi*4]
	fstp	QWORD PTR [eax+40]

; 1557 :                        pressure_set_flag = 0; break;

	mov	DWORD PTR _pressure_set_flag, 0
	jmp	$LN537@other_stuf
$LN308@other_stuf:

; 1566 :                  }
; 1567 :               *recalc_flag = 1;
; 1568 :              }
; 1569 :            break;
; 1570 :    
; 1571 :            case SET_PHASE_NODE:
; 1572 :            { int phase = (int)*(stacktop--);
; 1573 :               switch ( id_type(id) )
; 1574 :                  { case BODY: set_b_phase(id,phase); break;
; 1575 :                    case FACET: set_f_phase(id,phase); break;
; 1576 :                  }
; 1577 :               *recalc_flag = 1;
; 1578 :            }
; 1579 :            break;
; 1580 :    
; 1581 :            case SET_VOLCONST_NODE: 
; 1582 :            { REAL v = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H

; 1583 :               REAL oldvalue = get_body_volconst(id); 

	push	esi
	fstp	QWORD PTR _v$91061[ebp]
	mov	DWORD PTR [ebx+48], eax
	call	_get_body_volconst
	fst	QWORD PTR _oldvalue$91062[ebp]

; 1584 :               switch ( assign_type )

	mov	eax, DWORD PTR _assign_type$90764[ebp]
	add	eax, -30002				; ffff8aceH
	add	esp, 4
	cmp	eax, 3
	ja	SHORT $LN1506@other_stuf
	jmp	DWORD PTR $LN1657@other_stuf[eax*4]
$LN304@other_stuf:

; 1585 :                  { case ASSIGN_OP:    break;
; 1586 :                    case PLUSASSIGN_OP: v +=  oldvalue; break;

	fadd	QWORD PTR _v$91061[ebp]

; 1590 :                  }
; 1591 :              set_body_volconst(id,v); 

	sub	esp, 8
	fstp	QWORD PTR _v$91061[ebp]

; 1592 :              set_body_volume(id,get_body_volume(id)+v-oldvalue,SETSTAMP);
; 1593 :              set_body_oldvolume(id,get_body_oldvolume(id)+v-oldvalue);
; 1594 :              if ( everything_quantities_flag )
; 1595 :                GEN_QUANT(get_body_volquant(id))->volconst = v;

	jmp	$LN1624@other_stuf
$LN303@other_stuf:

; 1587 :                    case SUBASSIGN_OP: v = oldvalue - v; break;

	fsub	QWORD PTR _v$91061[ebp]

; 1590 :                  }
; 1591 :              set_body_volconst(id,v); 

	sub	esp, 8
	fstp	QWORD PTR _v$91061[ebp]

; 1592 :              set_body_volume(id,get_body_volume(id)+v-oldvalue,SETSTAMP);
; 1593 :              set_body_oldvolume(id,get_body_oldvolume(id)+v-oldvalue);
; 1594 :              if ( everything_quantities_flag )
; 1595 :                GEN_QUANT(get_body_volquant(id))->volconst = v;

	jmp	$LN1624@other_stuf
$LN302@other_stuf:

; 1588 :                    case MULTASSIGN_OP: v = oldvalue * v; break;

	fmul	QWORD PTR _v$91061[ebp]

; 1590 :                  }
; 1591 :              set_body_volconst(id,v); 

	sub	esp, 8
	fstp	QWORD PTR _v$91061[ebp]

; 1592 :              set_body_volume(id,get_body_volume(id)+v-oldvalue,SETSTAMP);
; 1593 :              set_body_oldvolume(id,get_body_oldvolume(id)+v-oldvalue);
; 1594 :              if ( everything_quantities_flag )
; 1595 :                GEN_QUANT(get_body_volquant(id))->volconst = v;

	jmp	$LN1624@other_stuf
$LN301@other_stuf:

; 1589 :                    case DIVASSIGN_OP: v = oldvalue / v; break;

	fdiv	QWORD PTR _v$91061[ebp]

; 1590 :                  }
; 1591 :              set_body_volconst(id,v); 

	sub	esp, 8
	fstp	QWORD PTR _v$91061[ebp]

; 1592 :              set_body_volume(id,get_body_volume(id)+v-oldvalue,SETSTAMP);
; 1593 :              set_body_oldvolume(id,get_body_oldvolume(id)+v-oldvalue);
; 1594 :              if ( everything_quantities_flag )
; 1595 :                GEN_QUANT(get_body_volquant(id))->volconst = v;

	jmp	$LN1624@other_stuf
$LN1506@other_stuf:

; 1589 :                    case DIVASSIGN_OP: v = oldvalue / v; break;

	fstp	ST(0)

; 1590 :                  }
; 1591 :              set_body_volconst(id,v); 

	sub	esp, 8

; 1592 :              set_body_volume(id,get_body_volume(id)+v-oldvalue,SETSTAMP);
; 1593 :              set_body_oldvolume(id,get_body_oldvolume(id)+v-oldvalue);
; 1594 :              if ( everything_quantities_flag )
; 1595 :                GEN_QUANT(get_body_volquant(id))->volconst = v;

	jmp	$LN1624@other_stuf
$LN299@other_stuf:

; 1596 :               *recalc_flag = 1;
; 1597 :              break;
; 1598 :            }
; 1599 : 
; 1600 :            case SET_TARGET_NODE: 
; 1601 :            { REAL v = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H

; 1602 :               REAL oldvalue = get_body_fixvol(id); 

	push	esi
	fstp	QWORD PTR _v$91077[ebp]
	mov	DWORD PTR [ebx+48], eax
	call	_get_body_fixvol

; 1603 :               switch ( assign_type )

	mov	eax, DWORD PTR _assign_type$90764[ebp]
	add	eax, -30002				; ffff8aceH
	add	esp, 4
	cmp	eax, 3
	ja	SHORT $LN1517@other_stuf
	jmp	DWORD PTR $LN1658@other_stuf[eax*4]
$LN295@other_stuf:

; 1604 :                  { case ASSIGN_OP:    break;
; 1605 :                    case PLUSASSIGN_OP: v +=  oldvalue; break;

	fadd	QWORD PTR _v$91077[ebp]
	fstp	QWORD PTR _v$91077[ebp]
	jmp	SHORT $LN297@other_stuf
$LN294@other_stuf:

; 1606 :                    case SUBASSIGN_OP: v = oldvalue - v; break;

	fsub	QWORD PTR _v$91077[ebp]
	fstp	QWORD PTR _v$91077[ebp]
	jmp	SHORT $LN297@other_stuf
$LN293@other_stuf:

; 1607 :                    case MULTASSIGN_OP: v = oldvalue * v; break;

	fmul	QWORD PTR _v$91077[ebp]
	fstp	QWORD PTR _v$91077[ebp]
	jmp	SHORT $LN297@other_stuf
$LN292@other_stuf:

; 1608 :                    case DIVASSIGN_OP: v = oldvalue / v; break;

	fdiv	QWORD PTR _v$91077[ebp]
	fstp	QWORD PTR _v$91077[ebp]
	jmp	SHORT $LN297@other_stuf
$LN1517@other_stuf:
	fstp	ST(0)
$LN297@other_stuf:

; 1609 :                  }
; 1610 :               if ( get_attr(id) & PRESSURE )

	mov	eax, DWORD PTR tv9707[ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 4
	mov	eax, DWORD PTR _web[ecx+12]
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 2048				; 00000800H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN1183@other_stuf

; 1611 :               { sprintf(errmsg,"Must unset body pressure before fixing target.\n");

	push	OFFSET ??_C@_0DA@GLPHHFLM@Must?5unset?5body?5pressure?5before?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1612 :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1613 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1150@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1150@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1614 :                  kb_error(2029,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2029					; 000007edH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1183@other_stuf:

; 1615 :               }
; 1616 :              set_attr(id,FIXEDVOL);

	push	0
	push	32					; 00000020H
	push	esi
	call	_set_attr

; 1617 :              set_body_fixvol(id,v); 

	fld	QWORD PTR _v$91077[ebp]
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	esi
	call	_set_body_fixvol

; 1618 :              *recalc_flag = 1;

	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN290@other_stuf:

; 1619 :              break;
; 1620 :            }
; 1621 :            case SET_PRESSURE_NODE: 
; 1622 :            { REAL p = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H

; 1623 :               REAL oldvalue = get_body_pressure(id); 

	push	esi
	fstp	QWORD PTR _p$91094[ebp]
	mov	DWORD PTR [ebx+48], eax
	call	_get_body_pressure

; 1624 :               switch ( assign_type )

	mov	eax, DWORD PTR _assign_type$90764[ebp]
	add	eax, -30002				; ffff8aceH
	add	esp, 4
	cmp	eax, 3
	ja	SHORT $LN1525@other_stuf
	jmp	DWORD PTR $LN1659@other_stuf[eax*4]
$LN286@other_stuf:

; 1625 :                  { case ASSIGN_OP:    break;
; 1626 :                    case PLUSASSIGN_OP: p +=  oldvalue; break;

	fadd	QWORD PTR _p$91094[ebp]
	fstp	QWORD PTR _p$91094[ebp]
	jmp	SHORT $LN288@other_stuf
$LN285@other_stuf:

; 1627 :                    case SUBASSIGN_OP: p = oldvalue - p; break;

	fsub	QWORD PTR _p$91094[ebp]
	fstp	QWORD PTR _p$91094[ebp]
	jmp	SHORT $LN288@other_stuf
$LN284@other_stuf:

; 1628 :                    case MULTASSIGN_OP: p = oldvalue * p; break;

	fmul	QWORD PTR _p$91094[ebp]
	fstp	QWORD PTR _p$91094[ebp]
	jmp	SHORT $LN288@other_stuf
$LN283@other_stuf:

; 1629 :                    case DIVASSIGN_OP: p = oldvalue / p; break;

	fdiv	QWORD PTR _p$91094[ebp]
	fstp	QWORD PTR _p$91094[ebp]
	jmp	SHORT $LN288@other_stuf
$LN1525@other_stuf:
	fstp	ST(0)
$LN288@other_stuf:

; 1630 :                  }
; 1631 :               if ( get_attr(id) & FIXEDVOL )

	mov	eax, DWORD PTR tv9707[ebp]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	ebx, esi
	and	ebx, 134217727				; 07ffffffH
	add	ebx, ebx
	shl	edx, 4
	mov	eax, DWORD PTR _web[edx+12]
	add	ebx, ebx
	mov	eax, DWORD PTR [eax+ebx]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 32					; 00000020H
	xor	ecx, ecx
	or	eax, ecx
	je	SHORT $LN1184@other_stuf

; 1632 :               { sprintf(errmsg,"Must unset body target before fixing pressure.\n");

	push	OFFSET ??_C@_0DA@ILOKBJND@Must?5unset?5body?5target?5before?5fi@
	push	OFFSET _errmsg
	call	_sprintf

; 1633 :                 sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1634 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1151@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1151@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1635 :                 kb_error(2030,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2030					; 000007eeH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1184@other_stuf:

; 1636 :               }
; 1637 :              set_attr(id,PRESSURE);

	push	0
	push	2048					; 00000800H
	push	esi
	call	_set_attr

; 1638 :              set_body_pressure(id,p);    web.pressflag = 1;

	fld	QWORD PTR _p$91094[ebp]
	add	esp, 4
	fstp	QWORD PTR [esp]
	push	esi
	call	_set_body_pressure
	add	esp, 12					; 0000000cH

; 1639 :              if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	mov	DWORD PTR _web+844, 1
	je	$LN277@other_stuf

; 1640 :              { struct gen_quant *q = GEN_QUANT(get_body_volquant(id));

	mov	ecx, DWORD PTR _web+348

; 1641 :                if ( p == 0.0 )

	fld	QWORD PTR _p$91094[ebp]
	mov	edx, DWORD PTR [ebx+ecx]
	fld	ST(0)
	mov	ecx, DWORD PTR [edx+404]
	fldz
	imul	ecx, 368				; 00000170H
	fucompp
	fnstsw	ax
	add	ecx, DWORD PTR _gen_quant_list
	test	ah, 68					; 00000044H

; 1643 :                   if ( !(q->flags & Q_INFO) )

	mov	eax, DWORD PTR [ecx+136]
	jp	SHORT $LN280@other_stuf

; 1642 :                { q->modulus = 1.0;

	fstp	ST(0)
	fld1
	fstp	QWORD PTR [ecx+176]

; 1643 :                   if ( !(q->flags & Q_INFO) )

	test	al, 4
	jne	SHORT $LN277@other_stuf

; 1644 :                   { q->flags &= ~(Q_ENERGY|Q_FIXED|Q_CONSERVED);

	and	eax, -12				; fffffff4H

; 1645 :                      q->flags |= Q_INFO;

	or	eax, 4
	pop	edi

; 1652 :                      q->flags |= Q_ENERGY;

	mov	DWORD PTR [ecx+136], eax

; 1653 :                   }
; 1654 :                }
; 1655 :              }
; 1656 :               *recalc_flag = 1;

	mov	eax, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN280@other_stuf:

; 1646 :                   }
; 1647 :                }
; 1648 :                else 
; 1649 :                { q->modulus = -p;

	fchs
	fstp	QWORD PTR [ecx+176]

; 1650 :                   if ( !(q->flags & Q_ENERGY ) )

	test	al, 1
	jne	SHORT $LN277@other_stuf

; 1651 :                   { q->flags &= ~(Q_INFO|Q_FIXED|Q_CONSERVED);

	and	eax, -15				; fffffff1H

; 1652 :                      q->flags |= Q_ENERGY;

	or	eax, 1
	mov	DWORD PTR [ecx+136], eax
$LN277@other_stuf:

; 1653 :                   }
; 1654 :                }
; 1655 :              }
; 1656 :               *recalc_flag = 1;

	mov	eax, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN276@other_stuf:

; 1657 :              break;
; 1658 :            }
; 1659 : 
; 1660 :            case SET_OPACITY_NODE:
; 1661 :              facet_alpha = *(stacktop)--;

	mov	ecx, DWORD PTR [ebx+48]
	fld	QWORD PTR [ecx]
	fstp	QWORD PTR _facet_alpha

; 1662 :              break;

	jmp	$LN1613@other_stuf
$LN275@other_stuf:

; 1663 :    
; 1664 :            case SET_CONSTRAINT_NODE:
; 1665 :            { int con = (int)*(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	mov	ecx, DWORD PTR [ebx+48]
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], ecx

; 1666 :               struct constraint *constr = get_constraint(con);

	mov	ebx, eax
	and	ebx, 1073741823				; 3fffffffH
	imul	ebx, 176				; 000000b0H
	add	ebx, DWORD PTR _web+652
	mov	DWORD PTR _con$91120[ebp], eax

; 1667 :               if ( (con<0) || (con>=web.maxcon) || !(constr->attr & IN_USE))

	test	eax, eax
	js	SHORT $LN1187@other_stuf
	mov	edx, eax
	cmp	edx, DWORD PTR _web+644
	jge	SHORT $LN1187@other_stuf
	mov	eax, DWORD PTR [ebx+32]
	and	eax, 32					; 00000020H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN1185@other_stuf
$LN1187@other_stuf:

; 1668 :               { sprintf(errmsg,"Illegal constraint number: %d.\n",con);

	mov	eax, DWORD PTR _con$91120[ebp]
	push	eax
	push	OFFSET ??_C@_0CA@KOHHCGIN@Illegal?5constraint?5number?3?5?$CFd?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1669 :                 sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1670 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL1152@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1152@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1671 :                 kb_error(1146,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1146					; 0000047aH
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1185@other_stuf:

; 1672 :               } 
; 1673 :              if ( get_attr(id) & BOUNDARY ) 

	mov	eax, DWORD PTR tv9707[ebp]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	shl	edx, 4
	mov	eax, DWORD PTR _web[edx+12]
	mov	ecx, esi
	and	ecx, 134217727				; 07ffffffH
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+8]
	and	eax, 128				; 00000080H
	xor	edx, edx
	or	eax, edx
	je	$LN513@other_stuf

; 1674 :              { sprintf(errmsg,
; 1675 :                  "Cannot set constraint on %s %s since it is on a boundary.\n",
; 1676 :                   typenames[id_type(id)],ELNAME(id));

	test	esi, 268435456				; 10000000H
	je	SHORT $LN961@other_stuf
	inc	ecx
	push	ecx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN962@other_stuf
$LN961@other_stuf:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN962@other_stuf:
	mov	ecx, DWORD PTR tv9707[ebp]
	mov	edx, DWORD PTR _typenames[ecx*4]
	push	eax
	push	edx
	push	OFFSET ??_C@_0DL@HKDGADPO@Cannot?5set?5constraint?5on?5?$CFs?5?$CFs?5s@
	push	OFFSET _errmsg
	call	_sprintf

; 1677 :                 sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1678 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	1
$LL1153@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1153@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1679 :                kb_error(5111,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5111					; 000013f7H

; 1680 :              }
; 1681 : 
; 1682 :               set_attr(id,CONSTRAINT);
; 1683 :               if ( constr->attr & CON_ENERGY )
; 1684 :                  set_attr(id, BDRY_ENERGY);
; 1685 :               if ( constr->attr & CON_CONTENT )
; 1686 :                  set_attr(id, BDRY_CONTENT);
; 1687 :               switch ( id_type(id) )
; 1688 :                  { case VERTEX: set_v_constraint_map(id,con); 
; 1689 :                               project_v_constr(id,ACTUAL_MOVE,RESET_ONESIDEDNESS);
; 1690 :                               break;
; 1691 :                    case EDGE: set_e_constraint_map(id,con); break;
; 1692 :                    case FACET: set_f_constraint_map(id,con); break;

	jmp	$LN1629@other_stuf
$LN264@other_stuf:

; 1693 :                  }
; 1694 :               *recalc_flag = 1;
; 1695 :              }
; 1696 :            break;
; 1697 :    
; 1698 :            case SET_ORIGINAL_NODE:
; 1699 :              set_original(id,(int)*(stacktop--)-1 | ((element_id)id_type(id)<<TYPESHIFT)
; 1700 :                   | VALIDMASK);

	mov	edx, DWORD PTR [ebx+48]
	fnstcw	WORD PTR tv11133[ebp]
	fld	QWORD PTR [edx]
	movzx	eax, WORD PTR tv11133[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv11130[ebp], eax
	mov	edx, esi
	and	edx, -268435456				; f0000000H
	fldcw	WORD PTR tv11130[ebp]
	fistp	QWORD PTR tv11128[ebp]
	mov	eax, DWORD PTR tv11128[ebp]
	dec	eax
	or	eax, edx
	lea	edx, DWORD PTR [ecx*8]
	fldcw	WORD PTR tv11133[ebp]
	sub	edx, ecx
	shl	edx, 4
	mov	ecx, DWORD PTR _web[edx+12]
	or	eax, 268435456				; 10000000H
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR [edx+20], eax

; 1701 :              break;

	jmp	$LN1613@other_stuf
$LN254@other_stuf:

; 1702 :    
; 1703 :            case SET_COLOR_NODE:
; 1704 :            { int color = (int)*(stacktop--);
; 1705 :               switch ( id_type(id) )
; 1706 :                  { case EDGE: set_edge_color(id,color); break;
; 1707 :                    case FACET: set_facet_color(id,color); break;
; 1708 :                  }
; 1709 :               *update_display_flag = 1;
; 1710 :            }
; 1711 :            break;
; 1712 :    
; 1713 :            case SET_FRONTCOLOR_NODE:
; 1714 :            { int color = (int)*(stacktop--);
; 1715 :               set_facet_frontcolor(id,color);
; 1716 :               *update_display_flag = 1;
; 1717 :            }
; 1718 :            break;
; 1719 :    
; 1720 :            case SET_BACKCOLOR_NODE:
; 1721 :            { int color = (int)*(stacktop--);
; 1722 :               set_facet_backcolor(id,color);
; 1723 :               *update_display_flag = 1;
; 1724 :            }
; 1725 :            break;
; 1726 :    
; 1727 :            case SET_WRAP_NODE:
; 1728 :            { int w = (int)*(stacktop--);
; 1729 :              if ( web.symmetry_flag )
; 1730 :              { set_edge_wrap(id,w);
; 1731 :                *update_display_flag = 1;
; 1732 :              }
; 1733 :            }
; 1734 :            break;
; 1735 :    
; 1736 :            case SET_COORD_NODE: case SET_COORD_1_NODE: 
; 1737 :              if ( node->right ) /* indexed */

	cmp	DWORD PTR [edi+8], 0
	je	$LN253@other_stuf

; 1738 :              { int dim = (int)*(stacktop--)-1;

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	mov	ecx, DWORD PTR [ebx+48]

; 1739 :                REAL oldvalue = get_coord(id)[dim]; 

	and	esi, 134217727				; 07ffffffH
	add	ecx, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], ecx
	mov	edx, DWORD PTR _web+12
	add	esi, esi
	add	esi, esi
	mov	ecx, DWORD PTR [esi+edx]
	mov	edx, DWORD PTR _web+104
	mov	DWORD PTR tv9792[ebp], esi
	mov	esi, DWORD PTR _dymem
	add	ecx, DWORD PTR [esi+edx+64]
	dec	eax
	fld	QWORD PTR [ecx+eax*8]

; 1740 :                REAL v;
; 1741 :                if ( (dim >= SDIM) || (dim < 0) )

	mov	ecx, DWORD PTR _web+616
	fst	QWORD PTR _oldvalue$91192[ebp]
	mov	esi, eax
	cmp	eax, ecx
	jge	SHORT $LN1534@other_stuf
	test	esi, esi
	jns	SHORT $LN1190@other_stuf
$LN1534@other_stuf:

; 1742 :                    { sprintf(errmsg,
; 1743 :                       "Trying to set coordinate %d, in space dimension %d.\n",
; 1744 :                            dim,SDIM);

	push	ecx
	fstp	ST(0)
	push	esi
	push	OFFSET ??_C@_0DF@OFFNPKIE@Trying?5to?5set?5coordinate?5?$CFd?0?5in?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1745 :                      sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1746 :                           file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL1154@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1154@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1747 :                      kb_error(2031,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2031					; 000007efH
	call	_kb_error
	fld	QWORD PTR _oldvalue$91192[ebp]
	add	esp, 28					; 0000001cH
$LN1190@other_stuf:

; 1748 :                    }
; 1749 :                v = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax

; 1750 :                switch ( assign_type )

	mov	eax, DWORD PTR _assign_type$90764[ebp]
	add	eax, -30002				; ffff8aceH
	cmp	eax, 3
	ja	SHORT $LN1542@other_stuf
	jmp	DWORD PTR $LN1660@other_stuf[eax*4]
$LN247@other_stuf:

; 1751 :                  { case ASSIGN_OP:  break;
; 1752 :                    case PLUSASSIGN_OP: v +=  oldvalue; break;

	faddp	ST(1), ST(0)
	jmp	SHORT $LN249@other_stuf
$LN246@other_stuf:

; 1753 :                    case SUBASSIGN_OP: v = oldvalue - v; break;

	fsubp	ST(1), ST(0)
	jmp	SHORT $LN249@other_stuf
$LN245@other_stuf:

; 1754 :                    case MULTASSIGN_OP: v = oldvalue * v; break;

	fmulp	ST(1), ST(0)
	jmp	SHORT $LN249@other_stuf
$LN244@other_stuf:

; 1755 :                    case DIVASSIGN_OP: v = oldvalue / v; break;

	fdivp	ST(1), ST(0)
	jmp	SHORT $LN249@other_stuf
$LN1542@other_stuf:
	fstp	ST(1)
$LN249@other_stuf:

; 1756 :                  }
; 1757 :                  get_coord(id)[dim] = v;

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR tv9792[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR _web+104
	mov	edx, DWORD PTR _dymem
	add	eax, DWORD PTR [edx+ecx+64]
	pop	edi
	fstp	QWORD PTR [eax+esi*8]

; 1758 :                  *recalc_flag = 1;

	mov	eax, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	esi
	mov	DWORD PTR [eax], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN253@other_stuf:

; 1759 :                  break;
; 1760 :               }
; 1761 :               /* else fall through */
; 1762 :    
; 1763 :           case SET_COORD_2_NODE:
; 1764 :           case SET_COORD_3_NODE: case SET_COORD_4_NODE: case SET_COORD_5_NODE:
; 1765 :           case SET_COORD_6_NODE: case SET_COORD_7_NODE: case SET_COORD_8_NODE:
; 1766 :              { REAL v = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax

; 1767 :                REAL oldvalue = get_coord(id)[node->op2.attr_kind-SET_COORD_1_NODE];

	mov	ecx, DWORD PTR _web+12
	mov	edx, DWORD PTR _web+104
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+edx+64]
	and	esi, 134217727				; 07ffffffH
	mov	esi, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR [edi+136]
	lea	edx, DWORD PTR [esi+ecx*8-82520]

; 1768 :                switch ( assign_type )

	mov	ecx, DWORD PTR _assign_type$90764[ebp]
	fld	QWORD PTR [edx+eax]
	add	ecx, -30002				; ffff8aceH
	cmp	ecx, 3
	ja	SHORT $LN1550@other_stuf
	jmp	DWORD PTR $LN1661@other_stuf[ecx*4]
$LN239@other_stuf:

; 1769 :                  { case ASSIGN_OP:  break;
; 1770 :                    case PLUSASSIGN_OP: v +=  oldvalue; break;

	faddp	ST(1), ST(0)
	jmp	SHORT $LN241@other_stuf
$LN238@other_stuf:

; 1771 :                    case SUBASSIGN_OP: v = oldvalue - v; break;

	fsubrp	ST(1), ST(0)
	jmp	SHORT $LN241@other_stuf
$LN237@other_stuf:

; 1772 :                    case MULTASSIGN_OP: v = oldvalue * v; break;

	fmulp	ST(1), ST(0)
	jmp	SHORT $LN241@other_stuf
$LN236@other_stuf:

; 1773 :                    case DIVASSIGN_OP: v = oldvalue / v; break;

	fdivrp	ST(1), ST(0)
	jmp	SHORT $LN241@other_stuf
$LN1550@other_stuf:
	fstp	ST(0)
$LN241@other_stuf:

; 1774 :                  }
; 1775 :                get_coord(id)[node->op2.attr_kind-SET_COORD_1_NODE] = v;

	mov	ecx, DWORD PTR [edi+136]
	lea	edx, DWORD PTR [esi+ecx*8-82520]
	fstp	QWORD PTR [edx+eax]

; 1776 :                if ( node->op2.attr_kind-SET_COORD_1_NODE <= SDIM ) *recalc_flag = 1;

	mov	eax, DWORD PTR [edi+136]
	sub	eax, 10315				; 0000284bH
	cmp	eax, DWORD PTR _web+616
	jg	$LN855@other_stuf
	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], 1
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN234@other_stuf:

; 1777 :              }
; 1778 :              break;
; 1779 :    
; 1780 :           case SET_PARAM_NODE: case SET_PARAM_1_NODE: case SET_PARAM_2_NODE:
; 1781 :           case SET_PARAM_3_NODE: case SET_PARAM_4_NODE:
; 1782 :              if ( get_vattr(id) & BOUNDARY )

	mov	ecx, DWORD PTR _web+12
	mov	eax, esi
	and	eax, 134217727				; 07ffffffH
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv10053[ebp], eax
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv10055[ebp], eax
	mov	eax, DWORD PTR [eax+8]
	and	eax, 128				; 00000080H
	xor	ecx, ecx
	or	eax, ecx
	je	$LN233@other_stuf

; 1783 :                { struct boundary *boundary = get_boundary(id);

	mov	eax, DWORD PTR _V_BOUNDARY_ATTR
	mov	ecx, DWORD PTR _web+104
	test	eax, eax
	je	SHORT $LN967@other_stuf
	imul	eax, 240				; 000000f0H
	add	eax, DWORD PTR _dymem
	mov	edx, DWORD PTR [eax+ecx+64]
	mov	eax, DWORD PTR tv10055[ebp]
	mov	eax, DWORD PTR [edx+eax]
	imul	eax, 136				; 00000088H
	add	eax, DWORD PTR _web+776
	mov	DWORD PTR _boundary$91238[ebp], eax
	jmp	SHORT $LN968@other_stuf
$LN967@other_stuf:
	mov	DWORD PTR _boundary$91238[ebp], 0
$LN968@other_stuf:

; 1784 :                   REAL *param = get_param(id);

	mov	edx, DWORD PTR tv10053[ebp]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR _dymem
	mov	eax, DWORD PTR [eax+ecx+544]
	add	eax, edx
	mov	DWORD PTR tv10462[ebp], edx

; 1785 :                   REAL *xx = get_coord(id);

	mov	edx, DWORD PTR _dymem
	mov	ecx, DWORD PTR [edx+ecx+64]
	add	ecx, DWORD PTR tv10462[ebp]
	mov	DWORD PTR _param$91244[ebp], eax
	mov	DWORD PTR _xx$91249[ebp], ecx

; 1786 :                   REAL v;
; 1787 :                   int pnum = node->op2.attr_kind-SET_PARAM_1_NODE; 

	mov	ecx, DWORD PTR [edi+136]

; 1788 :                   REAL oldvalue = param[pnum];

	fld	QWORD PTR [eax+ecx*8-82608]
	add	ecx, -10326				; ffffd7aaH

; 1789 :                   if ( node->right ) pnum += (int)*(stacktop--);

	cmp	DWORD PTR [edi+8], 0
	fst	QWORD PTR _oldvalue$91256[ebp]
	mov	DWORD PTR _pnum$91255[ebp], ecx
	je	SHORT $LN1209@other_stuf
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	add	DWORD PTR _pnum$91255[ebp], eax
	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR _pnum$91255[ebp]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	mov	eax, DWORD PTR _param$91244[ebp]
$LN1209@other_stuf:

; 1790 :                   if ( pnum > boundary->pcount )

	mov	edx, DWORD PTR _boundary$91238[ebp]
	mov	edx, DWORD PTR [edx+40]
	cmp	ecx, edx
	jle	SHORT $LN1210@other_stuf

; 1791 :                   { sprintf(errmsg,"Parameter number is %d; maximum is %d.\n",
; 1792 :                           pnum,boundary->pcount);

	mov	eax, DWORD PTR _pnum$91255[ebp]
	fstp	ST(0)
	push	edx
	push	eax
	push	OFFSET ??_C@_0CI@EMPMINAB@Parameter?5number?5is?5?$CFd?$DL?5maximum?5@
	push	OFFSET _errmsg
	call	_sprintf

; 1793 :                     sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1794 :                          file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL1155@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1155@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1795 :                     kb_error(1213,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1213					; 000004bdH
	call	_kb_error
	fld	QWORD PTR _oldvalue$91256[ebp]
	mov	ecx, DWORD PTR _pnum$91255[ebp]
	mov	eax, DWORD PTR _param$91244[ebp]
	add	esp, 28					; 0000001cH
$LN1210@other_stuf:

; 1796 :                   }
; 1797 :                   v = *(stacktop--);

	mov	edx, DWORD PTR [ebx+48]
	fld	QWORD PTR [edx]
	add	edx, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], edx

; 1798 :                   switch ( assign_type )

	mov	edx, DWORD PTR _assign_type$90764[ebp]
	add	edx, -30002				; ffff8aceH
	cmp	edx, 3
	ja	SHORT $LN1564@other_stuf
	jmp	DWORD PTR $LN1662@other_stuf[edx*4]
$LN227@other_stuf:

; 1799 :                   { case ASSIGN_OP:  break;
; 1800 :                     case PLUSASSIGN_OP: v +=  oldvalue; break;

	faddp	ST(1), ST(0)
	jmp	SHORT $LN229@other_stuf
$LN226@other_stuf:

; 1801 :                     case SUBASSIGN_OP: v = oldvalue - v; break;

	fsubp	ST(1), ST(0)
	jmp	SHORT $LN229@other_stuf
$LN225@other_stuf:

; 1802 :                     case MULTASSIGN_OP: v = oldvalue * v; break;

	fmulp	ST(1), ST(0)
	jmp	SHORT $LN229@other_stuf
$LN224@other_stuf:

; 1803 :                     case DIVASSIGN_OP: v = oldvalue / v; break;

	fdivp	ST(1), ST(0)
	jmp	SHORT $LN229@other_stuf
$LN1564@other_stuf:
	fstp	ST(1)
$LN229@other_stuf:

; 1804 :                   }
; 1805 :                   param[pnum] = v; 

	fstp	QWORD PTR [eax+ecx*8]

; 1806 :                   PUSH_TRACE;

	mov	eax, DWORD PTR _eval_stack_trace_spot
	cmp	eax, 100				; 00000064H
	jl	SHORT $LN1214@other_stuf
	xor	eax, eax
$LN1214@other_stuf:
	mov	DWORD PTR _eval_stack_trace[eax*4], edi
	inc	eax

; 1807 :                   for ( k = 0 ; k < SDIM ; k++ )

	xor	edi, edi
	mov	DWORD PTR _eval_stack_trace_spot, eax
	cmp	DWORD PTR _web+616, edi
	jle	$LN445@other_stuf

; 1806 :                   PUSH_TRACE;

	mov	ebx, DWORD PTR _boundary$91238[ebp]
	add	ebx, 48					; 00000030H
	npad	6
$LL222@other_stuf:

; 1808 :                      xx[k] = eval(boundary->coordf[k],param,id,NULL);

	mov	ecx, DWORD PTR _param$91244[ebp]
	mov	edx, DWORD PTR [ebx]
	push	0
	push	esi
	push	ecx
	push	edx
	call	_eval
	mov	eax, DWORD PTR _xx$91249[ebp]
	fstp	QWORD PTR [eax+edi*8]
	inc	edi
	add	esp, 16					; 00000010H
	add	ebx, 4
	cmp	edi, DWORD PTR _web+616
	jl	SHORT $LL222@other_stuf

; 1809 :                   POP_TRACE;
; 1810 :                   *recalc_flag = 1;
; 1811 :                }
; 1812 :               else /* just parking a value probably */ 

	jmp	$LN1616@other_stuf
$LN233@other_stuf:

; 1813 :                  { REAL *param = get_param(id);

	mov	ecx, DWORD PTR _dymem
	mov	eax, DWORD PTR _web+104
	mov	esi, DWORD PTR [ecx+eax+544]
	add	esi, DWORD PTR tv10055[ebp]

; 1814 :                    int pnum = node->op2.attr_kind-SET_PARAM_1_NODE;
; 1815 :                    REAL oldvalue = param[pnum];
; 1816 :                    REAL v;
; 1817 :                    if ( node->right ) pnum += (int)*(stacktop--);

	cmp	DWORD PTR [edi+8], 0
	fld	QWORD PTR [esi+edx*8-82608]
	lea	ecx, DWORD PTR [edx-10326]
	mov	DWORD PTR _pnum$91282[ebp], ecx
	je	SHORT $LN217@other_stuf
	mov	edi, DWORD PTR [ebx+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	add	DWORD PTR _pnum$91282[ebp], eax
	mov	ecx, DWORD PTR _pnum$91282[ebp]
	add	edi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], edi
$LN217@other_stuf:

; 1818 :                   v = *(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax

; 1819 :                   switch ( assign_type )

	mov	eax, DWORD PTR _assign_type$90764[ebp]
	add	eax, -30002				; ffff8aceH
	cmp	eax, 3
	ja	SHORT $LN1575@other_stuf
	jmp	DWORD PTR $LN1663@other_stuf[eax*4]
$LN213@other_stuf:

; 1820 :                   { case ASSIGN_OP:  break;
; 1821 :                     case PLUSASSIGN_OP: v +=  oldvalue; break;

	faddp	ST(1), ST(0)
	pop	edi

; 1825 :                   }
; 1826 :    
; 1827 :                   param[pnum] = v;

	fstp	QWORD PTR [esi+ecx*8]
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN212@other_stuf:

; 1822 :                     case SUBASSIGN_OP: v = oldvalue - v; break;

	fsubp	ST(1), ST(0)
	pop	edi

; 1825 :                   }
; 1826 :    
; 1827 :                   param[pnum] = v;

	fstp	QWORD PTR [esi+ecx*8]
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN211@other_stuf:

; 1823 :                     case MULTASSIGN_OP: v = oldvalue * v; break;

	fmulp	ST(1), ST(0)
	pop	edi

; 1825 :                   }
; 1826 :    
; 1827 :                   param[pnum] = v;

	fstp	QWORD PTR [esi+ecx*8]
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN210@other_stuf:

; 1824 :                     case DIVASSIGN_OP: v = oldvalue / v; break;

	fdivp	ST(1), ST(0)
	pop	edi

; 1825 :                   }
; 1826 :    
; 1827 :                   param[pnum] = v;

	fstp	QWORD PTR [esi+ecx*8]
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1575@other_stuf:

; 1824 :                     case DIVASSIGN_OP: v = oldvalue / v; break;

	fstp	ST(1)
	pop	edi

; 1825 :                   }
; 1826 :    
; 1827 :                   param[pnum] = v;

	fstp	QWORD PTR [esi+ecx*8]
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN209@other_stuf:

; 1828 :                 }
; 1829 :                 break;
; 1830 :    
; 1831 :              case SET_FRONTBODY_NODE:
; 1832 :              case SET_BACKBODY_NODE:
; 1833 :                b_id = get_ordinal_id(BODY,(int)*(stacktop--)-1);

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	call	__ftol2_sse
	mov	ecx, DWORD PTR [ebx+48]
	dec	eax
	push	eax
	add	ecx, -8					; fffffff8H
	push	3
	mov	DWORD PTR [ebx+48], ecx
	call	_get_ordinal_id
	mov	ebx, eax
	add	esp, 8

; 1834 :                if ( b_id && !valid_id(b_id) ) 

	test	ebx, ebx
	je	$LN1200@other_stuf
	test	ebx, 268435456				; 10000000H
	jne	$LN1200@other_stuf

; 1835 :                { sprintf(errmsg,"Invalid body in SET FRONTBODY or BACKBODY.\n");

	push	OFFSET ??_C@_0CM@OKNEOKD@Invalid?5body?5in?5SET?5FRONTBODY?5or@
	push	OFFSET _errmsg
	call	_sprintf

; 1836 :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1837 :                       file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1156@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1156@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 1838 :                  kb_error(2032,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2032					; 000007f0H

; 1839 :                }
; 1840 :                set_body((node->op2.attr_kind==SET_FRONTBODY_NODE?id:inverse_id(id)),b_id);
; 1841 :                *recalc_flag = 1;
; 1842 :                break;

	jmp	$LN1631@other_stuf
$LN207@other_stuf:

; 1843 :    
; 1844 :             default: 
; 1845 :                sprintf(errmsg,"Unhandled SET attribute %d\n",node->op2.attr_kind);

	push	edx
	push	OFFSET ??_C@_0BM@NMEKOFHC@Unhandled?5SET?5attribute?5?$CFd?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1846 :                sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1847 :                     file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	3
$LL1157@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1157@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1848 :                kb_error(2033,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2033					; 000007f1H
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN206@other_stuf:

; 1849 :                break;
; 1850 :    
; 1851 :            } /* end assigned SET_ATTRIBUTE_A */
; 1852 :          }
; 1853 :          break;
; 1854 : 
; 1855 :       /******************************/
; 1856 :       /* initializing element loops */
; 1857 :       /******************************/
; 1858 : 
; 1859 :     case INIT_VERTEX_NODE: /* all vertices */
; 1860 :            *(element_id *)++stacktop = q_id; /* save old element */

	mov	ecx, 8
	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi

; 1861 :            *(vertex_id*)++stacktop=web.skel[VERTEX].last; /* sentinel */

	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR _web+52
	mov	DWORD PTR [eax], edx

; 1862 :            *(element_id *)++stacktop = web.skel[VERTEX].used;

	add	DWORD PTR [ebx+48], ecx
	mov	ebx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR _web+48
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN205@other_stuf:

; 1863 :            break;
; 1864 : 
; 1865 :     case INIT_EDGE_VERTEX_NODE: /* edge endpoints */
; 1866 :            *(element_id *)++stacktop = q_id; /* save old element */

	mov	ecx, 8
	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi

; 1867 :            if ( node->op2.localnum ) 

	mov	edi, DWORD PTR [edi+136]
	test	edi, edi
	je	SHORT $LN204@other_stuf

; 1868 :               id = *(element_id*)get_localp(node->op2.localnum);

	mov	eax, DWORD PTR _localbase$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax]
	and	edi, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [edi*8]
	sub	edx, edi
	shl	edx, 5
	mov	edx, DWORD PTR [edx+eax+216]
	mov	eax, DWORD PTR _localstack$GSCopy$[ebp]
	mov	esi, DWORD PTR [eax+edx*8]
$LN204@other_stuf:

; 1869 :            else id = q_id;
; 1870 :  //          *(element_id *)++stacktop = id; /* save old element */
; 1871 :            *(int *)++stacktop = 0; /* element number */

	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], 0

; 1872 :            *(element_id **)++stacktop = get_edge_vertices(id);

	add	DWORD PTR [ebx+48], ecx
	mov	ecx, DWORD PTR _web+124
	mov	eax, DWORD PTR _web+216
	mov	ebx, DWORD PTR [ebx+48]
	and	esi, 134217727				; 07ffffffH
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _dymem
	add	edx, DWORD PTR [ecx+eax+304]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], edx
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN202@other_stuf:

; 1873 :            break;
; 1874 : 
; 1875 :     case INIT_FACET_VERTEX_NODE: /* facet vertices */
; 1876 :           *(element_id *)++stacktop = q_id; /* save old element */

	mov	ecx, 8
	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi

; 1877 :            if ( node->op2.localnum ) 

	mov	edi, DWORD PTR [edi+136]
	test	edi, edi
	je	SHORT $LN201@other_stuf

; 1878 :               id = *(element_id*)get_localp(node->op2.localnum);

	mov	eax, DWORD PTR _localbase$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax]
	and	edi, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [edi*8]
	sub	edx, edi
	shl	edx, 5
	mov	edx, DWORD PTR [edx+eax+216]
	mov	eax, DWORD PTR _localstack$GSCopy$[ebp]
	mov	esi, DWORD PTR [eax+edx*8]
$LN201@other_stuf:

; 1879 :            else id = q_id;
; 1880 : //           *(element_id *)++stacktop = id; /* save old element */
; 1881 :            if ( (web.representation == SIMPLEX) ||
; 1882 :                    (web.modeltype==LAGRANGE) || 
; 1883 :                 ((web.modeltype==QUADRATIC) && (web.representation==SOAPFILM)))

	mov	edx, DWORD PTR _web+624
	cmp	edx, 3
	je	SHORT $LN198@other_stuf
	mov	eax, DWORD PTR _web+628
	cmp	eax, 3
	je	SHORT $LN198@other_stuf
	cmp	eax, 2
	jne	SHORT $LN199@other_stuf
	cmp	edx, eax
	je	SHORT $LN198@other_stuf
$LN199@other_stuf:

; 1886 :            }
; 1887 :            else 
; 1888 :            { facetedge_id fe = get_facet_fe(id);

	push	esi
	call	_get_facet_fe
	add	esp, 4
	mov	edi, eax

; 1889 :              if ( inverted(id) && web.representation==STRING && valid_id(fe) ) 

	test	esi, 134217728				; 08000000H
	je	SHORT $LN193@other_stuf
	cmp	DWORD PTR _web+624, 1
	jne	SHORT $LN193@other_stuf
	test	edi, 268435456				; 10000000H
	je	SHORT $LN193@other_stuf

; 1890 :              { facetedge_id nextfe=fe,startfe=fe;

	mov	esi, edi
	npad	7
$LL195@other_stuf:

; 1891 :                /* go back round to find start */
; 1892 :                do
; 1893 :                { fe = nextfe;
; 1894 :                  nextfe = get_prev_edge(fe);

	push	eax
	mov	edi, eax
	call	_get_prev_edge
	add	esp, 4

; 1895 :                } while ( valid_id(nextfe) && !equal_id(nextfe,startfe) );

	test	eax, 268435456				; 10000000H
	je	SHORT $LN193@other_stuf
	cmp	eax, esi
	jne	SHORT $LL195@other_stuf
$LN193@other_stuf:

; 1896 :              }
; 1897 :              *(element_id *)++stacktop = fe; /* start */

	mov	ecx, 8
	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], edi

; 1898 :              *(element_id *)++stacktop = fe; /* current */

	add	DWORD PTR [ebx+48], ecx
	mov	ebx, DWORD PTR [ebx+48]
	mov	DWORD PTR [ebx], edi
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN198@other_stuf:

; 1884 :            { *(element_id *)++stacktop = 0 ; /* counter */

	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], 0

; 1885 :              *(element_id *)++stacktop = id ; /* facet */

	add	DWORD PTR [ebx+48], ecx
	mov	ebx, DWORD PTR [ebx+48]
	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN191@other_stuf:

; 1899 :            }
; 1900 :            break;
; 1901 : 
; 1902 :     case INIT_BODY_VERTEX_NODE: /* vertices on body */
; 1903 :            sprintf(errmsg,"Can't do body vertices yet.\n");

	push	OFFSET ??_C@_0BN@ELJFOBHK@Can?8t?5do?5body?5vertices?5yet?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1904 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1905 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL1158@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1158@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1906 :            kb_error(1214,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1214					; 000004beH
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN190@other_stuf:

; 1907 : 
; 1908 :            break;
; 1909 : 
; 1910 :     case INIT_EDGE_NODE: /* all edges */
; 1911 :            *(element_id *)++stacktop = q_id; /* save old element */

	mov	ecx, 8
	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi

; 1912 :            *(edge_id *)++stacktop = web.skel[EDGE].last; /* sentinel */

	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR _web+164
	mov	DWORD PTR [eax], edx

; 1913 :            *(element_id *)++stacktop = web.skel[EDGE].used;

	add	DWORD PTR [ebx+48], ecx
	mov	ebx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR _web+160
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN189@other_stuf:

; 1914 :            break;
; 1915 : 
; 1916 :     case INIT_VERTEX_EDGE_NODE:
; 1917 :            *(element_id *)++stacktop = q_id; /* save old element */

	mov	edx, 8
	add	DWORD PTR [ebx+48], edx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi

; 1918 :            if ( node->op2.localnum ) 

	mov	edi, DWORD PTR [edi+136]
	test	edi, edi
	je	SHORT $LN188@other_stuf

; 1919 :               id = *(element_id*)get_localp(node->op2.localnum);

	mov	eax, DWORD PTR _localbase$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax]
	and	edi, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	mov	eax, DWORD PTR _localstack$GSCopy$[ebp]
	mov	esi, DWORD PTR [eax+ecx*8]
$LN188@other_stuf:

; 1920 :            else id = q_id;
; 1921 : //           *(element_id *)++stacktop = id; /* save old element */
; 1922 :            if ( get_vattr(id) & Q_MIDFACET )

	mov	ecx, DWORD PTR _web+12
	and	esi, 134217727				; 07ffffffH
	add	esi, esi
	add	esi, esi
	mov	eax, DWORD PTR [esi+ecx]
	mov	eax, DWORD PTR [eax+8]

; 1923 :            { *(element_id *)++stacktop = NULLID;

	add	DWORD PTR [ebx+48], edx
	and	eax, 2097152				; 00200000H
	xor	ecx, ecx
	or	eax, ecx
	mov	eax, DWORD PTR [ebx+48]
	je	SHORT $LN186@other_stuf
	mov	DWORD PTR [eax], ecx

; 1924 :              *(element_id *)++stacktop = NULLID;

	add	DWORD PTR [ebx+48], edx
	mov	ebx, DWORD PTR [ebx+48]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], ecx
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN186@other_stuf:

; 1925 :            }
; 1926 :            else
; 1927 :            { *(element_id *)++stacktop = get_vertex_edge(id);

	mov	ecx, DWORD PTR _web+12
	mov	ecx, DWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax], ecx

; 1928 :              *(element_id *)++stacktop = get_vertex_edge(id);

	add	DWORD PTR [ebx+48], edx
	mov	edx, DWORD PTR _web+12
	mov	eax, DWORD PTR [esi+edx]
	mov	ebx, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax+28]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], ecx
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN184@other_stuf:

; 1929 :            }
; 1930 :            break;
; 1931 :            
; 1932 :     case INIT_FACET_EDGE_NODE:
; 1933 :            *(element_id *)++stacktop = q_id; /* save old element */

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi

; 1934 :            if ( node->op2.localnum ) 

	mov	edi, DWORD PTR [edi+136]
	test	edi, edi
	je	SHORT $LN183@other_stuf

; 1935 :               id = *(element_id*)get_localp(node->op2.localnum);

	mov	eax, DWORD PTR _localbase$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _localstack$GSCopy$[ebp]
	and	edi, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [edi*8]
	sub	edx, edi
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	mov	esi, DWORD PTR [eax+edx*8]
$LN183@other_stuf:

; 1936 :            else id = q_id;
; 1937 : //           *(element_id *)++stacktop = id; /* save old element */
; 1938 :            if ( web.representation == STRING )

	cmp	DWORD PTR _web+624, 1

; 1939 :            { facetedge_id fe = get_facet_fe(id);

	push	esi
	jne	SHORT $LN181@other_stuf
	call	_get_facet_fe
	add	esp, 4
	mov	edi, eax

; 1940 :              if ( inverted(id) && valid_id(fe) ) 

	test	esi, 134217728				; 08000000H
	je	$LN193@other_stuf
	test	edi, 268435456				; 10000000H
	je	$LN193@other_stuf

; 1941 :              { facetedge_id nextfe=fe,startfe=fe;

	mov	esi, edi
	npad	2
$LL179@other_stuf:

; 1942 :                /* go back round to find start */
; 1943 :                do
; 1944 :                { fe = nextfe;
; 1945 :                  nextfe = get_prev_edge(fe);

	push	eax
	mov	edi, eax
	call	_get_prev_edge
	add	esp, 4

; 1946 :                } while ( valid_id(nextfe) && !equal_id(nextfe,startfe) );

	test	eax, 268435456				; 10000000H
	je	$LN193@other_stuf
	cmp	eax, esi
	jne	SHORT $LL179@other_stuf

; 1947 :              }
; 1948 :              *(element_id *)++stacktop = fe; /* start */
; 1949 :              *(element_id *)++stacktop = fe;
; 1950 :            }
; 1951 :            else

	jmp	$LN193@other_stuf
$LN181@other_stuf:

; 1952 :            { *(int *)++stacktop = 0; /* counter */

	mov	ecx, 8
	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], 0

; 1953 :              *(element_id *)++stacktop = get_facet_fe(id);

	add	DWORD PTR [ebx+48], ecx
	mov	ebx, DWORD PTR [ebx+48]
	call	_get_facet_fe
	add	esp, 4
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN174@other_stuf:

; 1954 :            }
; 1955 :            break;
; 1956 :            
; 1957 :     case INIT_BODY_EDGE_NODE:
; 1958 :            sprintf(errmsg,"Can't do body edges yet.\n");

	push	OFFSET ??_C@_0BK@NEDLACAF@Can?8t?5do?5body?5edges?5yet?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 1959 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 1960 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL1159@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1159@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 1961 :            kb_error(1215,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1215					; 000004bfH
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN173@other_stuf:

; 1962 :            break;
; 1963 : 
; 1964 :     case INIT_FACET_NODE: /* all facets */
; 1965 :            *(element_id *)++stacktop = q_id; /* save old element */

	mov	ecx, 8
	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi

; 1966 :            *(facet_id *)++stacktop = web.skel[FACET].last; /* sentinel */

	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR _web+276
	mov	DWORD PTR [eax], edx

; 1967 :            *(element_id *)++stacktop = web.skel[FACET].used;

	add	DWORD PTR [ebx+48], ecx
	mov	ebx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR _web+272
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN172@other_stuf:

; 1968 :            break;
; 1969 : 
; 1970 :     case INIT_VERTEX_FACET_NODE:
; 1971 :  //       *(element_id *)++stacktop = q_id; /* save old element */
; 1972 :          if ( node->op2.localnum ) 

	mov	edi, DWORD PTR [edi+136]
	test	edi, edi
	je	SHORT $LN171@other_stuf

; 1973 :               id = *(element_id*)get_localp(node->op2.localnum);

	mov	edx, DWORD PTR _localbase$GSCopy$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _localstack$GSCopy$[ebp]
	and	edi, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	mov	esi, DWORD PTR [edx+ecx*8]
$LN171@other_stuf:

; 1974 :          else id = q_id;
; 1975 : //         *(element_id *)++stacktop = id; /* save old element */
; 1976 :          *(element_id *)++stacktop = id;  //save the vertex

	mov	edi, 8
	add	DWORD PTR [ebx+48], edi
	mov	eax, DWORD PTR [ebx+48]

; 1977 :          *(element_id *)++stacktop = f_id = get_vertex_first_facet(id); 

	push	esi
	mov	DWORD PTR [eax], esi
	call	_get_vertex_first_facet
	add	DWORD PTR [ebx+48], edi
	mov	ecx, DWORD PTR [ebx+48]
	add	esp, 4
	mov	DWORD PTR [ecx], eax

; 1978 :          *(element_id *)++stacktop = f_id; 

	add	DWORD PTR [ebx+48], edi
	mov	ebx, DWORD PTR [ebx+48]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN169@other_stuf:

; 1979 :          break;
; 1980 : 
; 1981 :     case INIT_FACETEDGE_EDGE_NODE:
; 1982 :           *(element_id *)++stacktop = q_id; /* save old element */

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi

; 1983 :            if ( node->op2.localnum ) 

	mov	edi, DWORD PTR [edi+136]
	test	edi, edi
	je	SHORT $LN168@other_stuf

; 1984 :               id = *(element_id*)get_localp(node->op2.localnum);

	mov	ecx, DWORD PTR _localbase$GSCopy$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _localstack$GSCopy$[ebp]
	and	edi, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	shl	eax, 5
	mov	eax, DWORD PTR [eax+edx+216]
	mov	esi, DWORD PTR [ecx+eax*8]
$LN168@other_stuf:

; 1985 :            else id = q_id;
; 1986 : //           *(element_id *)++stacktop = id; /* save old element */
; 1987 :            *(element_id *)++stacktop = get_fe_edge(id); /* start */

	add	DWORD PTR [ebx+48], 8
	mov	edi, DWORD PTR [ebx+48]
	push	esi
	call	_get_fe_edge
	mov	DWORD PTR [edi], eax

; 1988 :            *(element_id *)++stacktop = get_fe_edge(id);

	add	DWORD PTR [ebx+48], 8
	mov	ebx, DWORD PTR [ebx+48]
	push	esi
	call	_get_fe_edge
	add	esp, 8
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN166@other_stuf:

; 1989 :            break;
; 1990 : 
; 1991 :     case INIT_FACETEDGE_FACET_NODE:
; 1992 :            *(element_id *)++stacktop = q_id; /* save old element */

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi

; 1993 :            if ( node->op2.localnum ) 

	mov	edi, DWORD PTR [edi+136]
	test	edi, edi
	je	SHORT $LN165@other_stuf

; 1994 :               id = *(element_id*)get_localp(node->op2.localnum);

	mov	eax, DWORD PTR _localbase$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _localstack$GSCopy$[ebp]
	and	edi, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [edi*8]
	sub	edx, edi
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	mov	esi, DWORD PTR [eax+edx*8]
$LN165@other_stuf:

; 1995 :            else id = q_id;
; 1996 : //           *(element_id *)++stacktop = id; /* save old element */
; 1997 :            *(element_id *)++stacktop = get_fe_facet(id); /* start */

	add	DWORD PTR [ebx+48], 8
	mov	edi, DWORD PTR [ebx+48]
	push	esi
	call	_get_fe_facet
	mov	DWORD PTR [edi], eax

; 1998 :            *(element_id *)++stacktop = get_fe_facet(id);

	add	DWORD PTR [ebx+48], 8
	mov	ebx, DWORD PTR [ebx+48]
	push	esi
	call	_get_fe_facet
	add	esp, 8
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN163@other_stuf:

; 1999 :            break;
; 2000 : 
; 2001 :     case INIT_EDGE_FACET_NODE:
; 2002 :            *(element_id *)++stacktop = q_id; /* save old element */

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi

; 2003 :           if ( node->op2.localnum ) 

	mov	edi, DWORD PTR [edi+136]
	test	edi, edi
	je	SHORT $LN162@other_stuf

; 2004 :               id = *(element_id*)get_localp(node->op2.localnum);

	mov	edx, DWORD PTR _localbase$GSCopy$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _localstack$GSCopy$[ebp]
	and	edi, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	mov	esi, DWORD PTR [edx+ecx*8]
$LN162@other_stuf:

; 2005 :            else id = q_id;
; 2006 : //           *(element_id *)++stacktop = id; /* save old element */
; 2007 :            *(element_id *)++stacktop = get_edge_fe(id); /* start */

	add	DWORD PTR [ebx+48], 8
	mov	edi, DWORD PTR [ebx+48]
	push	esi
	call	_get_edge_fe
	mov	DWORD PTR [edi], eax

; 2008 :            *(element_id *)++stacktop = get_edge_fe(id);

	add	DWORD PTR [ebx+48], 8
	mov	ebx, DWORD PTR [ebx+48]
	push	esi
	call	_get_edge_fe
	add	esp, 8
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN160@other_stuf:

; 2009 :            break;
; 2010 : 
; 2011 :     case INIT_EDGE_FACETEDGE_NODE:
; 2012 :           *(element_id *)++stacktop = q_id; /* save old element */

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi

; 2013 :           if ( node->op2.localnum ) 

	mov	edi, DWORD PTR [edi+136]
	test	edi, edi
	je	SHORT $LN162@other_stuf

; 2014 :               id = *(element_id*)get_localp(node->op2.localnum);

	mov	ecx, DWORD PTR _localbase$GSCopy$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _localstack$GSCopy$[ebp]
	and	edi, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	shl	eax, 5
	mov	eax, DWORD PTR [eax+edx+216]
	mov	esi, DWORD PTR [ecx+eax*8]

; 2015 :            else id = q_id;
; 2016 : //           *(element_id *)++stacktop = id; /* save old element */
; 2017 :            *(element_id *)++stacktop = get_edge_fe(id); /* start */
; 2018 :            *(element_id *)++stacktop = get_edge_fe(id);
; 2019 :            break;

	jmp	SHORT $LN162@other_stuf
$LN157@other_stuf:

; 2020 : 
; 2021 :     case INIT_BODY_FACET_NODE:
; 2022 :            if ( node->op2.localnum ) 

	mov	eax, DWORD PTR [edi+136]
	test	eax, eax
	je	SHORT $LN156@other_stuf

; 2023 :               id = *(element_id*)get_localp(node->op2.localnum);

	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _localstack$GSCopy$[ebp]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+ecx+216]
	mov	ecx, DWORD PTR [eax+edx*8]
	jmp	SHORT $LN155@other_stuf
$LN156@other_stuf:

; 2024 :            else id = q_id;

	mov	ecx, esi
$LN155@other_stuf:

; 2025 :            *(element_id *)++stacktop = q_id; /* save old element */

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]

; 2026 :            f_id =  get_body_facet(id);

	push	ecx
	mov	DWORD PTR [eax], esi
	call	_get_body_facet

; 2027 :            *(element_id *)++stacktop = f_id;

	mov	edx, 8
	add	DWORD PTR [ebx+48], edx
	mov	ecx, DWORD PTR [ebx+48]
	mov	DWORD PTR [ecx], eax

; 2028 :            *(element_id *)++stacktop = f_id;

	add	DWORD PTR [ebx+48], edx
	mov	ebx, DWORD PTR [ebx+48]
	add	esp, 4
	mov	DWORD PTR _f_id$[ebp], eax
	mov	DWORD PTR [ebx], eax

; 2029 :            /* kludge to make things work in the face of arbitrary deletions. */
; 2030 :            if ( valid_id(f_id) )

	test	eax, 268435456				; 10000000H
	je	$LN855@other_stuf

; 2031 :            { facet_id start_f = f_id;
; 2032 :              int counter = 0;
; 2033 :              int maxcount = 2*web.skel[FACET].count;

	mov	ecx, DWORD PTR _web+288
	mov	ebx, eax
	lea	edx, DWORD PTR [ecx+ecx]
	mov	DWORD PTR _start_f$91432[ebp], ebx
	mov	DWORD PTR _counter$91433[ebp], 0
	mov	DWORD PTR _maxcount$91434[ebp], edx
$LL153@other_stuf:

; 2034 :              do
; 2035 :              { f_id = get_next_body_facet(f_id);

	push	ebx
	call	_get_next_body_facet

; 2036 :                unset_attr(f_id,DID_BODYFRONTFACET|DID_BODYBACKFACET);

	push	0
	mov	ebx, eax
	push	1572864					; 00180000H
	push	ebx
	call	_unset_attr

; 2037 :                if ( counter++ > maxcount )

	mov	eax, DWORD PTR _counter$91433[ebp]
	mov	ecx, eax
	inc	eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _counter$91433[ebp], eax
	cmp	ecx, DWORD PTR _maxcount$91434[ebp]
	jle	$LN152@other_stuf

; 2038 :                { sprintf(errmsg,"Internal error: Body %s facet list is not closed.\n",
; 2039 :                       ELNAME(q_id));

	test	esi, 268435456				; 10000000H
	je	SHORT $LN971@other_stuf
	mov	edx, esi
	and	edx, 134217727				; 07ffffffH
	inc	edx
	push	edx
	push	OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	OFFSET _elnames
	call	_sprintf
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET _elnames
	jmp	SHORT $LN972@other_stuf
$LN971@other_stuf:
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN972@other_stuf:
	push	eax
	push	OFFSET ??_C@_0DD@COJNEPDA@Internal?5error?3?5Body?5?$CFs?5facet?5li@
	push	OFFSET _errmsg
	call	_sprintf

; 2040 :                  sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2041 :                                 file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1160@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1160@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 2042 :                  kb_error(4376,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	4376					; 00001118H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN152@other_stuf:

; 2043 :                }
; 2044 :              } while ( !equal_id(f_id,start_f) );

	cmp	ebx, DWORD PTR _start_f$91432[ebp]
	jne	$LL153@other_stuf

; 2045 :              set_attr(f_id,(inverted(f_id)?DID_BODYBACKFACET:DID_BODYFRONTFACET));

	xor	ecx, ecx
	mov	eax, 1048576				; 00100000H
	test	ebx, 134217728				; 08000000H
	jne	SHORT $LN974@other_stuf
	mov	eax, 524288				; 00080000H
$LN974@other_stuf:
	push	ecx
	push	eax
	push	ebx
	call	_set_attr
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN149@other_stuf:

; 2046 :            }
; 2047 :            break;
; 2048 : 
; 2049 :     case INIT_BODY_NODE: /* all bodies */
; 2050 :            *(element_id *)++stacktop = q_id; /* save old element */

	mov	ecx, 8
	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi

; 2051 :            *(body_id *)++stacktop = web.skel[BODY].last; /* sentinel */

	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR _web+388
	mov	DWORD PTR [eax], edx

; 2052 :            *(element_id *)++stacktop = web.skel[BODY].used;

	add	DWORD PTR [ebx+48], ecx
	mov	ebx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR _web+384
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN148@other_stuf:

; 2053 :            break;
; 2054 : 
; 2055 :     case INIT_FACET_BODY_NODE: 
; 2056 :            if ( node->op2.localnum ) 

	mov	edi, DWORD PTR [edi+136]
	test	edi, edi
	je	SHORT $LN147@other_stuf

; 2057 :               id = *(element_id*)get_localp(node->op2.localnum);

	mov	edx, DWORD PTR _localbase$GSCopy$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _localstack$GSCopy$[ebp]
	and	edi, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	shl	ecx, 5
	mov	ecx, DWORD PTR [ecx+eax+216]
	mov	esi, DWORD PTR [edx+ecx*8]
$LN147@other_stuf:

; 2058 :            else id = q_id;
; 2059 :            *(element_id *)++stacktop = id; /* save old element */

	mov	ecx, 8
	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi

; 2060 :            *(int *)++stacktop = 0; /* element number */

	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], 0

; 2061 :            *(element_id *)++stacktop = NULLID;

	add	DWORD PTR [ebx+48], ecx
	mov	ebx, DWORD PTR [ebx+48]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], 0
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN145@other_stuf:

; 2062 :            break;
; 2063 : 
; 2064 :     case INIT_VERTEX_BODY_NODE:
; 2065 :            sprintf(errmsg,"Can't do vertex bodies yet.\n");

	push	OFFSET ??_C@_0BN@MDLPGBBO@Can?8t?5do?5vertex?5bodies?5yet?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 2066 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2067 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1161@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1161@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 2068 :            kb_error(1216,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1216					; 000004c0H
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN144@other_stuf:

; 2069 :            break;
; 2070 : 
; 2071 :     case INIT_EDGE_BODY_NODE:
; 2072 :            sprintf(errmsg,"Can't do edge bodies yet.\n");

	push	OFFSET ??_C@_0BL@HJMLIBGL@Can?8t?5do?5edge?5bodies?5yet?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 2073 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2074 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL1162@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1162@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 2075 :            kb_error(1217,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1217					; 000004c1H
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN143@other_stuf:

; 2076 :            break;
; 2077 : 
; 2078 :     case INIT_FACETEDGE_NODE: /* all edges */
; 2079 :            *(element_id *)++stacktop = q_id; /* save old element */

	mov	ecx, 8
	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi

; 2080 :            *(edge_id *)++stacktop = web.skel[FACETEDGE].last; /* sentinel */

	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR _web+500
	mov	DWORD PTR [eax], edx

; 2081 :            *(element_id *)++stacktop = web.skel[FACETEDGE].used;

	add	DWORD PTR [ebx+48], ecx
	mov	ebx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR _web+496
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx], eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN142@other_stuf:

; 2082 :            break;
; 2083 : 
; 2084 :     case SINGLE_ELEMENT_INIT_NODE: 
; 2085 :            *(element_id *)++stacktop = q_id; /* save old element */
; 2086 :            *(++stacktop) = 0.0 ; /* iteration count */

	fldz
	mov	ecx, 8
	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], esi
	add	DWORD PTR [ebx+48], ecx
	mov	eax, DWORD PTR [ebx+48]

; 2087 :            stacktop++;  /* dummy local to pop */

	add	DWORD PTR [ebx+48], ecx
	fstp	QWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN140@other_stuf:

; 2088 :            break;
; 2089 : 
; 2090 : 
; 2091 :     /*******************/
; 2092 :     /* simple commands */
; 2093 :     /*******************/
; 2094 : 
; 2095 :     case NOP_NODE:
; 2096 :     case NULLBLOCK_NODE:
; 2097 :     case NULLCMD_NODE:
; 2098 :         break;
; 2099 : 
; 2100 :     case DEFINE_EXTRA_NODE:
; 2101 :        { int one = 1; 
; 2102 :          struct extra *ex = EXTRAS(node->op2.eltype) + node->op1.extranum;

	mov	eax, DWORD PTR [edi+136]
	mov	edi, DWORD PTR [edi+32]
	mov	edx, edi
	imul	edx, 240				; 000000f0H
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 4
	mov	esi, DWORD PTR _web[ecx+104]
	add	esi, edx
	add	esi, DWORD PTR _dymem
	mov	ebx, 1
	mov	DWORD PTR _one$91470[ebp], ebx

; 2103 :          if ( ex->array_spec.dim == 0 )

	cmp	DWORD PTR [esi+76], 0
	jne	$LN855@other_stuf

; 2104 :          { expand_attribute(node->op2.eltype,node->op1.extranum,&one);

	lea	ecx, DWORD PTR _one$91470[ebp]
	push	ecx
	push	edi
	push	eax
	call	_expand_attribute
	add	esp, 12					; 0000000cH

; 2105 :            ex->array_spec.datacount = 1;
; 2106 :            ex->flags &= ~DIMENSIONED_ATTR;

	and	DWORD PTR [esi+232], -5			; fffffffbH
	pop	edi
	mov	DWORD PTR [esi+88], ebx
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN138@other_stuf:

; 2107 :          }
; 2108 :          break;
; 2109 :        }
; 2110 : 
; 2111 :     case DEFINE_EXTRA_INDEX_NODE:  /* have indexes tacked onto DEFINE_EXTRA_ */
; 2112 :        { int newsizes[MAXARRAYDIMS];
; 2113 :          struct extra *ex = EXTRAS(node->op2.eltype) + node->op1.extranum;

	mov	eax, DWORD PTR [edi+136]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [edi+32]
	imul	eax, 240				; 000000f0H
	shl	edx, 4

; 2114 :          for ( k = ex->array_spec.dim-1 ; k >= 0 ; k-- ) 

	mov	ecx, DWORD PTR _web[edx+104]
	mov	edx, DWORD PTR _dymem
	add	ecx, eax
	mov	esi, DWORD PTR [ecx+edx+76]
	dec	esi
	js	SHORT $LN135@other_stuf
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR tv4401[ebp], eax
$LL1212@other_stuf:

; 2115 :            newsizes[k] = (int)*(stacktop--);

	mov	ecx, DWORD PTR tv4401[ebp]
	fld	QWORD PTR [ecx]
	call	__ftol2_sse
	sub	DWORD PTR tv4401[ebp], 8
	dec	esi
	mov	DWORD PTR _newsizes$91475[ebp+esi*4+4], eax
	jns	SHORT $LL1212@other_stuf

; 2114 :          for ( k = ex->array_spec.dim-1 ; k >= 0 ; k-- ) 

	mov	edx, DWORD PTR tv4401[ebp]
	mov	DWORD PTR [ebx+48], edx
$LN135@other_stuf:

; 2116 :          expand_attribute(node->op2.eltype,node->op1.extranum,newsizes);

	mov	ecx, DWORD PTR [edi+32]
	mov	edx, DWORD PTR [edi+136]
	lea	eax, DWORD PTR _newsizes$91475[ebp]
	push	eax
	push	ecx
	push	edx
	call	_expand_attribute
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN134@other_stuf:

; 2117 :          break;
; 2118 :        }
; 2119 : 
; 2120 :     case HISTORY_NODE:
; 2121 :         if ( history_space == NULL ) { outstring("No history.\n"); break;}

	cmp	DWORD PTR _history_space, 0
	jne	SHORT $LN133@other_stuf
	push	OFFSET ??_C@_0N@MHAJCLKO@No?5history?4?6?$AA@
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN133@other_stuf:

; 2122 :         for ( k = history_count-1 ; k >= 0 ; k-- )

	mov	edi, DWORD PTR _history_count
	dec	edi
	js	$LN855@other_stuf
	npad	9
$LL1178@other_stuf:

; 2123 :           { h = history_space+history_offsets[k];
; 2124 :             sprintf(msg,"%d) ",history_number-k); outstring(msg);

	mov	eax, DWORD PTR _history_number
	mov	ecx, DWORD PTR _msg
	mov	esi, DWORD PTR _history_offsets[edi*4]
	add	esi, DWORD PTR _history_space
	sub	eax, edi
	push	eax
	push	OFFSET ??_C@_04CGKAJBAP@?$CFd?$CJ?5?$AA@
	push	ecx
	call	_sprintf
	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring

; 2125 :             outstring(h);

	push	esi
	call	_outstring
	add	esp, 20					; 00000014H
	dec	edi
	jns	SHORT $LL1178@other_stuf
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN129@other_stuf:

; 2126 :           }
; 2127 :           break;
; 2128 : 
; 2129 :     case REDIRECT_NODE:
; 2130 :     case REDIRECTOVER_NODE:
; 2131 : #ifdef __L_EVOLVER__
; 2132 : 		   if (l_evolver_mode)

	cmp	DWORD PTR _l_evolver_mode, 0
	je	SHORT $LN128@other_stuf

; 2133 : 		   {
; 2134 : 			   l_redirect = TRUE;

	mov	DWORD PTR _l_redirect, 1

; 2135 : 			   l_evolver_mode = FALSE;

	mov	DWORD PTR _l_evolver_mode, 0
$LN128@other_stuf:

; 2136 : 		   }
; 2137 : #endif
; 2138 :         { struct stat st;
; 2139 :            int retval;
; 2140 :            flush_counts(); // so don't get into redirected output

	call	_flush_counts

; 2141 :            if ( node->left ) s = *(char**)(stacktop--);

	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN127@other_stuf
	mov	eax, DWORD PTR [ebx+48]
	mov	esi, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	jmp	SHORT $LN126@other_stuf
$LN127@other_stuf:

; 2142 :            else s = node->op1.string;

	mov	esi, DWORD PTR [edi+32]
$LN126@other_stuf:

; 2143 :            *(FILE **)(++stacktop) = outfd;

	add	DWORD PTR [ebx+48], 8
	mov	ebx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR _outfd

; 2144 :            retval = stat(s,&st);

	lea	ecx, DWORD PTR _st$91492[ebp]
	push	ecx
	push	esi
	mov	DWORD PTR [ebx], eax
	call	__stat64i32

; 2145 :            outfd = NULL;

	xor	ebx, ebx
	add	esp, 8
	mov	DWORD PTR _outfd, ebx

; 2146 :            if ( ((retval == 0) && (st.st_mode & S_IFIFO)) 
; 2147 :             || (node->type==REDIRECTOVER_NODE) )

	cmp	eax, ebx
	jne	SHORT $LN123@other_stuf
	test	DWORD PTR _st$91492[ebp+6], 4096	; 00001000H
	jne	SHORT $LN124@other_stuf
$LN123@other_stuf:
	cmp	DWORD PTR [edi], 10482			; 000028f2H
	jne	SHORT $LN125@other_stuf
$LN124@other_stuf:

; 2148 :               outfd = fopen(s,"w");

	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	jmp	SHORT $LN1600@other_stuf
$LN125@other_stuf:

; 2149 :            else outfd = fopen(s,"a");

	push	OFFSET ??_C@_01MCMALHOG@a?$AA@
$LN1600@other_stuf:
	push	esi
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _outfd, eax

; 2150 :            if ( outfd == NULL )

	cmp	eax, ebx
	jne	$LN121@other_stuf

; 2161 : 			   erroutstring(s);

	push	esi
	cmp	DWORD PTR _l_redirect, ebx
	je	SHORT $LN120@other_stuf

; 2151 :            { 
; 2152 : #ifdef MAC_APP
; 2153 :              sprintf(errmsg,"Cannot open file %s. \n",s);
; 2154 : #else
; 2155 : 	#ifdef __L_EVOLVER__
; 2156 : 		   /* If redirection failed and file layer mode was active restore functionality */
; 2157 : 		   if (l_redirect)
; 2158 : 		   {
; 2159 : 			   l_redirect = FALSE;
; 2160 : 			   l_evolver_mode = TRUE;

	mov	DWORD PTR _l_redirect, ebx
	mov	DWORD PTR _l_evolver_mode, 1

; 2161 : 			   erroutstring(s);

	call	_erroutstring

; 2162 : 			   erroutstring("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_erroutstring
	add	esp, 8

; 2163 : 		   }
; 2164 : 		   else

	jmp	SHORT $LN119@other_stuf
$LN120@other_stuf:

; 2165 : 			   perror(s);

	call	_perror
	add	esp, 4
$LN119@other_stuf:

; 2166 : 	#else
; 2167 :              perror(s);
; 2168 : 	#endif
; 2169 : 
; 2170 :              sprintf(errmsg,"Cannot open redirection file %s.\n",s);

	push	esi
	push	OFFSET ??_C@_0CC@OOOIOPJB@Cannot?5open?5redirection?5file?5?$CFs?4@
	push	OFFSET _errmsg
	call	_sprintf

; 2171 : #endif
; 2172 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2173 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1163@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1163@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2174 :              kb_error(1218,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1218					; 000004c2H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN121@other_stuf:

; 2175 : 
; 2176 :             }
; 2177 :            if ( node->left && (node[node->left].flags & DEALLOCATE_POINTER) )

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, ebx
	je	$LN855@other_stuf
	imul	eax, 168				; 000000a8H
	test	DWORD PTR [eax+edi+24], 1024		; 00000400H
	je	$LN855@other_stuf

; 2178 :              myfree(s);

	push	esi
	call	_myfree
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN117@other_stuf:

; 2179 :           }
; 2180 :            break;
; 2181 : 
; 2182 :     case REDIRECT_END_NODE:
; 2183 :            fclose(outfd);

	mov	eax, DWORD PTR _outfd
	push	eax
	call	_fclose
	add	esp, 4

; 2184 :            /* outfd = stdout; */
; 2185 : #ifdef __L_EVOLVER__
; 2186 : 		   if (l_redirect)

	cmp	DWORD PTR _l_redirect, 0
	je	SHORT $LN116@other_stuf

; 2187 : 		   {
; 2188 : 			   l_redirect = FALSE;

	mov	DWORD PTR _l_redirect, 0

; 2189 : 			   l_evolver_mode = TRUE;

	mov	DWORD PTR _l_evolver_mode, 1
$LN116@other_stuf:

; 2190 : 		   }
; 2191 : 
; 2192 : 
; 2193 : 
; 2194 : 
; 2195 : 
; 2196 : 
; 2197 : 
; 2198 : 
; 2199 : 
; 2200 : 
; 2201 : 
; 2202 : 
; 2203 : 
; 2204 : 
; 2205 : 
; 2206 : 
; 2207 : 
; 2208 : 
; 2209 : 
; 2210 : 
; 2211 : 
; 2212 : 
; 2213 : 
; 2214 : 
; 2215 : #endif
; 2216 :            outfd = *(FILE**)(stacktop--);

	mov	ecx, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [ecx]
	pop	edi
	mov	DWORD PTR _outfd, edx
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN115@other_stuf:

; 2217 :            break;
; 2218 : 
; 2219 :     case REDIRECT_ERR_NODE:
; 2220 :     case REDIRECTOVER_ERR_NODE:
; 2221 :         { struct stat st;
; 2222 :            int retval;
; 2223 :            flush_counts(); // so don't get into redirected output

	call	_flush_counts

; 2224 :            if ( node->left ) s = *(char**)(stacktop--);

	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN114@other_stuf
	mov	eax, DWORD PTR [ebx+48]
	mov	esi, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	jmp	SHORT $LN113@other_stuf
$LN114@other_stuf:

; 2225 :            else s = node->op1.string;

	mov	esi, DWORD PTR [edi+32]
$LN113@other_stuf:

; 2226 :            *(FILE **)(++stacktop) = erroutfd;

	add	DWORD PTR [ebx+48], 8
	mov	ebx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR _erroutfd

; 2227 :            retval = stat(s,&st);

	lea	ecx, DWORD PTR _st$91516[ebp]
	push	ecx
	push	esi
	mov	DWORD PTR [ebx], eax
	call	__stat64i32
	add	esp, 8

; 2228 :            erroutfd = NULL;

	mov	DWORD PTR _erroutfd, 0

; 2229 :            if ( ((retval == 0) && (st.st_mode & S_IFIFO)) 
; 2230 :             || (node->type==REDIRECTOVER_NODE) )

	test	eax, eax
	jne	SHORT $LN110@other_stuf
	test	DWORD PTR _st$91516[ebp+6], 4096	; 00001000H
	jne	SHORT $LN111@other_stuf
$LN110@other_stuf:
	cmp	DWORD PTR [edi], 10482			; 000028f2H
	jne	SHORT $LN112@other_stuf
$LN111@other_stuf:

; 2231 :               erroutfd = fopen(s,"w");

	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	jmp	SHORT $LN1601@other_stuf
$LN112@other_stuf:

; 2232 :            else erroutfd = fopen(s,"a");

	push	OFFSET ??_C@_01MCMALHOG@a?$AA@
$LN1601@other_stuf:
	push	esi
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _erroutfd, eax

; 2233 :            if ( erroutfd == NULL )

	test	eax, eax
	jne	SHORT $LN108@other_stuf

; 2234 :            { erroutfd = stderr;

	call	___iob_func
	add	eax, 64					; 00000040H

; 2235 : #ifdef MAC_APP
; 2236 :              sprintf(errmsg,"Cannot open file %s. \n",s);
; 2237 : #else
; 2238 :              perror(s);

	push	esi
	mov	DWORD PTR _erroutfd, eax
	call	_perror

; 2239 :              sprintf(errmsg,"Cannot open redirection file %s.\n",s);

	push	esi
	push	OFFSET ??_C@_0CC@OOOIOPJB@Cannot?5open?5redirection?5file?5?$CFs?4@
	push	OFFSET _errmsg
	call	_sprintf

; 2240 : #endif
; 2241 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2242 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL1164@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1164@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2243 :              kb_error(5218,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	5218					; 00001462H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN108@other_stuf:

; 2244 : 
; 2245 :             }
; 2246 :            if ( node->left && (node[node->left].flags & DEALLOCATE_POINTER) )

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	$LN855@other_stuf
	imul	eax, 168				; 000000a8H
	test	DWORD PTR [eax+edi+24], 1024		; 00000400H
	je	$LN855@other_stuf

; 2247 :              myfree(s);

	push	esi
	call	_myfree
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN106@other_stuf:

; 2248 :           }
; 2249 :            break;
; 2250 : 
; 2251 :     case REDIRECT_ERR_END_NODE:
; 2252 :            fclose(erroutfd);

	mov	eax, DWORD PTR _erroutfd
	push	eax
	call	_fclose

; 2253 :            erroutfd = *(FILE**)(stacktop--);

	mov	ecx, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [ecx]
	add	esp, 4
	pop	edi
	mov	DWORD PTR _erroutfd, edx
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN105@other_stuf:

; 2254 :            break;
; 2255 : 
; 2256 :     case PIPE_NODE:
; 2257 :            if ( node->left ) s = *(char**)(stacktop--);

	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN104@other_stuf
	mov	eax, DWORD PTR [ebx+48]
	mov	esi, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	jmp	SHORT $LN103@other_stuf
$LN104@other_stuf:

; 2258 :            else s = node->op1.string;

	mov	esi, DWORD PTR [edi+32]
$LN103@other_stuf:

; 2259 :            *(FILE **)(++stacktop) = outfd;

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR _outfd
	mov	DWORD PTR [eax], ecx

; 2260 :            if ( s[0] == '+' )  /* kludge to permit appending to file */

	cmp	BYTE PTR [esi], 43			; 0000002bH
	jne	SHORT $LN102@other_stuf

; 2261 :            outfd = fopen(s+1,"a+");

	lea	edx, DWORD PTR [esi+1]
	push	OFFSET ??_C@_02DPNLHKJD@a?$CL?$AA@
	push	edx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _outfd, eax
$LN102@other_stuf:

; 2262 : #ifdef NOPIPE
; 2263 :            else
; 2264 :            outfd = fopen(s,"w");
; 2265 : #else
; 2266 :            outfd = popen(s,"w");

	push	OFFSET ??_C@_01NOFIACDB@w?$AA@
	push	esi
	call	__popen
	add	esp, 8
	mov	DWORD PTR _outfd, eax

; 2267 : #endif
; 2268 :            if ( outfd == NULL )

	test	eax, eax
	jne	$LN101@other_stuf

; 2269 :               { 
; 2270 :                 outfd = *(FILE**)(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _outfd, ecx
	add	DWORD PTR [ebx+48], -8			; fffffff8H

; 2271 : #ifdef MAC_APP
; 2272 :                 sprintf(errmsg,"Cannot open pipe %s. \n",s);
; 2273 : #else
; 2274 : 	#ifdef __L_EVOLVER__
; 2275 : 		   if (l_redirect||l_evolver_mode)

	cmp	DWORD PTR _l_redirect, 0
	jne	SHORT $LN99@other_stuf
	cmp	DWORD PTR _l_evolver_mode, 0
	jne	SHORT $LN99@other_stuf

; 2281 : 		   }
; 2282 : 		   else
; 2283 : 			   perror(s);

	push	esi
	call	_perror
	add	esp, 4
	jmp	SHORT $LN98@other_stuf
$LN99@other_stuf:

; 2276 : 		   {
; 2277 : 			   //l_redirect = FALSE;
; 2278 : 			   //l_evolver_mode = TRUE;
; 2279 : 			   erroutstring(s);

	push	esi
	call	_erroutstring

; 2280 : 			   erroutstring("\n");

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_erroutstring
	add	esp, 8
$LN98@other_stuf:

; 2284 : 	#else
; 2285 :              perror(s);
; 2286 : 	#endif
; 2287 :           
; 2288 : 
; 2289 :                 sprintf(errmsg,"Cannot open pipe %s.\n",s);

	push	esi
	push	OFFSET ??_C@_0BG@OELPOHFE@Cannot?5open?5pipe?5?$CFs?4?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 2290 : #endif
; 2291 :                 sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2292 :                      file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1165@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1165@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2293 :                 kb_error(1219,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1219					; 000004c3H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN101@other_stuf:

; 2294 : 
; 2295 :               }
; 2296 :            if ( node->left && (node[node->left].flags & DEALLOCATE_POINTER) )

	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN97@other_stuf
	imul	eax, 168				; 000000a8H
	test	DWORD PTR [eax+edi+24], 1024		; 00000400H
	je	SHORT $LN97@other_stuf

; 2297 :              myfree(s);

	push	esi
	call	_myfree
	add	esp, 4
$LN97@other_stuf:

; 2298 :            broken_pipe_flag = 0; /* reset */

	pop	edi
	pop	esi
	mov	DWORD PTR _broken_pipe_flag, 0
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN96@other_stuf:

; 2299 :            break;
; 2300 :  
; 2301 :     case PIPE_END_NODE:
; 2302 : #ifdef NOPIPE
; 2303 :            fclose(outfd);
; 2304 : #else
; 2305 :            pclose(outfd);

	mov	eax, DWORD PTR _outfd
	push	eax
	call	__pclose

; 2306 : #endif
; 2307 :            /* outfd = stdout; */
; 2308 :            outfd = *(FILE**)(stacktop--);

	mov	ecx, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [ecx]
	add	esp, 4
	pop	edi
	mov	DWORD PTR _outfd, edx
	add	DWORD PTR [ebx+48], -8			; fffffff8H
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN95@other_stuf:

; 2309 :            break;
; 2310 : 
; 2311 :     case DEBUG_NODE:
; 2312 :           outstring(yydebug?"YACC debugging was ON.":
; 2313 :               "YACC debugging was OFF.\n");

	cmp	DWORD PTR _yydebug, 0
	mov	eax, OFFSET ??_C@_0BH@PFCHHHCD@YACC?5debugging?5was?5ON?4?$AA@
	jne	SHORT $LN976@other_stuf
	mov	eax, OFFSET ??_C@_0BJ@HGBGHBJE@YACC?5debugging?5was?5OFF?4?6?$AA@
$LN976@other_stuf:
	push	eax
	call	_outstring

; 2314 :           yydebug = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	add	esp, 4
	cmp	DWORD PTR [edi+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _yydebug, eax

; 2315 :           outstring(yydebug?"Now ON.\n":"Now OFF.\n");

	test	eax, eax
	mov	eax, OFFSET ??_C@_08EBFKAJLG@Now?5ON?4?6?$AA@
	jne	SHORT $LN978@other_stuf
	mov	eax, OFFSET ??_C@_09CJAKNOCL@Now?5OFF?4?6?$AA@
$LN978@other_stuf:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN94@other_stuf:

; 2316 :           break;
; 2317 : 
; 2318 :     case ITDEBUG_NODE:
; 2319 :           outstring(itdebug?"Iteration debugging was ON.":
; 2320 :               "Iteration debugging was OFF.\n");

	cmp	DWORD PTR _itdebug, 0
	mov	eax, OFFSET ??_C@_0BM@PPPHNHDI@Iteration?5debugging?5was?5ON?4?$AA@
	jne	SHORT $LN980@other_stuf
	mov	eax, OFFSET ??_C@_0BO@JPGBDDG@Iteration?5debugging?5was?5OFF?4?6?$AA@
$LN980@other_stuf:
	push	eax
	call	_outstring

; 2321 :           itdebug = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	add	esp, 4
	cmp	DWORD PTR [edi+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _itdebug, eax

; 2322 :           outstring(itdebug?"Now ON.\n":"Now OFF.\n");

	test	eax, eax
	mov	eax, OFFSET ??_C@_08EBFKAJLG@Now?5ON?4?6?$AA@
	jne	SHORT $LN982@other_stuf
	mov	eax, OFFSET ??_C@_09CJAKNOCL@Now?5OFF?4?6?$AA@
$LN982@other_stuf:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN93@other_stuf:

; 2323 :           break;
; 2324 : 
; 2325 :     case MEMDEBUG_NODE:
; 2326 :           old = memdebug;

	mov	esi, DWORD PTR _memdebug

; 2327 :           memdebug = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [edi+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _memdebug, eax

; 2328 : #ifdef M_DEBUG
; 2329 :     mallopt(M_DEBUG,memdebug);
; 2330 : #endif
; 2331 :           outstring(memdebug?"Memory debugging ON.":
; 2332 :                                    "Memory debugging OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BF@CFOHIJHM@Memory?5debugging?5ON?4?$AA@
	jne	SHORT $LN984@other_stuf
	mov	eax, OFFSET ??_C@_0BG@NBOBGBMF@Memory?5debugging?5OFF?4?$AA@
$LN984@other_stuf:
	push	eax
	call	_outstring
	add	esp, 4

; 2333 :           outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN986@other_stuf
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN986@other_stuf:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN91@other_stuf:

; 2334 :           break;
; 2335 : 
; 2336 :     case RECALC_NODE: recalc(); break;
; 2337 : 
; 2338 :     case CLOSE_SHOW_NODE: close_graphics(); break;

	call	DWORD PTR _close_graphics
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN90@other_stuf:

; 2339 : 
; 2340 :     case TOPINFO_NODE: 
; 2341 :           oldquiet = quiet_flag; quiet_flag = 0;
; 2342 :           top_dump(outfd);

	mov	eax, DWORD PTR _outfd
	mov	esi, DWORD PTR _quiet_flag
	push	eax
	mov	DWORD PTR _quiet_flag, 0
	call	_top_dump
	add	esp, 4
	pop	edi

; 2343 :           quiet_flag = oldquiet;   

	mov	DWORD PTR _quiet_flag, esi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN89@other_stuf:

; 2344 :           break;
; 2345 : 
; 2346 :     case BOTTOMINFO_NODE: 
; 2347 :           oldquiet = quiet_flag; quiet_flag = 0;
; 2348 :           bottom_dump(outfd);

	mov	ecx, DWORD PTR _outfd
	mov	esi, DWORD PTR _quiet_flag
	push	ecx
	mov	DWORD PTR _quiet_flag, 0
	call	_bottom_dump
	add	esp, 4
	pop	edi

; 2349 :           quiet_flag = oldquiet;   

	mov	DWORD PTR _quiet_flag, esi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN88@other_stuf:

; 2350 :           break;
; 2351 : 
; 2352 :     case LIST_QUANTITY_NODE:
; 2353 :           list_quantity(node->op1.quant_id);

	mov	edx, DWORD PTR [edi+32]
	push	edx
	call	_list_quantity
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN87@other_stuf:

; 2354 :           break;
; 2355 : 
; 2356 :     case LIST_METHOD_INSTANCE_NODE:
; 2357 :           list_method_instance(node->op1.meth_id);

	mov	eax, DWORD PTR [edi+32]
	push	eax
	call	_list_method_instance
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN86@other_stuf:

; 2358 :           break;
; 2359 : 
; 2360 :     case LIST_CONSTRAINT_NODE:
; 2361 :           k = (int)(*(stacktop--));

	mov	edi, DWORD PTR [ebx+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	mov	esi, eax
	add	edi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], edi

; 2362 :           if ( k < 0 || k >= web.maxcon || !(get_constraint(k)->attr & IN_USE) )

	test	esi, esi
	js	SHORT $LN84@other_stuf
	cmp	esi, DWORD PTR _web+644
	jge	SHORT $LN84@other_stuf
	mov	ecx, DWORD PTR _web+652
	and	eax, 1073741823				; 3fffffffH
	imul	eax, 176				; 000000b0H
	mov	eax, DWORD PTR [eax+ecx+32]
	and	eax, 32					; 00000020H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN85@other_stuf
$LN84@other_stuf:

; 2363 :             kb_error(3614,"Invalid constraint for list_constraint.",
; 2364 :               RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CI@PKIAGMJH@Invalid?5constraint?5for?5list_cons@
	push	3614					; 00000e1eH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN85@other_stuf:

; 2365 :           list_constraint(k);

	push	esi
	call	_list_constraint
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN83@other_stuf:

; 2366 :           break;
; 2367 : 
; 2368 :     case LIST_BOUNDARY_NODE:
; 2369 :           k = (int)(*(stacktop--));

	mov	edi, DWORD PTR [ebx+48]
	fld	QWORD PTR [edi]
	call	__ftol2_sse
	mov	esi, eax
	add	edi, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], edi

; 2370 :           if ( k < 0 || k >= web.bdrymax || !(web.boundaries[k].attr & IN_USE) )

	test	esi, esi
	js	SHORT $LN81@other_stuf
	cmp	esi, DWORD PTR _web+768
	jge	SHORT $LN81@other_stuf
	mov	edx, DWORD PTR _web+776
	imul	eax, 136				; 00000088H
	mov	eax, DWORD PTR [eax+edx+32]
	and	eax, 32					; 00000020H
	xor	ecx, ecx
	or	eax, ecx
	jne	SHORT $LN82@other_stuf
$LN81@other_stuf:

; 2371 :             kb_error(3615,"Invalid boundary for list_boundary.",
; 2372 :               RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CE@NHFFMKDI@Invalid?5boundary?5for?5list_bounda@
	push	3615					; 00000e1fH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN82@other_stuf:

; 2373 :           list_boundary(k);

	push	esi
	call	_list_boundary
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN80@other_stuf:

; 2374 :           break;
; 2375 : 
; 2376 :     case LIST_PROCS_NODE:
; 2377 :           oldquiet = quiet_flag; quiet_flag = 0;

	mov	esi, DWORD PTR _quiet_flag

; 2378 :           list_procedures(LIST_PROTO);

	push	1
	mov	DWORD PTR _quiet_flag, 0
	call	_list_procedures
	add	esp, 4
	pop	edi

; 2379 :           quiet_flag = oldquiet;   

	mov	DWORD PTR _quiet_flag, esi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN79@other_stuf:

; 2380 :           break;
; 2381 :     
; 2382 :     case LIST_ATTRIBUTES_NODE:
; 2383 :           oldquiet = quiet_flag; quiet_flag = 0;

	mov	esi, DWORD PTR _quiet_flag

; 2384 :           outstring("//Element attributes: \n");

	push	OFFSET ??_C@_0BI@PIKEDNEI@?1?1Element?5attributes?3?5?6?$AA@
	mov	DWORD PTR _quiet_flag, 0
	call	_outstring
	add	esp, 4

; 2385 :           list_attributes();

	call	_list_attributes
	pop	edi

; 2386 :           quiet_flag = oldquiet;   

	mov	DWORD PTR _quiet_flag, esi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN78@other_stuf:

; 2387 :           break;
; 2388 :     
; 2389 :     case PRINT_ARRAY_NODE:
; 2390 :           oldquiet = quiet_flag; quiet_flag = 0;

	mov	esi, DWORD PTR _quiet_flag
	mov	DWORD PTR _quiet_flag, 0

; 2391 :           print_array(globals(node->op1.name_id)->attr.arrayptr,NULL,PRINT_PLAIN);

	mov	edi, DWORD PTR [edi+32]
	mov	eax, edi
	and	eax, -16777216				; ff000000H
	cmp	eax, 268435456				; 10000000H
	je	SHORT $LN987@other_stuf
	cmp	eax, 805306368				; 30000000H
	jne	SHORT $LN989@other_stuf
	mov	ecx, DWORD PTR _localbase$GSCopy$[ebp]
	and	edi, 16777215				; 00ffffffH
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	shl	eax, 5
	add	eax, DWORD PTR [ecx]
	jmp	SHORT $LN988@other_stuf
$LN989@other_stuf:
	cmp	eax, 536870912				; 20000000H
	jne	SHORT $LN987@other_stuf
	mov	edx, DWORD PTR _web+5656
	and	edi, 16777215				; 00ffffffH
	mov	eax, DWORD PTR [edx+edi*4]
	jmp	SHORT $LN988@other_stuf
$LN987@other_stuf:
	mov	eax, DWORD PTR _web+5652
	mov	edx, DWORD PTR _dymem
	and	edi, 16777215				; 00ffffffH
	lea	ecx, DWORD PTR [eax+edi*4]
	mov	eax, DWORD PTR [ecx+edx]
$LN988@other_stuf:
	mov	eax, DWORD PTR [eax+168]
	push	1001					; 000003e9H
	push	0
	push	eax
	call	_print_array
	add	esp, 12					; 0000000cH
	pop	edi

; 2392 :           quiet_flag = oldquiet;   

	mov	DWORD PTR _quiet_flag, esi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN77@other_stuf:

; 2393 :           break;
; 2394 : 
; 2395 :     case PRINT_ARRAY_LVALUE_NODE:
; 2396 :         { struct array *a,kludge;
; 2397 :           oldquiet = quiet_flag; quiet_flag = 0;

	mov	ecx, DWORD PTR _quiet_flag

; 2398 :           a = get_name_arrayptr(node->op2.name_id,localstack,localbase);

	mov	edx, DWORD PTR _localbase$GSCopy$[ebp]
	mov	eax, DWORD PTR _localstack$GSCopy$[ebp]
	push	edx
	mov	DWORD PTR _oldquiet$[ebp], ecx
	mov	DWORD PTR _quiet_flag, 0
	mov	ecx, DWORD PTR [edi+136]
	push	eax
	push	ecx
	call	_get_name_arrayptr

; 2399 :           if ( node[node->left].flags & IS_VIRTUAL_ATTR )

	mov	edx, DWORD PTR [edi+4]
	imul	edx, 168				; 000000a8H
	add	esp, 12					; 0000000cH
	test	DWORD PTR [edx+edi+24], 65536		; 00010000H
	je	SHORT $LN76@other_stuf

; 2400 :           { kludge = *a;

	mov	esi, eax

; 2401 :             kludge.datacount = SDIM;

	mov	eax, DWORD PTR _web+616
	mov	ecx, 14					; 0000000eH
	lea	edi, DWORD PTR _kludge$91589[ebp]
	rep movsd
	mov	DWORD PTR _kludge$91589[ebp+16], eax

; 2402 :             kludge.sizes[0] = SDIM;

	mov	DWORD PTR _kludge$91589[ebp+24], eax

; 2403 :             a = &kludge;

	lea	eax, DWORD PTR _kludge$91589[ebp]
$LN76@other_stuf:

; 2404 :           }
; 2405 :           print_array(a,*(char**)(stacktop--),PRINT_PLAIN);

	mov	ecx, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [ecx]
	push	1001					; 000003e9H
	push	edx
	add	ecx, -8					; fffffff8H
	push	eax
	mov	DWORD PTR [ebx+48], ecx
	call	_print_array

; 2406 :           quiet_flag = oldquiet;   

	mov	eax, DWORD PTR _oldquiet$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	mov	DWORD PTR _quiet_flag, eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN75@other_stuf:

; 2407 :           break;
; 2408 :         }
; 2409 :         
; 2410 :     case PRINT_ARRAYPART_NODE:
; 2411 :         { struct array *part;
; 2412 :           struct array *a;
; 2413 :           char *datastart = *(char**)(stacktop--);

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]

; 2414 : 
; 2415 :           a = get_name_arrayptr(node[node->left].op2.name_id,localstack,localbase);

	mov	edx, DWORD PTR _localbase$GSCopy$[ebp]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	mov	eax, DWORD PTR _localstack$GSCopy$[ebp]
	mov	DWORD PTR _datastart$91595[ebp], ecx
	mov	ecx, DWORD PTR [edi+4]
	imul	ecx, 168				; 000000a8H
	push	edx
	mov	edx, DWORD PTR [ecx+edi+136]
	push	eax
	push	edx
	call	_get_name_arrayptr
	mov	ebx, eax

; 2416 : 
; 2417 :           part = (struct array *)temp_calloc(1,sizeof(struct array)+
; 2418 :                   a->dim*sizeof(int));

	mov	eax, DWORD PTR [ebx+4]
	push	2418					; 00000972H
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	lea	ecx, DWORD PTR [eax*4+56]
	push	ecx
	push	1
	call	_kb_temp_calloc

; 2419 :           part->dim =  a->dim - node->op5.indexcount;

	mov	edx, DWORD PTR [ebx+4]
	sub	edx, DWORD PTR [edi+152]
	mov	esi, eax
	mov	DWORD PTR [esi+4], edx

; 2420 :           part->datatype = a->datatype;

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [esi+8], eax

; 2421 :           part->itemsize = a->itemsize;

	mov	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR [esi+12], ecx

; 2422 :           part->datacount = a->datacount;

	mov	edx, DWORD PTR [ebx+16]

; 2423 :           part->datastart = (char*)part - (char*)datastart;

	mov	eax, esi
	sub	eax, DWORD PTR _datastart$91595[ebp]
	mov	DWORD PTR [esi+16], edx
	mov	DWORD PTR [esi+20], eax

; 2424 :           for ( i = node->op5.indexcount, j = 0  ; i < a->dim ; i++,j++ )

	mov	edi, DWORD PTR [edi+152]
	add	esp, 28					; 0000001cH
	cmp	edi, DWORD PTR [ebx+4]
	jge	SHORT $LN72@other_stuf

; 2407 :           break;
; 2408 :         }
; 2409 :         
; 2410 :     case PRINT_ARRAYPART_NODE:
; 2411 :         { struct array *part;
; 2412 :           struct array *a;
; 2413 :           char *datastart = *(char**)(stacktop--);

	lea	ecx, DWORD PTR [esi+24]
	lea	eax, DWORD PTR [ebx+edi*4+24]
	npad	5
$LL74@other_stuf:

; 2425 :             part->sizes[j] = a->sizes[i];

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	inc	edi
	add	eax, 4
	add	ecx, 4
	cmp	edi, DWORD PTR [ebx+4]
	jl	SHORT $LL74@other_stuf
$LN72@other_stuf:

; 2426 :           msg[0] = 0;

	mov	eax, DWORD PTR _msg

; 2427 :           oldquiet = quiet_flag; quiet_flag = 0;
; 2428 :           print_array(part,datastart,PRINT_PLAIN);

	mov	ecx, DWORD PTR _datastart$91595[ebp]
	push	1001					; 000003e9H
	mov	BYTE PTR [eax], 0
	push	ecx
$LN1632@other_stuf:
	mov	edi, DWORD PTR _quiet_flag
	push	esi
	mov	DWORD PTR _quiet_flag, 0
	call	_print_array

; 2429 :           quiet_flag = oldquiet;   
; 2430 :           temp_free((char*)part);

	push	esi
	mov	DWORD PTR _quiet_flag, edi
	call	_temp_free
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN71@other_stuf:

; 2440 :           n = node->op3.extranum;  /* attribute number */
; 2441 :           id = *(element_id*)get_localp((node+node->left)->op2.localnum);

	mov	edx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+140]
	imul	edx, 168				; 000000a8H
	mov	eax, DWORD PTR [edx+edi+136]
	and	eax, 16777215				; 00ffffffH
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR _localbase$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax]
	shl	edx, 5
	mov	edx, DWORD PTR [edx+eax+216]
	mov	eax, DWORD PTR _localstack$GSCopy$[ebp]
	mov	edx, DWORD PTR [eax+edx*8]

; 2442 :          
; 2443 :           ext = EXTRAS(node->op2.eltype) + n;

	mov	eax, DWORD PTR [edi+136]
	mov	DWORD PTR _n$[ebp], ecx
	imul	ecx, 240				; 000000f0H
	mov	DWORD PTR _id$[ebp], edx
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	shl	edx, 4
	mov	esi, DWORD PTR _web[edx+104]
	add	esi, ecx
	add	esi, DWORD PTR _dymem

; 2444 : 
; 2445 :           part = (struct array *)temp_calloc(1,sizeof(struct array)+
; 2446 :                   ext->array_spec.dim*sizeof(int));

	push	2446					; 0000098eH
	mov	eax, DWORD PTR [esi+76]
	push	OFFSET ??_C@_0L@OMPKCCNP@EVALMORE?4C?$AA@
	lea	ecx, DWORD PTR [eax*4+56]
	push	ecx
	push	1
	mov	DWORD PTR _offset$91610[ebp], 0
	call	_kb_temp_calloc

; 2447 :           part->dim =  ext->array_spec.dim - node->op5.indexcount;

	mov	edx, DWORD PTR [esi+76]
	sub	edx, DWORD PTR [edi+152]
	mov	DWORD PTR _part$91608[ebp], eax
	mov	DWORD PTR [eax+4], edx

; 2448 :           part->datatype = ext->type;

	mov	ecx, DWORD PTR [esi+68]
	mov	DWORD PTR [eax+8], ecx

; 2449 :           part->itemsize = ext->array_spec.itemsize;

	mov	edx, DWORD PTR [esi+84]
	mov	DWORD PTR [eax+12], edx

; 2450 :           part->datacount = ext->array_spec.datacount;

	mov	ecx, DWORD PTR [esi+88]

; 2451 :           part->datastart =  (char*)get_extra(id,n) - (char*)part;

	mov	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR _id$[ebp]
	push	edx
	push	eax
	call	_get_extra
	mov	ecx, eax
	mov	eax, DWORD PTR _part$91608[ebp]
	sub	ecx, eax
	mov	DWORD PTR [eax+20], ecx

; 2452 :           for ( n = 0; n < node->op5.indexcount ; n++ )

	mov	eax, DWORD PTR [edi+152]
	add	esp, 24					; 00000018H
	mov	DWORD PTR _n$[ebp], 0
	test	eax, eax
	jle	$LN1202@other_stuf

; 2431 :           break;
; 2432 :         }
; 2433 : 
; 2434 :        
; 2435 : 
; 2436 :     case PRINT_ATTR_ARRAY_NODE:
; 2437 :         { struct array *part;
; 2438 :           struct extra *ext;
; 2439 :           int offset = 0;

	lea	edx, DWORD PTR [esi+96]
	mov	DWORD PTR tv14771[ebp], edx
$LL70@other_stuf:

; 2453 :           { int size = ext->array_spec.sizes[n];

	mov	ecx, DWORD PTR tv14771[ebp]
	mov	edx, DWORD PTR [ecx]

; 2454 :             int inx = (int)*(stacktop - node->op5.indexcount + n + 1) - 1;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _size$91621[ebp], edx
	mov	edx, DWORD PTR [ebx+48]
	sub	ecx, eax
	fld	QWORD PTR [edx+ecx*8+8]
	call	__ftol2_sse
	dec	eax
	mov	DWORD PTR _inx$91622[ebp], eax

; 2455 :             if ( inx >= size )

	cmp	eax, DWORD PTR _size$91621[ebp]
	jl	SHORT $LN67@other_stuf

; 2456 :             { sprintf(errmsg,
; 2457 :                 "Index %d of attribute %s is %d; exceeds declared size, %d\n",
; 2458 :                 n+1,ext->name,inx+1,size);

	mov	eax, DWORD PTR _size$91621[ebp]
	mov	ecx, DWORD PTR _inx$91622[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	push	eax
	inc	ecx
	push	ecx
	push	esi
	inc	edx
	push	edx
	push	OFFSET ??_C@_0DL@CFEHCEG@Index?5?$CFd?5of?5attribute?5?$CFs?5is?5?$CFd?$DL?5@
	push	OFFSET _errmsg
	call	_sprintf

; 2459 :               sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2460 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 24					; 00000018H
	lea	ecx, DWORD PTR [eax+1]
$LL1166@other_stuf:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL1166@other_stuf
	mov	edx, DWORD PTR [edi+16]
	sub	eax, ecx
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 2461 :               kb_error(2645,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2645					; 00000a55H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN67@other_stuf:

; 2462 :             }
; 2463 :             if ( size ) part->datacount /= size;

	mov	ecx, DWORD PTR _size$91621[ebp]
	test	ecx, ecx
	je	SHORT $LN1201@other_stuf
	mov	edx, DWORD PTR _part$91608[ebp]
	mov	eax, DWORD PTR [edx+16]
	cdq
	idiv	ecx
	mov	edx, DWORD PTR _part$91608[ebp]
	mov	DWORD PTR [edx+16], eax
$LN1201@other_stuf:

; 2464 :             offset *= size;

	imul	ecx, DWORD PTR _offset$91610[ebp]
	mov	edx, DWORD PTR _n$[ebp]

; 2465 :             offset += inx;

	add	ecx, DWORD PTR _inx$91622[ebp]
	mov	eax, DWORD PTR [edi+152]
	add	DWORD PTR tv14771[ebp], 4
	inc	edx
	mov	DWORD PTR _offset$91610[ebp], ecx
	mov	DWORD PTR _n$[ebp], edx
	cmp	edx, eax
	jl	$LL70@other_stuf

; 2452 :           for ( n = 0; n < node->op5.indexcount ; n++ )

	jmp	SHORT $LN68@other_stuf
$LN1202@other_stuf:
	mov	ecx, DWORD PTR _offset$91610[ebp]
	mov	edx, ecx
$LN68@other_stuf:

; 2466 :           }
; 2467 :           stacktop -= n;

	mov	eax, edx
	neg	eax
	add	eax, eax
	add	eax, eax
	add	eax, eax
	add	DWORD PTR [ebx+48], eax

; 2468 :           for ( k = 0 ; n < ext->array_spec.dim ; n++,k++ )

	cmp	edx, DWORD PTR [esi+76]
	jge	SHORT $LN63@other_stuf

; 2466 :           }
; 2467 :           stacktop -= n;

	mov	ebx, DWORD PTR _part$91608[ebp]
	add	ebx, 24					; 00000018H
	lea	edi, DWORD PTR [esi+edx*4+96]
	npad	5
$LL65@other_stuf:

; 2469 :           { int size = ext->array_spec.sizes[n];

	mov	eax, DWORD PTR [edi]

; 2470 :             part->sizes[k] = size;

	mov	DWORD PTR [ebx], eax

; 2471 :             offset *= size;

	imul	ecx, eax
	inc	edx
	add	edi, 4
	add	ebx, 4
	cmp	edx, DWORD PTR [esi+76]
	jl	SHORT $LL65@other_stuf
	mov	DWORD PTR _offset$91610[ebp], ecx
$LN63@other_stuf:

; 2472 :           }
; 2473 :           part->datastart += offset*part->itemsize;

	mov	esi, DWORD PTR _part$91608[ebp]
	mov	ecx, DWORD PTR [esi+12]
	imul	ecx, DWORD PTR _offset$91610[ebp]
	add	DWORD PTR [esi+20], ecx

; 2474 :           msg[0] = 0;

	mov	edx, DWORD PTR _msg

; 2475 :           oldquiet = quiet_flag; quiet_flag = 0;
; 2476 :           print_array(part,NULL,PRINT_PLAIN);

	push	1001					; 000003e9H
	mov	BYTE PTR [edx], 0
	push	0

; 2477 :           quiet_flag = oldquiet;   
; 2478 :           temp_free((char*)part);
; 2479 :           break;

	jmp	$LN1632@other_stuf
$LN62@other_stuf:

; 2480 :         }
; 2481 : 
; 2482 :     case DIRICHLET_NODE:
; 2483 :     case DIRICHLET_SEEK_NODE:
; 2484 :           scale = dirichlet(node->type==DIRICHLET_NODE?0:1);

	xor	ecx, ecx
	cmp	eax, 10506				; 0000290aH
	setne	cl
	push	ecx
	call	_dirichlet
$LN1609@other_stuf:
	fstp	QWORD PTR _scale$[ebp]

; 2485 :           recalc();

	call	_recalc

; 2486 : #ifdef FLOAT128
; 2487 :           sprintf(msg,"%3d.  energy: %#*.*Qg  scale: %#g\n",gocount,
; 2488 :               DWIDTH,DPREC, web.total_energy,(DOUBLE)scale);
; 2489 : #elif defined(LONGDOUBLE)
; 2490 :           sprintf(msg,"%3d.  energy: %#*.*Lg  scale: %#g\n",gocount,
; 2491 :               DWIDTH,DPREC, web.total_energy,(DOUBLE)scale);
; 2492 : #else
; 2493 :           sprintf(msg,"%3d. %s: %#17.15g energy: %#17.15g  scale: %#g\n",gocount,
; 2494 :               areaname,web.total_area,web.total_energy,scale);

	fld	QWORD PTR _scale$[ebp]
	mov	edx, DWORD PTR _areaname
	mov	eax, DWORD PTR _gocount
	mov	ecx, DWORD PTR _msg
	sub	esp, 20					; 00000014H
	fstp	QWORD PTR [esp+16]
	fld	QWORD PTR _web+1240
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _web+992
	fstp	QWORD PTR [esp]
	push	edx
	push	eax
	push	OFFSET ??_C@_0DA@CLPAALJF@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@
	push	ecx
	call	_sprintf

; 2495 : #endif 
; 2496 :           outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
$LN1610@other_stuf:
	call	_outstring
	add	esp, 44					; 0000002cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN61@other_stuf:

; 2497 :           break;
; 2498 : 
; 2499 :     case SOBOLEV_NODE:
; 2500 :     case SOBOLEV_SEEK_NODE:
; 2501 :           scale = sobolev(node->type==SOBOLEV_NODE?0:1);

	xor	ecx, ecx
	cmp	eax, 10508				; 0000290cH
	setne	cl
	push	ecx
	call	_sobolev

; 2502 :           recalc();
; 2503 : #ifdef FLOAT128
; 2504 :           sprintf(msg,"%3d.  energy: %#*.*Qg  scale: %#g\n",gocount,
; 2505 :               DWIDTH,DPREC,web.total_energy,(DOUBLE)scale);
; 2506 : #elif defined(LONGDOUBLE)
; 2507 :           sprintf(msg,"%3d.  energy: %#*.*Lg  scale: %#g\n",gocount,
; 2508 :               DWIDTH,DPREC,web.total_energy,(DOUBLE)scale);
; 2509 : #else
; 2510 :           sprintf(msg,"%3d. %s: %#17.15g energy: %#17.15g  scale: %#g\n",gocount,
; 2511 :               areaname,web.total_area,web.total_energy,scale);
; 2512 : #endif 
; 2513 :           outstring(msg);
; 2514 :           break;

	jmp	SHORT $LN1609@other_stuf
$LN60@other_stuf:

; 2515 : 
; 2516 :     case HESSIAN_SEEK_NODE:
; 2517 :        { REAL maxscale; 
; 2518 :           if ( node->left ) maxscale = *(stacktop--);

	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN59@other_stuf
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H
	mov	DWORD PTR [ebx+48], eax
	jmp	SHORT $LN58@other_stuf
$LN59@other_stuf:

; 2519 :           else maxscale = 10.;

	fld	QWORD PTR __real@4024000000000000
$LN58@other_stuf:

; 2520 :           scale = hessian_seek(maxscale);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_hessian_seek
	fstp	QWORD PTR _scale$[ebp]

; 2521 :           recalc();

	call	_recalc

; 2522 : #ifdef FLOAT128
; 2523 :           sprintf(msg,"%3d.  energy: %#*.*Qg  scale: %#g\n",gocount,
; 2524 :               DWIDTH,DPREC,web.total_energy,(DOUBLE)scale);
; 2525 : #elif defined(LONGDOUBLE)
; 2526 :           sprintf(msg,"%3d.  energy: %#*.*Lg  scale: %#g\n",gocount,
; 2527 :               DWIDTH,DPREC,web.total_energy,(DOUBLE)scale);
; 2528 : #else
; 2529 :           sprintf(msg,"%3d. %s: %#17.15g energy: %#17.15g  scale: %#g\n",
; 2530 :                gocount, areaname,web.total_area,web.total_energy,scale);

	fld	QWORD PTR _scale$[ebp]
	mov	eax, DWORD PTR _areaname
	mov	ecx, DWORD PTR _gocount
	fstp	QWORD PTR [esp]
	fld	QWORD PTR _web+1240
	mov	edx, DWORD PTR _msg
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _web+992
	fstp	QWORD PTR [esp]
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DA@CLPAALJF@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@
	push	edx
	call	_sprintf

; 2531 : #endif 
; 2532 :           outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax

; 2533 :         }
; 2534 :         break;

	jmp	$LN1610@other_stuf
$LN57@other_stuf:

; 2535 : 
; 2536 :     case HESSIAN_SADDLE_NODE:
; 2537 :        { REAL maxscale; 
; 2538 :           if ( node->left ) maxscale = *(stacktop--);

	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN56@other_stuf
	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax]
	add	eax, -8					; fffffff8H

; 2540 :           hessian_saddle(maxscale);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	DWORD PTR [ebx+48], eax
	call	_hessian_saddle
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN56@other_stuf:

; 2539 :           else maxscale = 100.;

	fld	QWORD PTR __real@4059000000000000

; 2540 :           hessian_saddle(maxscale);

	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_hessian_saddle
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN54@other_stuf:

; 2541 :        }
; 2542 :        break;
; 2543 : 
; 2544 :     case HESSIAN_MENU_NODE: 
; 2545 :           if ( hessian_subshell_flag )

	cmp	DWORD PTR _hessian_subshell_flag, 0
	je	SHORT $LN53@other_stuf

; 2546 :           { kb_error(3633,"Can't do hessian_menu in a hessian subshell.\n",WARNING);

	push	2
	push	OFFSET ??_C@_0CO@BCOCKICC@Can?8t?5do?5hessian_menu?5in?5a?5hessi@
	push	3633					; 00000e31H
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN53@other_stuf:

; 2547 :             break;
; 2548 :           }
; 2549 :            hessian_menu();

	call	_hessian_menu

; 2550 :            recalc();

	call	_recalc

; 2551 : #ifdef FLOAT128
; 2552 :           sprintf(msg,"%3d.  energy: %#*.*Qg \n",1, 
; 2553 :                DWIDTH,DPREC,web.total_energy);
; 2554 : #elif defined(LONGDOUBLE)
; 2555 :           sprintf(msg,"%3d.  energy: %#*.*Lg \n",1, 
; 2556 :                DWIDTH,DPREC,web.total_energy);
; 2557 : #else
; 2558 :           sprintf(msg,"%3d. %s: %#17.15g energy: %#17.15g \n",1,
; 2559 :               areaname,web.total_area,web.total_energy);

	fld	QWORD PTR _web+1240
	mov	ecx, DWORD PTR _areaname
	mov	edx, DWORD PTR _msg
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _web+992
	fstp	QWORD PTR [esp]
	push	ecx
	push	1
	push	OFFSET ??_C@_0CF@BNMONBF@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@
	push	edx
	call	_sprintf

; 2560 : #endif 
; 2561 :            outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@other_stuf:

; 2562 :            break;
; 2563 : 
; 2564 :     case HESSIAN_NODE: 
; 2565 :            hessian_auto();

	call	_hessian_auto

; 2566 :            recalc();

	call	_recalc

; 2567 : #ifdef FLOAT128
; 2568 :           sprintf(msg,"%3d.  energy: %#*.*Qg  \n",gocount, DWIDTH,
; 2569 :                DPREC,web.total_energy);
; 2570 : #elif defined(LONGDOUBLE)
; 2571 :           sprintf(msg,"%3d.  energy: %#*.*Lg  \n",gocount, DWIDTH,
; 2572 :                DPREC,web.total_energy);
; 2573 : #else
; 2574 :           sprintf(msg,"%3d. %s: %#17.15g energy: %#17.15g\n",gocount,
; 2575 :               areaname,web.total_area,web.total_energy);

	fld	QWORD PTR _web+1240
	mov	ecx, DWORD PTR _areaname
	mov	edx, DWORD PTR _gocount
	mov	eax, DWORD PTR _msg
	sub	esp, 16					; 00000010H
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _web+992
	fstp	QWORD PTR [esp]
	push	ecx
	push	edx
	push	OFFSET ??_C@_0CE@IICCDGHH@?$CF3d?4?5?$CFs?3?5?$CF?$CD17?415g?5energy?3?5?$CF?$CD17?41@
	push	eax
	call	_sprintf

; 2576 : #endif 
; 2577 :            outstring(msg);

	mov	ecx, DWORD PTR _msg
	push	ecx
	call	_outstring
	add	esp, 36					; 00000024H
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@other_stuf:

; 2578 :            break;
; 2579 : 
; 2580 :     case SHELL_NODE:  /* execute subshell */
; 2581 : #if defined(__WIN32__) || defined(_WIN32)
; 2582 :        _spawnlp(_P_WAIT,"cmd.exe","cmd.exe",NULL);

	push	0
	push	OFFSET ??_C@_07INNMNHPJ@cmd?4exe?$AA@
	push	OFFSET ??_C@_07INNMNHPJ@cmd?4exe?$AA@
	push	0
	call	__spawnlp
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@other_stuf:

; 2583 : #else
; 2584 : #if defined(MAC_APP) || defined(MAC_CW)
; 2585 :        kb_error(1221,"No subshell on Mac.\n",RECOVERABLE);
; 2586 : 
; 2587 : #else
; 2588 :        if ( fork() == 0 )
; 2589 :        { execlp("sh","sh",NULL);
; 2590 :          perror("sh");
; 2591 :        }
; 2592 :        else wait(NULL);
; 2593 : #endif
; 2594 : #endif
; 2595 :           break;
; 2596 : 
; 2597 :     case SHOW_TRANS_NODE:
; 2598 :            view_transform(*(char**)(stacktop--));

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	push	ecx
	mov	DWORD PTR [ebx+48], eax
	call	_view_transform
	add	esp, 4

; 2599 :            update_display();

	call	_update_display
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN49@other_stuf:

; 2600 :            break;
; 2601 : 
; 2602 :     case CHECK_NODE:
; 2603 :           run_checks();

	call	_run_checks
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@other_stuf:

; 2604 :           break;
; 2605 : 
; 2606 :     case CONVERT_TO_QUANTS_NODE:
; 2607 :           if ( everything_quantities_flag )

	cmp	DWORD PTR _everything_quantities_flag, 0
	je	SHORT $LN47@other_stuf

; 2608 :             outstring("Everything already quantities.\n");

	push	OFFSET ??_C@_0CA@COCFHENO@Everything?5already?5quantities?4?6?$AA@
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN47@other_stuf:

; 2609 :           else
; 2610 :           { convert_to_quantities();

	call	_convert_to_quantities

; 2611 :             recalc();

	call	_recalc
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN45@other_stuf:

; 2612 :           }
; 2613 :           break;
; 2614 : 
; 2615 :     case SHOW_VOL_NODE:
; 2616 :           show_volumes();

	call	_show_volumes
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@other_stuf:

; 2617 :           break;
; 2618 : 
; 2619 :     case LOGFILE_NODE:
; 2620 :           start_logfile(*(char**)(stacktop--));

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	push	ecx
	mov	DWORD PTR [ebx+48], eax
	call	_start_logfile

; 2621 :           outstring("Logfile ON.\n");

	push	OFFSET ??_C@_0N@OIJOBCFB@Logfile?5ON?4?6?$AA@
	call	_outstring
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@other_stuf:

; 2622 :           break;
; 2623 : 
; 2624 :     case KEYLOGFILE_NODE:
; 2625 :           start_keylogfile(*(char**)(stacktop--));

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	push	ecx
	mov	DWORD PTR [ebx+48], eax
	call	_start_keylogfile

; 2626 :           outstring("Keylogfile ON.\n");

	push	OFFSET ??_C@_0BA@PJAKDOFJ@Keylogfile?5ON?4?6?$AA@
	call	_outstring
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@other_stuf:

; 2627 :           break;
; 2628 : 
; 2629 :     case GEOMVIEW_NODE:
; 2630 :           geomview_command(*(char**)(stacktop--));

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	push	ecx
	mov	DWORD PTR [ebx+48], eax
	call	_geomview_command
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@other_stuf:

; 2631 :           break;
; 2632 : 
; 2633 :     case IS_DEFINED_NODE:
; 2634 :          *stacktop = (identcase(*(char**)stacktop) != NEWIDENT_TOK);  

	mov	edx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_identcase
	mov	edx, DWORD PTR [ebx+48]
	add	esp, 4
	xor	ecx, ecx
	cmp	eax, 268				; 0000010cH
	setne	cl
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR tv10666[ebp], ecx
	fild	DWORD PTR tv10666[ebp]
	fstp	QWORD PTR [edx]

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN40@other_stuf:

; 2635 :          break;
; 2636 : 
; 2637 :     case REPARTITION_NODE:
; 2638 : #ifdef MPI_EVOLVER
; 2639 :        mpi_repartition();
; 2640 :        update_display();
; 2641 : #else
; 2642 :        kb_error(5005,"'Repartition' command only implemented in MPI Evolver.\n",
; 2643 :           WARNING);

	push	2
	push	OFFSET ??_C@_0DI@NLJAFAOJ@?8Repartition?8?5command?5only?5imple@
	push	5005					; 0000138dH
	call	_kb_error
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@other_stuf:

; 2644 : #endif
; 2645 :        break;
; 2646 : 
; 2647 :     case EXEC_NODE:
; 2648 :        command(*(char**)(stacktop--),NO_HISTORY);

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	push	0
	push	ecx
	mov	DWORD PTR [ebx+48], eax
	call	_command
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@other_stuf:

; 2649 :        break;
; 2650 : 
; 2651 :     case PARALLEL_EXEC_NODE:
; 2652 : #ifdef MPI_EVOLVER
; 2653 :        mpi_parallel_exec(*(char**)(stacktop--));
; 2654 : #else
; 2655 :        command(*(char**)(stacktop--),NO_HISTORY);
; 2656 : #endif
; 2657 :        break;
; 2658 : 
; 2659 :     case TASK_EXEC_NODE:
; 2660 :        { int task = (int)(stacktop[-1]); 
; 2661 : #ifdef MPI_EVOLVER
; 2662 :          if ( task == 0 ) command(*(char**)(stacktop--),NO_HISTORY);
; 2663 :          else if ( task >= mpi_nprocs )
; 2664 :          { sprintf(errmsg,"Node number %d exceeds maximum node number, %d.\n",
; 2665 :               task,mpi_nprocs-1);
; 2666 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2667 :                                 file_names[node->file_no],node->line_no);
; 2668 :            kb_error(3167,errmsg,RECOVERABLE);
; 2669 :          }
; 2670 :          else if ( task < 0 )
; 2671 :          { sprintf(errmsg,"Node number %d is negative!\n", task);
; 2672 :            sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2673 :                                 file_names[node->file_no],node->line_no);
; 2674 :            kb_error(3168,errmsg,RECOVERABLE);
; 2675 :          }
; 2676 :          else
; 2677 :            mpi_task_exec(task,*(char**)(stacktop--));
; 2678 : #else
; 2679 :          if ( task != 0 )

	mov	eax, DWORD PTR [ebx+48]
	fld	QWORD PTR [eax-8]
	call	__ftol2_sse
	test	eax, eax
	je	SHORT $LN36@other_stuf

; 2680 :          { 
; 2681 :             sprintf(errmsg,"Node_exec node number must be 0 for non-MPI Evolver.\n");

	push	OFFSET ??_C@_0DG@BOMEKDIH@Node_exec?5node?5number?5must?5be?50?5@
	push	OFFSET _errmsg
	call	_sprintf

; 2682 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2683 :                                 file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 8
	lea	edx, DWORD PTR [eax+1]
$LL1167@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1167@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 2684 :             kb_error(3169,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	3169					; 00000c61H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN36@other_stuf:

; 2685 :          }
; 2686 :          command(*(char**)(stacktop--),NO_HISTORY);

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	push	0
	push	ecx
	mov	DWORD PTR [ebx+48], eax
	call	_command
	add	esp, 8

; 2687 : #endif
; 2688 :          stacktop--; /* pop node number */

	add	DWORD PTR [ebx+48], -8			; fffffff8H
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@other_stuf:

; 2689 :        }
; 2690 :        break;
; 2691 : 
; 2692 :     case SYSTEM_NODE:
; 2693 :        system(*(char**)(stacktop--));

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	push	ecx
	mov	DWORD PTR [ebx+48], eax
	call	_system
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@other_stuf:

; 2694 :        break;
; 2695 : 
; 2696 :     case CHDIR_NODE:
; 2697 : #ifdef MSC
; 2698 : 	#ifdef __L_EVOLVER__
; 2699 : 		strcpy(png_dir, *(char**)(stacktop--));

	mov	ecx, DWORD PTR [ebx+48]
	mov	eax, DWORD PTR [ecx]
	add	ecx, -8					; fffffff8H
	mov	edx, OFFSET _png_dir
	mov	DWORD PTR [ebx+48], ecx
	sub	edx, eax
$LL993@other_stuf:
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $LL993@other_stuf

; 2700 : 		k = strlen(png_dir); 

	mov	eax, OFFSET _png_dir
	lea	edx, DWORD PTR [eax+1]
$LL1168@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1168@other_stuf
	sub	eax, edx

; 2701 : 		if (png_dir[k - 1] != '/') 

	mov	cl, 47					; 0000002fH
	cmp	BYTE PTR _png_dir[eax-1], cl
	je	SHORT $LN33@other_stuf

; 2702 : 		{ 
; 2703 : 			png_dir[k] = '/'; 

	mov	BYTE PTR _png_dir[eax], cl

; 2704 : 			png_dir[k + 1] = 0; 

	mov	BYTE PTR _png_dir[eax+1], 0
$LN33@other_stuf:

; 2705 : 			//png_dir[k + 2] = 0; 
; 2706 : 				//strcat(png_dir, "/\"");
; 2707 : 			//outstring(png_dir);
; 2708 : 		}
; 2709 : 		k = _chdir(png_dir);

	push	OFFSET _png_dir
	call	__chdir
	add	esp, 4

; 2710 : 	#else 
; 2711 :        k = _chdir(*(char**)(stacktop--));
; 2712 : 	#endif
; 2713 :        if ( k < 0 )

	test	eax, eax
	jns	$LN855@other_stuf

; 2714 :        { sprintf(errmsg,"Unable to change directory. \n");

	push	OFFSET ??_C@_0BO@IGMMDLLJ@Unable?5to?5change?5directory?4?5?6?$AA@
	push	OFFSET _errmsg
	call	_sprintf

; 2715 :          if ( !strchr(*(char**)(stacktop+1),'\\') )

	mov	ecx, DWORD PTR [ebx+48]
	mov	edx, DWORD PTR [ecx+8]
	push	92					; 0000005cH
	push	edx
	call	_strchr
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN31@other_stuf

; 2716 :            strcat(errmsg,"Try using \\\\ or / instead of \\.\n");

	mov	edi, OFFSET _errmsg
	dec	edi
$LL1169@other_stuf:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL1169@other_stuf
	mov	ecx, 8
	mov	esi, OFFSET ??_C@_0CB@MNEAHDFA@Try?5using?5?2?2?5or?5?1?5instead?5of?5?2?4?6@
	rep movsd
	movsb
	mov	edi, DWORD PTR _node$GSCopy$[ebp]
$LN31@other_stuf:

; 2717 :          sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2718 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	lea	edx, DWORD PTR [eax+1]
$LL1170@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1170@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 2719 :          kb_error(2034,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2034					; 000007f2H
	call	_kb_error
	add	esp, 28					; 0000001cH
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@other_stuf:

; 2720 :        }
; 2721 : #else
; 2722 :        k = chdir(*(char**)(stacktop--));
; 2723 :        if ( k < 0 )
; 2724 :        { sprintf(errmsg,"Unable to change to directory \"%s\".\n",
; 2725 :              *(char**)(stacktop+1));
; 2726 :          sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2727 :                  file_names[node->file_no],node->line_no);
; 2728 :          kb_error(1116,errmsg,RECOVERABLE);
; 2729 :        }
; 2730 : #endif
; 2731 : 
; 2732 :        break;
; 2733 : 
; 2734 :     case READ_NODE:
; 2735 :        if ( read_depth <= 1 ) warning_messages_new = 0;

	cmp	DWORD PTR _read_depth, 1
	jg	SHORT $LN29@other_stuf
	mov	DWORD PTR _warning_messages_new, 0
$LN29@other_stuf:

; 2736 :        exec_file(NULL,*(char**)(stacktop--));

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	add	eax, -8					; fffffff8H
	push	0
	mov	DWORD PTR [ebx+48], eax
	call	_exec_file
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@other_stuf:

; 2737 :        break;
; 2738 : 
; 2739 :     case VIEW_TRANSFORM_SWAP_COLORS_NODE: 
; 2740 :         { int k = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	mov	DWORD PTR _k$91698[ebp], eax
	mov	DWORD PTR [ebx+48], esi

; 2741 :           if ( (k < 1) || (k > transform_count) )

	cmp	eax, 1
	jl	SHORT $LN26@other_stuf
	cmp	eax, DWORD PTR _transform_count
	jle	SHORT $LN27@other_stuf
$LN26@other_stuf:

; 2742 :           { sprintf(errmsg,
; 2743 :                "Invalid index %d to view_transform_swap_colors.\n",k);

	push	eax
	push	OFFSET ??_C@_0DB@NGHECIGG@Invalid?5index?5?$CFd?5to?5view_transfo@
	push	OFFSET _errmsg
	call	_sprintf

; 2744 :             sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2745 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
	npad	6
$LL1171@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1171@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 2746 :             kb_error(2518,errmsg, RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2518					; 000009d6H
	call	_kb_error
	mov	eax, DWORD PTR _k$91698[ebp]
	add	esp, 28					; 0000001cH
$LN27@other_stuf:

; 2747 :           }
; 2748 :           if ( !transform_colors ) *(++stacktop) = 0;

	cmp	DWORD PTR _transform_colors, 0
	jne	SHORT $LN25@other_stuf
	add	DWORD PTR [ebx+48], 8
	fldz
	mov	ebx, DWORD PTR [ebx+48]
	fstp	QWORD PTR [ebx]
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@other_stuf:

; 2749 :           else
; 2750 :            *(++stacktop) = (transform_colors[k-1] == SWAP_COLORS);

	add	DWORD PTR [ebx+48], 8
	mov	edx, DWORD PTR _transform_colors
	mov	ebx, DWORD PTR [ebx+48]
	xor	ecx, ecx
	cmp	DWORD PTR [edx+eax*4-4], 1
	pop	edi
	sete	cl
	pop	esi
	mov	DWORD PTR tv10585[ebp], ecx
	fild	DWORD PTR tv10585[ebp]
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@other_stuf:

; 2751 :           break;
; 2752 :         }
; 2753 : 
; 2754 :     case VIEW_TRANSFORM_PARITY_NODE:
; 2755 :         { int k = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	lea	ecx, DWORD PTR [esi-8]
	mov	DWORD PTR [ebx+48], ecx

; 2756 :           if ( !transform_parity ) 

	cmp	DWORD PTR _transform_parity, 0
	jne	SHORT $LN22@other_stuf

; 2757 :            *(++stacktop) = 1;

	fld1
	pop	edi
	lea	eax, DWORD PTR [ecx+8]
	fstp	QWORD PTR [eax]
	pop	esi
	mov	DWORD PTR [ebx+48], eax
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@other_stuf:

; 2758 :           else
; 2759 :            *(++stacktop) = transform_parity[k-1];

	add	ecx, 8
	mov	DWORD PTR [ebx+48], ecx
	mov	edx, DWORD PTR _transform_parity
	fild	DWORD PTR [edx+eax*4-4]
	pop	edi
	pop	esi
	pop	ebx
	fstp	QWORD PTR [ecx]

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@other_stuf:

; 2760 :           break;
; 2761 :         }
; 2762 : 
; 2763 :     case VIEW_TRANSFORMS_NODE:
; 2764 :        read_transforms((int)(*stacktop--));

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	push	eax
	mov	DWORD PTR [ebx+48], esi
	call	_read_transforms
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@other_stuf:

; 2765 :        break;
; 2766 : 
; 2767 :     case VIEW_TRANSFORMS_NOP_NODE: 
; 2768 :          break;  /* just to get first two indices on stack */
; 2769 :     case VIEW_TRANSFORMS_ELEMENT_NODE:
; 2770 :          { int k = (int)(*stacktop--);

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse

; 2771 :            int j = (int)(*stacktop--);

	fld	QWORD PTR [esi-8]
	mov	DWORD PTR _k$91714[ebp], eax
	call	__ftol2_sse

; 2772 :            int i = (int)(*stacktop--);

	fld	QWORD PTR [esi-16]
	mov	DWORD PTR _j$91716[ebp], eax
	call	__ftol2_sse
	add	esi, -24				; ffffffe8H
	mov	DWORD PTR _i$91718[ebp], eax
	mov	DWORD PTR [ebx+48], esi

; 2773 :            if ( i < 1 )

	cmp	eax, 1
	jge	SHORT $LN1227@other_stuf

; 2774 :            { sprintf(errmsg,
; 2775 :                  "View_transforms index 1 is %d, must be at least 1.\n",i);

	push	eax
	push	OFFSET ??_C@_0DE@MEJLOJCC@View_transforms?5index?51?5is?5?$CFd?0?5m@
	push	OFFSET _errmsg
	call	_sprintf

; 2776 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2777 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1172@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1172@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 2778 :              kb_error(2036,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2036					; 000007f4H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN1227@other_stuf:

; 2779 :            }
; 2780 :            if ( j < 1 )

	mov	eax, DWORD PTR _j$91716[ebp]
	cmp	eax, 1
	jge	SHORT $LN16@other_stuf

; 2781 :            { sprintf(errmsg,
; 2782 :                  "View_transforms index 2 is %d, must be at least 1.\n",j);

	push	eax
	push	OFFSET ??_C@_0DE@IADKMMDK@View_transforms?5index?52?5is?5?$CFd?0?5m@
	push	OFFSET _errmsg
	call	_sprintf

; 2783 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2784 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1173@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1173@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 2785 :              kb_error(2037,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2037					; 000007f5H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN16@other_stuf:

; 2786 :            }
; 2787 :            if ( k < 1 )

	mov	esi, DWORD PTR _k$91714[ebp]
	cmp	esi, 1
	jge	SHORT $LN15@other_stuf

; 2788 :            { sprintf(errmsg,
; 2789 :                  "View_transforms index 3 is %d, must be at least 1.\n",k);

	push	esi
	push	OFFSET ??_C@_0DE@LMFKCPDC@View_transforms?5index?53?5is?5?$CFd?0?5m@
	push	OFFSET _errmsg
	call	_sprintf

; 2790 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2791 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1174@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1174@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 2792 :              kb_error(2038,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2038					; 000007f6H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN15@other_stuf:

; 2793 :            }
; 2794 :            if ( (view_transforms == 0)  && (i == 1))

	cmp	DWORD PTR _view_transforms, 0
	mov	ecx, DWORD PTR _i$91718[ebp]
	jne	SHORT $LN14@other_stuf
	cmp	ecx, 1
	jne	SHORT $LN14@other_stuf

; 2795 :            { *(++stacktop) =  (j==k) ? 1 : 0; break; }

	add	DWORD PTR [ebx+48], 8
	mov	ebx, DWORD PTR [ebx+48]
	xor	ecx, ecx
	cmp	DWORD PTR _j$91716[ebp], esi
	pop	edi
	sete	cl
	pop	esi
	mov	DWORD PTR tv10517[ebp], ecx
	fild	DWORD PTR tv10517[ebp]
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@other_stuf:

; 2796 :            if ( i > transform_count )

	mov	eax, DWORD PTR _transform_count
	cmp	ecx, eax
	jle	SHORT $LN13@other_stuf

; 2797 :            { sprintf(errmsg,
; 2798 :                  "View_transforms index 1 is %d, must be at most transform_count %d.\n",i,transform_count);

	push	eax
	push	ecx
	push	OFFSET ??_C@_0EE@EHAPANAL@View_transforms?5index?51?5is?5?$CFd?0?5m@
	push	OFFSET _errmsg
	call	_sprintf

; 2799 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2800 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
$LL1175@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1175@other_stuf
	mov	ecx, DWORD PTR [edi+16]
	sub	eax, edx
	mov	edx, DWORD PTR [edi+12]
	push	edx
	mov	edx, DWORD PTR _file_names
	mov	ecx, DWORD PTR [edx+ecx*4]
	push	ecx
	lea	edx, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	edx
	call	_sprintf

; 2801 :              kb_error(2039,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2039					; 000007f7H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN13@other_stuf:

; 2802 :            }
; 2803 :            if ( j > 4 )

	cmp	DWORD PTR _j$91716[ebp], 4
	jle	SHORT $LN12@other_stuf

; 2804 :            { sprintf(errmsg,
; 2805 :                  "View_transforms index 2 is %d, must be at most 4.\n",j);

	mov	eax, DWORD PTR _j$91716[ebp]
	push	eax
	push	OFFSET ??_C@_0DD@CAPLABHH@View_transforms?5index?52?5is?5?$CFd?0?5m@
	push	OFFSET _errmsg
	call	_sprintf

; 2806 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2807 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1176@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1176@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 2808 :              kb_error(2040,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2040					; 000007f8H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN12@other_stuf:

; 2809 :            }
; 2810 :            if ( k > 4 )

	cmp	esi, 4
	jle	SHORT $LN11@other_stuf

; 2811 :            { sprintf(errmsg,
; 2812 :                  "View_transforms index 3 is %d, must be at most 4.\n",k);

	push	esi
	push	OFFSET ??_C@_0DD@EDPMNIFD@View_transforms?5index?53?5is?5?$CFd?0?5m@
	push	OFFSET _errmsg
	call	_sprintf

; 2813 :              sprintf(errmsg+strlen(errmsg),"(source file %s, line %d)\n",
; 2814 :                  file_names[node->file_no],node->line_no);

	mov	eax, OFFSET _errmsg
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR [eax+1]
$LL1177@other_stuf:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL1177@other_stuf
	mov	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, DWORD PTR _file_names
	sub	eax, edx
	mov	edx, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	eax, DWORD PTR _errmsg[eax]
	push	OFFSET ??_C@_0BL@LMCMICK@?$CIsource?5file?5?$CFs?0?5line?5?$CFd?$CJ?6?$AA@
	push	eax
	call	_sprintf

; 2815 :              kb_error(2041,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	2041					; 000007f9H
	call	_kb_error
	add	esp, 28					; 0000001cH
$LN11@other_stuf:

; 2816 :            }
; 2817 :            *(++stacktop) = view_transforms[i-1][j-1][k-1];

	add	DWORD PTR [ebx+48], 8
	mov	ecx, DWORD PTR _view_transforms
	mov	edx, DWORD PTR _i$91718[ebp]
	mov	eax, DWORD PTR [ecx+edx*4-4]
	mov	ecx, DWORD PTR _j$91716[ebp]
	mov	edx, DWORD PTR [eax+ecx*4-4]
	mov	ebx, DWORD PTR [ebx+48]
	fld	QWORD PTR [edx+esi*8-8]
	pop	edi
	fstp	QWORD PTR [ebx]
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@other_stuf:

; 2818 :            break;
; 2819 :         }
; 2820 :     case TRANSFORM_DEPTH_NODE:
; 2821 :        generate_transforms((int)(*stacktop--));

	mov	esi, DWORD PTR [ebx+48]
	fld	QWORD PTR [esi]
	call	__ftol2_sse
	add	esi, -8					; fffffff8H
	push	eax
	mov	DWORD PTR [ebx+48], esi
	call	_generate_transforms
	add	esp, 4

; 2822 :        update_display();

	call	_update_display
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@other_stuf:

; 2823 :        break;
; 2824 : 
; 2825 :     case TRANSFORM_EXPR_NODE:
; 2826 :        calc_view_transform_gens();

	call	_calc_view_transform_gens

; 2827 :        transform_gen_expr(*(char**)(stacktop--));

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]
	add	eax, -8					; fffffff8H
	push	ecx
	mov	DWORD PTR [ebx+48], eax
	call	_transform_gen_expr
	add	esp, 4

; 2828 :        update_display();

	call	_update_display
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@other_stuf:

; 2829 :        break;
; 2830 : 
; 2831 :     case DEFINE_METHOD_INSTANCE_NODE:
; 2832 :     case DEFINE_QUANTITY_NODE:
; 2833 :     case DEFINE_CONSTRAINT_NODE:
; 2834 :     case DEFINE_BOUNDARY_NODE:
; 2835 :        /* was parse-time action */
; 2836 :        break;
; 2837 : 
; 2838 :     case GRAVITY_NODE:
; 2839 :        old = web.gravflag;

	mov	esi, DWORD PTR _web+824

; 2840 :        web.gravflag = (node->op1.toggle_state==ON_) ? 1 : 0;

	xor	eax, eax
	cmp	DWORD PTR [edi+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _web+824, eax

; 2841 :        outstring(web.gravflag ? "Gravity ON." : "Gravity OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0M@FDBIIEOE@Gravity?5ON?4?$AA@
	jne	SHORT $LN995@other_stuf
	mov	eax, OFFSET ??_C@_0N@CPEDIFLO@Gravity?5OFF?4?$AA@
$LN995@other_stuf:
	push	eax
	call	_outstring
	add	esp, 4

; 2842 :        outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN997@other_stuf
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN997@other_stuf:
	push	eax
	call	_outstring
	add	esp, 4

; 2843 :        recalc();

	call	_recalc
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@other_stuf:

; 2844 :        break;
; 2845 : 
; 2846 :     case TOGGLEVALUE_NODE:
; 2847 :        *++stacktop = (REAL)get_toggle_value(node->op1.toggle_id);

	add	DWORD PTR [ebx+48], 8
	mov	eax, DWORD PTR [edi+32]
	mov	ebx, DWORD PTR [ebx+48]
	push	eax
	call	_get_toggle_value
	add	esp, 4
	mov	DWORD PTR tv10466[ebp], eax
	fild	DWORD PTR tv10466[ebp]
	pop	edi
	pop	esi
	fstp	QWORD PTR [ebx]
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@other_stuf:

; 2848 :        break;
; 2849 : 
; 2850 :     case FACET_COLORS_NODE:
; 2851 :        old = color_flag;

	mov	esi, DWORD PTR _color_flag

; 2852 :        color_flag = (node->op1.toggle_state==ON_) ? 1 : 0; 

	xor	eax, eax
	cmp	DWORD PTR [edi+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _color_flag, eax

; 2853 :        outstring(color_flag ? "Facet colors ON.":
; 2854 :                                         "Facet colors OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BB@LNLINMBL@Facet?5colors?5ON?4?$AA@
	jne	SHORT $LN999@other_stuf
	mov	eax, OFFSET ??_C@_0BC@CKPMKGL@Facet?5colors?5OFF?4?$AA@
$LN999@other_stuf:
	push	eax
	call	_outstring
	add	esp, 4

; 2855 :           outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN1001@other_stuf
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN1001@other_stuf:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@other_stuf:

; 2856 :        break;
; 2857 : 
; 2858 :     case SHADING_NODE:
; 2859 :        old = shading_flag;

	mov	esi, DWORD PTR _shading_flag

; 2860 :        shading_flag = (node->op1.toggle_state==ON_) ? 1 : 0; 

	xor	eax, eax
	cmp	DWORD PTR [edi+32], 15000		; 00003a98H
	sete	al
	mov	DWORD PTR _shading_flag, eax

; 2861 :        outstring(shading_flag ? "Facet shading ON.":
; 2862 :                                         "Facet shading OFF.");

	test	eax, eax
	mov	eax, OFFSET ??_C@_0BC@NNLDDHA@Facet?5shading?5ON?4?$AA@
	jne	SHORT $LN1003@other_stuf
	mov	eax, OFFSET ??_C@_0BD@NIHPBBFE@Facet?5shading?5OFF?4?$AA@
$LN1003@other_stuf:
	push	eax
	call	_outstring
	add	esp, 4

; 2863 :           outstring(old?" (was on)\n":" (was off)\n");

	mov	eax, OFFSET ??_C@_0L@BBCJLGBA@?5?$CIwas?5on?$CJ?6?$AA@
	test	esi, esi
	jne	SHORT $LN1005@other_stuf
	mov	eax, OFFSET ??_C@_0M@COEFCKEL@?5?$CIwas?5off?$CJ?6?$AA@
$LN1005@other_stuf:
	push	eax
	call	_outstring
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@other_stuf:

; 2864 :        break;
; 2865 : 
; 2866 :     case PREPRINTF_NODE:
; 2867 :     case PRESPRINTF_NODE:
; 2868 :            break;
; 2869 :     case GO_NODE:
; 2870 :           iterate();

	call	_iterate
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1@other_stuf:

; 2871 :           break;
; 2872 : 
; 2873 :        default:
; 2874 :           more_other_stuff(node,recalc_flag,
; 2875 :               update_display_flag,q_id,localstack,localbase);

	mov	ecx, DWORD PTR _localbase$GSCopy$[ebp]
	mov	edx, DWORD PTR _localstack$GSCopy$[ebp]
	mov	eax, DWORD PTR _update_display_flag$GSCopy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _recalc_flag$GSCopy$[ebp]
	push	edx
	push	esi
	push	eax
	push	ecx
	push	edi
	call	_more_other_stuff
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1357@other_stuf:

; 615  :              if (gravity_quantity_num >= 0 )

	fstp	ST(0)
$LN1333@other_stuf:
	fstp	ST(0)
$LN855@other_stuf:

; 2876 :           break;
; 2877 :   }
; 2878 : 
; 2879 : } /* end other_stuff() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1633@other_stuf:
	DD	$LN854@other_stuf
	DD	$LN853@other_stuf
	DD	$LN852@other_stuf
	DD	$LN851@other_stuf
	DD	$LN850@other_stuf
	DD	$LN849@other_stuf
	DD	$LN848@other_stuf
	DD	$LN847@other_stuf
	DD	$LN846@other_stuf
	DD	$LN843@other_stuf
	DD	$LN842@other_stuf
	DD	$LN841@other_stuf
	DD	$LN840@other_stuf
	DD	$LN839@other_stuf
	DD	$LN832@other_stuf
	DD	$LN831@other_stuf
	DD	$LN827@other_stuf
	DD	$LN826@other_stuf
	DD	$LN823@other_stuf
	DD	$LN787@other_stuf
	DD	$LN786@other_stuf
	DD	$LN781@other_stuf
	DD	$LN774@other_stuf
	DD	$LN767@other_stuf
	DD	$LN762@other_stuf
	DD	$LN757@other_stuf
	DD	$LN753@other_stuf
	DD	$LN752@other_stuf
	DD	$LN1@other_stuf
	DD	$LN1@other_stuf
	DD	$LN1@other_stuf
	DD	$LN1@other_stuf
	DD	$LN1@other_stuf
	DD	$LN626@other_stuf
	DD	$LN625@other_stuf
	DD	$LN624@other_stuf
	DD	$LN622@other_stuf
	DD	$LN617@other_stuf
	DD	$LN616@other_stuf
	DD	$LN615@other_stuf
	DD	$LN614@other_stuf
	DD	$LN613@other_stuf
	DD	$LN612@other_stuf
	DD	$LN611@other_stuf
	DD	$LN609@other_stuf
	DD	$LN608@other_stuf
	DD	$LN607@other_stuf
	DD	$LN606@other_stuf
	DD	$LN605@other_stuf
	DD	$LN602@other_stuf
	DD	$LN601@other_stuf
	DD	$LN601@other_stuf
	DD	$LN600@other_stuf
	DD	$LN600@other_stuf
	DD	$LN597@other_stuf
	DD	$LN594@other_stuf
	DD	$LN591@other_stuf
	DD	$LN588@other_stuf
	DD	$LN585@other_stuf
	DD	$LN579@other_stuf
	DD	$LN571@other_stuf
	DD	$LN571@other_stuf
	DD	$LN1@other_stuf
	DD	$LN1@other_stuf
	DD	$LN1@other_stuf
	DD	$LN1@other_stuf
	DD	$LN438@other_stuf
	DD	$LN206@other_stuf
	DD	$LN205@other_stuf
	DD	$LN202@other_stuf
	DD	$LN191@other_stuf
	DD	$LN190@other_stuf
	DD	$LN189@other_stuf
	DD	$LN184@other_stuf
	DD	$LN174@other_stuf
	DD	$LN173@other_stuf
	DD	$LN172@other_stuf
	DD	$LN169@other_stuf
	DD	$LN166@other_stuf
	DD	$LN163@other_stuf
	DD	$LN160@other_stuf
	DD	$LN157@other_stuf
	DD	$LN149@other_stuf
	DD	$LN148@other_stuf
	DD	$LN145@other_stuf
	DD	$LN144@other_stuf
	DD	$LN143@other_stuf
	DD	$LN142@other_stuf
	DD	$LN855@other_stuf
	DD	$LN855@other_stuf
	DD	$LN855@other_stuf
	DD	$LN140@other_stuf
	DD	$LN138@other_stuf
	DD	$LN134@other_stuf
	DD	$LN129@other_stuf
	DD	$LN129@other_stuf
	DD	$LN117@other_stuf
	DD	$LN115@other_stuf
	DD	$LN115@other_stuf
	DD	$LN106@other_stuf
	DD	$LN105@other_stuf
	DD	$LN96@other_stuf
	DD	$LN95@other_stuf
	DD	$LN94@other_stuf
	DD	$LN93@other_stuf
	DD	$LN92@other_stuf
	DD	$LN91@other_stuf
	DD	$LN90@other_stuf
	DD	$LN89@other_stuf
	DD	$LN88@other_stuf
	DD	$LN87@other_stuf
	DD	$LN86@other_stuf
	DD	$LN83@other_stuf
	DD	$LN80@other_stuf
	DD	$LN79@other_stuf
	DD	$LN78@other_stuf
	DD	$LN77@other_stuf
	DD	$LN75@other_stuf
	DD	$LN71@other_stuf
	DD	$LN62@other_stuf
	DD	$LN62@other_stuf
	DD	$LN61@other_stuf
	DD	$LN61@other_stuf
	DD	$LN60@other_stuf
	DD	$LN57@other_stuf
	DD	$LN54@other_stuf
	DD	$LN52@other_stuf
	DD	$LN51@other_stuf
	DD	$LN50@other_stuf
	DD	$LN49@other_stuf
	DD	$LN48@other_stuf
	DD	$LN45@other_stuf
	DD	$LN44@other_stuf
	DD	$LN43@other_stuf
	DD	$LN42@other_stuf
	DD	$LN41@other_stuf
	DD	$LN40@other_stuf
	DD	$LN39@other_stuf
	DD	$LN39@other_stuf
	DD	$LN37@other_stuf
	DD	$LN35@other_stuf
	DD	$LN34@other_stuf
	DD	$LN30@other_stuf
	DD	$LN28@other_stuf
	DD	$LN23@other_stuf
	DD	$LN20@other_stuf
	DD	$LN855@other_stuf
	DD	$LN18@other_stuf
	DD	$LN10@other_stuf
	DD	$LN9@other_stuf
	DD	$LN855@other_stuf
	DD	$LN855@other_stuf
	DD	$LN855@other_stuf
	DD	$LN855@other_stuf
	DD	$LN7@other_stuf
	DD	$LN6@other_stuf
	DD	$LN5@other_stuf
	DD	$LN4@other_stuf
	DD	$LN855@other_stuf
	DD	$LN855@other_stuf
	DD	$LN2@other_stuf
$LN1634@other_stuf:
	DD	$LN728@other_stuf
	DD	$LN707@other_stuf
	DD	$LN740@other_stuf
	DD	$LN735@other_stuf
	DD	$LN729@other_stuf
	DD	$LN726@other_stuf
	DD	$LN713@other_stuf
	DD	$LN716@other_stuf
	DD	$LN715@other_stuf
	DD	$LN714@other_stuf
	DD	$LN712@other_stuf
	DD	$LN709@other_stuf
	DD	$LN706@other_stuf
	DD	$LN710@other_stuf
	DD	$LN1448@other_stuf
$LN1110@other_stuf:
	DB	0
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	1
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	2
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	3
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	4
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	5
	DB	6
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	7
	DB	8
	DB	9
	DB	14					; 0000000eH
	DB	10					; 0000000aH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	11					; 0000000bH
	DB	14					; 0000000eH
	DB	12					; 0000000cH
	DB	1
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	13					; 0000000dH
$LN1635@other_stuf:
	DD	$LN733@other_stuf
	DD	$LN736@other_stuf
	DD	$LN727@other_stuf
	DD	$LN1398@other_stuf
	DD	$LN738@other_stuf
	DD	$LN730@other_stuf
	DD	$LN737@other_stuf
	DD	$LN739@other_stuf
	DD	$LN731@other_stuf
	DD	$LN732@other_stuf
	DD	$LN746@other_stuf
	DD	$LN745@other_stuf
	DD	$LN744@other_stuf
	DD	$LN743@other_stuf
	DD	$LN742@other_stuf
	DD	$LN741@other_stuf
	DD	$LN747@other_stuf
	DD	$LN1448@other_stuf
$LN1111@other_stuf:
	DB	0
	DB	1
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	2
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	3
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	4
	DB	5
	DB	17					; 00000011H
	DB	6
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	7
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	8
	DB	9
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	16					; 00000010H
	npad	1
$LN1636@other_stuf:
	DD	$LN719@other_stuf
	DD	$LN718@other_stuf
	DD	$LN717@other_stuf
	DD	$LN704@other_stuf
	DD	$LN721@other_stuf
	DD	$LN1448@other_stuf
$LN1113@other_stuf:
	DB	0
	DB	1
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
	npad	1
$LN1637@other_stuf:
	DD	$LN725@other_stuf
	DD	$LN724@other_stuf
	DD	$LN723@other_stuf
	DD	$LN722@other_stuf
$LN1638@other_stuf:
	DD	$LN698@other_stuf
	DD	$LN697@other_stuf
	DD	$LN696@other_stuf
	DD	$LN695@other_stuf
$LN1639@other_stuf:
	DD	$LN1288@other_stuf
	DD	$LN1279@other_stuf
	DD	$LN1291@other_stuf
	DD	$LN673@other_stuf
	DD	$LN1289@other_stuf
	DD	$LN1287@other_stuf
	DD	$LN1283@other_stuf
	DD	$LN1286@other_stuf
	DD	$LN1285@other_stuf
	DD	$LN1284@other_stuf
	DD	$LN1282@other_stuf
	DD	$LN1280@other_stuf
	DD	$LN1278@other_stuf
	DD	$LN1277@other_stuf
	DD	$LN1281@other_stuf
	DD	$LN1364@other_stuf
$LN1115@other_stuf:
	DB	0
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	1
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	2
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	3
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	4
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	5
	DB	6
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	7
	DB	8
	DB	9
	DB	15					; 0000000fH
	DB	10					; 0000000aH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	11					; 0000000bH
	DB	15					; 0000000fH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	14					; 0000000eH
$LN1640@other_stuf:
	DD	$LN1305@other_stuf
	DD	$LN1309@other_stuf
	DD	$LN1304@other_stuf
	DD	$LN1302@other_stuf
	DD	$LN679@other_stuf
	DD	$LN1308@other_stuf
	DD	$LN1310@other_stuf
	DD	$LN1303@other_stuf
	DD	$LN1307@other_stuf
	DD	$LN1306@other_stuf
	DD	$LN1317@other_stuf
	DD	$LN1316@other_stuf
	DD	$LN1315@other_stuf
	DD	$LN1314@other_stuf
	DD	$LN1313@other_stuf
	DD	$LN1312@other_stuf
	DD	$LN1318@other_stuf
	DD	$LN1364@other_stuf
$LN1117@other_stuf:
	DB	0
	DB	1
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	2
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	3
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	4
	DB	5
	DB	17					; 00000011H
	DB	6
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	7
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	8
	DB	9
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	16					; 00000010H
	npad	1
$LN1641@other_stuf:
	DD	$LN652@other_stuf
	DD	$LN651@other_stuf
	DD	$LN650@other_stuf
	DD	$LN637@other_stuf
	DD	$LN1333@other_stuf
	DD	$LN654@other_stuf
	DD	$LN1372@other_stuf
$LN1120@other_stuf:
	DB	0
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	npad	1
$LN1642@other_stuf:
	DD	$LN658@other_stuf
	DD	$LN657@other_stuf
	DD	$LN656@other_stuf
	DD	$LN655@other_stuf
$LN1643@other_stuf:
	DD	$LN566@other_stuf
	DD	$LN505@other_stuf
	DD	$LN565@other_stuf
	DD	$LN564@other_stuf
	DD	$LN563@other_stuf
	DD	$LN540@other_stuf
	DD	$LN523@other_stuf
	DD	$LN517@other_stuf
	DD	$LN516@other_stuf
	DD	$LN470@other_stuf
	DD	$LN465@other_stuf
	DD	$LN464@other_stuf
	DD	$LN458@other_stuf
	DD	$LN457@other_stuf
	DD	$LN453@other_stuf
	DD	$LN562@other_stuf
	DD	$LN441@other_stuf
	DD	$LN475@other_stuf
	DD	$LN461@other_stuf
	DD	$LN532@other_stuf
	DD	$LN527@other_stuf
	DD	$LN525@other_stuf
	DD	$LN463@other_stuf
	DD	$LN439@other_stuf
$LN1127@other_stuf:
	DB	0
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	1
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	2
	DB	23					; 00000017H
	DB	3
	DB	23					; 00000017H
	DB	4
	DB	23					; 00000017H
	DB	5
	DB	23					; 00000017H
	DB	6
	DB	7
	DB	8
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	23					; 00000017H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
	DB	22					; 00000016H
$LN1644@other_stuf:
	DD	$LN552@other_stuf
	DD	$LN551@other_stuf
	DD	$LN550@other_stuf
	DD	$LN547@other_stuf
	DD	$LN549@other_stuf
	DD	$LN548@other_stuf
	DD	$LN541@other_stuf
	DD	$LN544@other_stuf
	DD	$LN545@other_stuf
	DD	$LN543@other_stuf
	DD	$LN855@other_stuf
$LN1130@other_stuf:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	npad	1
$LN1645@other_stuf:
	DD	$LN333@other_stuf
	DD	$LN290@other_stuf
	DD	$LN276@other_stuf
	DD	$LN275@other_stuf
	DD	$LN470@other_stuf
	DD	$LN465@other_stuf
	DD	$LN464@other_stuf
	DD	$LN254@other_stuf
	DD	$LN253@other_stuf
	DD	$LN234@other_stuf
	DD	$LN430@other_stuf
	DD	$LN209@other_stuf
	DD	$LN264@other_stuf
	DD	$LN433@other_stuf
	DD	$LN532@other_stuf
	DD	$LN308@other_stuf
	DD	$LN299@other_stuf
	DD	$LN463@other_stuf
	DD	$LN207@other_stuf
$LN1143@other_stuf:
	DB	0
	DB	18					; 00000012H
	DB	1
	DB	2
	DB	3
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	4
	DB	5
	DB	6
	DB	7
	DB	7
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
$LN1646@other_stuf:
	DD	$LN420@other_stuf
	DD	$LN412@other_stuf
	DD	$LN404@other_stuf
	DD	$LN380@other_stuf
	DD	$LN356@other_stuf
	DD	$LN388@other_stuf
	DD	$LN396@other_stuf
	DD	$LN372@other_stuf
	DD	$LN364@other_stuf
	DD	$LN346@other_stuf
	DD	$LN348@other_stuf
	DD	$LN341@other_stuf
	DD	$LN855@other_stuf
$LN1146@other_stuf:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	9
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	npad	1
$LN1647@other_stuf:
	DD	$LN417@other_stuf
	DD	$LN416@other_stuf
	DD	$LN415@other_stuf
	DD	$LN414@other_stuf
	DD	$LN413@other_stuf
$LN1648@other_stuf:
	DD	$LN409@other_stuf
	DD	$LN408@other_stuf
	DD	$LN407@other_stuf
	DD	$LN406@other_stuf
	DD	$LN405@other_stuf
$LN1649@other_stuf:
	DD	$LN401@other_stuf
	DD	$LN400@other_stuf
	DD	$LN399@other_stuf
	DD	$LN398@other_stuf
	DD	$LN397@other_stuf
$LN1650@other_stuf:
	DD	$LN393@other_stuf
	DD	$LN392@other_stuf
	DD	$LN391@other_stuf
	DD	$LN390@other_stuf
	DD	$LN389@other_stuf
$LN1651@other_stuf:
	DD	$LN385@other_stuf
	DD	$LN384@other_stuf
	DD	$LN383@other_stuf
	DD	$LN382@other_stuf
	DD	$LN381@other_stuf
$LN1652@other_stuf:
	DD	$LN377@other_stuf
	DD	$LN376@other_stuf
	DD	$LN375@other_stuf
	DD	$LN374@other_stuf
	DD	$LN373@other_stuf
$LN1653@other_stuf:
	DD	$LN369@other_stuf
	DD	$LN368@other_stuf
	DD	$LN367@other_stuf
	DD	$LN366@other_stuf
	DD	$LN365@other_stuf
$LN1654@other_stuf:
	DD	$LN361@other_stuf
	DD	$LN360@other_stuf
	DD	$LN359@other_stuf
	DD	$LN358@other_stuf
	DD	$LN357@other_stuf
$LN1655@other_stuf:
	DD	$LN353@other_stuf
	DD	$LN352@other_stuf
	DD	$LN351@other_stuf
	DD	$LN350@other_stuf
	DD	$LN349@other_stuf
$LN1656@other_stuf:
	DD	$LN323@other_stuf
	DD	$LN322@other_stuf
	DD	$LN321@other_stuf
	DD	$LN320@other_stuf
$LN1657@other_stuf:
	DD	$LN304@other_stuf
	DD	$LN303@other_stuf
	DD	$LN302@other_stuf
	DD	$LN301@other_stuf
$LN1658@other_stuf:
	DD	$LN295@other_stuf
	DD	$LN294@other_stuf
	DD	$LN293@other_stuf
	DD	$LN292@other_stuf
$LN1659@other_stuf:
	DD	$LN286@other_stuf
	DD	$LN285@other_stuf
	DD	$LN284@other_stuf
	DD	$LN283@other_stuf
$LN1660@other_stuf:
	DD	$LN247@other_stuf
	DD	$LN246@other_stuf
	DD	$LN245@other_stuf
	DD	$LN244@other_stuf
$LN1661@other_stuf:
	DD	$LN239@other_stuf
	DD	$LN238@other_stuf
	DD	$LN237@other_stuf
	DD	$LN236@other_stuf
$LN1662@other_stuf:
	DD	$LN227@other_stuf
	DD	$LN226@other_stuf
	DD	$LN225@other_stuf
	DD	$LN224@other_stuf
$LN1663@other_stuf:
	DD	$LN213@other_stuf
	DD	$LN212@other_stuf
	DD	$LN211@other_stuf
	DD	$LN210@other_stuf
_other_stuff ENDP
_TEXT	ENDS
END
