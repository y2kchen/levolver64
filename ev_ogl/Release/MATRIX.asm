; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\levolver\yonkang-sefit\levolver\ev_ogl\MATRIX.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_mat_approx_solve_epsilon
_DATA	SEGMENT
_mat_approx_solve_epsilon DQ 03eb0c6f7a0b5ed8dr	; 1e-006
_DATA	ENDS
PUBLIC	_matcopy
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
; File c:\levolver\yonkang-sefit\levolver\ev_ogl\matrix.c
;	COMDAT _matcopy
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
tv129 = 16						; size = 4
_rows$ = 16						; size = 4
_cols$ = 20						; size = 4
_matcopy PROC						; COMDAT

; 51   : {

	push	ebp
	mov	ebp, esp
	push	ebx

; 52   :   int i;
; 53   : 
; 54   :   for ( i = 0 ; i < rows ; i++ )

	mov	ebx, DWORD PTR _rows$[ebp]
	test	ebx, ebx
	jle	SHORT $LN1@matcopy
	mov	eax, DWORD PTR _cols$[ebp]
	push	esi
	mov	esi, DWORD PTR _a$[ebp]
	push	edi
	mov	edi, DWORD PTR _b$[ebp]
	lea	ecx, DWORD PTR [eax*8]
	mov	DWORD PTR tv129[ebp], ecx
	sub	edi, esi
$LL8@matcopy:

; 55   :      memcpy((char *)a[i],(char *)b[i],cols*sizeof(REAL));

	mov	edx, DWORD PTR tv129[ebp]
	mov	eax, DWORD PTR [edi+esi]
	mov	ecx, DWORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	add	esi, 4
	dec	ebx
	jne	SHORT $LL8@matcopy
	pop	edi
	pop	esi
$LN1@matcopy:
	pop	ebx

; 56   : } // end matcopy()

	pop	ebp
	ret	0
_matcopy ENDP
_TEXT	ENDS
PUBLIC	??_C@_08PHBNMDHD@MATRIX?4C?$AA@			; `string'
PUBLIC	??_C@_0BG@NEFJNLIN@dmatrix?5from?5?$CFs?5?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	_kb_dmatrix
EXTRN	_kb_calloc:PROC
EXTRN	_outstring:PROC
EXTRN	_sprintf:PROC
EXTRN	_msg:DWORD
EXTRN	_memdebug:DWORD
;	COMDAT ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
CONST	SEGMENT
??_C@_08PHBNMDHD@MATRIX?4C?$AA@ DB 'MATRIX.C', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NEFJNLIN@dmatrix?5from?5?$CFs?5?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BG@NEFJNLIN@dmatrix?5from?5?$CFs?5?5?$CFd?4?6?$AA@ DB 'dmatrix fro'
	DB	'm %s  %d.', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _kb_dmatrix
_TEXT	SEGMENT
tv193 = -4						; size = 4
tv278 = 8						; size = 4
_rlo$ = 8						; size = 4
_rhi$ = 12						; size = 4
_clo$ = 16						; size = 4
_chi$ = 20						; size = 4
_file$ = 24						; size = 4
_line$ = 28						; size = 4
_kb_dmatrix PROC					; COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 84   :   int i;
; 85   :   REAL **m;
; 86   : 
; 87   : #ifdef MEMSTRINGS
; 88   :   if ( memdebug)

	cmp	DWORD PTR _memdebug, 0
	je	SHORT $LN5@kb_dmatrix

; 89   :   { sprintf(msg,"dmatrix from %s  %d.\n",file,line);

	mov	eax, DWORD PTR _line$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR _msg
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BG@NEFJNLIN@dmatrix?5from?5?$CFs?5?5?$CFd?4?6?$AA@
	push	edx
	call	_sprintf

; 90   :      outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H
$LN5@kb_dmatrix:

; 91   :   }
; 92   : #endif
; 93   :   if ( rhi-rlo+1 == 0 ) return NULL;

	mov	eax, DWORD PTR _rhi$[ebp]
	mov	ecx, DWORD PTR _rlo$[ebp]
	sub	eax, ecx
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR tv193[ebp], eax
	test	edx, edx
	jne	SHORT $LN4@kb_dmatrix
	xor	eax, eax

; 103  : } // end kb_dmatrix()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@kb_dmatrix:
	push	ebx
	push	esi
	push	edi

; 94   :   m = (REAL **)mycalloc((unsigned)(rhi-rlo+1+1),sizeof(REAL *));

	push	94					; 0000005eH
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	add	eax, 2
	push	4
	push	eax

; 95   :   m -= rlo;

	lea	edi, DWORD PTR [ecx*4]
	call	_kb_calloc

; 96   :   m++; /* room for private pointer */
; 97   : 
; 98   :   m[rlo-1] = (REAL *) mycalloc((unsigned)(chi-clo+1),(rhi-rlo+1)*sizeof(REAL));

	mov	ebx, DWORD PTR _chi$[ebp]
	mov	ecx, DWORD PTR tv193[ebp]
	sub	ebx, DWORD PTR _clo$[ebp]
	mov	esi, eax
	push	98					; 00000062H
	mov	eax, 4
	sub	eax, edi
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	lea	edx, DWORD PTR [ecx*8+8]
	add	esi, eax
	push	edx
	lea	eax, DWORD PTR [ebx+1]
	push	eax
	call	_kb_calloc

; 99   :   for ( i = rlo ; i <= rhi ; i++ )

	mov	edx, DWORD PTR _rhi$[ebp]
	mov	DWORD PTR [edi+esi-4], eax
	mov	eax, DWORD PTR _rlo$[ebp]
	add	esp, 32					; 00000020H
	cmp	eax, edx
	jg	SHORT $LN1@kb_dmatrix

; 94   :   m = (REAL **)mycalloc((unsigned)(rhi-rlo+1+1),sizeof(REAL *));

	lea	ecx, DWORD PTR [ebx*8+8]
	mov	DWORD PTR tv278[ebp], ecx
	mov	ecx, DWORD PTR _clo$[ebp]
	neg	ecx
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	npad	6
$LL3@kb_dmatrix:

; 100  :         m[i] = m[rlo-1] + (i - rlo)*(chi - clo + 1) - clo;

	mov	ebx, DWORD PTR [edi+esi-4]
	add	ebx, ecx
	add	ecx, DWORD PTR tv278[ebp]
	mov	DWORD PTR [esi+eax*4], ebx
	inc	eax
	cmp	eax, edx
	jle	SHORT $LL3@kb_dmatrix
$LN1@kb_dmatrix:
	pop	edi

; 101  : 
; 102  :   return m;

	mov	eax, esi
	pop	esi
	pop	ebx

; 103  : } // end kb_dmatrix()

	mov	esp, ebp
	pop	ebp
	ret	0
_kb_dmatrix ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@PBHFGFDJ@dmatrix3?5from?5?$CFs?5?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	_kb_dmatrix3
;	COMDAT ??_C@_0BH@PBHFGFDJ@dmatrix3?5from?5?$CFs?5?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@PBHFGFDJ@dmatrix3?5from?5?$CFs?5?5?$CFd?4?6?$AA@ DB 'dmatrix3 f'
	DB	'rom %s  %d.', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _kb_dmatrix3
_TEXT	SEGMENT
tv443 = -8						; size = 4
tv429 = -4						; size = 4
_n1$ = 8						; size = 4
_i$ = 12						; size = 4
_n2$ = 12						; size = 4
_n3$ = 16						; size = 4
_file$ = 20						; size = 4
_line$ = 24						; size = 4
_kb_dmatrix3 PROC					; COMDAT

; 122  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 123  :   int i,j;
; 124  :   REAL ***m;
; 125  : 
; 126  : #ifdef MEMSTRINGS
; 127  :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	je	SHORT $LN12@kb_dmatrix@2

; 128  :   { sprintf(msg,"dmatrix3 from %s  %d.\n",file,line);

	mov	eax, DWORD PTR _line$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR _msg
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BH@PBHFGFDJ@dmatrix3?5from?5?$CFs?5?5?$CFd?4?6?$AA@
	push	edx
	call	_sprintf

; 129  :      outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H
$LN12@kb_dmatrix@2:

; 130  :   }
; 131  : #endif
; 132  : 
; 133  :   if ( n1 <= 0 ) n1 = 1;

	push	ebx
	mov	ebx, DWORD PTR _n1$[ebp]
	push	esi
	push	edi
	test	ebx, ebx
	jg	SHORT $LN23@kb_dmatrix@2
	mov	ebx, 1
	mov	DWORD PTR _n1$[ebp], ebx
$LN23@kb_dmatrix@2:

; 134  :   if ( n2 <= 0 ) n2 = 1;

	mov	edi, DWORD PTR _n2$[ebp]
	test	edi, edi
	jg	SHORT $LN25@kb_dmatrix@2
	mov	edi, 1
$LN25@kb_dmatrix@2:

; 135  :   /* assumes all pointers same machine size and alignment */
; 136  :   m = (REAL ***)mycalloc((n2+1)*n1+1,sizeof(REAL **));

	lea	ecx, DWORD PTR [edi+1]
	imul	ecx, ebx
	push	136					; 00000088H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	inc	ecx
	push	4
	push	ecx
	call	_kb_calloc
	mov	esi, eax
	add	esp, 16					; 00000010H

; 137  : 
; 138  :   m++; /* room for private pointer to doubles */
; 139  :   for ( i = 0 ; i < n1 ; i++ )

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN7@kb_dmatrix@2

; 135  :   /* assumes all pointers same machine size and alignment */
; 136  :   m = (REAL ***)mycalloc((n2+1)*n1+1,sizeof(REAL **));

	lea	edx, DWORD PTR [edi*4]
	lea	ecx, DWORD PTR [esi+ebx*4+4]
$LL9@kb_dmatrix@2:

; 140  :      m[i] = (REAL **)(m + n1 + i*n2);

	mov	DWORD PTR [esi+eax*4+4], ecx
	inc	eax
	add	ecx, edx
	cmp	eax, ebx
	jl	SHORT $LL9@kb_dmatrix@2
$LN7@kb_dmatrix@2:

; 141  :   m[0][0] = (REAL *) mycalloc(n1*n2*n3,sizeof(REAL));

	mov	edx, ebx
	imul	edx, edi
	imul	edx, DWORD PTR _n3$[ebp]
	push	141					; 0000008dH
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	push	8
	push	edx
	call	_kb_calloc
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx], eax

; 142  :   m[-1] = (REAL **)(m[0][0]);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 143  :   for ( i = 0 ; i < n1 ; i++ )

	xor	eax, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _i$[ebp], eax
	cmp	ebx, eax
	jle	SHORT $LN21@kb_dmatrix@2

; 141  :   m[0][0] = (REAL *) mycalloc(n1*n2*n3,sizeof(REAL));

	mov	ecx, edi
	imul	ecx, DWORD PTR _n3$[ebp]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR tv429[ebp], eax
	mov	DWORD PTR tv443[ebp], ecx
$LL24@kb_dmatrix@2:

; 144  :      for ( j = 0 ; j < n2 ; j++ )

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN5@kb_dmatrix@2
	mov	ecx, DWORD PTR tv429[ebp]
	npad	4
$LL22@kb_dmatrix@2:

; 145  :         m[i][j] = m[0][0] + i*n2*n3 + j*n3;

	mov	edx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edx]
	mov	ebx, DWORD PTR _i$[ebp]
	mov	ebx, DWORD PTR [esi+ebx*4+4]
	add	edx, ecx
	mov	DWORD PTR [ebx+eax*4], edx
	mov	edx, DWORD PTR _n3$[ebp]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	inc	eax
	add	ecx, edx
	cmp	eax, edi
	jl	SHORT $LL22@kb_dmatrix@2

; 144  :      for ( j = 0 ; j < n2 ; j++ )

	mov	ebx, DWORD PTR _n1$[ebp]
	mov	ecx, DWORD PTR tv443[ebp]
$LN5@kb_dmatrix@2:

; 143  :   for ( i = 0 ; i < n1 ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv429[ebp], ecx
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, ebx
	jl	SHORT $LL24@kb_dmatrix@2
$LN21@kb_dmatrix@2:
	pop	edi

; 146  : 
; 147  :   return m;

	lea	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebx

; 148  : } // end kb_dmatrix3()

	mov	esp, ebp
	pop	ebp
	ret	0
_kb_dmatrix3 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@MIMJNEM@dmatrix4?5from?5?$CFs?5?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	_kb_dmatrix4
;	COMDAT ??_C@_0BH@MIMJNEM@dmatrix4?5from?5?$CFs?5?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@MIMJNEM@dmatrix4?5from?5?$CFs?5?5?$CFd?4?6?$AA@ DB 'dmatrix4 fr'
	DB	'om %s  %d.', 0aH, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _kb_dmatrix4
_TEXT	SEGMENT
tv503 = -12						; size = 4
tv640 = -8						; size = 4
tv429 = -8						; size = 4
tv677 = -4						; size = 4
tv497 = -4						; size = 4
tv657 = 8						; size = 4
_n1$ = 8						; size = 4
_n2$ = 12						; size = 4
_n3$ = 16						; size = 4
_n4$ = 20						; size = 4
_file$ = 24						; size = 4
_line$ = 28						; size = 4
_kb_dmatrix4 PROC					; COMDAT

; 192  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 193  :   int i,j,k;
; 194  :   REAL ****m;
; 195  : 
; 196  : #ifdef MEMSTRINGS
; 197  :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	je	SHORT $LN19@kb_dmatrix@3

; 198  :   { sprintf(msg,"dmatrix4 from %s  %d.\n",file,line);

	mov	eax, DWORD PTR _line$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR _msg
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BH@MIMJNEM@dmatrix4?5from?5?$CFs?5?5?$CFd?4?6?$AA@
	push	edx
	call	_sprintf

; 199  :      outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H
$LN19@kb_dmatrix@3:

; 200  :   }
; 201  : #endif
; 202  : 
; 203  :   if ( n1 <= 0 ) n1 = 1;

	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _n1$[ebp]
	test	edi, edi
	jg	SHORT $LN34@kb_dmatrix@3
	mov	edi, 1
	mov	DWORD PTR _n1$[ebp], edi
$LN34@kb_dmatrix@3:

; 204  :   if ( n2 <= 0 ) n2 = 1;

	mov	ebx, DWORD PTR _n2$[ebp]
	test	ebx, ebx
	jg	SHORT $LN38@kb_dmatrix@3
	mov	ebx, 1
	mov	DWORD PTR _n2$[ebp], ebx
$LN38@kb_dmatrix@3:

; 205  :   if ( n3 <= 0 ) n3 = 1;

	cmp	DWORD PTR _n3$[ebp], 0
	jg	SHORT $LN39@kb_dmatrix@3
	mov	DWORD PTR _n3$[ebp], 1
$LN39@kb_dmatrix@3:

; 206  : 
; 207  :   /* assumes all pointers same machine size and alignment */
; 208  :   m = (REAL ****)mycalloc(1+n1+n1*n2+n1*n2*n3,sizeof(REAL ***));

	mov	ecx, DWORD PTR _n3$[ebp]
	inc	ecx
	imul	ecx, ebx
	inc	ecx
	imul	ecx, edi
	push	208					; 000000d0H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	inc	ecx
	push	4
	push	ecx
	call	_kb_calloc

; 209  : 
; 210  :   m++; /* room for private pointer */
; 211  :   for ( i = 0 ; i < n1 ; i++ )

	xor	edx, edx
	add	esp, 16					; 00000010H
	lea	esi, DWORD PTR [eax+4]
	cmp	edi, edx
	jle	SHORT $LN13@kb_dmatrix@3

; 206  : 
; 207  :   /* assumes all pointers same machine size and alignment */
; 208  :   m = (REAL ****)mycalloc(1+n1+n1*n2+n1*n2*n3,sizeof(REAL ***));

	mov	eax, ebx
	imul	eax, DWORD PTR _n3$[ebp]
	mov	DWORD PTR tv503[ebp], eax
	lea	eax, DWORD PTR [esi+edi*4]
	mov	DWORD PTR tv429[ebp], edx
	mov	DWORD PTR tv497[ebp], eax
$LL36@kb_dmatrix@3:

; 212  :      { m[i] = (REAL ***)(m + n1 + i*n2);

	mov	ecx, DWORD PTR tv497[ebp]

; 213  :         for ( j = 0 ; j < n2 ; j++ )

	xor	eax, eax
	mov	DWORD PTR [esi+edx*4], ecx
	test	ebx, ebx
	jle	SHORT $LN14@kb_dmatrix@3

; 212  :      { m[i] = (REAL ***)(m + n1 + i*n2);

	lea	ecx, DWORD PTR [ebx+1]
	imul	ecx, edi
	add	ecx, DWORD PTR tv429[ebp]
	lea	ecx, DWORD PTR [esi+ecx*4]
	npad	8
$LL12@kb_dmatrix@3:

; 214  :           m[i][j] = (REAL **)(m + n1 + n1*n2 + i*n2*n3 + j*n3);

	mov	edi, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edi+eax*4], ecx
	mov	edi, DWORD PTR _n3$[ebp]
	add	edi, edi
	add	edi, edi
	inc	eax
	add	ecx, edi
	cmp	eax, ebx
	jl	SHORT $LL12@kb_dmatrix@3

; 213  :         for ( j = 0 ; j < n2 ; j++ )

	mov	edi, DWORD PTR _n1$[ebp]
$LN14@kb_dmatrix@3:

; 209  : 
; 210  :   m++; /* room for private pointer */
; 211  :   for ( i = 0 ; i < n1 ; i++ )

	lea	eax, DWORD PTR [ebx*4]
	add	DWORD PTR tv497[ebp], eax
	mov	eax, DWORD PTR tv503[ebp]
	add	DWORD PTR tv429[ebp], eax
	inc	edx
	cmp	edx, edi
	jl	SHORT $LL36@kb_dmatrix@3
$LN13@kb_dmatrix@3:

; 215  :      }
; 216  :   m[0][0][0] = (REAL *) mycalloc(n1*n2*n3*n4,sizeof(REAL));

	mov	ecx, edi
	imul	ecx, ebx
	imul	ecx, DWORD PTR _n3$[ebp]
	imul	ecx, DWORD PTR _n4$[ebp]
	push	216					; 000000d8H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	push	8
	push	ecx
	call	_kb_calloc
	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 217  :   m[-1] = (REAL***)(m[0][0][0]);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi-4], ecx

; 218  :   for ( i = 0 ; i < n1 ; i++ )

	test	edi, edi
	jle	SHORT $LN32@kb_dmatrix@3

; 215  :      }
; 216  :   m[0][0][0] = (REAL *) mycalloc(n1*n2*n3*n4,sizeof(REAL));

	mov	DWORD PTR tv640[ebp], 0
	mov	DWORD PTR tv657[ebp], esi
	mov	DWORD PTR tv677[ebp], edi
	npad	2
$LL35@kb_dmatrix@3:

; 219  :      for ( j = 0 ; j < n2 ; j++ )

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN8@kb_dmatrix@3
$LL37@kb_dmatrix@3:

; 220  :         for ( k = 0 ; k < n3 ; k++ )

	mov	edx, DWORD PTR _n3$[ebp]
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN5@kb_dmatrix@3
	mov	eax, DWORD PTR tv640[ebp]
	add	eax, edi
	imul	eax, edx
	imul	eax, DWORD PTR _n4$[ebp]
	add	eax, eax
	add	eax, eax
	add	eax, eax
$LL33@kb_dmatrix@3:

; 221  :           m[i][j][k] = m[0][0][0] + i*n2*n3*n4 + j*n3*n4 + k*n4;

	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx]
	mov	ebx, DWORD PTR tv657[ebp]
	mov	ebx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [ebx+edi*4]
	add	edx, eax
	mov	DWORD PTR [ebx+ecx*4], edx
	mov	edx, DWORD PTR _n4$[ebp]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	inc	ecx
	add	eax, edx
	cmp	ecx, DWORD PTR _n3$[ebp]
	jl	SHORT $LL33@kb_dmatrix@3

; 220  :         for ( k = 0 ; k < n3 ; k++ )

	mov	ebx, DWORD PTR _n2$[ebp]
$LN5@kb_dmatrix@3:

; 219  :      for ( j = 0 ; j < n2 ; j++ )

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL37@kb_dmatrix@3
$LN8@kb_dmatrix@3:

; 218  :   for ( i = 0 ; i < n1 ; i++ )

	add	DWORD PTR tv657[ebp], 4
	add	DWORD PTR tv640[ebp], ebx
	dec	DWORD PTR tv677[ebp]
	jne	SHORT $LL35@kb_dmatrix@3
$LN32@kb_dmatrix@3:
	pop	edi

; 222  : 
; 223  :   return m;

	mov	eax, esi
	pop	esi
	pop	ebx

; 224  : } // end kb_dmatrix4()

	mov	esp, ebp
	pop	ebp
	ret	0
_kb_dmatrix4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@GNBEEBML@temp_dmatrix?5from?5?$CFs?5?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	_kb_temp_dmatrix
EXTRN	_kb_temp_calloc:PROC
;	COMDAT ??_C@_0BL@GNBEEBML@temp_dmatrix?5from?5?$CFs?5?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BL@GNBEEBML@temp_dmatrix?5from?5?$CFs?5?5?$CFd?4?6?$AA@ DB 'temp_d'
	DB	'matrix from %s  %d.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _kb_temp_dmatrix
_TEXT	SEGMENT
tv193 = -4						; size = 4
tv278 = 8						; size = 4
_rlo$ = 8						; size = 4
_rhi$ = 12						; size = 4
_clo$ = 16						; size = 4
_chi$ = 20						; size = 4
_file$ = 24						; size = 4
_line$ = 28						; size = 4
_kb_temp_dmatrix PROC					; COMDAT

; 246  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 247  :   int i;
; 248  :   REAL **m;
; 249  : 
; 250  : #ifdef MEMSTRINGS
; 251  :   if ( memdebug)

	cmp	DWORD PTR _memdebug, 0
	je	SHORT $LN5@kb_temp_dm

; 252  :   { sprintf(msg,"temp_dmatrix from %s  %d.\n",file,line);

	mov	eax, DWORD PTR _line$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR _msg
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BL@GNBEEBML@temp_dmatrix?5from?5?$CFs?5?5?$CFd?4?6?$AA@
	push	edx
	call	_sprintf

; 253  :      outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H
$LN5@kb_temp_dm:

; 254  :   }
; 255  : #endif
; 256  :   if ( rhi-rlo+1 == 0 ) return NULL;

	mov	eax, DWORD PTR _rhi$[ebp]
	mov	ecx, DWORD PTR _rlo$[ebp]
	sub	eax, ecx
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR tv193[ebp], eax
	test	edx, edx
	jne	SHORT $LN4@kb_temp_dm
	xor	eax, eax

; 266  : } // end kb_temp_dmatrix()

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@kb_temp_dm:
	push	ebx
	push	esi
	push	edi

; 257  :   m = (REAL **)temp_calloc((unsigned)(rhi-rlo+1+1),sizeof(REAL *));

	push	257					; 00000101H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	add	eax, 2
	push	4
	push	eax

; 258  :   m -= rlo;

	lea	edi, DWORD PTR [ecx*4]
	call	_kb_temp_calloc

; 259  :   m++; /* room for private pointer */
; 260  : 
; 261  :   m[rlo-1] = (REAL *) temp_calloc((unsigned)(chi-clo+1),(rhi-rlo+1)*sizeof(REAL));

	mov	ebx, DWORD PTR _chi$[ebp]
	mov	ecx, DWORD PTR tv193[ebp]
	sub	ebx, DWORD PTR _clo$[ebp]
	mov	esi, eax
	push	261					; 00000105H
	mov	eax, 4
	sub	eax, edi
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	lea	edx, DWORD PTR [ecx*8+8]
	add	esi, eax
	push	edx
	lea	eax, DWORD PTR [ebx+1]
	push	eax
	call	_kb_temp_calloc

; 262  :   for ( i = rlo ; i <= rhi ; i++ )

	mov	edx, DWORD PTR _rhi$[ebp]
	mov	DWORD PTR [edi+esi-4], eax
	mov	eax, DWORD PTR _rlo$[ebp]
	add	esp, 32					; 00000020H
	cmp	eax, edx
	jg	SHORT $LN1@kb_temp_dm

; 257  :   m = (REAL **)temp_calloc((unsigned)(rhi-rlo+1+1),sizeof(REAL *));

	lea	ecx, DWORD PTR [ebx*8+8]
	mov	DWORD PTR tv278[ebp], ecx
	mov	ecx, DWORD PTR _clo$[ebp]
	neg	ecx
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
$LL3@kb_temp_dm:

; 263  :         m[i] = m[rlo-1] + (i - rlo)*(chi - clo + 1) - clo;

	mov	ebx, DWORD PTR [edi+esi-4]
	add	ebx, ecx
	add	ecx, DWORD PTR tv278[ebp]
	mov	DWORD PTR [esi+eax*4], ebx
	inc	eax
	cmp	eax, edx
	jle	SHORT $LL3@kb_temp_dm
$LN1@kb_temp_dm:
	pop	edi

; 264  : 
; 265  :   return m;

	mov	eax, esi
	pop	esi
	pop	ebx

; 266  : } // end kb_temp_dmatrix()

	mov	esp, ebp
	pop	ebp
	ret	0
_kb_temp_dmatrix ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@GOHDMMAG@temp_dmatrix3?5from?5?$CFs?5?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	_kb_temp_dmatrix3
;	COMDAT ??_C@_0BM@GOHDMMAG@temp_dmatrix3?5from?5?$CFs?5?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@GOHDMMAG@temp_dmatrix3?5from?5?$CFs?5?5?$CFd?4?6?$AA@ DB 'temp_'
	DB	'dmatrix3 from %s  %d.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _kb_temp_dmatrix3
_TEXT	SEGMENT
tv443 = -8						; size = 4
tv429 = -4						; size = 4
_n1$ = 8						; size = 4
_i$ = 12						; size = 4
_n2$ = 12						; size = 4
_n3$ = 16						; size = 4
_file$ = 20						; size = 4
_line$ = 24						; size = 4
_kb_temp_dmatrix3 PROC					; COMDAT

; 288  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 289  :   int i,j;
; 290  :   REAL ***m;
; 291  : 
; 292  : #ifdef MEMSTRINGS
; 293  :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	je	SHORT $LN12@kb_temp_dm@2

; 294  :   { sprintf(msg,"temp_dmatrix3 from %s  %d.\n",file,line);

	mov	eax, DWORD PTR _line$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR _msg
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BM@GOHDMMAG@temp_dmatrix3?5from?5?$CFs?5?5?$CFd?4?6?$AA@
	push	edx
	call	_sprintf

; 295  :      outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H
$LN12@kb_temp_dm@2:

; 296  :   }
; 297  : #endif
; 298  : 
; 299  :   if ( n1 <= 0 ) n1 = 1;

	push	ebx
	mov	ebx, DWORD PTR _n1$[ebp]
	push	esi
	push	edi
	test	ebx, ebx
	jg	SHORT $LN23@kb_temp_dm@2
	mov	ebx, 1
	mov	DWORD PTR _n1$[ebp], ebx
$LN23@kb_temp_dm@2:

; 300  :   if ( n2 <= 0 ) n2 = 1;

	mov	edi, DWORD PTR _n2$[ebp]
	test	edi, edi
	jg	SHORT $LN25@kb_temp_dm@2
	mov	edi, 1
$LN25@kb_temp_dm@2:

; 301  :   /* assumes all pointers same machine size and alignment */
; 302  :   m = (REAL ***)temp_calloc((n2+1)*n1+1,sizeof(REAL **));

	lea	ecx, DWORD PTR [edi+1]
	imul	ecx, ebx
	push	302					; 0000012eH
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	inc	ecx
	push	4
	push	ecx
	call	_kb_temp_calloc
	mov	esi, eax
	add	esp, 16					; 00000010H

; 303  : 
; 304  :   m++; /* room for private pointer to doubles */
; 305  :   for ( i = 0 ; i < n1 ; i++ )

	xor	eax, eax
	test	ebx, ebx
	jle	SHORT $LN7@kb_temp_dm@2

; 301  :   /* assumes all pointers same machine size and alignment */
; 302  :   m = (REAL ***)temp_calloc((n2+1)*n1+1,sizeof(REAL **));

	lea	edx, DWORD PTR [edi*4]
	lea	ecx, DWORD PTR [esi+ebx*4+4]
$LL9@kb_temp_dm@2:

; 306  :      m[i] = (REAL **)(m + n1 + i*n2);

	mov	DWORD PTR [esi+eax*4+4], ecx
	inc	eax
	add	ecx, edx
	cmp	eax, ebx
	jl	SHORT $LL9@kb_temp_dm@2
$LN7@kb_temp_dm@2:

; 307  :   m[0][0] = (REAL *) temp_calloc(n1*n2*n3,sizeof(REAL));

	mov	edx, ebx
	imul	edx, edi
	imul	edx, DWORD PTR _n3$[ebp]
	push	307					; 00000133H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	push	8
	push	edx
	call	_kb_temp_calloc
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx], eax

; 308  :   m[-1] = (REAL **)(m[0][0]);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax

; 309  :   for ( i = 0 ; i < n1 ; i++ )

	xor	eax, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _i$[ebp], eax
	cmp	ebx, eax
	jle	SHORT $LN21@kb_temp_dm@2

; 307  :   m[0][0] = (REAL *) temp_calloc(n1*n2*n3,sizeof(REAL));

	mov	ecx, edi
	imul	ecx, DWORD PTR _n3$[ebp]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR tv429[ebp], eax
	mov	DWORD PTR tv443[ebp], ecx
$LL24@kb_temp_dm@2:

; 310  :      for ( j = 0 ; j < n2 ; j++ )

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN5@kb_temp_dm@2
	mov	ecx, DWORD PTR tv429[ebp]
	npad	4
$LL22@kb_temp_dm@2:

; 311  :         m[i][j] = m[0][0] + i*n2*n3 + j*n3;

	mov	edx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [edx]
	mov	ebx, DWORD PTR _i$[ebp]
	mov	ebx, DWORD PTR [esi+ebx*4+4]
	add	edx, ecx
	mov	DWORD PTR [ebx+eax*4], edx
	mov	edx, DWORD PTR _n3$[ebp]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	inc	eax
	add	ecx, edx
	cmp	eax, edi
	jl	SHORT $LL22@kb_temp_dm@2

; 310  :      for ( j = 0 ; j < n2 ; j++ )

	mov	ebx, DWORD PTR _n1$[ebp]
	mov	ecx, DWORD PTR tv443[ebp]
$LN5@kb_temp_dm@2:

; 309  :   for ( i = 0 ; i < n1 ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv429[ebp], ecx
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, ebx
	jl	SHORT $LL24@kb_temp_dm@2
$LN21@kb_temp_dm@2:
	pop	edi

; 312  : 
; 313  :   return m;

	lea	eax, DWORD PTR [esi+4]
	pop	esi
	pop	ebx

; 314  : } // end kb_temp_dmatrix3()

	mov	esp, ebp
	pop	ebp
	ret	0
_kb_temp_dmatrix3 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@JDIKDEHD@temp_dmatrix4?5from?5?$CFs?5?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	_kb_temp_dmatrix4
;	COMDAT ??_C@_0BM@JDIKDEHD@temp_dmatrix4?5from?5?$CFs?5?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@JDIKDEHD@temp_dmatrix4?5from?5?$CFs?5?5?$CFd?4?6?$AA@ DB 'temp_'
	DB	'dmatrix4 from %s  %d.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _kb_temp_dmatrix4
_TEXT	SEGMENT
tv503 = -12						; size = 4
tv640 = -8						; size = 4
tv429 = -8						; size = 4
tv677 = -4						; size = 4
tv497 = -4						; size = 4
tv657 = 8						; size = 4
_n1$ = 8						; size = 4
_n2$ = 12						; size = 4
_n3$ = 16						; size = 4
_n4$ = 20						; size = 4
_file$ = 24						; size = 4
_line$ = 28						; size = 4
_kb_temp_dmatrix4 PROC					; COMDAT

; 335  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 336  :   int i,j,k;
; 337  :   REAL ****m;
; 338  : 
; 339  : #ifdef MEMSTRINGS
; 340  :   if ( memdebug )

	cmp	DWORD PTR _memdebug, 0
	je	SHORT $LN19@kb_temp_dm@3

; 341  :   { sprintf(msg,"temp_dmatrix4 from %s  %d.\n",file,line);

	mov	eax, DWORD PTR _line$[ebp]
	mov	ecx, DWORD PTR _file$[ebp]
	mov	edx, DWORD PTR _msg
	push	eax
	push	ecx
	push	OFFSET ??_C@_0BM@JDIKDEHD@temp_dmatrix4?5from?5?$CFs?5?5?$CFd?4?6?$AA@
	push	edx
	call	_sprintf

; 342  :      outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 20					; 00000014H
$LN19@kb_temp_dm@3:

; 343  :   }
; 344  : #endif
; 345  : 
; 346  :   if ( n1 <= 0 ) n1 = 1;

	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _n1$[ebp]
	test	edi, edi
	jg	SHORT $LN34@kb_temp_dm@3
	mov	edi, 1
	mov	DWORD PTR _n1$[ebp], edi
$LN34@kb_temp_dm@3:

; 347  :   if ( n2 <= 0 ) n2 = 1;

	mov	ebx, DWORD PTR _n2$[ebp]
	test	ebx, ebx
	jg	SHORT $LN38@kb_temp_dm@3
	mov	ebx, 1
	mov	DWORD PTR _n2$[ebp], ebx
$LN38@kb_temp_dm@3:

; 348  :   if ( n3 <= 0 ) n3 = 1;

	cmp	DWORD PTR _n3$[ebp], 0
	jg	SHORT $LN39@kb_temp_dm@3
	mov	DWORD PTR _n3$[ebp], 1
$LN39@kb_temp_dm@3:

; 349  : 
; 350  :   /* assumes all pointers same machine size and alignment */
; 351  :   m = (REAL ****)temp_calloc(1+n1+n1*n2+n1*n2*n3,sizeof(REAL ***));

	mov	ecx, DWORD PTR _n3$[ebp]
	inc	ecx
	imul	ecx, ebx
	inc	ecx
	imul	ecx, edi
	push	351					; 0000015fH
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	inc	ecx
	push	4
	push	ecx
	call	_kb_temp_calloc

; 352  : 
; 353  :   m++; /* room for private pointer */
; 354  :   for ( i = 0 ; i < n1 ; i++ )

	xor	edx, edx
	add	esp, 16					; 00000010H
	lea	esi, DWORD PTR [eax+4]
	cmp	edi, edx
	jle	SHORT $LN13@kb_temp_dm@3

; 349  : 
; 350  :   /* assumes all pointers same machine size and alignment */
; 351  :   m = (REAL ****)temp_calloc(1+n1+n1*n2+n1*n2*n3,sizeof(REAL ***));

	mov	eax, ebx
	imul	eax, DWORD PTR _n3$[ebp]
	mov	DWORD PTR tv503[ebp], eax
	lea	eax, DWORD PTR [esi+edi*4]
	mov	DWORD PTR tv429[ebp], edx
	mov	DWORD PTR tv497[ebp], eax
$LL36@kb_temp_dm@3:

; 355  :      { m[i] = (REAL ***)(m + n1 + i*n2);

	mov	ecx, DWORD PTR tv497[ebp]

; 356  :         for ( j = 0 ; j < n2 ; j++ )

	xor	eax, eax
	mov	DWORD PTR [esi+edx*4], ecx
	test	ebx, ebx
	jle	SHORT $LN14@kb_temp_dm@3

; 355  :      { m[i] = (REAL ***)(m + n1 + i*n2);

	lea	ecx, DWORD PTR [ebx+1]
	imul	ecx, edi
	add	ecx, DWORD PTR tv429[ebp]
	lea	ecx, DWORD PTR [esi+ecx*4]
	npad	8
$LL12@kb_temp_dm@3:

; 357  :           m[i][j] = (REAL **)(m + n1 + n1*n2 + i*n2*n3 + j*n3);

	mov	edi, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [edi+eax*4], ecx
	mov	edi, DWORD PTR _n3$[ebp]
	add	edi, edi
	add	edi, edi
	inc	eax
	add	ecx, edi
	cmp	eax, ebx
	jl	SHORT $LL12@kb_temp_dm@3

; 356  :         for ( j = 0 ; j < n2 ; j++ )

	mov	edi, DWORD PTR _n1$[ebp]
$LN14@kb_temp_dm@3:

; 352  : 
; 353  :   m++; /* room for private pointer */
; 354  :   for ( i = 0 ; i < n1 ; i++ )

	lea	eax, DWORD PTR [ebx*4]
	add	DWORD PTR tv497[ebp], eax
	mov	eax, DWORD PTR tv503[ebp]
	add	DWORD PTR tv429[ebp], eax
	inc	edx
	cmp	edx, edi
	jl	SHORT $LL36@kb_temp_dm@3
$LN13@kb_temp_dm@3:

; 358  :      }
; 359  :   m[0][0][0] = (REAL *) temp_calloc(n1*n2*n3*n4,sizeof(REAL));

	mov	ecx, edi
	imul	ecx, ebx
	imul	ecx, DWORD PTR _n3$[ebp]
	imul	ecx, DWORD PTR _n4$[ebp]
	push	359					; 00000167H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	push	8
	push	ecx
	call	_kb_temp_calloc
	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 360  :   m[-1] = (REAL***)(m[0][0][0]);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi-4], ecx

; 361  :   for ( i = 0 ; i < n1 ; i++ )

	test	edi, edi
	jle	SHORT $LN32@kb_temp_dm@3

; 358  :      }
; 359  :   m[0][0][0] = (REAL *) temp_calloc(n1*n2*n3*n4,sizeof(REAL));

	mov	DWORD PTR tv640[ebp], 0
	mov	DWORD PTR tv657[ebp], esi
	mov	DWORD PTR tv677[ebp], edi
	npad	2
$LL35@kb_temp_dm@3:

; 362  :      for ( j = 0 ; j < n2 ; j++ )

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN8@kb_temp_dm@3
$LL37@kb_temp_dm@3:

; 363  :         for ( k = 0 ; k < n3 ; k++ )

	mov	edx, DWORD PTR _n3$[ebp]
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN5@kb_temp_dm@3
	mov	eax, DWORD PTR tv640[ebp]
	add	eax, edi
	imul	eax, edx
	imul	eax, DWORD PTR _n4$[ebp]
	add	eax, eax
	add	eax, eax
	add	eax, eax
$LL33@kb_temp_dm@3:

; 364  :           m[i][j][k] = m[0][0][0] + i*n2*n3*n4 + j*n3*n4 + k*n4;

	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx]
	mov	ebx, DWORD PTR tv657[ebp]
	mov	ebx, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [ebx+edi*4]
	add	edx, eax
	mov	DWORD PTR [ebx+ecx*4], edx
	mov	edx, DWORD PTR _n4$[ebp]
	add	edx, edx
	add	edx, edx
	add	edx, edx
	inc	ecx
	add	eax, edx
	cmp	ecx, DWORD PTR _n3$[ebp]
	jl	SHORT $LL33@kb_temp_dm@3

; 363  :         for ( k = 0 ; k < n3 ; k++ )

	mov	ebx, DWORD PTR _n2$[ebp]
$LN5@kb_temp_dm@3:

; 362  :      for ( j = 0 ; j < n2 ; j++ )

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL37@kb_temp_dm@3
$LN8@kb_temp_dm@3:

; 361  :   for ( i = 0 ; i < n1 ; i++ )

	add	DWORD PTR tv657[ebp], 4
	add	DWORD PTR tv640[ebp], ebx
	dec	DWORD PTR tv677[ebp]
	jne	SHORT $LL35@kb_temp_dm@3
$LN32@kb_temp_dm@3:
	pop	edi

; 365  : 
; 366  :   return m;

	mov	eax, esi
	pop	esi
	pop	ebx

; 367  : } // end kb_temp_dmatrix4()

	mov	esp, ebp
	pop	ebp
	ret	0
_kb_temp_dmatrix4 ENDP
_TEXT	ENDS
PUBLIC	_perm_matrix2
EXTRN	_calloc:PROC
; Function compile flags: /Ogtp
;	COMDAT _perm_matrix2
_TEXT	SEGMENT
_rows$ = 8						; size = 4
_cols$ = 12						; size = 4
_perm_matrix2 PROC					; COMDAT

; 376  : { REAL **m;

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 377  :   int i;
; 378  :   m = (REAL**)calloc(rows,sizeof(REAL*));

	mov	edi, DWORD PTR _rows$[ebp]
	push	4
	push	edi
	call	_calloc

; 379  :   m[0] = (REAL*)calloc(rows*cols,sizeof(REAL));

	mov	ebx, DWORD PTR _cols$[ebp]
	mov	esi, eax
	mov	eax, edi
	imul	eax, ebx
	push	8
	push	eax
	call	_calloc
	mov	DWORD PTR [esi], eax

; 380  :   for ( i = 1 ; i < rows ; i++ )

	mov	eax, 1
	add	esp, 16					; 00000010H
	cmp	edi, eax
	jle	SHORT $LN8@perm_matri
	lea	ecx, DWORD PTR [ebx*8]
	npad	8
$LL3@perm_matri:

; 381  :     m[i] = m[i-1] + cols;

	mov	edx, DWORD PTR [esi+eax*4-4]
	add	edx, ecx
	mov	DWORD PTR [esi+eax*4], edx
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL3@perm_matri
$LN8@perm_matri:
	pop	edi

; 382  :   return m;

	mov	eax, esi
	pop	esi
	pop	ebx

; 383  : } // end perm_matrix2()

	pop	ebp
	ret	0
_perm_matrix2 ENDP
_TEXT	ENDS
PUBLIC	_mat2d_setup
; Function compile flags: /Ogtp
;	COMDAT _mat2d_setup
_TEXT	SEGMENT
_name$ = 8						; size = 4
_spacename$ = 12					; size = 4
_rows$ = 16						; size = 4
_cols$ = 20						; size = 4
_mat2d_setup PROC					; COMDAT

; 399  : { REAL **spot = name;

	push	ebp
	mov	ebp, esp

; 400  :   for ( ; rows > 0 ; rows--,spacename += cols,spot++ )

	mov	ecx, DWORD PTR _rows$[ebp]
	mov	eax, DWORD PTR _name$[ebp]
	mov	edx, eax
	test	ecx, ecx
	jle	SHORT $LN1@mat2d_setu
	push	esi
	mov	esi, DWORD PTR _spacename$[ebp]
	push	edi
	mov	edi, DWORD PTR _cols$[ebp]
	add	edi, edi
	add	edi, edi
	add	edi, edi
	npad	3
$LL3@mat2d_setu:

; 401  :      *spot = spacename;

	mov	DWORD PTR [edx], esi
	dec	ecx
	add	esi, edi
	add	edx, 4
	test	ecx, ecx
	jg	SHORT $LL3@mat2d_setu
	pop	edi
	pop	esi
$LN1@mat2d_setu:

; 402  :   return name;
; 403  : } // end mat2d_setup()

	pop	ebp
	ret	0
_mat2d_setup ENDP
_TEXT	ENDS
PUBLIC	_mat3d_setup
; Function compile flags: /Ogtp
;	COMDAT _mat3d_setup
_TEXT	SEGMENT
_name$ = 8						; size = 4
_spacename$ = 12					; size = 4
_rows$ = 16						; size = 4
_cols$ = 20						; size = 4
_levels$ = 24						; size = 4
_mat3d_setup PROC					; COMDAT

; 412  : { int i;

	push	ebp
	mov	ebp, esp
	push	ebx

; 413  :   REAL ***spot;
; 414  :   REAL **row = (REAL **)(name + rows);

	mov	ebx, DWORD PTR _rows$[ebp]
	push	edi
	mov	edi, DWORD PTR _name$[ebp]
	lea	ecx, DWORD PTR [edi+ebx*4]

; 415  :   for ( spot = name ; rows > 0 ; rows--,spot++ )

	mov	eax, edi
	test	ebx, ebx
	jle	SHORT $LN4@mat3d_setu
	mov	edx, DWORD PTR _spacename$[ebp]
	push	esi
$LL6@mat3d_setu:

; 416  :   { *spot = row;
; 417  :      for ( i = 0 ; i < cols ; i++,spacename += levels, row++ )

	mov	esi, DWORD PTR _cols$[ebp]
	mov	DWORD PTR [eax], ecx
	test	esi, esi
	jle	SHORT $LN5@mat3d_setu
	mov	edi, DWORD PTR _levels$[ebp]
	add	edi, edi
	add	edi, edi
	add	edi, edi
	npad	6
$LL3@mat3d_setu:

; 418  :         *row = spacename;

	mov	DWORD PTR [ecx], edx
	add	edx, edi
	add	ecx, 4
	dec	esi
	jne	SHORT $LL3@mat3d_setu

; 416  :   { *spot = row;
; 417  :      for ( i = 0 ; i < cols ; i++,spacename += levels, row++ )

	mov	edi, DWORD PTR _name$[ebp]
$LN5@mat3d_setu:

; 415  :   for ( spot = name ; rows > 0 ; rows--,spot++ )

	dec	ebx
	add	eax, 4
	test	ebx, ebx
	jg	SHORT $LL6@mat3d_setu

; 419  :   }
; 420  :   return name;

	mov	eax, edi
	pop	esi
$LN4@mat3d_setu:
	pop	edi
	pop	ebx

; 421  : } // end mat3d_setup()

	pop	ebp
	ret	0
_mat3d_setup ENDP
_TEXT	ENDS
PUBLIC	_mat4d_setup
; Function compile flags: /Ogtp
;	COMDAT _mat4d_setup
_TEXT	SEGMENT
tv197 = -8						; size = 4
_spot$ = -4						; size = 4
_name$ = 8						; size = 4
_spacename$ = 12					; size = 4
_rows$ = 16						; size = 4
_cols$ = 20						; size = 4
_levels$ = 24						; size = 4
_tiers$ = 28						; size = 4
_mat4d_setup PROC					; COMDAT

; 431  : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 432  :   REAL ***row = (REAL ***)(name + rows);

	mov	edx, DWORD PTR _rows$[ebp]

; 433  :   REAL **col = (REAL **)(name + rows + rows*cols);

	mov	ecx, DWORD PTR _cols$[ebp]
	mov	eax, DWORD PTR _name$[ebp]
	inc	ecx
	imul	ecx, edx
	push	ebx
	lea	ebx, DWORD PTR [eax+edx*4]
	lea	ecx, DWORD PTR [eax+ecx*4]

; 434  :   REAL ****spot;
; 435  :   for (spot=name ; rows > 0 ; rows--,spot++ )

	mov	DWORD PTR _spot$[ebp], eax
	test	edx, edx
	jle	SHORT $LN7@mat4d_setu
	mov	eax, DWORD PTR _levels$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _spacename$[ebp]
	npad	7
$LL9@mat4d_setu:

; 436  :   { *spot = row;

	mov	esi, DWORD PTR _spot$[ebp]
	mov	DWORD PTR [esi], ebx

; 437  :      for ( i = 0 ; i < cols ; i++, row++ )

	mov	esi, DWORD PTR _cols$[ebp]
	test	esi, esi
	jle	SHORT $LN8@mat4d_setu

; 436  :   { *spot = row;

	mov	DWORD PTR tv197[ebp], esi
	npad	1
$LL6@mat4d_setu:

; 438  :      { *row = col;

	mov	DWORD PTR [ebx], ecx

; 439  :         for ( j = 0 ; j < levels ; j++,spacename += tiers, col++ )

	test	eax, eax
	jle	SHORT $LN5@mat4d_setu
	mov	esi, DWORD PTR _tiers$[ebp]
	add	esi, esi
	add	esi, esi
	add	esi, esi
	mov	edx, eax
$LL3@mat4d_setu:

; 440  :           *col = spacename;

	mov	DWORD PTR [ecx], edi
	add	edi, esi
	add	ecx, 4
	dec	edx
	jne	SHORT $LL3@mat4d_setu
$LN5@mat4d_setu:

; 437  :      for ( i = 0 ; i < cols ; i++, row++ )

	add	ebx, 4
	dec	DWORD PTR tv197[ebp]
	jne	SHORT $LL6@mat4d_setu
	mov	edx, DWORD PTR _rows$[ebp]
$LN8@mat4d_setu:

; 434  :   REAL ****spot;
; 435  :   for (spot=name ; rows > 0 ; rows--,spot++ )

	add	DWORD PTR _spot$[ebp], 4
	dec	edx
	mov	DWORD PTR _rows$[ebp], edx
	test	edx, edx
	jg	SHORT $LL9@mat4d_setu

; 441  :      }
; 442  :   }
; 443  :   return name;

	mov	eax, DWORD PTR _name$[ebp]
	pop	edi
	pop	esi
$LN7@mat4d_setu:
	pop	ebx

; 444  : } // end mat4d_setup()

	mov	esp, ebp
	pop	ebp
	ret	0
_mat4d_setup ENDP
_TEXT	ENDS
PUBLIC	_ivector
; Function compile flags: /Ogtp
;	COMDAT _ivector
_TEXT	SEGMENT
_lo$ = 8						; size = 4
_hi$ = 12						; size = 4
_ivector PROC						; COMDAT

; 456  : {

	push	ebp
	mov	ebp, esp

; 457  :   int *v;
; 458  : 
; 459  :   v = (int *)mycalloc((unsigned)(hi-lo+1),sizeof(int));
; 460  :   return v-lo;

	mov	eax, DWORD PTR _hi$[ebp]
	push	esi
	mov	esi, DWORD PTR _lo$[ebp]
	push	459					; 000001cbH
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	sub	eax, esi
	inc	eax
	push	4
	push	eax
	call	_kb_calloc
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR [esi*4]
	sub	eax, ecx
	pop	esi

; 461  : } // end ivector()

	pop	ebp
	ret	0
_ivector ENDP
_TEXT	ENDS
PUBLIC	_free_ivector
EXTRN	_myfree:PROC
; Function compile flags: /Ogtp
;	COMDAT _free_ivector
_TEXT	SEGMENT
_v$ = 8							; size = 4
_lo$ = 12						; size = 4
_hi$ = 16						; size = 4
_free_ivector PROC					; COMDAT

; 470  : {

	push	ebp
	mov	ebp, esp

; 471  :   myfree((char *)(v+lo));

	mov	eax, DWORD PTR _lo$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_myfree
	add	esp, 4

; 472  : }

	pop	ebp
	ret	0
_free_ivector ENDP
_TEXT	ENDS
PUBLIC	_free_matrix
; Function compile flags: /Ogtp
;	COMDAT _free_matrix
_TEXT	SEGMENT
_m$ = 8							; size = 4
_free_matrix PROC					; COMDAT

; 482  : {

	push	ebp
	mov	ebp, esp

; 483  :   if ( !m ) return;

	mov	eax, DWORD PTR _m$[ebp]
	test	eax, eax
	je	SHORT $LN2@free_matri

; 484  :   myfree((char *)m[-1]);  /* using private pointer */

	push	esi
	lea	esi, DWORD PTR [eax-4]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	_myfree

; 485  :   myfree((char *)(m-1));

	push	esi
	call	_myfree
	add	esp, 8
	pop	esi
$LN2@free_matri:

; 486  : } // end free_matrix()

	pop	ebp
	ret	0
_free_matrix ENDP
_TEXT	ENDS
PUBLIC	_free_matrix3
; Function compile flags: /Ogtp
;	COMDAT _free_matrix3
_TEXT	SEGMENT
_m$ = 8							; size = 4
_free_matrix3 PROC					; COMDAT

; 489  : {

	push	ebp
	mov	ebp, esp

; 490  :   if ( !m ) return;

	mov	eax, DWORD PTR _m$[ebp]
	test	eax, eax
	je	SHORT $LN2@free_matri@2

; 491  :   myfree((char *)m[-1]);

	push	esi
	lea	esi, DWORD PTR [eax-4]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	_myfree

; 492  :   myfree((char *)(m-1));

	push	esi
	call	_myfree
	add	esp, 8
	pop	esi
$LN2@free_matri@2:

; 493  : } // end free_matrix3()

	pop	ebp
	ret	0
_free_matrix3 ENDP
_TEXT	ENDS
PUBLIC	_free_matrix4
; Function compile flags: /Ogtp
;	COMDAT _free_matrix4
_TEXT	SEGMENT
_m$ = 8							; size = 4
_free_matrix4 PROC					; COMDAT

; 496  : {

	push	ebp
	mov	ebp, esp

; 497  :   if ( !m ) return;

	mov	eax, DWORD PTR _m$[ebp]
	test	eax, eax
	je	SHORT $LN2@free_matri@3

; 498  :   myfree((char *)m[-1]);

	push	esi
	lea	esi, DWORD PTR [eax-4]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	_myfree

; 499  :   myfree((char *)(m-1));

	push	esi
	call	_myfree
	add	esp, 8
	pop	esi
$LN2@free_matri@3:

; 500  : } // end free_matrix4()

	pop	ebp
	ret	0
_free_matrix4 ENDP
_TEXT	ENDS
PUBLIC	_free_temp_matrix
EXTRN	_temp_free:PROC
; Function compile flags: /Ogtp
;	COMDAT _free_temp_matrix
_TEXT	SEGMENT
_m$ = 8							; size = 4
_free_temp_matrix PROC					; COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp

; 505  :   if ( !m ) return;

	mov	eax, DWORD PTR _m$[ebp]
	test	eax, eax
	je	SHORT $LN2@free_temp_

; 506  :   temp_free((char *)m[-1]);  /* using private pointer */

	push	esi
	lea	esi, DWORD PTR [eax-4]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	_temp_free

; 507  :   temp_free((char *)(m-1));

	push	esi
	call	_temp_free
	add	esp, 8
	pop	esi
$LN2@free_temp_:

; 508  : } // end free_temp_matrix()

	pop	ebp
	ret	0
_free_temp_matrix ENDP
_TEXT	ENDS
PUBLIC	_free_temp_matrix3
; Function compile flags: /Ogtp
;	COMDAT _free_temp_matrix3
_TEXT	SEGMENT
_m$ = 8							; size = 4
_free_temp_matrix3 PROC					; COMDAT

; 511  : {

	push	ebp
	mov	ebp, esp

; 512  :   if ( !m ) return;

	mov	eax, DWORD PTR _m$[ebp]
	test	eax, eax
	je	SHORT $LN2@free_temp_@2

; 513  :   temp_free((char *)m[-1]);

	push	esi
	lea	esi, DWORD PTR [eax-4]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	_temp_free

; 514  :   temp_free((char *)(m-1));

	push	esi
	call	_temp_free
	add	esp, 8
	pop	esi
$LN2@free_temp_@2:

; 515  : } // end free_temp_matrix3()

	pop	ebp
	ret	0
_free_temp_matrix3 ENDP
_TEXT	ENDS
PUBLIC	_free_temp_matrix4
; Function compile flags: /Ogtp
;	COMDAT _free_temp_matrix4
_TEXT	SEGMENT
_m$ = 8							; size = 4
_free_temp_matrix4 PROC					; COMDAT

; 518  : {

	push	ebp
	mov	ebp, esp

; 519  :   if ( !m ) return;

	mov	eax, DWORD PTR _m$[ebp]
	test	eax, eax
	je	SHORT $LN2@free_temp_@3

; 520  :   temp_free((char *)m[-1]);

	push	esi
	lea	esi, DWORD PTR [eax-4]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	_temp_free

; 521  :   temp_free((char *)(m-1));

	push	esi
	call	_temp_free
	add	esp, 8
	pop	esi
$LN2@free_temp_@3:

; 522  : } // end free_temp_matrix4()

	pop	ebp
	ret	0
_free_temp_matrix4 ENDP
_TEXT	ENDS
PUBLIC	_vector_add
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtp
;	COMDAT _vector_add
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_n$ = 16						; size = 4
_vector_add PROC					; COMDAT

; 535  : { for(;n!=0;n--) *(a++) += *(b++);

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _n$[ebp]
	test	edx, edx
	je	SHORT $LN1@vector_add
	mov	ecx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	sub	ecx, eax
$LL3@vector_add:
	fld	QWORD PTR [ecx+eax]
	add	eax, 8
	dec	edx
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LL3@vector_add
$LN1@vector_add:

; 536  : } // end vector_add()

	pop	ebp
	ret	0
_vector_add ENDP
_TEXT	ENDS
PUBLIC	_vector_add_smul
; Function compile flags: /Ogtp
;	COMDAT _vector_add_smul
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 8
_n$ = 24						; size = 4
_vector_add_smul PROC					; COMDAT

; 550  : { for(;n!=0;n--) *(a++) += c*(*(b++));

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _n$[ebp]
	test	edx, edx
	je	SHORT $LN1@vector_add@2
	mov	ecx, DWORD PTR _b$[ebp]
	fld	QWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	sub	ecx, eax
$LN3@vector_add@2:
	fld	QWORD PTR [ecx+eax]
	add	eax, 8
	dec	edx
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LN3@vector_add@2
	fstp	ST(0)
$LN1@vector_add@2:

; 551  : } // end vector_add_smul()

	pop	ebp
	ret	0
_vector_add_smul ENDP
_TEXT	ENDS
PUBLIC	_vector_sub
; Function compile flags: /Ogtp
;	COMDAT _vector_sub
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_n$ = 16						; size = 4
_vector_sub PROC					; COMDAT

; 565  : { for(;n!=0;n--) *(a++) -= *(b++);

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _n$[ebp]
	test	edx, edx
	je	SHORT $LN1@vector_sub
	mov	ecx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	sub	ecx, eax
$LL3@vector_sub:
	fld	QWORD PTR [eax]
	add	eax, 8
	dec	edx
	fsub	QWORD PTR [ecx+eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LL3@vector_sub
$LN1@vector_sub:

; 566  : } // end vector_sub()

	pop	ebp
	ret	0
_vector_sub ENDP
_TEXT	ENDS
PUBLIC	_cross_prod
; Function compile flags: /Ogtp
;	COMDAT _cross_prod
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_cross_prod PROC					; COMDAT

; 593  : {

	push	ebp
	mov	ebp, esp

; 594  :   c[0] = a[1]*b[2] - a[2]*b[1];

	mov	ecx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	fld	QWORD PTR [ecx+16]
	fmul	QWORD PTR [eax+8]
	mov	edx, DWORD PTR _c$[ebp]
	fld	QWORD PTR [eax+16]
	fmul	QWORD PTR [ecx+8]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [edx]

; 595  :   c[1] = a[2]*b[0] - a[0]*b[2];

	fld	QWORD PTR [eax+16]
	fmul	QWORD PTR [ecx]
	fld	QWORD PTR [eax]
	fmul	QWORD PTR [ecx+16]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [edx+8]

; 596  :   c[2] = a[0]*b[1] - a[1]*b[0];

	fld	QWORD PTR [eax]
	fmul	QWORD PTR [ecx+8]
	fld	QWORD PTR [ecx]
	fmul	QWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [edx+16]

; 597  : } // end cross_prod()

	pop	ebp
	ret	0
_cross_prod ENDP
_TEXT	ENDS
PUBLIC	_triple_prod
; Function compile flags: /Ogtp
;	COMDAT _triple_prod
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_triple_prod PROC					; COMDAT

; 606  : {

	push	ebp
	mov	ebp, esp

; 607  :   return  a[0]*(b[1]*c[2] - b[2]*c[1]) - a[1]*(b[0]*c[2] - b[2]*c[0])
; 608  :              + a[2]*(b[0]*c[1] - b[1]*c[0]);

	mov	ecx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	QWORD PTR [ecx+16]
	fmul	QWORD PTR [eax+8]
	mov	edx, DWORD PTR _a$[ebp]
	fld	QWORD PTR [eax+16]
	fmul	QWORD PTR [ecx+8]
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR [edx]
	fld	QWORD PTR [ecx+16]
	fmul	QWORD PTR [eax]
	fld	QWORD PTR [eax+16]
	fmul	QWORD PTR [ecx]
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR [edx+8]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [eax]
	fmul	QWORD PTR [ecx+8]
	fld	QWORD PTR [ecx]
	fmul	QWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR [edx+16]
	faddp	ST(1), ST(0)

; 609  : } // end triple_prod()

	pop	ebp
	ret	0
_triple_prod ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	_dot
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _dot
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_n$ = 16						; size = 4
_dot	PROC						; COMDAT

; 623  : {

	push	ebp
	mov	ebp, esp

; 624  :   REAL x = 0.0;

	fldz
	push	esi

; 625  :   for (  ; --n >= 0 ;  ) x += (*(a++))*(*(b++));

	mov	esi, DWORD PTR _n$[ebp]
	dec	esi
	js	SHORT $LN7@dot
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, 4
	mov	eax, DWORD PTR _b$[ebp]
	jl	SHORT $LN12@dot
	lea	edx, DWORD PTR [esi+1]
	shr	edx, 2
	mov	ecx, edx
	neg	ecx
	lea	esi, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR _a$[ebp]
$LN9@dot:
	fld	QWORD PTR [ecx+8]
	add	ecx, 32					; 00000020H
	fmul	QWORD PTR [eax+8]
	add	eax, 32					; 00000020H
	dec	edx
	fld	QWORD PTR [ecx-32]
	fmul	QWORD PTR [eax-32]
	faddp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-16]
	fmul	QWORD PTR [eax-16]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-8]
	fmul	QWORD PTR [eax-8]
	faddp	ST(1), ST(0)
	jne	SHORT $LN9@dot
	jmp	SHORT $LC8@dot
$LN12@dot:
	mov	ecx, DWORD PTR _a$[ebp]
$LC8@dot:
	test	esi, esi
	js	SHORT $LN7@dot
	sub	ecx, eax
$LC2@dot:
	fld	QWORD PTR [ecx+eax]
	add	eax, 8
	dec	esi
	fmul	QWORD PTR [eax-8]
	faddp	ST(1), ST(0)
	jns	SHORT $LC2@dot
$LN7@dot:
	pop	esi

; 626  :   return x;
; 627  : } // end dot()

	pop	ebp
	ret	0
_dot	ENDP
_TEXT	ENDS
PUBLIC	_dotdf
; Function compile flags: /Ogtp
;	COMDAT _dotdf
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_n$ = 16						; size = 4
_dotdf	PROC						; COMDAT

; 635  : {

	push	ebp
	mov	ebp, esp

; 636  :   REAL x = 0.0;

	fldz
	push	esi

; 637  :   for (  ; --n >= 0 ;  ) x += (*(a++))*(*(b++));

	mov	esi, DWORD PTR _n$[ebp]
	dec	esi
	js	SHORT $LN7@dotdf
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, 4
	mov	eax, DWORD PTR _a$[ebp]
	jl	SHORT $LN12@dotdf
	lea	edx, DWORD PTR [esi+1]
	shr	edx, 2
	mov	ecx, edx
	neg	ecx
	lea	esi, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR _b$[ebp]
$LN9@dotdf:
	fld	DWORD PTR [ecx+4]
	add	eax, 32					; 00000020H
	fmul	QWORD PTR [eax-24]
	add	ecx, 16					; 00000010H
	dec	edx
	fld	DWORD PTR [ecx-16]
	fmul	QWORD PTR [eax-32]
	faddp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ecx-8]
	fmul	QWORD PTR [eax-16]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ecx-4]
	fmul	QWORD PTR [eax-8]
	faddp	ST(1), ST(0)
	jne	SHORT $LN9@dotdf
	jmp	SHORT $LC8@dotdf
$LN12@dotdf:
	mov	ecx, DWORD PTR _b$[ebp]
$LC8@dotdf:
	test	esi, esi
	js	SHORT $LN7@dotdf
$LC2@dotdf:
	fld	DWORD PTR [ecx]
	add	eax, 8
	fmul	QWORD PTR [eax-8]
	add	ecx, 4
	dec	esi
	faddp	ST(1), ST(0)
	jns	SHORT $LC2@dotdf
$LN7@dotdf:
	pop	esi

; 638  :   return x;
; 639  : } // end dotdf()

	pop	ebp
	ret	0
_dotdf	ENDP
_TEXT	ENDS
PUBLIC	_dotf
; Function compile flags: /Ogtp
;	COMDAT _dotf
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_n$ = 16						; size = 4
_dotf	PROC						; COMDAT

; 646  : {

	push	ebp
	mov	ebp, esp

; 647  :   REAL x = 0.0;

	fldz
	push	esi

; 648  :   for (  ; --n >= 0 ;  ) x += (*(a++))*(*(b++));

	mov	esi, DWORD PTR _n$[ebp]
	dec	esi
	js	SHORT $LN7@dotf
	lea	eax, DWORD PTR [esi+1]
	cmp	eax, 4
	mov	eax, DWORD PTR _b$[ebp]
	jl	SHORT $LN12@dotf
	lea	edx, DWORD PTR [esi+1]
	shr	edx, 2
	mov	ecx, edx
	neg	ecx
	lea	esi, DWORD PTR [esi+ecx*4]
	mov	ecx, DWORD PTR _a$[ebp]
$LN9@dotf:
	fld	DWORD PTR [ecx+4]
	add	ecx, 16					; 00000010H
	fmul	DWORD PTR [eax+4]
	add	eax, 16					; 00000010H
	dec	edx
	fld	DWORD PTR [ecx-16]
	fmul	DWORD PTR [eax-16]
	faddp	ST(2), ST(0)
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ecx-8]
	fmul	DWORD PTR [eax-8]
	faddp	ST(1), ST(0)
	fld	DWORD PTR [ecx-4]
	fmul	DWORD PTR [eax-4]
	faddp	ST(1), ST(0)
	jne	SHORT $LN9@dotf
	jmp	SHORT $LC8@dotf
$LN12@dotf:
	mov	ecx, DWORD PTR _a$[ebp]
$LC8@dotf:
	test	esi, esi
	js	SHORT $LN7@dotf
	sub	ecx, eax
$LC2@dotf:
	fld	DWORD PTR [ecx+eax]
	add	eax, 4
	dec	esi
	fmul	DWORD PTR [eax-4]
	faddp	ST(1), ST(0)
	jns	SHORT $LC2@dotf
$LN7@dotf:
	pop	esi

; 649  :   return x;
; 650  : } // end dotf()

	pop	ebp
	ret	0
_dotf	ENDP
_TEXT	ENDS
PUBLIC	_matvec_mul
; Function compile flags: /Ogtp
;	COMDAT _matvec_mul
_TEXT	SEGMENT
_i$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_rows$ = 20						; size = 4
_cols$ = 24						; size = 4
_matvec_mul PROC					; COMDAT

; 662  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 663  :   int i,j;
; 664  : 
; 665  :   for ( i = 0 ; i < rows ; i++ )

	xor	esi, esi
	mov	DWORD PTR _i$[ebp], esi
	cmp	DWORD PTR _rows$[ebp], esi
	jle	$LN4@matvec_mul
	mov	ecx, DWORD PTR _c$[ebp]
	fldz
	push	ebx
	push	edi
$LN16@matvec_mul:

; 667  :     for ( j = 0 ; j < cols ; j++ )

	mov	edx, DWORD PTR _cols$[ebp]
	fst	QWORD PTR [ecx]
	xor	ebx, ebx
	cmp	edx, 4
	jl	SHORT $LC14@matvec_mul

; 666  :   { c[i] = 0.0;

	mov	eax, DWORD PTR _a$[ebp]
	mov	edi, DWORD PTR [eax+esi*4]
	mov	ebx, DWORD PTR _b$[ebp]
	add	edx, -4					; fffffffcH
	lea	esi, DWORD PTR [edi+24]

; 668  :       c[i] += a[i][j]*b[j];

	sub	edi, ebx
	shr	edx, 2
	inc	edx
	lea	eax, DWORD PTR [ebx+8]
	lea	ebx, DWORD PTR [edx*4]
$LN15@matvec_mul:
	fld	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	fmul	QWORD PTR [esi-24]
	add	esi, 32					; 00000020H
	dec	edx
	fadd	QWORD PTR [ecx]
	fst	QWORD PTR [ecx]
	fld	QWORD PTR [edi+eax-32]
	fmul	QWORD PTR [eax-32]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [ecx]
	fld	QWORD PTR [eax-24]
	fmul	QWORD PTR [esi-40]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [ecx]
	fld	QWORD PTR [eax-16]
	fmul	QWORD PTR [esi-32]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx]
	jne	SHORT $LN15@matvec_mul

; 666  :   { c[i] = 0.0;

	mov	esi, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _cols$[ebp]
$LC14@matvec_mul:

; 667  :     for ( j = 0 ; j < cols ; j++ )

	cmp	ebx, edx
	jge	SHORT $LN5@matvec_mul
	mov	edi, DWORD PTR _a$[ebp]
	mov	esi, DWORD PTR [edi+esi*4]
	mov	eax, DWORD PTR _b$[ebp]
	sub	esi, DWORD PTR _b$[ebp]
	lea	eax, DWORD PTR [eax+ebx*8]
	sub	edx, ebx
$LC3@matvec_mul:

; 668  :       c[i] += a[i][j]*b[j];

	fld	QWORD PTR [eax+esi]
	add	eax, 8
	dec	edx
	fmul	QWORD PTR [eax-8]
	fadd	QWORD PTR [ecx]
	fstp	QWORD PTR [ecx]
	jne	SHORT $LC3@matvec_mul

; 667  :     for ( j = 0 ; j < cols ; j++ )

	mov	esi, DWORD PTR _i$[ebp]
$LN5@matvec_mul:

; 663  :   int i,j;
; 664  : 
; 665  :   for ( i = 0 ; i < rows ; i++ )

	inc	esi
	add	ecx, 8
	mov	DWORD PTR _i$[ebp], esi
	cmp	esi, DWORD PTR _rows$[ebp]
	jl	$LN16@matvec_mul
	pop	edi
	fstp	ST(0)
	pop	ebx
$LN4@matvec_mul:
	pop	esi

; 669  :   }
; 670  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_matvec_mul ENDP
_TEXT	ENDS
PUBLIC	_vec_mat_mul
; Function compile flags: /Ogtp
;	COMDAT _vec_mat_mul
_TEXT	SEGMENT
tv703 = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_rows$ = 20						; size = 4
_cols$ = 24						; size = 4
_vec_mat_mul PROC					; COMDAT

; 682  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 683  :   int i,j;
; 684  : 
; 685  :   for ( i = 0 ; i < cols ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _cols$[ebp], eax
	jle	$LN4@vec_mat_mu
	mov	ecx, DWORD PTR _c$[ebp]
	fldz
	mov	edx, DWORD PTR _b$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _rows$[ebp]
	push	esi
	push	edi
$LN17@vec_mat_mu:

; 687  :     for ( j = 0 ; j < rows ; j++ )

	xor	edi, edi
	fst	QWORD PTR [ecx+eax*8]
	cmp	ebx, 4
	jl	SHORT $LC14@vec_mat_mu

; 686  :   { c[i] = 0.0;

	mov	esi, DWORD PTR _a$[ebp]
	lea	edi, DWORD PTR [ebx-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv703[ebp], edi
	add	edi, edi
	add	esi, 16					; 00000010H
	add	edx, 8
	add	edi, edi

; 687  :     for ( j = 0 ; j < rows ; j++ )

$LN15@vec_mat_mu:

; 688  :       c[i] += a[j]*b[j][i];

	mov	ebx, DWORD PTR [edx-8]
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [edx-4]
	fmul	QWORD PTR [esi-16]
	add	edx, 16					; 00000010H
	add	esi, 32					; 00000020H
	dec	DWORD PTR tv703[ebp]
	fadd	QWORD PTR [ecx+eax*8]
	fst	QWORD PTR [ecx+eax*8]
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [edx-16]
	fmul	QWORD PTR [esi-40]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [ecx+eax*8]
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [edx-12]
	fmul	QWORD PTR [esi-32]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [ecx+eax*8]
	fld	QWORD PTR [ebx+eax*8]
	fmul	QWORD PTR [esi-24]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+eax*8]
	jne	SHORT $LN15@vec_mat_mu

; 686  :   { c[i] = 0.0;

	mov	edx, DWORD PTR _b$[ebp]
	mov	ebx, DWORD PTR _rows$[ebp]
$LC14@vec_mat_mu:

; 687  :     for ( j = 0 ; j < rows ; j++ )

	cmp	edi, ebx
	jge	SHORT $LN5@vec_mat_mu
$LC3@vec_mat_mu:

; 688  :       c[i] += a[j]*b[j][i];

	mov	esi, DWORD PTR [edx+edi*4]
	fld	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR _a$[ebp]
	fmul	QWORD PTR [esi+edi*8]
	inc	edi
	fadd	QWORD PTR [ecx+eax*8]
	fstp	QWORD PTR [ecx+eax*8]
	cmp	edi, ebx
	jl	SHORT $LC3@vec_mat_mu
$LN5@vec_mat_mu:

; 683  :   int i,j;
; 684  : 
; 685  :   for ( i = 0 ; i < cols ; i++ )

	inc	eax
	cmp	eax, DWORD PTR _cols$[ebp]
	jl	$LN17@vec_mat_mu
	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx
$LN4@vec_mat_mu:

; 689  :   }
; 690  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_vec_mat_mul ENDP
_TEXT	ENDS
PUBLIC	_kmax$GSCopy$
PUBLIC	_imax$GSCopy$
PUBLIC	_c$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_mat_mult
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Ogtp
;	COMDAT _mat_mult
_TEXT	SEGMENT
_tempqXvS$89559 = -352					; size = 24
tv2752 = -328						; size = 4
_imax$GSCopy$ = -324					; size = 4
tv3445 = -320						; size = 4
_temp$89561 = -320					; size = 4
tv1950 = -316						; size = 4
_c$GSCopy$ = -316					; size = 4
tv3369 = -312						; size = 4
tv2591 = -312						; size = 4
_j$ = -308						; size = 4
tv1109 = -304						; size = 4
_kmax$GSCopy$ = -304					; size = 4
_temp$89573 = -304					; size = 4
tv3328 = -300						; size = 4
tv2716 = -300						; size = 4
tv1913 = -300						; size = 4
tv3417 = -296						; size = 4
tv2697 = -296						; size = 4
tv1847 = -296						; size = 4
_tempxJ$89560 = -292					; size = 288
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_imax$ = 20						; size = 4
_jmax$ = 24						; size = 4
_kmax$ = 28						; size = 4
_mat_mult PROC						; COMDAT

; 705  : { int i,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	edx, DWORD PTR _c$[ebp]
	push	ebx

; 706  : 
; 707  :   if ( (a == c) || (b == c) )

	mov	ebx, DWORD PTR _a$[ebp]
	push	esi
	mov	esi, DWORD PTR _kmax$[ebp]
	push	edi
	mov	edi, DWORD PTR _imax$[ebp]

; 713  :              temp[i][k] += a[i][j]*b[j][k];

	mov	DWORD PTR _c$GSCopy$[ebp], edx
	mov	DWORD PTR _imax$GSCopy$[ebp], edi
	mov	DWORD PTR _kmax$GSCopy$[ebp], esi
	cmp	ebx, edx
	je	$LN74@mat_mult

; 706  : 
; 707  :   if ( (a == c) || (b == c) )

	cmp	DWORD PTR _b$[ebp], edx
	je	$LN74@mat_mult

; 727  :     }
; 728  :   }
; 729  :   else
; 730  :   { for ( i = 0 ; i < imax ; i++ )

	test	edi, edi
	jle	$LN25@mat_mult
	fldz
	sub	ebx, edx
	mov	DWORD PTR tv1913[ebp], edx
	mov	DWORD PTR tv1950[ebp], ebx
	mov	DWORD PTR tv1109[ebp], edi
$LN77@mat_mult:

; 731  :     { for ( k = 0 ; k < kmax ; k++ ) c[i][k] = 0.0;

	xor	ebx, ebx
	cmp	esi, 4
	jl	SHORT $LN73@mat_mult
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	add	eax, 16					; 00000010H
	inc	ecx
	lea	ebx, DWORD PTR [ecx*4]
$LN62@mat_mult:
	fst	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	ecx
	fst	QWORD PTR [eax-40]
	fst	QWORD PTR [eax-32]
	fst	QWORD PTR [eax-24]
	jne	SHORT $LN62@mat_mult
$LN73@mat_mult:
	cmp	ebx, esi
	jge	SHORT $LC10@mat_mult
	mov	eax, DWORD PTR [edx]
	mov	ecx, esi
	sub	ecx, ebx
	add	ecx, ecx
	lea	edi, DWORD PTR [eax+ebx*8]
	and	ecx, 1073741822				; 3ffffffeH
	xor	eax, eax
	rep stosd
$LC10@mat_mult:

; 732  :       for ( j = 0 ; j < jmax ; j++ )

	xor	ebx, ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	DWORD PTR _jmax$[ebp], ebx
	jle	$LN12@mat_mult
	mov	ecx, DWORD PTR tv1950[ebp]
	mov	eax, DWORD PTR [ecx+edx]
	mov	DWORD PTR tv1847[ebp], eax
$LN80@mat_mult:

; 733  :       { REAL aa = a[i][j];

	mov	ecx, DWORD PTR tv1847[ebp]
	fld	QWORD PTR [ecx]

; 734  :         if ( aa == 0.0 ) continue;

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN103@mat_mult

; 735  :         for ( k = 0 ; k < kmax ; k++ )

	xor	edi, edi
	cmp	esi, 4
	jl	SHORT $LC64@mat_mult
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	edi, DWORD PTR [edx]

; 736  :           c[i][k] += aa*b[j][k];

	mov	ebx, ecx
	lea	edx, DWORD PTR [ecx+24]
	lea	ecx, DWORD PTR [esi-4]
	sub	ebx, edi
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [edi+8]
	lea	edi, DWORD PTR [ecx*4]
$LN65@mat_mult:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	dec	ecx
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [ebx+eax-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN65@mat_mult

; 735  :         for ( k = 0 ; k < kmax ; k++ )

	mov	edx, DWORD PTR tv1913[ebp]
	mov	ebx, DWORD PTR _j$[ebp]
$LC64@mat_mult:
	cmp	edi, esi
	jge	SHORT $LN103@mat_mult
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]
	lea	eax, DWORD PTR [ecx+edi*8]
	sub	edx, ecx
	mov	ecx, esi
	sub	ecx, edi
$LC3@mat_mult:

; 736  :           c[i][k] += aa*b[j][k];

	fld	QWORD PTR [edx+eax]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC3@mat_mult

; 735  :         for ( k = 0 ; k < kmax ; k++ )

	mov	edx, DWORD PTR tv1913[ebp]
$LN103@mat_mult:

; 732  :       for ( j = 0 ; j < jmax ; j++ )

	add	DWORD PTR tv1847[ebp], 8

; 735  :         for ( k = 0 ; k < kmax ; k++ )

	fstp	ST(0)
	inc	ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, DWORD PTR _jmax$[ebp]
	jl	$LN80@mat_mult
$LN12@mat_mult:

; 727  :     }
; 728  :   }
; 729  :   else
; 730  :   { for ( i = 0 ; i < imax ; i++ )

	add	edx, 4
	dec	DWORD PTR tv1109[ebp]
	mov	DWORD PTR tv1913[ebp], edx
	jne	$LN77@mat_mult
	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx

; 737  :       }
; 738  :     }
; 739  :   }
; 740  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@mat_mult:

; 708  :   { if ( (imax<=MAXCOORD)&&(kmax<=MAXCOORD))

	cmp	edi, 6
	jg	$LN35@mat_mult
	cmp	esi, 6
	jg	$LN35@mat_mult

; 709  :     { MAT2D(temp,MAXCOORD,MAXCOORD);  /* local temp space */

	push	6
	push	6
	lea	eax, DWORD PTR _tempxJ$89560[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempqXvS$89559[ebp]
	push	ecx
	call	_mat2d_setup
	add	esp, 16					; 00000010H
	mov	DWORD PTR _temp$89561[ebp], eax

; 710  :       for ( i = 0 ; i < imax ; i++ )

	test	edi, edi
	jle	$LN32@mat_mult
	fldz
	mov	ecx, eax
	mov	eax, DWORD PTR _jmax$[ebp]
	sub	ecx, ebx
	mov	DWORD PTR tv2697[ebp], ebx
	mov	DWORD PTR tv2716[ebp], ecx
	mov	DWORD PTR tv2591[ebp], edi
$LN79@mat_mult:

; 711  :         for ( k = 0 ; k < kmax ; k++ )

	xor	edx, edx
	test	esi, esi
	jle	$LN33@mat_mult

; 709  :     { MAT2D(temp,MAXCOORD,MAXCOORD);  /* local temp space */

	mov	ecx, DWORD PTR [ecx+ebx]
	mov	DWORD PTR tv2752[ebp], ecx
$LN78@mat_mult:

; 712  :           for ( j = 0, temp[i][k] = 0.0 ; j < jmax ; j++ )

	mov	edi, DWORD PTR tv2752[ebp]
	xor	ecx, ecx
	fst	QWORD PTR [edi+edx*8]
	cmp	eax, 4
	jl	SHORT $LN75@mat_mult

; 711  :         for ( k = 0 ; k < kmax ; k++ )

	mov	ecx, DWORD PTR tv2716[ebp]
	mov	ecx, DWORD PTR [ecx+ebx]

; 712  :           for ( j = 0, temp[i][k] = 0.0 ; j < jmax ; j++ )

	mov	esi, DWORD PTR _b$[ebp]
	lea	edi, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR [ebx]
	add	eax, -4					; fffffffcH
	shr	eax, 2
	add	esi, 8
	add	ecx, 16					; 00000010H
	inc	eax
	lea	ebx, DWORD PTR [eax*4]
	mov	DWORD PTR _j$[ebp], ebx
$LN68@mat_mult:

; 713  :              temp[i][k] += a[i][j]*b[j][k];

	mov	ebx, DWORD PTR [esi-8]
	fld	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [esi-4]
	fmul	QWORD PTR [ecx-16]
	add	ecx, 32					; 00000020H
	add	esi, 16					; 00000010H
	dec	eax
	fadd	QWORD PTR [edi]
	fst	QWORD PTR [edi]
	fld	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [esi-16]
	fmul	QWORD PTR [ecx-40]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [edi]
	fld	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [esi-12]
	fmul	QWORD PTR [ecx-32]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [edi]
	fld	QWORD PTR [ebx+edx*8]
	fmul	QWORD PTR [ecx-24]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edi]
	jne	SHORT $LN68@mat_mult

; 712  :           for ( j = 0, temp[i][k] = 0.0 ; j < jmax ; j++ )

	mov	eax, DWORD PTR _jmax$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _kmax$GSCopy$[ebp]
	mov	ebx, DWORD PTR tv2697[ebp]
$LN75@mat_mult:
	cmp	ecx, eax
	jge	SHORT $LN30@mat_mult

; 711  :         for ( k = 0 ; k < kmax ; k++ )

	mov	esi, DWORD PTR tv2716[ebp]
	mov	esi, DWORD PTR [esi+ebx]
	lea	ebx, DWORD PTR [esi+edx*8]

; 712  :           for ( j = 0, temp[i][k] = 0.0 ; j < jmax ; j++ )

	mov	esi, DWORD PTR tv2697[ebp]
	mov	esi, DWORD PTR [esi]
	lea	edi, DWORD PTR [esi+ecx*8]
$LN72@mat_mult:

; 713  :              temp[i][k] += a[i][j]*b[j][k];

	mov	esi, DWORD PTR _b$[ebp]
	mov	esi, DWORD PTR [esi+ecx*4]
	fld	QWORD PTR [esi+edx*8]
	inc	ecx
	fmul	QWORD PTR [edi]
	add	edi, 8
	fadd	QWORD PTR [ebx]
	fstp	QWORD PTR [ebx]
	cmp	ecx, eax
	jl	SHORT $LN72@mat_mult

; 712  :           for ( j = 0, temp[i][k] = 0.0 ; j < jmax ; j++ )

	mov	ebx, DWORD PTR tv2697[ebp]
	mov	esi, DWORD PTR _kmax$GSCopy$[ebp]
$LN30@mat_mult:

; 711  :         for ( k = 0 ; k < kmax ; k++ )

	inc	edx
	cmp	edx, esi
	jl	$LN78@mat_mult
	mov	ecx, DWORD PTR tv2716[ebp]
$LN33@mat_mult:

; 710  :       for ( i = 0 ; i < imax ; i++ )

	add	ebx, 4
	dec	DWORD PTR tv2591[ebp]
	mov	DWORD PTR tv2697[ebp], ebx
	jne	$LN79@mat_mult
	mov	edi, DWORD PTR _imax$GSCopy$[ebp]
	fstp	ST(0)
	mov	eax, DWORD PTR _temp$89561[ebp]
$LN32@mat_mult:

; 714  :       matcopy(c,temp,imax,kmax);

	mov	edx, DWORD PTR _c$GSCopy$[ebp]
	push	esi
	push	edi
	push	eax
	push	edx
	call	_matcopy
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 737  :       }
; 738  :     }
; 739  :   }
; 740  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@mat_mult:

; 715  :     }
; 716  :     else /* have to go to the effort to get temp work space */
; 717  :     { REAL **temp = dmatrix(0,imax-1,0,kmax-1);  /* temporary storage */

	push	717					; 000002cdH
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	lea	eax, DWORD PTR [esi-1]
	push	eax
	push	0
	lea	ecx, DWORD PTR [edi-1]
	push	ecx
	push	0
	call	_kb_dmatrix
	add	esp, 24					; 00000018H
	mov	DWORD PTR _temp$89573[ebp], eax

; 718  :       for ( i = 0 ; i < imax ; i++ )

	test	edi, edi
	jle	$LN22@mat_mult
	fldz
	mov	ecx, ebx
	mov	edx, eax
	sub	ecx, eax
	mov	DWORD PTR tv3417[ebp], edx
	mov	DWORD PTR tv3445[ebp], ecx
	mov	DWORD PTR tv3369[ebp], edi
$LN24@mat_mult:

; 719  :         for ( j = 0 ; j < jmax ; j++ )

	xor	ebx, ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	DWORD PTR _jmax$[ebp], ebx
	jle	$LN23@mat_mult
	mov	eax, DWORD PTR [ecx+edx]
	mov	DWORD PTR tv3328[ebp], eax
$LN21@mat_mult:

; 720  :         { REAL aa = a[i][j];

	mov	ecx, DWORD PTR tv3328[ebp]
	fld	QWORD PTR [ecx]

; 721  :           if ( aa==0.0 ) continue;

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN146@mat_mult

; 722  :           for ( k = 0 ; k < kmax ; k++ )

	xor	edi, edi
	cmp	esi, 4
	jl	SHORT $LC70@mat_mult
	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	edi, DWORD PTR [edx]

; 723  :             temp[i][k] += aa*b[j][k];

	mov	ebx, ecx
	lea	edx, DWORD PTR [ecx+24]
	lea	ecx, DWORD PTR [esi-4]
	sub	ebx, edi
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [edi+8]
	lea	edi, DWORD PTR [ecx*4]
$LN71@mat_mult:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	dec	ecx
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax+ebx-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN71@mat_mult

; 722  :           for ( k = 0 ; k < kmax ; k++ )

	mov	edx, DWORD PTR tv3417[ebp]
	mov	ebx, DWORD PTR _j$[ebp]
$LC70@mat_mult:
	cmp	edi, esi
	jge	SHORT $LN146@mat_mult
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]
	lea	eax, DWORD PTR [ecx+edi*8]
	sub	edx, ecx
	mov	ecx, esi
	sub	ecx, edi
$LC17@mat_mult:

; 723  :             temp[i][k] += aa*b[j][k];

	fld	QWORD PTR [edx+eax]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC17@mat_mult

; 722  :           for ( k = 0 ; k < kmax ; k++ )

	mov	edx, DWORD PTR tv3417[ebp]
$LN146@mat_mult:

; 719  :         for ( j = 0 ; j < jmax ; j++ )

	add	DWORD PTR tv3328[ebp], 8

; 722  :           for ( k = 0 ; k < kmax ; k++ )

	fstp	ST(0)
	inc	ebx
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, DWORD PTR _jmax$[ebp]
	jl	$LN21@mat_mult

; 719  :         for ( j = 0 ; j < jmax ; j++ )

	mov	ecx, DWORD PTR tv3445[ebp]
	mov	edi, DWORD PTR _imax$GSCopy$[ebp]
	mov	eax, DWORD PTR _temp$89573[ebp]
$LN23@mat_mult:

; 718  :       for ( i = 0 ; i < imax ; i++ )

	add	edx, 4
	dec	DWORD PTR tv3369[ebp]
	mov	DWORD PTR tv3417[ebp], edx
	jne	$LN24@mat_mult
	fstp	ST(0)
$LN22@mat_mult:

; 724  :         }
; 725  :       matcopy(c,temp,imax,kmax);

	push	esi
	push	edi
	push	eax
	mov	eax, DWORD PTR _c$GSCopy$[ebp]
	push	eax
	call	_matcopy

; 726  :       free_matrix(temp);

	mov	ecx, DWORD PTR _temp$89573[ebp]
	push	ecx
	call	_free_matrix
	add	esp, 20					; 00000014H
$LN25@mat_mult:

; 737  :       }
; 738  :     }
; 739  :   }
; 740  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_mat_mult ENDP
_TEXT	ENDS
PUBLIC	_tr_mat_mul
; Function compile flags: /Ogtp
;	COMDAT _tr_mat_mul
_TEXT	SEGMENT
tv1915 = -20						; size = 4
tv678 = -20						; size = 4
tv216 = -16						; size = 4
tv139 = -16						; size = 4
_temp$ = -16						; size = 4
tv1684 = -12						; size = 4
tv977 = -12						; size = 4
tv1054 = -8						; size = 4
_i$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_imax$ = 20						; size = 4
_jmax$ = 24						; size = 4
_kmax$ = 28						; size = 4
_tr_mat_mul PROC					; COMDAT

; 754  : {

	push	ebp
	mov	ebp, esp

; 755  :   REAL **temp;  /* temporary storage, if needed */
; 756  :   int i,j,k;
; 757  : 
; 758  :   if ( (a == c) || (b == c) )

	mov	eax, DWORD PTR _c$[ebp]
	sub	esp, 20					; 00000014H
	push	ebx
	mov	ebx, DWORD PTR _a$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _b$[ebp]
	cmp	ebx, eax
	je	$LN20@tr_mat_mul
	cmp	edi, eax
	je	$LN20@tr_mat_mul

; 766  :   }
; 767  :   else
; 768  :   { REAL *s;
; 769  :     for ( j = 0 ; j < jmax ; j++ )

	xor	esi, esi
	cmp	DWORD PTR _jmax$[ebp], esi
	jle	$LN7@tr_mat_mul
	mov	ecx, DWORD PTR _kmax$[ebp]
	fldz
$LN45@tr_mat_mul:

; 770  :       for ( k = 0, s = c[j] ; k < kmax ; k++,s++ )

	mov	eax, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]
	xor	edx, edx
	test	ecx, ecx
	jle	$LN8@tr_mat_mul
$LN6@tr_mat_mul:

; 772  :          for ( i = 0 ; i < imax ; i++ )

	cmp	DWORD PTR _imax$[ebp], 4
	fst	QWORD PTR [eax]
	mov	DWORD PTR _i$[ebp], 0
	jl	SHORT $LC37@tr_mat_mul

; 773  :            *s += a[i][j]*b[i][k];

	lea	ecx, DWORD PTR [ebx+12]
	sub	ebx, edi
	mov	DWORD PTR tv977[ebp], ecx
	lea	ecx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR _imax$[ebp]
	add	edi, -4					; fffffffcH
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv216[ebp], edi
	add	edi, edi
	add	edi, edi
	mov	DWORD PTR tv1054[ebp], ebx
	mov	DWORD PTR _i$[ebp], edi
$LN42@tr_mat_mul:
	mov	edi, DWORD PTR [ecx-4]
	fld	QWORD PTR [edi+edx*8]
	mov	ebx, DWORD PTR tv977[ebp]
	mov	ebx, DWORD PTR [ebx-12]
	fmul	QWORD PTR [ebx+esi*8]
	mov	edi, DWORD PTR tv1054[ebp]
	mov	edi, DWORD PTR [ecx+edi]
	mov	ebx, DWORD PTR [ecx]
	fadd	QWORD PTR [eax]
	add	ecx, 16					; 00000010H
	fst	QWORD PTR [eax]
	fld	QWORD PTR [edi+esi*8]
	mov	edi, DWORD PTR [ecx-12]
	fmul	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR tv977[ebp]
	mov	ebx, DWORD PTR [ebx-4]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [eax]
	fld	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR [ecx-8]
	fmul	QWORD PTR [ebx+esi*8]
	mov	ebx, DWORD PTR tv977[ebp]
	mov	ebx, DWORD PTR [ebx]
	add	DWORD PTR tv977[ebp], 16		; 00000010H
	dec	DWORD PTR tv216[ebp]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [eax]
	fld	QWORD PTR [edi+edx*8]
	fmul	QWORD PTR [ebx+esi*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax]
	jne	SHORT $LN42@tr_mat_mul

; 771  :       { *s = 0.0;

	mov	ebx, DWORD PTR _a$[ebp]
	mov	edi, DWORD PTR _b$[ebp]
$LC37@tr_mat_mul:

; 772  :          for ( i = 0 ; i < imax ; i++ )

	mov	ecx, DWORD PTR _imax$[ebp]
	cmp	DWORD PTR _i$[ebp], ecx
	jge	SHORT $LN5@tr_mat_mul
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ebx, edi
	lea	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR _imax$[ebp]
	sub	edi, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv1054[ebp], ebx
	mov	DWORD PTR tv139[ebp], edi
$LC3@tr_mat_mul:

; 773  :            *s += a[i][j]*b[i][k];

	mov	edi, DWORD PTR tv1054[ebp]
	mov	edi, DWORD PTR [ecx+edi]
	mov	ebx, DWORD PTR [ecx]
	fld	QWORD PTR [edi+esi*8]
	fmul	QWORD PTR [ebx+edx*8]
	add	ecx, 4
	dec	DWORD PTR tv139[ebp]
	fadd	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	jne	SHORT $LC3@tr_mat_mul

; 772  :          for ( i = 0 ; i < imax ; i++ )

	mov	edi, DWORD PTR _b$[ebp]
	mov	ebx, DWORD PTR _a$[ebp]
$LN5@tr_mat_mul:

; 770  :       for ( k = 0, s = c[j] ; k < kmax ; k++,s++ )

	mov	ecx, DWORD PTR _kmax$[ebp]
	inc	edx
	add	eax, 8
	cmp	edx, ecx
	jl	$LN6@tr_mat_mul
$LN8@tr_mat_mul:

; 766  :   }
; 767  :   else
; 768  :   { REAL *s;
; 769  :     for ( j = 0 ; j < jmax ; j++ )

	inc	esi
	cmp	esi, DWORD PTR _jmax$[ebp]
	jl	$LN45@tr_mat_mul
	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx

; 774  :       }
; 775  :   }
; 776  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@tr_mat_mul:

; 759  :   { temp = dmatrix(0,jmax-1,0,kmax-1);  /* temporary storage */

	mov	esi, DWORD PTR _kmax$[ebp]
	mov	eax, DWORD PTR _jmax$[ebp]
	push	759					; 000002f7H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	lea	edx, DWORD PTR [esi-1]
	push	edx
	push	0
	dec	eax
	push	eax
	push	0
	call	_kb_dmatrix
	mov	DWORD PTR _temp$[ebp], eax

; 760  :     for ( j = 0 ; j < jmax ; j++ )

	mov	eax, DWORD PTR _jmax$[ebp]
	add	esp, 24					; 00000018H
	xor	edx, edx
	test	eax, eax
	jle	$LN17@tr_mat_mul
	npad	1
$LL19@tr_mat_mul:

; 761  :       for ( k = 0 ; k < kmax ; k++ )

	xor	ecx, ecx
	test	esi, esi
	jle	$LN18@tr_mat_mul
	npad	6
$LL47@tr_mat_mul:

; 762  :         for ( i = 0 ; i < imax ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _imax$[ebp], 4
	mov	DWORD PTR _i$[ebp], eax
	jl	$LC40@tr_mat_mul

; 761  :       for ( k = 0 ; k < kmax ; k++ )

	mov	eax, DWORD PTR _temp$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	lea	esi, DWORD PTR [eax+ecx*8]

; 762  :         for ( i = 0 ; i < imax ; i++ )

	lea	eax, DWORD PTR [ebx+12]

; 763  :           temp[j][k] += a[i][j]*b[i][k];

	sub	ebx, edi
	mov	DWORD PTR tv1684[ebp], eax
	lea	eax, DWORD PTR [edi+4]
	mov	edi, DWORD PTR _imax$[ebp]
	add	edi, -4					; fffffffcH
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv1915[ebp], edi
	add	edi, edi
	add	edi, edi
	mov	DWORD PTR tv1054[ebp], ebx
	mov	DWORD PTR _i$[ebp], edi
	npad	6
$LL41@tr_mat_mul:
	mov	edi, DWORD PTR [eax-4]
	fld	QWORD PTR [edi+ecx*8]
	mov	ebx, DWORD PTR tv1684[ebp]
	mov	ebx, DWORD PTR [ebx-12]
	fmul	QWORD PTR [ebx+edx*8]
	mov	edi, DWORD PTR tv1054[ebp]
	mov	edi, DWORD PTR [eax+edi]
	mov	ebx, DWORD PTR [eax]
	fadd	QWORD PTR [esi]
	add	eax, 16					; 00000010H
	fst	QWORD PTR [esi]
	fld	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR [eax-12]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR tv1684[ebp]
	mov	ebx, DWORD PTR [ebx-4]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [esi]
	fld	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR [eax-8]
	fmul	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR tv1684[ebp]
	mov	ebx, DWORD PTR [ebx]
	add	DWORD PTR tv1684[ebp], 16		; 00000010H
	dec	DWORD PTR tv1915[ebp]
	faddp	ST(1), ST(0)
	fst	QWORD PTR [esi]
	fld	QWORD PTR [edi+ecx*8]
	fmul	QWORD PTR [ebx+edx*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi]
	jne	SHORT $LL41@tr_mat_mul

; 762  :         for ( i = 0 ; i < imax ; i++ )

	mov	edi, DWORD PTR _b$[ebp]
	mov	ebx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
$LC40@tr_mat_mul:
	cmp	eax, DWORD PTR _imax$[ebp]
	jge	SHORT $LN15@tr_mat_mul

; 761  :       for ( k = 0 ; k < kmax ; k++ )

	mov	esi, DWORD PTR _temp$[ebp]
	mov	esi, DWORD PTR [esi+edx*4]
	lea	esi, DWORD PTR [esi+ecx*8]
	mov	DWORD PTR tv678[ebp], esi

; 762  :         for ( i = 0 ; i < imax ; i++ )

	mov	esi, DWORD PTR _imax$[ebp]
	sub	ebx, edi
	sub	esi, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR tv1054[ebp], ebx
	jmp	SHORT $LC13@tr_mat_mul
$LL43@tr_mat_mul:
	mov	ebx, DWORD PTR tv1054[ebp]
$LC13@tr_mat_mul:

; 763  :           temp[j][k] += a[i][j]*b[i][k];

	mov	edi, DWORD PTR [eax+ebx]
	fld	QWORD PTR [edi+edx*8]
	mov	ebx, DWORD PTR [eax]
	fmul	QWORD PTR [ebx+ecx*8]
	mov	edi, DWORD PTR tv678[ebp]
	add	eax, 4
	dec	esi
	fadd	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	jne	SHORT $LL43@tr_mat_mul

; 762  :         for ( i = 0 ; i < imax ; i++ )

	mov	ebx, DWORD PTR _a$[ebp]
	mov	edi, DWORD PTR _b$[ebp]
$LN15@tr_mat_mul:

; 761  :       for ( k = 0 ; k < kmax ; k++ )

	mov	esi, DWORD PTR _kmax$[ebp]
	inc	ecx
	cmp	ecx, esi
	jl	$LL47@tr_mat_mul
	mov	eax, DWORD PTR _jmax$[ebp]
$LN18@tr_mat_mul:

; 760  :     for ( j = 0 ; j < jmax ; j++ )

	inc	edx
	cmp	edx, eax
	jl	$LL19@tr_mat_mul
$LN17@tr_mat_mul:

; 764  :     matcopy(c,temp,jmax,kmax);

	mov	ecx, DWORD PTR _temp$[ebp]
	mov	edx, DWORD PTR _c$[ebp]
	push	esi
	push	eax
	push	ecx
	push	edx
	call	_matcopy

; 765  :     free_matrix(temp);

	mov	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	_free_matrix
	add	esp, 20					; 00000014H
$LN7@tr_mat_mul:
	pop	edi
	pop	esi
	pop	ebx

; 774  :       }
; 775  :   }
; 776  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_tr_mat_mul ENDP
_TEXT	ENDS
PUBLIC	_mat_mul_tr
; Function compile flags: /Ogtp
;	COMDAT _mat_mul_tr
_TEXT	SEGMENT
tv2758 = -16						; size = 4
_k$ = -16						; size = 4
_i$ = -16						; size = 4
tv872 = -12						; size = 4
_temp$ = -12						; size = 4
tv2698 = -8						; size = 4
tv828 = -8						; size = 4
tv2720 = -4						; size = 4
tv1578 = -4						; size = 4
tv2753 = 8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_imax$ = 20						; size = 4
_jmax$ = 24						; size = 4
_kmax$ = 28						; size = 4
_mat_mul_tr PROC					; COMDAT

; 789  : {

	push	ebp
	mov	ebp, esp

; 790  :   REAL **temp;  /* temporary storage, if needed */
; 791  :   int i,j,k;
; 792  : 
; 793  :   if ( (a == c) || (b == c) )

	mov	eax, DWORD PTR _c$[ebp]
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _a$[ebp]
	cmp	edi, eax
	je	$LN52@mat_mul_tr
	cmp	DWORD PTR _b$[ebp], eax
	je	$LN52@mat_mul_tr

; 801  :   }
; 802  :   else
; 803  :   { 
; 804  :     for ( k = 0 ; k < kmax ; k++ )

	xor	ecx, ecx
	cmp	DWORD PTR _kmax$[ebp], ecx
	jle	$LN11@mat_mul_tr
	mov	edi, DWORD PTR _imax$[ebp]
	fldz
$LN59@mat_mul_tr:

; 805  :     { for ( i = 0 ; i < imax ; i++ ) c[i][k] = 0.0;

	xor	esi, esi
	cmp	edi, 4
	jl	SHORT $LN54@mat_mul_tr
	mov	eax, DWORD PTR _c$[ebp]
	lea	edx, DWORD PTR [edi-4]
	shr	edx, 2
	add	eax, 8
	inc	edx
	lea	esi, DWORD PTR [edx*4]
$LN44@mat_mul_tr:
	mov	ebx, DWORD PTR [eax-8]
	fst	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [eax-4]
	fst	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [eax]
	fst	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [eax+4]
	add	eax, 16					; 00000010H
	fst	QWORD PTR [ebx+ecx*8]
	dec	edx
	jne	SHORT $LN44@mat_mul_tr
$LN54@mat_mul_tr:
	cmp	esi, edi
	jge	SHORT $LN42@mat_mul_tr
$LC10@mat_mul_tr:
	mov	eax, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR [eax+esi*4]
	inc	esi
	fst	QWORD PTR [edx+ecx*8]
	cmp	esi, edi
	jl	SHORT $LC10@mat_mul_tr
$LN42@mat_mul_tr:

; 806  :       for ( j = 0 ; j < jmax ; j++ ) 

	xor	edx, edx
	cmp	DWORD PTR _jmax$[ebp], edx
	jle	$LN12@mat_mul_tr
	mov	eax, DWORD PTR _b$[ebp]

; 808  :         if ( bb == 0.0 ) continue;

	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv872[ebp], eax
$LN56@mat_mul_tr:

; 807  :       { REAL bb = b[k][j];

	mov	eax, DWORD PTR tv872[ebp]
	fld	QWORD PTR [eax+edx*8]

; 808  :         if ( bb == 0.0 ) continue;

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN81@mat_mul_tr

; 809  :         for ( i = 0 ; i < imax ; i++ )

	xor	esi, esi
	cmp	edi, 4
	jl	SHORT $LC46@mat_mul_tr
	mov	ebx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _c$[ebp]
	add	edi, -4					; fffffffcH
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv828[ebp], edi
	lea	esi, DWORD PTR [ebx+12]

; 810  :           c[i][k] += a[i][j]*bb;

	sub	ebx, DWORD PTR _c$[ebp]
	add	edi, edi
	add	eax, 4
	add	edi, edi
	mov	DWORD PTR tv1578[ebp], ebx
	mov	DWORD PTR _i$[ebp], edi
$LN47@mat_mul_tr:
	mov	ebx, DWORD PTR [esi-12]
	fld	QWORD PTR [ebx+edx*8]
	mov	edi, DWORD PTR [eax-4]
	mov	ebx, DWORD PTR tv1578[ebp]
	fmul	ST(0), ST(1)
	mov	ebx, DWORD PTR [ebx+eax]
	lea	edi, DWORD PTR [edi+ecx*8]
	fadd	QWORD PTR [edi]
	add	eax, 16					; 00000010H
	add	esi, 16					; 00000010H
	dec	DWORD PTR tv828[ebp]
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR [eax-16]
	fld	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [esi-20]
	fmul	ST(0), ST(1)
	lea	edi, DWORD PTR [edi+ecx*8]
	fadd	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR [eax-12]
	fld	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR [esi-16]
	fmul	ST(0), ST(1)
	lea	edi, DWORD PTR [edi+ecx*8]
	fadd	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR [eax-8]
	fld	QWORD PTR [ebx+edx*8]
	lea	edi, DWORD PTR [edi+ecx*8]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [edi]
	fstp	QWORD PTR [edi]
	jne	SHORT $LN47@mat_mul_tr

; 809  :         for ( i = 0 ; i < imax ; i++ )

	mov	esi, DWORD PTR _i$[ebp]
	mov	edi, DWORD PTR _imax$[ebp]
$LC46@mat_mul_tr:
	cmp	esi, edi
	jge	SHORT $LN81@mat_mul_tr
	mov	ebx, DWORD PTR _a$[ebp]
	sub	ebx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR [eax+esi*4]
	mov	DWORD PTR tv1578[ebp], ebx
	sub	edi, esi
	jmp	SHORT $LC3@mat_mul_tr
$LN51@mat_mul_tr:
	mov	ebx, DWORD PTR tv1578[ebp]
$LC3@mat_mul_tr:

; 810  :           c[i][k] += a[i][j]*bb;

	mov	ebx, DWORD PTR [eax+ebx]
	fld	QWORD PTR [ebx+edx*8]
	mov	esi, DWORD PTR [eax]
	fmul	ST(0), ST(1)
	lea	esi, DWORD PTR [esi+ecx*8]
	add	eax, 4
	dec	edi
	fadd	QWORD PTR [esi]
	fstp	QWORD PTR [esi]
	jne	SHORT $LN51@mat_mul_tr

; 809  :         for ( i = 0 ; i < imax ; i++ )

	mov	edi, DWORD PTR _imax$[ebp]
$LN81@mat_mul_tr:

; 806  :       for ( j = 0 ; j < jmax ; j++ ) 

	inc	edx

; 809  :         for ( i = 0 ; i < imax ; i++ )

	fstp	ST(0)
	cmp	edx, DWORD PTR _jmax$[ebp]
	jl	$LN56@mat_mul_tr
$LN12@mat_mul_tr:

; 801  :   }
; 802  :   else
; 803  :   { 
; 804  :     for ( k = 0 ; k < kmax ; k++ )

	inc	ecx
	cmp	ecx, DWORD PTR _kmax$[ebp]
	jl	$LN59@mat_mul_tr
	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx

; 811  :       }
; 812  :     }
; 813  :   }
; 814  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN52@mat_mul_tr:

; 794  :   { temp = dmatrix(0,imax-1,0,kmax-1);  /* temporary storage */

	mov	esi, DWORD PTR _kmax$[ebp]
	mov	ebx, DWORD PTR _imax$[ebp]
	push	794					; 0000031aH
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	lea	ecx, DWORD PTR [esi-1]
	push	ecx
	push	0
	lea	edx, DWORD PTR [ebx-1]
	push	edx
	push	0
	call	_kb_dmatrix
	add	esp, 24					; 00000018H
	mov	DWORD PTR _temp$[ebp], eax

; 795  :     for ( i = 0 ; i < imax ; i++ )

	test	ebx, ebx
	jle	$LN21@mat_mul_tr
	mov	ecx, DWORD PTR _imax$[ebp]
	mov	edx, edi
	mov	edi, DWORD PTR _jmax$[ebp]
	mov	ebx, eax
	sub	edx, eax
	mov	DWORD PTR tv2698[ebp], ebx
	mov	DWORD PTR tv2753[ebp], edx
	mov	DWORD PTR tv2720[ebp], ecx
$LL23@mat_mul_tr:

; 796  :       for ( j = 0 ; j < jmax ; j++ )

	xor	ecx, ecx
	test	edi, edi
	jle	$LN22@mat_mul_tr
	npad	4
$LL20@mat_mul_tr:

; 797  :         for ( k = 0 ; k < kmax ; k++ )

	xor	eax, eax
	cmp	esi, 4
	jl	SHORT $LC49@mat_mul_tr
	mov	edx, DWORD PTR [edx+ebx]
	mov	eax, DWORD PTR [ebx]
	lea	edi, DWORD PTR [edx+ecx*8]
	mov	edx, DWORD PTR _b$[ebp]
	add	esi, -4					; fffffffcH
	shr	esi, 2
	add	eax, 16					; 00000010H
	add	edx, 8
	inc	esi
	lea	ebx, DWORD PTR [esi*4]
	mov	DWORD PTR _k$[ebp], ebx
	npad	7
$LL50@mat_mul_tr:

; 798  :           temp[i][k] += a[i][j]*b[k][j];

	mov	ebx, DWORD PTR [edx-8]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [edx-4]
	fmul	QWORD PTR [edi]
	add	edx, 16					; 00000010H
	add	eax, 32					; 00000020H
	dec	esi
	fadd	QWORD PTR [eax-48]
	fstp	QWORD PTR [eax-48]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [edx-16]
	fmul	QWORD PTR [edi]
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [edx-12]
	fmul	QWORD PTR [edi]
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [ebx+ecx*8]
	fmul	QWORD PTR [edi]
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LL50@mat_mul_tr

; 797  :         for ( k = 0 ; k < kmax ; k++ )

	mov	esi, DWORD PTR _kmax$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
	mov	ebx, DWORD PTR tv2698[ebp]
	mov	edx, DWORD PTR tv2753[ebp]
$LC49@mat_mul_tr:
	cmp	eax, esi
	jge	SHORT $LN19@mat_mul_tr

; 796  :       for ( j = 0 ; j < jmax ; j++ )

	mov	edx, DWORD PTR [edx+ebx]
	lea	edx, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR tv2758[ebp], edx

; 797  :         for ( k = 0 ; k < kmax ; k++ )

	mov	edx, DWORD PTR [ebx]
	lea	edx, DWORD PTR [edx+eax*8]
	npad	1
$LL53@mat_mul_tr:

; 798  :           temp[i][k] += a[i][j]*b[k][j];

	mov	edi, DWORD PTR _b$[ebp]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR tv2758[ebp]
	fmul	QWORD PTR [edi]
	inc	eax
	add	edx, 8
	fadd	QWORD PTR [edx-8]
	fstp	QWORD PTR [edx-8]
	cmp	eax, esi
	jl	SHORT $LL53@mat_mul_tr

; 797  :         for ( k = 0 ; k < kmax ; k++ )

	mov	edx, DWORD PTR tv2753[ebp]
$LN19@mat_mul_tr:

; 796  :       for ( j = 0 ; j < jmax ; j++ )

	mov	edi, DWORD PTR _jmax$[ebp]
	inc	ecx
	cmp	ecx, edi
	jl	$LL20@mat_mul_tr
	mov	eax, DWORD PTR _temp$[ebp]
$LN22@mat_mul_tr:

; 795  :     for ( i = 0 ; i < imax ; i++ )

	add	ebx, 4
	dec	DWORD PTR tv2720[ebp]
	mov	DWORD PTR tv2698[ebp], ebx
	jne	$LL23@mat_mul_tr
	mov	ebx, DWORD PTR _imax$[ebp]
$LN21@mat_mul_tr:

; 799  :     matcopy(c,temp,imax,kmax);

	push	esi
	push	ebx
	push	eax
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	call	_matcopy

; 800  :     free_matrix(temp);

	mov	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	call	_free_matrix
	add	esp, 20					; 00000014H
$LN11@mat_mul_tr:
	pop	edi
	pop	esi
	pop	ebx

; 811  :       }
; 812  :     }
; 813  :   }
; 814  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_mat_mul_tr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@GPBDNBGM@mat_tsquare?3?5a?5and?5b?5same?5?$CIinter@ ; `string'
PUBLIC	_mat_tsquare
EXTRN	_kb_error:PROC
;	COMDAT ??_C@_0CN@GPBDNBGM@mat_tsquare?3?5a?5and?5b?5same?5?$CIinter@
CONST	SEGMENT
??_C@_0CN@GPBDNBGM@mat_tsquare?3?5a?5and?5b?5same?5?$CIinter@ DB 'mat_tsq'
	DB	'uare: a and b same (internal error).', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _mat_tsquare
_TEXT	SEGMENT
tv302 = -12						; size = 4
tv287 = -8						; size = 4
tv214 = -4						; size = 4
tv86 = 8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_n$ = 16						; size = 4
_m$ = 20						; size = 4
_mat_tsquare PROC					; COMDAT

; 827  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 828  :   int i,j;
; 829  :   if ( a == b )

	mov	esi, DWORD PTR _b$[ebp]
	push	edi
	mov	edi, DWORD PTR _a$[ebp]
	cmp	edi, esi
	jne	SHORT $LN14@mat_tsquar

; 830  :     kb_error(2141,"mat_tsquare: a and b same (internal error).\n",RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CN@GPBDNBGM@mat_tsquare?3?5a?5and?5b?5same?5?$CIinter@
	push	2141					; 0000085dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN14@mat_tsquar:

; 831  :   for ( i = 0 ; i < n ; i++ )

	xor	ebx, ebx
	cmp	DWORD PTR _n$[ebp], ebx
	jle	SHORT $LN4@mat_tsquar
	mov	eax, edi
	mov	ecx, esi
	sub	eax, esi
	mov	DWORD PTR tv287[ebp], ecx
	mov	DWORD PTR tv214[ebp], eax
	npad	6
$LL16@mat_tsquar:

; 832  :     for ( j = 0 ; j <= i ; j++ )

	test	ebx, ebx
	js	SHORT $LN5@mat_tsquar
	mov	edx, DWORD PTR [ecx+eax]
	mov	edi, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ebx+1]
	mov	DWORD PTR tv302[ebp], edx
	mov	DWORD PTR tv86[ebp], ecx
$LL3@mat_tsquar:

; 833  :       b[i][j] = b[j][i] = dot(a[i],a[j],m);

	mov	edx, DWORD PTR _m$[ebp]
	mov	eax, DWORD PTR [eax+esi]
	mov	ecx, DWORD PTR tv302[ebp]
	push	edx
	push	eax
	push	ecx
	call	_dot
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR tv214[ebp]
	fst	QWORD PTR [edx+ebx*8]
	fstp	QWORD PTR [edi]
	add	esp, 12					; 0000000cH
	add	esi, 4
	add	edi, 8
	dec	DWORD PTR tv86[ebp]
	jne	SHORT $LL3@mat_tsquar

; 832  :     for ( j = 0 ; j <= i ; j++ )

	mov	esi, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR tv287[ebp]
$LN5@mat_tsquar:

; 831  :   for ( i = 0 ; i < n ; i++ )

	inc	ebx
	add	ecx, 4
	mov	DWORD PTR tv287[ebp], ecx
	cmp	ebx, DWORD PTR _n$[ebp]
	jl	SHORT $LL16@mat_tsquar
$LN4@mat_tsquar:
	pop	edi
	pop	esi
	pop	ebx

; 834  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_mat_tsquare ENDP
_TEXT	ENDS
PUBLIC	_quadratic_form
; Function compile flags: /Ogtp
;	COMDAT _quadratic_form
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_n$ = 20						; size = 4
_quadratic_form PROC					; COMDAT

; 845  : { int i,j;

	push	ebp
	mov	ebp, esp

; 846  :   REAL sum = 0.0;

	fldz
	push	ebx

; 847  :   REAL temp;
; 848  : 
; 849  :   for ( i = 0 ; i < n ; i++ )

	mov	ebx, DWORD PTR _n$[ebp]
	xor	ecx, ecx
	test	ebx, ebx
	jle	$LN7@quadratic_
	mov	edx, DWORD PTR _b$[ebp]
	push	esi
	mov	esi, DWORD PTR _c$[ebp]
	push	edi
$LN9@quadratic_:

; 850  :   { temp = b[i][0]*c[0];

	mov	edi, DWORD PTR [edx+ecx*4]
	fld	QWORD PTR [esi]
	fmul	QWORD PTR [edi]

; 851  :     for ( j = 1 ; j <= i ; j++ )

	mov	eax, 1
	cmp	ecx, 4
	jl	SHORT $LC19@quadratic_

; 850  :   { temp = b[i][0]*c[0];

	lea	ebx, DWORD PTR [edi+32]
	lea	edx, DWORD PTR [esi+16]

; 852  :       temp += b[i][j]*c[j];

	sub	edi, esi
	mov	esi, ecx
	shr	esi, 2
	lea	eax, DWORD PTR [esi*4+1]
$LN20@quadratic_:
	fld	QWORD PTR [edx-8]
	add	edx, 32					; 00000020H
	fmul	QWORD PTR [ebx-24]
	add	ebx, 32					; 00000020H
	dec	esi
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+edx-32]
	fmul	QWORD PTR [edx-32]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx-24]
	fmul	QWORD PTR [ebx-40]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx-16]
	fmul	QWORD PTR [ebx-32]
	faddp	ST(1), ST(0)
	jne	SHORT $LN20@quadratic_

; 850  :   { temp = b[i][0]*c[0];

	mov	ebx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	mov	esi, DWORD PTR _c$[ebp]
$LC19@quadratic_:

; 851  :     for ( j = 1 ; j <= i ; j++ )

	cmp	eax, ecx
	jg	SHORT $LN18@quadratic_
	mov	ebx, DWORD PTR [edx+ecx*4]
	mov	edx, ecx
	sub	edx, eax
	inc	edx
	lea	edi, DWORD PTR [esi+eax*8]
	sub	ebx, esi
	add	eax, edx
$LC6@quadratic_:

; 852  :       temp += b[i][j]*c[j];

	fld	QWORD PTR [edi+ebx]
	add	edi, 8
	dec	edx
	fmul	QWORD PTR [edi-8]
	faddp	ST(1), ST(0)
	jne	SHORT $LC6@quadratic_

; 851  :     for ( j = 1 ; j <= i ; j++ )

	mov	edx, DWORD PTR _b$[ebp]
	mov	ebx, DWORD PTR _n$[ebp]
$LN18@quadratic_:
	cmp	eax, ebx
	jge	SHORT $LN21@quadratic_
	mov	edi, ebx
	sub	edi, eax

; 853  :     for (  ; j < n ; j++ )

	cmp	edi, 4
	jl	SHORT $LC22@quadratic_

; 854  :       temp += b[j][i]*c[j];

	mov	edi, ebx
	sub	edi, eax
	sub	edi, 4
	shr	edi, 2
	inc	edi
	lea	esi, DWORD PTR [esi+eax*8+16]
	lea	edx, DWORD PTR [edx+eax*4+8]
	lea	eax, DWORD PTR [eax+edi*4]
$LN23@quadratic_:
	mov	ebx, DWORD PTR [edx-8]
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [edx-4]
	fmul	QWORD PTR [esi-16]
	add	edx, 16					; 00000010H
	add	esi, 32					; 00000020H
	dec	edi
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [edx-16]
	fmul	QWORD PTR [esi-40]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR [edx-12]
	fmul	QWORD PTR [esi-32]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+ecx*8]
	fmul	QWORD PTR [esi-24]
	faddp	ST(1), ST(0)
	jne	SHORT $LN23@quadratic_
	mov	ebx, DWORD PTR _n$[ebp]
	mov	esi, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
$LC22@quadratic_:

; 853  :     for (  ; j < n ; j++ )

	cmp	eax, ebx
	jge	SHORT $LN21@quadratic_
$LC3@quadratic_:

; 854  :       temp += b[j][i]*c[j];

	mov	edi, DWORD PTR [edx+eax*4]
	fld	QWORD PTR [edi+ecx*8]
	inc	eax
	fmul	QWORD PTR [esi+eax*8-8]
	faddp	ST(1), ST(0)
	cmp	eax, ebx
	jl	SHORT $LC3@quadratic_
$LN21@quadratic_:

; 855  :     sum += a[i]*temp;

	mov	eax, DWORD PTR _a$[ebp]
	fmul	QWORD PTR [eax+ecx*8]
	inc	ecx
	faddp	ST(1), ST(0)
	cmp	ecx, ebx
	jl	$LN9@quadratic_
	pop	edi
	pop	esi
$LN7@quadratic_:
	pop	ebx

; 856  :   }
; 857  : 
; 858  :   return sum;
; 859  : }

	pop	ebp
	ret	0
_quadratic_form ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	_a$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_mat_inv
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _mat_inv
_TEXT	SEGMENT
_ll$ = -176						; size = 4
tv2275 = -172						; size = 4
_k$ = -172						; size = 4
tv3215 = -168						; size = 4
_irow$ = -164						; size = 4
_indxr$ = -160						; size = 4
_retval$ = -156						; size = 4
_icol$ = -152						; size = 4
tv3558 = -148						; size = 4
_i$ = -148						; size = 4
_indxc$ = -144						; size = 4
_ipiv$ = -140						; size = 4
_a$GSCopy$ = -136					; size = 4
tv3861 = -132						; size = 4
tv3843 = -132						; size = 4
tv3830 = -132						; size = 4
tv3817 = -132						; size = 4
tv3799 = -132						; size = 4
tv3223 = -132						; size = 4
tv2254 = -128						; size = 4
tv1887 = -128						; size = 4
_l$ = -128						; size = 4
_temp1$ = -124						; size = 40
_temp2$ = -84						; size = 40
_temp3$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_n$ = 12						; size = 4
_mat_inv PROC						; COMDAT

; 879  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _n$[ebp]
	push	esi

; 880  :   int *indxc,*indxr,*ipiv;
; 881  :   int i,icol=0,irow=0,j,k,l,ll;

	xor	esi, esi
	push	edi
	mov	edi, DWORD PTR _a$[ebp]

; 882  :   REAL big,dum,pivinv;
; 883  :   int retval = 1;  /* default return value is success */

	mov	DWORD PTR _a$GSCopy$[ebp], edi
	mov	DWORD PTR _icol$[ebp], esi
	mov	DWORD PTR _irow$[ebp], esi
	mov	DWORD PTR _retval$[ebp], 1

; 884  :   int temp1[SMALL],temp2[SMALL],temp3[SMALL]; /* avoid alloc for small sizes */
; 885  : 
; 886  :   if ( n <= SMALL )

	cmp	ebx, 10					; 0000000aH
	jg	SHORT $LN42@mat_inv

; 887  :   { indxc = temp1; indxr = temp2; ipiv = temp3; }

	lea	edx, DWORD PTR _temp1$[ebp]
	lea	eax, DWORD PTR _temp2$[ebp]
	lea	ecx, DWORD PTR _temp3$[ebp]
	mov	DWORD PTR _indxc$[ebp], edx
	mov	DWORD PTR _indxr$[ebp], eax
	mov	DWORD PTR _ipiv$[ebp], ecx

; 888  :   else

	jmp	SHORT $LN41@mat_inv
$LN42@mat_inv:

; 889  :   { /* large size */
; 890  :     indxc = ivector(0,n-1);

	lea	eax, DWORD PTR [ebx-1]
	push	eax
	push	esi
	call	_ivector
	mov	DWORD PTR _indxc$[ebp], eax

; 891  :     indxr = ivector(0,n-1);

	lea	eax, DWORD PTR [ebx-1]
	push	eax
	push	0
	call	_ivector
	mov	DWORD PTR _indxr$[ebp], eax

; 892  :     ipiv  = ivector(0,n-1);

	lea	eax, DWORD PTR [ebx-1]
	push	eax
	push	0
	call	_ivector
	mov	edx, DWORD PTR _indxc$[ebp]
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ipiv$[ebp], eax
$LN41@mat_inv:

; 893  :   }
; 894  :   for ( j = 0 ; j < n ; j++ ) 

	test	ebx, ebx
	jle	SHORT $LN80@mat_inv
	mov	edi, DWORD PTR _ipiv$[ebp]
	mov	ecx, ebx
	or	eax, -1
	rep stosd
	mov	edi, DWORD PTR _a$GSCopy$[ebp]
$LN80@mat_inv:

; 895  :     ipiv[j] = -1;
; 896  :   for ( i = 0 ; i < n ; i++ )

	mov	DWORD PTR _i$[ebp], esi
	test	ebx, ebx
	jle	$LN35@mat_inv
	mov	eax, DWORD PTR _ipiv$[ebp]
	fldz
	fld1
	sub	eax, edi
	mov	DWORD PTR tv2275[ebp], eax
	mov	eax, DWORD PTR _indxr$[ebp]
	sub	eax, edx
	mov	DWORD PTR tv3215[ebp], edx
	mov	DWORD PTR tv3223[ebp], eax
$LN85@mat_inv:

; 897  :   { /* find pivot */
; 898  :     big = 0.0;

	fld	ST(1)

; 899  :     for ( j = 0 ; j < n ; j++ )

	xor	edx, edx
	mov	DWORD PTR tv2254[ebp], edi
$LN34@mat_inv:

; 900  :     { if ( ipiv[j] != 0 )

	mov	eax, DWORD PTR tv2275[ebp]
	mov	ecx, DWORD PTR tv2254[ebp]
	cmp	DWORD PTR [eax+ecx], 0
	je	SHORT $LN33@mat_inv

; 901  :          for ( k = 0 ; k < n ; k++ )

	xor	ecx, ecx
$LN30@mat_inv:

; 902  :          { if ( ipiv[k] == -1 )

	mov	eax, DWORD PTR _ipiv$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	cmp	eax, -1
	jne	SHORT $LN27@mat_inv

; 903  :            { if ( fabs(a[j][k]) >= big )

	mov	eax, DWORD PTR tv2254[ebp]
	mov	eax, DWORD PTR [eax]
	fld	QWORD PTR [eax+ecx*8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN100@mat_inv

; 910  :              if ( ipiv[k] > 0 ) 

	fstp	ST(1)
	mov	DWORD PTR _irow$[ebp], edx
	mov	DWORD PTR _icol$[ebp], ecx
	mov	esi, ecx
	jmp	SHORT $LN29@mat_inv
$LN27@mat_inv:
	test	eax, eax
	jle	SHORT $LN29@mat_inv

; 904  :              { big = fabs(a[j][k]);
; 905  :                irow = j;
; 906  :                icol = k;
; 907  :              }
; 908  :            }
; 909  :            else 

	fstp	ST(0)
$LN118@mat_inv:
	fstp	ST(1)

; 911  :              { retval = -1; goto mat_inv_exit; }

	mov	DWORD PTR _retval$[ebp], -1
	fstp	ST(0)
	jmp	$mat_inv_exit$89764
$LN100@mat_inv:

; 910  :              if ( ipiv[k] > 0 ) 

	fstp	ST(0)
$LN29@mat_inv:

; 901  :          for ( k = 0 ; k < n ; k++ )

	inc	ecx
	cmp	ecx, ebx
	jl	SHORT $LN30@mat_inv
$LN33@mat_inv:

; 899  :     for ( j = 0 ; j < n ; j++ )

	add	DWORD PTR tv2254[ebp], 4
	inc	edx
	cmp	edx, ebx
	jl	SHORT $LN34@mat_inv

; 912  :          }
; 913  :     }
; 914  :     ++(ipiv[icol]);

	mov	eax, DWORD PTR _ipiv$[ebp]
	fstp	ST(0)

; 915  : 
; 916  :     if ( irow != icol )

	mov	ecx, DWORD PTR _irow$[ebp]
	inc	DWORD PTR [eax+esi*4]
	cmp	ecx, esi
	je	$LN82@mat_inv

; 917  :        for ( l = 0 ; l < n ; l++ ) 

	xor	eax, eax
	mov	DWORD PTR _l$[ebp], eax
	cmp	ebx, 4
	jl	SHORT $LC68@mat_inv

; 918  :          SWAP(a[irow][l],a[icol][l])

	mov	edx, DWORD PTR [edi+ecx*4]
	mov	esi, DWORD PTR [edi+esi*4]
	mov	edi, edx
	lea	ecx, DWORD PTR [edx+24]
	lea	edx, DWORD PTR [ebx-4]
	sub	edi, esi
	shr	edx, 2
	inc	edx
	lea	eax, DWORD PTR [esi+8]
	lea	esi, DWORD PTR [edx*4]
	mov	DWORD PTR _l$[ebp], esi
$LN69@mat_inv:
	fld	QWORD PTR [ecx-24]
	add	eax, 32					; 00000020H
	fld	QWORD PTR [eax-40]
	add	ecx, 32					; 00000020H
	dec	edx
	fstp	QWORD PTR [ecx-56]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [edi+eax-32]
	fld	QWORD PTR [eax-32]
	fstp	QWORD PTR [edi+eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [ecx-40]
	fld	QWORD PTR [eax-24]
	fstp	QWORD PTR [ecx-40]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [ecx-32]
	fld	QWORD PTR [eax-16]
	fstp	QWORD PTR [ecx-32]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN69@mat_inv

; 917  :        for ( l = 0 ; l < n ; l++ ) 

	mov	esi, DWORD PTR _icol$[ebp]
	mov	edi, DWORD PTR _a$GSCopy$[ebp]
	mov	eax, DWORD PTR _l$[ebp]
$LC68@mat_inv:
	cmp	eax, ebx
	jge	SHORT $LN82@mat_inv
	mov	edx, DWORD PTR [edi+esi*4]
	mov	ecx, DWORD PTR _irow$[ebp]
	mov	ecx, DWORD PTR [edi+ecx*4]
	lea	eax, DWORD PTR [edx+eax*8]
	sub	ecx, edx
	mov	edx, ebx
	sub	edx, DWORD PTR _l$[ebp]
$LC22@mat_inv:

; 918  :          SWAP(a[irow][l],a[icol][l])

	fld	QWORD PTR [ecx+eax]
	add	eax, 8
	dec	edx
	fld	QWORD PTR [eax-8]
	fstp	QWORD PTR [ecx+eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC22@mat_inv
$LN82@mat_inv:

; 919  :     indxr[i] = irow;

	mov	eax, DWORD PTR tv3215[ebp]
	mov	edx, DWORD PTR tv3223[ebp]
	mov	ecx, DWORD PTR _irow$[ebp]
	mov	DWORD PTR [edx+eax], ecx

; 920  :     indxc[i] = icol;

	mov	DWORD PTR [eax], esi

; 921  :     if ( a[icol][icol] == 0.0 ) 

	mov	eax, DWORD PTR [edi+esi*4]
	fld	QWORD PTR [eax+esi*8]
	mov	DWORD PTR tv1887[ebp], eax
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN118@mat_inv

; 922  :     { retval = -1; goto mat_inv_exit; }
; 923  :     pivinv = 1/a[icol][icol];

	mov	edx, DWORD PTR [edi+esi*4]
	fld	ST(0)
	fdiv	QWORD PTR [edx+esi*8]
	lea	eax, DWORD PTR [edx+esi*8]

; 924  :     a[icol][icol] = 1.0;
; 925  :     for ( l = 0 ; l < n ; l++ ) 

	xor	edx, edx
	fxch	ST(1)
	fst	QWORD PTR [eax]
	cmp	ebx, 4
	jl	SHORT $LC71@mat_inv

; 922  :     { retval = -1; goto mat_inv_exit; }
; 923  :     pivinv = 1/a[icol][icol];

	mov	eax, DWORD PTR [edi+esi*4]
	lea	ecx, DWORD PTR [ebx-4]
	shr	ecx, 2
	add	eax, 16					; 00000010H
	inc	ecx
	lea	edx, DWORD PTR [ecx*4]

; 924  :     a[icol][icol] = 1.0;
; 925  :     for ( l = 0 ; l < n ; l++ ) 

$LN72@mat_inv:

; 926  :       a[icol][l] *= pivinv;

	fld	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	ecx
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [eax-48]
	fld	QWORD PTR [eax-40]
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax-32]
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [eax-24]
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN72@mat_inv
$LC71@mat_inv:

; 924  :     a[icol][icol] = 1.0;
; 925  :     for ( l = 0 ; l < n ; l++ ) 

	cmp	edx, ebx
	jge	SHORT $LN128@mat_inv
	mov	eax, DWORD PTR [edi+esi*4]
	mov	ecx, ebx
	lea	eax, DWORD PTR [eax+edx*8]
	sub	ecx, edx
$LC18@mat_inv:

; 926  :       a[icol][l] *= pivinv;

	fld	ST(1)
	add	eax, 8
	dec	ecx
	fmul	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC18@mat_inv
$LN128@mat_inv:

; 927  :     for ( ll = 0  ; ll < n ; ll++ )

	xor	edx, edx
	fstp	ST(1)
	mov	DWORD PTR _ll$[ebp], edx
$LN89@mat_inv:

; 928  :       if ( ll != icol )

	cmp	edx, esi
	je	$LN14@mat_inv

; 929  :       { dum = a[ll][icol];

	mov	ecx, DWORD PTR [edi+edx*4]
	fld	QWORD PTR [ecx+esi*8]
	lea	eax, DWORD PTR [ecx+esi*8]

; 930  :         a[ll][icol] = 0.0;

	fxch	ST(2)

; 931  :         for ( l = 0 ; l < n ; l++ ) 

	xor	esi, esi
	fst	QWORD PTR [eax]
	cmp	ebx, 4
	jl	SHORT $LC74@mat_inv
	mov	eax, DWORD PTR _a$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edi, DWORD PTR tv1887[ebp]
	lea	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edi+24]

; 932  :           a[ll][l] -= a[icol][l]*dum;

	sub	edi, ecx
	lea	ecx, DWORD PTR [ebx-4]
	shr	ecx, 2
	inc	ecx
	lea	esi, DWORD PTR [ecx*4]
$LN75@mat_inv:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(3)
	add	edx, 32					; 00000020H
	dec	ecx
	fsubr	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax+edi-32]
	fmul	ST(0), ST(3)
	fsubr	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(3)
	fsubr	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	ST(2)
	fmul	QWORD PTR [edx-32]
	fsubr	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN75@mat_inv

; 929  :       { dum = a[ll][icol];

	mov	edx, DWORD PTR _ll$[ebp]
$LC74@mat_inv:

; 931  :         for ( l = 0 ; l < n ; l++ ) 

	cmp	esi, ebx
	jge	SHORT $LN140@mat_inv
	mov	ecx, DWORD PTR _a$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edi, DWORD PTR tv1887[ebp]
	lea	eax, DWORD PTR [ecx+esi*8]
	sub	edi, ecx
	mov	ecx, ebx
	sub	ecx, esi
$LC11@mat_inv:

; 932  :           a[ll][l] -= a[icol][l]*dum;

	fld	QWORD PTR [eax+edi]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(3)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC11@mat_inv
$LN140@mat_inv:

; 931  :         for ( l = 0 ; l < n ; l++ ) 

	mov	edi, DWORD PTR _a$GSCopy$[ebp]
	fstp	ST(2)
	mov	esi, DWORD PTR _icol$[ebp]
$LN14@mat_inv:

; 927  :     for ( ll = 0  ; ll < n ; ll++ )

	inc	edx
	mov	DWORD PTR _ll$[ebp], edx
	cmp	edx, ebx
	jl	$LN89@mat_inv

; 895  :     ipiv[j] = -1;
; 896  :   for ( i = 0 ; i < n ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv3215[ebp], 4
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, ebx
	jl	$LN85@mat_inv

; 921  :     if ( a[icol][icol] == 0.0 ) 

	mov	edx, DWORD PTR _indxc$[ebp]
	fstp	ST(1)
	fstp	ST(0)
$LN35@mat_inv:

; 933  :       }
; 934  :   }
; 935  :   for ( l = n-1 ; l >= 0 ; l-- )

	lea	eax, DWORD PTR [ebx-1]
	mov	DWORD PTR _l$[ebp], eax
	test	eax, eax
	js	$mat_inv_exit$89764
	lea	eax, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _indxr$[ebp]
	sub	edx, DWORD PTR _indxc$[ebp]
	npad	6
$LL88@mat_inv:

; 936  :   { if ( indxr[l] != indxc[l] )

	mov	ecx, DWORD PTR [eax+edx]
	cmp	ecx, DWORD PTR [eax]
	je	$LN7@mat_inv

; 937  :        for ( k = 0 ; k < n ; k++ )

	xor	edi, edi
	cmp	ebx, 4
	jl	$LC77@mat_inv
	mov	ecx, DWORD PTR _a$GSCopy$[ebp]
	lea	esi, DWORD PTR [ebx-4]
	shr	esi, 2
	inc	esi
	mov	DWORD PTR tv3558[ebp], esi
	add	esi, esi
	add	ecx, 8
	add	esi, esi
	mov	DWORD PTR _k$[ebp], esi
$LL78@mat_inv:

; 938  :           SWAP(a[k][indxr[l]],a[k][indxc[l]])

	mov	edi, DWORD PTR [eax+edx]
	mov	esi, DWORD PTR [ecx-8]
	fld	QWORD PTR [esi+edi*8]
	lea	edi, DWORD PTR [esi+edi*8]
	mov	DWORD PTR tv3799[ebp], edi
	mov	edi, DWORD PTR [eax]
	fld	QWORD PTR [esi+edi*8]
	mov	edi, DWORD PTR tv3799[ebp]
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR [eax]
	add	ecx, 16					; 00000010H
	dec	DWORD PTR tv3558[ebp]
	fstp	QWORD PTR [esi+edi*8]
	mov	edi, DWORD PTR [eax+edx]
	mov	esi, DWORD PTR [ecx-20]
	fld	QWORD PTR [esi+edi*8]
	lea	edi, DWORD PTR [esi+edi*8]
	mov	DWORD PTR tv3817[ebp], edi
	mov	edi, DWORD PTR [eax]
	fld	QWORD PTR [esi+edi*8]
	mov	edi, DWORD PTR tv3817[ebp]
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR [eax]
	fstp	QWORD PTR [esi+edi*8]
	mov	esi, DWORD PTR [ecx-16]
	mov	edi, DWORD PTR [eax+edx]
	fld	QWORD PTR [esi+edi*8]
	lea	edi, DWORD PTR [esi+edi*8]
	mov	DWORD PTR tv3830[ebp], edi
	mov	edi, DWORD PTR [eax]
	fld	QWORD PTR [esi+edi*8]
	mov	edi, DWORD PTR tv3830[ebp]
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR [eax]
	fstp	QWORD PTR [esi+edi*8]
	mov	esi, DWORD PTR [ecx-12]
	mov	edi, DWORD PTR [eax+edx]
	fld	QWORD PTR [esi+edi*8]
	lea	edi, DWORD PTR [esi+edi*8]
	mov	DWORD PTR tv3843[ebp], edi
	mov	edi, DWORD PTR [eax]
	fld	QWORD PTR [esi+edi*8]
	mov	edi, DWORD PTR tv3843[ebp]
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR [eax]
	fstp	QWORD PTR [esi+edi*8]
	jne	$LL78@mat_inv

; 937  :        for ( k = 0 ; k < n ; k++ )

	mov	edi, DWORD PTR _k$[ebp]
$LC77@mat_inv:
	cmp	edi, ebx
	jge	SHORT $LN7@mat_inv
	npad	1
$LL83@mat_inv:

; 938  :           SWAP(a[k][indxr[l]],a[k][indxc[l]])

	mov	ecx, DWORD PTR _a$GSCopy$[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	esi, DWORD PTR [eax+edx]
	fld	QWORD PTR [ecx+esi*8]
	lea	esi, DWORD PTR [ecx+esi*8]
	mov	DWORD PTR tv3861[ebp], esi
	mov	esi, DWORD PTR [eax]
	fld	QWORD PTR [ecx+esi*8]
	mov	esi, DWORD PTR tv3861[ebp]
	fstp	QWORD PTR [esi]
	mov	esi, DWORD PTR [eax]
	inc	edi
	fstp	QWORD PTR [ecx+esi*8]
	cmp	edi, ebx
	jl	SHORT $LL83@mat_inv
$LN7@mat_inv:

; 933  :       }
; 934  :   }
; 935  :   for ( l = n-1 ; l >= 0 ; l-- )

	mov	ecx, DWORD PTR _l$[ebp]
	dec	ecx
	sub	eax, 4
	mov	DWORD PTR _l$[ebp], ecx
	test	ecx, ecx
	jns	$LL88@mat_inv
$mat_inv_exit$89764:

; 939  :   }
; 940  : 
; 941  : mat_inv_exit:
; 942  :   if ( n > SMALL )

	cmp	ebx, 10					; 0000000aH
	jle	SHORT $LN79@mat_inv

; 943  :   { free_ivector(ipiv,0,n-1);

	mov	edx, DWORD PTR _ipiv$[ebp]
	dec	ebx
	push	ebx
	push	0
	push	edx
	call	_free_ivector

; 944  :     free_ivector(indxr,0,n-1);

	mov	eax, DWORD PTR _indxr$[ebp]
	push	ebx
	push	0
	push	eax
	call	_free_ivector

; 945  :     free_ivector(indxc,0,n-1);

	mov	ecx, DWORD PTR _indxc$[ebp]
	push	ebx
	push	0
	push	ecx
	call	_free_ivector
	add	esp, 36					; 00000024H
$LN79@mat_inv:

; 946  :   }
; 947  :   return retval;
; 948  : } /* end mat_inv() */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, DWORD PTR _retval$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_mat_inv ENDP
_TEXT	ENDS
PUBLIC	_mat_approx_solve
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogtp
;	COMDAT _mat_approx_solve
_TEXT	SEGMENT
tv5029 = -40						; size = 4
tv5023 = -36						; size = 4
tv4786 = -32						; size = 4
tv4832 = -28						; size = 4
_ll$ = -24						; size = 4
_l$ = -24						; size = 4
_rank$ = -20						; size = 4
tv4923 = -16						; size = 4
tv4551 = -12						; size = 4
tv4547 = -8						; size = 4
tv4784 = -4						; size = 4
_a$ = 8							; size = 4
tv4681 = 12						; size = 4
_irow$ = 12						; size = 4
_n$ = 12						; size = 4
_b$ = 16						; size = 4
_mat_approx_solve PROC					; COMDAT

; 967  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 968  :   int i,j,l,ll,irow=0;
; 969  :   REAL big,dum,pivinv;
; 970  :   int rank = n;  /* return value is effective rank of matrix */
; 971  : 
; 972  :   /* normalize row magnitudes */
; 973  :   for ( i = 0 ; i < n ; i++ )

	fldz
	push	ebx
	fld1
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR _rank$[ebp], esi
	test	esi, esi
	jle	$LN108@mat_approx
$LN79@mat_approx:

; 974  :   { REAL mag = 0.0;

	mov	edi, DWORD PTR _a$[ebp]
	fld	ST(1)

; 975  :     for ( j = 0 ; j < n ; j++ )

	xor	edx, edx
	cmp	esi, 4
	jl	SHORT $LC54@mat_approx

; 974  :   { REAL mag = 0.0;

	mov	eax, DWORD PTR [edi+ebx*4]
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	add	eax, 16					; 00000010H
	inc	ecx
	lea	edx, DWORD PTR [ecx*4]

; 975  :     for ( j = 0 ; j < n ; j++ )

$LN55@mat_approx:

; 976  :       mag += a[i][j]*a[i][j];

	fld	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	ecx
	fld	QWORD PTR [eax-40]
	fld	QWORD PTR [eax-32]
	fld	QWORD PTR [eax-24]
	fld	ST(3)
	fmulp	ST(4), ST(0)
	fxch	ST(3)
	faddp	ST(4), ST(0)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fxch	ST(3)
	faddp	ST(1), ST(0)
	fld	ST(2)
	fmulp	ST(3), ST(0)
	faddp	ST(2), ST(0)
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LN55@mat_approx
$LC54@mat_approx:

; 975  :     for ( j = 0 ; j < n ; j++ )

	cmp	edx, esi
	jge	SHORT $LN53@mat_approx
	mov	eax, DWORD PTR [edi+ebx*4]
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	eax, esi
	sub	eax, edx
$LC29@mat_approx:

; 976  :       mag += a[i][j]*a[i][j];

	fld	QWORD PTR [ecx]
	add	ecx, 8
	dec	eax
	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	jne	SHORT $LC29@mat_approx
$LN53@mat_approx:

; 977  :     if ( mag > 0.0 )

	fcom	ST(2)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN26@mat_approx

; 978  :       mag = 1/sqrt(mag);

	fstp	ST(2)
	fstp	ST(0)
	call	__CIsqrt
	fld1
	fld	ST(0)
	fdivrp	ST(2), ST(0)
	fldz
	fxch	ST(2)
$LN26@mat_approx:

; 979  :     for ( j = 0 ; j < n ; j++ )

	xor	edx, edx
	cmp	esi, 4
	jl	SHORT $LC57@mat_approx
	mov	eax, DWORD PTR [edi+ebx*4]
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	add	eax, 16					; 00000010H
	inc	ecx
	lea	edx, DWORD PTR [ecx*4]
$LN58@mat_approx:

; 980  :       a[i][j] *= mag;

	fld	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	ecx
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-48]
	fld	QWORD PTR [eax-40]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax-32]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [eax-24]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN58@mat_approx
$LC57@mat_approx:

; 979  :     for ( j = 0 ; j < n ; j++ )

	cmp	edx, esi
	jge	SHORT $LN56@mat_approx
	mov	ecx, DWORD PTR [edi+ebx*4]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, esi
	sub	ecx, edx
$LC25@mat_approx:

; 980  :       a[i][j] *= mag;

	fld	ST(0)
	add	eax, 8
	dec	ecx
	fmul	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC25@mat_approx
$LN56@mat_approx:

; 981  :     b[i] *= mag;

	mov	eax, DWORD PTR _b$[ebp]
	fmul	QWORD PTR [eax+ebx*8]
	inc	ebx
	fstp	QWORD PTR [eax+ebx*8-8]
	cmp	ebx, esi
	jl	$LN79@mat_approx

; 982  :   }
; 983  : 
; 984  :   /* now gaussian elimination */
; 985  :   for ( i = 0 ; i < n ; i++ )

	test	esi, esi
	jle	$LN108@mat_approx
	mov	eax, DWORD PTR _a$[ebp]

; 1004 :       b[i] = 0.0;

	mov	ebx, DWORD PTR _b$[ebp]
	mov	DWORD PTR tv4784[ebp], eax
	mov	eax, 32					; 00000020H
	sub	eax, ebx
	mov	DWORD PTR tv5023[ebp], eax
	xor	edi, edi
	mov	eax, 8
	mov	edx, 1
	lea	ecx, DWORD PTR [esi-1]
	sub	eax, ebx
	mov	DWORD PTR tv4547[ebp], edi
	mov	DWORD PTR tv4551[ebp], edx
	mov	DWORD PTR tv4786[ebp], -1
	mov	DWORD PTR tv4923[ebp], ecx
	mov	DWORD PTR tv5029[ebp], eax
	jmp	SHORT $LN80@mat_approx
$LN158@mat_approx:

; 982  :   }
; 983  : 
; 984  :   /* now gaussian elimination */
; 985  :   for ( i = 0 ; i < n ; i++ )

	fxch	ST(1)
$LN80@mat_approx:

; 986  :   { /* find pivot */
; 987  :     big = fabs(a[i][i]);

	mov	eax, DWORD PTR tv4784[ebp]
	mov	eax, DWORD PTR [eax]
	fld	QWORD PTR [eax+edi]
	mov	DWORD PTR tv4832[ebp], eax

; 988  :     irow = i;

	lea	eax, DWORD PTR [edx-1]
	fabs
	mov	DWORD PTR _irow$[ebp], eax

; 989  :     for ( j = i+1 ; j < n ; j++ )

	mov	ecx, edx
	cmp	edx, esi
	jge	$LN112@mat_approx
	cmp	DWORD PTR tv4923[ebp], 4
	jl	$LC60@mat_approx

; 990  :     { 
; 991  :       if ( fabs(a[j][i]) > big )

	mov	ebx, DWORD PTR tv4784[ebp]
	add	ebx, 12					; 0000000cH
$LN65@mat_approx:
	mov	eax, DWORD PTR [ebx-8]
	fld	QWORD PTR [eax+edi]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN119@mat_approx

; 992  :       { big = fabs(a[j][i]);
; 993  :         irow = j;

	fstp	ST(1)
	mov	DWORD PTR _irow$[ebp], ecx
	jmp	SHORT $LN61@mat_approx
$LN119@mat_approx:
	fstp	ST(0)
$LN61@mat_approx:

; 990  :     { 
; 991  :       if ( fabs(a[j][i]) > big )

	mov	eax, DWORD PTR [ebx-4]
	fld	QWORD PTR [eax+edi]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN122@mat_approx
	lea	eax, DWORD PTR [ecx+1]
	fstp	ST(1)
	mov	DWORD PTR _irow$[ebp], eax
	jmp	SHORT $LN62@mat_approx
$LN122@mat_approx:
	fstp	ST(0)
$LN62@mat_approx:
	mov	eax, DWORD PTR [ebx]
	fld	QWORD PTR [edi+eax]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN125@mat_approx
	lea	eax, DWORD PTR [ecx+2]
	fstp	ST(1)
	mov	DWORD PTR _irow$[ebp], eax
	jmp	SHORT $LN63@mat_approx
$LN125@mat_approx:
	fstp	ST(0)
$LN63@mat_approx:
	mov	eax, DWORD PTR [ebx+4]
	fld	QWORD PTR [eax+edi]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN128@mat_approx
	lea	eax, DWORD PTR [ecx+3]
	fstp	ST(1)
	mov	DWORD PTR _irow$[ebp], eax
	jmp	SHORT $LN64@mat_approx
$LN128@mat_approx:
	fstp	ST(0)
$LN64@mat_approx:
	add	ecx, 4
	lea	eax, DWORD PTR [esi-3]
	add	ebx, 16					; 00000010H
	cmp	ecx, eax
	jl	SHORT $LN65@mat_approx
	mov	ebx, DWORD PTR _b$[ebp]
$LC60@mat_approx:

; 989  :     for ( j = i+1 ; j < n ; j++ )

	cmp	ecx, esi
	jge	SHORT $LN137@mat_approx
$LC19@mat_approx:

; 990  :     { 
; 991  :       if ( fabs(a[j][i]) > big )

	mov	eax, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	fld	QWORD PTR [eax+edi]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN135@mat_approx

; 992  :       { big = fabs(a[j][i]);
; 993  :         irow = j;

	fstp	ST(1)
	mov	DWORD PTR _irow$[ebp], ecx
	jmp	SHORT $LN18@mat_approx
$LN135@mat_approx:
	fstp	ST(0)
$LN18@mat_approx:
	inc	ecx

; 989  :     for ( j = i+1 ; j < n ; j++ )

	cmp	ecx, esi
	jl	SHORT $LC19@mat_approx
$LN137@mat_approx:

; 994  :       }
; 995  :     }
; 996  : 
; 997  :     if ( irow != i )

	mov	ecx, DWORD PTR _irow$[ebp]
	fstp	ST(0)
	lea	eax, DWORD PTR [edx-1]
	cmp	ecx, eax
	je	$LN81@mat_approx

; 998  :     { for ( l = 0 ; l < n ; l++ ) 

	xor	eax, eax
	mov	DWORD PTR _l$[ebp], eax
	cmp	esi, 4
	jl	SHORT $LC67@mat_approx
	mov	edx, DWORD PTR _a$[ebp]
	mov	ebx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR tv4784[ebp]
	mov	edx, DWORD PTR [eax]
	lea	eax, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [ebx+24]

; 999  :         SWAP(a[irow][l],a[i][l])

	sub	ebx, edx
	lea	edx, DWORD PTR [esi-4]
	shr	edx, 2
	inc	edx
	lea	edi, DWORD PTR [edx*4]
	mov	DWORD PTR _l$[ebp], edi
$LN68@mat_approx:
	fld	QWORD PTR [ecx-24]
	add	eax, 32					; 00000020H
	fld	QWORD PTR [eax-40]
	add	ecx, 32					; 00000020H
	dec	edx
	fstp	QWORD PTR [ecx-56]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [ebx+eax-32]
	fld	QWORD PTR [eax-32]
	fstp	QWORD PTR [ebx+eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [ecx-40]
	fld	QWORD PTR [eax-24]
	fstp	QWORD PTR [ecx-40]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [ecx-32]
	fld	QWORD PTR [eax-16]
	fstp	QWORD PTR [ecx-32]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN68@mat_approx

; 998  :     { for ( l = 0 ; l < n ; l++ ) 

	mov	edx, DWORD PTR tv4551[ebp]
	mov	edi, DWORD PTR tv4547[ebp]
	mov	eax, DWORD PTR _l$[ebp]
	mov	ebx, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _irow$[ebp]
$LC67@mat_approx:
	cmp	eax, esi
	jge	SHORT $LN66@mat_approx
	mov	ecx, DWORD PTR tv4784[ebp]
	mov	ebx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edi, DWORD PTR _irow$[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4]
	lea	eax, DWORD PTR [ebx+eax*8]
	sub	ecx, ebx
	mov	ebx, esi
	sub	ebx, DWORD PTR _l$[ebp]
$LC14@mat_approx:

; 999  :         SWAP(a[irow][l],a[i][l])

	fld	QWORD PTR [ecx+eax]
	add	eax, 8
	dec	ebx
	fld	QWORD PTR [eax-8]
	fstp	QWORD PTR [ecx+eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC14@mat_approx

; 998  :     { for ( l = 0 ; l < n ; l++ ) 

	mov	edi, DWORD PTR tv4547[ebp]
	mov	ebx, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _irow$[ebp]
$LN66@mat_approx:

; 1000 :       SWAP(b[irow],b[i]);

	fld	QWORD PTR [ebx+ecx*8]
	fld	QWORD PTR [edi+ebx]
	fstp	QWORD PTR [ebx+ecx*8]
	fstp	QWORD PTR [edi+ebx]
	jmp	SHORT $LN81@mat_approx
$LN112@mat_approx:
	fstp	ST(0)
$LN81@mat_approx:

; 1001 :     }
; 1002 :     if ( fabs(a[i][i]) < mat_approx_solve_epsilon ) 

	mov	eax, DWORD PTR tv4832[ebp]
	fld	QWORD PTR [eax+edi]
	fabs
	fcomp	QWORD PTR _mat_approx_solve_epsilon
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN11@mat_approx

; 1003 :     { rank--;

	mov	eax, 1

; 1004 :       b[i] = 0.0;

	fxch	ST(1)
	sub	DWORD PTR _rank$[ebp], eax
	fst	QWORD PTR [edi+ebx]

; 1005 :       continue; 

	jmp	$LN21@mat_approx
$LN11@mat_approx:

; 1006 :     }
; 1007 : 
; 1008 :     pivinv = 1/a[i][i];

	mov	ecx, DWORD PTR tv4784[ebp]
	fld	ST(0)
	mov	eax, DWORD PTR [ecx]
	fdiv	QWORD PTR [eax+edi]

; 1009 :     a[i][i] = 1.0;
; 1010 :     for ( l = i+1 ; l < n ; l++ ) 

	mov	ebx, edx
	fxch	ST(1)
	fst	QWORD PTR [eax+edi]
	cmp	edx, esi
	jge	SHORT $LN69@mat_approx
	cmp	DWORD PTR tv4923[ebp], 4
	jl	SHORT $LC70@mat_approx

; 1011 :       a[i][l] *= pivinv;

	mov	ecx, DWORD PTR tv5023[ebp]
	mov	eax, DWORD PTR tv4784[ebp]
	mov	eax, DWORD PTR [eax]
	add	ecx, edi
	add	ecx, DWORD PTR _b$[ebp]
	lea	ecx, DWORD PTR [ecx+eax-8]
	mov	eax, esi
	sub	eax, edx
	sub	eax, 4
	shr	eax, 2
	inc	eax
	lea	ebx, DWORD PTR [edx+eax*4]
$LN71@mat_approx:
	fld	QWORD PTR [ecx-16]
	add	ecx, 32					; 00000020H
	dec	eax
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [ecx-48]
	fld	QWORD PTR [ecx-40]
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [ecx-40]
	fld	QWORD PTR [ecx-32]
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [ecx-32]
	fld	ST(1)
	fmul	QWORD PTR [ecx-24]
	fstp	QWORD PTR [ecx-24]
	jne	SHORT $LN71@mat_approx
$LC70@mat_approx:

; 1009 :     a[i][i] = 1.0;
; 1010 :     for ( l = i+1 ; l < n ; l++ ) 

	cmp	ebx, esi
	jge	SHORT $LN69@mat_approx
	mov	ecx, DWORD PTR tv4784[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	ecx, esi
	lea	eax, DWORD PTR [eax+ebx*8]
	sub	ecx, ebx
$LC10@mat_approx:

; 1011 :       a[i][l] *= pivinv;

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC10@mat_approx
$LN69@mat_approx:

; 1012 :     b[i] *= pivinv;

	mov	ecx, DWORD PTR _b$[ebp]
	fld	QWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [edi+ecx]
	fmulp	ST(2), ST(0)

; 1013 :     for ( ll = 0  ; ll < n ; ll++ )

	xor	ecx, ecx
	fxch	ST(1)
	mov	DWORD PTR tv4681[ebp], eax
	mov	DWORD PTR _ll$[ebp], ecx
	fstp	QWORD PTR [eax]
$LN7@mat_approx:

; 1014 :     { if ( ll == i ) continue;

	lea	ebx, DWORD PTR [edx-1]
	cmp	ecx, ebx
	je	$LN6@mat_approx

; 1015 :       { dum = a[ll][i];

	mov	ebx, DWORD PTR _a$[ebp]
	mov	ebx, DWORD PTR [ebx+ecx*4]
	fld	QWORD PTR [ebx+edi]

; 1016 :         a[ll][i] = 0.0;

	fxch	ST(2)
	fst	QWORD PTR [ebx+edi]

; 1017 :         for ( l = i+1 ; l < n ; l++ ) 

	mov	ebx, edx
	cmp	edx, esi
	jge	$LN78@mat_approx
	mov	edi, DWORD PTR tv4786[ebp]
	add	edi, esi
	cmp	edi, 4
	jl	SHORT $LN77@mat_approx
	mov	edx, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]

; 1018 :           a[ll][l] -= a[i][l]*dum;

	mov	edi, DWORD PTR tv4832[ebp]
	mov	edx, DWORD PTR tv5023[ebp]
	mov	ebx, DWORD PTR tv5029[ebp]
	add	edx, edi
	add	ebx, eax
	sub	edi, ecx
	add	edx, eax
	lea	eax, DWORD PTR [ebx+ecx+8]
	mov	ebx, DWORD PTR tv4551[ebp]
	mov	ecx, esi
	sub	ecx, ebx
	sub	ecx, 4
	shr	ecx, 2
	inc	ecx
	lea	ebx, DWORD PTR [ebx+ecx*4]
$LN74@mat_approx:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(3)
	add	edx, 32					; 00000020H
	dec	ecx
	fsubr	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax+edi-32]
	fmul	ST(0), ST(3)
	fsubr	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(3)
	fsubr	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fmul	ST(0), ST(3)
	fsubr	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN74@mat_approx
	mov	eax, DWORD PTR tv4681[ebp]
	mov	ecx, DWORD PTR _ll$[ebp]
	mov	edx, DWORD PTR tv4551[ebp]
$LN77@mat_approx:
	mov	edi, DWORD PTR tv4547[ebp]
	cmp	ebx, esi
	jge	SHORT $LN78@mat_approx

; 1017 :         for ( l = i+1 ; l < n ; l++ ) 

	mov	eax, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	edi, DWORD PTR tv4832[ebp]
	lea	eax, DWORD PTR [edx+ebx*8]
	sub	edi, edx
	mov	edx, esi
	sub	edx, ebx
$LC3@mat_approx:

; 1018 :           a[ll][l] -= a[i][l]*dum;

	fld	QWORD PTR [edi+eax]
	add	eax, 8
	dec	edx
	fmul	ST(0), ST(3)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC3@mat_approx

; 1017 :         for ( l = i+1 ; l < n ; l++ ) 

	mov	edi, DWORD PTR tv4547[ebp]
	mov	edx, DWORD PTR tv4551[ebp]
	mov	eax, DWORD PTR tv4681[ebp]
$LN78@mat_approx:

; 1019 :         b[ll] -= b[i]*dum;

	fld	QWORD PTR [eax]
	mov	ebx, DWORD PTR _b$[ebp]
	fmulp	ST(3), ST(0)
	fld	QWORD PTR [ebx+ecx*8]
	fsubrp	ST(3), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR [ebx+ecx*8]
$LN6@mat_approx:

; 1013 :     for ( ll = 0  ; ll < n ; ll++ )

	inc	ecx
	mov	DWORD PTR _ll$[ebp], ecx
	cmp	ecx, esi
	jl	$LN7@mat_approx
	mov	ebx, DWORD PTR _b$[ebp]
	fxch	ST(1)
	mov	eax, 1
$LN21@mat_approx:

; 982  :   }
; 983  : 
; 984  :   /* now gaussian elimination */
; 985  :   for ( i = 0 ; i < n ; i++ )

	sub	DWORD PTR tv4786[ebp], eax
	sub	DWORD PTR tv4923[ebp], eax
	add	DWORD PTR tv4784[ebp], 4
	add	edx, eax
	add	edi, 8
	lea	ecx, DWORD PTR [edx-1]
	mov	DWORD PTR tv4551[ebp], edx
	mov	DWORD PTR tv4547[ebp], edi
	cmp	ecx, esi
	jl	$LN158@mat_approx

; 1020 :       }
; 1021 :     }
; 1022 :   }
; 1023 : 
; 1024 :   return rank;

	mov	eax, DWORD PTR _rank$[ebp]
	fstp	ST(0)
	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx

; 1025 : 
; 1026 : } /* end mat_approx_solve() */

	mov	esp, ebp
	pop	ebp
	ret	0
$LN108@mat_approx:
	pop	edi

; 982  :   }
; 983  : 
; 984  :   /* now gaussian elimination */
; 985  :   for ( i = 0 ; i < n ; i++ )

	fstp	ST(1)

; 1020 :       }
; 1021 :     }
; 1022 :   }
; 1023 : 
; 1024 :   return rank;

	mov	eax, esi
	fstp	ST(0)
	pop	esi
	pop	ebx

; 1025 : 
; 1026 : } /* end mat_approx_solve() */

	mov	esp, ebp
	pop	ebp
	ret	0
_mat_approx_solve ENDP
_TEXT	ENDS
PUBLIC	_n$GSCopy$
PUBLIC	_a$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_mat_inv_sym
EXTRN	_BKalpha:QWORD
; Function compile flags: /Ogtp
;	COMDAT _mat_inv_sym
_TEXT	SEGMENT
tv14008 = -156						; size = 4
_a$GSCopy$ = -156					; size = 4
tv12905 = -152						; size = 4
_irow$ = -152						; size = 4
_spiv$ = -148						; size = 4
tv18633 = -144						; size = 4
tv18545 = -144						; size = 4
tv13983 = -144						; size = 4
tv12541 = -144						; size = 4
tv12538 = -144						; size = 4
_negs$ = -140						; size = 4
tv18640 = -136						; size = 4
tv15381 = -136						; size = 4
tv15229 = -136						; size = 4
tv15113 = -136						; size = 4
tv13986 = -136						; size = 4
_k$ = -136						; size = 4
tv13030 = -132						; size = 4
tv12200 = -132						; size = 4
_ipiv$ = -128						; size = 4
tv15877 = -124						; size = 4
tv12762 = -124						; size = 4
tv12293 = -124						; size = 4
tv17584 = -120						; size = 4
tv13662 = -120						; size = 4
tv10434 = -120						; size = 4
tv9431 = -120						; size = 4
tv7882 = -120						; size = 4
tv15330 = -116						; size = 4
tv13697 = -116						; size = 4
tv11840 = -116						; size = 4
tv10747 = -116						; size = 4
tv10397 = -116						; size = 4
tv9732 = -116						; size = 4
tv9394 = -116						; size = 4
tv7857 = -116						; size = 4
tv13943 = -112						; size = 4
tv7311 = -112						; size = 4
tv13625 = -108						; size = 4
tv12196 = -108						; size = 4
tv11540 = -108						; size = 4
tv14997 = -104						; size = 4
tv13990 = -104						; size = 4
tv12469 = -104						; size = 4
tv12038 = -104						; size = 4
tv7737 = -104						; size = 4
tv13870 = -100						; size = 4
tv7305 = -100						; size = 4
_i$ = -100						; size = 4
tv13506 = -96						; size = 4
tv12729 = -96						; size = 4
_j$ = -96						; size = 4
_n$GSCopy$ = -92					; size = 4
tv17372 = -88						; size = 4
tv15502 = -88						; size = 4
tv15411 = -88						; size = 4
tv14407 = -88						; size = 4
tv13775 = -88						; size = 4
tv11694 = -88						; size = 4
tv10517 = -88						; size = 4
tv9514 = -88						; size = 4
tv7953 = -88						; size = 4
tv7172 = -88						; size = 4
tv5343 = -88						; size = 4
tv4706 = -88						; size = 4
tv1201 = -88						; size = 4
tv952 = -88						; size = 4
tv910 = -88						; size = 4
tv556 = -88						; size = 4
tv303 = -88						; size = 4
_temp1$ = -84						; size = 40
_temp3$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_n$ = 12						; size = 4
_mat_inv_sym PROC					; COMDAT

; 1046 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _a$[ebp]
	push	esi
	mov	esi, DWORD PTR _n$[ebp]
	push	edi

; 1047 :   int *spiv; /* 1 or 2, size of pivot */
; 1048 :   int *ipiv; /* permutation */
; 1049 :   int i,irow=0,j,k;

	xor	edi, edi
	mov	DWORD PTR _a$GSCopy$[ebp], ebx
	mov	DWORD PTR _n$GSCopy$[ebp], esi
	mov	DWORD PTR _irow$[ebp], edi

; 1050 :   REAL piv;
; 1051 :   int temp1[SMALL],temp3[SMALL]; /* avoid alloc for small sizes */
; 1052 :   int negs = 0;

	mov	DWORD PTR _negs$[ebp], edi

; 1053 : 
; 1054 :   if ( n <= SMALL )

	cmp	esi, 10					; 0000000aH
	jg	SHORT $LN117@mat_inv_sy

; 1055 :   { spiv = temp1; ipiv = temp3; }

	lea	eax, DWORD PTR _temp1$[ebp]
	mov	DWORD PTR _spiv$[ebp], eax
	lea	eax, DWORD PTR _temp3$[ebp]

; 1056 :   else

	jmp	SHORT $LN581@mat_inv_sy
$LN117@mat_inv_sy:

; 1057 :   { /* large size */
; 1058 :     spiv = ivector(0,n-1);

	lea	eax, DWORD PTR [esi-1]
	push	eax
	push	edi
	call	_ivector
	mov	DWORD PTR _spiv$[ebp], eax

; 1059 :     ipiv = ivector(0,n-1);

	lea	eax, DWORD PTR [esi-1]
	push	eax
	push	0
	call	_ivector
	add	esp, 16					; 00000010H
$LN581@mat_inv_sy:

; 1060 :   }
; 1061 :   for ( j = 0 ; j < n ; j++ ) 

	xor	ecx, ecx
	mov	DWORD PTR _ipiv$[ebp], eax
	test	esi, esi
	jle	SHORT $LN113@mat_inv_sy
	npad	3
$LL115@mat_inv_sy:

; 1062 :     ipiv[j] = j;

	mov	DWORD PTR [eax+ecx*4], ecx
	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LL115@mat_inv_sy
$LN113@mat_inv_sy:

; 1063 : 
; 1064 :   /* First, do LDL with Bunch-Kaufman pivoting */
; 1065 :   for ( i = 0 ; i < n ; i++ )

	fldz
	xor	ecx, ecx
	test	esi, esi
	jle	$LN110@mat_inv_sy
$LN112@mat_inv_sy:

; 1066 :   { /* find pivot */
; 1067 :     /* max in pivot column */
; 1068 :     int s = 1; /* pivot size */
; 1069 :     REAL lambda = 0.0;
; 1070 :     for ( j = i+1 ; j < n ; j++ )

	mov	eax, DWORD PTR _n$GSCopy$[ebp]
	fld	ST(0)
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR tv7305[ebp], edx
	cmp	edx, eax
	jge	$LN301@mat_inv_sy
	sub	eax, edx
	cmp	eax, 4
	jl	SHORT $LN271@mat_inv_sy

; 1071 :     { if ( fabs(a[i][j]) > lambda )

	mov	eax, DWORD PTR [ebx+ecx*4]
	lea	esi, DWORD PTR [eax+edx*8+16]
$LN186@mat_inv_sy:
	fld	QWORD PTR [esi-16]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN308@mat_inv_sy

; 1072 :       { lambda = fabs(a[i][j]);
; 1073 :         irow = j;

	fstp	ST(1)
	mov	edi, edx
	jmp	SHORT $LN182@mat_inv_sy
$LN308@mat_inv_sy:
	fstp	ST(0)
$LN182@mat_inv_sy:

; 1071 :     { if ( fabs(a[i][j]) > lambda )

	fld	QWORD PTR [esi-8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN311@mat_inv_sy
	fstp	ST(1)
	lea	edi, DWORD PTR [edx+1]
	jmp	SHORT $LN183@mat_inv_sy
$LN311@mat_inv_sy:
	fstp	ST(0)
$LN183@mat_inv_sy:
	fld	QWORD PTR [esi]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN314@mat_inv_sy
	fstp	ST(1)
	lea	edi, DWORD PTR [edx+2]
	jmp	SHORT $LN184@mat_inv_sy
$LN314@mat_inv_sy:
	fstp	ST(0)
$LN184@mat_inv_sy:
	fld	QWORD PTR [esi+8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN317@mat_inv_sy
	fstp	ST(1)
	lea	edi, DWORD PTR [edx+3]
	jmp	SHORT $LN185@mat_inv_sy
$LN317@mat_inv_sy:
	fstp	ST(0)
$LN185@mat_inv_sy:
	mov	eax, DWORD PTR _n$GSCopy$[ebp]
	add	edx, 4
	add	eax, -3					; fffffffdH
	add	esi, 32					; 00000020H
	cmp	edx, eax
	jl	SHORT $LN186@mat_inv_sy

; 1072 :       { lambda = fabs(a[i][j]);
; 1073 :         irow = j;

	mov	DWORD PTR _irow$[ebp], edi
$LN271@mat_inv_sy:

; 1066 :   { /* find pivot */
; 1067 :     /* max in pivot column */
; 1068 :     int s = 1; /* pivot size */
; 1069 :     REAL lambda = 0.0;
; 1070 :     for ( j = i+1 ; j < n ; j++ )

	cmp	edx, DWORD PTR _n$GSCopy$[ebp]
	jge	SHORT $LN256@mat_inv_sy
	mov	eax, DWORD PTR [ebx+ecx*4]
	lea	esi, DWORD PTR [eax+edx*8]
$LC109@mat_inv_sy:

; 1071 :     { if ( fabs(a[i][j]) > lambda )

	fld	QWORD PTR [esi]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN326@mat_inv_sy

; 1072 :       { lambda = fabs(a[i][j]);
; 1073 :         irow = j;

	fstp	ST(1)
	mov	edi, edx
	jmp	SHORT $LN108@mat_inv_sy
$LN326@mat_inv_sy:
	fstp	ST(0)
$LN108@mat_inv_sy:
	inc	edx

; 1066 :   { /* find pivot */
; 1067 :     /* max in pivot column */
; 1068 :     int s = 1; /* pivot size */
; 1069 :     REAL lambda = 0.0;
; 1070 :     for ( j = i+1 ; j < n ; j++ )

	add	esi, 8
	cmp	edx, DWORD PTR _n$GSCopy$[ebp]
	jl	SHORT $LC109@mat_inv_sy

; 1072 :       { lambda = fabs(a[i][j]);
; 1073 :         irow = j;

	mov	DWORD PTR _irow$[ebp], edi
$LN256@mat_inv_sy:

; 1074 :       }
; 1075 :     }
; 1076 :     if ( lambda > 0.0 )

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN301@mat_inv_sy

; 1077 :     { 
; 1078 :       if ( fabs(a[i][i]) > BKalpha*lambda  )

	mov	edx, DWORD PTR [ebx+ecx*4]
	fld	QWORD PTR [edx+ecx*8]
	fabs
	fld	QWORD PTR _BKalpha
	fld	ST(0)
	fmul	ST(0), ST(3)
	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jnp	$LN334@mat_inv_sy

; 1079 :         s = PIV1; 
; 1080 :       else
; 1081 :       { REAL sigma = 0.0;

	fld	ST(4)

; 1082 :         for ( j = i ; j < n ; j++ )

	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, DWORD PTR _n$GSCopy$[ebp]
	jge	$LN187@mat_inv_sy
	mov	eax, DWORD PTR _n$GSCopy$[ebp]
	sub	eax, ecx
	cmp	eax, 4
	jl	SHORT $LC188@mat_inv_sy

; 1083 :           if ( fabs(a[j][irow]) > sigma )

	mov	edx, DWORD PTR _n$GSCopy$[ebp]
	sub	edx, ecx
	sub	edx, 4
	shr	edx, 2
	inc	edx
	lea	eax, DWORD PTR [ecx+edx*4]
	lea	esi, DWORD PTR [ebx+ecx*4+8]
	mov	DWORD PTR _j$[ebp], eax
$LN193@mat_inv_sy:
	mov	eax, DWORD PTR [esi-8]
	fld	QWORD PTR [eax+edi*8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN344@mat_inv_sy

; 1084 :             sigma = fabs(a[j][irow]);

	fstp	ST(1)
	jmp	SHORT $LN189@mat_inv_sy
$LN344@mat_inv_sy:
	fstp	ST(0)
$LN189@mat_inv_sy:

; 1083 :           if ( fabs(a[j][irow]) > sigma )

	mov	eax, DWORD PTR [esi-4]
	fld	QWORD PTR [eax+edi*8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN347@mat_inv_sy

; 1084 :             sigma = fabs(a[j][irow]);

	fstp	ST(1)
	jmp	SHORT $LN190@mat_inv_sy
$LN347@mat_inv_sy:
	fstp	ST(0)
$LN190@mat_inv_sy:

; 1083 :           if ( fabs(a[j][irow]) > sigma )

	mov	eax, DWORD PTR [esi]
	fld	QWORD PTR [eax+edi*8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN350@mat_inv_sy

; 1084 :             sigma = fabs(a[j][irow]);

	fstp	ST(1)
	jmp	SHORT $LN191@mat_inv_sy
$LN350@mat_inv_sy:
	fstp	ST(0)
$LN191@mat_inv_sy:

; 1083 :           if ( fabs(a[j][irow]) > sigma )

	mov	eax, DWORD PTR [esi+4]
	fld	QWORD PTR [eax+edi*8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN353@mat_inv_sy

; 1084 :             sigma = fabs(a[j][irow]);

	fstp	ST(1)
	jmp	SHORT $LN192@mat_inv_sy
$LN353@mat_inv_sy:
	fstp	ST(0)
$LN192@mat_inv_sy:

; 1083 :           if ( fabs(a[j][irow]) > sigma )

	add	esi, 16					; 00000010H
	dec	edx
	jne	SHORT $LN193@mat_inv_sy
$LC188@mat_inv_sy:

; 1082 :         for ( j = i ; j < n ; j++ )

	mov	edx, DWORD PTR _n$GSCopy$[ebp]
	cmp	DWORD PTR _j$[ebp], edx
	jge	SHORT $LN187@mat_inv_sy
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _n$GSCopy$[ebp]
$LC102@mat_inv_sy:

; 1083 :           if ( fabs(a[j][irow]) > sigma )

	mov	eax, DWORD PTR [ebx+edx*4]
	fld	QWORD PTR [eax+edi*8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN359@mat_inv_sy

; 1084 :             sigma = fabs(a[j][irow]);

	fstp	ST(1)
	jmp	SHORT $LN101@mat_inv_sy
$LN359@mat_inv_sy:
	fstp	ST(0)
$LN101@mat_inv_sy:
	inc	edx

; 1082 :         for ( j = i ; j < n ; j++ )

	cmp	edx, esi
	jl	SHORT $LC102@mat_inv_sy
$LN187@mat_inv_sy:

; 1085 :         if ( sigma*fabs(a[i][i]) >= BKalpha*lambda*lambda )

	fmul	ST(3), ST(0)
	fxch	ST(1)
	fmulp	ST(4), ST(0)
	fxch	ST(2)
	fcomp	ST(3)
	fnstsw	ax
	fstp	ST(2)
	test	ah, 1
	je	$LN362@mat_inv_sy

; 1086 :           s = PIV1;
; 1087 :         else if ( fabs(a[irow][irow]) >= BKalpha*sigma )

	mov	edx, DWORD PTR [ebx+edi*4]
	fld	QWORD PTR [edx+edi*8]
	fabs
	fxch	ST(2)
	fmulp	ST(1), ST(0)
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H

; 1088 :         { 
; 1089 :           /* swap irow and i */
; 1090 :           int itmp = ipiv[i];

	mov	eax, DWORD PTR _ipiv$[ebp]

; 1091 :           ipiv[i] = ipiv[irow];

	mov	esi, DWORD PTR [eax+edi*4]
	jp	$LN96@mat_inv_sy
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [eax+ecx*4], esi

; 1092 :           ipiv[irow] = itmp;

	mov	DWORD PTR [eax+edi*4], edx

; 1093 :           s = PIV1;
; 1094 :           for ( j = 0 ; j < i ; j++ )

	xor	eax, eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	ecx, 4
	jl	SHORT $LN272@mat_inv_sy

; 1088 :         { 
; 1089 :           /* swap irow and i */
; 1090 :           int itmp = ipiv[i];

	mov	esi, DWORD PTR [ebx+ecx*4]
	mov	edx, DWORD PTR [ebx+edi*4]
	lea	eax, DWORD PTR [esi+24]

; 1095 :             SWAP(a[i][j],a[irow][j]);

	sub	esi, edx
	mov	DWORD PTR tv9394[ebp], eax
	lea	eax, DWORD PTR [edx+8]
	lea	edx, DWORD PTR [ecx-4]
	shr	edx, 2
	inc	edx
	mov	DWORD PTR tv7172[ebp], edx
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR _j$[ebp], edx
	mov	edx, DWORD PTR tv9394[ebp]
	mov	DWORD PTR tv9431[ebp], esi
	jmp	SHORT $LN196@mat_inv_sy
$LN270@mat_inv_sy:

; 1088 :         { 
; 1089 :           /* swap irow and i */
; 1090 :           int itmp = ipiv[i];

	mov	esi, DWORD PTR tv9431[ebp]

; 1093 :           s = PIV1;
; 1094 :           for ( j = 0 ; j < i ; j++ )

$LN196@mat_inv_sy:

; 1095 :             SWAP(a[i][j],a[irow][j]);

	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fld	QWORD PTR [eax-40]
	add	edx, 32					; 00000020H
	dec	DWORD PTR tv7172[ebp]
	fstp	QWORD PTR [edx-56]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [esi+eax-32]
	fld	QWORD PTR [eax-32]
	fstp	QWORD PTR [esi+eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fld	QWORD PTR [eax-24]
	fstp	QWORD PTR [edx-40]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fld	QWORD PTR [eax-16]
	fstp	QWORD PTR [edx-32]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN270@mat_inv_sy

; 1088 :         { 
; 1089 :           /* swap irow and i */
; 1090 :           int itmp = ipiv[i];

	mov	eax, DWORD PTR _j$[ebp]
$LN272@mat_inv_sy:

; 1093 :           s = PIV1;
; 1094 :           for ( j = 0 ; j < i ; j++ )

	cmp	eax, ecx
	jge	SHORT $LN294@mat_inv_sy
	mov	edx, DWORD PTR [ebx+edi*4]
	mov	esi, DWORD PTR [ebx+ecx*4]
	sub	esi, edx
	lea	eax, DWORD PTR [edx+eax*8]
	mov	edx, ecx
	sub	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR tv9514[ebp], esi
$LC95@mat_inv_sy:

; 1095 :             SWAP(a[i][j],a[irow][j]);

	fld	QWORD PTR [esi+eax]
	add	eax, 8
	dec	edx
	fld	QWORD PTR [eax-8]
	fstp	QWORD PTR [esi+eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC95@mat_inv_sy
$LN294@mat_inv_sy:

; 1096 :           SWAP(a[i][i],a[irow][irow]);

	mov	eax, DWORD PTR [ebx+ecx*4]
	mov	edx, DWORD PTR [ebx+edi*4]
	fld	QWORD PTR [eax+ecx*8]
	fld	QWORD PTR [edx+edi*8]
	lea	eax, DWORD PTR [eax+ecx*8]
	lea	edx, DWORD PTR [edx+edi*8]
	fstp	QWORD PTR [eax]
	fstp	QWORD PTR [edx]

; 1097 :           for ( j = i+1 ; j < irow ; j++ )

	mov	edx, DWORD PTR tv7305[ebp]
	cmp	edx, edi
	jge	$LN197@mat_inv_sy
	mov	eax, edi
	sub	eax, edx
	cmp	eax, 4
	jl	SHORT $LN257@mat_inv_sy

; 1098 :             SWAP(a[j][i],a[irow][j]);

	mov	eax, DWORD PTR [ebx+edi*4]
	lea	esi, DWORD PTR [ebx+edx*4+8]
	mov	DWORD PTR tv9732[ebp], esi
	mov	esi, edi
	sub	esi, edx
	sub	esi, 4
	shr	esi, 2
	inc	esi
	lea	eax, DWORD PTR [eax+edx*8+16]
	lea	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR _j$[ebp], edx
	mov	edx, DWORD PTR tv9732[ebp]
	mov	DWORD PTR tv5343[ebp], esi
$LN199@mat_inv_sy:
	mov	esi, DWORD PTR [edx-8]
	fld	QWORD PTR [esi+ecx*8]
	lea	esi, DWORD PTR [esi+ecx*8]
	fld	QWORD PTR [eax-16]
	add	edx, 16					; 00000010H
	fstp	QWORD PTR [esi]
	mov	esi, DWORD PTR [edx-20]
	lea	esi, DWORD PTR [esi+ecx*8]
	fstp	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	DWORD PTR tv5343[ebp]
	fld	QWORD PTR [esi]
	fld	QWORD PTR [eax-40]
	fstp	QWORD PTR [esi]
	mov	esi, DWORD PTR [edx-16]
	lea	esi, DWORD PTR [esi+ecx*8]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [esi]
	fld	QWORD PTR [eax-32]
	fstp	QWORD PTR [esi]
	mov	esi, DWORD PTR [edx-12]
	lea	esi, DWORD PTR [esi+ecx*8]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [esi]
	fld	QWORD PTR [eax-24]
	fstp	QWORD PTR [esi]
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN199@mat_inv_sy
	mov	edx, DWORD PTR _j$[ebp]
$LN257@mat_inv_sy:

; 1097 :           for ( j = i+1 ; j < irow ; j++ )

	cmp	edx, edi
	jge	SHORT $LN197@mat_inv_sy
	mov	eax, DWORD PTR [ebx+edi*4]
	lea	eax, DWORD PTR [eax+edx*8]
$LC92@mat_inv_sy:

; 1098 :             SWAP(a[j][i],a[irow][j]);

	mov	esi, DWORD PTR [ebx+edx*4]
	fld	QWORD PTR [esi+ecx*8]
	lea	esi, DWORD PTR [esi+ecx*8]
	fld	QWORD PTR [eax]
	inc	edx
	fstp	QWORD PTR [esi]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	edx, edi
	jl	SHORT $LC92@mat_inv_sy
$LN197@mat_inv_sy:

; 1099 :           for ( j = irow+1 ; j < n ; j++ )

	lea	esi, DWORD PTR [edi+1]
	cmp	esi, DWORD PTR _n$GSCopy$[ebp]
	jge	$LN274@mat_inv_sy
	mov	edx, DWORD PTR _n$GSCopy$[ebp]
	mov	eax, edx
	sub	eax, esi
	cmp	eax, 4
	jl	SHORT $LC201@mat_inv_sy

; 1100 :             SWAP(a[j][i],a[j][irow]);

	sub	edx, esi
	sub	edx, 4
	shr	edx, 2
	inc	edx
	lea	eax, DWORD PTR [ebx+esi*4+8]
	mov	DWORD PTR tv556[ebp], edx
	lea	esi, DWORD PTR [esi+edx*4]
$LN202@mat_inv_sy:
	mov	edx, DWORD PTR [eax-8]
	fld	QWORD PTR [edx+ecx*8]
	add	eax, 16					; 00000010H
	dec	DWORD PTR tv556[ebp]
	fld	QWORD PTR [edx+edi*8]
	fstp	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR [eax-20]
	fld	QWORD PTR [edx+ecx*8]
	fld	QWORD PTR [edx+edi*8]
	fstp	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR [eax-16]
	fld	QWORD PTR [edx+ecx*8]
	fld	QWORD PTR [edx+edi*8]
	fstp	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR [eax-12]
	fld	QWORD PTR [edx+ecx*8]
	fld	QWORD PTR [edx+edi*8]
	fstp	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+edi*8]
	jne	SHORT $LN202@mat_inv_sy
	mov	edx, DWORD PTR _n$GSCopy$[ebp]
$LC201@mat_inv_sy:

; 1099 :           for ( j = irow+1 ; j < n ; j++ )

	cmp	esi, edx
	jge	$LN274@mat_inv_sy
	mov	edx, DWORD PTR _n$GSCopy$[ebp]
$LC89@mat_inv_sy:

; 1100 :             SWAP(a[j][i],a[j][irow]);

	mov	eax, DWORD PTR [ebx+esi*4]
	fld	QWORD PTR [eax+ecx*8]
	inc	esi
	fld	QWORD PTR [eax+edi*8]
	fstp	QWORD PTR [eax+ecx*8]
	fstp	QWORD PTR [eax+edi*8]
	cmp	esi, edx
	jl	SHORT $LC89@mat_inv_sy

; 1088 :         { 
; 1089 :           /* swap irow and i */
; 1090 :           int itmp = ipiv[i];

	jmp	$LN274@mat_inv_sy
$LN96@mat_inv_sy:

; 1101 :         }
; 1102 :         else
; 1103 :         { /* swap irow and i+1 */
; 1104 :           int itmp = ipiv[i+1];

	mov	edx, DWORD PTR [eax+ecx*4+4]

; 1105 :           ipiv[i+1] = ipiv[irow];

	mov	DWORD PTR [eax+ecx*4+4], esi

; 1106 :           ipiv[irow] = itmp;

	mov	DWORD PTR [eax+edi*4], edx

; 1107 :           s = PIV2;
; 1108 :           if ( irow != i+1 )

	mov	edx, DWORD PTR tv7305[ebp]
	cmp	edi, edx
	je	$LN275@mat_inv_sy

; 1109 :           { for ( j = 0 ; j <= i ; j++ )

	xor	eax, eax
	mov	DWORD PTR _j$[ebp], eax
	test	ecx, ecx
	js	$LN273@mat_inv_sy
	cmp	edx, 4
	jl	SHORT $LN258@mat_inv_sy

; 1110 :               SWAP(a[i+1][j],a[irow][j]);

	mov	esi, DWORD PTR [ebx+ecx*4+4]
	mov	edx, DWORD PTR [ebx+edi*4]
	lea	eax, DWORD PTR [esi+24]
	sub	esi, edx
	mov	DWORD PTR tv10397[ebp], eax
	lea	eax, DWORD PTR [edx+8]
	lea	edx, DWORD PTR [ecx+1]
	shr	edx, 2
	mov	DWORD PTR tv4706[ebp], edx
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR _j$[ebp], edx
	mov	edx, DWORD PTR tv10397[ebp]
	mov	DWORD PTR tv10434[ebp], esi
	jmp	SHORT $LN205@mat_inv_sy
$LN269@mat_inv_sy:
	mov	esi, DWORD PTR tv10434[ebp]

; 1109 :           { for ( j = 0 ; j <= i ; j++ )

$LN205@mat_inv_sy:

; 1110 :               SWAP(a[i+1][j],a[irow][j]);

	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fld	QWORD PTR [eax-40]
	add	edx, 32					; 00000020H
	dec	DWORD PTR tv4706[ebp]
	fstp	QWORD PTR [edx-56]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [esi+eax-32]
	fld	QWORD PTR [eax-32]
	fstp	QWORD PTR [esi+eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fld	QWORD PTR [eax-24]
	fstp	QWORD PTR [edx-40]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fld	QWORD PTR [eax-16]
	fstp	QWORD PTR [edx-32]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN269@mat_inv_sy
	mov	eax, DWORD PTR _j$[ebp]
$LN258@mat_inv_sy:

; 1109 :           { for ( j = 0 ; j <= i ; j++ )

	cmp	eax, ecx
	jg	SHORT $LN273@mat_inv_sy
	mov	edx, DWORD PTR [ebx+edi*4]
	mov	esi, DWORD PTR [ebx+ecx*4+4]
	sub	esi, edx
	lea	eax, DWORD PTR [edx+eax*8]
	mov	edx, ecx
	sub	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR tv10517[ebp], esi
	inc	edx
$LC84@mat_inv_sy:

; 1110 :               SWAP(a[i+1][j],a[irow][j]);

	fld	QWORD PTR [esi+eax]
	add	eax, 8
	dec	edx
	fld	QWORD PTR [eax-8]
	fstp	QWORD PTR [esi+eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC84@mat_inv_sy
$LN273@mat_inv_sy:

; 1111 :             SWAP(a[i+1][i+1],a[irow][irow]);

	mov	eax, DWORD PTR [ebx+ecx*4+4]
	mov	edx, DWORD PTR [ebx+edi*4]
	fld	QWORD PTR [eax+ecx*8+8]
	fld	QWORD PTR [edx+edi*8]
	lea	eax, DWORD PTR [eax+ecx*8+8]
	lea	edx, DWORD PTR [edx+edi*8]
	fstp	QWORD PTR [eax]
	fstp	QWORD PTR [edx]

; 1112 :             for ( j = i+2 ; j < irow ; j++ )

	lea	edx, DWORD PTR [ecx+2]
	cmp	edx, edi
	jge	$LN206@mat_inv_sy
	mov	eax, edi
	sub	eax, edx
	cmp	eax, 4
	jl	SHORT $LN259@mat_inv_sy

; 1113 :               SWAP(a[j][i+1],a[irow][j]);

	mov	eax, DWORD PTR [ebx+edi*4]
	lea	esi, DWORD PTR [ebx+edx*4+8]
	mov	DWORD PTR tv10747[ebp], esi
	mov	esi, edi
	sub	esi, edx
	sub	esi, 4
	shr	esi, 2
	inc	esi
	lea	eax, DWORD PTR [eax+edx*8+16]
	lea	edx, DWORD PTR [edx+esi*4]
	mov	DWORD PTR _j$[ebp], edx
	mov	edx, DWORD PTR tv10747[ebp]
	mov	DWORD PTR tv952[ebp], esi
$LN208@mat_inv_sy:
	mov	esi, DWORD PTR [edx-8]
	fld	QWORD PTR [esi+ecx*8+8]
	lea	esi, DWORD PTR [esi+ecx*8+8]
	fld	QWORD PTR [eax-16]
	add	edx, 16					; 00000010H
	fstp	QWORD PTR [esi]
	mov	esi, DWORD PTR [edx-20]
	lea	esi, DWORD PTR [esi+ecx*8+8]
	fstp	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	DWORD PTR tv952[ebp]
	fld	QWORD PTR [esi]
	fld	QWORD PTR [eax-40]
	fstp	QWORD PTR [esi]
	mov	esi, DWORD PTR [edx-16]
	lea	esi, DWORD PTR [esi+ecx*8+8]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [esi]
	fld	QWORD PTR [eax-32]
	fstp	QWORD PTR [esi]
	mov	esi, DWORD PTR [edx-12]
	lea	esi, DWORD PTR [esi+ecx*8+8]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [esi]
	fld	QWORD PTR [eax-24]
	fstp	QWORD PTR [esi]
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN208@mat_inv_sy
	mov	edx, DWORD PTR _j$[ebp]
$LN259@mat_inv_sy:

; 1112 :             for ( j = i+2 ; j < irow ; j++ )

	cmp	edx, edi
	jge	SHORT $LN206@mat_inv_sy
	mov	eax, DWORD PTR [ebx+edi*4]
	lea	eax, DWORD PTR [eax+edx*8]
$LC81@mat_inv_sy:

; 1113 :               SWAP(a[j][i+1],a[irow][j]);

	mov	esi, DWORD PTR [ebx+edx*4]
	fld	QWORD PTR [esi+ecx*8+8]
	lea	esi, DWORD PTR [esi+ecx*8+8]
	fld	QWORD PTR [eax]
	inc	edx
	fstp	QWORD PTR [esi]
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	cmp	edx, edi
	jl	SHORT $LC81@mat_inv_sy
$LN206@mat_inv_sy:

; 1114 :             for ( j = irow+1 ; j < n ; j++ )

	lea	esi, DWORD PTR [edi+1]
	cmp	esi, DWORD PTR _n$GSCopy$[ebp]
	jge	$LN275@mat_inv_sy
	mov	edx, DWORD PTR _n$GSCopy$[ebp]
	mov	eax, edx
	sub	eax, esi
	cmp	eax, 4
	jl	SHORT $LC210@mat_inv_sy

; 1115 :               SWAP(a[j][i+1],a[j][irow]);

	sub	edx, esi
	sub	edx, 4
	shr	edx, 2
	inc	edx
	lea	eax, DWORD PTR [ebx+esi*4+8]
	mov	DWORD PTR tv910[ebp], edx
	lea	esi, DWORD PTR [esi+edx*4]
$LN211@mat_inv_sy:
	mov	edx, DWORD PTR [eax-8]
	fld	QWORD PTR [edx+ecx*8+8]
	add	eax, 16					; 00000010H
	dec	DWORD PTR tv910[ebp]
	fld	QWORD PTR [edx+edi*8]
	fstp	QWORD PTR [edx+ecx*8+8]
	fstp	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR [eax-20]
	fld	QWORD PTR [edx+ecx*8+8]
	fld	QWORD PTR [edx+edi*8]
	fstp	QWORD PTR [edx+ecx*8+8]
	fstp	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR [eax-16]
	fld	QWORD PTR [edx+ecx*8+8]
	fld	QWORD PTR [edx+edi*8]
	fstp	QWORD PTR [edx+ecx*8+8]
	fstp	QWORD PTR [edx+edi*8]
	mov	edx, DWORD PTR [eax-12]
	fld	QWORD PTR [edx+ecx*8+8]
	fld	QWORD PTR [edx+edi*8]
	fstp	QWORD PTR [edx+ecx*8+8]
	fstp	QWORD PTR [edx+edi*8]
	jne	SHORT $LN211@mat_inv_sy
	mov	edx, DWORD PTR _n$GSCopy$[ebp]
$LC210@mat_inv_sy:

; 1114 :             for ( j = irow+1 ; j < n ; j++ )

	cmp	esi, edx
	jge	SHORT $LN275@mat_inv_sy
	mov	edx, DWORD PTR _n$GSCopy$[ebp]
$LC78@mat_inv_sy:

; 1115 :               SWAP(a[j][i+1],a[j][irow]);

	mov	eax, DWORD PTR [ebx+esi*4]
	fld	QWORD PTR [eax+ecx*8+8]
	inc	esi
	fld	QWORD PTR [eax+edi*8]
	fstp	QWORD PTR [eax+ecx*8+8]
	fstp	QWORD PTR [eax+edi*8]
	cmp	esi, edx
	jl	SHORT $LC78@mat_inv_sy
$LN275@mat_inv_sy:

; 1139 :     { REAL t;
; 1140 :       REAL det = a[i][i]*a[i+1][i+1] - a[i+1][i]*a[i+1][i];

	mov	eax, DWORD PTR [ebx+ecx*4+4]
	fld	QWORD PTR [eax+ecx*8]
	mov	edx, DWORD PTR [ebx+ecx*4]
	fld	QWORD PTR [eax+ecx*8+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	fmul	QWORD PTR [edx+ecx*8]
	mov	DWORD PTR tv7311[ebp], edx
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fsubrp	ST(1), ST(0)

; 1141 :       if ( det == 0.0 ) 

	fld	ST(0)
	fld	ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN445@mat_inv_sy

; 1144 :       }
; 1145 :       t = a[i][i];

	fld	QWORD PTR [edx+ecx*8]

; 1146 :       a[i][i] = a[i+1][i+1]/det;

	mov	eax, DWORD PTR [ebx+ecx*4+4]
	fld	QWORD PTR [eax+ecx*8+8]
	lea	edx, DWORD PTR [edx+ecx*8]
	lea	eax, DWORD PTR [eax+ecx*8]
	fdiv	ST(0), ST(2)
	fstp	QWORD PTR [edx]

; 1147 :       a[i+1][i+1] = t/det; 

	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax+8]

; 1148 :       a[i][i+1] = a[i+1][i] /= -det;

	fld	QWORD PTR [eax]
	fdiv	ST(0), ST(1)
	fchs
	fst	QWORD PTR [eax]
	fstp	QWORD PTR [edx+8]

; 1149 :       for ( j = i+2 ; j < n ; j++ )

	lea	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _n$GSCopy$[ebp]
	jge	$LN276@mat_inv_sy
	mov	eax, DWORD PTR [ebx+ecx*4+4]

; 1248 :   }
; 1249 :   return negs;

	lea	eax, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR tv7857[ebp], eax
	mov	eax, 4
	sub	eax, edx
	mov	DWORD PTR tv12729[ebp], eax
$LN64@mat_inv_sy:

; 1150 :       {
; 1151 :         t = a[i][i]*a[j][i] + a[i+1][i]*a[j][i+1];

	mov	esi, DWORD PTR tv7311[ebp]
	fld	QWORD PTR [esi+ecx*8]
	mov	eax, DWORD PTR [ebx+edx*4]
	fmul	QWORD PTR [eax+ecx*8]
	mov	esi, DWORD PTR tv7857[ebp]
	fld	QWORD PTR [eax+ecx*8+8]
	lea	eax, DWORD PTR [eax+ecx*8]
	fmul	QWORD PTR [esi]
	faddp	ST(1), ST(0)

; 1152 :         a[j][i+1] = a[i+1][i]*a[j][i] + a[i+1][i+1]*a[j][i+1];

	fld	QWORD PTR [esi+8]
	fmul	QWORD PTR [eax+8]
	fld	QWORD PTR [eax]
	fmul	QWORD PTR [esi]

; 1153 :         a[j][i] = t;
; 1154 :         for ( k = i+2 ; k <= j ; k++ )

	lea	esi, DWORD PTR [ecx+2]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax+8]
	fstp	QWORD PTR [eax]
	cmp	esi, edx
	jg	$LN63@mat_inv_sy
	mov	eax, DWORD PTR tv12729[ebp]
	lea	eax, DWORD PTR [eax+edx-3]
	cmp	eax, 4
	jl	$LN252@mat_inv_sy
	mov	eax, DWORD PTR [ebx+ecx*4+4]
	mov	edi, DWORD PTR [ebx+edx*4]
	lea	eax, DWORD PTR [eax+esi*8]
	mov	DWORD PTR tv12038[ebp], eax
	lea	eax, DWORD PTR [ebx+esi*4+8]
	mov	ebx, DWORD PTR tv7311[ebp]
	mov	DWORD PTR tv7882[ebp], edi
	mov	DWORD PTR tv12196[ebp], eax
	lea	eax, DWORD PTR [ebx+esi*8+16]

; 1156 :           a[k][j] = a[j][k];

	sub	ebx, edi
	mov	DWORD PTR tv12200[ebp], eax
	lea	eax, DWORD PTR [edi+esi*8+8]
	mov	edi, DWORD PTR _a$GSCopy$[ebp]
	mov	edi, DWORD PTR [edi+ecx*4+4]
	sub	edi, DWORD PTR tv7311[ebp]
	mov	DWORD PTR tv12538[ebp], ebx
	mov	DWORD PTR tv12293[ebp], edi
	mov	edi, edx
	sub	edi, esi
	sub	edi, 3
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv1201[ebp], edi
	lea	esi, DWORD PTR [esi+edi*4]
	mov	edi, DWORD PTR tv7882[ebp]
$LN251@mat_inv_sy:

; 1155 :         { a[j][k] -= a[j][i]*a[i][k] + a[j][i+1]*a[i+1][k];

	mov	ebx, DWORD PTR tv12200[ebp]
	fld	QWORD PTR [ebx-16]
	mov	ebx, DWORD PTR tv12038[ebp]
	fmul	QWORD PTR [edi+ecx*8]
	fld	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv12293[ebp]
	fmul	QWORD PTR [edi+ecx*8+8]

; 1156 :           a[k][j] = a[j][k];

	mov	edi, DWORD PTR tv12196[ebp]
	mov	edi, DWORD PTR [edi-8]
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR [eax-8]
	fst	QWORD PTR [eax-8]
	fstp	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR tv12538[ebp]
	add	edi, eax
	fld	QWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR tv7882[ebp]
	fmul	QWORD PTR [ebx+ecx*8+8]
	add	eax, 32					; 00000020H
	fld	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR tv12200[ebp]
	fmul	QWORD PTR [edi]
	mov	edi, DWORD PTR tv12196[ebp]
	mov	edi, DWORD PTR [edi-4]
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR [eax-32]
	fst	QWORD PTR [eax-32]
	fstp	QWORD PTR [edi+edx*8]
	mov	edi, DWORD PTR tv12293[ebp]
	fld	QWORD PTR [ebx+edi]
	mov	edi, DWORD PTR tv7882[ebp]
	fmul	QWORD PTR [edi+ecx*8+8]
	fld	QWORD PTR [edi+ecx*8]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv12196[ebp]
	mov	ebx, DWORD PTR [ebx]
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR [eax-24]
	fst	QWORD PTR [eax-24]
	fstp	QWORD PTR [ebx+edx*8]
	mov	ebx, DWORD PTR tv12038[ebp]
	fld	QWORD PTR [ebx+24]
	mov	ebx, DWORD PTR tv12200[ebp]
	fmul	QWORD PTR [edi+ecx*8+8]
	add	DWORD PTR tv12038[ebp], 32		; 00000020H
	fld	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR tv12196[ebp]
	fmul	QWORD PTR [edi+ecx*8]
	mov	ebx, DWORD PTR [ebx+4]
	add	DWORD PTR tv12200[ebp], 32		; 00000020H
	add	DWORD PTR tv12196[ebp], 16		; 00000010H
	dec	DWORD PTR tv1201[ebp]
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR [eax-16]
	fst	QWORD PTR [eax-16]
	fstp	QWORD PTR [ebx+edx*8]
	jne	$LN251@mat_inv_sy

; 1153 :         a[j][i] = t;
; 1154 :         for ( k = i+2 ; k <= j ; k++ )

	mov	ebx, DWORD PTR _a$GSCopy$[ebp]
	mov	edi, DWORD PTR _irow$[ebp]
$LN252@mat_inv_sy:
	cmp	esi, edx
	jg	$LN63@mat_inv_sy
	mov	eax, DWORD PTR [ebx+edx*4]
	mov	ebx, DWORD PTR [ebx+ecx*4+4]
	mov	DWORD PTR tv7953[ebp], eax
	lea	eax, DWORD PTR [eax+esi*8]
	mov	DWORD PTR tv12469[ebp], eax
	mov	eax, DWORD PTR tv7311[ebp]
	sub	ebx, eax
	sub	eax, DWORD PTR tv7953[ebp]
	mov	DWORD PTR tv12293[ebp], ebx
	mov	DWORD PTR tv12541[ebp], eax
	jmp	$LC61@mat_inv_sy
$LN334@mat_inv_sy:

; 1077 :     { 
; 1078 :       if ( fabs(a[i][i]) > BKalpha*lambda  )

	fstp	ST(3)
	fstp	ST(1)
	fstp	ST(1)
	jmp	SHORT $LN301@mat_inv_sy
$LN362@mat_inv_sy:

; 1085 :         if ( sigma*fabs(a[i][i]) >= BKalpha*lambda*lambda )

	fstp	ST(0)
$LN301@mat_inv_sy:
	fstp	ST(0)
$LN274@mat_inv_sy:

; 1116 :           }
; 1117 :         }
; 1118 :       }
; 1119 :     }
; 1120 :    
; 1121 :     /* now pivot step */
; 1122 :     if ( s == PIV1 )
; 1123 :     { if ( a[i][i] == 0.0 ) 

	mov	edx, DWORD PTR [ebx+ecx*4]
	fld	QWORD PTR [edx+ecx*8]
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN474@mat_inv_sy

; 1124 :       { negs = -1;
; 1125 :         goto mat_inv_sym_exit; 
; 1126 :       }
; 1127 :       piv = 1/a[i][i]; 

	fld1
	lea	eax, DWORD PTR [edx+ecx*8]
	fdiv	QWORD PTR [eax]

; 1128 :       a[i][i] = piv;

	fst	QWORD PTR [eax]

; 1129 :       for ( j = i+1 ; j < n ; j++ )

	mov	eax, DWORD PTR tv7305[ebp]
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _n$GSCopy$[ebp]
	jge	$LN71@mat_inv_sy
	mov	esi, 2
	sub	esi, ecx
	mov	DWORD PTR tv11840[ebp], esi
	jmp	SHORT $LN73@mat_inv_sy
$LN296@mat_inv_sy:
	mov	esi, DWORD PTR tv11840[ebp]
$LN73@mat_inv_sy:

; 1130 :       { for ( k = i+1 ; k < j ; k++ )

	mov	edx, DWORD PTR tv7305[ebp]
	cmp	edx, eax
	jge	$LN255@mat_inv_sy
	lea	esi, DWORD PTR [esi+eax-3]
	cmp	esi, 4
	jl	$LN254@mat_inv_sy

; 1131 :           a[j][k] -= a[j][i]*a[k][i];

	mov	eax, DWORD PTR [ebx+eax*4]
	lea	esi, DWORD PTR [ebx+edx*4+8]
	mov	DWORD PTR tv11540[ebp], esi
	mov	esi, DWORD PTR _j$[ebp]
	sub	esi, edx
	sub	esi, 4
	shr	esi, 2
	inc	esi
	mov	DWORD PTR tv7737[ebp], eax
	lea	eax, DWORD PTR [eax+edx*8+16]
	mov	DWORD PTR tv303[ebp], esi
	lea	edx, DWORD PTR [edx+esi*4]
$LN253@mat_inv_sy:
	mov	esi, DWORD PTR tv11540[ebp]
	mov	esi, DWORD PTR [esi-8]
	fld	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR tv7737[ebp]
	fmul	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR tv11540[ebp]
	mov	esi, DWORD PTR [esi-4]
	add	eax, 32					; 00000020H
	fsubr	QWORD PTR [eax-48]
	fstp	QWORD PTR [eax-48]
	fld	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR tv7737[ebp]
	fmul	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR tv11540[ebp]
	mov	esi, DWORD PTR [esi]
	fsubr	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR tv7737[ebp]
	fmul	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR tv11540[ebp]
	mov	esi, DWORD PTR [esi+4]
	add	DWORD PTR tv11540[ebp], 16		; 00000010H
	dec	DWORD PTR tv303[ebp]
	fsubr	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR tv7737[ebp]
	fmul	QWORD PTR [esi+ecx*8]
	fsubr	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN253@mat_inv_sy
	mov	eax, DWORD PTR _j$[ebp]
$LN254@mat_inv_sy:

; 1130 :       { for ( k = i+1 ; k < j ; k++ )

	cmp	edx, eax
	jge	SHORT $LN255@mat_inv_sy
	mov	esi, DWORD PTR [ebx+eax*4]
	lea	esi, DWORD PTR [esi+edx*8]
	mov	DWORD PTR tv11694[ebp], esi
$LC70@mat_inv_sy:

; 1131 :           a[j][k] -= a[j][i]*a[k][i];

	mov	esi, DWORD PTR [ebx+edx*4]
	fld	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR [ebx+eax*4]
	fmul	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR tv11694[ebp]
	inc	edx
	add	esi, 8
	fsubr	QWORD PTR [esi-8]
	mov	DWORD PTR tv11694[ebp], esi
	fstp	QWORD PTR [esi-8]
	cmp	edx, eax
	jl	SHORT $LC70@mat_inv_sy
$LN255@mat_inv_sy:

; 1132 :         a[j][j] -= a[j][i]*a[j][i]*piv;

	mov	edx, DWORD PTR [ebx+eax*4]
	fld	QWORD PTR [edx+ecx*8]
	inc	eax
	fmul	ST(0), ST(0)
	mov	DWORD PTR _j$[ebp], eax
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [edx+eax*8-8]
	fstp	QWORD PTR [edx+eax*8-8]

; 1133 :         a[j][i] *= piv;

	fld	QWORD PTR [edx+ecx*8]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [edx+ecx*8]
	cmp	eax, DWORD PTR _n$GSCopy$[ebp]
	jl	$LN296@mat_inv_sy
$LN71@mat_inv_sy:

; 1134 :       }
; 1135 :       spiv[i] = PIV1;

	mov	edx, DWORD PTR _spiv$[ebp]

; 1136 :       if ( piv < 0.0 ) negs++;

	fcomp	ST(1)
	mov	DWORD PTR [edx+ecx*4], 1
	fnstsw	ax
	test	ah, 5
	jp	$LN111@mat_inv_sy
	inc	DWORD PTR _negs$[ebp]

; 1137 :     }
; 1138 :     else /* s == 2, so 2 x 2 pivot */

	jmp	$LN111@mat_inv_sy
$LN250@mat_inv_sy:

; 1153 :         a[j][i] = t;
; 1154 :         for ( k = i+2 ; k <= j ; k++ )

	mov	eax, DWORD PTR tv12541[ebp]
$LC61@mat_inv_sy:

; 1155 :         { a[j][k] -= a[j][i]*a[i][k] + a[j][i+1]*a[i+1][k];

	add	eax, DWORD PTR tv12469[ebp]
	mov	ebx, DWORD PTR tv12293[ebp]
	fld	QWORD PTR [eax+ebx]
	mov	ebx, DWORD PTR tv7953[ebp]
	fmul	QWORD PTR [ebx+ecx*8+8]
	inc	esi
	fld	QWORD PTR [eax]
	mov	eax, DWORD PTR tv12469[ebp]
	fmul	QWORD PTR [ebx+ecx*8]

; 1156 :           a[k][j] = a[j][k];

	mov	ebx, DWORD PTR _a$GSCopy$[ebp]
	add	DWORD PTR tv12469[ebp], 8
	faddp	ST(1), ST(0)
	fsubr	QWORD PTR [eax]
	fst	QWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+esi*4-4]
	fstp	QWORD PTR [eax+edx*8]
	cmp	esi, edx
	jle	SHORT $LN250@mat_inv_sy
$LN63@mat_inv_sy:

; 1149 :       for ( j = i+2 ; j < n ; j++ )

	inc	edx
	cmp	edx, DWORD PTR _n$GSCopy$[ebp]
	jl	$LN64@mat_inv_sy
$LN276@mat_inv_sy:

; 1157 :         }
; 1158 :       }
; 1159 :       spiv[i] = PIV2;

	mov	eax, DWORD PTR _spiv$[ebp]

; 1160 :       spiv[i+1] = PIV3;
; 1161 :       if ( det < 0.0 ) negs++;

	fcomp	ST(1)
	mov	DWORD PTR [eax+ecx*4], 2
	mov	DWORD PTR [eax+ecx*4+4], 3
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN58@mat_inv_sy
	inc	DWORD PTR _negs$[ebp]
	jmp	SHORT $LN56@mat_inv_sy
$LN58@mat_inv_sy:

; 1162 :       else if ( a[i][i] < 0.0 ) negs += 2;

	mov	edx, DWORD PTR [ebx+ecx*4]
	fcom	QWORD PTR [edx+ecx*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN56@mat_inv_sy
	add	DWORD PTR _negs$[ebp], 2
$LN56@mat_inv_sy:

; 1163 :       i++; /* extra increment */

	mov	ecx, DWORD PTR tv7305[ebp]
$LN111@mat_inv_sy:

; 1063 : 
; 1064 :   /* First, do LDL with Bunch-Kaufman pivoting */
; 1065 :   for ( i = 0 ; i < n ; i++ )

	inc	ecx
	cmp	ecx, DWORD PTR _n$GSCopy$[ebp]
	jl	$LN112@mat_inv_sy

; 1141 :       if ( det == 0.0 ) 

	mov	esi, DWORD PTR _n$GSCopy$[ebp]
$LN110@mat_inv_sy:

; 1164 :     }
; 1165 : 
; 1166 :   }
; 1167 : 
; 1168 :   /* convert from LDL to inverse */
; 1169 :   /* invert L into upper triangle U */
; 1170 :   for ( i = 1 ; i < n ; i++ )

	cmp	esi, 1
	jle	$LN496@mat_inv_sy
	mov	edx, DWORD PTR _spiv$[ebp]
	lea	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv13943[ebp], eax
	mov	eax, ebx
	sub	eax, edx
	mov	DWORD PTR tv13870[ebp], 0
	mov	ecx, 8
	mov	DWORD PTR tv13983[ebp], eax
$LN55@mat_inv_sy:

; 1171 :   { for ( j = 0 ; j < i ; j++ )

	mov	eax, DWORD PTR tv13870[ebp]
	inc	eax
	mov	DWORD PTR tv13990[ebp], eax
	test	eax, eax
	jle	$LN54@mat_inv_sy
	mov	eax, DWORD PTR tv13870[ebp]
	mov	DWORD PTR tv13697[ebp], eax
	mov	eax, DWORD PTR _spiv$[ebp]
	mov	edx, 1
	mov	esi, ebx
	add	eax, 12					; 0000000cH
	mov	DWORD PTR tv13506[ebp], edx
	mov	DWORD PTR tv13625[ebp], esi
	mov	DWORD PTR tv13662[ebp], 24		; 00000018H
	mov	DWORD PTR tv13775[ebp], eax
$LN290@mat_inv_sy:

; 1172 :     { if ( j == i-1 && spiv[i]==PIV3 )

	lea	eax, DWORD PTR [edx-1]
	cmp	eax, DWORD PTR tv13870[ebp]
	jne	SHORT $LN291@mat_inv_sy
	mov	eax, DWORD PTR tv13943[ebp]
	cmp	DWORD PTR [eax], 3
	jne	SHORT $LN291@mat_inv_sy

; 1173 :       { a[j][i] = 0 ;

	mov	eax, DWORD PTR [esi]
	fst	QWORD PTR [ecx+eax]

; 1174 :         continue;

	jmp	$LN51@mat_inv_sy
$LN445@mat_inv_sy:

; 1141 :       if ( det == 0.0 ) 

	fstp	ST(0)
$LN474@mat_inv_sy:

; 1142 :       { negs = -1;
; 1143 :         goto mat_inv_sym_exit; 

	mov	edx, DWORD PTR _ipiv$[ebp]
	fstp	ST(0)
	mov	DWORD PTR _negs$[ebp], -1
	jmp	$mat_inv_sym_exit$89914
$LN291@mat_inv_sy:

; 1175 :       }
; 1176 :       a[j][i] = -a[i][j];

	mov	eax, DWORD PTR tv13983[ebp]
	mov	edi, DWORD PTR tv13943[ebp]
	mov	edi, DWORD PTR [eax+edi]
	mov	eax, DWORD PTR tv13662[ebp]
	fld	QWORD PTR [edi+eax-24]
	mov	eax, DWORD PTR [esi]
	fchs
	mov	DWORD PTR tv13986[ebp], edi
	fstp	QWORD PTR [ecx+eax]
	cmp	edx, DWORD PTR tv13990[ebp]
	jge	$LN279@mat_inv_sy

; 1177 :       for ( k = j+1 ; k < i ; k++ )

	cmp	DWORD PTR tv13697[ebp], 4
	jl	$LN278@mat_inv_sy

; 1178 :       { if ( !( ((k==i-1) && (spiv[i]==PIV3)) || ((k==j+1) && (spiv[k]==PIV3))) )

	mov	eax, DWORD PTR tv13506[ebp]
	mov	esi, DWORD PTR tv13775[ebp]
	add	eax, 2
	mov	DWORD PTR tv12762[ebp], eax
	mov	eax, DWORD PTR tv13662[ebp]
	mov	DWORD PTR tv12905[ebp], eax
	add	eax, edi
	neg	edi
	mov	DWORD PTR tv13030[ebp], esi
	mov	DWORD PTR tv14008[ebp], edi
	jmp	SHORT $LN232@mat_inv_sy
$LN264@mat_inv_sy:
	mov	edi, DWORD PTR tv14008[ebp]

; 1177 :       for ( k = j+1 ; k < i ; k++ )

$LN232@mat_inv_sy:

; 1178 :       { if ( !( ((k==i-1) && (spiv[i]==PIV3)) || ((k==j+1) && (spiv[k]==PIV3))) )

	cmp	edx, DWORD PTR tv13870[ebp]
	jne	SHORT $LN277@mat_inv_sy
	mov	esi, DWORD PTR tv13943[ebp]
	cmp	DWORD PTR [esi], 3
	je	SHORT $LN284@mat_inv_sy
$LN277@mat_inv_sy:
	cmp	edx, DWORD PTR tv13506[ebp]
	jne	SHORT $LN221@mat_inv_sy
	mov	esi, DWORD PTR tv13030[ebp]
	cmp	DWORD PTR [esi-8], 3
	je	SHORT $LN284@mat_inv_sy
$LN221@mat_inv_sy:

; 1179 :           a[j][i] -= a[i][k]*a[j][k];

	mov	esi, DWORD PTR tv13625[ebp]
	mov	esi, DWORD PTR [esi]
	lea	edi, DWORD PTR [eax+edi-16]
	fld	QWORD PTR [edi+esi]
	fmul	QWORD PTR [eax-16]
	fsubr	QWORD PTR [ecx+esi]
	fstp	QWORD PTR [ecx+esi]
$LN284@mat_inv_sy:

; 1178 :       { if ( !( ((k==i-1) && (spiv[i]==PIV3)) || ((k==j+1) && (spiv[k]==PIV3))) )

	mov	esi, DWORD PTR tv12762[ebp]
	dec	esi
	cmp	esi, DWORD PTR tv13870[ebp]
	jne	SHORT $LN223@mat_inv_sy
	mov	edi, DWORD PTR tv13943[ebp]
	cmp	DWORD PTR [edi], 3
	je	SHORT $LN265@mat_inv_sy
$LN223@mat_inv_sy:
	cmp	esi, DWORD PTR tv13506[ebp]
	jne	SHORT $LN224@mat_inv_sy
	mov	esi, DWORD PTR tv13030[ebp]
	cmp	DWORD PTR [esi-4], 3
	je	SHORT $LN265@mat_inv_sy
$LN224@mat_inv_sy:

; 1179 :           a[j][i] -= a[i][k]*a[j][k];

	mov	esi, DWORD PTR tv13625[ebp]
	mov	esi, DWORD PTR [esi]
	mov	edi, DWORD PTR tv14008[ebp]
	lea	edi, DWORD PTR [eax+edi-16]
	fld	QWORD PTR [edi+esi+8]
	fmul	QWORD PTR [eax-8]
	fsubr	QWORD PTR [ecx+esi]
	fstp	QWORD PTR [ecx+esi]
$LN265@mat_inv_sy:

; 1178 :       { if ( !( ((k==i-1) && (spiv[i]==PIV3)) || ((k==j+1) && (spiv[k]==PIV3))) )

	mov	esi, DWORD PTR tv12762[ebp]
	cmp	esi, DWORD PTR tv13870[ebp]
	jne	SHORT $LN226@mat_inv_sy
	mov	edi, DWORD PTR tv13943[ebp]
	cmp	DWORD PTR [edi], 3
	je	SHORT $LN266@mat_inv_sy
$LN226@mat_inv_sy:
	cmp	esi, DWORD PTR tv13506[ebp]
	jne	SHORT $LN227@mat_inv_sy
	mov	edi, DWORD PTR tv13030[ebp]
	cmp	DWORD PTR [edi], 3
	je	SHORT $LN266@mat_inv_sy
$LN227@mat_inv_sy:

; 1179 :           a[j][i] -= a[i][k]*a[j][k];

	mov	esi, DWORD PTR tv13625[ebp]
	mov	esi, DWORD PTR [esi]
	mov	edi, DWORD PTR tv12905[ebp]
	fld	QWORD PTR [edi+esi]
	fmul	QWORD PTR [eax]
	fsubr	QWORD PTR [ecx+esi]
	fstp	QWORD PTR [ecx+esi]
	mov	esi, DWORD PTR tv12762[ebp]
$LN266@mat_inv_sy:

; 1178 :       { if ( !( ((k==i-1) && (spiv[i]==PIV3)) || ((k==j+1) && (spiv[k]==PIV3))) )

	inc	esi
	cmp	esi, DWORD PTR tv13870[ebp]
	jne	SHORT $LN229@mat_inv_sy
	mov	edi, DWORD PTR tv13943[ebp]
	cmp	DWORD PTR [edi], 3
	je	SHORT $LN267@mat_inv_sy
$LN229@mat_inv_sy:
	cmp	esi, DWORD PTR tv13506[ebp]
	jne	SHORT $LN230@mat_inv_sy
	mov	esi, DWORD PTR tv13030[ebp]
	cmp	DWORD PTR [esi+4], 3
	je	SHORT $LN267@mat_inv_sy
$LN230@mat_inv_sy:

; 1179 :           a[j][i] -= a[i][k]*a[j][k];

	mov	esi, DWORD PTR tv13625[ebp]
	mov	esi, DWORD PTR [esi]
	mov	edi, DWORD PTR tv14008[ebp]
	lea	edi, DWORD PTR [eax+edi+8]
	fld	QWORD PTR [edi+esi]
	fmul	QWORD PTR [eax+8]
	fsubr	QWORD PTR [ecx+esi]
	fstp	QWORD PTR [ecx+esi]
$LN267@mat_inv_sy:

; 1178 :       { if ( !( ((k==i-1) && (spiv[i]==PIV3)) || ((k==j+1) && (spiv[k]==PIV3))) )

	mov	esi, DWORD PTR tv13870[ebp]
	add	DWORD PTR tv13030[ebp], 16		; 00000010H
	add	DWORD PTR tv12905[ebp], 32		; 00000020H
	add	DWORD PTR tv12762[ebp], 4
	add	edx, 4
	add	esi, -2					; fffffffeH
	add	eax, 32					; 00000020H
	cmp	edx, esi
	jl	$LN264@mat_inv_sy
	mov	edi, DWORD PTR tv13986[ebp]
$LN278@mat_inv_sy:
	mov	esi, DWORD PTR tv13625[ebp]
	cmp	edx, DWORD PTR tv13990[ebp]
	jge	SHORT $LN287@mat_inv_sy
$LC48@mat_inv_sy:
	cmp	edx, DWORD PTR tv13870[ebp]
	jne	SHORT $LN44@mat_inv_sy
	mov	eax, DWORD PTR tv13943[ebp]
	cmp	DWORD PTR [eax], 3
	je	SHORT $LN47@mat_inv_sy
$LN44@mat_inv_sy:
	cmp	edx, DWORD PTR tv13506[ebp]
	jne	SHORT $LN43@mat_inv_sy
	mov	eax, DWORD PTR _spiv$[ebp]
	cmp	DWORD PTR [eax+edx*4], 3
	je	SHORT $LN47@mat_inv_sy
$LN43@mat_inv_sy:

; 1179 :           a[j][i] -= a[i][k]*a[j][k];

	mov	eax, DWORD PTR [esi]
	fld	QWORD PTR [edi+edx*8]
	fmul	QWORD PTR [eax+edx*8]
	fsubr	QWORD PTR [ecx+eax]
	fstp	QWORD PTR [ecx+eax]
$LN47@mat_inv_sy:

; 1177 :       for ( k = j+1 ; k < i ; k++ )

	inc	edx
	cmp	edx, DWORD PTR tv13990[ebp]
	jl	SHORT $LC48@mat_inv_sy
$LN287@mat_inv_sy:
	mov	edx, DWORD PTR tv13506[ebp]
$LN51@mat_inv_sy:

; 1171 :   { for ( j = 0 ; j < i ; j++ )

	dec	DWORD PTR tv13697[ebp]
	add	DWORD PTR tv13662[ebp], 8
	add	DWORD PTR tv13775[ebp], 4
	inc	edx
	add	esi, 4
	lea	eax, DWORD PTR [edx-1]
	mov	DWORD PTR tv13506[ebp], edx
	mov	DWORD PTR tv13625[ebp], esi
	cmp	eax, DWORD PTR tv13990[ebp]
	jl	$LN290@mat_inv_sy
$LN54@mat_inv_sy:

; 1164 :     }
; 1165 : 
; 1166 :   }
; 1167 : 
; 1168 :   /* convert from LDL to inverse */
; 1169 :   /* invert L into upper triangle U */
; 1170 :   for ( i = 1 ; i < n ; i++ )

	mov	eax, DWORD PTR tv13990[ebp]
	add	DWORD PTR tv13943[ebp], 4
	mov	DWORD PTR tv13870[ebp], eax
	inc	eax
	add	ecx, 8
	cmp	eax, DWORD PTR _n$GSCopy$[ebp]
	jl	$LN55@mat_inv_sy
	mov	esi, DWORD PTR _n$GSCopy$[ebp]
$LN496@mat_inv_sy:

; 1180 :       }
; 1181 :     }
; 1182 :   }
; 1183 :   /* multiply by already inverted diagonal into lower */
; 1184 :   for ( j = 0 ; j < n ; j++ )

	xor	eax, eax
	fstp	ST(0)
	test	esi, esi
	jle	$LN40@mat_inv_sy
	mov	esi, -4					; fffffffcH
	mov	DWORD PTR tv15877[ebp], esi
	npad	5
$LL42@mat_inv_sy:

; 1185 :   { if ( spiv[j] == PIV1 )

	mov	ecx, DWORD PTR _spiv$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 1
	jne	$LN39@mat_inv_sy

; 1186 :     { for ( i = 0 ; i < j ; i++ )

	xor	ecx, ecx
	cmp	eax, 4
	jl	SHORT $LN289@mat_inv_sy
	mov	edi, DWORD PTR [ebx+eax*4]
	shr	esi, 2
	inc	esi
	mov	DWORD PTR tv14407[ebp], esi
	add	esi, esi
	add	esi, esi
	lea	edx, DWORD PTR [edi+16]
	lea	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR _i$[ebp], esi
	npad	2
$LL235@mat_inv_sy:

; 1187 :         a[j][i] = a[i][j]*a[j][j];

	mov	esi, DWORD PTR [ecx-8]
	fld	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR [ecx-4]
	fmul	QWORD PTR [edi+eax*8]
	add	ecx, 16					; 00000010H
	add	edx, 32					; 00000020H
	dec	DWORD PTR tv14407[ebp]
	fstp	QWORD PTR [edx-48]
	fld	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR [ecx-16]
	fmul	QWORD PTR [edi+eax*8]
	fstp	QWORD PTR [edx-40]
	fld	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR [ecx-12]
	fmul	QWORD PTR [edi+eax*8]
	fstp	QWORD PTR [edx-32]
	fld	QWORD PTR [esi+eax*8]
	fmul	QWORD PTR [edi+eax*8]
	fstp	QWORD PTR [edx-24]
	jne	SHORT $LL235@mat_inv_sy

; 1186 :     { for ( i = 0 ; i < j ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
$LN289@mat_inv_sy:
	cmp	ecx, eax
	jge	$LN41@mat_inv_sy
	mov	esi, DWORD PTR [ebx+eax*4]
	lea	edx, DWORD PTR [esi+ecx*8]
	npad	4
$LC38@mat_inv_sy:

; 1187 :         a[j][i] = a[i][j]*a[j][j];

	mov	edi, DWORD PTR [ebx+ecx*4]
	fld	QWORD PTR [edi+eax*8]
	inc	ecx
	fmul	QWORD PTR [esi+eax*8]
	add	edx, 8
	fstp	QWORD PTR [edx-8]
	cmp	ecx, eax
	jl	SHORT $LC38@mat_inv_sy

; 1188 :     }
; 1189 :     else  /* PIV2 */

	jmp	$LN41@mat_inv_sy
$LN279@mat_inv_sy:

; 1177 :       for ( k = j+1 ; k < i ; k++ )

	mov	esi, DWORD PTR tv13625[ebp]
	jmp	$LN51@mat_inv_sy
$LN39@mat_inv_sy:

; 1190 :     { for ( i = 0 ; i < j ; i++ )

	xor	edx, edx
	cmp	eax, 4
	jl	$LN261@mat_inv_sy
	mov	esi, DWORD PTR [ebx+eax*4]
	mov	ecx, DWORD PTR [ebx+eax*4+4]
	lea	edx, DWORD PTR [esi+24]

; 1192 :         a[j+1][i] = a[i][j]*a[j+1][j] + a[i][j+1]*a[j+1][j+1];

	sub	esi, ecx
	mov	DWORD PTR tv18545[ebp], esi
	mov	esi, DWORD PTR tv15877[ebp]
	shr	esi, 2
	inc	esi
	mov	DWORD PTR tv15330[ebp], esi
	add	esi, esi
	add	esi, esi
	mov	DWORD PTR tv14997[ebp], edx
	lea	edi, DWORD PTR [ebx+8]
	lea	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _i$[ebp], esi
	npad	8
$LL238@mat_inv_sy:

; 1191 :       { a[j][i] = a[i][j]*a[j][j] + a[i][j+1]*a[j+1][j];

	mov	esi, DWORD PTR [edi-8]
	fld	QWORD PTR [esi+eax*8+8]
	lea	esi, DWORD PTR [esi+eax*8]
	fmul	QWORD PTR [ecx+eax*8]
	mov	DWORD PTR tv15229[ebp], esi
	fld	QWORD PTR [esi]
	mov	esi, DWORD PTR [ebx+eax*4]
	fmul	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR tv14997[ebp]

; 1192 :         a[j+1][i] = a[i][j]*a[j+1][j] + a[i][j+1]*a[j+1][j+1];

	add	edi, 16					; 00000010H
	add	edx, 32					; 00000020H
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi-24]
	mov	esi, DWORD PTR tv15229[ebp]
	fld	QWORD PTR [esi+8]
	fmul	QWORD PTR [ecx+eax*8+8]
	fld	QWORD PTR [ecx+eax*8]
	fmul	QWORD PTR [esi]
	mov	esi, DWORD PTR [edi-20]
	lea	esi, DWORD PTR [esi+eax*8]
	mov	DWORD PTR tv15381[ebp], esi
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx-40]
	fld	QWORD PTR [esi+8]
	fmul	QWORD PTR [ecx+eax*8]
	fld	QWORD PTR [esi]
	mov	esi, DWORD PTR [ebx+eax*4]
	fmul	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR tv18545[ebp]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx+esi-32]
	mov	esi, DWORD PTR tv15381[ebp]
	fld	QWORD PTR [esi+8]
	fmul	QWORD PTR [ecx+eax*8+8]
	fld	QWORD PTR [ecx+eax*8]
	fmul	QWORD PTR [esi]
	mov	esi, DWORD PTR [edi-16]
	lea	esi, DWORD PTR [esi+eax*8]
	mov	DWORD PTR tv15113[ebp], esi
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx-32]
	fld	QWORD PTR [esi+8]
	fmul	QWORD PTR [ecx+eax*8]
	fld	QWORD PTR [esi]
	mov	esi, DWORD PTR [ebx+eax*4]
	fmul	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR tv14997[ebp]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi-8]
	mov	esi, DWORD PTR tv15113[ebp]
	fld	QWORD PTR [esi+8]
	fmul	QWORD PTR [ecx+eax*8+8]
	fld	QWORD PTR [ecx+eax*8]
	fmul	QWORD PTR [esi]
	mov	esi, DWORD PTR [edi-12]
	lea	esi, DWORD PTR [esi+eax*8]
	mov	DWORD PTR tv15411[ebp], esi
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx-24]
	fld	QWORD PTR [esi]
	mov	esi, DWORD PTR [ebx+eax*4]
	fmul	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR tv15411[ebp]
	fld	QWORD PTR [ecx+eax*8]
	fmul	QWORD PTR [esi+8]
	mov	esi, DWORD PTR tv14997[ebp]
	add	DWORD PTR tv14997[ebp], 32		; 00000020H
	dec	DWORD PTR tv15330[ebp]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi]
	mov	esi, DWORD PTR tv15411[ebp]
	fld	QWORD PTR [esi+8]
	fmul	QWORD PTR [ecx+eax*8+8]
	fld	QWORD PTR [esi]
	fmul	QWORD PTR [ecx+eax*8]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx-16]
	jne	$LL238@mat_inv_sy

; 1190 :     { for ( i = 0 ; i < j ; i++ )

	mov	edx, DWORD PTR _i$[ebp]
$LN261@mat_inv_sy:
	cmp	edx, eax
	jge	SHORT $LN297@mat_inv_sy

; 1180 :       }
; 1181 :     }
; 1182 :   }
; 1183 :   /* multiply by already inverted diagonal into lower */
; 1184 :   for ( j = 0 ; j < n ; j++ )

	mov	esi, DWORD PTR [ebx+eax*4+4]
	mov	ecx, DWORD PTR [ebx+eax*4]
	lea	edi, DWORD PTR [esi+eax*8+8]
	mov	DWORD PTR tv18633[ebp], edi

; 1190 :     { for ( i = 0 ; i < j ; i++ )

	lea	edi, DWORD PTR [esi+edx*8]
	sub	ecx, esi
	mov	DWORD PTR tv15502[ebp], edi
	mov	DWORD PTR tv18640[ebp], ecx
	npad	2
$LC34@mat_inv_sy:

; 1191 :       { a[j][i] = a[i][j]*a[j][j] + a[i][j+1]*a[j+1][j];

	mov	ecx, DWORD PTR [ebx+edx*4]
	mov	edi, DWORD PTR [ebx+eax*4]
	fld	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR tv15502[ebp]
	fmul	QWORD PTR [ecx+eax*8]
	lea	ecx, DWORD PTR [ecx+eax*8]
	fld	QWORD PTR [esi+eax*8]
	mov	esi, DWORD PTR tv18640[ebp]
	fmul	QWORD PTR [ecx+8]
	inc	edx
	add	edi, 8
	mov	DWORD PTR tv15502[ebp], edi
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+edi-8]

; 1192 :         a[j+1][i] = a[i][j]*a[j+1][j] + a[i][j+1]*a[j+1][j+1];

	mov	esi, DWORD PTR tv18633[ebp]
	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR [esi]
	mov	esi, DWORD PTR [ebx+eax*4+4]
	fld	QWORD PTR [esi+eax*8]
	fmul	QWORD PTR [ecx]
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edi-8]
	cmp	edx, eax
	jl	SHORT $LC34@mat_inv_sy
$LN297@mat_inv_sy:

; 1193 :        }
; 1194 :       j++; /* extra increment */

	inc	eax
	inc	DWORD PTR tv15877[ebp]
$LN41@mat_inv_sy:

; 1180 :       }
; 1181 :     }
; 1182 :   }
; 1183 :   /* multiply by already inverted diagonal into lower */
; 1184 :   for ( j = 0 ; j < n ; j++ )

	mov	esi, DWORD PTR tv15877[ebp]
	inc	eax
	inc	esi
	mov	DWORD PTR tv15877[ebp], esi
	cmp	eax, DWORD PTR _n$GSCopy$[ebp]
	jl	$LL42@mat_inv_sy
$LN40@mat_inv_sy:

; 1195 :     }
; 1196 :   }
; 1197 :   /* multiply lower triangle and upper to get full inverse in lower */
; 1198 :  for ( i = 0 ; i < n ; i++ )

	xor	edx, edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _n$GSCopy$[ebp], edx
	jle	$LN29@mat_inv_sy
	npad	5
$LL31@mat_inv_sy:

; 1199 :   { 
; 1200 :     for ( j = 0 ; j <= i ; j++ )

	xor	ecx, ecx
	test	edx, edx
	js	$LN30@mat_inv_sy

; 1195 :     }
; 1196 :   }
; 1197 :   /* multiply lower triangle and upper to get full inverse in lower */
; 1198 :  for ( i = 0 ; i < n ; i++ )

	mov	edi, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR tv7311[ebp], edi

; 1201 :     { REAL sum;
; 1202 :       int first;
; 1203 :       if ( j == i )

	cmp	ecx, edx
$LN582@mat_inv_sy:
	jne	SHORT $LN25@mat_inv_sy

; 1204 :       { sum = a[i][i];
; 1205 :         if ( spiv[j] == PIV2 )

	mov	eax, DWORD PTR _spiv$[ebp]
	fld	QWORD PTR [edi+edx*8]
	cmp	DWORD PTR [eax+ecx*4], 2
	jne	SHORT $LN24@mat_inv_sy

; 1206 :           first = i+2;

	lea	esi, DWORD PTR [edx+2]

; 1207 :         else 

	jmp	SHORT $LN22@mat_inv_sy
$LN25@mat_inv_sy:

; 1208 :           first = i+1;
; 1209 :       }
; 1210 :       else 
; 1211 :       { sum = a[i][j];

	fld	QWORD PTR [edi+ecx*8]
$LN24@mat_inv_sy:

; 1212 :         first = i+1;

	lea	esi, DWORD PTR [edx+1]
$LN22@mat_inv_sy:

; 1213 :       }
; 1214 :        for ( k = first ; k < n ; k++ )

	mov	eax, esi
	cmp	esi, DWORD PTR _n$GSCopy$[ebp]
	jge	$LN239@mat_inv_sy
	mov	edi, DWORD PTR _n$GSCopy$[ebp]
	sub	edi, esi
	cmp	edi, 4
	jl	SHORT $LN262@mat_inv_sy

; 1215 :         sum += a[i][k]*a[k][j];

	mov	eax, DWORD PTR _n$GSCopy$[ebp]
	mov	edx, DWORD PTR tv7311[ebp]
	sub	eax, esi
	sub	eax, 4
	shr	eax, 2
	inc	eax
	lea	edi, DWORD PTR [ebx+esi*4+8]
	lea	edx, DWORD PTR [edx+esi*8+16]
	lea	esi, DWORD PTR [esi+eax*4]
	mov	DWORD PTR _k$[ebp], esi
$LN241@mat_inv_sy:
	mov	esi, DWORD PTR [edi-8]
	fld	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR [edi-4]
	fmul	QWORD PTR [edx-16]
	add	edx, 32					; 00000020H
	add	edi, 16					; 00000010H
	dec	eax
	faddp	ST(1), ST(0)
	fld	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR [edi-16]
	fmul	QWORD PTR [edx-40]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR [edi-12]
	fmul	QWORD PTR [edx-32]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [esi+ecx*8]
	fmul	QWORD PTR [edx-24]
	faddp	ST(1), ST(0)
	jne	SHORT $LN241@mat_inv_sy
	mov	eax, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
$LN262@mat_inv_sy:
	mov	edi, DWORD PTR _n$GSCopy$[ebp]
	cmp	eax, edi
	jge	SHORT $LN295@mat_inv_sy

; 1213 :       }
; 1214 :        for ( k = first ; k < n ; k++ )

	mov	edx, DWORD PTR tv7311[ebp]
	lea	esi, DWORD PTR [edx+eax*8]
$LC21@mat_inv_sy:

; 1215 :         sum += a[i][k]*a[k][j];

	mov	edx, DWORD PTR [ebx+eax*4]
	fld	QWORD PTR [edx+ecx*8]
	inc	eax
	fmul	QWORD PTR [esi]
	add	esi, 8
	faddp	ST(1), ST(0)
	cmp	eax, edi
	jl	SHORT $LC21@mat_inv_sy

; 1213 :       }
; 1214 :        for ( k = first ; k < n ; k++ )

	mov	edx, DWORD PTR _i$[ebp]
$LN295@mat_inv_sy:
	mov	edi, DWORD PTR tv7311[ebp]
$LN239@mat_inv_sy:

; 1216 :        a[i][j] = sum;

	fstp	QWORD PTR [edi+ecx*8]
	inc	ecx
	cmp	ecx, edx
	jle	$LN582@mat_inv_sy
$LN30@mat_inv_sy:

; 1195 :     }
; 1196 :   }
; 1197 :   /* multiply lower triangle and upper to get full inverse in lower */
; 1198 :  for ( i = 0 ; i < n ; i++ )

	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, DWORD PTR _n$GSCopy$[ebp]
	jl	$LL31@mat_inv_sy
$LN29@mat_inv_sy:

; 1217 :     }
; 1218 :   }
; 1219 :   /* unpermute lower to upper */
; 1220 :   /* first, off diagonal */
; 1221 :   for ( i = 0 ; i < n ; i++ )

	mov	edx, DWORD PTR _ipiv$[ebp]
	xor	esi, esi
	mov	DWORD PTR _i$[ebp], esi
	cmp	DWORD PTR _n$GSCopy$[ebp], esi
	jle	$LN16@mat_inv_sy
	mov	edi, ebx
	sub	edi, edx
	mov	ecx, edx
	mov	DWORD PTR tv17584[ebp], edi
	npad	7
$LL18@mat_inv_sy:

; 1222 :   { for ( j = 0 ; j < i ; j++ )

	xor	eax, eax
	cmp	esi, 4
	jl	SHORT $LN292@mat_inv_sy
	mov	eax, DWORD PTR [edi+ecx]
	add	esi, -4					; fffffffcH
	shr	esi, 2
	inc	esi
	mov	DWORD PTR tv17372[ebp], esi
	add	esi, esi
	add	edx, 8
	add	eax, 16					; 00000010H
	add	esi, esi
	mov	DWORD PTR _j$[ebp], esi
$LL244@mat_inv_sy:

; 1223 :       a[ipiv[j]][ipiv[i]] = a[i][j];

	mov	esi, DWORD PTR [edx-8]
	fld	QWORD PTR [eax-16]
	mov	esi, DWORD PTR [ebx+esi*4]
	mov	edi, DWORD PTR [ecx]
	fstp	QWORD PTR [esi+edi*8]
	mov	esi, DWORD PTR [edx-4]
	mov	esi, DWORD PTR [ebx+esi*4]
	fld	QWORD PTR [eax-8]
	mov	edi, DWORD PTR [ecx]
	fstp	QWORD PTR [esi+edi*8]
	mov	esi, DWORD PTR [edx]
	mov	edi, DWORD PTR [ecx]
	fld	QWORD PTR [eax]
	mov	esi, DWORD PTR [ebx+esi*4]
	fstp	QWORD PTR [esi+edi*8]
	mov	esi, DWORD PTR [edx+4]
	fld	QWORD PTR [eax+8]
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [ebx+esi*4]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [esi+edi*8]
	add	edx, 16					; 00000010H
	dec	DWORD PTR tv17372[ebp]
	jne	SHORT $LL244@mat_inv_sy

; 1222 :   { for ( j = 0 ; j < i ; j++ )

	mov	edx, DWORD PTR _ipiv$[ebp]
	mov	edi, DWORD PTR tv17584[ebp]
	mov	esi, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
$LN292@mat_inv_sy:
	cmp	eax, esi
	jge	SHORT $LN17@mat_inv_sy
	mov	esi, DWORD PTR [edi+ecx]
	lea	edi, DWORD PTR [esi+eax*8]
$LC15@mat_inv_sy:

; 1223 :       a[ipiv[j]][ipiv[i]] = a[i][j];

	mov	edx, DWORD PTR [edx+eax*4]
	fld	QWORD PTR [edi]
	mov	esi, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx+edx*4]
	fstp	QWORD PTR [edx+esi*8]
	mov	esi, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _ipiv$[ebp]
	inc	eax
	add	edi, 8
	cmp	eax, esi
	jl	SHORT $LC15@mat_inv_sy

; 1222 :   { for ( j = 0 ; j < i ; j++ )

	mov	edi, DWORD PTR tv17584[ebp]
$LN17@mat_inv_sy:

; 1217 :     }
; 1218 :   }
; 1219 :   /* unpermute lower to upper */
; 1220 :   /* first, off diagonal */
; 1221 :   for ( i = 0 ; i < n ; i++ )

	inc	esi
	add	ecx, 4
	mov	DWORD PTR _i$[ebp], esi
	cmp	esi, DWORD PTR _n$GSCopy$[ebp]
	jl	$LL18@mat_inv_sy
$LN16@mat_inv_sy:

; 1224 :   }
; 1225 :   /* and then the diagonal */
; 1226 :   for ( i = 0 ; i < n ; i++ )

	xor	edi, edi
	cmp	DWORD PTR _n$GSCopy$[ebp], edi
	jle	SHORT $LN10@mat_inv_sy
	mov	eax, ebx
	sub	eax, edx
	mov	ecx, edx
	mov	DWORD PTR tv17584[ebp], eax
$LL12@mat_inv_sy:

; 1227 :   { j = i;
; 1228 :     while ( ipiv[j] != j )

	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN11@mat_inv_sy
	npad	6
$LL9@mat_inv_sy:

; 1229 :     { int ti = ipiv[j];

	mov	eax, DWORD PTR [ecx]

; 1230 :       double t = a[ti][ti];

	mov	edx, DWORD PTR [ebx+eax*4]
	fld	QWORD PTR [edx+eax*8]
	lea	esi, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR tv17584[ebp]
	mov	edx, DWORD PTR [ecx+edx]

; 1231 :       a[ti][ti] = a[j][j];

	fld	QWORD PTR [edx+edi*8]
	lea	edx, DWORD PTR [edx+edi*8]
	fstp	QWORD PTR [esi]

; 1232 :       a[j][j] = t;

	fstp	QWORD PTR [edx]

; 1233 :       ipiv[j] = ipiv[ti]; 

	mov	edx, DWORD PTR _ipiv$[ebp]
	mov	esi, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], esi

; 1234 :       ipiv[ti] = ti;

	mov	DWORD PTR [edx+eax*4], eax
	cmp	DWORD PTR [ecx], edi
	jne	SHORT $LL9@mat_inv_sy
$LN11@mat_inv_sy:

; 1224 :   }
; 1225 :   /* and then the diagonal */
; 1226 :   for ( i = 0 ; i < n ; i++ )

	inc	edi
	add	ecx, 4
	cmp	edi, DWORD PTR _n$GSCopy$[ebp]
	jl	SHORT $LL12@mat_inv_sy
$LN10@mat_inv_sy:

; 1235 :     }
; 1236 :   }  
; 1237 : 
; 1238 :   /* symmetrize from upper to lower */
; 1239 :   for ( i = 0 ; i < n ; i++ )

	xor	eax, eax
	cmp	DWORD PTR _n$GSCopy$[ebp], eax
	jle	SHORT $mat_inv_sym_exit$89914
	npad	6
$LL7@mat_inv_sy:

; 1240 :     for ( j = 0 ; j < i ; j++ )

	xor	ecx, ecx
	cmp	eax, 4
	jl	SHORT $LN282@mat_inv_sy
	mov	ecx, DWORD PTR [ebx+eax*4]
	lea	edi, DWORD PTR [eax-4]
	shr	edi, 2
	add	ecx, 16					; 00000010H
	inc	edi
	lea	edx, DWORD PTR [edi*4]
	lea	esi, DWORD PTR [ebx+8]
	mov	DWORD PTR _j$[ebp], edx
$LL247@mat_inv_sy:

; 1241 :       a[i][j] = a[j][i];

	mov	edx, DWORD PTR [esi-8]
	fld	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [esi-4]
	fstp	QWORD PTR [ecx-16]
	add	esi, 16					; 00000010H
	fld	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [esi-16]
	fstp	QWORD PTR [ecx-8]
	add	ecx, 32					; 00000020H
	dec	edi
	fld	QWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR [esi-12]
	fstp	QWORD PTR [ecx-32]
	fld	QWORD PTR [edx+eax*8]
	fstp	QWORD PTR [ecx-24]
	jne	SHORT $LL247@mat_inv_sy

; 1240 :     for ( j = 0 ; j < i ; j++ )

	mov	edx, DWORD PTR _ipiv$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
$LN282@mat_inv_sy:
	cmp	ecx, eax
	jge	SHORT $LN6@mat_inv_sy
	mov	esi, DWORD PTR [ebx+eax*4]
	lea	esi, DWORD PTR [esi+ecx*8]
	npad	2
$LC4@mat_inv_sy:

; 1241 :       a[i][j] = a[j][i];

	mov	edi, DWORD PTR [ebx+ecx*4]
	fld	QWORD PTR [edi+eax*8]
	inc	ecx
	fstp	QWORD PTR [esi]
	add	esi, 8
	cmp	ecx, eax
	jl	SHORT $LC4@mat_inv_sy
$LN6@mat_inv_sy:

; 1235 :     }
; 1236 :   }  
; 1237 : 
; 1238 :   /* symmetrize from upper to lower */
; 1239 :   for ( i = 0 ; i < n ; i++ )

	inc	eax
	cmp	eax, DWORD PTR _n$GSCopy$[ebp]
	jl	SHORT $LL7@mat_inv_sy
$mat_inv_sym_exit$89914:

; 1242 : 
; 1243 :   
; 1244 : mat_inv_sym_exit:
; 1245 :   if ( n > SMALL )

	mov	esi, DWORD PTR _n$GSCopy$[ebp]
	cmp	esi, 10					; 0000000aH
	jle	SHORT $LN249@mat_inv_sy

; 1246 :   { free_ivector(ipiv,0,n-1);

	dec	esi
	push	esi
	push	0
	push	edx
	call	_free_ivector

; 1247 :     free_ivector(spiv,0,n-1);

	mov	eax, DWORD PTR _spiv$[ebp]
	push	esi
	push	0
	push	eax
	call	_free_ivector
	add	esp, 24					; 00000018H
$LN249@mat_inv_sy:

; 1250 : } // end mat_inv_sym()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, DWORD PTR _negs$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_mat_inv_sym ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@PBEPOHJA@Trying?5to?5factor?5singular?5matrix@ ; `string'
PUBLIC	_LD_factor
;	COMDAT ??_C@_0DF@PBEPOHJA@Trying?5to?5factor?5singular?5matrix@
CONST	SEGMENT
??_C@_0DF@PBEPOHJA@Trying?5to?5factor?5singular?5matrix@ DB 'Trying to fa'
	DB	'ctor singular matrix; using 1 as pivot.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _LD_factor
_TEXT	SEGMENT
_k$ = -24						; size = 4
tv1490 = -20						; size = 4
_negs$ = -16						; size = 4
tv1468 = -12						; size = 4
tv1470 = -8						; size = 4
tv1358 = -4						; size = 4
_H$ = 8							; size = 4
_N$ = 12						; size = 4
_LD_factor PROC						; COMDAT

; 1265 : { int i,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1267 : 
; 1268 : #ifdef BLAS
; 1269 :   if ( blas_flag )
; 1270 :   { char uplo = 'U';
; 1271 :     int stride = H[1] - H[0];
; 1272 :     int info=0;
; 1273 :     DPOTRF(&uplo,&N,&H[0][0],&stride,&info);
; 1274 :   }
; 1275 :   else
; 1276 : #endif
; 1277 :   for ( i = 0 ; i < N ; i++ )   /* pivot (i,i) */

	mov	eax, DWORD PTR _N$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _negs$[ebp], ecx
	test	eax, eax
	jle	$LN23@LD_factor

; 1266 :   int negs = 0;

	fldz
	push	ebx
	mov	ebx, DWORD PTR _H$[ebp]
	fld1
	push	esi
	push	edi
	xor	esi, esi
	mov	DWORD PTR tv1358[ebp], 1
	mov	DWORD PTR tv1468[ebp], 2
	mov	DWORD PTR tv1470[ebp], ebx
	mov	DWORD PTR tv1490[ebp], eax
$LN24@LD_factor:

; 1278 :   { REAL pivot = H[i][i];

	mov	eax, DWORD PTR tv1470[ebp]
	mov	ecx, DWORD PTR [eax]
	fld	QWORD PTR [esi+ecx]

; 1279 :     if ( pivot == 0.0 )

	fld	ST(0)
	fld	ST(3)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN8@LD_factor

; 1280 :     { kb_error(2553,"Trying to factor singular matrix; using 1 as pivot.\n",
; 1281 :        WARNING);

	push	2
	fstp	ST(0)
	push	OFFSET ??_C@_0DF@PBEPOHJA@Trying?5to?5factor?5singular?5matrix@
	fstp	ST(0)
	push	2553					; 000009f9H
	fstp	ST(0)
	call	_kb_error

; 1282 :       pivot = 1.0;

	fld1
	fld	ST(0)
	add	esp, 12					; 0000000cH

; 1283 :     }
; 1284 :     if ( pivot < 0 ) negs++;

	fldz
	fxch	ST(2)
	fxch	ST(1)
$LN7@LD_factor:

; 1285 :     pivot = 1/pivot;
; 1286 :     for ( j = i+1 ; j < N ; j++ )  /* row j */

	mov	edi, DWORD PTR tv1358[ebp]
	fdivr	ST(0), ST(1)
	mov	eax, edi
	cmp	eax, DWORD PTR _N$[ebp]
	jge	$LN34@LD_factor
$LN6@LD_factor:

; 1287 :     { REAL x = H[j][i];

	mov	edx, DWORD PTR [ebx+edi*4]
	fld	QWORD PTR [esi+edx]
	cmp	eax, edi
	jge	$LN20@LD_factor

; 1288 :       for ( k = i+1 ; k < j ; k++ ) /* col k */

	mov	ecx, DWORD PTR tv1468[ebp]
	lea	edx, DWORD PTR [ecx+edi-3]
	cmp	edx, 4
	jl	SHORT $LC21@LD_factor

; 1289 :         H[j][k] -= x*H[k][i];

	mov	eax, DWORD PTR [ebx+edi*4]
	mov	ebx, DWORD PTR tv1358[ebp]
	mov	edx, DWORD PTR tv1470[ebp]
	mov	ecx, edi
	sub	ecx, ebx
	sub	ecx, 4
	shr	ecx, 2
	add	edx, 12					; 0000000cH
	inc	ecx
	lea	ebx, DWORD PTR [ebx+ecx*4]
	lea	eax, DWORD PTR [esi+eax+24]
	mov	DWORD PTR _k$[ebp], ebx
$LN22@LD_factor:
	mov	ebx, DWORD PTR [edx-8]
	fld	QWORD PTR [ebx+esi]
	mov	ebx, DWORD PTR [edx-4]
	fmul	ST(0), ST(1)
	add	edx, 16					; 00000010H
	add	eax, 32					; 00000020H
	dec	ecx
	fsubr	QWORD PTR [eax-48]
	fstp	QWORD PTR [eax-48]
	fld	QWORD PTR [ebx+esi]
	mov	ebx, DWORD PTR [edx-16]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [esi+ebx]
	mov	ebx, DWORD PTR [edx-12]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [ebx+esi]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN22@LD_factor
	mov	ebx, DWORD PTR _H$[ebp]
	mov	eax, DWORD PTR _k$[ebp]
$LC21@LD_factor:

; 1288 :       for ( k = i+1 ; k < j ; k++ ) /* col k */

	cmp	eax, edi
	jge	SHORT $LN20@LD_factor
	mov	ecx, DWORD PTR [ebx+edi*4]
	lea	ecx, DWORD PTR [ecx+eax*8]
$LC3@LD_factor:

; 1289 :         H[j][k] -= x*H[k][i];

	mov	edx, DWORD PTR [ebx+eax*4]
	fld	QWORD PTR [edx+esi]
	inc	eax
	fmul	ST(0), ST(1)
	add	ecx, 8
	fsubr	QWORD PTR [ecx-8]
	fstp	QWORD PTR [ecx-8]
	cmp	eax, edi
	jl	SHORT $LC3@LD_factor
$LN20@LD_factor:

; 1290 :       H[j][i] = x*pivot;

	mov	eax, DWORD PTR [ebx+edi*4]
	fld	ST(0)
	fmul	ST(0), ST(2)
	inc	edi
	fstp	QWORD PTR [eax+esi]

; 1291 :       H[j][j] -= x*x*pivot;

	fmul	ST(0), ST(0)
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax+edi*8-8]
	fstp	QWORD PTR [eax+edi*8-8]
	mov	eax, DWORD PTR tv1358[ebp]
	cmp	edi, DWORD PTR _N$[ebp]
	jl	$LN6@LD_factor
$LN34@LD_factor:

; 1267 : 
; 1268 : #ifdef BLAS
; 1269 :   if ( blas_flag )
; 1270 :   { char uplo = 'U';
; 1271 :     int stride = H[1] - H[0];
; 1272 :     int info=0;
; 1273 :     DPOTRF(&uplo,&N,&H[0][0],&stride,&info);
; 1274 :   }
; 1275 :   else
; 1276 : #endif
; 1277 :   for ( i = 0 ; i < N ; i++ )   /* pivot (i,i) */

	add	DWORD PTR tv1470[ebp], 4

; 1285 :     pivot = 1/pivot;
; 1286 :     for ( j = i+1 ; j < N ; j++ )  /* row j */

	fstp	ST(0)
	mov	ecx, 1
	sub	DWORD PTR tv1468[ebp], ecx
	add	eax, ecx
	add	esi, 8
	sub	DWORD PTR tv1490[ebp], ecx
	mov	DWORD PTR tv1358[ebp], eax
	jne	$LN24@LD_factor

; 1292 :     }
; 1293 :   }
; 1294 :  return negs;

	mov	eax, DWORD PTR _negs$[ebp]
	fstp	ST(0)
	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx

; 1295 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@LD_factor:

; 1283 :     }
; 1284 :     if ( pivot < 0 ) negs++;

	fcom	ST(2)
	fnstsw	ax
	test	ah, 5
	jp	$LN7@LD_factor
	inc	DWORD PTR _negs$[ebp]
	jmp	$LN7@LD_factor
$LN23@LD_factor:

; 1292 :     }
; 1293 :   }
; 1294 :  return negs;

	mov	eax, ecx

; 1295 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_LD_factor ENDP
_TEXT	ENDS
PUBLIC	_LD_solve
; Function compile flags: /Ogtp
;	COMDAT _LD_solve
_TEXT	SEGMENT
tv2558 = -16						; size = 4
tv1658 = -16						; size = 4
tv1252 = -16						; size = 4
tv2743 = -12						; size = 4
tv1654 = -12						; size = 4
tv1071 = -12						; size = 4
tv2683 = -8						; size = 4
_i$ = -8						; size = 4
tv1407 = -4						; size = 4
_j$ = -4						; size = 4
_LD$ = 8						; size = 4
_B$ = 12						; size = 4
_X$ = 16						; size = 4
_N$ = 20						; size = 4
_LD_solve PROC						; COMDAT

; 1310 : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1311 : #ifdef BLAS
; 1312 :   if ( blas_flag )
; 1313 :   { char uplo = 'U';
; 1314 :     int stride = LD[1] - LD[0];
; 1315 :     int info=0;
; 1316 :     int nrhs = 1; /* number of rhs */
; 1317 :     for ( i = 0 ; i < N ; i++ ) X[i] = B[i]; /* since DPOTRS overwrites */
; 1318 :     DPOTRS(&uplo,&N,&nrhs,&LD[0][0],&stride,&X[0],&N,&info);
; 1319 :   }
; 1320 :   else
; 1321 : #endif
; 1322 :   {  for ( i = 0 ; i < N ; i++ )

	mov	edx, DWORD PTR _N$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	push	ebx
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR _i$[ebp], edi
	test	edx, edx
	jle	$LN39@LD_solve
	mov	esi, DWORD PTR _B$[ebp]
	sub	esi, ecx
	mov	eax, ecx
	mov	DWORD PTR tv1252[ebp], esi
	jmp	SHORT $LN15@LD_solve
$LL41@LD_solve:
	mov	esi, DWORD PTR tv1252[ebp]
$LN15@LD_solve:

; 1323 :      { X[i] = B[i];

	fld	QWORD PTR [esi+eax]

; 1324 :        for ( j = 0 ; j < i ; j++ )

	xor	esi, esi
	fstp	QWORD PTR [eax]
	mov	DWORD PTR _j$[ebp], esi
	cmp	edi, 4
	jl	SHORT $LC29@LD_solve
	mov	edx, DWORD PTR _LD$[ebp]
	mov	ebx, DWORD PTR [edx+edi*4]
	add	edi, -4					; fffffffcH
	lea	esi, DWORD PTR [ebx+24]

; 1325 :          X[i] -= LD[i][j]*X[j];

	sub	ebx, ecx
	shr	edi, 2
	mov	DWORD PTR tv1071[ebp], ebx
	inc	edi
	lea	ebx, DWORD PTR [edi*4]
	mov	DWORD PTR _j$[ebp], ebx
	mov	ebx, DWORD PTR tv1071[ebp]
	lea	edx, DWORD PTR [ecx+8]
	npad	1
$LL30@LD_solve:
	fld	QWORD PTR [edx-8]
	add	edx, 32					; 00000020H
	fmul	QWORD PTR [esi-24]
	add	esi, 32					; 00000020H
	dec	edi
	fsubr	QWORD PTR [eax]
	fst	QWORD PTR [eax]
	fld	QWORD PTR [ebx+edx-32]
	fmul	QWORD PTR [edx-32]
	fsubp	ST(1), ST(0)
	fst	QWORD PTR [eax]
	fld	QWORD PTR [edx-24]
	fmul	QWORD PTR [esi-40]
	fsubp	ST(1), ST(0)
	fst	QWORD PTR [eax]
	fld	QWORD PTR [edx-16]
	fmul	QWORD PTR [esi-32]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax]
	jne	SHORT $LL30@LD_solve

; 1323 :      { X[i] = B[i];

	mov	edx, DWORD PTR _N$[ebp]
	mov	esi, DWORD PTR _j$[ebp]
	mov	edi, DWORD PTR _i$[ebp]
$LC29@LD_solve:

; 1324 :        for ( j = 0 ; j < i ; j++ )

	cmp	esi, edi
	jge	SHORT $LN14@LD_solve
	mov	edx, DWORD PTR _LD$[ebp]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	ebx, edi
	sub	edx, ecx
	sub	ebx, DWORD PTR _j$[ebp]
	lea	esi, DWORD PTR [ecx+esi*8]
	npad	1
$LC12@LD_solve:

; 1325 :          X[i] -= LD[i][j]*X[j];

	fld	QWORD PTR [esi+edx]
	add	esi, 8
	dec	ebx
	fmul	QWORD PTR [esi-8]
	fsubr	QWORD PTR [eax]
	fstp	QWORD PTR [eax]
	jne	SHORT $LC12@LD_solve

; 1324 :        for ( j = 0 ; j < i ; j++ )

	mov	edx, DWORD PTR _N$[ebp]
$LN14@LD_solve:

; 1311 : #ifdef BLAS
; 1312 :   if ( blas_flag )
; 1313 :   { char uplo = 'U';
; 1314 :     int stride = LD[1] - LD[0];
; 1315 :     int info=0;
; 1316 :     int nrhs = 1; /* number of rhs */
; 1317 :     for ( i = 0 ; i < N ; i++ ) X[i] = B[i]; /* since DPOTRS overwrites */
; 1318 :     DPOTRS(&uplo,&N,&nrhs,&LD[0][0],&stride,&X[0],&N,&info);
; 1319 :   }
; 1320 :   else
; 1321 : #endif
; 1322 :   {  for ( i = 0 ; i < N ; i++ )

	inc	edi
	add	eax, 8
	mov	DWORD PTR _i$[ebp], edi
	cmp	edi, edx
	jl	$LL41@LD_solve
$LN39@LD_solve:

; 1326 :      }
; 1327 :      for ( i = 0 ; i < N ; i++ )

	xor	eax, eax
	cmp	edx, 4
	jl	$LN38@LD_solve
	mov	esi, DWORD PTR _LD$[ebp]

; 1328 :        X[i] /= LD[i][i];

	mov	edi, 8
	sub	edi, ecx
	mov	DWORD PTR tv1654[ebp], edi
	lea	edi, DWORD PTR [edx-4]
	mov	ebx, -16				; fffffff0H
	sub	ebx, ecx
	shr	edi, 2
	add	esi, 8
	inc	edi
	lea	edx, DWORD PTR [edi*4]
	mov	DWORD PTR tv1407[ebp], 16		; 00000010H
	lea	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR tv1658[ebp], ebx
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $LN33@LD_solve
$LL37@LD_solve:

; 1326 :      }
; 1327 :      for ( i = 0 ; i < N ; i++ )

	mov	ebx, DWORD PTR tv1658[ebp]
$LN33@LD_solve:

; 1328 :        X[i] /= LD[i][i];

	fld	QWORD PTR [eax-16]
	lea	edx, DWORD PTR [ebx+eax]
	mov	ebx, DWORD PTR [esi-8]
	fdiv	QWORD PTR [ebx+edx]
	mov	ebx, DWORD PTR [esi-4]
	add	esi, 16					; 00000010H
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-48]
	fld	QWORD PTR [eax-40]
	fdiv	QWORD PTR [ebx+edx+8]
	mov	edx, DWORD PTR [esi-16]
	mov	ebx, DWORD PTR tv1407[ebp]
	add	DWORD PTR tv1407[ebp], 32		; 00000020H
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax-32]
	fdiv	QWORD PTR [ebx+edx]
	mov	edx, DWORD PTR [esi-12]
	add	edx, DWORD PTR tv1654[ebp]
	dec	edi
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [eax-24]
	fdiv	QWORD PTR [edx+eax-32]
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LL37@LD_solve

; 1326 :      }
; 1327 :      for ( i = 0 ; i < N ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _N$[ebp]
$LN38@LD_solve:
	cmp	eax, edx
	jge	SHORT $LN31@LD_solve
	npad	7
$LC9@LD_solve:

; 1328 :        X[i] /= LD[i][i];

	mov	esi, DWORD PTR _LD$[ebp]
	fld	QWORD PTR [ecx+eax*8]
	mov	esi, DWORD PTR [esi+eax*4]
	fdiv	QWORD PTR [esi+eax*8]
	inc	eax
	fstp	QWORD PTR [ecx+eax*8-8]
	cmp	eax, edx
	jl	SHORT $LC9@LD_solve
$LN31@LD_solve:

; 1329 :      for ( i = N-1 ; i >= 0 ; i-- )

	lea	eax, DWORD PTR [edx-1]
	test	eax, eax
	js	$LN4@LD_solve
	mov	esi, DWORD PTR _LD$[ebp]
	mov	edi, edx
	sub	edi, eax
	lea	ebx, DWORD PTR [eax+1]
	dec	edi
	lea	esi, DWORD PTR [esi+eax*4+12]
	mov	DWORD PTR tv2558[ebp], ebx
	mov	DWORD PTR tv2683[ebp], edi
	mov	DWORD PTR tv2743[ebp], esi
	npad	8
$LL6@LD_solve:

; 1330 :      { for ( j = i+1 ; j < N ; j++ )

	mov	esi, ebx
	cmp	ebx, edx
	jge	$LN5@LD_solve
	cmp	edi, 4
	jl	SHORT $LC35@LD_solve

; 1331 :         X[i] -= LD[j][i]*X[j];

	mov	esi, DWORD PTR tv2743[ebp]
	sub	edx, ebx
	sub	edx, 4
	shr	edx, 2
	inc	edx
	lea	ebx, DWORD PTR [ebx+edx*4]
	lea	edi, DWORD PTR [ecx+eax*8+24]
	mov	DWORD PTR _j$[ebp], ebx
$LL36@LD_solve:
	mov	ebx, DWORD PTR [esi-8]
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [esi-4]
	fmul	QWORD PTR [edi-16]
	add	esi, 16					; 00000010H
	add	edi, 32					; 00000020H
	dec	edx
	fsubr	QWORD PTR [ecx+eax*8]
	fst	QWORD PTR [ecx+eax*8]
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [esi-16]
	fmul	QWORD PTR [edi-40]
	fsubp	ST(1), ST(0)
	fst	QWORD PTR [ecx+eax*8]
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR [esi-12]
	fmul	QWORD PTR [edi-32]
	fsubp	ST(1), ST(0)
	fst	QWORD PTR [ecx+eax*8]
	fld	QWORD PTR [ebx+eax*8]
	fmul	QWORD PTR [edi-24]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ecx+eax*8]
	jne	SHORT $LL36@LD_solve
	mov	ebx, DWORD PTR tv2558[ebp]
	mov	esi, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _N$[ebp]
	mov	edi, DWORD PTR tv2683[ebp]
$LC35@LD_solve:

; 1330 :      { for ( j = i+1 ; j < N ; j++ )

	cmp	esi, edx
	jge	SHORT $LN5@LD_solve
$LC3@LD_solve:

; 1331 :         X[i] -= LD[j][i]*X[j];

	mov	edi, DWORD PTR _LD$[ebp]
	mov	edi, DWORD PTR [edi+esi*4]
	fld	QWORD PTR [edi+eax*8]
	inc	esi
	fmul	QWORD PTR [ecx+esi*8-8]
	fsubr	QWORD PTR [ecx+eax*8]
	fstp	QWORD PTR [ecx+eax*8]
	cmp	esi, edx
	jl	SHORT $LC3@LD_solve

; 1330 :      { for ( j = i+1 ; j < N ; j++ )

	mov	edi, DWORD PTR tv2683[ebp]
$LN5@LD_solve:

; 1329 :      for ( i = N-1 ; i >= 0 ; i-- )

	sub	DWORD PTR tv2743[ebp], 4
	inc	edi
	dec	ebx
	dec	eax
	mov	DWORD PTR tv2683[ebp], edi
	mov	DWORD PTR tv2558[ebp], ebx
	jns	$LL6@LD_solve
$LN4@LD_solve:
	pop	edi
	pop	esi
	pop	ebx

; 1332 :      }
; 1333 :   }
; 1334 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_LD_solve ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@MKNMDPFL@Internal?3?5ipiv?5?$DO?50?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CK@MBKBLEOI@Internal?5error?3?5Matrix?5size?5not?5@ ; `string'
PUBLIC	_a$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_det_adjoint
;	COMDAT ??_C@_0BF@MKNMDPFL@Internal?3?5ipiv?5?$DO?50?4?6?$AA@
CONST	SEGMENT
??_C@_0BF@MKNMDPFL@Internal?3?5ipiv?5?$DO?50?4?6?$AA@ DB 'Internal: ipiv '
	DB	'> 0.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MBKBLEOI@Internal?5error?3?5Matrix?5size?5not?5@
CONST	SEGMENT
??_C@_0CK@MBKBLEOI@Internal?5error?3?5Matrix?5size?5not?5@ DB 'Internal e'
	DB	'rror: Matrix size not positive.', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _det_adjoint
_TEXT	SEGMENT
_a$GSCopy$ = -184					; size = 4
tv3331 = -180						; size = 4
_icol$ = -176						; size = 4
tv2554 = -172						; size = 4
tv5308 = -168						; size = 4
_i$ = -168						; size = 4
_indxr$ = -164						; size = 4
_indxc$ = -160						; size = 4
_det$ = -156						; size = 8
tv3947 = -152						; size = 4
tv3850 = -152						; size = 4
tv3451 = -152						; size = 4
tv3368 = -152						; size = 4
_ipiv$ = -148						; size = 4
_irow$ = -144						; size = 4
tv4615 = -140						; size = 4
tv4051 = -140						; size = 4
tv3182 = -136						; size = 4
_l$ = -136						; size = 4
tv5720 = -132						; size = 4
tv5702 = -132						; size = 4
tv5689 = -132						; size = 4
tv5676 = -132						; size = 4
tv5626 = -132						; size = 4
tv4946 = -132						; size = 4
tv4702 = -132						; size = 4
tv4160 = -132						; size = 4
tv4059 = -132						; size = 4
tv3161 = -128						; size = 4
tv1935 = -128						; size = 4
_ll$ = -128						; size = 4
_k$ = -128						; size = 4
_temp1$ = -124						; size = 40
_temp2$ = -84						; size = 40
_temp3$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_n$ = 12						; size = 4
_det_adjoint PROC					; COMDAT

; 1346 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1347 :   int *indxc,*indxr,*ipiv;
; 1348 :   int i,icol=0,irow=0,j,k,l,ll;
; 1349 :   REAL big,dum,pivinv,piv;
; 1350 :   int temp1[SMALL],temp2[SMALL],temp3[SMALL]; /* avoid alloc for small sizes */
; 1351 :   REAL det = 1.0;  /* will multiply by pivots */

	fld1
	push	ebx
	mov	ebx, DWORD PTR _a$[ebp]
	fld	ST(0)
	push	esi
	fst	QWORD PTR _det$[ebp]
	mov	esi, DWORD PTR _n$[ebp]
	push	edi
	xor	edi, edi

; 1423 :     }
; 1424 :   det *= piv;
; 1425 : 
; 1426 :   for ( l = n-1 ; l >= 0 ; l-- )

	mov	DWORD PTR _a$GSCopy$[ebp], ebx
	mov	DWORD PTR _icol$[ebp], edi
	mov	DWORD PTR _irow$[ebp], edi
	cmp	esi, edi
	jg	SHORT $LN65@det_adjoin

; 1352 : 
; 1353 :   if ( n <= 0 )

	push	1
	fstp	ST(0)

; 1354 :     kb_error(1205,"Internal error: Matrix size not positive.",RECOVERABLE);

	push	OFFSET ??_C@_0CK@MBKBLEOI@Internal?5error?3?5Matrix?5size?5not?5@
	fstp	ST(0)
	push	1205					; 000004b5H
	call	_kb_error
	fld1
	fld	QWORD PTR _det$[ebp]
	add	esp, 12					; 0000000cH
$LN65@det_adjoin:

; 1355 : 
; 1356 :   if ( n == 1 ) { det = a[0][0]; a[0][0] = 1.0; return det; }

	cmp	esi, 1
	jne	SHORT $LN64@det_adjoin
	mov	ebx, DWORD PTR [ebx]
	fstp	ST(0)
	fld	QWORD PTR [ebx]
	pop	edi
	fxch	ST(1)
	pop	esi
	fstp	QWORD PTR [ebx]
	pop	ebx

; 1446 :   
; 1447 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN64@det_adjoin:

; 1357 :   if ( n == 2 )

	cmp	esi, 2
	jne	SHORT $LN63@det_adjoin

; 1358 :   { REAL temp;
; 1359 :     det = a[0][0]*a[1][1] - a[0][1]*a[1][0];

	mov	eax, DWORD PTR [ebx+4]
	fstp	ST(0)
	mov	ebx, DWORD PTR [ebx]
	fstp	ST(0)
	fld	QWORD PTR [ebx]
	pop	edi
	fmul	QWORD PTR [eax+8]
	pop	esi
	fld	QWORD PTR [eax]
	fmul	QWORD PTR [ebx+8]
	fsubp	ST(1), ST(0)

; 1360 :     temp = a[0][0]; a[0][0] = a[1][1]; a[1][1] = temp;

	fld	QWORD PTR [ebx]
	fld	QWORD PTR [eax+8]
	fstp	QWORD PTR [ebx]
	fstp	QWORD PTR [eax+8]

; 1361 :     a[0][1] = -a[0][1]; a[1][0] = -a[1][0];

	fld	QWORD PTR [ebx+8]
	fchs
	fstp	QWORD PTR [ebx+8]
	pop	ebx
	fld	QWORD PTR [eax]
	fchs
	fstp	QWORD PTR [eax]

; 1446 :   
; 1447 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@det_adjoin:

; 1362 :     return det;
; 1363 :   }
; 1364 : 
; 1365 :   if ( n <= SMALL )

	cmp	esi, 10					; 0000000aH
	jg	SHORT $LN146@det_adjoin

; 1366 :   { indxc = temp1; indxr = temp2; ipiv = temp3; }

	lea	eax, DWORD PTR _temp1$[ebp]
	lea	ecx, DWORD PTR _temp2$[ebp]
	lea	edx, DWORD PTR _temp3$[ebp]
	mov	DWORD PTR _indxc$[ebp], eax
	mov	DWORD PTR _indxr$[ebp], ecx
	mov	DWORD PTR _ipiv$[ebp], edx

; 1367 :   else

	jmp	SHORT $LN61@det_adjoin
$LN146@det_adjoin:

; 1368 :   { /* large size */
; 1369 :     indxc = ivector(0,n-1);

	lea	eax, DWORD PTR [esi-1]
	fstp	ST(0)
	push	eax
	fstp	ST(0)
	push	0
	call	_ivector
	mov	DWORD PTR _indxc$[ebp], eax

; 1370 :     indxr = ivector(0,n-1);

	lea	eax, DWORD PTR [esi-1]
	push	eax
	push	0
	call	_ivector
	mov	DWORD PTR _indxr$[ebp], eax

; 1371 :     ipiv  = ivector(0,n-1);

	lea	eax, DWORD PTR [esi-1]
	push	eax
	push	0
	call	_ivector
	fld1
	fld	QWORD PTR _det$[ebp]
	add	esp, 24					; 00000018H
	mov	DWORD PTR _ipiv$[ebp], eax
$LN61@det_adjoin:

; 1372 :   }
; 1373 :   for ( j = 0 ; j < n ; j++ ) ipiv[j] = -1;

	test	esi, esi
	jle	SHORT $LN60@det_adjoin
	mov	edi, DWORD PTR _ipiv$[ebp]
	mov	ecx, esi
	or	eax, -1
	rep stosd
	mov	edi, DWORD PTR _icol$[ebp]
$LN60@det_adjoin:

; 1374 :   for ( i = 0 ; i < n-1 ; i++ )

	fldz
	lea	eax, DWORD PTR [esi-1]
	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR tv2554[ebp], eax
	test	eax, eax
	jle	$LN55@det_adjoin
	mov	ecx, DWORD PTR _indxc$[ebp]
	mov	eax, DWORD PTR _indxr$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv4051[ebp], ecx
	mov	DWORD PTR tv4059[ebp], eax
$LN57@det_adjoin:

; 1375 :   { big = 0.0;
; 1376 :     for ( j = 0 ; j < n ; j++ )

	xor	edx, edx
	fld	ST(0)
	test	esi, esi
	jle	$LN173@det_adjoin
	mov	eax, DWORD PTR _ipiv$[ebp]
	sub	eax, ebx
	mov	DWORD PTR tv3161[ebp], ebx
	mov	DWORD PTR tv3182[ebp], eax
$LN54@det_adjoin:

; 1377 :       if ( ipiv[j] != 0 )

	mov	ecx, DWORD PTR tv3161[ebp]
	cmp	DWORD PTR [eax+ecx], 0
	je	SHORT $LN53@det_adjoin

; 1378 :          for ( k = 0 ; k < n ; k++ )

	xor	ecx, ecx
$LN50@det_adjoin:

; 1379 :          { if ( ipiv[k] == -1 )

	mov	eax, DWORD PTR _ipiv$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	cmp	eax, -1
	jne	SHORT $LN47@det_adjoin

; 1380 :            { if ( fabs(a[j][k]) >= big )

	mov	eax, DWORD PTR tv3161[ebp]
	mov	eax, DWORD PTR [eax]
	fld	QWORD PTR [eax+ecx*8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN168@det_adjoin

; 1381 :              { big = fabs(a[j][k]);
; 1382 :                irow = j;
; 1383 :                icol = k;

	mov	edi, ecx

; 1384 :              }
; 1385 :            }
; 1386 :            else if ( ipiv[k] > 0 )

	fstp	ST(1)
	mov	DWORD PTR _irow$[ebp], edx
	mov	DWORD PTR _icol$[ebp], edi
	jmp	SHORT $LN49@det_adjoin
$LN47@det_adjoin:
	test	eax, eax
	jle	SHORT $LN49@det_adjoin

; 1387 :            { kb_error(1206,"Internal: ipiv > 0.\n",WARNING); det = 0.0; goto det_exit; }

	fstp	ST(0)
	push	2
	fstp	ST(1)
	push	OFFSET ??_C@_0BF@MKNMDPFL@Internal?3?5ipiv?5?$DO?50?4?6?$AA@
	fstp	ST(0)
	push	1206					; 000004b6H
	fstp	ST(0)
	call	_kb_error
	fldz
	add	esp, 12					; 0000000cH
	fstp	QWORD PTR _det$[ebp]
	jmp	$det_exit$90092
$LN168@det_adjoin:

; 1384 :              }
; 1385 :            }
; 1386 :            else if ( ipiv[k] > 0 )

	fstp	ST(0)
$LN49@det_adjoin:

; 1378 :          for ( k = 0 ; k < n ; k++ )

	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LN50@det_adjoin
	mov	eax, DWORD PTR tv3182[ebp]
$LN53@det_adjoin:

; 1375 :   { big = 0.0;
; 1376 :     for ( j = 0 ; j < n ; j++ )

	add	DWORD PTR tv3161[ebp], 4
	inc	edx
	cmp	edx, esi
	jl	$LN54@det_adjoin
$LN173@det_adjoin:

; 1388 :          }
; 1389 :       ++(ipiv[icol]);

	mov	eax, DWORD PTR _ipiv$[ebp]
	fstp	ST(0)
	inc	DWORD PTR [eax+edi*4]

; 1390 : 
; 1391 :       if ( irow != icol )

	cmp	DWORD PTR _irow$[ebp], edi
	je	$LN125@det_adjoin

; 1392 :       { for ( l = 0 ; l < n ; l++ ) SWAP(a[irow][l],a[icol][l])

	xor	eax, eax
	mov	DWORD PTR _l$[ebp], eax
	cmp	esi, 4
	jl	$LN124@det_adjoin
	mov	ecx, DWORD PTR _irow$[ebp]
	mov	edx, DWORD PTR [ebx+ecx*4]
	mov	ecx, DWORD PTR [ebx+edi*4]
	lea	eax, DWORD PTR [edx+24]
	sub	edx, ecx
	mov	DWORD PTR tv3331[ebp], eax
	lea	eax, DWORD PTR [ecx+8]
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	inc	ecx
	mov	DWORD PTR tv1935[ebp], ecx
	add	ecx, ecx
	add	ecx, ecx
	mov	DWORD PTR _l$[ebp], ecx
	mov	ecx, DWORD PTR tv3331[ebp]
	mov	DWORD PTR tv3368[ebp], edx
	jmp	SHORT $LN105@det_adjoin
$LN130@det_adjoin:
	mov	edx, DWORD PTR tv3368[ebp]
$LN105@det_adjoin:
	fld	QWORD PTR [ecx-24]
	add	eax, 32					; 00000020H
	fld	QWORD PTR [eax-40]
	add	ecx, 32					; 00000020H
	dec	DWORD PTR tv1935[ebp]
	fstp	QWORD PTR [ecx-56]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [edx+eax-32]
	fld	QWORD PTR [eax-32]
	fstp	QWORD PTR [edx+eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [ecx-40]
	fld	QWORD PTR [eax-24]
	fstp	QWORD PTR [ecx-40]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [ecx-32]
	fld	QWORD PTR [eax-16]
	fstp	QWORD PTR [ecx-32]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN130@det_adjoin
	mov	eax, DWORD PTR _l$[ebp]
$LN124@det_adjoin:
	cmp	eax, esi
	jge	SHORT $LN134@det_adjoin
	mov	ecx, DWORD PTR [ebx+edi*4]
	mov	edx, DWORD PTR _irow$[ebp]
	mov	edx, DWORD PTR [ebx+edx*4]
	sub	edx, ecx
	lea	eax, DWORD PTR [ecx+eax*8]
	mov	ecx, esi
	sub	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR tv3451[ebp], edx
$LC42@det_adjoin:
	fld	QWORD PTR [edx+eax]
	add	eax, 8
	dec	ecx
	fld	QWORD PTR [eax-8]
	fstp	QWORD PTR [edx+eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC42@det_adjoin
$LN134@det_adjoin:

; 1393 :         det = -det;

	fxch	ST(1)
	fchs
	fxch	ST(1)
$LN125@det_adjoin:

; 1394 :       }
; 1395 :       indxr[i] = irow;

	mov	eax, DWORD PTR tv4051[ebp]
	mov	edx, DWORD PTR _irow$[ebp]
	mov	ecx, DWORD PTR tv4059[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 1396 :       indxc[i] = icol;

	mov	DWORD PTR [eax], edi

; 1397 :       det *= a[icol][icol];  /* build determinant */

	mov	eax, DWORD PTR [ebx+edi*4]
	fld	QWORD PTR [eax+edi*8]
	lea	eax, DWORD PTR [eax+edi*8]
	fmulp	ST(2), ST(0)

; 1401 :       for ( l = 0 ; l < n ; l++ ) a[icol][l] *= pivinv;

	xor	edx, edx
	fld	QWORD PTR [eax]
$det_lowrank$90099:
	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN190@det_adjoin

; 1399 :       pivinv = 1/a[icol][icol];

	mov	ecx, DWORD PTR [ebx+edi*4]
	fld	ST(2)
	fdiv	QWORD PTR [ecx+edi*8]
	lea	eax, DWORD PTR [ecx+edi*8]

; 1400 :       a[icol][icol] = 1.0;

	fxch	ST(3)
	fst	QWORD PTR [eax]

; 1401 :       for ( l = 0 ; l < n ; l++ ) a[icol][l] *= pivinv;

	cmp	esi, 4
	jl	SHORT $LN127@det_adjoin

; 1399 :       pivinv = 1/a[icol][icol];

	lea	eax, DWORD PTR [ecx+16]
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	inc	ecx
	lea	edx, DWORD PTR [ecx*4]

; 1401 :       for ( l = 0 ; l < n ; l++ ) a[icol][l] *= pivinv;

$LN108@det_adjoin:
	fld	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	ecx
	fmul	ST(0), ST(4)
	fstp	QWORD PTR [eax-48]
	fld	ST(3)
	fmul	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax-32]
	fmul	ST(0), ST(4)
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [eax-24]
	fmul	ST(0), ST(4)
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN108@det_adjoin
$LN127@det_adjoin:
	cmp	edx, esi
	jge	SHORT $LN200@det_adjoin
	mov	eax, DWORD PTR [ebx+edi*4]
	mov	ecx, esi
	lea	eax, DWORD PTR [eax+edx*8]
	sub	ecx, edx
$LC38@det_adjoin:
	fld	QWORD PTR [eax]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(4)
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC38@det_adjoin
$LN200@det_adjoin:

; 1402 :       for ( ll = 0  ; ll < n ; ll++ )

	xor	eax, eax
	fstp	ST(3)
	mov	DWORD PTR _ll$[ebp], eax
	test	esi, esi
	jle	$LN56@det_adjoin
$LN35@det_adjoin:

; 1403 :         if ( ll != icol )

	cmp	eax, edi
	je	$LN34@det_adjoin

; 1404 :         { dum = a[ll][icol];

	mov	ecx, DWORD PTR [ebx+eax*4]
	fld	QWORD PTR [ecx+edi*8]
	lea	ecx, DWORD PTR [ecx+edi*8]

; 1405 :           a[ll][icol] = 0.0;
; 1406 :           for ( l = 0 ; l < n ; l++ ) a[ll][l] -= a[icol][l]*dum;

	xor	edx, edx
	fxch	ST(1)
	fst	QWORD PTR [ecx]
	mov	DWORD PTR _l$[ebp], edx
	cmp	esi, 4
	jl	SHORT $LC110@det_adjoin

; 1404 :         { dum = a[ll][icol];

	mov	edi, DWORD PTR [ebx+edi*4]
	mov	ecx, DWORD PTR [ebx+eax*4]
	lea	edx, DWORD PTR [edi+24]

; 1405 :           a[ll][icol] = 0.0;
; 1406 :           for ( l = 0 ; l < n ; l++ ) a[ll][l] -= a[icol][l]*dum;

	sub	edi, ecx
	lea	eax, DWORD PTR [ecx+8]
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	mov	DWORD PTR tv3850[ebp], edi
	inc	ecx
	lea	edi, DWORD PTR [ecx*4]
	mov	DWORD PTR _l$[ebp], edi
	mov	edi, DWORD PTR tv3850[ebp]
$LN111@det_adjoin:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(2)
	add	edx, 32					; 00000020H
	dec	ecx
	fsubr	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [edi+eax-32]
	fmul	ST(0), ST(2)
	fsubr	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(2)
	fsubr	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fmul	ST(0), ST(2)
	fsubr	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN111@det_adjoin

; 1404 :         { dum = a[ll][icol];

	mov	eax, DWORD PTR _ll$[ebp]
	mov	edx, DWORD PTR _l$[ebp]
	mov	edi, DWORD PTR _icol$[ebp]
$LC110@det_adjoin:

; 1405 :           a[ll][icol] = 0.0;
; 1406 :           for ( l = 0 ; l < n ; l++ ) a[ll][l] -= a[icol][l]*dum;

	cmp	edx, esi
	jge	SHORT $LN213@det_adjoin
	mov	ecx, DWORD PTR [ebx+eax*4]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	edx, DWORD PTR [ebx+edi*4]
	sub	edx, ecx
	mov	ecx, esi
	sub	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR tv3947[ebp], edx
$LC31@det_adjoin:
	fld	QWORD PTR [edx+eax]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(2)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC31@det_adjoin
	mov	eax, DWORD PTR _ll$[ebp]
$LN213@det_adjoin:
	fstp	ST(1)
$LN34@det_adjoin:

; 1402 :       for ( ll = 0  ; ll < n ; ll++ )

	inc	eax
	mov	DWORD PTR _ll$[ebp], eax
	cmp	eax, esi
	jl	$LN35@det_adjoin
$LN56@det_adjoin:

; 1374 :   for ( i = 0 ; i < n-1 ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv4051[ebp], 4
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR tv2554[ebp]
	jl	$LN57@det_adjoin
$LN55@det_adjoin:

; 1407 :         }
; 1408 :   }
; 1409 :   /* special treatment for last pivot; works even if zero */
; 1410 :   for ( j = 0 ; j < n ; j++ )

	xor	eax, eax
	test	esi, esi
	jle	$LN135@det_adjoin
	mov	ecx, DWORD PTR _ipiv$[ebp]
$LN28@det_adjoin:

; 1411 :      if ( ipiv[j] != 0 ) { irow = icol = j; break; }

	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN86@det_adjoin

; 1407 :         }
; 1408 :   }
; 1409 :   /* special treatment for last pivot; works even if zero */
; 1410 :   for ( j = 0 ; j < n ; j++ )

	inc	eax
	cmp	eax, esi
	jl	SHORT $LN28@det_adjoin

; 1411 :      if ( ipiv[j] != 0 ) { irow = icol = j; break; }

	jmp	SHORT $LN135@det_adjoin
$LN190@det_adjoin:

; 1398 :       if ( a[icol][icol] == 0.0 ) { goto det_lowrank; }

	fstp	ST(1)
	fstp	ST(1)

; 1437 :   }
; 1438 :   return det;
; 1439 : 
; 1440 : det_lowrank: /* rank less than n-1, so adjoint = 0 */
; 1441 :   for ( i = 0 ; i < n ; i++ )

	test	esi, esi
	jle	SHORT $LN4@det_adjoin
$LN132@det_adjoin:

; 1442 :      for ( j = 0 ; j < n ; j++ )

	xor	edi, edi
	cmp	esi, 4
	jl	SHORT $LC113@det_adjoin
	mov	eax, DWORD PTR [ebx+edx*4]
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	add	eax, 16					; 00000010H
	inc	ecx
	lea	edi, DWORD PTR [ecx*4]
$LN114@det_adjoin:

; 1443 :         a[i][j] = 0.0;

	fst	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	ecx
	fst	QWORD PTR [eax-40]
	fst	QWORD PTR [eax-32]
	fst	QWORD PTR [eax-24]
	jne	SHORT $LN114@det_adjoin
$LC113@det_adjoin:

; 1442 :      for ( j = 0 ; j < n ; j++ )

	cmp	edi, esi
	jge	SHORT $LN5@det_adjoin
	mov	eax, DWORD PTR [ebx+edx*4]
	lea	ecx, DWORD PTR [eax+edi*8]
	mov	DWORD PTR tv4160[ebp], ecx
	mov	ecx, esi
	sub	ecx, edi
	mov	edi, DWORD PTR tv4160[ebp]
	add	ecx, ecx
	and	ecx, 1073741822				; 3ffffffeH
	xor	eax, eax
	rep stosd
$LN5@det_adjoin:

; 1437 :   }
; 1438 :   return det;
; 1439 : 
; 1440 : det_lowrank: /* rank less than n-1, so adjoint = 0 */
; 1441 :   for ( i = 0 ; i < n ; i++ )

	inc	edx
	cmp	edx, esi
	jl	SHORT $LN132@det_adjoin
$LN4@det_adjoin:

; 1444 :   det = 0.0;

	fstp	QWORD PTR _det$[ebp]

; 1445 :   goto det_exit;

	jmp	$det_exit$90092
$LN86@det_adjoin:

; 1411 :      if ( ipiv[j] != 0 ) { irow = icol = j; break; }

	mov	edi, eax
	mov	DWORD PTR _irow$[ebp], eax
$LN135@det_adjoin:

; 1412 :   indxr[n-1] = irow;

	mov	edx, DWORD PTR _indxr$[ebp]
	mov	eax, DWORD PTR _irow$[ebp]

; 1413 :   indxc[n-1] = icol;

	mov	ecx, DWORD PTR _indxc$[ebp]
	mov	DWORD PTR [edx+esi*4-4], eax
	mov	DWORD PTR [ecx+esi*4-4], edi

; 1414 :   piv = a[icol][icol];

	mov	edx, DWORD PTR [ebx+edi*4]
	fld	QWORD PTR [edx+edi*8]
	lea	eax, DWORD PTR [edx+edi*8]

; 1415 :   a[icol][icol] = 1.0;

	fxch	ST(3)

; 1416 :   for ( l = 0 ; l < n ; l++ ) a[icol][l] *= det;

	xor	edx, edx
	fstp	QWORD PTR [eax]
	cmp	esi, 4
	jl	SHORT $LC116@det_adjoin

; 1412 :   indxr[n-1] = irow;

	mov	eax, DWORD PTR [ebx+edi*4]
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	add	eax, 16					; 00000010H
	inc	ecx
	lea	edx, DWORD PTR [ecx*4]

; 1416 :   for ( l = 0 ; l < n ; l++ ) a[icol][l] *= det;

$LN117@det_adjoin:
	fld	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	ecx
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [eax-48]
	fld	ST(1)
	fmul	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax-32]
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [eax-24]
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN117@det_adjoin
$LC116@det_adjoin:
	cmp	edx, esi
	jge	SHORT $LN115@det_adjoin
	mov	eax, DWORD PTR [ebx+edi*4]
	mov	ecx, esi
	lea	eax, DWORD PTR [eax+edx*8]
	sub	ecx, edx
$LC24@det_adjoin:
	fld	QWORD PTR [eax]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(2)
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC24@det_adjoin
$LN115@det_adjoin:

; 1417 :   for ( ll = 0  ; ll < n ; ll++ )

	xor	eax, eax
	mov	DWORD PTR _ll$[ebp], eax
	test	esi, esi
	jle	$LN263@det_adjoin
$LN21@det_adjoin:

; 1418 :     if ( ll != icol )

	cmp	eax, edi
	je	$LN20@det_adjoin

; 1419 :     { dum = a[ll][icol];

	mov	ecx, DWORD PTR [ebx+eax*4]
	fld	QWORD PTR [ecx+edi*8]
	lea	ecx, DWORD PTR [ecx+edi*8]

; 1420 :       a[ll][icol] = 0.0;
; 1421 :       for ( l = 0 ; l < n ; l++ ) 

	xor	edx, edx
	fxch	ST(1)
	fst	QWORD PTR [ecx]
	mov	DWORD PTR _l$[ebp], edx
	cmp	esi, 4
	jl	$LC119@det_adjoin

; 1419 :     { dum = a[ll][icol];

	mov	edx, DWORD PTR [ebx+eax*4]
	mov	ecx, DWORD PTR [ebx+edi*4]
	lea	eax, DWORD PTR [ecx+24]

; 1422 :          a[ll][l] = a[ll][l]*piv*det - a[icol][l]*dum;

	sub	ecx, edx
	mov	DWORD PTR tv4702[ebp], ecx
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	mov	DWORD PTR tv4615[ebp], eax
	lea	eax, DWORD PTR [edx+8]
	inc	ecx
	lea	edx, DWORD PTR [ecx*4]
	mov	DWORD PTR _l$[ebp], edx
	mov	edx, DWORD PTR tv4615[ebp]
$LN120@det_adjoin:
	fld	QWORD PTR [eax-8]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(4)
	fmul	ST(0), ST(3)
	fld	QWORD PTR [edx-24]
	mov	edx, DWORD PTR tv4702[ebp]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax-32]
	fmul	ST(0), ST(4)
	fmul	ST(0), ST(3)
	fld	QWORD PTR [edx+eax-32]
	mov	edx, DWORD PTR tv4615[ebp]
	fmul	ST(0), ST(3)
	add	edx, 32					; 00000020H
	dec	ecx
	mov	DWORD PTR tv4615[ebp], edx
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [eax-24]
	fmul	ST(0), ST(4)
	fmul	ST(0), ST(3)
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax-24]
	fld	ST(3)
	fmul	QWORD PTR [eax-16]
	fmul	ST(0), ST(3)
	fld	QWORD PTR [edx-32]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN120@det_adjoin

; 1419 :     { dum = a[ll][icol];

	mov	eax, DWORD PTR _ll$[ebp]
	mov	edx, DWORD PTR _l$[ebp]
$LC119@det_adjoin:

; 1420 :       a[ll][icol] = 0.0;
; 1421 :       for ( l = 0 ; l < n ; l++ ) 

	cmp	edx, esi
	jge	SHORT $LN258@det_adjoin
	mov	ecx, DWORD PTR [ebx+eax*4]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	edx, DWORD PTR [ebx+edi*4]
	sub	edx, ecx
	mov	ecx, esi
	sub	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR tv4946[ebp], edx
$LC17@det_adjoin:

; 1422 :          a[ll][l] = a[ll][l]*piv*det - a[icol][l]*dum;

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(4)
	fmul	ST(0), ST(3)
	fld	QWORD PTR [edx+eax-8]
	fmul	ST(0), ST(3)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC17@det_adjoin

; 1420 :       a[ll][icol] = 0.0;
; 1421 :       for ( l = 0 ; l < n ; l++ ) 

	mov	eax, DWORD PTR _ll$[ebp]
$LN258@det_adjoin:
	fstp	ST(1)
$LN20@det_adjoin:

; 1417 :   for ( ll = 0  ; ll < n ; ll++ )

	inc	eax
	mov	DWORD PTR _ll$[ebp], eax
	cmp	eax, esi
	jl	$LN21@det_adjoin
$LN263@det_adjoin:

; 1423 :     }
; 1424 :   det *= piv;
; 1425 : 
; 1426 :   for ( l = n-1 ; l >= 0 ; l-- )

	mov	eax, DWORD PTR tv2554[ebp]
	fstp	ST(0)
	fmulp	ST(1), ST(0)
	mov	DWORD PTR _l$[ebp], eax
	fstp	QWORD PTR _det$[ebp]
	test	eax, eax
	js	$det_exit$90092
	mov	ecx, DWORD PTR _indxc$[ebp]
	mov	edx, DWORD PTR _indxr$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	sub	edx, ecx
$LL14@det_adjoin:

; 1427 :   { if ( indxr[l] != indxc[l] )

	mov	ecx, DWORD PTR [edx+eax]
	cmp	ecx, DWORD PTR [eax]
	je	$LN13@det_adjoin

; 1428 :       for ( k = 0 ; k < n ; k++ )

	xor	ecx, ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	esi, 4
	jl	$LC122@det_adjoin
	lea	edi, DWORD PTR [esi-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv5308[ebp], edi
	add	edi, edi
	add	edi, edi
	lea	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR _k$[ebp], edi
$LL123@det_adjoin:

; 1429 :         SWAP(a[k][indxr[l]],a[k][indxc[l]])

	mov	ebx, DWORD PTR [edx+eax]
	mov	edi, DWORD PTR [ecx-8]
	fld	QWORD PTR [edi+ebx*8]
	lea	ebx, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR tv5626[ebp], ebx
	mov	ebx, DWORD PTR [eax]
	fld	QWORD PTR [edi+ebx*8]
	mov	ebx, DWORD PTR tv5626[ebp]
	fstp	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [eax]
	add	ecx, 16					; 00000010H
	dec	DWORD PTR tv5308[ebp]
	fstp	QWORD PTR [edi+ebx*8]
	mov	ebx, DWORD PTR [edx+eax]
	mov	edi, DWORD PTR [ecx-20]
	fld	QWORD PTR [edi+ebx*8]
	lea	ebx, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR tv5676[ebp], ebx
	mov	ebx, DWORD PTR [eax]
	fld	QWORD PTR [edi+ebx*8]
	mov	ebx, DWORD PTR tv5676[ebp]
	fstp	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [eax]
	fstp	QWORD PTR [edi+ebx*8]
	mov	edi, DWORD PTR [ecx-16]
	mov	ebx, DWORD PTR [edx+eax]
	fld	QWORD PTR [edi+ebx*8]
	lea	ebx, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR tv5689[ebp], ebx
	mov	ebx, DWORD PTR [eax]
	fld	QWORD PTR [edi+ebx*8]
	mov	ebx, DWORD PTR tv5689[ebp]
	fstp	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [eax]
	fstp	QWORD PTR [edi+ebx*8]
	mov	edi, DWORD PTR [ecx-12]
	mov	ebx, DWORD PTR [edx+eax]
	fld	QWORD PTR [edi+ebx*8]
	lea	ebx, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR tv5702[ebp], ebx
	mov	ebx, DWORD PTR [eax]
	fld	QWORD PTR [edi+ebx*8]
	mov	ebx, DWORD PTR tv5702[ebp]
	fstp	QWORD PTR [ebx]
	mov	ebx, DWORD PTR [eax]
	fstp	QWORD PTR [edi+ebx*8]
	jne	$LL123@det_adjoin

; 1428 :       for ( k = 0 ; k < n ; k++ )

	mov	ebx, DWORD PTR _a$GSCopy$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
$LC122@det_adjoin:
	cmp	ecx, esi
	jge	SHORT $LN13@det_adjoin
	npad	1
$LC10@det_adjoin:

; 1429 :         SWAP(a[k][indxr[l]],a[k][indxc[l]])

	mov	ecx, DWORD PTR [ebx+ecx*4]
	mov	edi, DWORD PTR [edx+eax]
	fld	QWORD PTR [ecx+edi*8]
	lea	edi, DWORD PTR [ecx+edi*8]
	mov	DWORD PTR tv5720[ebp], edi
	mov	edi, DWORD PTR [eax]
	fld	QWORD PTR [ecx+edi*8]
	mov	edi, DWORD PTR tv5720[ebp]
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR [eax]
	fstp	QWORD PTR [ecx+edi*8]
	mov	ecx, DWORD PTR _k$[ebp]
	inc	ecx
	mov	DWORD PTR _k$[ebp], ecx
	cmp	ecx, esi
	jl	SHORT $LC10@det_adjoin
$LN13@det_adjoin:

; 1423 :     }
; 1424 :   det *= piv;
; 1425 : 
; 1426 :   for ( l = n-1 ; l >= 0 ; l-- )

	mov	ecx, DWORD PTR _l$[ebp]
	dec	ecx
	sub	eax, 4
	mov	DWORD PTR _l$[ebp], ecx
	test	ecx, ecx
	jns	$LL14@det_adjoin
$det_exit$90092:

; 1430 :   }
; 1431 : 
; 1432 : det_exit:
; 1433 :   if ( n > SMALL )

	cmp	esi, 10					; 0000000aH
	jle	SHORT $LN7@det_adjoin

; 1434 :   { free_ivector(ipiv,0,n-1);

	mov	esi, DWORD PTR tv2554[ebp]
	mov	edx, DWORD PTR _ipiv$[ebp]
	push	esi
	push	0
	push	edx
	call	_free_ivector

; 1435 :     free_ivector(indxr,0,n-1);

	mov	eax, DWORD PTR _indxr$[ebp]
	push	esi
	push	0
	push	eax
	call	_free_ivector

; 1436 :     free_ivector(indxc,0,n-1);

	mov	ecx, DWORD PTR _indxc$[ebp]
	push	esi
	push	0
	push	ecx
	call	_free_ivector
	add	esp, 36					; 00000024H
$LN7@det_adjoin:

; 1446 :   
; 1447 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fld	QWORD PTR _det$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_det_adjoint ENDP
_TEXT	ENDS
PUBLIC	_determinant
; Function compile flags: /Ogtp
;	COMDAT _determinant
_TEXT	SEGMENT
_a$ = 8							; size = 4
_n$ = 12						; size = 4
_determinant PROC					; COMDAT

; 1460 : {

	push	ebp
	mov	ebp, esp

; 1461 :   if ( n == 1 ) { return a[0][0];  }

	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, 1
	jne	SHORT $LN3@determinan
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax]
	fld	QWORD PTR [ecx]

; 1469 : }

	pop	ebp
	ret	0
$LN3@determinan:

; 1462 :   if ( n == 2 ) { return  a[0][0]*a[1][1] - a[0][1]*a[1][0]; }

	cmp	eax, 2
	jne	SHORT $LN2@determinan
	mov	ecx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	fld	QWORD PTR [eax+8]
	fmul	QWORD PTR [ecx]
	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR [eax]
	fsubp	ST(1), ST(0)

; 1469 : }

	pop	ebp
	ret	0
$LN2@determinan:

; 1463 :   if ( n == 3 )
; 1464 :      { return a[0][0]*(a[1][1]*a[2][2] - a[1][2]*a[2][1])
; 1465 :               - a[0][1]*(a[1][0]*a[2][2] - a[1][2]*a[2][0])
; 1466 :               + a[0][2]*(a[1][0]*a[2][1] - a[1][1]*a[2][0]);

	mov	edx, DWORD PTR _a$[ebp]
	cmp	eax, 3
	jne	SHORT $LN1@determinan
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [edx+4]
	fld	QWORD PTR [eax+16]
	fmul	QWORD PTR [ecx+8]
	mov	edx, DWORD PTR [edx]
	fld	QWORD PTR [ecx+16]
	fmul	QWORD PTR [eax+8]
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR [edx]
	fld	QWORD PTR [eax+16]
	fmul	QWORD PTR [ecx]
	fld	QWORD PTR [ecx+16]
	fmul	QWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR [edx+8]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [eax+8]
	fmul	QWORD PTR [ecx]
	fld	QWORD PTR [ecx+8]
	fmul	QWORD PTR [eax]
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR [edx+16]
	faddp	ST(1), ST(0)

; 1469 : }

	pop	ebp
	ret	0
$LN1@determinan:

; 1467 :      }
; 1468 :   return det_adjoint(a,n);  /* other cases */

	push	eax
	push	edx
	call	_det_adjoint
	add	esp, 8

; 1469 : }

	pop	ebp
	ret	0
_determinant ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_07FDEKEAMH@?$CF10?46f?5?$AA@		; `string'
PUBLIC	_print_matrix
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FDEKEAMH@?$CF10?46f?5?$AA@
CONST	SEGMENT
??_C@_07FDEKEAMH@?$CF10?46f?5?$AA@ DB '%10.6f ', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _print_matrix
_TEXT	SEGMENT
_a$ = 8							; size = 4
tv211 = 12						; size = 4
_rows$ = 12						; size = 4
_cols$ = 16						; size = 4
_print_matrix PROC					; COMDAT

; 1479 : {

	push	ebp
	mov	ebp, esp

; 1480 :   int i,j;
; 1481 : 
; 1482 :   for ( i = 0 ; i < rows ; i++ )

	mov	eax, DWORD PTR _rows$[ebp]
	test	eax, eax
	jle	$LN4@print_matr
	push	ebx
	mov	ebx, DWORD PTR _a$[ebp]
	push	esi
	push	edi
	mov	DWORD PTR tv211[ebp], eax
	npad	9
$LL15@print_matr:

; 1483 :     { msg[0] = 0;

	mov	eax, DWORD PTR _msg

; 1484 :       for ( j = 0 ; j < cols ; j++ )

	xor	esi, esi
	mov	BYTE PTR [eax], 0
	cmp	DWORD PTR _cols$[ebp], esi
	jle	SHORT $LN1@print_matr
	npad	1
$LL3@print_matr:

; 1485 :         sprintf(msg+strlen(msg),"%10.6f ",(DOUBLE)a[i][j]);

	mov	edx, DWORD PTR _msg
	mov	eax, edx
	lea	edi, DWORD PTR [eax+1]
	npad	5
$LL13@print_matr:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL13@print_matr
	mov	ecx, DWORD PTR [ebx]
	fld	QWORD PTR [ecx+esi*8]
	sub	esp, 8
	sub	eax, edi
	fstp	QWORD PTR [esp]
	add	eax, edx
	push	OFFSET ??_C@_07FDEKEAMH@?$CF10?46f?5?$AA@
	push	eax
	call	_sprintf
	inc	esi
	add	esp, 16					; 00000010H
	cmp	esi, DWORD PTR _cols$[ebp]
	jl	SHORT $LL3@print_matr
$LN1@print_matr:

; 1486 :       strcat(msg,"\n");

	mov	edi, DWORD PTR _msg
	dec	edi
$LL14@print_matr:
	mov	al, BYTE PTR [edi+1]
	inc	edi
	test	al, al
	jne	SHORT $LL14@print_matr
	mov	dx, WORD PTR ??_C@_01EEMJAFIK@?6?$AA@
	mov	WORD PTR [edi], dx

; 1487 :       outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 4
	add	ebx, 4
	dec	DWORD PTR tv211[ebp]
	jne	SHORT $LL15@print_matr
	pop	edi
	pop	esi
	pop	ebx
$LN4@print_matr:

; 1488 :     }
; 1489 : }

	pop	ebp
	ret	0
_print_matrix ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@GLMBAAL@Exterior?5product?5of?5?$CFd?5vectors?4?6@ ; `string'
PUBLIC	_exterior_product
EXTRN	_errmsg:BYTE
;	COMDAT ??_C@_0CB@GLMBAAL@Exterior?5product?5of?5?$CFd?5vectors?4?6@
CONST	SEGMENT
??_C@_0CB@GLMBAAL@Exterior?5product?5of?5?$CFd?5vectors?4?6@ DB 'Exterior'
	DB	' product of %d vectors.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _exterior_product
_TEXT	SEGMENT
tv4968 = -52						; size = 4
tv272 = -52						; size = 4
tv4539 = -48						; size = 4
tv3936 = -48						; size = 4
tv2462 = -48						; size = 4
tv3437 = -44						; size = 4
tv249 = -44						; size = 4
tv3442 = -40						; size = 4
tv3187 = -40						; size = 4
tv3170 = -36						; size = 4
tv665 = -36						; size = 4
tv3165 = -32						; size = 4
tv5107 = -28						; size = 4
tv4229 = -28						; size = 4
tv4996 = -24						; size = 4
tv3489 = -24						; size = 4
tv3727 = -20						; size = 4
_i3$ = -16						; size = 4
tv3008 = -12						; size = 4
tv2410 = -12						; size = 4
tv2780 = -8						; size = 4
_i2$ = -8						; size = 4
tv3000 = -4						; size = 4
_v$ = 8							; size = 4
_w$ = 12						; size = 4
tv4937 = 16						; size = 4
tv4490 = 16						; size = 4
tv2358 = 16						; size = 4
tv2217 = 16						; size = 4
_k$ = 16						; size = 4
_n$ = 20						; size = 4
_exterior_product PROC					; COMDAT

; 1503 : {

	push	ebp
	mov	ebp, esp

; 1504 :   /* anticipate only small k, so just brute force */
; 1505 :   int i1,i2,i3;
; 1506 : 
; 1507 :   switch ( k )

	mov	ecx, DWORD PTR _k$[ebp]
	sub	esp, 52					; 00000034H
	push	ebx
	mov	eax, ecx
	dec	eax
	push	esi
	push	edi
	je	$LN22@exterior_p
	dec	eax
	je	$LN18@exterior_p
	dec	eax
	je	SHORT $LN11@exterior_p

; 1526 :                break;
; 1527 : 
; 1528 :       default: sprintf(errmsg,"Exterior product of %d vectors.\n",k);

	push	ecx
	push	OFFSET ??_C@_0CB@GLMBAAL@Exterior?5product?5of?5?$CFd?5vectors?4?6@
	push	OFFSET _errmsg
	call	_sprintf

; 1529 :                kb_error(1207,errmsg,RECOVERABLE);

	push	1
	push	OFFSET _errmsg
	push	1207					; 000004b7H
	call	_kb_error
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebx

; 1530 : 
; 1531 :                break;
; 1532 :     }
; 1533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@exterior_p:

; 1515 :                break;
; 1516 : 
; 1517 :       case 3:  for ( i1 = 0 ; i1 < n ; i1++ )

	mov	esi, DWORD PTR _n$[ebp]
	test	esi, esi
	jle	$LN45@exterior_p
	mov	ebx, DWORD PTR _v$[ebp]
	mov	eax, 1
	lea	edx, DWORD PTR [esi-2]
	xor	ecx, ecx
	mov	DWORD PTR tv3936[ebp], eax
	mov	DWORD PTR tv4229[ebp], edx
	mov	DWORD PTR tv272[ebp], esi
	npad	5
$LL10@exterior_p:

; 1518 :                  for ( i2 = i1+1 ; i2 < n ; i2++ )

	cmp	eax, esi
	jge	$LN54@exterior_p
	mov	edi, DWORD PTR tv4229[ebp]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR tv3489[ebp], edx
	mov	DWORD PTR tv3727[ebp], edi
$LL7@exterior_p:

; 1519 :                    for ( i3 = i2+1 ; i3 < n ; i3++ )

	mov	DWORD PTR _i3$[ebp], edx
	cmp	edx, esi
	jge	$LN6@exterior_p
	cmp	DWORD PTR tv3727[ebp], 4
	jl	$LN50@exterior_p

; 1520 :                       *(w++) = v[0][i1]*v[1][i2]*v[2][i3]
; 1521 :                              + v[0][i2]*v[1][i3]*v[2][i1] 
; 1522 :                              + v[0][i3]*v[1][i1]*v[2][i2] 
; 1523 :                              - v[0][i1]*v[1][i3]*v[2][i2] 
; 1524 :                              - v[0][i3]*v[1][i2]*v[2][i1] 
; 1525 :                              - v[0][i2]*v[1][i1]*v[2][i3] ;

	mov	edx, DWORD PTR [ebx]
	mov	esi, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ebx+4]
	lea	edi, DWORD PTR [ebx+eax*8+8]
	mov	DWORD PTR tv2780[ebp], edi
	lea	edi, DWORD PTR [esi+eax*8+24]
	mov	DWORD PTR tv3000[ebp], edi
	lea	edi, DWORD PTR [edx+eax*8+16]
	mov	DWORD PTR tv3008[ebp], edi
	mov	edi, ebx
	sub	edi, edx
	mov	DWORD PTR tv3165[ebp], edi
	mov	DWORD PTR tv2217[ebp], ebx
	mov	edi, esi
	sub	edi, edx
	mov	DWORD PTR tv3170[ebp], edi
	mov	edi, DWORD PTR _n$[ebp]
	sub	ebx, esi
	mov	DWORD PTR tv3187[ebp], ebx
	mov	ebx, DWORD PTR tv3489[ebp]
	sub	edi, ebx
	sub	edi, 4
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv249[ebp], edi
	lea	edi, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR _i3$[ebp], edi
	mov	edi, DWORD PTR tv3008[ebp]
$LL49@exterior_p:
	mov	ebx, DWORD PTR tv2217[ebp]
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR tv3000[ebp]
	fmul	QWORD PTR [ecx+edx]
	fmul	QWORD PTR [ebx-16]
	mov	ebx, DWORD PTR tv2780[ebp]
	fld	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv2217[ebp]
	fmul	QWORD PTR [edx+eax*8]
	fmul	QWORD PTR [ecx+esi]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi-8]
	fmul	QWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR tv2780[ebp]
	fmul	QWORD PTR [esi+eax*8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv2217[ebp]
	fmul	QWORD PTR [ecx+edx]
	fmul	QWORD PTR [esi+eax*8]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ebx+eax*8]
	fmul	QWORD PTR [edi-8]
	fmul	QWORD PTR [ecx+esi]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR tv3000[ebp]
	fmul	QWORD PTR [edx+eax*8]
	fmul	QWORD PTR [ebx-16]
	mov	ebx, DWORD PTR _w$[ebp]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv3165[ebp]
	fld	QWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR tv2217[ebp]
	fmul	QWORD PTR [edx+eax*8]
	fmul	QWORD PTR [ecx+esi]
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR tv3170[ebp]
	fmul	QWORD PTR [ecx+edx]
	fmul	QWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR tv2217[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR tv3165[ebp]
	fmul	QWORD PTR [edi]
	fmul	QWORD PTR [esi+eax*8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR tv2217[ebp]
	fmul	QWORD PTR [ecx+edx]
	fmul	QWORD PTR [esi+eax*8]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ebx+eax*8]
	fmul	QWORD PTR [edi]
	fmul	QWORD PTR [ecx+esi]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR tv3170[ebp]
	fmul	QWORD PTR [edx+eax*8]
	fmul	QWORD PTR [edi+ebx]
	mov	edi, DWORD PTR _w$[ebp]
	mov	ebx, DWORD PTR tv3187[ebp]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [edi+8]
	mov	edi, DWORD PTR tv2217[ebp]
	fld	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR tv3000[ebp]
	fmul	QWORD PTR [ecx+edx]
	fmul	QWORD PTR [edi]
	fld	QWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR tv3008[ebp]
	fmul	QWORD PTR [edx+eax*8]
	fmul	QWORD PTR [ecx+esi]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR tv2217[ebp]
	fmul	QWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR tv3187[ebp]
	fmul	QWORD PTR [esi+eax*8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR tv2217[ebp]
	fmul	QWORD PTR [ecx+edx]
	mov	edi, DWORD PTR tv3008[ebp]
	add	edi, 32					; 00000020H
	mov	DWORD PTR tv3008[ebp], edi
	fmul	QWORD PTR [esi+eax*8]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ebx+eax*8]
	fmul	QWORD PTR [edi-24]
	fmul	QWORD PTR [ecx+esi]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR tv3000[ebp]
	fmul	QWORD PTR [edx+eax*8]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR _w$[ebp]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [ebx+16]
	mov	ebx, DWORD PTR tv2217[ebp]
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR tv3000[ebp]
	fmul	QWORD PTR [ecx+edx]
	fmul	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR tv2780[ebp]
	fld	QWORD PTR [ebx+24]
	mov	ebx, DWORD PTR tv2217[ebp]
	fmul	QWORD PTR [edx+eax*8]
	fmul	QWORD PTR [ecx+esi]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edi-16]
	fmul	QWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR tv2780[ebp]
	add	DWORD PTR tv2780[ebp], 32		; 00000020H
	fmul	QWORD PTR [esi+eax*8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+24]
	mov	ebx, DWORD PTR tv2217[ebp]
	fmul	QWORD PTR [ecx+edx]
	fmul	QWORD PTR [esi+eax*8]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ebx+eax*8]
	fmul	QWORD PTR [edi-16]
	fmul	QWORD PTR [ecx+esi]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR tv3000[ebp]
	fmul	QWORD PTR [edx+eax*8]
	add	DWORD PTR tv3000[ebp], 32		; 00000020H
	fmul	QWORD PTR [ebx+8]
	mov	ebx, DWORD PTR _w$[ebp]
	add	ebx, 32					; 00000020H
	dec	DWORD PTR tv249[ebp]
	fsubp	ST(1), ST(0)
	mov	DWORD PTR _w$[ebp], ebx
	fstp	QWORD PTR [ebx-8]
	jne	$LL49@exterior_p
	mov	edx, DWORD PTR _i3$[ebp]
	mov	ebx, DWORD PTR _v$[ebp]
	mov	esi, DWORD PTR _n$[ebp]
$LN50@exterior_p:

; 1519 :                    for ( i3 = i2+1 ; i3 < n ; i3++ )

	cmp	edx, esi
	jge	$LN6@exterior_p
	mov	esi, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ebx+4]
	mov	DWORD PTR tv2358[ebp], ebx
	sub	ebx, esi
	mov	DWORD PTR tv3437[ebp], ebx
	mov	ebx, edi
	sub	ebx, esi
	mov	DWORD PTR tv3442[ebp], ebx
	mov	ebx, DWORD PTR _n$[ebp]
	sub	ebx, DWORD PTR _i3$[ebp]
	lea	edx, DWORD PTR [esi+edx*8]
	mov	DWORD PTR tv665[ebp], ebx
$LC4@exterior_p:

; 1520 :                       *(w++) = v[0][i1]*v[1][i2]*v[2][i3]
; 1521 :                              + v[0][i2]*v[1][i3]*v[2][i1] 
; 1522 :                              + v[0][i3]*v[1][i1]*v[2][i2] 
; 1523 :                              - v[0][i1]*v[1][i3]*v[2][i2] 
; 1524 :                              - v[0][i3]*v[1][i2]*v[2][i1] 
; 1525 :                              - v[0][i2]*v[1][i1]*v[2][i3] ;

	mov	ebx, DWORD PTR tv3437[ebp]
	fld	QWORD PTR [ebx+edx]
	mov	ebx, DWORD PTR tv2358[ebp]
	fmul	QWORD PTR [esi+eax*8]
	add	edx, 8
	fmul	QWORD PTR [ecx+edi]
	fld	QWORD PTR [ebx+eax*8]
	mov	ebx, DWORD PTR tv3442[ebp]
	fmul	QWORD PTR [ecx+esi]
	fmul	QWORD PTR [ebx+edx-8]
	mov	ebx, DWORD PTR tv2358[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx-8]
	fmul	QWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR tv3437[ebp]
	fmul	QWORD PTR [edi+eax*8]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx+edx-8]
	mov	ebx, DWORD PTR tv2358[ebp]
	fmul	QWORD PTR [ecx+esi]
	fmul	QWORD PTR [edi+eax*8]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ebx+eax*8]
	fmul	QWORD PTR [edx-8]
	fmul	QWORD PTR [ecx+edi]
	fsubp	ST(1), ST(0)
	fld	QWORD PTR [ecx+ebx]
	mov	ebx, DWORD PTR tv3442[ebp]
	fmul	QWORD PTR [esi+eax*8]
	fmul	QWORD PTR [ebx+edx-8]
	mov	ebx, DWORD PTR _w$[ebp]
	add	ebx, 8
	dec	DWORD PTR tv665[ebp]
	fsubp	ST(1), ST(0)
	mov	DWORD PTR _w$[ebp], ebx
	fstp	QWORD PTR [ebx-8]
	jne	SHORT $LC4@exterior_p

; 1519 :                    for ( i3 = i2+1 ; i3 < n ; i3++ )

	mov	esi, DWORD PTR _n$[ebp]
	mov	ebx, DWORD PTR _v$[ebp]
$LN6@exterior_p:

; 1518 :                  for ( i2 = i1+1 ; i2 < n ; i2++ )

	mov	edx, DWORD PTR tv3489[ebp]
	mov	edi, 1
	sub	DWORD PTR tv3727[ebp], edi
	add	eax, edi
	add	edx, edi
	mov	DWORD PTR tv3489[ebp], edx
	cmp	eax, esi
	jl	$LL7@exterior_p
	mov	eax, DWORD PTR tv3936[ebp]
	jmp	SHORT $LN9@exterior_p
$LN54@exterior_p:
	mov	edi, 1
$LN9@exterior_p:

; 1515 :                break;
; 1516 : 
; 1517 :       case 3:  for ( i1 = 0 ; i1 < n ; i1++ )

	sub	DWORD PTR tv4229[ebp], edi
	add	eax, edi
	add	ecx, 8
	sub	DWORD PTR tv272[ebp], edi
	mov	DWORD PTR tv3936[ebp], eax
	jne	$LL10@exterior_p
	pop	edi
	pop	esi
	pop	ebx

; 1530 : 
; 1531 :                break;
; 1532 :     }
; 1533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@exterior_p:

; 1510 :                break;
; 1511 : 
; 1512 :       case 2:  for ( i1 = 0 ; i1 < n ; i1++ )

	mov	esi, DWORD PTR _n$[ebp]
	test	esi, esi
	jle	$LN45@exterior_p
	mov	edx, DWORD PTR _w$[ebp]
	lea	ecx, DWORD PTR [esi-1]
	mov	ebx, 1
	mov	DWORD PTR tv5107[ebp], ecx
	mov	ecx, DWORD PTR _v$[ebp]
	xor	eax, eax
	mov	DWORD PTR tv4996[ebp], ebx
	mov	DWORD PTR tv4968[ebp], esi
	npad	8
$LL17@exterior_p:

; 1513 :                  for ( i2 = i1+1 ; i2 < n ; i2++ )

	mov	DWORD PTR _i2$[ebp], ebx
	cmp	ebx, esi
	jge	$LN16@exterior_p
	cmp	DWORD PTR tv5107[ebp], 4
	jl	$LC43@exterior_p

; 1514 :                     *(w++) = v[0][i1]*v[1][i2] - v[0][i2]*v[1][i1];

	mov	edi, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edi+32]
	mov	DWORD PTR tv2410[ebp], edi
	sub	edi, esi
	mov	DWORD PTR tv4539[ebp], edi
	mov	edi, DWORD PTR _n$[ebp]
	sub	edi, ebx
	sub	edi, 4
	shr	edi, 2
	inc	edi
	lea	ebx, DWORD PTR [ebx+edi*4]
	mov	DWORD PTR tv4490[ebp], ecx
	lea	ecx, DWORD PTR [eax+esi+16]
	mov	DWORD PTR _i2$[ebp], ebx
	npad	1
$LL44@exterior_p:
	mov	ebx, DWORD PTR tv4490[ebp]
	fld	QWORD PTR [ebx-24]
	mov	ebx, DWORD PTR tv2410[ebp]
	fmul	QWORD PTR [eax+esi]
	add	edx, 32					; 00000020H
	fld	QWORD PTR [ecx-8]
	add	ecx, 32					; 00000020H
	fmul	QWORD PTR [eax+ebx]
	mov	ebx, DWORD PTR tv4539[ebp]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [edx-32]
	fld	QWORD PTR [ebx+ecx-32]
	mov	ebx, DWORD PTR tv2410[ebp]
	fmul	QWORD PTR [eax+esi]
	fld	QWORD PTR [eax+ebx]
	mov	ebx, DWORD PTR tv4490[ebp]
	fmul	QWORD PTR [ecx-32]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [edx-24]
	fld	QWORD PTR [ebx-8]
	mov	ebx, DWORD PTR tv2410[ebp]
	fmul	QWORD PTR [eax+esi]
	fld	QWORD PTR [ecx-24]
	fmul	QWORD PTR [eax+ebx]
	mov	ebx, DWORD PTR tv4490[ebp]
	add	DWORD PTR tv4490[ebp], 32		; 00000020H
	dec	edi
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [edx-16]
	fld	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv2410[ebp]
	fmul	QWORD PTR [eax+esi]
	fld	QWORD PTR [ecx-16]
	fmul	QWORD PTR [eax+ebx]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [edx-8]
	jne	SHORT $LL44@exterior_p
	mov	ecx, DWORD PTR _v$[ebp]
	mov	ebx, DWORD PTR tv4996[ebp]
	mov	esi, DWORD PTR _n$[ebp]
$LC43@exterior_p:

; 1513 :                  for ( i2 = i1+1 ; i2 < n ; i2++ )

	cmp	DWORD PTR _i2$[ebp], esi
	jge	SHORT $LN16@exterior_p
	mov	ebx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _i2$[ebp]
	mov	DWORD PTR tv2462[ebp], ebx
	sub	ebx, edi
	sub	esi, DWORD PTR _i2$[ebp]
	lea	ecx, DWORD PTR [edi+ecx*8]
	mov	DWORD PTR tv4937[ebp], ebx
	npad	3
$LC14@exterior_p:

; 1514 :                     *(w++) = v[0][i1]*v[1][i2] - v[0][i2]*v[1][i1];

	mov	ebx, DWORD PTR tv4937[ebp]
	fld	QWORD PTR [ebx+ecx]
	mov	ebx, DWORD PTR tv2462[ebp]
	fmul	QWORD PTR [eax+edi]
	add	edx, 8
	fld	QWORD PTR [eax+ebx]
	add	ecx, 8
	dec	esi
	fmul	QWORD PTR [ecx-8]
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR [edx-8]
	jne	SHORT $LC14@exterior_p

; 1513 :                  for ( i2 = i1+1 ; i2 < n ; i2++ )

	mov	ecx, DWORD PTR _v$[ebp]
	mov	ebx, DWORD PTR tv4996[ebp]
	mov	esi, DWORD PTR _n$[ebp]
$LN16@exterior_p:

; 1510 :                break;
; 1511 : 
; 1512 :       case 2:  for ( i1 = 0 ; i1 < n ; i1++ )

	dec	DWORD PTR tv5107[ebp]
	inc	ebx
	add	eax, 8
	dec	DWORD PTR tv4968[ebp]
	mov	DWORD PTR tv4996[ebp], ebx
	jne	$LL17@exterior_p
	pop	edi
	pop	esi
	pop	ebx

; 1530 : 
; 1531 :                break;
; 1532 :     }
; 1533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@exterior_p:

; 1508 :     {
; 1509 :       case 1:  for ( i1 = 0 ; i1 < n ; i1++ ) *(w++) = v[0][i1];

	mov	esi, DWORD PTR _n$[ebp]
	mov	ebx, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _w$[ebp]
	xor	edi, edi
	cmp	esi, 4
	jl	SHORT $LC46@exterior_p
	mov	eax, DWORD PTR [ebx]
	lea	edx, DWORD PTR [esi-4]
	shr	edx, 2
	add	eax, 16					; 00000010H
	inc	edx
	lea	edi, DWORD PTR [edx*4]
$LL47@exterior_p:
	fld	QWORD PTR [eax-16]
	add	ecx, 32					; 00000020H
	fstp	QWORD PTR [ecx-32]
	add	eax, 32					; 00000020H
	dec	edx
	fld	QWORD PTR [eax-40]
	fstp	QWORD PTR [ecx-24]
	fld	QWORD PTR [eax-32]
	fstp	QWORD PTR [ecx-16]
	fld	QWORD PTR [eax-24]
	fstp	QWORD PTR [ecx-8]
	jne	SHORT $LL47@exterior_p
$LC46@exterior_p:
	cmp	edi, esi
	jge	SHORT $LN45@exterior_p
	mov	edx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [edx+edi*8]
	sub	esi, edi
$LC21@exterior_p:
	fld	QWORD PTR [eax]
	add	ecx, 8
	fstp	QWORD PTR [ecx-8]
	add	eax, 8
	dec	esi
	jne	SHORT $LC21@exterior_p
$LN45@exterior_p:
	pop	edi
	pop	esi
	pop	ebx

; 1530 : 
; 1531 :                break;
; 1532 :     }
; 1533 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_exterior_product ENDP
_TEXT	ENDS
PUBLIC	_ker$GSCopy$
PUBLIC	_a$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_kernel_basis
; Function compile flags: /Ogtp
;	COMDAT _kernel_basis
_TEXT	SEGMENT
tv1126 = -108						; size = 4
_ker$GSCopy$ = -104					; size = 4
tv2824 = -100						; size = 4
tv1099 = -100						; size = 4
tv2819 = -96						; size = 4
_a$GSCopy$ = -96					; size = 4
tv2378 = -92						; size = 4
_i$ = -92						; size = 4
_n$ = -88						; size = 4
_piv$90224 = -88					; size = 4
_pivrow$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_ker$ = 12						; size = 4
_imax$ = 16						; size = 4
_jmax$ = 20						; size = 4
_kernel_basis PROC					; COMDAT

; 1546 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	edx, DWORD PTR _a$[ebp]

; 1577 :     }
; 1578 :   }         
; 1579 : 
; 1580 :   /* now find kernel basis */
; 1581 :   for ( j = 0, n = 0 ; j < jmax ; j++ )

	mov	eax, DWORD PTR _ker$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _jmax$[ebp]
	push	edi
	mov	DWORD PTR _a$GSCopy$[ebp], edx
	mov	DWORD PTR _ker$GSCopy$[ebp], eax
	test	esi, esi
	jle	SHORT $LN80@kernel_bas

; 1547 :   int i,j,k;
; 1548 :   int pivrow[20];    /* pivot row in column */
; 1549 :   int n; /* nullity */
; 1550 : 
; 1551 :   for ( j = 0 ; j < jmax ; j++ ) pivrow[j] = -1;  /* mark as no pivot in col */

	mov	ecx, esi
	or	eax, -1
	lea	edi, DWORD PTR _pivrow$[ebp]
	rep stosd
$LN80@kernel_bas:

; 1552 : 
; 1553 :   /* get row echelon form, pivot largest in each row */
; 1554 :   for ( i = 0 ; i < imax ; i++ )

	fldz
	xor	ebx, ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	DWORD PTR _imax$[ebp], ebx
	jle	$LN84@kernel_bas
$LN87@kernel_bas:

; 1555 :   { int piv = -1;

	or	eax, -1

; 1556 :     REAL b,big,p;
; 1557 : 
; 1558 :     /* find largest element in row */
; 1559 :     big = 0.0;

	fld	ST(0)

; 1560 :     for ( j = 0 ; j < jmax ; j++ )

	xor	ecx, ecx
	mov	DWORD PTR _piv$90224[ebp], eax
	cmp	esi, 4
	jl	SHORT $LN81@kernel_bas

; 1555 :   { int piv = -1;

	lea	edi, DWORD PTR [esi-3]
	mov	esi, DWORD PTR [edx+ebx*4]
	add	esi, 16					; 00000010H

; 1560 :     for ( j = 0 ; j < jmax ; j++ )

$LN57@kernel_bas:

; 1561 :       if ( fabs(a[i][j]) > big )

	fld	QWORD PTR [esi-16]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN96@kernel_bas

; 1562 :       { big = fabs(a[i][j]);
; 1563 :         piv = j;

	fstp	ST(1)
	mov	DWORD PTR _piv$90224[ebp], ecx
	jmp	SHORT $LN53@kernel_bas
$LN96@kernel_bas:
	fstp	ST(0)
$LN53@kernel_bas:

; 1561 :       if ( fabs(a[i][j]) > big )

	fld	QWORD PTR [esi-8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN99@kernel_bas

; 1555 :   { int piv = -1;

	lea	eax, DWORD PTR [ecx+1]
	fstp	ST(1)
	mov	DWORD PTR _piv$90224[ebp], eax
	jmp	SHORT $LN54@kernel_bas
$LN99@kernel_bas:
	fstp	ST(0)
$LN54@kernel_bas:

; 1561 :       if ( fabs(a[i][j]) > big )

	fld	QWORD PTR [esi]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN102@kernel_bas

; 1555 :   { int piv = -1;

	lea	eax, DWORD PTR [ecx+2]
	fstp	ST(1)
	mov	DWORD PTR _piv$90224[ebp], eax
	jmp	SHORT $LN55@kernel_bas
$LN102@kernel_bas:
	fstp	ST(0)
$LN55@kernel_bas:

; 1561 :       if ( fabs(a[i][j]) > big )

	fld	QWORD PTR [esi+8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN105@kernel_bas

; 1555 :   { int piv = -1;

	lea	eax, DWORD PTR [ecx+3]
	fstp	ST(1)
	mov	DWORD PTR _piv$90224[ebp], eax
	jmp	SHORT $LN56@kernel_bas
$LN105@kernel_bas:
	fstp	ST(0)
$LN56@kernel_bas:
	add	ecx, 4
	add	esi, 32					; 00000020H
	cmp	ecx, edi
	jl	SHORT $LN57@kernel_bas
	mov	esi, DWORD PTR _jmax$[ebp]
	mov	eax, DWORD PTR _piv$90224[ebp]
$LN81@kernel_bas:

; 1560 :     for ( j = 0 ; j < jmax ; j++ )

	cmp	ecx, esi
	jge	SHORT $LN110@kernel_bas
	mov	eax, DWORD PTR [edx+ebx*4]
	lea	esi, DWORD PTR [eax+ecx*8]
$LC26@kernel_bas:

; 1561 :       if ( fabs(a[i][j]) > big )

	fld	QWORD PTR [esi]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN114@kernel_bas

; 1562 :       { big = fabs(a[i][j]);
; 1563 :         piv = j;

	fstp	ST(1)
	mov	DWORD PTR _piv$90224[ebp], ecx
	jmp	SHORT $LN25@kernel_bas
$LN114@kernel_bas:
	fstp	ST(0)
$LN25@kernel_bas:
	inc	ecx

; 1560 :     for ( j = 0 ; j < jmax ; j++ )

	add	esi, 8
	cmp	ecx, DWORD PTR _jmax$[ebp]
	jl	SHORT $LC26@kernel_bas
	mov	esi, DWORD PTR _jmax$[ebp]
	mov	eax, DWORD PTR _piv$90224[ebp]
$LN110@kernel_bas:
	fstp	ST(0)

; 1564 :       }
; 1565 :     if ( piv == -1 ) continue; /* row of zeros */

	cmp	eax, -1
	je	$LN28@kernel_bas

; 1567 : 
; 1568 :     /* pivot step */
; 1569 :     p = a[i][piv];

	mov	esi, DWORD PTR [edx+ebx*4]

; 1570 :     for ( j = 0 ; j < jmax ; j++ )

	mov	ecx, DWORD PTR _jmax$[ebp]
	fld	QWORD PTR [esi+eax*8]
	xor	edi, edi
	mov	DWORD PTR _pivrow$[ebp+eax*4], ebx
	mov	DWORD PTR tv1099[ebp], esi
	cmp	ecx, 4
	jl	SHORT $LN82@kernel_bas

; 1566 :     pivrow[piv] = i;

	add	ecx, -4					; fffffffcH
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [esi+16]
	lea	edi, DWORD PTR [ecx*4]

; 1570 :     for ( j = 0 ; j < jmax ; j++ )

$LN60@kernel_bas:

; 1571 :       a[i][j] /= p;

	fld	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	ecx
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax-48]
	fld	QWORD PTR [eax-40]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax-32]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [eax-24]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN60@kernel_bas

; 1566 :     pivrow[piv] = i;

	mov	ecx, DWORD PTR _jmax$[ebp]
$LN82@kernel_bas:

; 1570 :     for ( j = 0 ; j < jmax ; j++ )

	cmp	edi, ecx
	jge	SHORT $LN131@kernel_bas
	lea	eax, DWORD PTR [esi+edi*8]
	sub	ecx, edi
$LC21@kernel_bas:

; 1571 :       a[i][j] /= p;

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	ecx
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC21@kernel_bas
$LN131@kernel_bas:

; 1570 :     for ( j = 0 ; j < jmax ; j++ )

	fstp	ST(0)

; 1572 :     for ( k = 0 ; k < imax ; k++ )

	xor	ebx, ebx
$LN18@kernel_bas:

; 1573 :     { if ( k == i ) continue;

	cmp	ebx, DWORD PTR _i$[ebp]
	je	$LN17@kernel_bas

; 1574 :       b = a[k][piv];

	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	eax, DWORD PTR _piv$90224[ebp]
	fld	QWORD PTR [ecx+eax*8]

; 1575 :       for ( j = 0 ; j < jmax ; j++ )

	xor	edi, edi
	cmp	DWORD PTR _jmax$[ebp], 4
	jl	SHORT $LC62@kernel_bas

; 1574 :       b = a[k][piv];

	lea	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [esi+24]

; 1576 :            a[k][j] -= b*a[i][j];

	sub	esi, ecx
	mov	ecx, DWORD PTR _jmax$[ebp]
	add	ecx, -4					; fffffffcH
	shr	ecx, 2
	inc	ecx
	lea	edi, DWORD PTR [ecx*4]
$LN63@kernel_bas:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	dec	ecx
	fsubr	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax+esi-32]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	ST(0)
	fmul	QWORD PTR [edx-32]
	fsubr	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN63@kernel_bas

; 1574 :       b = a[k][piv];

	mov	esi, DWORD PTR tv1099[ebp]
	mov	edx, DWORD PTR _a$GSCopy$[ebp]
$LC62@kernel_bas:

; 1575 :       for ( j = 0 ; j < jmax ; j++ )

	cmp	edi, DWORD PTR _jmax$[ebp]
	jge	SHORT $LN143@kernel_bas
	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	edx, esi
	lea	eax, DWORD PTR [ecx+edi*8]
	sub	edx, ecx
	mov	ecx, DWORD PTR _jmax$[ebp]
	sub	ecx, edi
$LC14@kernel_bas:

; 1576 :            a[k][j] -= b*a[i][j];

	fld	QWORD PTR [edx+eax]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC14@kernel_bas

; 1575 :       for ( j = 0 ; j < jmax ; j++ )

	mov	edx, DWORD PTR _a$GSCopy$[ebp]
$LN143@kernel_bas:
	fstp	ST(0)
$LN17@kernel_bas:

; 1572 :     for ( k = 0 ; k < imax ; k++ )

	inc	ebx
	cmp	ebx, DWORD PTR _imax$[ebp]
	jl	$LN18@kernel_bas
	mov	ebx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _jmax$[ebp]
$LN28@kernel_bas:

; 1552 : 
; 1553 :   /* get row echelon form, pivot largest in each row */
; 1554 :   for ( i = 0 ; i < imax ; i++ )

	inc	ebx
	mov	DWORD PTR _i$[ebp], ebx
	cmp	ebx, DWORD PTR _imax$[ebp]
	jl	$LN87@kernel_bas
$LN84@kernel_bas:

; 1577 :     }
; 1578 :   }         
; 1579 : 
; 1580 :   /* now find kernel basis */
; 1581 :   for ( j = 0, n = 0 ; j < jmax ; j++ )

	xor	eax, eax
	xor	edi, edi
	mov	DWORD PTR _n$[ebp], eax
	test	esi, esi
	jle	$LN151@kernel_bas
	fld1
$LN88@kernel_bas:

; 1582 :   { if ( pivrow[j] >= 0 ) continue;  /* column has leading 1 */

	cmp	DWORD PTR _pivrow$[ebp+edi*4], 0
	jge	$LN10@kernel_bas

; 1583 :     /* column j is parameter column */
; 1584 :     for ( k = 0 ; k < jmax ; k++ )

	xor	ebx, ebx
	cmp	esi, 4
	jl	$LC65@kernel_bas
	add	esi, -3					; fffffffdH
	mov	DWORD PTR tv1126[ebp], esi
	mov	esi, DWORD PTR _ker$GSCopy$[ebp]
	lea	eax, DWORD PTR _pivrow$[ebp]
	sub	eax, esi
	mov	DWORD PTR tv2819[ebp], eax
	lea	eax, DWORD PTR _pivrow$[ebp+4]
	sub	eax, esi
	mov	DWORD PTR tv2378[ebp], 2
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR tv2824[ebp], eax
$LN78@kernel_bas:

; 1585 :     { if ( pivrow[k] >= 0 )

	mov	eax, DWORD PTR _n$[ebp]
	mov	esi, DWORD PTR _pivrow$[ebp+ebx*4]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	test	esi, esi
	js	SHORT $LN66@kernel_bas

; 1586 :          ker[k][n] = -a[pivrow[k]][j];

	mov	esi, DWORD PTR [edx+esi*4]
	fld	QWORD PTR [esi+edi*8]
	mov	esi, DWORD PTR [ecx-8]
	fchs
	fstp	QWORD PTR [eax+esi]
	jmp	SHORT $LN68@kernel_bas
$LN66@kernel_bas:

; 1588 :          ker[k][n] = 1.0;

	mov	esi, DWORD PTR [ecx-8]
	cmp	ebx, edi
	jne	SHORT $LN67@kernel_bas
	fst	QWORD PTR [eax+esi]
	jmp	SHORT $LN68@kernel_bas
$LN67@kernel_bas:

; 1589 :       else ker[k][n] = 0.0;

	fxch	ST(1)
	fst	QWORD PTR [eax+esi]
	fxch	ST(1)
$LN68@kernel_bas:

; 1585 :     { if ( pivrow[k] >= 0 )

	mov	esi, DWORD PTR _pivrow$[ebp+ebx*4+4]
	test	esi, esi
	js	SHORT $LN69@kernel_bas

; 1586 :          ker[k][n] = -a[pivrow[k]][j];

	mov	esi, DWORD PTR [edx+esi*4]
	fld	QWORD PTR [esi+edi*8]
	mov	esi, DWORD PTR [ecx-4]
	fchs
	fstp	QWORD PTR [eax+esi]
	jmp	SHORT $LN71@kernel_bas
$LN69@kernel_bas:

; 1583 :     /* column j is parameter column */
; 1584 :     for ( k = 0 ; k < jmax ; k++ )

	mov	esi, DWORD PTR tv2378[ebp]
	dec	esi

; 1587 :       else if ( k == j )

	cmp	esi, edi

; 1588 :          ker[k][n] = 1.0;

	mov	esi, DWORD PTR [ecx-4]
	jne	SHORT $LN70@kernel_bas
	fst	QWORD PTR [eax+esi]
	jmp	SHORT $LN71@kernel_bas
$LN70@kernel_bas:

; 1589 :       else ker[k][n] = 0.0;

	fxch	ST(1)
	fst	QWORD PTR [eax+esi]
	fxch	ST(1)
$LN71@kernel_bas:

; 1585 :     { if ( pivrow[k] >= 0 )

	mov	esi, DWORD PTR tv2819[ebp]
	mov	esi, DWORD PTR [esi+ecx]
	test	esi, esi
	js	SHORT $LN72@kernel_bas

; 1586 :          ker[k][n] = -a[pivrow[k]][j];

	mov	esi, DWORD PTR [edx+esi*4]
	fld	QWORD PTR [esi+edi*8]
	mov	esi, DWORD PTR [ecx]
	fchs
	fstp	QWORD PTR [eax+esi]
	jmp	SHORT $LN74@kernel_bas
$LN72@kernel_bas:

; 1588 :          ker[k][n] = 1.0;

	mov	esi, DWORD PTR [ecx]
	cmp	DWORD PTR tv2378[ebp], edi
	jne	SHORT $LN73@kernel_bas
	fst	QWORD PTR [eax+esi]
	jmp	SHORT $LN74@kernel_bas
$LN73@kernel_bas:

; 1589 :       else ker[k][n] = 0.0;

	fxch	ST(1)
	fst	QWORD PTR [eax+esi]
	fxch	ST(1)
$LN74@kernel_bas:

; 1585 :     { if ( pivrow[k] >= 0 )

	mov	esi, DWORD PTR tv2824[ebp]
	mov	esi, DWORD PTR [esi+ecx]
	test	esi, esi
	js	SHORT $LN75@kernel_bas

; 1586 :          ker[k][n] = -a[pivrow[k]][j];

	mov	esi, DWORD PTR [edx+esi*4]
	fld	QWORD PTR [esi+edi*8]
	mov	esi, DWORD PTR [ecx+4]
	fchs
	fstp	QWORD PTR [eax+esi]
	jmp	SHORT $LN77@kernel_bas
$LN75@kernel_bas:

; 1583 :     /* column j is parameter column */
; 1584 :     for ( k = 0 ; k < jmax ; k++ )

	mov	esi, DWORD PTR tv2378[ebp]
	inc	esi

; 1587 :       else if ( k == j )

	cmp	esi, edi

; 1588 :          ker[k][n] = 1.0;

	mov	esi, DWORD PTR [ecx+4]
	jne	SHORT $LN76@kernel_bas
	fst	QWORD PTR [eax+esi]
	jmp	SHORT $LN77@kernel_bas
$LN76@kernel_bas:

; 1589 :       else ker[k][n] = 0.0;

	fxch	ST(1)
	fst	QWORD PTR [eax+esi]
	fxch	ST(1)
$LN77@kernel_bas:

; 1583 :     /* column j is parameter column */
; 1584 :     for ( k = 0 ; k < jmax ; k++ )

	add	DWORD PTR tv2378[ebp], 4
	add	ebx, 4
	add	ecx, 16					; 00000010H
	cmp	ebx, DWORD PTR tv1126[ebp]
	jl	$LN78@kernel_bas
	mov	esi, DWORD PTR _jmax$[ebp]
$LC65@kernel_bas:
	cmp	ebx, esi
	jge	SHORT $LN64@kernel_bas
	mov	esi, DWORD PTR _ker$GSCopy$[ebp]
	lea	eax, DWORD PTR _pivrow$[ebp]
	sub	eax, esi
	lea	ecx, DWORD PTR [esi+ebx*4]
	mov	DWORD PTR tv2819[ebp], eax
	jmp	SHORT $LC7@kernel_bas
$LN86@kernel_bas:
	mov	eax, DWORD PTR tv2819[ebp]
$LC7@kernel_bas:

; 1585 :     { if ( pivrow[k] >= 0 )

	mov	esi, DWORD PTR [ecx+eax]
	test	esi, esi
	js	SHORT $LN4@kernel_bas

; 1586 :          ker[k][n] = -a[pivrow[k]][j];

	mov	eax, DWORD PTR [edx+esi*4]
	fld	QWORD PTR [eax+edi*8]
	mov	eax, DWORD PTR [ecx]
	mov	esi, DWORD PTR _n$[ebp]
	fchs
	fstp	QWORD PTR [eax+esi*8]
	jmp	SHORT $LN6@kernel_bas
$LN4@kernel_bas:

; 1588 :          ker[k][n] = 1.0;

	mov	eax, DWORD PTR [ecx]
	mov	esi, DWORD PTR _n$[ebp]
	cmp	ebx, edi
	jne	SHORT $LN2@kernel_bas
	fst	QWORD PTR [eax+esi*8]
	jmp	SHORT $LN6@kernel_bas
$LN2@kernel_bas:

; 1589 :       else ker[k][n] = 0.0;

	fxch	ST(1)
	fst	QWORD PTR [eax+esi*8]
	fxch	ST(1)
$LN6@kernel_bas:

; 1583 :     /* column j is parameter column */
; 1584 :     for ( k = 0 ; k < jmax ; k++ )

	inc	ebx
	add	ecx, 4
	cmp	ebx, DWORD PTR _jmax$[ebp]
	jl	SHORT $LN86@kernel_bas
	mov	esi, DWORD PTR _jmax$[ebp]
$LN64@kernel_bas:

; 1590 :     }
; 1591 :     n++;

	mov	eax, DWORD PTR _n$[ebp]
	inc	eax
	mov	DWORD PTR _n$[ebp], eax
$LN10@kernel_bas:

; 1577 :     }
; 1578 :   }         
; 1579 : 
; 1580 :   /* now find kernel basis */
; 1581 :   for ( j = 0, n = 0 ; j < jmax ; j++ )

	inc	edi
	cmp	edi, esi
	jl	$LN88@kernel_bas
	fstp	ST(0)
$LN151@kernel_bas:

; 1592 :   }
; 1593 :   return n; /* nullity */
; 1594 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(0)
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_kernel_basis ENDP
_TEXT	ENDS
PUBLIC	_imax$GSCopy$
PUBLIC	_a$GSCopy$
PUBLIC	_ker$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_kernel_basis_rows
EXTRN	_web:BYTE
; Function compile flags: /Ogtp
;	COMDAT _kernel_basis_rows
_TEXT	SEGMENT
_ker$GSCopy$ = -200					; size = 4
_detsign$ = -196					; size = 4
tv3355 = -192						; size = 4
tv2463 = -192						; size = 4
_a$GSCopy$ = -188					; size = 4
tv2600 = -184						; size = 4
_piv$90276 = -184					; size = 4
tv3219 = -180						; size = 4
_i$ = -180						; size = 4
_imax$GSCopy$ = -176					; size = 4
_sign$90299 = -176					; size = 4
tv2428 = -172						; size = 4
_n$ = -172						; size = 4
tv3413 = -168						; size = 4
tv3409 = -168						; size = 4
tv3405 = -168						; size = 4
tv3401 = -168						; size = 4
tv3397 = -168						; size = 4
tv2508 = -168						; size = 4
tv2433 = -168						; size = 4
_pivcol$ = -164						; size = 80
_pivrow$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_ker$ = 12						; size = 4
_imax$ = 16						; size = 4
_jmax$ = 20						; size = 4
_kernel_basis_rows PROC					; COMDAT

; 1609 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, DWORD PTR _ker$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _imax$[ebp]
	push	ebx

; 1610 :   int i,j,k;
; 1611 :   int pivrow[20];    /* pivot row in column */
; 1612 :   int pivcol[20];    /* pivot column  in row */
; 1613 :   int n; /* nullity */
; 1614 :   int  detsign=1;  /* to try to keep orientation of normal positive */

	mov	DWORD PTR _ker$GSCopy$[ebp], ecx

; 1615 : 
; 1616 :   for ( j = 0 ; j < jmax ; j++ ) pivrow[j] = -1;  /* mark as no pivot in col */

	mov	ecx, DWORD PTR _jmax$[ebp]
	push	esi
	push	edi
	mov	DWORD PTR _a$GSCopy$[ebp], eax
	mov	DWORD PTR _imax$GSCopy$[ebp], edx
	mov	DWORD PTR _detsign$[ebp], 1
	test	ecx, ecx
	jle	SHORT $LN46@kernel_bas@2
	or	eax, -1
	lea	edi, DWORD PTR _pivrow$[ebp]
	rep stosd
$LN46@kernel_bas@2:

; 1617 : 
; 1618 :   /* get row echelon form, pivot largest in each row */
; 1619 :   for ( i = 0 ; i < imax ; i++ )

	fldz
	mov	DWORD PTR _i$[ebp], 0
	test	edx, edx
	jle	$LN41@kernel_bas@2
	mov	ecx, DWORD PTR _a$GSCopy$[ebp]
	lea	eax, DWORD PTR _pivcol$[ebp]
	sub	eax, ecx
	mov	DWORD PTR tv2428[ebp], ecx
	mov	DWORD PTR tv2463[ebp], eax
$LN43@kernel_bas@2:

; 1621 :     REAL b,big,p;
; 1622 : 
; 1623 :     /* find largest element in row */
; 1624 :     big = 0.0;
; 1625 :     for ( j = 0 ; j < jmax ; j++ )

	mov	ebx, DWORD PTR _jmax$[ebp]
	fld	ST(0)
	or	esi, -1
	xor	ecx, ecx
	mov	DWORD PTR _piv$90276[ebp], esi
	cmp	ebx, 4
	jl	SHORT $LN102@kernel_bas@2

; 1620 :   { int piv = -1;

	mov	edx, DWORD PTR tv2428[ebp]
	mov	edx, DWORD PTR [edx]
	lea	edi, DWORD PTR [ebx-3]
	add	edx, 16					; 00000010H

; 1621 :     REAL b,big,p;
; 1622 : 
; 1623 :     /* find largest element in row */
; 1624 :     big = 0.0;
; 1625 :     for ( j = 0 ; j < jmax ; j++ )

$LN79@kernel_bas@2:

; 1626 :       if ( fabs(a[i][j]) > big )

	fld	QWORD PTR [edx-16]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN121@kernel_bas@2

; 1627 :       { big = fabs(a[i][j]);
; 1628 :         piv = j;

	fstp	ST(1)
	mov	esi, ecx
	jmp	SHORT $LN75@kernel_bas@2
$LN121@kernel_bas@2:
	fstp	ST(0)
$LN75@kernel_bas@2:

; 1626 :       if ( fabs(a[i][j]) > big )

	fld	QWORD PTR [edx-8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN124@kernel_bas@2

; 1620 :   { int piv = -1;

	fstp	ST(1)
	lea	esi, DWORD PTR [ecx+1]
	jmp	SHORT $LN76@kernel_bas@2
$LN124@kernel_bas@2:
	fstp	ST(0)
$LN76@kernel_bas@2:

; 1626 :       if ( fabs(a[i][j]) > big )

	fld	QWORD PTR [edx]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN127@kernel_bas@2

; 1620 :   { int piv = -1;

	fstp	ST(1)
	lea	esi, DWORD PTR [ecx+2]
	jmp	SHORT $LN77@kernel_bas@2
$LN127@kernel_bas@2:
	fstp	ST(0)
$LN77@kernel_bas@2:

; 1626 :       if ( fabs(a[i][j]) > big )

	fld	QWORD PTR [edx+8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN130@kernel_bas@2

; 1620 :   { int piv = -1;

	fstp	ST(1)
	lea	esi, DWORD PTR [ecx+3]
	jmp	SHORT $LN78@kernel_bas@2
$LN130@kernel_bas@2:
	fstp	ST(0)
$LN78@kernel_bas@2:
	add	ecx, 4
	add	edx, 32					; 00000020H
	cmp	ecx, edi
	jl	SHORT $LN79@kernel_bas@2

; 1627 :       { big = fabs(a[i][j]);
; 1628 :         piv = j;

	mov	DWORD PTR _piv$90276[ebp], esi
$LN102@kernel_bas@2:

; 1621 :     REAL b,big,p;
; 1622 : 
; 1623 :     /* find largest element in row */
; 1624 :     big = 0.0;
; 1625 :     for ( j = 0 ; j < jmax ; j++ )

	cmp	ecx, ebx
	jge	SHORT $LN135@kernel_bas@2
	mov	eax, DWORD PTR tv2428[ebp]
	mov	edx, DWORD PTR [eax]
	lea	edx, DWORD PTR [edx+ecx*8]
$LC40@kernel_bas@2:

; 1626 :       if ( fabs(a[i][j]) > big )

	fld	QWORD PTR [edx]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN139@kernel_bas@2

; 1627 :       { big = fabs(a[i][j]);
; 1628 :         piv = j;

	fstp	ST(1)
	mov	esi, ecx
	jmp	SHORT $LN39@kernel_bas@2
$LN139@kernel_bas@2:
	fstp	ST(0)
$LN39@kernel_bas@2:
	inc	ecx

; 1621 :     REAL b,big,p;
; 1622 : 
; 1623 :     /* find largest element in row */
; 1624 :     big = 0.0;
; 1625 :     for ( j = 0 ; j < jmax ; j++ )

	add	edx, 8
	cmp	ecx, ebx
	jl	SHORT $LC40@kernel_bas@2

; 1627 :       { big = fabs(a[i][j]);
; 1628 :         piv = j;

	mov	DWORD PTR _piv$90276[ebp], esi
$LN135@kernel_bas@2:
	fstp	ST(0)

; 1629 :       }
; 1630 :     if ( piv == -1 ) continue; /* row of zeros */

	cmp	esi, -1
	je	$LN42@kernel_bas@2

; 1631 :     pivrow[piv] = i; pivcol[i] = piv;

	mov	eax, DWORD PTR _piv$90276[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edi, DWORD PTR tv2428[ebp]
	mov	edx, DWORD PTR tv2463[ebp]
	mov	DWORD PTR _pivrow$[ebp+eax*4], ecx

; 1632 : 
; 1633 :     /* pivot step */
; 1634 :     p = a[i][piv];   if ( p < 0 ) detsign = -detsign;

	mov	ecx, DWORD PTR [edi]
	fld	QWORD PTR [ecx+eax*8]
	mov	DWORD PTR [edx+edi], eax
	fcom	ST(1)
	mov	DWORD PTR tv2433[ebp], ecx
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN35@kernel_bas@2
	mov	eax, DWORD PTR _detsign$[ebp]
	neg	eax
	mov	DWORD PTR _detsign$[ebp], eax
$LN35@kernel_bas@2:

; 1635 :     for ( j = 0 ; j < jmax ; j++ )

	mov	esi, ebx
	xor	edx, edx
	cmp	esi, 4
	jl	SHORT $LN103@kernel_bas@2
	lea	eax, DWORD PTR [ecx+16]
	lea	ecx, DWORD PTR [esi-4]
	shr	ecx, 2
	inc	ecx
	lea	edx, DWORD PTR [ecx*4]
$LN82@kernel_bas@2:

; 1636 :       a[i][j] /= p;

	fld	QWORD PTR [eax-16]
	add	eax, 32					; 00000020H
	dec	ecx
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax-48]
	fld	QWORD PTR [eax-40]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax-32]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [eax-24]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN82@kernel_bas@2
$LN103@kernel_bas@2:

; 1635 :     for ( j = 0 ; j < jmax ; j++ )

	cmp	edx, esi
	jge	SHORT $LN157@kernel_bas@2
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, esi
	sub	ecx, edx
$LC34@kernel_bas@2:

; 1636 :       a[i][j] /= p;

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	ecx
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC34@kernel_bas@2
$LN157@kernel_bas@2:

; 1635 :     for ( j = 0 ; j < jmax ; j++ )

	fstp	ST(0)

; 1637 :     for ( k = 0 ; k < imax ; k++ )

	xor	ebx, ebx
$LN31@kernel_bas@2:

; 1638 :     { if ( k == i ) continue;

	cmp	ebx, DWORD PTR _i$[ebp]
	je	$LN30@kernel_bas@2

; 1639 :       b = a[k][piv];

	mov	edx, DWORD PTR _a$GSCopy$[ebp]
	mov	eax, DWORD PTR [edx+ebx*4]
	mov	ecx, DWORD PTR _piv$90276[ebp]
	fld	QWORD PTR [eax+ecx*8]

; 1640 :       for ( j = 0 ; j < jmax ; j++ )

	xor	edi, edi
	cmp	DWORD PTR _jmax$[ebp], 4
	jl	SHORT $LC84@kernel_bas@2

; 1639 :       b = a[k][piv];

	mov	ecx, DWORD PTR [edx+ebx*4]
	mov	esi, DWORD PTR tv2433[ebp]
	lea	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [esi+24]

; 1641 :          a[k][j] -= b*a[i][j];

	sub	esi, ecx
	mov	ecx, DWORD PTR _jmax$[ebp]
	add	ecx, -4					; fffffffcH
	shr	ecx, 2
	inc	ecx
	lea	edi, DWORD PTR [ecx*4]
$LN85@kernel_bas@2:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	dec	ecx
	fsubr	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [esi+eax-32]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN85@kernel_bas@2
$LC84@kernel_bas@2:

; 1640 :       for ( j = 0 ; j < jmax ; j++ )

	mov	esi, DWORD PTR _jmax$[ebp]
	cmp	edi, esi
	jge	SHORT $LN170@kernel_bas@2
	mov	eax, DWORD PTR _a$GSCopy$[ebp]
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	edx, DWORD PTR tv2433[ebp]
	lea	eax, DWORD PTR [ecx+edi*8]
	sub	edx, ecx
	mov	ecx, esi
	sub	ecx, edi
$LC27@kernel_bas@2:

; 1641 :          a[k][j] -= b*a[i][j];

	fld	QWORD PTR [edx+eax]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC27@kernel_bas@2
$LN170@kernel_bas@2:

; 1640 :       for ( j = 0 ; j < jmax ; j++ )

	fstp	ST(0)
$LN30@kernel_bas@2:

; 1637 :     for ( k = 0 ; k < imax ; k++ )

	inc	ebx
	cmp	ebx, DWORD PTR _imax$GSCopy$[ebp]
	jl	$LN31@kernel_bas@2
$LN42@kernel_bas@2:

; 1617 : 
; 1618 :   /* get row echelon form, pivot largest in each row */
; 1619 :   for ( i = 0 ; i < imax ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	add	DWORD PTR tv2428[ebp], 4
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _imax$GSCopy$[ebp]
	jl	$LN43@kernel_bas@2
$LN41@kernel_bas@2:

; 1642 :     }
; 1643 :   }         
; 1644 : 
; 1645 :   /* now find kernel basis */
; 1646 :   for ( j = 0, n = 0 ; j < jmax ; j++ )

	mov	edi, DWORD PTR _jmax$[ebp]
	xor	esi, esi
	mov	DWORD PTR _n$[ebp], esi
	cmp	edi, esi
	jle	$LN237@kernel_bas@2
	mov	eax, DWORD PTR _imax$GSCopy$[ebp]
	mov	DWORD PTR tv3219[ebp], eax
	lea	eax, DWORD PTR _pivcol$[ebp+eax*4]
	mov	DWORD PTR tv3355[ebp], eax
$LN110@kernel_bas@2:

; 1647 :   { int sign;
; 1648 :     if ( pivrow[j] >= 0 ) continue;  /* column has leading 1 */

	cmp	DWORD PTR _pivrow$[ebp+esi*4], 0
	jge	$LN23@kernel_bas@2

; 1651 :     /* get sign for pos det */
; 1652 :     for (sign = detsign, k=0 ; k <= imax+n ; k++ )

	cmp	DWORD PTR tv3219[ebp], 0
	mov	ebx, DWORD PTR _detsign$[ebp]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR _sign$90299[ebp], ebx
	jl	SHORT $LN111@kernel_bas@2

; 1649 :     /* column j is parameter column */
; 1650 :     pivcol[imax+n] = j;

	mov	eax, DWORD PTR tv3219[ebp]
	inc	eax
	mov	ecx, 1
	lea	edx, DWORD PTR _pivcol$[ebp]
	mov	DWORD PTR tv2508[ebp], eax
$LN20@kernel_bas@2:

; 1653 :       for ( i = k+1 ; i <= imax+n ; i++ )

	mov	eax, ecx
	cmp	ecx, DWORD PTR tv3219[ebp]
	jg	SHORT $LN19@kernel_bas@2
	mov	edi, DWORD PTR [edx]
$LN17@kernel_bas@2:

; 1654 :         if ( pivcol[k] > pivcol[i] ) sign = -sign;

	cmp	edi, DWORD PTR _pivcol$[ebp+eax*4]
	jle	SHORT $LN16@kernel_bas@2
	neg	ebx
	mov	DWORD PTR _sign$90299[ebp], ebx
$LN16@kernel_bas@2:

; 1653 :       for ( i = k+1 ; i <= imax+n ; i++ )

	mov	ebx, DWORD PTR _sign$90299[ebp]
	inc	eax
	cmp	eax, DWORD PTR tv3219[ebp]
	jle	SHORT $LN17@kernel_bas@2
$LN19@kernel_bas@2:

; 1651 :     /* get sign for pos det */
; 1652 :     for (sign = detsign, k=0 ; k <= imax+n ; k++ )

	inc	ecx
	add	edx, 4
	dec	DWORD PTR tv2508[ebp]
	jne	SHORT $LN20@kernel_bas@2
	mov	edi, DWORD PTR _jmax$[ebp]
$LN111@kernel_bas@2:

; 1655 :     for ( k = 0 ; k < jmax ; k++ )

	xor	ecx, ecx
	cmp	edi, 4
	jl	$LN107@kernel_bas@2
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR _ker$GSCopy$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv2600[ebp], 2
	add	eax, 16					; 00000010H
$LN100@kernel_bas@2:

; 1656 :     { if ( pivrow[k] >= 0 )

	mov	edx, DWORD PTR _pivrow$[ebp+ecx*4]
	test	edx, edx
	js	SHORT $LN88@kernel_bas@2

; 1657 :         ker[n][k] = -sign*a[pivrow[k]][j];

	mov	edi, DWORD PTR _a$GSCopy$[ebp]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, ebx
	neg	edi
	mov	DWORD PTR tv3413[ebp], edi
	fild	DWORD PTR tv3413[ebp]
	fmul	QWORD PTR [edx+esi*8]
	fstp	QWORD PTR [eax-16]
	jmp	SHORT $LN90@kernel_bas@2
$LN88@kernel_bas@2:

; 1658 :       else if ( k == j )

	cmp	ecx, esi
	jne	SHORT $LN89@kernel_bas@2

; 1659 :         ker[n][k] = sign;

	fild	DWORD PTR _sign$90299[ebp]
	fstp	QWORD PTR [eax-16]
	jmp	SHORT $LN90@kernel_bas@2
$LN89@kernel_bas@2:

; 1660 :       else ker[n][k] = 0.0;

	fst	QWORD PTR [eax-16]
$LN90@kernel_bas@2:

; 1656 :     { if ( pivrow[k] >= 0 )

	mov	edx, DWORD PTR _pivrow$[ebp+ecx*4+4]
	test	edx, edx
	js	SHORT $LN91@kernel_bas@2

; 1657 :         ker[n][k] = -sign*a[pivrow[k]][j];

	mov	edi, DWORD PTR _a$GSCopy$[ebp]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, ebx
	neg	edi
	mov	DWORD PTR tv3409[ebp], edi
	fild	DWORD PTR tv3409[ebp]
	fmul	QWORD PTR [edx+esi*8]
	fstp	QWORD PTR [eax-8]
	jmp	SHORT $LN93@kernel_bas@2
$LN91@kernel_bas@2:

; 1655 :     for ( k = 0 ; k < jmax ; k++ )

	mov	edx, DWORD PTR tv2600[ebp]
	dec	edx

; 1658 :       else if ( k == j )

	cmp	edx, esi
	jne	SHORT $LN92@kernel_bas@2

; 1659 :         ker[n][k] = sign;

	fild	DWORD PTR _sign$90299[ebp]
	fstp	QWORD PTR [eax-8]
	jmp	SHORT $LN93@kernel_bas@2
$LN92@kernel_bas@2:

; 1660 :       else ker[n][k] = 0.0;

	fst	QWORD PTR [eax-8]
$LN93@kernel_bas@2:

; 1656 :     { if ( pivrow[k] >= 0 )

	mov	edx, DWORD PTR _pivrow$[ebp+ecx*4+8]
	test	edx, edx
	js	SHORT $LN94@kernel_bas@2

; 1657 :         ker[n][k] = -sign*a[pivrow[k]][j];

	mov	edi, DWORD PTR _a$GSCopy$[ebp]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, ebx
	neg	edi
	mov	DWORD PTR tv3405[ebp], edi
	fild	DWORD PTR tv3405[ebp]
	fmul	QWORD PTR [edx+esi*8]
	fstp	QWORD PTR [eax]
	jmp	SHORT $LN96@kernel_bas@2
$LN94@kernel_bas@2:

; 1658 :       else if ( k == j )

	cmp	DWORD PTR tv2600[ebp], esi
	jne	SHORT $LN95@kernel_bas@2

; 1659 :         ker[n][k] = sign;

	fild	DWORD PTR _sign$90299[ebp]
	fstp	QWORD PTR [eax]
	jmp	SHORT $LN96@kernel_bas@2
$LN95@kernel_bas@2:

; 1660 :       else ker[n][k] = 0.0;

	fst	QWORD PTR [eax]
$LN96@kernel_bas@2:

; 1656 :     { if ( pivrow[k] >= 0 )

	mov	edx, DWORD PTR _pivrow$[ebp+ecx*4+12]
	test	edx, edx
	js	SHORT $LN97@kernel_bas@2

; 1657 :         ker[n][k] = -sign*a[pivrow[k]][j];

	mov	edi, DWORD PTR _a$GSCopy$[ebp]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, ebx
	neg	edi
	mov	DWORD PTR tv3401[ebp], edi
	fild	DWORD PTR tv3401[ebp]
	fmul	QWORD PTR [edx+esi*8]
	fstp	QWORD PTR [eax+8]
	jmp	SHORT $LN99@kernel_bas@2
$LN97@kernel_bas@2:

; 1655 :     for ( k = 0 ; k < jmax ; k++ )

	mov	edx, DWORD PTR tv2600[ebp]
	inc	edx

; 1658 :       else if ( k == j )

	cmp	edx, esi
	jne	SHORT $LN98@kernel_bas@2

; 1659 :         ker[n][k] = sign;

	fild	DWORD PTR _sign$90299[ebp]
	fstp	QWORD PTR [eax+8]
	jmp	SHORT $LN99@kernel_bas@2
$LN98@kernel_bas@2:

; 1660 :       else ker[n][k] = 0.0;

	fst	QWORD PTR [eax+8]
$LN99@kernel_bas@2:

; 1655 :     for ( k = 0 ; k < jmax ; k++ )

	mov	edi, DWORD PTR _jmax$[ebp]
	add	DWORD PTR tv2600[ebp], 4
	add	ecx, 4
	lea	edx, DWORD PTR [edi-3]
	add	eax, 32					; 00000020H
	cmp	ecx, edx
	jl	$LN100@kernel_bas@2
$LN107@kernel_bas@2:
	cmp	ecx, edi
	jge	SHORT $LN108@kernel_bas@2
	mov	eax, DWORD PTR _ker$GSCopy$[ebp]
	mov	edx, DWORD PTR _n$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	lea	eax, DWORD PTR [eax+ecx*8]
$LC13@kernel_bas@2:

; 1656 :     { if ( pivrow[k] >= 0 )

	mov	edx, DWORD PTR _pivrow$[ebp+ecx*4]
	test	edx, edx
	js	SHORT $LN10@kernel_bas@2

; 1657 :         ker[n][k] = -sign*a[pivrow[k]][j];

	mov	edi, DWORD PTR _a$GSCopy$[ebp]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, ebx
	neg	edi
	mov	DWORD PTR tv3397[ebp], edi
	fild	DWORD PTR tv3397[ebp]
	fmul	QWORD PTR [edx+esi*8]
	fstp	QWORD PTR [eax]
	jmp	SHORT $LN12@kernel_bas@2
$LN10@kernel_bas@2:

; 1658 :       else if ( k == j )

	cmp	ecx, esi
	jne	SHORT $LN8@kernel_bas@2

; 1659 :         ker[n][k] = sign;

	fild	DWORD PTR _sign$90299[ebp]
	fstp	QWORD PTR [eax]
	jmp	SHORT $LN12@kernel_bas@2
$LN8@kernel_bas@2:

; 1660 :       else ker[n][k] = 0.0;

	fst	QWORD PTR [eax]
$LN12@kernel_bas@2:

; 1655 :     for ( k = 0 ; k < jmax ; k++ )

	mov	edi, DWORD PTR _jmax$[ebp]
	inc	ecx
	add	eax, 8
	cmp	ecx, edi
	jl	SHORT $LC13@kernel_bas@2
$LN108@kernel_bas@2:

; 1661 :     }
; 1662 :     n++;

	mov	eax, 1
	add	DWORD PTR _n$[ebp], eax
	add	DWORD PTR tv3219[ebp], eax
	mov	eax, DWORD PTR tv3355[ebp]
	add	eax, 4
	mov	DWORD PTR tv3355[ebp], eax
$LN23@kernel_bas@2:

; 1642 :     }
; 1643 :   }         
; 1644 : 
; 1645 :   /* now find kernel basis */
; 1646 :   for ( j = 0, n = 0 ; j < jmax ; j++ )

	inc	esi
	cmp	esi, edi
	jl	$LN110@kernel_bas@2
$LN237@kernel_bas@2:

; 1663 :   }
; 1664 :   /* normalize */
; 1665 :   for ( i = 0 ; i < n ; i ++ )

	mov	eax, DWORD PTR _n$[ebp]
	fstp	ST(0)
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN4@kernel_bas@2
	mov	esi, DWORD PTR _web+616
	mov	ebx, DWORD PTR _ker$GSCopy$[ebp]
$LL6@kernel_bas@2:

; 1666 :   { REAL mag;
; 1667 :     mag = sqrt(SDIM_dot(ker[i],ker[i]));

	mov	eax, DWORD PTR [ebx+edi*4]
	push	esi
	push	eax
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH
	call	__CIsqrt

; 1668 :     for ( j = 0 ; j < SDIM ; j++ )

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN242@kernel_bas@2

; 1663 :   }
; 1664 :   /* normalize */
; 1665 :   for ( i = 0 ; i < n ; i ++ )

	mov	eax, DWORD PTR [ebx+edi*4]
$LN3@kernel_bas@2:

; 1669 :       ker[i][j] /= mag;

	fld	QWORD PTR [eax]
	inc	ecx
	fdiv	ST(0), ST(1)
	add	eax, 8
	fstp	QWORD PTR [eax-8]
	mov	esi, DWORD PTR _web+616
	cmp	ecx, esi
	jl	SHORT $LN3@kernel_bas@2
$LN242@kernel_bas@2:

; 1663 :   }
; 1664 :   /* normalize */
; 1665 :   for ( i = 0 ; i < n ; i ++ )

	mov	eax, DWORD PTR _n$[ebp]

; 1668 :     for ( j = 0 ; j < SDIM ; j++ )

	fstp	ST(0)
	inc	edi
	cmp	edi, eax
	jl	SHORT $LL6@kernel_bas@2
$LN4@kernel_bas@2:

; 1670 :   } 
; 1671 : 
; 1672 :   return n; /* nullity */
; 1673 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_kernel_basis_rows ENDP
_TEXT	ENDS
PUBLIC	_matrix_index
; Function compile flags: /Ogtp
;	COMDAT _matrix_index
_TEXT	SEGMENT
_firstrow$ = -44					; size = 4
tv2867 = -40						; size = 4
tv1470 = -36						; size = 4
tv2918 = -32						; size = 4
tv1462 = -32						; size = 4
_a$ = -28						; size = 4
tv1342 = -24						; size = 4
_j$ = -24						; size = 4
_indx$ = -20						; size = 4
_i$ = -16						; size = 4
_prow$ = -12						; size = 4
_row$ = -8						; size = 4
tv3225 = -4						; size = 4
_M$ = 8							; size = 4
_n$ = 12						; size = 4
_matrix_index PROC					; COMDAT

; 1688 : { REAL **a = dmatrix(0,n-1,0,n-1);

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	mov	ebx, DWORD PTR _n$[ebp]
	push	esi
	push	edi
	push	1688					; 00000698H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	lea	eax, DWORD PTR [ebx-1]
	push	eax
	xor	esi, esi
	push	esi
	push	eax
	push	esi
	call	_kb_dmatrix

; 1689 :   REAL *tempptr;
; 1690 :   int row,col,prow=0;
; 1691 :   REAL maxp;
; 1692 :   int i,j;
; 1693 :   int indx = 0;
; 1694 :   REAL temp;
; 1695 :   REAL *firstrow;  /* for proper freeing after swapping rows */
; 1696 : 
; 1697 :   firstrow = a[0];
; 1698 :   matcopy(a,M,n,n);

	mov	ecx, DWORD PTR _M$[ebp]
	push	ebx
	mov	edi, eax
	mov	eax, DWORD PTR [edi]
	push	ebx
	push	ecx
	push	edi
	mov	DWORD PTR _a$[ebp], edi
	mov	DWORD PTR _prow$[ebp], esi
	mov	DWORD PTR _indx$[ebp], esi
	mov	DWORD PTR _firstrow$[ebp], eax
	call	_matcopy
	add	esp, 40					; 00000028H

; 1699 : 
; 1700 : 
; 1701 :   /* basically, gauss elimination to lower triangular form
; 1702 :      with partial pivoting.  
; 1703 :   */
; 1704 :   for ( col = 0 ; col < n ; col++ )

	xor	ecx, ecx
	test	ebx, ebx
	jle	$LN17@matrix_ind

; 1688 : { REAL **a = dmatrix(0,n-1,0,n-1);

	fldz
	mov	DWORD PTR tv3225[ebp], ebx
$LN19@matrix_ind:

; 1705 :   { /* find max pivot in diagonal */
; 1706 :     maxp = 0.0;

	fld	ST(0)

; 1707 :     for ( row = col ; row < n ; row++ )

	mov	edx, ecx
	cmp	ecx, ebx
	jge	$LN55@matrix_ind
	cmp	DWORD PTR tv3225[ebp], 4
	jl	$LC33@matrix_ind

; 1699 : 
; 1700 : 
; 1701 :   /* basically, gauss elimination to lower triangular form
; 1702 :      with partial pivoting.  
; 1703 :   */
; 1704 :   for ( col = 0 ; col < n ; col++ )

	lea	ebx, DWORD PTR [edi+ecx*4+8]

; 1707 :     for ( row = col ; row < n ; row++ )

$LN38@matrix_ind:

; 1708 :        if ( fabs(a[row][row]) > maxp ) { maxp = fabs(a[row][row]); prow = row; }

	mov	eax, DWORD PTR [ebx-8]
	fld	QWORD PTR [eax+edx*8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN62@matrix_ind
	fstp	ST(1)
	mov	esi, edx
	jmp	SHORT $LN34@matrix_ind
$LN62@matrix_ind:
	fstp	ST(0)
$LN34@matrix_ind:
	mov	eax, DWORD PTR [ebx-4]
	fld	QWORD PTR [eax+edx*8+8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN65@matrix_ind
	fstp	ST(1)
	lea	esi, DWORD PTR [edx+1]
	jmp	SHORT $LN35@matrix_ind
$LN65@matrix_ind:
	fstp	ST(0)
$LN35@matrix_ind:
	mov	eax, DWORD PTR [ebx]
	fld	QWORD PTR [eax+edx*8+16]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN68@matrix_ind
	fstp	ST(1)
	lea	esi, DWORD PTR [edx+2]
	jmp	SHORT $LN36@matrix_ind
$LN68@matrix_ind:
	fstp	ST(0)
$LN36@matrix_ind:
	mov	eax, DWORD PTR [ebx+4]
	fld	QWORD PTR [eax+edx*8+24]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN71@matrix_ind
	fstp	ST(1)
	lea	esi, DWORD PTR [edx+3]
	jmp	SHORT $LN37@matrix_ind
$LN71@matrix_ind:
	fstp	ST(0)
$LN37@matrix_ind:
	mov	eax, DWORD PTR _n$[ebp]
	add	edx, 4
	add	eax, -3					; fffffffdH
	add	ebx, 16					; 00000010H
	cmp	edx, eax
	jl	SHORT $LN38@matrix_ind
	mov	ebx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _prow$[ebp], esi
$LC33@matrix_ind:

; 1707 :     for ( row = col ; row < n ; row++ )

	cmp	edx, ebx
	jge	SHORT $LN32@matrix_ind
$LC16@matrix_ind:

; 1708 :        if ( fabs(a[row][row]) > maxp ) { maxp = fabs(a[row][row]); prow = row; }

	mov	eax, DWORD PTR [edi+edx*4]
	fld	QWORD PTR [eax+edx*8]
	fabs
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN78@matrix_ind
	fstp	ST(1)
	mov	esi, edx
	jmp	SHORT $LN15@matrix_ind
$LN78@matrix_ind:
	fstp	ST(0)
$LN15@matrix_ind:
	inc	edx

; 1707 :     for ( row = col ; row < n ; row++ )

	cmp	edx, ebx
	jl	SHORT $LC16@matrix_ind

; 1708 :        if ( fabs(a[row][row]) > maxp ) { maxp = fabs(a[row][row]); prow = row; }

	mov	DWORD PTR _prow$[ebp], esi
$LN32@matrix_ind:

; 1709 :     if ( maxp == 0.0 ) continue;

	fld	ST(1)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN18@matrix_ind

; 1710 :     if ( prow != col )

	cmp	esi, ecx
	je	$LN46@matrix_ind

; 1713 :       for ( j = col; j < n ; j++ )

	cmp	DWORD PTR tv3225[ebp], 4
	mov	edx, DWORD PTR [edi+ecx*4]
	mov	eax, DWORD PTR [edi+esi*4]
	mov	DWORD PTR [edi+esi*4], edx
	mov	DWORD PTR [edi+ecx*4], eax
	mov	edx, ecx
	jl	SHORT $LN45@matrix_ind

; 1711 :     { /* swap rows and columns to keep symmetric */
; 1712 :       tempptr = a[prow]; a[prow] = a[col]; a[col] = tempptr;

	sub	ebx, ecx
	sub	ebx, 4
	shr	ebx, 2
	inc	ebx
	lea	edx, DWORD PTR [ecx+ebx*4]
	lea	eax, DWORD PTR [edi+ecx*4+8]
	mov	DWORD PTR _j$[ebp], edx

; 1713 :       for ( j = col; j < n ; j++ )

$LN41@matrix_ind:

; 1714 :       { temp = a[j][col]; a[j][col] = a[j][prow]; a[j][prow] = temp; }

	mov	edx, DWORD PTR [eax-8]
	fld	QWORD PTR [edx+ecx*8]
	add	eax, 16					; 00000010H
	dec	ebx
	fld	QWORD PTR [edx+esi*8]
	fstp	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+esi*8]
	mov	edx, DWORD PTR [eax-20]
	fld	QWORD PTR [edx+ecx*8]
	fld	QWORD PTR [edx+esi*8]
	fstp	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+esi*8]
	mov	edx, DWORD PTR [eax-16]
	fld	QWORD PTR [edx+ecx*8]
	fld	QWORD PTR [edx+esi*8]
	fstp	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+esi*8]
	mov	edx, DWORD PTR [eax-12]
	fld	QWORD PTR [edx+ecx*8]
	fld	QWORD PTR [edx+esi*8]
	fstp	QWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [edx+esi*8]
	jne	SHORT $LN41@matrix_ind

; 1711 :     { /* swap rows and columns to keep symmetric */
; 1712 :       tempptr = a[prow]; a[prow] = a[col]; a[col] = tempptr;

	mov	edx, DWORD PTR _j$[ebp]
	mov	ebx, DWORD PTR _n$[ebp]
$LN45@matrix_ind:

; 1713 :       for ( j = col; j < n ; j++ )

	cmp	edx, ebx
	jge	SHORT $LN46@matrix_ind
$LC10@matrix_ind:

; 1714 :       { temp = a[j][col]; a[j][col] = a[j][prow]; a[j][prow] = temp; }

	mov	eax, DWORD PTR [edi+edx*4]
	fld	QWORD PTR [eax+ecx*8]
	inc	edx
	fld	QWORD PTR [eax+esi*8]
	fstp	QWORD PTR [eax+ecx*8]
	fstp	QWORD PTR [eax+esi*8]
	cmp	edx, ebx
	jl	SHORT $LC10@matrix_ind
$LN46@matrix_ind:

; 1715 :     }
; 1716 :     if ( a[col][col] < 0.0 ) indx++;

	mov	ebx, DWORD PTR [edi+ecx*4]
	fcom	QWORD PTR [ebx+ecx*8]
	mov	DWORD PTR tv1342[ebp], ebx
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN7@matrix_ind
	inc	DWORD PTR _indx$[ebp]
$LN7@matrix_ind:

; 1717 :     for ( row = col+1 ; row < n ; row++ )

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR _row$[ebp], eax
	cmp	eax, DWORD PTR _n$[ebp]
	jge	$LN51@matrix_ind
$LN6@matrix_ind:

; 1718 :       for ( i = col+1 ; i < n ; i++ )

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR _n$[ebp]
	jge	$LN5@matrix_ind
	mov	eax, DWORD PTR tv3225[ebp]
	dec	eax
	cmp	eax, 4
	jl	SHORT $LN49@matrix_ind
	mov	edx, DWORD PTR _row$[ebp]
	mov	esi, DWORD PTR [edi+edx*4]

; 1719 :       { a[row][i] -= a[row][col]/a[col][col]*a[col][i];

	mov	edx, DWORD PTR _n$[ebp]
	lea	edi, DWORD PTR [ebx+ecx*8+32]
	sub	ebx, esi
	mov	DWORD PTR tv2918[ebp], ebx
	lea	ebx, DWORD PTR [ecx+1]
	sub	edx, ebx
	sub	edx, 4
	shr	edx, 2
	inc	edx
	lea	ebx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR _i$[ebp], ebx
	mov	ebx, DWORD PTR tv1342[ebp]
	lea	eax, DWORD PTR [esi+ecx*8+16]
$LN44@matrix_ind:
	fld	QWORD PTR [esi+ecx*8]
	add	eax, 32					; 00000020H
	fdiv	QWORD PTR [ebx+ecx*8]
	add	edi, 32					; 00000020H
	dec	edx
	fmul	QWORD PTR [edi-56]
	fsubr	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [esi+ecx*8]
	fdiv	QWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR tv2918[ebp]
	fmul	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv1342[ebp]
	fsubr	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [esi+ecx*8]
	fdiv	QWORD PTR [ebx+ecx*8]
	fmul	QWORD PTR [edi-40]
	fsubr	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [esi+ecx*8]
	fdiv	QWORD PTR [ebx+ecx*8]
	fmul	QWORD PTR [edi-32]
	fsubr	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN44@matrix_ind
	mov	esi, DWORD PTR _prow$[ebp]
	mov	edi, DWORD PTR _a$[ebp]
$LN49@matrix_ind:

; 1718 :       for ( i = col+1 ; i < n ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _n$[ebp]
	jge	SHORT $LN5@matrix_ind
	mov	edx, DWORD PTR _row$[ebp]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	DWORD PTR tv1462[ebp], edx
	mov	DWORD PTR tv1470[ebp], edi
	sub	edi, edx
	lea	eax, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _n$[ebp]
	sub	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv2867[ebp], edi
$LN48@matrix_ind:

; 1719 :       { a[row][i] -= a[row][col]/a[col][col]*a[col][i];

	mov	edi, DWORD PTR tv1462[ebp]
	fld	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR tv1470[ebp]
	fdiv	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR tv2867[ebp]
	add	eax, 8
	dec	edx
	fmul	QWORD PTR [edi+eax-8]
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LN48@matrix_ind

; 1718 :       for ( i = col+1 ; i < n ; i++ )

	mov	edi, DWORD PTR _a$[ebp]
$LN5@matrix_ind:

; 1717 :     for ( row = col+1 ; row < n ; row++ )

	mov	eax, DWORD PTR _row$[ebp]
	inc	eax
	mov	DWORD PTR _row$[ebp], eax
	cmp	eax, DWORD PTR _n$[ebp]
	jl	$LN6@matrix_ind
$LN51@matrix_ind:
	mov	ebx, DWORD PTR _n$[ebp]
$LN18@matrix_ind:

; 1699 : 
; 1700 : 
; 1701 :   /* basically, gauss elimination to lower triangular form
; 1702 :      with partial pivoting.  
; 1703 :   */
; 1704 :   for ( col = 0 ; col < n ; col++ )

	dec	DWORD PTR tv3225[ebp]
	inc	ecx
	cmp	ecx, ebx
	jl	$LN19@matrix_ind
	fstp	ST(0)
$LN17@matrix_ind:

; 1720 :       }
; 1721 :   }
; 1722 :   a[0] = firstrow; free_matrix(a);

	mov	eax, DWORD PTR _firstrow$[ebp]
	push	edi
	mov	DWORD PTR [edi], eax
	call	_free_matrix

; 1723 :   return indx;

	mov	eax, DWORD PTR _indx$[ebp]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 1724 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN55@matrix_ind:

; 1707 :     for ( row = col ; row < n ; row++ )

	fstp	ST(0)

; 1717 :     for ( row = col+1 ; row < n ; row++ )

	jmp	SHORT $LN18@matrix_ind
_matrix_index ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@BDCMKFGP@50?5Jacobi?5iterations?5should?5neve@ ; `string'
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__real@3fc999999999999a
PUBLIC	_jacobi_eigenpairs
;	COMDAT ??_C@_0CL@BDCMKFGP@50?5Jacobi?5iterations?5should?5neve@
CONST	SEGMENT
??_C@_0CL@BDCMKFGP@50?5Jacobi?5iterations?5should?5neve@ DB '50 Jacobi it'
	DB	'erations should never happen.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@3fc999999999999a
CONST	SEGMENT
__real@3fc999999999999a DQ 03fc999999999999ar	; 0.2
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _jacobi_eigenpairs
_TEXT	SEGMENT
_tresh$ = -88						; size = 8
_theta$ = -80						; size = 8
_t$ = -80						; size = 8
tv7198 = -76						; size = 4
tv6396 = -76						; size = 4
tv7017 = -72						; size = 4
tv7242 = -68						; size = 4
tv7021 = -64						; size = 4
tv4268 = -60						; size = 4
tv6964 = -56						; size = 4
tv7246 = -52						; size = 4
_b$ = -48						; size = 4
tv6611 = -44						; size = 4
tv6422 = -40						; size = 4
tv335 = -40						; size = 4
tv7023 = -36						; size = 4
_i$ = -32						; size = 4
tv7062 = -28						; size = 4
tv4572 = -28						; size = 4
tv6285 = -24						; size = 4
tv4570 = -24						; size = 4
tv7105 = -20						; size = 4
tv7301 = -16						; size = 4
_j$ = -16						; size = 4
tv6957 = -12						; size = 4
tv6715 = -8						; size = 4
tv6021 = -4						; size = 4
_a$ = 8							; size = 4
tv8423 = 12						; size = 4
_n$ = 12						; size = 4
_d$ = 16						; size = 4
_v$ = 20						; size = 4
tv3696 = 24						; size = 4
_work$ = 24						; size = 4
_jacobi_eigenpairs PROC					; COMDAT

; 1743 : { REAL sm,h,tresh,dum,g,t,theta,tau,s,c;

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 1744 :   int i,iq,ip,nrot,j;
; 1745 :   REAL *z,*b;
; 1746 : 
; 1747 :   z = work;
; 1748 :   b = work+n;

	mov	eax, DWORD PTR _work$[ebp]

; 1749 : 
; 1750 :   /* initialize v to identity */
; 1751 :   for ( ip = 0 ; ip < n ; ip++ )

	fldz
	fld1
	push	ebx
	mov	ebx, DWORD PTR _n$[ebp]
	push	esi
	mov	esi, DWORD PTR _v$[ebp]
	lea	ecx, DWORD PTR [eax+ebx*8]
	xor	edx, edx
	push	edi
	mov	DWORD PTR _b$[ebp], ecx
	test	ebx, ebx
	jle	SHORT $LN57@jacobi_eig
$LN134@jacobi_eig:

; 1752 :   { for ( iq = 0 ; iq < n ; iq++ ) v[ip][iq] = 0.0;

	xor	edi, edi
	cmp	ebx, 4
	jl	SHORT $LN132@jacobi_eig
	mov	eax, DWORD PTR [esi+edx*4]
	lea	ecx, DWORD PTR [ebx-4]
	shr	ecx, 2
	add	eax, 16					; 00000010H
	inc	ecx
	lea	edi, DWORD PTR [ecx*4]
$LN142@jacobi_eig:
	fxch	ST(1)
	add	eax, 32					; 00000020H
	dec	ecx
	fst	QWORD PTR [eax-48]
	fst	QWORD PTR [eax-40]
	fst	QWORD PTR [eax-32]
	fst	QWORD PTR [eax-24]
	fxch	ST(1)
	jne	SHORT $LN142@jacobi_eig
$LN132@jacobi_eig:
	cmp	edi, ebx
	jge	SHORT $LC56@jacobi_eig
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	lea	esi, DWORD PTR [ecx+edi*8]
	mov	ecx, ebx
	sub	ecx, edi
	add	ecx, ecx
	and	ecx, 1073741822				; 3ffffffeH
	mov	edi, esi
	mov	esi, DWORD PTR _v$[ebp]
	xor	eax, eax
	rep stosd
$LC56@jacobi_eig:

; 1753 :     v[ip][ip] = 1.0;

	mov	eax, DWORD PTR [esi+edx*4]
	fst	QWORD PTR [eax+edx*8]
	inc	edx
	cmp	edx, ebx
	jl	SHORT $LN134@jacobi_eig
$LN57@jacobi_eig:

; 1754 :   }
; 1755 : 
; 1756 :   for ( ip = 0 ; ip < n ; ip++ )

	mov	eax, DWORD PTR _d$[ebp]
	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN51@jacobi_eig

; 1759 :     z[ip] = 0.0;

	mov	edx, DWORD PTR _b$[ebp]
	mov	esi, DWORD PTR _work$[ebp]
	sub	edx, eax
	sub	esi, eax
$LN151@jacobi_eig:

; 1757 :   { b[ip] = a[ip][ip];

	mov	edi, DWORD PTR _a$[ebp]
	mov	edi, DWORD PTR [edi+ecx*4]
	fld	QWORD PTR [edi+ecx*8]
	inc	ecx
	fst	QWORD PTR [edx+eax]
	add	eax, 8

; 1758 :     d[ip] = b[ip];

	fstp	QWORD PTR [eax-8]

; 1759 :     z[ip] = 0.0;

	fxch	ST(1)
	fst	QWORD PTR [esi+eax-8]
	fxch	ST(1)
	cmp	ecx, ebx
	jl	SHORT $LN151@jacobi_eig
$LN51@jacobi_eig:

; 1760 :   }
; 1761 : 
; 1762 :   nrot = 0;
; 1763 :   for ( i = 1 ; i < 50 ; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $LN50@jacobi_eig
$LN125@jacobi_eig:
	mov	ebx, DWORD PTR _n$[ebp]
$LN50@jacobi_eig:

; 1765 :     for ( ip = 0 ; ip < n-1; ip++ )

	lea	eax, DWORD PTR [ebx-1]
	fld	ST(1)
	test	eax, eax
	jle	$LN170@jacobi_eig

; 1764 :   { sm = 0.0;

	mov	esi, DWORD PTR _a$[ebp]
	mov	edx, 1
	mov	DWORD PTR tv4570[ebp], 24		; 00000018H
	mov	DWORD PTR tv4572[ebp], eax
	mov	DWORD PTR tv335[ebp], eax
$LN47@jacobi_eig:

; 1766 :       for ( iq = ip + 1 ; iq < n ; iq++ )

	mov	edi, edx
	cmp	edx, ebx
	jge	SHORT $LN46@jacobi_eig
	cmp	DWORD PTR tv4572[ebp], 4
	jl	SHORT $LC99@jacobi_eig

; 1767 :         sm += fabs(a[ip][iq]);

	mov	ecx, DWORD PTR [esi]
	add	ecx, DWORD PTR tv4570[ebp]
	mov	eax, ebx
	sub	eax, edx
	sub	eax, 4
	shr	eax, 2
	inc	eax
	lea	edi, DWORD PTR [edx+eax*4]
$LN100@jacobi_eig:
	fld	QWORD PTR [ecx-16]
	add	ecx, 32					; 00000020H
	dec	eax
	fabs
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-40]
	fabs
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-32]
	fabs
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-24]
	fabs
	faddp	ST(1), ST(0)
	jne	SHORT $LN100@jacobi_eig
$LC99@jacobi_eig:

; 1766 :       for ( iq = ip + 1 ; iq < n ; iq++ )

	cmp	edi, ebx
	jge	SHORT $LN46@jacobi_eig
	mov	ecx, DWORD PTR [esi]
	mov	eax, ebx
	lea	ecx, DWORD PTR [ecx+edi*8]
	sub	eax, edi
$LC44@jacobi_eig:

; 1767 :         sm += fabs(a[ip][iq]);

	fld	QWORD PTR [ecx]
	add	ecx, 8
	dec	eax
	fabs
	faddp	ST(1), ST(0)
	jne	SHORT $LC44@jacobi_eig
$LN46@jacobi_eig:

; 1765 :     for ( ip = 0 ; ip < n-1; ip++ )

	add	DWORD PTR tv4570[ebp], 8
	mov	eax, 1
	sub	DWORD PTR tv4572[ebp], eax
	add	edx, eax
	add	esi, 4
	sub	DWORD PTR tv335[ebp], eax
	jne	SHORT $LN47@jacobi_eig

; 1768 :     if ( sm == 0.0 ) goto jacobi_exit; /* normal exit */

	fld	ST(0)
	fld	ST(3)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN170@jacobi_eig

; 1769 : 
; 1770 :     if ( i < 4 ) tresh = .2*sm/n/n;

	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $LN173@jacobi_eig
	fild	DWORD PTR _n$[ebp]
	fxch	ST(1)
	fmul	QWORD PTR __real@3fc999999999999a
	fdiv	ST(0), ST(1)
	fdivrp	ST(1), ST(0)
	fstp	QWORD PTR _tresh$[ebp]
	jmp	SHORT $LN39@jacobi_eig
$LN173@jacobi_eig:
	fstp	ST(0)

; 1771 :     else tresh = 0.0;

	fxch	ST(1)
	fst	QWORD PTR _tresh$[ebp]
	fxch	ST(1)
$LN39@jacobi_eig:

; 1772 : 
; 1773 :     for ( ip = 0 ; ip < n-1 ; ip++ )

	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, 24					; 00000018H
	sub	eax, ecx
	mov	DWORD PTR tv7242[ebp], eax
	mov	eax, 8
	sub	eax, ecx
	mov	DWORD PTR tv7246[ebp], eax
	mov	eax, DWORD PTR _work$[ebp]
	xor	edi, edi
	sub	eax, ecx
	mov	DWORD PTR tv6715[ebp], 1
	mov	DWORD PTR tv6957[ebp], edx
	mov	DWORD PTR tv7062[ebp], 3
	mov	DWORD PTR tv4268[ebp], eax
$LN38@jacobi_eig:

; 1774 :      for ( iq = ip+1 ; iq < n ; iq++ )

	mov	eax, DWORD PTR _n$[ebp]
	cmp	DWORD PTR tv6715[ebp], eax
	jge	$LN37@jacobi_eig
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR tv6715[ebp]
	mov	eax, DWORD PTR tv6957[ebp]
	mov	ebx, DWORD PTR [eax]
	lea	esi, DWORD PTR [edi+ecx]
	add	esi, DWORD PTR tv7246[ebp]
	lea	ecx, DWORD PTR [edx-1]
	mov	DWORD PTR tv6021[ebp], ecx
	lea	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR tv7062[ebp]
	mov	DWORD PTR tv6285[ebp], ecx
	mov	ecx, DWORD PTR _n$[ebp]
	lea	eax, DWORD PTR [eax+ecx-5]
	mov	DWORD PTR tv6422[ebp], eax

; 1778 :          a[ip][iq] = 0.0;

	mov	eax, ebx
	neg	eax
	mov	DWORD PTR tv6964[ebp], ebx
	mov	ebx, DWORD PTR _work$[ebp]
	add	ebx, eax
	mov	DWORD PTR tv7017[ebp], eax
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR tv7021[ebp], ebx
	mov	DWORD PTR tv7023[ebp], eax
	mov	eax, ecx
	sub	eax, edx
	mov	DWORD PTR tv6611[ebp], eax
$LN124@jacobi_eig:

; 1775 :      { g = 100*fabs(a[ip][iq]);

	mov	ecx, DWORD PTR tv6964[ebp]
	fld	QWORD PTR [ecx+esi]

; 1776 :        dum = fabs(d[ip]);

	mov	edx, DWORD PTR _d$[ebp]
	add	ecx, esi
	fabs

; 1777 :        if ( (i > 4) && (dum+g == dum) && (fabs(d[iq])+g == fabs(d[iq])) )

	cmp	DWORD PTR _i$[ebp], 4
	fld	QWORD PTR __real@4059000000000000
	fmul	ST(0), ST(1)
	lea	ebx, DWORD PTR [edi+edx]
	fld	QWORD PTR [ebx]
	mov	DWORD PTR tv7105[ebp], ecx
	fabs
	jle	SHORT $LN182@jacobi_eig
	fld	ST(0)
	fadd	ST(0), ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN32@jacobi_eig
	mov	eax, DWORD PTR tv7023[ebp]
	fld	QWORD PTR [ecx+eax]
	fabs
	fld	ST(0)
	fadd	ST(0), ST(2)
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN32@jacobi_eig
	fstp	ST(1)
	fstp	ST(0)

; 1778 :          a[ip][iq] = 0.0;

	fxch	ST(1)
	fst	QWORD PTR [ecx]
	jmp	$LN34@jacobi_eig
$LN182@jacobi_eig:

; 1777 :        if ( (i > 4) && (dum+g == dum) && (fabs(d[iq])+g == fabs(d[iq])) )

	fstp	ST(0)
$LN32@jacobi_eig:

; 1779 :        else if ( fabs(a[ip][iq]) > tresh ) 

	fld	QWORD PTR _tresh$[ebp]
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 5
	jp	$LN192@jacobi_eig

; 1780 :        { h = d[iq] - d[ip];

	mov	ecx, DWORD PTR tv7105[ebp]
	fstp	ST(2)
	mov	edx, DWORD PTR tv7023[ebp]
	fld	QWORD PTR [ecx+edx]
	fsub	QWORD PTR [ebx]

; 1781 :          if ( fabs(h) + g == fabs(h) ) t = a[ip][iq]/h;

	fld	ST(0)
	fabs
	fld	ST(0)
	faddp	ST(4), ST(0)
	fucomp	ST(3)
	fnstsw	ax
	fstp	ST(2)
	test	ah, 68					; 00000044H
	jp	SHORT $LN29@jacobi_eig
	fld	QWORD PTR [ecx]
	fdivrp	ST(2), ST(0)
	fxch	ST(1)

; 1782 :          else 

	jmp	SHORT $LN284@jacobi_eig
$LN29@jacobi_eig:

; 1783 :          { theta = .5*h/a[ip][iq];

	mov	eax, DWORD PTR tv7105[ebp]
	fxch	ST(1)
	fmul	QWORD PTR __real@3fe0000000000000
	fdiv	QWORD PTR [eax]
	fst	QWORD PTR _theta$[ebp]

; 1784 :            t = 1.0/(fabs(theta) + sqrt(1 + theta*theta));

	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fld	QWORD PTR _theta$[ebp]
	fld	ST(0)
	fabs
	faddp	ST(2), ST(0)
	fld1
	fld	ST(0)
	fdivrp	ST(3), ST(0)
	fxch	ST(2)
	fst	QWORD PTR _t$[ebp]

; 1785 :            if ( theta < 0.0 ) t = -t;

	fldz
	fcomp	ST(2)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jne	SHORT $LN27@jacobi_eig
	fchs
$LN284@jacobi_eig:
	fst	QWORD PTR _t$[ebp]
$LN27@jacobi_eig:

; 1786 :          }
; 1787 :          c = 1.0/sqrt(1 + t*t);

	fmul	ST(0), ST(0)
	faddp	ST(1), ST(0)
	call	__CIsqrt
	fld1
	fld	ST(0)

; 1788 :          s = t*c;
; 1789 :          tau = s/(1+c);
; 1790 :          h = t*a[ip][iq];

	mov	ecx, DWORD PTR tv6957[ebp]
	fdivrp	ST(2), ST(0)
	mov	edx, DWORD PTR [ecx]

; 1791 :          z[ip] -= h;

	mov	eax, DWORD PTR tv4268[ebp]
	lea	ecx, DWORD PTR [esi+edx]

; 1792 :          z[iq] += h;

	mov	edx, DWORD PTR tv7021[ebp]
	fld	ST(1)
	fld	QWORD PTR _t$[ebp]
	fmul	ST(1), ST(0)
	fxch	ST(3)
	fadd	ST(0), ST(2)
	fdivr	ST(0), ST(1)
	fld	QWORD PTR [ecx]
	fmulp	ST(4), ST(0)
	fld	QWORD PTR [ebx+eax]
	fsub	ST(0), ST(4)
	fstp	QWORD PTR [ebx+eax]
	mov	eax, DWORD PTR tv7105[ebp]
	fld	QWORD PTR [eax+edx]
	fadd	ST(0), ST(4)
	fstp	QWORD PTR [eax+edx]

; 1793 :          d[ip] -= h;
; 1794 :          d[iq] += h;

	mov	edx, DWORD PTR tv7023[ebp]
	fld	QWORD PTR [ebx]
	fsub	ST(0), ST(4)
	fstp	QWORD PTR [ebx]
	fxch	ST(3)
	fadd	QWORD PTR [eax+edx]
	fstp	QWORD PTR [eax+edx]

; 1795 :          a[ip][iq] = 0.0;
; 1796 :          for ( j = 0 ; j <= ip-1 ; j++ )

	mov	eax, DWORD PTR tv6715[ebp]
	fldz
	xor	edx, edx
	add	eax, -2					; fffffffeH
	fst	QWORD PTR [ecx]

; 1797 :          { g = a[j][ip];

	mov	DWORD PTR tv7301[ebp], eax
	js	$LN127@jacobi_eig

; 1795 :          a[ip][iq] = 0.0;
; 1796 :          for ( j = 0 ; j <= ip-1 ; j++ )

	mov	ebx, DWORD PTR tv6715[ebp]
	lea	eax, DWORD PTR [ebx-1]
	cmp	eax, 4
	jl	$LN126@jacobi_eig

; 1800 :            a[j][iq] = h + s*(g-h*tau);

	mov	eax, DWORD PTR _a$[ebp]
	dec	ebx
	add	eax, 8
	shr	ebx, 2
	lea	edx, DWORD PTR [ebx*4]
$LN103@jacobi_eig:

; 1797 :          { g = a[j][ip];

	mov	ecx, DWORD PTR [eax-8]
	fld	QWORD PTR [ecx+edi]

; 1800 :            a[j][iq] = h + s*(g-h*tau);

	add	eax, 16					; 00000010H
	dec	ebx
	fld	QWORD PTR [esi+ecx]
	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [ecx+edi]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR [eax-20]
	fld	QWORD PTR [ecx+edi]
	fld	QWORD PTR [esi+ecx]
	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [ecx+edi]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR [eax-16]
	fld	QWORD PTR [ecx+edi]
	fld	QWORD PTR [esi+ecx]
	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [ecx+edi]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR [eax-12]
	fld	QWORD PTR [ecx+edi]
	fld	QWORD PTR [esi+ecx]
	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [ecx+edi]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+ecx]
	jne	$LN103@jacobi_eig
$LN126@jacobi_eig:

; 1795 :          a[ip][iq] = 0.0;
; 1796 :          for ( j = 0 ; j <= ip-1 ; j++ )

	cmp	edx, DWORD PTR tv7301[ebp]
	jg	SHORT $LN127@jacobi_eig
	mov	ebx, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR tv7301[ebp]
$LC26@jacobi_eig:

; 1797 :          { g = a[j][ip];

	mov	eax, DWORD PTR [ebx+edx*4]
	fld	QWORD PTR [edi+eax]
	inc	edx

; 1798 :            h = a[j][iq];

	fld	QWORD PTR [esi+eax]

; 1799 :            a[j][ip] = g - s*(h+g*tau);

	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [edi+eax]

; 1800 :            a[j][iq] = h + s*(g-h*tau);

	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+eax]
	cmp	edx, ecx
	jle	SHORT $LC26@jacobi_eig
$LN127@jacobi_eig:

; 1801 :          }
; 1802 :          for ( j = ip+1 ; j <= iq-1 ; j++ )

	mov	eax, DWORD PTR tv6715[ebp]
	cmp	eax, DWORD PTR tv6021[ebp]
	jg	$LN104@jacobi_eig
	mov	ecx, DWORD PTR tv7062[ebp]
	mov	edx, DWORD PTR tv6021[ebp]
	lea	ecx, DWORD PTR [ecx+edx-3]
	cmp	ecx, 4
	jl	$LC105@jacobi_eig
	mov	eax, DWORD PTR tv6957[ebp]
	mov	edx, DWORD PTR _d$[ebp]
	mov	ebx, DWORD PTR tv6715[ebp]
	add	edx, edi
	lea	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [eax]
	add	eax, edx
	mov	edx, DWORD PTR tv6021[ebp]
	add	eax, DWORD PTR tv7242[ebp]
	sub	edx, ebx
	sub	edx, 3
	shr	edx, 2
	inc	edx
	lea	ebx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR _j$[ebp], ebx
$LN106@jacobi_eig:

; 1803 :          { g = a[ip][j];

	fld	QWORD PTR [eax-16]

; 1804 :            h = a[j][iq];

	mov	ebx, DWORD PTR [ecx-8]
	fld	QWORD PTR [ebx+esi]

; 1806 :            a[j][iq] = h + s*(g-h*tau);

	add	eax, 32					; 00000020H
	fld	ST(5)
	add	ecx, 16					; 00000010H
	dec	edx
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [eax-48]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ebx+esi]
	mov	ebx, DWORD PTR [ecx-20]
	fld	QWORD PTR [eax-40]
	fld	QWORD PTR [ebx+esi]
	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [eax-40]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ebx+esi]
	mov	ebx, DWORD PTR [ecx-16]
	fld	QWORD PTR [eax-32]
	fld	QWORD PTR [ebx+esi]
	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [eax-32]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ebx+esi]
	mov	ebx, DWORD PTR [ecx-12]
	fld	QWORD PTR [eax-24]
	fld	QWORD PTR [ebx+esi]
	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [eax-24]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [ebx+esi]
	jne	$LN106@jacobi_eig

; 1801 :          }
; 1802 :          for ( j = ip+1 ; j <= iq-1 ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
$LC105@jacobi_eig:
	cmp	eax, DWORD PTR tv6021[ebp]
	jg	SHORT $LN104@jacobi_eig
	mov	ecx, DWORD PTR tv6957[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ebx, DWORD PTR _a$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
$LC23@jacobi_eig:

; 1803 :          { g = a[ip][j];

	fld	QWORD PTR [ecx]

; 1804 :            h = a[j][iq];

	mov	edx, DWORD PTR [ebx+eax*4]
	fld	QWORD PTR [edx+esi]
	inc	eax

; 1805 :            a[ip][j] = g - s*(h+g*tau);

	fld	ST(5)
	add	ecx, 8
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [ecx-8]

; 1806 :            a[j][iq] = h + s*(g-h*tau);

	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [edx+esi]
	cmp	eax, DWORD PTR tv6021[ebp]
	jle	SHORT $LC23@jacobi_eig
$LN104@jacobi_eig:

; 1807 :          }
; 1808 :          for ( j = iq+1 ; j < n ; j++ )

	mov	ebx, DWORD PTR tv6021[ebp]
	add	ebx, 2
	mov	DWORD PTR _j$[ebp], ebx
	cmp	ebx, DWORD PTR _n$[ebp]
	jge	$LN107@jacobi_eig
	cmp	DWORD PTR tv6422[ebp], 4
	jl	$LC108@jacobi_eig
	mov	eax, DWORD PTR tv6957[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv6285[ebp]
	mov	eax, DWORD PTR [ecx]

; 1812 :            a[iq][j] = h + s*(g-h*tau);

	mov	ebx, DWORD PTR tv7017[ebp]
	mov	DWORD PTR tv6396[ebp], eax
	mov	eax, DWORD PTR tv7105[ebp]
	lea	ecx, DWORD PTR [eax+ebx+32]
	lea	eax, DWORD PTR [eax+ebx+8]
	mov	ebx, DWORD PTR tv6396[ebp]
	add	ecx, edx
	sub	edx, ebx
	mov	DWORD PTR tv7198[ebp], edx
	mov	edx, DWORD PTR _n$[ebp]
	lea	eax, DWORD PTR [eax+ebx+8]
	mov	ebx, DWORD PTR _j$[ebp]
	sub	edx, ebx
	sub	edx, 4
	shr	edx, 2
	inc	edx
	lea	ebx, DWORD PTR [ebx+edx*4]
	mov	DWORD PTR _j$[ebp], ebx
	mov	ebx, DWORD PTR tv7198[ebp]
$LN109@jacobi_eig:
	fld	QWORD PTR [ecx-24]
	add	eax, 32					; 00000020H
	fld	QWORD PTR [eax-40]
	add	ecx, 32					; 00000020H
	dec	edx
	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [ecx-56]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax+ebx-32]
	fld	QWORD PTR [eax-32]
	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [eax+ebx-32]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [ecx-40]
	fld	QWORD PTR [eax-24]
	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [ecx-40]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [ecx-32]
	fld	QWORD PTR [eax-16]
	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [ecx-32]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax-16]
	jne	$LN109@jacobi_eig
	mov	ebx, DWORD PTR _j$[ebp]
$LC108@jacobi_eig:

; 1807 :          }
; 1808 :          for ( j = iq+1 ; j < n ; j++ )

	cmp	ebx, DWORD PTR _n$[ebp]
	jge	SHORT $LN107@jacobi_eig
	mov	ecx, DWORD PTR tv6285[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv6957[ebp]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+ebx*8]
	sub	ecx, edx
	mov	edx, DWORD PTR _n$[ebp]
	sub	edx, ebx
$LC20@jacobi_eig:

; 1809 :          { g = a[ip][j];

	fld	QWORD PTR [eax+ecx]
	add	eax, 8
	dec	edx

; 1810 :            h = a[iq][j];

	fld	QWORD PTR [eax-8]

; 1811 :            a[ip][j] = g - s*(h+g*tau);

	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [eax+ecx-8]

; 1812 :            a[iq][j] = h + s*(g-h*tau);

	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC20@jacobi_eig
$LN107@jacobi_eig:

; 1813 :          }
; 1814 :          for ( j = 0 ; j < n ; j++ )

	mov	edx, DWORD PTR _n$[ebp]
	xor	ebx, ebx
	cmp	edx, 4
	jl	$LN128@jacobi_eig
	mov	eax, DWORD PTR _v$[ebp]
	add	edx, -4					; fffffffcH
	shr	edx, 2
	add	eax, 8
	inc	edx
	lea	ebx, DWORD PTR [edx*4]
$LN112@jacobi_eig:

; 1815 :          { g = v[j][ip];

	mov	ecx, DWORD PTR [eax-8]
	fld	QWORD PTR [ecx+edi]

; 1818 :            v[j][iq] = h + s*(g-h*tau);

	add	eax, 16					; 00000010H
	dec	edx
	fld	QWORD PTR [esi+ecx]
	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [ecx+edi]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR [eax-20]
	fld	QWORD PTR [ecx+edi]
	fld	QWORD PTR [esi+ecx]
	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [ecx+edi]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR [eax-16]
	fld	QWORD PTR [ecx+edi]
	fld	QWORD PTR [esi+ecx]
	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [ecx+edi]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+ecx]
	mov	ecx, DWORD PTR [eax-12]
	fld	QWORD PTR [ecx+edi]
	fld	QWORD PTR [esi+ecx]
	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [ecx+edi]
	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+ecx]
	jne	$LN112@jacobi_eig

; 1813 :          }
; 1814 :          for ( j = 0 ; j < n ; j++ )

	mov	edx, DWORD PTR _n$[ebp]
$LN128@jacobi_eig:
	cmp	ebx, edx
	jge	SHORT $LN240@jacobi_eig
$LC17@jacobi_eig:

; 1815 :          { g = v[j][ip];

	mov	eax, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	fld	QWORD PTR [eax+edi]
	inc	ebx

; 1816 :            h = v[j][iq];

	fld	QWORD PTR [esi+eax]

; 1817 :            v[j][ip] = g - s*(h+g*tau);

	fld	ST(5)
	fmul	ST(0), ST(2)
	fadd	ST(0), ST(1)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(2)
	fstp	QWORD PTR [eax+edi]

; 1818 :            v[j][iq] = h + s*(g-h*tau);

	fld	ST(5)
	fmul	ST(0), ST(1)
	fsubp	ST(2), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(3)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR [esi+eax]
	cmp	ebx, edx
	jl	SHORT $LC17@jacobi_eig
$LN240@jacobi_eig:

; 1813 :          }
; 1814 :          for ( j = 0 ; j < n ; j++ )

	fstp	ST(1)
	fstp	ST(2)
$LN285@jacobi_eig:
	fxch	ST(1)
$LN34@jacobi_eig:

; 1774 :      for ( iq = ip+1 ; iq < n ; iq++ )

	add	DWORD PTR tv6285[ebp], 4

; 1813 :          }
; 1814 :          for ( j = 0 ; j < n ; j++ )

	fxch	ST(1)
	mov	eax, 1
	sub	DWORD PTR tv6422[ebp], eax
	add	DWORD PTR tv6021[ebp], eax
	add	esi, 8
	sub	DWORD PTR tv6611[ebp], eax
	jne	$LN124@jacobi_eig
$LN37@jacobi_eig:

; 1772 : 
; 1773 :     for ( ip = 0 ; ip < n-1 ; ip++ )

	mov	eax, DWORD PTR tv6715[ebp]
	dec	DWORD PTR tv7062[ebp]
	add	DWORD PTR tv6957[ebp], 4
	inc	eax
	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR tv6715[ebp], eax
	mov	eax, DWORD PTR _n$[ebp]
	dec	eax
	add	edi, 8
	cmp	ecx, eax
	jl	$LN38@jacobi_eig

; 1819 :          }
; 1820 :          nrot++;
; 1821 :       } /* end if */
; 1822 : 
; 1823 :      } /* end iq */
; 1824 :       /* end ip */
; 1825 : 
; 1826 :      for ( ip = 0 ; ip < n ; ip++ )

	mov	esi, DWORD PTR _n$[ebp]
	test	esi, esi
	jle	SHORT $LN49@jacobi_eig
	mov	eax, DWORD PTR _b$[ebp]

; 1829 :        z[ip] = 0.0;

	mov	edx, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _work$[ebp]
	sub	edx, eax
	sub	ecx, eax
$LN250@jacobi_eig:

; 1819 :          }
; 1820 :          nrot++;
; 1821 :       } /* end if */
; 1822 : 
; 1823 :      } /* end iq */
; 1824 :       /* end ip */
; 1825 : 
; 1826 :      for ( ip = 0 ; ip < n ; ip++ )

	fld	QWORD PTR [eax]
	add	eax, 8
	dec	esi

; 1827 :      { b[ip] += z[ip];

	fadd	QWORD PTR [ecx+eax-8]
	fst	QWORD PTR [eax-8]

; 1828 :        d[ip] = b[ip];

	fstp	QWORD PTR [edx+eax-8]

; 1829 :        z[ip] = 0.0;

	fxch	ST(1)
	fst	QWORD PTR [ecx+eax-8]
	fxch	ST(1)
	jne	SHORT $LN250@jacobi_eig
$LN49@jacobi_eig:

; 1760 :   }
; 1761 : 
; 1762 :   nrot = 0;
; 1763 :   for ( i = 1 ; i < 50 ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, 50					; 00000032H
	jl	$LN125@jacobi_eig

; 1830 :      }
; 1831 :   } /* end i */
; 1832 : 
; 1833 :   kb_error(2548,"50 Jacobi iterations should never happen.\n",WARNING);

	push	2
	fstp	ST(0)
	push	OFFSET ??_C@_0CL@BDCMKFGP@50?5Jacobi?5iterations?5should?5neve@
	fstp	ST(0)
	push	2548					; 000009f4H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN9@jacobi_eig:
	pop	edi
	pop	esi
	pop	ebx

; 1852 :     }
; 1853 :   }
; 1854 :   return; 
; 1855 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN192@jacobi_eig:

; 1779 :        else if ( fabs(a[ip][iq]) > tresh ) 

	fstp	ST(0)
	jmp	$LN285@jacobi_eig
$LN170@jacobi_eig:

; 1768 :     if ( sm == 0.0 ) goto jacobi_exit; /* normal exit */

	fstp	ST(0)

; 1834 :   return;
; 1835 : 
; 1836 : jacobi_exit:
; 1837 :   /* sort eigenpairs in descending order, insertion sort */
; 1838 :   for ( i = 0 ; i < n-1 ; i++ )

	lea	eax, DWORD PTR [ebx-1]
	fstp	ST(0)
	xor	edx, edx
	fstp	ST(0)
$jacobi_exit$90404:
	test	eax, eax
	jle	SHORT $LN9@jacobi_eig
	mov	DWORD PTR tv8423[ebp], eax
$LL130@jacobi_eig:

; 1839 :   { REAL p;
; 1840 :     int k;
; 1841 :     k = i;
; 1842 :     p = d[i];

	mov	eax, DWORD PTR _d$[ebp]
	fld	QWORD PTR [eax+edx*8]

; 1843 :     for ( j = i + 1 ; j < n ; j++ )

	lea	esi, DWORD PTR [edx+1]
	mov	ecx, edx
	mov	DWORD PTR tv3696[ebp], esi
	cmp	esi, ebx
	jge	$LN282@jacobi_eig
	cmp	DWORD PTR tv8423[ebp], 4
	jl	SHORT $LN131@jacobi_eig

; 1844 :     { if ( d[j] >= p ) 

	lea	edi, DWORD PTR [eax+edx*8+24]

; 1843 :     for ( j = i + 1 ; j < n ; j++ )

$LN119@jacobi_eig:

; 1844 :     { if ( d[j] >= p ) 

	fcom	QWORD PTR [edi-16]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN115@jacobi_eig
	fstp	ST(0)

; 1845 :       { k = j; p = d[j]; }

	mov	ecx, esi
	fld	QWORD PTR [edi-16]
$LN115@jacobi_eig:

; 1844 :     { if ( d[j] >= p ) 

	fcom	QWORD PTR [edi-8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN116@jacobi_eig
	fstp	ST(0)
	lea	ecx, DWORD PTR [esi+1]

; 1845 :       { k = j; p = d[j]; }

	fld	QWORD PTR [edi-8]
$LN116@jacobi_eig:

; 1844 :     { if ( d[j] >= p ) 

	fcom	QWORD PTR [edi]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN117@jacobi_eig
	fstp	ST(0)
	lea	ecx, DWORD PTR [esi+2]

; 1845 :       { k = j; p = d[j]; }

	fld	QWORD PTR [edi]
$LN117@jacobi_eig:

; 1844 :     { if ( d[j] >= p ) 

	fcom	QWORD PTR [edi+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN118@jacobi_eig
	fstp	ST(0)
	lea	ecx, DWORD PTR [esi+3]

; 1845 :       { k = j; p = d[j]; }

	fld	QWORD PTR [edi+8]
$LN118@jacobi_eig:

; 1844 :     { if ( d[j] >= p ) 

	add	esi, 4
	lea	eax, DWORD PTR [ebx-3]
	add	edi, 32					; 00000020H
	cmp	esi, eax
	jl	SHORT $LN119@jacobi_eig
$LN131@jacobi_eig:

; 1843 :     for ( j = i + 1 ; j < n ; j++ )

	cmp	esi, ebx
	jge	SHORT $LN113@jacobi_eig
	mov	edi, DWORD PTR _d$[ebp]
$LC8@jacobi_eig:

; 1844 :     { if ( d[j] >= p ) 

	fcom	QWORD PTR [edi+esi*8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN7@jacobi_eig
	fstp	ST(0)

; 1845 :       { k = j; p = d[j]; }

	mov	ecx, esi
	fld	QWORD PTR [edi+esi*8]
$LN7@jacobi_eig:

; 1843 :     for ( j = i + 1 ; j < n ; j++ )

	inc	esi
	cmp	esi, ebx
	jl	SHORT $LC8@jacobi_eig
$LN113@jacobi_eig:

; 1846 :     }
; 1847 :     if ( k != i )

	cmp	ecx, edx
	je	$LN282@jacobi_eig

; 1848 :     { d[k] = d[i];

	mov	eax, DWORD PTR _d$[ebp]
	fld	QWORD PTR [eax+edx*8]

; 1849 :       d[i] = p;
; 1850 :       for ( j = 0 ; j < n ; j++ ) 

	mov	DWORD PTR _j$[ebp], 0
	fstp	QWORD PTR [eax+ecx*8]
	fstp	QWORD PTR [eax+edx*8]
	cmp	ebx, 4
	jl	SHORT $LC121@jacobi_eig

; 1848 :     { d[k] = d[i];

	mov	eax, DWORD PTR _v$[ebp]
	lea	edi, DWORD PTR [ebx-4]
	shr	edi, 2
	add	eax, 8
	inc	edi
	lea	esi, DWORD PTR [edi*4]
	mov	DWORD PTR _j$[ebp], esi
	npad	5

; 1849 :       d[i] = p;
; 1850 :       for ( j = 0 ; j < n ; j++ ) 

$LL122@jacobi_eig:

; 1851 :       { p = v[j][i]; v[j][i] = v[j][k]; v[j][k] = p; }

	mov	esi, DWORD PTR [eax-8]
	fld	QWORD PTR [esi+edx*8]
	add	eax, 16					; 00000010H
	dec	edi
	fld	QWORD PTR [esi+ecx*8]
	fstp	QWORD PTR [esi+edx*8]
	fstp	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR [eax-20]
	fld	QWORD PTR [esi+edx*8]
	fld	QWORD PTR [esi+ecx*8]
	fstp	QWORD PTR [esi+edx*8]
	fstp	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR [eax-16]
	fld	QWORD PTR [esi+edx*8]
	fld	QWORD PTR [esi+ecx*8]
	fstp	QWORD PTR [esi+edx*8]
	fstp	QWORD PTR [esi+ecx*8]
	mov	esi, DWORD PTR [eax-12]
	fld	QWORD PTR [esi+edx*8]
	fld	QWORD PTR [esi+ecx*8]
	fstp	QWORD PTR [esi+edx*8]
	fstp	QWORD PTR [esi+ecx*8]
	jne	SHORT $LL122@jacobi_eig
$LC121@jacobi_eig:

; 1849 :       d[i] = p;
; 1850 :       for ( j = 0 ; j < n ; j++ ) 

	mov	esi, DWORD PTR _j$[ebp]
	cmp	esi, ebx
	jge	SHORT $LN10@jacobi_eig
	mov	edi, DWORD PTR _v$[ebp]
	npad	4
$LC3@jacobi_eig:

; 1851 :       { p = v[j][i]; v[j][i] = v[j][k]; v[j][k] = p; }

	mov	eax, DWORD PTR [edi+esi*4]
	fld	QWORD PTR [eax+edx*8]
	inc	esi
	fld	QWORD PTR [eax+ecx*8]
	fstp	QWORD PTR [eax+edx*8]
	fstp	QWORD PTR [eax+ecx*8]
	cmp	esi, ebx
	jl	SHORT $LC3@jacobi_eig

; 1849 :       d[i] = p;
; 1850 :       for ( j = 0 ; j < n ; j++ ) 

	jmp	SHORT $LN10@jacobi_eig
$LN282@jacobi_eig:

; 1846 :     }
; 1847 :     if ( k != i )

	fstp	ST(0)
$LN10@jacobi_eig:

; 1834 :   return;
; 1835 : 
; 1836 : jacobi_exit:
; 1837 :   /* sort eigenpairs in descending order, insertion sort */
; 1838 :   for ( i = 0 ; i < n-1 ; i++ )

	mov	edx, DWORD PTR tv3696[ebp]
	dec	DWORD PTR tv8423[ebp]
	lea	eax, DWORD PTR [ebx-1]
	cmp	edx, eax
	jl	$LL130@jacobi_eig
	pop	edi
	pop	esi
	pop	ebx

; 1852 :     }
; 1853 :   }
; 1854 :   return; 
; 1855 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_jacobi_eigenpairs ENDP
_TEXT	ENDS
PUBLIC	_det_hess
; Function compile flags: /Ogtp
;	COMDAT _det_hess
_TEXT	SEGMENT
tv1967 = -12						; size = 4
tv2821 = -8						; size = 4
_k$ = -8						; size = 4
_jj1$ = -8						; size = 4
_i1$ = -4						; size = 4
_a$ = 8							; size = 4
_h$ = 12						; size = 4
_n$ = 16						; size = 4
_det_hess PROC						; COMDAT

; 1870 : { int i1,i2,jj1,j2,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 1871 : 
; 1872 :   /* copy original matrix into h lots of times */
; 1873 :   for ( i1 = 0 ; i1 < n ; i1++ )

	mov	ebx, DWORD PTR _n$[ebp]
	xor	edx, edx
	push	esi
	push	edi
	mov	DWORD PTR _i1$[ebp], edx
	test	ebx, ebx
	jle	$LN37@det_hess
	npad	7
$LL83@det_hess:

; 1874 :     for ( jj1 = 0 ; jj1 < n ; jj1++ )

	xor	eax, eax
	mov	DWORD PTR _jj1$[ebp], eax
$LL84@det_hess:

; 1875 :      for ( i2 = 0 ; i2 < n ; i2++ )

	xor	esi, esi
$LL85@det_hess:

; 1876 :       for ( j2 = 0 ; j2 < n ; j2++ )

	xor	edi, edi
	cmp	ebx, 4
	jl	SHORT $LC69@det_hess
	mov	edi, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR [eax+esi*4]

; 1877 :          h[i1][jj1][i2][j2] = a[i2][j2];

	mov	ebx, ecx
	lea	edx, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR _n$[ebp]
	add	ecx, -4					; fffffffcH
	sub	ebx, edi
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [edi+8]
	lea	edi, DWORD PTR [ecx*4]
	npad	5
$LL70@det_hess:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	add	edx, 32					; 00000020H
	dec	ecx
	fld	QWORD PTR [ebx+eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LL70@det_hess

; 1876 :       for ( j2 = 0 ; j2 < n ; j2++ )

	mov	eax, DWORD PTR _jj1$[ebp]
	mov	edx, DWORD PTR _i1$[ebp]
	mov	ebx, DWORD PTR _n$[ebp]
$LC69@det_hess:
	cmp	edi, ebx
	jge	SHORT $LN32@det_hess
	mov	ecx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+esi*4]
	mov	edx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	lea	ecx, DWORD PTR [eax+edi*8]
	sub	edx, eax
	mov	eax, ebx
	sub	eax, edi
	npad	6
$LC30@det_hess:

; 1877 :          h[i1][jj1][i2][j2] = a[i2][j2];

	fld	QWORD PTR [ecx+edx]
	add	ecx, 8
	dec	eax
	fstp	QWORD PTR [ecx-8]
	jne	SHORT $LC30@det_hess

; 1876 :       for ( j2 = 0 ; j2 < n ; j2++ )

	mov	edx, DWORD PTR _i1$[ebp]
	mov	eax, DWORD PTR _jj1$[ebp]
$LN32@det_hess:

; 1875 :      for ( i2 = 0 ; i2 < n ; i2++ )

	inc	esi
	cmp	esi, ebx
	jl	$LL85@det_hess

; 1874 :     for ( jj1 = 0 ; jj1 < n ; jj1++ )

	inc	eax
	mov	DWORD PTR _jj1$[ebp], eax
	cmp	eax, ebx
	jl	$LL84@det_hess

; 1871 : 
; 1872 :   /* copy original matrix into h lots of times */
; 1873 :   for ( i1 = 0 ; i1 < n ; i1++ )

	inc	edx
	mov	DWORD PTR _i1$[ebp], edx
	cmp	edx, ebx
	jl	$LL83@det_hess
$LN37@det_hess:

; 1878 : 
; 1879 :   /* replace element row and column with identity stuff */
; 1880 :   for ( i1 = 0 ; i1 < n ; i1++ )

	fldz
	xor	esi, esi
	mov	DWORD PTR _i1$[ebp], esi
	test	ebx, ebx
	jle	$LN88@det_hess
	fld1
$LN86@det_hess:

; 1887 :     }
; 1888 : 
; 1889 :   /* find adjoints */
; 1890 :   for ( i1 = 0 ; i1 < n ; i1++ )

	mov	ecx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR [ecx+esi*4]
	xor	eax, eax
	mov	DWORD PTR tv1967[ebp], edx
$LN82@det_hess:

; 1882 :     { for ( k = 0 ; k < n ; k++ )

	xor	edi, edi
	cmp	ebx, 4
	jl	SHORT $LN77@det_hess
	mov	ecx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR [edx+eax*4]
	lea	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+esi*4]
	lea	esi, DWORD PTR [ebx-4]
	shr	esi, 2
	add	ecx, 16					; 00000010H
	inc	esi
	lea	edi, DWORD PTR [esi*4]
	mov	DWORD PTR _k$[ebp], edi
$LN73@det_hess:

; 1883 :       { h[i1][jj1][i1][k] = 0.0;
; 1884 :          h[i1][jj1][k][jj1] = 0.0;

	mov	edi, DWORD PTR [edx-8]
	fxch	ST(1)
	fst	QWORD PTR [ecx-16]
	add	ecx, 32					; 00000020H
	fst	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR [edx-4]
	fst	QWORD PTR [ecx-40]
	add	edx, 16					; 00000010H
	dec	esi
	fst	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR [edx-16]
	fst	QWORD PTR [ecx-32]
	fst	QWORD PTR [edi+eax*8]
	mov	edi, DWORD PTR [edx-12]
	fst	QWORD PTR [ecx-24]
	fst	QWORD PTR [edi+eax*8]
	fxch	ST(1)
	jne	SHORT $LN73@det_hess

; 1882 :     { for ( k = 0 ; k < n ; k++ )

	mov	edi, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR _i1$[ebp]
$LN77@det_hess:
	cmp	edi, ebx
	jge	SHORT $LN71@det_hess
	mov	ecx, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR [edx+eax*4]
	lea	edx, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [ecx+esi*4]
	mov	DWORD PTR tv2821[ebp], edx
	lea	edx, DWORD PTR [ecx+edi*8]
	mov	ecx, ebx
	sub	ecx, edi
$LN105@det_hess:

; 1883 :       { h[i1][jj1][i1][k] = 0.0;
; 1884 :          h[i1][jj1][k][jj1] = 0.0;

	mov	edi, DWORD PTR tv2821[ebp]
	fxch	ST(1)
	mov	edi, DWORD PTR [edi]
	fst	QWORD PTR [edx]
	add	DWORD PTR tv2821[ebp], 4
	fst	QWORD PTR [edi+eax*8]
	add	edx, 8
	fxch	ST(1)
	dec	ecx
	jne	SHORT $LN105@det_hess
$LN71@det_hess:

; 1885 :       }
; 1886 :       h[i1][jj1][i1][jj1] = 1.0;

	mov	edx, DWORD PTR tv1967[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+esi*4]
	fst	QWORD PTR [edx+eax*8]
	inc	eax
	cmp	eax, ebx
	jl	$LN82@det_hess

; 1878 : 
; 1879 :   /* replace element row and column with identity stuff */
; 1880 :   for ( i1 = 0 ; i1 < n ; i1++ )

	inc	esi
	mov	DWORD PTR _i1$[ebp], esi
	cmp	esi, ebx
	jl	$LN86@det_hess

; 1881 :     for ( jj1 = 0 ; jj1 < n ; jj1++ )

	fstp	ST(1)
$LN88@det_hess:
	fstp	ST(0)

; 1887 :     }
; 1888 : 
; 1889 :   /* find adjoints */
; 1890 :   for ( i1 = 0 ; i1 < n ; i1++ )

	mov	DWORD PTR _i1$[ebp], 0
	test	ebx, ebx
	jle	SHORT $LN16@det_hess
	mov	edi, DWORD PTR _h$[ebp]
$LL80@det_hess:
	mov	eax, DWORD PTR [edi]

; 1891 :     for ( jj1 = 0 ; jj1 < n ; jj1++ )

	xor	esi, esi
	npad	4
$LL15@det_hess:

; 1892 :     { det_adjoint(h[i1][jj1],n);

	mov	eax, DWORD PTR [eax+esi*4]
	push	ebx
	push	eax
	call	_det_adjoint
	fstp	ST(0)

; 1893 :       h[i1][jj1][jj1][i1] = 0.0; /* need fixup */

	mov	eax, DWORD PTR [edi]
	fldz
	mov	ecx, DWORD PTR [eax+esi*4]
	mov	edx, DWORD PTR [ecx+esi*4]
	mov	ecx, DWORD PTR _i1$[ebp]
	inc	esi
	fstp	QWORD PTR [edx+ecx*8]
	add	esp, 8
	cmp	esi, ebx
	jl	SHORT $LL15@det_hess

; 1887 :     }
; 1888 : 
; 1889 :   /* find adjoints */
; 1890 :   for ( i1 = 0 ; i1 < n ; i1++ )

	mov	eax, ecx
	inc	eax
	add	edi, 4
	mov	DWORD PTR _i1$[ebp], eax
	cmp	eax, ebx
	jl	SHORT $LL80@det_hess
$LN16@det_hess:

; 1894 :     }
; 1895 : 
; 1896 :   /* transpose to get back to hessian */
; 1897 :   for ( i1 = 0 ; i1 < n ; i1++ )

	xor	edx, edx
	mov	DWORD PTR _i1$[ebp], edx
	test	ebx, ebx
	jle	$LN10@det_hess
	npad	2
$LL81@det_hess:

; 1898 :     for ( jj1 = 0 ; jj1 < n ; jj1++ )

	xor	eax, eax
	mov	DWORD PTR _jj1$[ebp], eax
	npad	11
$LL9@det_hess:

; 1899 :      for ( i2 = 1 ; i2 < n ; i2++ )

	mov	ecx, 1
	cmp	ebx, ecx
	jle	$LN8@det_hess
	npad	3
$LL79@det_hess:

; 1900 :       for ( j2 = 0 ; j2 < i2 ; j2++ )

	xor	ebx, ebx
	cmp	ecx, 4
	jl	SHORT $LC75@det_hess
	mov	esi, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	eax, DWORD PTR [edx+eax*4]
	lea	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	esi, DWORD PTR [ecx-4]
	shr	esi, 2
	add	eax, 16					; 00000010H
	inc	esi
	lea	ebx, DWORD PTR [esi*4]
$LL76@det_hess:

; 1901 :       { REAL tmp =  h[i1][jj1][i2][j2];

	fld	QWORD PTR [eax-16]
	mov	edi, DWORD PTR [edx-8]

; 1902 :          h[i1][jj1][i2][j2] = h[i1][jj1][j2][i2];

	fld	QWORD PTR [edi+ecx*8]
	lea	edi, DWORD PTR [edi+ecx*8]
	fstp	QWORD PTR [eax-16]

; 1903 :          h[i1][jj1][j2][i2] = tmp;

	add	eax, 32					; 00000020H
	add	edx, 16					; 00000010H
	dec	esi
	fstp	QWORD PTR [edi]
	fld	QWORD PTR [eax-40]
	mov	edi, DWORD PTR [edx-20]
	fld	QWORD PTR [edi+ecx*8]
	lea	edi, DWORD PTR [edi+ecx*8]
	fstp	QWORD PTR [eax-40]
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR [edx-16]
	fld	QWORD PTR [eax-32]
	lea	edi, DWORD PTR [edi+ecx*8]
	fld	QWORD PTR [edi]
	fstp	QWORD PTR [eax-32]
	fstp	QWORD PTR [edi]
	mov	edi, DWORD PTR [edx-12]
	fld	QWORD PTR [eax-24]
	lea	edi, DWORD PTR [edi+ecx*8]
	fld	QWORD PTR [edi]
	fstp	QWORD PTR [eax-24]
	fstp	QWORD PTR [edi]
	jne	SHORT $LL76@det_hess

; 1900 :       for ( j2 = 0 ; j2 < i2 ; j2++ )

	mov	eax, DWORD PTR _jj1$[ebp]
	mov	edx, DWORD PTR _i1$[ebp]
$LC75@det_hess:
	cmp	ebx, ecx
	jge	SHORT $LN5@det_hess
	mov	esi, DWORD PTR _h$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	eax, DWORD PTR [edx+eax*4]
	lea	edi, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	esi, ecx
	lea	eax, DWORD PTR [eax+ebx*8]
	sub	esi, ebx
$LC3@det_hess:

; 1901 :       { REAL tmp =  h[i1][jj1][i2][j2];

	mov	edx, DWORD PTR [edi]
	fld	QWORD PTR [eax]

; 1902 :          h[i1][jj1][i2][j2] = h[i1][jj1][j2][i2];

	fld	QWORD PTR [edx+ecx*8]
	lea	edx, DWORD PTR [edx+ecx*8]
	fstp	QWORD PTR [eax]
	add	eax, 8
	add	edi, 4
	dec	esi

; 1903 :          h[i1][jj1][j2][i2] = tmp;

	fstp	QWORD PTR [edx]
	jne	SHORT $LC3@det_hess

; 1900 :       for ( j2 = 0 ; j2 < i2 ; j2++ )

	mov	eax, DWORD PTR _jj1$[ebp]
	mov	edx, DWORD PTR _i1$[ebp]
$LN5@det_hess:

; 1899 :      for ( i2 = 1 ; i2 < n ; i2++ )

	inc	ecx
	cmp	ecx, DWORD PTR _n$[ebp]
	jl	$LL79@det_hess
	mov	ebx, DWORD PTR _n$[ebp]
$LN8@det_hess:

; 1898 :     for ( jj1 = 0 ; jj1 < n ; jj1++ )

	inc	eax
	mov	DWORD PTR _jj1$[ebp], eax
	cmp	eax, ebx
	jl	$LL9@det_hess

; 1894 :     }
; 1895 : 
; 1896 :   /* transpose to get back to hessian */
; 1897 :   for ( i1 = 0 ; i1 < n ; i1++ )

	inc	edx
	mov	DWORD PTR _i1$[ebp], edx
	cmp	edx, ebx
	jl	$LL81@det_hess
$LN10@det_hess:
	pop	edi
	pop	esi
	pop	ebx

; 1904 :       }
; 1905 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_det_hess ENDP
_TEXT	ENDS
PUBLIC	_gram_schmidt
; Function compile flags: /Ogtp
;	COMDAT _gram_schmidt
_TEXT	SEGMENT
_k$ = -24						; size = 4
tv2119 = -20						; size = 4
tv2063 = -16						; size = 4
tv2058 = -12						; size = 4
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_mat$ = 8						; size = 4
_rows$ = 12						; size = 4
_cols$ = 16						; size = 4
_gram_schmidt PROC					; COMDAT

; 1921 : { int i,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1922 :   REAL d;
; 1923 :   for ( i = 0 ; i < rows ; i++ )

	mov	eax, DWORD PTR _rows$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _i$[ebp], ecx
	test	eax, eax
	jle	$LN15@gram_schmi
	push	ebx
	mov	ebx, DWORD PTR _mat$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _cols$[ebp]
	mov	DWORD PTR tv2058[ebp], ebx
	npad	14
$LL43@gram_schmi:

; 1924 :   { for ( j = 0 ; j < i ; j++ )

	mov	DWORD PTR _j$[ebp], 0
	test	ecx, ecx
	jle	$LN40@gram_schmi

; 1937 :     }
; 1938 :   }
; 1939 :   return rows;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR tv2063[ebp], eax
$LL42@gram_schmi:

; 1925 :     { REAL c = dot(mat[i],mat[j],cols);

	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR tv2063[ebp]
	push	edi
	push	esi
	push	eax
	call	_dot
	add	esp, 12					; 0000000cH

; 1926 :       for ( k = 0 ; k < cols ; k++ ) mat[i][k] -= c*mat[j][k];

	xor	edx, edx
	cmp	edi, 4
	jl	SHORT $LC31@gram_schmi

; 1925 :     { REAL c = dot(mat[i],mat[j],cols);

	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [ecx+8]

; 1926 :       for ( k = 0 ; k < cols ; k++ ) mat[i][k] -= c*mat[j][k];

	mov	ebx, esi
	sub	ebx, ecx
	lea	ecx, DWORD PTR [edi-4]
	shr	ecx, 2
	mov	DWORD PTR tv2119[ebp], ebx
	inc	ecx
	lea	ebx, DWORD PTR [ecx*4]
	mov	DWORD PTR _k$[ebp], ebx
	mov	ebx, DWORD PTR tv2119[ebp]
	lea	edx, DWORD PTR [esi+24]
$LN32@gram_schmi:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	dec	ecx
	fsubr	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [eax+ebx-32]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN32@gram_schmi

; 1925 :     { REAL c = dot(mat[i],mat[j],cols);

	mov	edx, DWORD PTR _k$[ebp]
	mov	ebx, DWORD PTR tv2058[ebp]
$LC31@gram_schmi:

; 1926 :       for ( k = 0 ; k < cols ; k++ ) mat[i][k] -= c*mat[j][k];

	cmp	edx, edi
	jge	SHORT $LN54@gram_schmi
	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [ecx+edx*8]
	sub	esi, ecx
	mov	ecx, edi
	sub	ecx, edx
$LC11@gram_schmi:
	fld	QWORD PTR [eax+esi]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(1)
	fsubr	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC11@gram_schmi
$LN54@gram_schmi:

; 1924 :   { for ( j = 0 ; j < i ; j++ )

	mov	eax, DWORD PTR _j$[ebp]

; 1926 :       for ( k = 0 ; k < cols ; k++ ) mat[i][k] -= c*mat[j][k];

	fstp	ST(0)
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR _i$[ebp]
	jl	$LL42@gram_schmi
$LN40@gram_schmi:

; 1927 :     }
; 1928 :     d = dot(mat[i],mat[i],cols);

	mov	eax, DWORD PTR [ebx]
	push	edi
	push	eax
	push	eax
	call	_dot

; 1929 :     if ( d == 0.0 ) 

	fld	ST(0)
	fldz
	add	esp, 12					; 0000000cH
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	$LN8@gram_schmi

; 1930 :     { rows--; 

	dec	DWORD PTR _rows$[ebp]
	fstp	ST(0)

; 1931 :       for ( k = 0 ; k < cols ; k++ ) mat[i][k] = mat[rows][k];

	xor	esi, esi
	cmp	edi, 4
	jl	SHORT $LC34@gram_schmi
	mov	edx, DWORD PTR _rows$[ebp]
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	esi, DWORD PTR [ebx]
	mov	ebx, ecx
	lea	edx, DWORD PTR [ecx+24]
	lea	ecx, DWORD PTR [edi-4]
	sub	ebx, esi
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [esi+8]
	lea	esi, DWORD PTR [ecx*4]
$LL35@gram_schmi:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	add	edx, 32					; 00000020H
	dec	ecx
	fld	QWORD PTR [eax+ebx-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LL35@gram_schmi

; 1930 :     { rows--; 

	mov	ebx, DWORD PTR tv2058[ebp]
$LC34@gram_schmi:

; 1931 :       for ( k = 0 ; k < cols ; k++ ) mat[i][k] = mat[rows][k];

	cmp	esi, edi
	jge	SHORT $LN33@gram_schmi
	mov	ecx, DWORD PTR _mat$[ebp]
	mov	edx, DWORD PTR _rows$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [ebx]
	sub	edx, DWORD PTR [ebx]
	mov	ecx, edi
	lea	eax, DWORD PTR [eax+esi*8]
	sub	ecx, esi
	npad	3
$LC7@gram_schmi:
	fld	QWORD PTR [eax+edx]
	add	eax, 8
	dec	ecx
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC7@gram_schmi
$LN33@gram_schmi:

; 1932 :       i--;

	dec	DWORD PTR _i$[ebp]
	sub	ebx, 4

; 1933 :     }
; 1934 :     else

	jmp	SHORT $LN16@gram_schmi
$LN8@gram_schmi:

; 1935 :     { d = 1/sqrt(d);

	call	__CIsqrt
	fld1

; 1936 :       for ( k = 0 ; k < cols ; k++ ) mat[i][k] *= d;

	xor	edx, edx
	fdivrp	ST(1), ST(0)
	cmp	edi, 4
	jl	SHORT $LC37@gram_schmi

; 1935 :     { d = 1/sqrt(d);

	mov	eax, DWORD PTR [ebx]
	lea	ecx, DWORD PTR [edi-4]
	shr	ecx, 2
	add	eax, 16					; 00000010H
	inc	ecx
	lea	edx, DWORD PTR [ecx*4]

; 1936 :       for ( k = 0 ; k < cols ; k++ ) mat[i][k] *= d;

$LN38@gram_schmi:
	fld	ST(0)
	add	eax, 32					; 00000020H
	dec	ecx
	fmul	QWORD PTR [eax-48]
	fstp	QWORD PTR [eax-48]
	fld	QWORD PTR [eax-40]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-40]
	fld	ST(0)
	fmul	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [eax-24]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-24]
	jne	SHORT $LN38@gram_schmi
$LC37@gram_schmi:
	cmp	edx, edi
	jge	SHORT $LN66@gram_schmi
	mov	eax, DWORD PTR [ebx]
	mov	ecx, edi
	lea	eax, DWORD PTR [eax+edx*8]
	sub	ecx, edx
$LC3@gram_schmi:
	fld	QWORD PTR [eax]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(1)
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC3@gram_schmi
$LN66@gram_schmi:
	fstp	ST(0)
$LN16@gram_schmi:

; 1922 :   REAL d;
; 1923 :   for ( i = 0 ; i < rows ; i++ )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _rows$[ebp]
	inc	ecx
	add	ebx, 4
	mov	DWORD PTR _i$[ebp], ecx
	mov	DWORD PTR tv2058[ebp], ebx
	cmp	ecx, eax
	jl	$LL43@gram_schmi
	pop	edi
	pop	esi
	pop	ebx
$LN15@gram_schmi:

; 1940 : } 

	mov	esp, ebp
	pop	ebp
	ret	0
_gram_schmidt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@FOPHLEO@Sparse?5init?5alloc?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	_sp_hash_init
EXTRN	_hessian_quiet_flag:DWORD
;	COMDAT ??_C@_0BH@FOPHLEO@Sparse?5init?5alloc?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BH@FOPHLEO@Sparse?5init?5alloc?3?5?$CFd?6?$AA@ DB 'Sparse init all'
	DB	'oc: %d', 0aH, 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _sp_hash_init
_TEXT	SEGMENT
_S$ = 8							; size = 4
_size_estimate$ = 12					; size = 4
_sp_hash_init PROC					; COMDAT

; 1993 : { int i;

	push	ebp
	mov	ebp, esp

; 1994 :   int estimate = SDIM*(web.skel[VERTEX].max_ord+10);

	mov	eax, DWORD PTR _web+68

; 1995 :    
; 1996 :   S->table_size = size_estimate > 0 ? 
; 1997 :        ( size_estimate > estimate ? estimate : size_estimate) : 
; 1998 :          estimate;

	mov	ecx, DWORD PTR _size_estimate$[ebp]
	add	eax, 10					; 0000000aH
	imul	eax, DWORD PTR _web+616
	test	ecx, ecx
	jle	SHORT $LN10@sp_hash_in
	cmp	ecx, eax
	jle	SHORT $LN11@sp_hash_in
$LN10@sp_hash_in:
	mov	ecx, eax
$LN11@sp_hash_in:

; 1999 :   S->max_fill = 4*S->table_size/5;  /* leave enough empty for decent hash */

	lea	edx, DWORD PTR [ecx*4]
	mov	eax, 1717986919				; 66666667H
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	add	eax, edx
	mov	DWORD PTR [esi+32], ecx
	mov	DWORD PTR [esi+36], eax

; 2000 :   if ( !hessian_quiet_flag )

	cmp	DWORD PTR _hessian_quiet_flag, 0
	jne	SHORT $LN5@sp_hash_in

; 2001 :   { sprintf(msg,"Sparse init alloc: %d\n",S->table_size);

	push	ecx
	mov	ecx, DWORD PTR _msg
	push	OFFSET ??_C@_0BH@FOPHLEO@Sparse?5init?5alloc?3?5?$CFd?6?$AA@
	push	ecx
	call	_sprintf

; 2002 :     outstring(msg);

	mov	edx, DWORD PTR _msg
	push	edx
	call	_outstring
	add	esp, 16					; 00000010H
$LN5@sp_hash_in:

; 2003 :   }
; 2004 :   S->hashcount = 0;
; 2005 :   if ( S->hashtable ) temp_free((char*)S->hashtable);

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [esi+40], 0
	test	eax, eax
	je	SHORT $LN4@sp_hash_in
	push	eax
	call	_temp_free
	add	esp, 4
$LN4@sp_hash_in:

; 2006 :   S->hashtable = 
; 2007 :      (struct sp_entry *)temp_calloc(S->table_size,sizeof(struct sp_entry));

	mov	eax, DWORD PTR [esi+32]
	push	2007					; 000007d7H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	push	16					; 00000010H
	push	eax
	call	_kb_temp_calloc
	mov	DWORD PTR [esi+44], eax

; 2008 :   for ( i = 0 ; i < S->table_size ; i++ ) S->hashtable[i].row = HASHEMPTY;

	xor	eax, eax
	add	esp, 16					; 00000010H
	cmp	DWORD PTR [esi+32], eax
	jle	SHORT $LN14@sp_hash_in

; 2006 :   S->hashtable = 
; 2007 :      (struct sp_entry *)temp_calloc(S->table_size,sizeof(struct sp_entry));

	xor	ecx, ecx
$LL3@sp_hash_in:

; 2008 :   for ( i = 0 ; i < S->table_size ; i++ ) S->hashtable[i].row = HASHEMPTY;

	mov	edx, DWORD PTR [esi+44]
	mov	DWORD PTR [ecx+edx], -1
	inc	eax
	add	ecx, 16					; 00000010H
	cmp	eax, DWORD PTR [esi+32]
	jl	SHORT $LL3@sp_hash_in

; 2009 :   S->hash_extraprobes = 0;

	mov	DWORD PTR [esi+48], 0
	pop	esi

; 2010 : }

	pop	ebp
	ret	0
$LN14@sp_hash_in:

; 2009 :   S->hash_extraprobes = 0;

	mov	DWORD PTR [esi+48], eax
	pop	esi

; 2010 : }

	pop	ebp
	ret	0
_sp_hash_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@NFEGIGMI@Expanded?5hashtable?5size?3?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	_sp_hash_expand
;	COMDAT ??_C@_0BO@NFEGIGMI@Expanded?5hashtable?5size?3?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@NFEGIGMI@Expanded?5hashtable?5size?3?5?$CFd?4?6?$AA@ DB 'Expand'
	DB	'ed hashtable size: %d.', 0aH, 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _sp_hash_expand
_TEXT	SEGMENT
_oldtable$ = -4						; size = 4
tv65 = 8						; size = 4
_S$ = 8							; size = 4
_sp_hash_expand PROC					; COMDAT

; 2020 : { struct sp_entry *newtable,*oldtable;

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	push	edi

; 2021 :   int i;
; 2022 :   struct sp_entry *e;
; 2023 :   int newsize; 
; 2024 :   int oldsize = S->table_size;

	mov	edi, DWORD PTR _S$[ebp]

; 2025 : 
; 2026 :   if ( !S->hashtable ) sp_hash_init(S,0);

	cmp	DWORD PTR [edi+44], 0
	mov	ebx, DWORD PTR [edi+32]
	jne	SHORT $LN13@sp_hash_ex
	push	0
	push	edi
	call	_sp_hash_init
	add	esp, 8
$LN13@sp_hash_ex:

; 2027 :   newsize = S->table_size*2; 

	mov	esi, DWORD PTR [edi+32]

; 2028 :   oldtable = S->hashtable;

	mov	eax, DWORD PTR [edi+44]

; 2029 :   newtable = 
; 2030 :      (struct sp_entry *)temp_calloc(newsize,sizeof(struct sp_entry));

	push	2030					; 000007eeH
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	add	esi, esi
	push	16					; 00000010H
	push	esi
	mov	DWORD PTR _oldtable$[ebp], eax
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
	mov	ecx, eax

; 2031 :   for ( i = 0 ; i < newsize ; i++ ) newtable[i].row = HASHEMPTY;

	test	esi, esi
	jle	SHORT $LN10@sp_hash_ex

; 2027 :   newsize = S->table_size*2; 

	mov	edx, esi
$LL12@sp_hash_ex:

; 2031 :   for ( i = 0 ; i < newsize ; i++ ) newtable[i].row = HASHEMPTY;

	mov	DWORD PTR [eax], -1
	add	eax, 16					; 00000010H
	dec	edx
	jne	SHORT $LL12@sp_hash_ex
$LN10@sp_hash_ex:

; 2032 :   S->table_size =  newsize;

	mov	DWORD PTR [edi+32], esi

; 2033 :   S->max_fill = 4*S->table_size/5;

	add	esi, esi
	add	esi, esi
	mov	eax, 1717986919				; 66666667H
	imul	esi

; 2034 :   S->hashtable = newtable;
; 2035 : 
; 2036 :   /* reinsert */
; 2037 :   for ( i = 0, e = oldtable ; i < oldsize ; i++,e++ )

	mov	esi, DWORD PTR _oldtable$[ebp]
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR [edi+36], eax
	mov	DWORD PTR [edi+44], ecx
	test	ebx, ebx
	jle	SHORT $LN7@sp_hash_ex

; 2032 :   S->table_size =  newsize;

	mov	DWORD PTR tv65[ebp], ebx
	npad	7
$LL9@sp_hash_ex:

; 2038 :      if ( e->row != HASHEMPTY )

	mov	ecx, DWORD PTR [esi]
	cmp	ecx, -1
	je	SHORT $LN8@sp_hash_ex

; 2039 :      { int spot = sp_hash(e->row,e->col) % S->table_size;

	mov	eax, DWORD PTR [esi+4]
	imul	ecx, 97					; 00000061H
	imul	eax, 99991				; 00018697H
	mov	ebx, DWORD PTR [edi+32]
	add	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	and	eax, 2147483647				; 7fffffffH
	cdq
	idiv	ebx

; 2040 :        struct sp_entry *ee;
; 2041 :        for ( ee = S->hashtable + spot; ee->row != HASHEMPTY ; spot++ )

	mov	ecx, DWORD PTR [edi+44]
	mov	eax, edx
	shl	eax, 4
	add	eax, ecx
	cmp	DWORD PTR [eax], -1
	je	SHORT $LN3@sp_hash_ex
$LL5@sp_hash_ex:

; 2042 :        { if ( spot == S->table_size ) spot = 0;

	cmp	edx, ebx
	jne	SHORT $LN2@sp_hash_ex
	xor	edx, edx
$LN2@sp_hash_ex:

; 2043 :          ee = S->hashtable + spot;

	mov	eax, edx
	shl	eax, 4
	add	eax, ecx
	inc	edx
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LL5@sp_hash_ex
$LN3@sp_hash_ex:

; 2044 :        }
; 2045 :        *ee = *e;

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+12], edx
$LN8@sp_hash_ex:

; 2034 :   S->hashtable = newtable;
; 2035 : 
; 2036 :   /* reinsert */
; 2037 :   for ( i = 0, e = oldtable ; i < oldsize ; i++,e++ )

	add	esi, 16					; 00000010H
	dec	DWORD PTR tv65[ebp]
	jne	SHORT $LL9@sp_hash_ex
$LN7@sp_hash_ex:

; 2046 :      }
; 2047 :   temp_free((char*)oldtable);

	mov	eax, DWORD PTR _oldtable$[ebp]
	push	eax
	call	_temp_free
	add	esp, 4

; 2048 : 
; 2049 :   if ( !hessian_quiet_flag )

	cmp	DWORD PTR _hessian_quiet_flag, 0
	jne	SHORT $LN1@sp_hash_ex

; 2050 :   { sprintf(msg,"Expanded hashtable size: %d.\n",S->table_size);

	mov	ecx, DWORD PTR [edi+32]
	mov	edx, DWORD PTR _msg
	push	ecx
	push	OFFSET ??_C@_0BO@NFEGIGMI@Expanded?5hashtable?5size?3?5?$CFd?4?6?$AA@
	push	edx
	call	_sprintf

; 2051 :     outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 16					; 00000010H
$LN1@sp_hash_ex:
	pop	edi
	pop	esi
	pop	ebx

; 2052 :   }
; 2053 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sp_hash_expand ENDP
_TEXT	ENDS
PUBLIC	_sp_hash_search
; Function compile flags: /Ogtp
;	COMDAT _sp_hash_search
_TEXT	SEGMENT
_S$ = 8							; size = 4
_row$ = 12						; size = 4
_col$ = 16						; size = 4
_value$ = 20						; size = 8
_sp_hash_search PROC					; COMDAT

; 2068 : {

	push	ebp
	mov	ebp, esp

; 2069 :   struct sp_entry *e;
; 2070 :   int spot;
; 2071 : 
; 2072 : 
; 2073 :   if ( value == 0.0 ) return;   

	fld	QWORD PTR _value$[ebp]
	fld	ST(0)
	fldz
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	$LN18@sp_hash_se

; 2074 : 
; 2075 :   if ( S->hashcount >= S->max_fill ) 

	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	mov	eax, DWORD PTR [esi+40]
	cmp	eax, DWORD PTR [esi+36]
	jl	SHORT $LN5@sp_hash_se

; 2076 :      sp_hash_expand(S);

	push	esi
	fstp	ST(0)
	call	_sp_hash_expand
	fld	QWORD PTR _value$[ebp]
	add	esp, 4
$LN5@sp_hash_se:

; 2077 : 
; 2078 :   /* search hash table */
; 2079 :   spot = sp_hash(row,col) % S->table_size;

	mov	eax, DWORD PTR _col$[ebp]
	imul	eax, 99991				; 00018697H
	mov	ecx, DWORD PTR [esi+32]
	push	ebx
	mov	ebx, DWORD PTR _row$[ebp]
	mov	edx, ebx
	imul	edx, 97					; 00000061H
	add	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	and	eax, 2147483647				; 7fffffffH
	cdq
	idiv	ecx
	push	edi

; 2080 :   e = S->hashtable + spot;

	mov	eax, edx
	shl	eax, 4
	add	eax, DWORD PTR [esi+44]

; 2081 :   while ( e->row != HASHEMPTY )

	cmp	DWORD PTR [eax], -1
	je	SHORT $LN3@sp_hash_se

; 2077 : 
; 2078 :   /* search hash table */
; 2079 :   spot = sp_hash(row,col) % S->table_size;

	mov	edi, ecx
	shl	edi, 4
$LN4@sp_hash_se:

; 2082 :   { if ( (e->row == row) && (e->col == col) )

	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN2@sp_hash_se
	mov	ebx, DWORD PTR _col$[ebp]
	cmp	DWORD PTR [eax+4], ebx
	je	SHORT $LN10@sp_hash_se
	mov	ebx, DWORD PTR _row$[ebp]
$LN2@sp_hash_se:

; 2084 :       return;
; 2085 :     }
; 2086 :     spot++;

	inc	edx
	add	eax, 16					; 00000010H

; 2087 :     if ( spot >= S->table_size ) spot -= S->table_size;

	cmp	edx, ecx
	jl	SHORT $LN1@sp_hash_se
	sub	edx, ecx
	sub	eax, edi
$LN1@sp_hash_se:

; 2088 :     e = S->hashtable + spot;
; 2089 :     S->hash_extraprobes++;

	inc	DWORD PTR [esi+48]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN4@sp_hash_se
$LN3@sp_hash_se:

; 2090 :   }
; 2091 :   /* if here, then have empty slot and need to insert */
; 2092 :   e->col = col; e->row = row;  S->hashcount++; 

	mov	ecx, DWORD PTR _col$[ebp]
	pop	edi
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ecx
	inc	DWORD PTR [esi+40]

; 2093 :   e->value = value;

	fstp	QWORD PTR [eax+8]
	pop	ebx
	pop	esi

; 2094 : 
; 2095 : }

	pop	ebp
	ret	0
$LN10@sp_hash_se:

; 2083 :     { e->value += value;

	fadd	QWORD PTR [eax+8]
	pop	edi
	pop	ebx
	pop	esi

; 2093 :   e->value = value;

	fstp	QWORD PTR [eax+8]

; 2094 : 
; 2095 : }

	pop	ebp
	ret	0
$LN18@sp_hash_se:

; 2069 :   struct sp_entry *e;
; 2070 :   int spot;
; 2071 : 
; 2072 : 
; 2073 :   if ( value == 0.0 ) return;   

	fstp	ST(0)

; 2094 : 
; 2095 : }

	pop	ebp
	ret	0
_sp_hash_search ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@EPOCECGC@Hash?5extra?5probes?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0CO@MIBILHJK@Sparse?5entries?3?5?$CFd?5?5Final?5hashta@ ; `string'
PUBLIC	_sp_hash_end
;	COMDAT ??_C@_0BH@EPOCECGC@Hash?5extra?5probes?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BH@EPOCECGC@Hash?5extra?5probes?3?5?$CFd?6?$AA@ DB 'Hash extra pro'
	DB	'bes: %d', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@MIBILHJK@Sparse?5entries?3?5?$CFd?5?5Final?5hashta@
CONST	SEGMENT
??_C@_0CO@MIBILHJK@Sparse?5entries?3?5?$CFd?5?5Final?5hashta@ DB 'Sparse '
	DB	'entries: %d  Final hashtable size: %d', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _sp_hash_end
_TEXT	SEGMENT
_etmp$90626 = -48					; size = 16
_eorig$90625 = -32					; size = 16
_counts$ = -16						; size = 4
tv1168 = -12						; size = 4
_spots$ = -8						; size = 4
_e$ = -4						; size = 4
_starts$ = -4						; size = 4
tv675 = 8						; size = 4
tv363 = 8						; size = 4
_sum$ = 8						; size = 4
_S$ = 8							; size = 4
_rows$ = 12						; size = 4
tv89 = 16						; size = 4
_i$ = 16						; size = 4
_cols$ = 16						; size = 4
_index_start$ = 20					; size = 4
_sp_hash_end PROC					; COMDAT

; 2115 : { int i;

	push	ebp
	mov	ebp, esp

; 2116 :   struct sp_entry *e;
; 2117 :   int *counts;
; 2118 :   int *starts;
; 2119 :   int *spots; 
; 2120 :   int sum,oldsum;
; 2121 : 
; 2122 :   S->N = rows;

	mov	eax, DWORD PTR _rows$[ebp]
	sub	esp, 48					; 00000030H
	push	esi
	mov	esi, DWORD PTR _S$[ebp]
	push	edi

; 2123 :   S->maxN = rows > cols ? rows : cols;

	mov	edi, DWORD PTR _cols$[ebp]
	mov	DWORD PTR [esi+4], eax
	cmp	eax, edi
	jg	SHORT $LN39@sp_hash_en
	mov	eax, edi
$LN39@sp_hash_en:
	push	ebx

; 2124 :   S->IA = (int *)temp_calloc(S->maxN+1,sizeof(int));

	push	2124					; 0000084cH
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	mov	DWORD PTR [esi+8], eax
	inc	eax
	push	4
	push	eax
	call	_kb_temp_calloc

; 2125 :   counts = (int *)temp_calloc(3*cols+1,sizeof(int));

	push	2125					; 0000084dH
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	mov	DWORD PTR [esi+52], eax
	lea	eax, DWORD PTR [edi+edi*2+1]
	push	4
	push	eax
	call	_kb_temp_calloc

; 2126 :   starts = counts + cols;
; 2127 :   spots = starts + cols + 1;
; 2128 : 
; 2129 :   /* first stage: column binning */
; 2130 :   /* count entries in columns */
; 2131 :   for ( i = 0, e = S->hashtable ; i < S->table_size ; i++, e++ )

	mov	ecx, DWORD PTR [esi+44]
	lea	edx, DWORD PTR [eax+edi*4]
	lea	ebx, DWORD PTR [edx+edi*4+4]
	xor	edi, edi
	add	esp, 32					; 00000020H
	mov	DWORD PTR _counts$[ebp], eax
	mov	DWORD PTR _starts$[ebp], edx
	mov	DWORD PTR _spots$[ebp], ebx
	cmp	DWORD PTR [esi+32], edi
	jle	SHORT $LN63@sp_hash_en
$LL35@sp_hash_en:

; 2132 :     if ( e->row != HASHEMPTY ) 

	cmp	DWORD PTR [ecx], -1
	je	SHORT $LN34@sp_hash_en

; 2133 :        counts[e->col]++;

	mov	edx, DWORD PTR [ecx+4]
	inc	DWORD PTR [eax+edx*4]
	lea	edx, DWORD PTR [eax+edx*4]
$LN34@sp_hash_en:

; 2126 :   starts = counts + cols;
; 2127 :   spots = starts + cols + 1;
; 2128 : 
; 2129 :   /* first stage: column binning */
; 2130 :   /* count entries in columns */
; 2131 :   for ( i = 0, e = S->hashtable ; i < S->table_size ; i++, e++ )

	inc	edi
	add	ecx, 16					; 00000010H
	cmp	edi, DWORD PTR [esi+32]
	jl	SHORT $LL35@sp_hash_en
	mov	edx, DWORD PTR _starts$[ebp]
$LN63@sp_hash_en:

; 2134 : 
; 2135 :   /* get starting points of each column */
; 2136 :   for ( i = 0, sum = 0 ; i < cols  ; i++ )

	xor	edi, edi
	mov	DWORD PTR _sum$[ebp], edi
	cmp	DWORD PTR _cols$[ebp], edi
	jle	SHORT $LN29@sp_hash_en
	sub	edx, ebx
	sub	eax, ebx
	mov	DWORD PTR tv1168[ebp], eax
	mov	eax, DWORD PTR _cols$[ebp]
	mov	ecx, ebx
	mov	DWORD PTR tv363[ebp], eax
	npad	6
$LL31@sp_hash_en:

; 2137 :   { 
; 2138 :     spots[i] = starts[i] = sum;
; 2139 :     sum += counts[i];

	mov	eax, DWORD PTR tv1168[ebp]
	mov	DWORD PTR [edx+ecx], edi
	mov	DWORD PTR [ecx], edi
	add	edi, DWORD PTR [eax+ecx]
	add	ecx, 4
	dec	DWORD PTR tv363[ebp]
	jne	SHORT $LL31@sp_hash_en
	mov	DWORD PTR _sum$[ebp], edi
$LN29@sp_hash_en:

; 2140 :   } 
; 2141 :   starts[cols] = sum;

	mov	ecx, DWORD PTR _starts$[ebp]
	mov	edx, DWORD PTR _cols$[ebp]

; 2142 :   S->maxA = sum + S->maxN;  /* extra room for later expansion */
; 2143 :   S->JA = (int *)temp_calloc(S->maxA,sizeof(int));

	push	2143					; 0000085fH
	mov	DWORD PTR [ecx+edx*4], edi
	mov	eax, DWORD PTR [esi+8]
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	add	eax, edi
	push	4
	push	eax
	mov	DWORD PTR [esi+64], eax
	call	_kb_temp_calloc

; 2144 :   S->A = (REAL *)temp_calloc(S->maxA,sizeof(REAL));

	mov	ecx, DWORD PTR [esi+64]
	push	2144					; 00000860H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	push	8
	push	ecx
	mov	DWORD PTR [esi+56], eax
	call	_kb_temp_calloc

; 2145 : 
; 2146 :   /* sort into column bins */
; 2147 :   for ( i = 0, e = S->hashtable ; i < S->table_size ; i++,e++ )

	xor	ecx, ecx
	mov	DWORD PTR [esi+60], eax
	mov	eax, DWORD PTR [esi+44]
	add	esp, 32					; 00000020H
	mov	DWORD PTR _i$[ebp], ecx
	mov	DWORD PTR _e$[ebp], eax
	cmp	DWORD PTR [esi+32], ecx
	jle	$LN26@sp_hash_en
	npad	5
$LL28@sp_hash_en:

; 2148 :   { 
; 2149 :     struct sp_entry eorig;
; 2150 :     struct sp_entry etmp;
; 2151 :     if ( e->row == HASHEMPTY ) continue;

	cmp	DWORD PTR [eax], -1
	je	SHORT $LN27@sp_hash_en

; 2152 :     if ( i < spots[e->col] ) continue; /* already in place */

	mov	edx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [ebx+edx*4]
	jl	SHORT $LN27@sp_hash_en

; 2153 :     eorig = *e;

	mov	edi, DWORD PTR [eax]
	mov	ecx, edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _eorig$90625[ebp+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _eorig$90625[ebp+12], edx

; 2154 :     e->row = HASHEMPTY;

	mov	DWORD PTR [eax], -1
$LL23@sp_hash_en:

; 2155 :     do
; 2156 :     { /* follow chain of replacements */
; 2157 :       int spot;
; 2158 :       spot = spots[eorig.col]++;

	mov	eax, DWORD PTR [ebx+ecx*4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ebx+ecx*4], edx

; 2159 :       etmp = S->hashtable[spot];

	shl	eax, 4
	add	eax, DWORD PTR [esi+44]
	mov	ebx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _etmp$90626[ebp+4], ebx
	mov	ebx, DWORD PTR [eax+8]
	mov	DWORD PTR _etmp$90626[ebp+8], ebx
	mov	ebx, DWORD PTR [eax+12]

; 2160 :       S->hashtable[spot] = eorig;

	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR _eorig$90625[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _eorig$90625[ebp+12]
	mov	DWORD PTR [eax+12], ecx

; 2161 :       eorig = etmp;

	mov	eax, DWORD PTR _etmp$90626[ebp+8]
	mov	ecx, DWORD PTR _etmp$90626[ebp+4]
	mov	DWORD PTR _eorig$90625[ebp+12], ebx

; 2162 :     }
; 2163 :     while ( eorig.row != HASHEMPTY ); /* stop when get back to empty */ 

	mov	ebx, DWORD PTR _spots$[ebp]
	mov	edi, edx
	mov	DWORD PTR _eorig$90625[ebp+8], eax
	cmp	edx, -1
	jne	SHORT $LL23@sp_hash_en
	mov	edi, DWORD PTR _sum$[ebp]
	mov	eax, DWORD PTR _e$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
$LN27@sp_hash_en:

; 2145 : 
; 2146 :   /* sort into column bins */
; 2147 :   for ( i = 0, e = S->hashtable ; i < S->table_size ; i++,e++ )

	inc	ecx
	add	eax, 16					; 00000010H
	mov	DWORD PTR _i$[ebp], ecx
	mov	DWORD PTR _e$[ebp], eax
	cmp	ecx, DWORD PTR [esi+32]
	jl	$LL28@sp_hash_en
$LN26@sp_hash_en:

; 2164 :   }
; 2165 : 
; 2166 : 
; 2167 :   /* Second stage: row binning */
; 2168 :   /* count entries in row */
; 2169 : 
; 2170 :   for ( i = 0, e = S->hashtable ; i < sum ; i++, e++ )

	mov	ecx, DWORD PTR [esi+44]
	test	edi, edi
	jle	SHORT $LN18@sp_hash_en
	npad	3
$LL20@sp_hash_en:

; 2171 :      S->IA[e->row]++;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi+52]
	inc	DWORD PTR [eax+edx*4]
	lea	eax, DWORD PTR [eax+edx*4]
	add	ecx, 16					; 00000010H
	dec	edi
	jne	SHORT $LL20@sp_hash_en
$LN18@sp_hash_en:

; 2172 : 
; 2173 :   /* get starting points of each row */
; 2174 :   for ( i = 0, sum = 0 ; i < rows  ; i++ )

	mov	edx, DWORD PTR _rows$[ebp]
	xor	eax, eax
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN15@sp_hash_en
	npad	4
$LL17@sp_hash_en:
	mov	edi, DWORD PTR [esi+52]
	lea	edi, DWORD PTR [edi+eax*4]

; 2175 :   { oldsum = sum;

	mov	ebx, ecx

; 2176 :     sum += S->IA[i];

	add	ecx, DWORD PTR [edi]
	inc	eax

; 2177 :     S->IA[i] = oldsum;

	mov	DWORD PTR [edi], ebx
	cmp	eax, edx
	jl	SHORT $LL17@sp_hash_en
$LN15@sp_hash_en:

; 2178 :   } 
; 2179 :   S->IA[rows] = sum;

	mov	eax, DWORD PTR [esi+52]

; 2180 : 
; 2181 :   /* sort into row bins */
; 2182 :   for ( i = 0, e = S->hashtable ; i < sum ; i++,e++ )

	xor	edi, edi
	mov	DWORD PTR [eax+edx*4], ecx
	mov	eax, DWORD PTR [esi+44]
	cmp	ecx, 4
	jl	$LN65@sp_hash_en

; 2178 :   } 
; 2179 :   S->IA[rows] = sum;

	lea	edx, DWORD PTR [ecx-4]
	shr	edx, 2
	inc	edx
	mov	DWORD PTR tv675[ebp], edx
	add	edx, edx
	add	edx, edx
	mov	DWORD PTR _i$[ebp], edx

; 2180 : 
; 2181 :   /* sort into row bins */
; 2182 :   for ( i = 0, e = S->hashtable ; i < sum ; i++,e++ )

$LL61@sp_hash_en:

; 2183 :   { 
; 2184 :     S->JA[S->IA[e->row]] = e->col;

	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	ebx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [esi+56]
	mov	DWORD PTR [edi+edx*4], ebx

; 2185 :     S->A[S->IA[e->row]] = e->value;

	fld	QWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR [esi+60]
	fstp	QWORD PTR [edi+edx*8]

; 2186 :     S->IA[e->row]++;

	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [esi+52]
	inc	DWORD PTR [edi+edx*4]
	mov	ebx, DWORD PTR [eax+20]
	lea	edx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [eax+16]
	mov	edi, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR [esi+56]
	mov	DWORD PTR [edi+edx*4], ebx
	fld	QWORD PTR [eax+24]
	mov	edx, DWORD PTR [eax+16]
	mov	edi, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR [esi+60]
	fstp	QWORD PTR [edi+edx*8]
	mov	edx, DWORD PTR [eax+16]
	mov	edi, DWORD PTR [esi+52]
	inc	DWORD PTR [edi+edx*4]
	mov	ebx, DWORD PTR [eax+36]
	lea	edx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [eax+32]
	mov	edi, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR [esi+56]
	mov	DWORD PTR [edi+edx*4], ebx
	fld	QWORD PTR [eax+40]
	mov	edx, DWORD PTR [eax+32]
	mov	edi, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR [esi+60]
	fstp	QWORD PTR [edi+edx*8]
	mov	edx, DWORD PTR [eax+32]
	mov	edi, DWORD PTR [esi+52]
	inc	DWORD PTR [edi+edx*4]
	mov	ebx, DWORD PTR [eax+52]
	lea	edx, DWORD PTR [edi+edx*4]
	mov	edx, DWORD PTR [eax+48]
	mov	edi, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR [esi+56]
	mov	DWORD PTR [edi+edx*4], ebx
	fld	QWORD PTR [eax+56]
	mov	edx, DWORD PTR [eax+48]
	mov	edi, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [edi+edx*4]
	mov	edi, DWORD PTR [esi+60]
	fstp	QWORD PTR [edi+edx*8]
	mov	edx, DWORD PTR [eax+48]
	mov	edi, DWORD PTR [esi+52]
	inc	DWORD PTR [edi+edx*4]
	lea	edx, DWORD PTR [edi+edx*4]
	add	eax, 64					; 00000040H
	dec	DWORD PTR tv675[ebp]
	jne	$LL61@sp_hash_en

; 2178 :   } 
; 2179 :   S->IA[rows] = sum;

	mov	edi, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _rows$[ebp]
$LN65@sp_hash_en:

; 2180 : 
; 2181 :   /* sort into row bins */
; 2182 :   for ( i = 0, e = S->hashtable ; i < sum ; i++,e++ )

	cmp	edi, ecx
	jge	SHORT $LN67@sp_hash_en
	sub	ecx, edi
	mov	DWORD PTR tv89[ebp], ecx
	npad	2
$LC14@sp_hash_en:

; 2183 :   { 
; 2184 :     S->JA[S->IA[e->row]] = e->col;

	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [esi+56]
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+ecx*4], ebx

; 2185 :     S->A[S->IA[e->row]] = e->value;

	fld	QWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [edi+ecx*4]
	mov	edi, DWORD PTR [esi+60]
	fstp	QWORD PTR [edi+ecx*8]

; 2186 :     S->IA[e->row]++;

	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR [esi+52]
	inc	DWORD PTR [edi+ecx*4]
	lea	ecx, DWORD PTR [edi+ecx*4]
	add	eax, 16					; 00000010H
	dec	DWORD PTR tv89[ebp]
	jne	SHORT $LC14@sp_hash_en
$LN67@sp_hash_en:

; 2187 :   }
; 2188 :   /* put back IA */
; 2189 :   for ( i = rows ; i > 0 ; i-- )

	mov	eax, edx
	pop	ebx
	test	edx, edx
	jle	SHORT $LN68@sp_hash_en
	npad	4
$LL11@sp_hash_en:
	mov	ecx, DWORD PTR [esi+52]

; 2190 :     S->IA[i] = S->IA[i-1];

	mov	edi, DWORD PTR [ecx+eax*4-4]
	lea	ecx, DWORD PTR [ecx+eax*4]
	dec	eax
	mov	DWORD PTR [ecx], edi
	test	eax, eax
	jg	SHORT $LL11@sp_hash_en
$LN68@sp_hash_en:

; 2191 :   S->IA[0] = 0;
; 2192 : 
; 2193 :   if ( index_start )

	mov	edi, DWORD PTR _index_start$[ebp]
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [eax], 0
	test	edi, edi
	je	SHORT $LN2@sp_hash_en

; 2194 :   { 
; 2195 :     for ( i = 0 ; i < S->IA[rows] ; i++ )

	mov	ecx, DWORD PTR [esi+52]
	xor	eax, eax
	cmp	DWORD PTR [ecx+edx*4], eax
	jle	SHORT $LN69@sp_hash_en
	npad	5
$LL7@sp_hash_en:
	mov	ecx, DWORD PTR [esi+56]

; 2196 :        S->JA[i] += index_start;

	add	DWORD PTR [ecx+eax*4], edi
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR [esi+52]
	inc	eax
	cmp	eax, DWORD PTR [ecx+edx*4]
	jl	SHORT $LL7@sp_hash_en
$LN69@sp_hash_en:

; 2197 :     for ( i = 0 ; i <= rows ; i++ )

	xor	eax, eax
	test	edx, edx
	js	SHORT $LN2@sp_hash_en
	npad	8
$LL4@sp_hash_en:
	mov	ecx, DWORD PTR [esi+52]

; 2198 :        S->IA[i] += index_start;

	add	DWORD PTR [ecx+eax*4], edi
	lea	ecx, DWORD PTR [ecx+eax*4]
	inc	eax
	cmp	eax, edx
	jle	SHORT $LL4@sp_hash_en
$LN2@sp_hash_en:

; 2199 :   }
; 2200 : 
; 2201 :   temp_free((char*)counts);

	mov	edx, DWORD PTR _counts$[ebp]
	push	edx
	call	_temp_free
	add	esp, 4

; 2202 : 
; 2203 :   if ( !hessian_quiet_flag )

	cmp	DWORD PTR _hessian_quiet_flag, 0
	jne	SHORT $LN1@sp_hash_en

; 2204 :   { sprintf(msg,"Sparse entries: %d  Final hashtable size: %d\n",
; 2205 :         S->hashcount, S->table_size);

	mov	eax, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [esi+40]
	mov	edx, DWORD PTR _msg
	push	eax
	push	ecx
	push	OFFSET ??_C@_0CO@MIBILHJK@Sparse?5entries?3?5?$CFd?5?5Final?5hashta@
	push	edx
	call	_sprintf

; 2206 :     outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring

; 2207 :     sprintf(msg,"Hash extra probes: %d\n",S->hash_extraprobes);

	mov	ecx, DWORD PTR [esi+48]
	mov	edx, DWORD PTR _msg
	push	ecx
	push	OFFSET ??_C@_0BH@EPOCECGC@Hash?5extra?5probes?3?5?$CFd?6?$AA@
	push	edx
	call	_sprintf

; 2208 :     outstring(msg);

	mov	eax, DWORD PTR _msg
	push	eax
	call	_outstring
	add	esp, 36					; 00000024H
$LN1@sp_hash_en:

; 2209 :   }
; 2210 :  
; 2211 :   temp_free((char*)S->hashtable);

	mov	ecx, DWORD PTR [esi+44]
	push	ecx
	call	_temp_free

; 2212 :   S->hashtable = NULL;
; 2213 : 
; 2214 :   return S->IA[S->N] + S->IA[S->N]/3;  /* estimate for next time */

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+44], 0
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, 1431655766				; 55555556H
	imul	ecx
	add	esp, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	edi
	add	eax, ecx
	pop	esi

; 2215 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sp_hash_end ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_bezier_eval
; Function compile flags: /Ogtp
;	COMDAT _bezier_eval
_TEXT	SEGMENT
$T93819 = -72						; size = 4
tv847 = -68						; size = 4
tv868 = -64						; size = 4
tv833 = -64						; size = 4
_mm$ = -60						; size = 4
_j$ = -56						; size = 4
_prodpart$ = -52					; size = 48
__$ArrayPad$ = -4					; size = 4
_order$ = 8						; size = 4
_dim$ = 12						; size = 4
_inx$ = 16						; size = 4
_x$ = 20						; size = 4
_bezier_eval PROC					; COMDAT

; 2810 : { REAL prod, prodpart[MAXCOORD];

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 2811 :   int i,j,k,mm;
; 2812 :   for ( k = 0 ; k <= dim ; k++ ) prodpart[k] = 0.0;

	mov	esi, DWORD PTR _dim$[ebp]
	push	edi
	test	esi, esi
	js	SHORT $LN13@bezier_eva
	lea	ecx, DWORD PTR [esi+esi+2]
	and	ecx, 1073741822				; 3ffffffeH
	xor	eax, eax
	lea	edi, DWORD PTR _prodpart$[ebp]
	rep stosd
$LN13@bezier_eva:

; 2813 :     for ( i = 0, prod = 1.0, mm = 1 ; i <= dim ; i++ )

	fld1
	xor	edx, edx
	fld	ST(0)
	mov	DWORD PTR _mm$[ebp], 1
	test	esi, esi
	js	$LN34@bezier_eva
	push	ebx
	mov	ebx, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv847[ebp], ebx
$LN10@bezier_eva:
	mov	eax, DWORD PTR _inx$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]

; 2814 :       for ( j = 0 ; j < inx[i] ; j++, mm++ )

	xor	edi, edi
	mov	DWORD PTR _j$[ebp], edi
	mov	DWORD PTR $T93819[ebp], eax
	test	eax, eax
	jle	$LN9@bezier_eva
$LN32@bezier_eva:

; 2815 :       { for ( k = 0 ; k <= dim ; k++ )

	lea	ecx, DWORD PTR [esi+1]
	xor	eax, eax
	cmp	ecx, 4
	jl	$LC25@bezier_eva
	fild	DWORD PTR _mm$[ebp]
	lea	ecx, DWORD PTR [edi+1]
	fld	QWORD PTR [ebx]
	mov	DWORD PTR tv868[ebp], ecx
	add	esi, -3					; fffffffdH
	fmul	ST(0), ST(1)
	lea	ecx, DWORD PTR [eax+2]
	fild	DWORD PTR tv868[ebp]
	fdivp	ST(1), ST(0)
$LN30@bezier_eva:

; 2816 :         { prodpart[k] *= mm*x[i]/(j+1);

	fld	ST(0)
	fmul	QWORD PTR _prodpart$[ebp+eax*8]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$[ebp+eax*8]

; 2817 :           if ( i == k ) prodpart[k] += prod*mm/(j+1.);

	cmp	edx, eax
	jne	SHORT $LN44@bezier_eva
	fld	ST(2)
	fmul	ST(0), ST(4)
	fild	DWORD PTR _j$[ebp]
	fadd	ST(0), ST(6)
	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$[ebp+eax*8]
	jmp	SHORT $LN26@bezier_eva
$LN44@bezier_eva:
	fstp	ST(0)
$LN26@bezier_eva:

; 2816 :         { prodpart[k] *= mm*x[i]/(j+1);

	fld	ST(0)

; 2817 :           if ( i == k ) prodpart[k] += prod*mm/(j+1.);

	lea	ebx, DWORD PTR [ecx-1]
	fmul	QWORD PTR _prodpart$[ebp+eax*8+8]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$[ebp+eax*8+8]
	cmp	edx, ebx
	jne	SHORT $LN47@bezier_eva
	fld	ST(2)
	fmul	ST(0), ST(4)
	fild	DWORD PTR _j$[ebp]
	fadd	ST(0), ST(6)
	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$[ebp+eax*8+8]
	jmp	SHORT $LN27@bezier_eva
$LN47@bezier_eva:
	fstp	ST(0)
$LN27@bezier_eva:

; 2816 :         { prodpart[k] *= mm*x[i]/(j+1);

	fld	ST(0)
	fmul	QWORD PTR _prodpart$[ebp+eax*8+16]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$[ebp+eax*8+16]

; 2817 :           if ( i == k ) prodpart[k] += prod*mm/(j+1.);

	cmp	edx, ecx
	jne	SHORT $LN50@bezier_eva
	fld	ST(2)
	fmul	ST(0), ST(4)
	fild	DWORD PTR _j$[ebp]
	fadd	ST(0), ST(6)
	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$[ebp+eax*8+16]
	jmp	SHORT $LN28@bezier_eva
$LN50@bezier_eva:
	fstp	ST(0)
$LN28@bezier_eva:

; 2816 :         { prodpart[k] *= mm*x[i]/(j+1);

	fld	ST(0)
	lea	ebx, DWORD PTR [ecx+1]
	fmul	QWORD PTR _prodpart$[ebp+eax*8+24]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$[ebp+eax*8+24]

; 2817 :           if ( i == k ) prodpart[k] += prod*mm/(j+1.);

	cmp	edx, ebx
	jne	SHORT $LN53@bezier_eva
	fld	ST(2)
	fmul	ST(0), ST(4)
	fild	DWORD PTR _j$[ebp]
	fadd	ST(0), ST(6)
	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$[ebp+eax*8+24]
	jmp	SHORT $LN29@bezier_eva
$LN53@bezier_eva:
	fstp	ST(0)
$LN29@bezier_eva:
	add	eax, 4

; 2815 :       { for ( k = 0 ; k <= dim ; k++ )

	add	ecx, 4
	cmp	eax, esi
	jle	$LN30@bezier_eva
	mov	ebx, DWORD PTR tv847[ebp]

; 2817 :           if ( i == k ) prodpart[k] += prod*mm/(j+1.);

	fstp	ST(1)
	mov	esi, DWORD PTR _dim$[ebp]
	fstp	ST(0)
$LC25@bezier_eva:

; 2815 :       { for ( k = 0 ; k <= dim ; k++ )

	cmp	eax, esi
	jg	SHORT $LN24@bezier_eva
	fild	DWORD PTR _mm$[ebp]
	lea	ecx, DWORD PTR [edi+1]
	fld	QWORD PTR [ebx]
	mov	DWORD PTR tv833[ebp], ecx
	fmul	ST(0), ST(1)
	fild	DWORD PTR tv833[ebp]
	fdivp	ST(1), ST(0)
$LC4@bezier_eva:

; 2816 :         { prodpart[k] *= mm*x[i]/(j+1);

	fld	ST(0)
	fmul	QWORD PTR _prodpart$[ebp+eax*8]
	fld	ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _prodpart$[ebp+eax*8]

; 2817 :           if ( i == k ) prodpart[k] += prod*mm/(j+1.);

	cmp	edx, eax
	jne	SHORT $LN62@bezier_eva
	fld	ST(2)
	fmul	ST(0), ST(4)
	fild	DWORD PTR _j$[ebp]
	fadd	ST(0), ST(6)
	fdivp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	QWORD PTR _prodpart$[ebp+eax*8]
	jmp	SHORT $LN3@bezier_eva
$LN62@bezier_eva:
	fstp	ST(0)
$LN3@bezier_eva:
	inc	eax

; 2815 :       { for ( k = 0 ; k <= dim ; k++ )

	cmp	eax, esi
	jle	SHORT $LC4@bezier_eva

; 2817 :           if ( i == k ) prodpart[k] += prod*mm/(j+1.);

	fstp	ST(1)
	fstp	ST(0)
$LN24@bezier_eva:

; 2818 :         }
; 2819 :         prod *= mm*x[i]/(j+1.);

	fild	DWORD PTR _mm$[ebp]
	inc	DWORD PTR _mm$[ebp]
	inc	edi
	fmul	QWORD PTR [ebx]
	fild	DWORD PTR _j$[ebp]
	mov	DWORD PTR _j$[ebp], edi
	fadd	ST(0), ST(3)
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
	cmp	edi, DWORD PTR $T93819[ebp]
	jl	$LN32@bezier_eva
$LN9@bezier_eva:

; 2813 :     for ( i = 0, prod = 1.0, mm = 1 ; i <= dim ; i++ )

	inc	edx
	add	ebx, 8
	mov	DWORD PTR tv847[ebp], ebx
	cmp	edx, esi
	jle	$LN10@bezier_eva
	pop	ebx
$LN34@bezier_eva:

; 2820 :       }
; 2821 :   return prod;
; 2822 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	ST(1)
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_bezier_eval ENDP
_TEXT	ENDS
PUBLIC	_bezier_eval_1d
; Function compile flags: /Ogtp
;	COMDAT _bezier_eval_1d
_TEXT	SEGMENT
_t$ = -24						; size = 16
_inx$ = -8						; size = 8
_order$ = 8						; size = 4
_sdim$ = 12						; size = 4
_p$ = 16						; size = 8
tv893 = 20						; size = 4
_ctrl$ = 24						; size = 4
_dest$ = 28						; size = 4
_bezier_eval_1d PROC					; COMDAT

; 2837 : { int inx[2];

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2838 :   REAL t[2];
; 2839 :   int i,k;
; 2840 : 
; 2841 :   t[0] = p; t[1] = 1 - p;

	fld	QWORD PTR _p$[ebp]
	push	ebx
	fst	QWORD PTR _t$[ebp]
	push	esi
	fld1

; 2842 :   for ( k = 0 ; k < sdim ; k++ ) dest[k] = 0.0;

	mov	esi, DWORD PTR _sdim$[ebp]
	fsubrp	ST(1), ST(0)
	push	edi
	fstp	QWORD PTR _t$[ebp+8]
	test	esi, esi
	jle	SHORT $LN21@bezier_eva@2

; 2838 :   REAL t[2];
; 2839 :   int i,k;
; 2840 : 
; 2841 :   t[0] = p; t[1] = 1 - p;

	mov	edi, DWORD PTR _dest$[ebp]
	mov	ecx, esi
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	rep stosd
$LN21@bezier_eva@2:

; 2843 :   for ( i = 0 ; i <= order ; i++ )

	mov	eax, DWORD PTR _order$[ebp]
	xor	ebx, ebx
	test	eax, eax
	js	$LN4@bezier_eva@2
	mov	DWORD PTR tv893[ebp], eax
	jmp	SHORT $LN6@bezier_eva@2
$LL22@bezier_eva@2:
	mov	eax, DWORD PTR _order$[ebp]
$LN6@bezier_eva@2:

; 2844 :   { REAL bezval;
; 2845 :     inx[0] = order-i;

	mov	ecx, DWORD PTR tv893[ebp]

; 2846 :     inx[1] = i;
; 2847 :     bezval = bezier_eval(order,1,inx,t);

	lea	edx, DWORD PTR _t$[ebp]
	push	edx
	mov	DWORD PTR _inx$[ebp], ecx
	lea	ecx, DWORD PTR _inx$[ebp]
	push	ecx
	push	1
	push	eax
	mov	DWORD PTR _inx$[ebp+4], ebx
	call	_bezier_eval
	add	esp, 16					; 00000010H

; 2848 :     for ( k = 0 ; k < sdim ; k++ )

	xor	edi, edi
	cmp	esi, 4
	jl	SHORT $LC19@bezier_eva@2
	mov	edx, DWORD PTR _ctrl$[ebp]
	mov	esi, DWORD PTR [edx+ebx*4]
	mov	ecx, DWORD PTR _dest$[ebp]
	lea	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [esi+24]

; 2849 :       dest[k] += bezval*ctrl[i][k];

	sub	esi, ecx
	mov	ecx, DWORD PTR _sdim$[ebp]
	add	ecx, -4					; fffffffcH
	shr	ecx, 2
	inc	ecx
	lea	edi, DWORD PTR [ecx*4]
$LN20@bezier_eva@2:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	dec	ecx
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [esi+eax-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN20@bezier_eva@2

; 2844 :   { REAL bezval;
; 2845 :     inx[0] = order-i;

	mov	esi, DWORD PTR _sdim$[ebp]
$LC19@bezier_eva@2:

; 2848 :     for ( k = 0 ; k < sdim ; k++ )

	cmp	edi, esi
	jge	SHORT $LN33@bezier_eva@2
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [edx+ebx*4]
	lea	eax, DWORD PTR [ecx+edi*8]
	sub	edx, ecx
	mov	ecx, esi
	sub	ecx, edi
$LC3@bezier_eva@2:

; 2849 :       dest[k] += bezval*ctrl[i][k];

	fld	QWORD PTR [eax+edx]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC3@bezier_eva@2
$LN33@bezier_eva@2:

; 2843 :   for ( i = 0 ; i <= order ; i++ )

	dec	DWORD PTR tv893[ebp]

; 2848 :     for ( k = 0 ; k < sdim ; k++ )

	fstp	ST(0)
	inc	ebx
	cmp	ebx, DWORD PTR _order$[ebp]
	jle	$LL22@bezier_eva@2
$LN4@bezier_eva@2:
	pop	edi
	pop	esi
	pop	ebx

; 2850 :   }
; 2851 : 
; 2852 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_bezier_eval_1d ENDP
_TEXT	ENDS
PUBLIC	_bezier_convert_1D_init
EXTRN	_bezier1revert:BYTE
EXTRN	_bezier1invert:BYTE
; Function compile flags: /Ogtp
;	COMDAT _bezier_convert_1D_init
_TEXT	SEGMENT
_x$ = -60						; size = 16
tv168 = -44						; size = 8
_inx$ = -36						; size = 8
_a$ = -28						; size = 4
_b$ = -24						; size = 4
tv250 = -20						; size = 4
tv316 = -16						; size = 4
tv294 = -12						; size = 4
tv298 = -8						; size = 4
_i$ = -4						; size = 4
tv243 = 8						; size = 4
_order$ = 8						; size = 4
_bezier_convert_1D_init PROC				; COMDAT

; 2864 : { int i,j;

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	esi

; 2865 :   REAL x[2];  /* barycentric coords of target point */
; 2866 :   int inx[2]; /* barycentric index of basis function */
; 2867 :   REAL **a = dmatrix(0,order,0,order); 

	mov	esi, DWORD PTR _order$[ebp]
	push	edi
	push	2867					; 00000b33H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	push	esi
	push	0
	push	esi
	push	0
	call	_kb_dmatrix

; 2868 :   REAL **b = dmatrix(0,order,0,order); 

	push	2868					; 00000b34H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	push	esi
	push	0
	mov	edi, eax
	push	esi
	push	0
	mov	DWORD PTR _a$[ebp], edi
	call	_kb_dmatrix
	add	esp, 48					; 00000030H

; 2869 : 
; 2870 :   if ( bezier1invert[order] ) return;

	cmp	DWORD PTR _bezier1invert[esi*4], 0
	mov	ebx, eax
	mov	DWORD PTR _b$[ebp], ebx
	jne	$LN8@bezier_con

; 2871 : 
; 2872 :   /* fill in forward matrix */
; 2873 :   for ( i = 0 ; i <= order ; i++ )  /* point on curve */

	mov	DWORD PTR _i$[ebp], 0
	test	esi, esi
	js	$LN4@bezier_con
	fild	DWORD PTR _order$[ebp]
	mov	ecx, ebx
	mov	eax, edi
	sub	ecx, edi
	fst	QWORD PTR tv168[ebp]
	mov	DWORD PTR tv294[ebp], eax
	mov	DWORD PTR tv298[ebp], esi
	mov	DWORD PTR tv316[ebp], ecx
	jmp	SHORT $LN6@bezier_con
$LL14@bezier_con:
	fld	QWORD PTR tv168[ebp]
	mov	eax, DWORD PTR tv294[ebp]
	mov	ecx, DWORD PTR tv316[ebp]
$LN6@bezier_con:

; 2874 :   { x[0] = (order-i)/(REAL)order;

	fild	DWORD PTR tv298[ebp]
	mov	edi, DWORD PTR [eax]

; 2875 :     x[1] = i/(REAL)order;
; 2876 :     for ( j = 0 ; j <= order ; j++ ) /* control point */

	mov	eax, DWORD PTR [ecx+eax]
	xor	ebx, ebx
	fdiv	ST(0), ST(1)
	sub	eax, edi
	mov	DWORD PTR tv243[ebp], esi
	mov	DWORD PTR tv250[ebp], eax
	fstp	QWORD PTR _x$[ebp]
	fidivr	DWORD PTR _i$[ebp]
	fstp	QWORD PTR _x$[ebp+8]
	npad	3
$LL15@bezier_con:

; 2877 :     { inx[0] = order-j;

	mov	eax, DWORD PTR tv243[ebp]

; 2878 :       inx[1] = j;
; 2879 :       a[i][j] = b[i][j] = bezier_eval(order,1,inx,x);

	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	push	1
	push	esi
	mov	DWORD PTR _inx$[ebp], eax
	mov	DWORD PTR _inx$[ebp+4], ebx
	call	_bezier_eval
	mov	eax, DWORD PTR tv250[ebp]
	dec	DWORD PTR tv243[ebp]
	fst	QWORD PTR [eax+edi]
	fstp	QWORD PTR [edi]
	inc	ebx
	add	esp, 16					; 00000010H
	add	edi, 8
	cmp	ebx, esi
	jle	SHORT $LL15@bezier_con

; 2871 : 
; 2872 :   /* fill in forward matrix */
; 2873 :   for ( i = 0 ; i <= order ; i++ )  /* point on curve */

	mov	eax, DWORD PTR _i$[ebp]
	dec	DWORD PTR tv298[ebp]
	add	DWORD PTR tv294[ebp], 4
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, esi
	jle	SHORT $LL14@bezier_con
	mov	ebx, DWORD PTR _b$[ebp]
	mov	edi, DWORD PTR _a$[ebp]
$LN4@bezier_con:

; 2880 :     }
; 2881 :   } 
; 2882 :   mat_inv(a,order+1);

	lea	ecx, DWORD PTR [esi+1]
	push	ecx
	push	edi
	call	_mat_inv
	add	esp, 8

; 2883 :   bezier1invert[order] = a;

	mov	DWORD PTR _bezier1invert[esi*4], edi

; 2884 :   bezier1revert[order] = b;

	mov	DWORD PTR _bezier1revert[esi*4], ebx
$LN8@bezier_con:
	pop	edi
	pop	esi
	pop	ebx

; 2885 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_bezier_convert_1D_init ENDP
_TEXT	ENDS
PUBLIC	_order$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_bezier_convert_2D_init
EXTRN	_bezier2revert:BYTE
EXTRN	_bezier2invert:BYTE
; Function compile flags: /Ogtp
;	COMDAT _bezier_convert_2D_init
_TEXT	SEGMENT
tv240 = -112						; size = 8
_order$GSCopy$ = -104					; size = 4
tv464 = -100						; size = 4
_b$ = -96						; size = 4
_a$ = -92						; size = 4
tv469 = -88						; size = 4
_numpts$ = -84						; size = 4
tv427 = -80						; size = 4
_j$ = -76						; size = 4
_mm$ = -72						; size = 4
tv354 = -68						; size = 4
tv382 = -64						; size = 4
tv528 = -60						; size = 4
_k$ = -56						; size = 4
_i$ = -52						; size = 4
_kk$ = -48						; size = 4
tv453 = -44						; size = 4
_x$ = -40						; size = 24
_inx$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_order$ = 8						; size = 4
_bezier_convert_2D_init PROC				; COMDAT

; 2897 : { int i,j,k,m,kk,mm;

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, DWORD PTR _order$[ebp]

; 2898 :   REAL x[3];  /* barycentric coords of target point */
; 2899 :   int inx[3]; /* barycentric index of basis function */
; 2900 :   int numpts = ((order+1)*(order+2))/2;

	lea	ecx, DWORD PTR [ebx+1]
	lea	eax, DWORD PTR [ebx+2]
	imul	eax, ecx
	push	esi
	push	edi
	cdq

; 2901 :   REAL **a = dmatrix(0,numpts-1,0,numpts-1); 

	push	2901					; 00000b55H
	sub	eax, edx
	sar	eax, 1
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	lea	esi, DWORD PTR [eax-1]
	push	esi
	push	0
	push	esi
	push	0
	mov	DWORD PTR _order$GSCopy$[ebp], ebx
	mov	DWORD PTR _numpts$[ebp], eax
	call	_kb_dmatrix

; 2902 :   REAL **b = dmatrix(0,numpts-1,0,numpts-1); 

	push	2902					; 00000b56H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	push	esi
	push	0
	mov	edi, eax
	push	esi
	push	0
	mov	DWORD PTR _a$[ebp], edi
	call	_kb_dmatrix

; 2903 : 
; 2904 :   if ( bezier2invert[order] ) return;

	xor	edx, edx
	add	esp, 48					; 00000030H
	mov	esi, eax
	mov	DWORD PTR _b$[ebp], esi
	cmp	DWORD PTR _bezier2invert[ebx*4], edx
	jne	$LN14@bezier_con@2

; 2905 : 
; 2906 :   /* fill in forward matrix */
; 2907 :   for ( i = 0, kk=0 ; i <= order ; i++ )  /* point on curve */

	mov	DWORD PTR _i$[ebp], edx
	mov	DWORD PTR _kk$[ebp], edx
	cmp	ebx, edx
	jl	$LN10@bezier_con@2
	mov	DWORD PTR tv528[ebp], ebx
	npad	12
$LL26@bezier_con@2:

; 2908 :     for ( k = 0 ; i+k <= order ; k++,kk++ )  /* point on curve */

	mov	DWORD PTR _k$[ebp], 0
	cmp	edx, ebx
	jg	$LN11@bezier_con@2
	fild	DWORD PTR _order$GSCopy$[ebp]
	mov	eax, DWORD PTR tv528[ebp]
	mov	edx, DWORD PTR _kk$[ebp]
	mov	DWORD PTR tv453[ebp], eax
	fst	QWORD PTR tv240[ebp]
	mov	eax, esi

; 2909 :     { x[0] = (order-i-k)/(REAL)order;
; 2910 :       x[1] = i/(REAL)order;

	fild	DWORD PTR _i$[ebp]
	lea	ecx, DWORD PTR [edi+edx*4]
	sub	eax, edi
	mov	DWORD PTR tv427[ebp], ecx
	fdiv	ST(0), ST(1)
	mov	DWORD PTR tv464[ebp], eax
	fstp	QWORD PTR _x$[ebp+8]
$LN9@bezier_con@2:

; 2911 :       x[2] = k/(REAL)order;
; 2912 :       for ( j = 0, mm=0 ; j <= order ; j++ ) /* control point */

	fild	DWORD PTR tv453[ebp]
	xor	eax, eax
	mov	DWORD PTR _j$[ebp], eax
	mov	DWORD PTR _mm$[ebp], eax
	fdiv	ST(0), ST(1)
	mov	DWORD PTR tv382[ebp], ebx
	fstp	QWORD PTR _x$[ebp]
	fild	DWORD PTR _k$[ebp]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _x$[ebp+16]
$LN25@bezier_con@2:

; 2913 :         for ( m = 0 ; m+j <= order ; m++,mm++ ) /* control point */

	xor	edi, edi
	cmp	eax, ebx
	jg	SHORT $LN5@bezier_con@2
	mov	edx, DWORD PTR _mm$[ebp]
	fstp	ST(0)

; 2914 :         { inx[0] = order-j-m;
; 2915 :           inx[1] = j;

	mov	DWORD PTR _inx$[ebp+4], eax
	mov	eax, DWORD PTR [ecx]
	lea	esi, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR tv382[ebp]
	mov	DWORD PTR tv354[ebp], edx
	mov	edx, DWORD PTR tv464[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	sub	ecx, eax
	mov	DWORD PTR tv469[ebp], ecx
$LL24@bezier_con@2:

; 2916 :           inx[2] = m;
; 2917 :           a[kk][mm] = b[kk][mm] = bezier_eval(order,2,inx,x);

	mov	eax, DWORD PTR tv354[ebp]
	lea	ecx, DWORD PTR _x$[ebp]
	push	ecx
	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	push	2
	push	ebx
	mov	DWORD PTR _inx$[ebp], eax
	mov	DWORD PTR _inx$[ebp+8], edi
	call	_bezier_eval
	mov	eax, DWORD PTR tv469[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	fst	QWORD PTR [eax+esi]
	mov	eax, 1
	fstp	QWORD PTR [esi]
	sub	DWORD PTR tv354[ebp], eax
	add	DWORD PTR _mm$[ebp], eax
	add	edi, eax
	lea	edx, DWORD PTR [edi+ecx]
	add	esp, 16					; 00000010H
	add	esi, 8
	cmp	edx, ebx
	jle	SHORT $LL24@bezier_con@2

; 2913 :         for ( m = 0 ; m+j <= order ; m++,mm++ ) /* control point */

	fld	QWORD PTR tv240[ebp]
	mov	eax, ecx
	mov	ecx, DWORD PTR tv427[ebp]
$LN5@bezier_con@2:

; 2911 :       x[2] = k/(REAL)order;
; 2912 :       for ( j = 0, mm=0 ; j <= order ; j++ ) /* control point */

	dec	DWORD PTR tv382[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, ebx
	jle	SHORT $LN25@bezier_con@2

; 2908 :     for ( k = 0 ; i+k <= order ; k++,kk++ )  /* point on curve */

	mov	eax, DWORD PTR _k$[ebp]
	mov	edx, 1
	sub	DWORD PTR tv453[ebp], edx
	add	DWORD PTR _kk$[ebp], edx
	add	eax, edx
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _k$[ebp], eax
	add	ecx, 4
	add	eax, edx
	mov	DWORD PTR tv427[ebp], ecx
	cmp	eax, ebx
	jle	$LN9@bezier_con@2
	mov	edi, DWORD PTR _a$[ebp]
	fstp	ST(0)
	mov	esi, DWORD PTR _b$[ebp]
$LN11@bezier_con@2:

; 2905 : 
; 2906 :   /* fill in forward matrix */
; 2907 :   for ( i = 0, kk=0 ; i <= order ; i++ )  /* point on curve */

	dec	DWORD PTR tv528[ebp]
	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, ebx
	jle	$LL26@bezier_con@2
$LN10@bezier_con@2:

; 2918 :         }
; 2919 :   } 
; 2920 :   mat_inv(a,numpts);

	mov	eax, DWORD PTR _numpts$[ebp]
	push	eax
	push	edi
	call	_mat_inv
	add	esp, 8

; 2921 :   bezier2invert[order] = a;

	mov	DWORD PTR _bezier2invert[ebx*4], edi

; 2922 :   bezier2revert[order] = b;

	mov	DWORD PTR _bezier2revert[ebx*4], esi
$LN14@bezier_con@2:

; 2923 : 
; 2924 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_bezier_convert_2D_init ENDP
_TEXT	ENDS
PUBLIC	_trans$GSCopy$
PUBLIC	_new_order$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_bezier_trans_1d
; Function compile flags: /Ogtp
;	COMDAT _bezier_trans_1d
_TEXT	SEGMENT
_xqXvS$ = -3672						; size = 84
_t$ = -3588						; size = 16
tv168 = -3572						; size = 8
_inx$ = -3564						; size = 8
_trans$GSCopy$ = -3556					; size = 4
_new_order$GSCopy$ = -3552				; size = 4
_x$ = -3548						; size = 4
tv226 = -3544						; size = 4
_i$ = -3540						; size = 4
tv268 = -3536						; size = 4
_xxJ$ = -3532						; size = 3528
__$ArrayPad$ = -4					; size = 4
_old_order$ = 8						; size = 4
_new_order$ = 12					; size = 4
_trans$ = 16						; size = 4
_bezier_trans_1d PROC					; COMDAT

; 2939 : { int i,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 3672				; 00000e58H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2940 :   int inx[2];
; 2941 :   REAL t[2];
; 2942 :   MAT2D(x,MAXLAGRANGE+1,MAXLAGRANGE+1);  /* old control to curve points */

	mov	eax, DWORD PTR _trans$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _new_order$[ebp]
	push	edi
	push	21					; 00000015H
	push	21					; 00000015H
	lea	ecx, DWORD PTR _xxJ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _xqXvS$[ebp]
	push	edx
	mov	DWORD PTR _new_order$GSCopy$[ebp], ebx
	mov	DWORD PTR _trans$GSCopy$[ebp], eax
	call	_mat2d_setup
	add	esp, 16					; 00000010H

; 2943 : 
; 2944 :   if ( !bezier1invert[new_order] )

	cmp	DWORD PTR _bezier1invert[ebx*4], 0
	mov	DWORD PTR _x$[ebp], eax
	jne	SHORT $LN7@bezier_tra

; 2945 :     bezier_convert_1D_init(new_order);

	push	ebx
	call	_bezier_convert_1D_init
	add	esp, 4
$LN7@bezier_tra:

; 2946 : 
; 2947 :   /* old control to curve point matrix */
; 2948 :   for ( i = 0 ; i <= new_order ; i++ )

	mov	edi, DWORD PTR _old_order$[ebp]
	xor	eax, eax
	mov	DWORD PTR _i$[ebp], eax
	test	ebx, ebx
	js	$LN4@bezier_tra
	fild	DWORD PTR _new_order$GSCopy$[ebp]
	mov	DWORD PTR tv268[ebp], ebx
	push	esi
	fst	QWORD PTR tv168[ebp]
$LN14@bezier_tra:

; 2949 :   { 
; 2950 :     t[0] = (new_order - i)/(REAL)new_order;

	fild	DWORD PTR tv268[ebp]

; 2951 :     t[1] = i/(REAL)new_order;
; 2952 :     for ( k = 0 ; k <= old_order ; k++ )

	xor	esi, esi
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _t$[ebp]
	fild	DWORD PTR _i$[ebp]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _t$[ebp+8]
	test	edi, edi
	js	SHORT $LN5@bezier_tra
	mov	ecx, DWORD PTR _x$[ebp]
	fstp	ST(0)
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv226[ebp], edx
	mov	ebx, edi
	npad	11
$LL3@bezier_tra:

; 2953 :     { inx[0] = old_order-k; inx[1] = k;
; 2954 :       x[i][k] = bezier_eval(old_order,1,inx,t);

	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	lea	ecx, DWORD PTR _inx$[ebp]
	push	ecx
	push	1
	push	edi
	mov	DWORD PTR _inx$[ebp], ebx
	mov	DWORD PTR _inx$[ebp+4], esi
	call	_bezier_eval
	mov	eax, DWORD PTR tv226[ebp]
	fstp	QWORD PTR [eax]
	inc	esi
	add	eax, 8
	add	esp, 16					; 00000010H
	dec	ebx
	mov	DWORD PTR tv226[ebp], eax
	cmp	esi, edi
	jle	SHORT $LL3@bezier_tra

; 2951 :     t[1] = i/(REAL)new_order;
; 2952 :     for ( k = 0 ; k <= old_order ; k++ )

	fld	QWORD PTR tv168[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ebx, DWORD PTR _new_order$GSCopy$[ebp]
$LN5@bezier_tra:

; 2946 : 
; 2947 :   /* old control to curve point matrix */
; 2948 :   for ( i = 0 ; i <= new_order ; i++ )

	dec	DWORD PTR tv268[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, ebx
	jle	$LN14@bezier_tra
	fstp	ST(0)
	pop	esi
$LN4@bezier_tra:

; 2955 :     }
; 2956 :   }
; 2957 :   
; 2958 :   /* now get final transition matrix */
; 2959 :   mat_mult(bezier1invert[new_order],x,trans,new_order+1,new_order+1,old_order+1);

	mov	edx, DWORD PTR _trans$GSCopy$[ebp]
	mov	ecx, DWORD PTR _bezier1invert[ebx*4]
	lea	eax, DWORD PTR [ebx+1]
	inc	edi
	push	edi
	push	eax
	push	eax
	mov	eax, DWORD PTR _x$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_mat_mult

; 2960 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 24					; 00000018H
	pop	edi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_bezier_trans_1d ENDP
_TEXT	ENDS
PUBLIC	_new_order$GSCopy$
PUBLIC	_trans$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_bezier_trans_2d
; Function compile flags: /Ogtp
;	COMDAT _bezier_trans_2d
_TEXT	SEGMENT
tv213 = -100						; size = 8
_new_numpts$ = -92					; size = 4
_old_numpts$ = -88					; size = 4
_trans$GSCopy$ = -84					; size = 4
_new_order$GSCopy$ = -80				; size = 4
_x$ = -76						; size = 4
_k$ = -72						; size = 4
tv388 = -68						; size = 4
_i$ = -64						; size = 4
_jj$ = -60						; size = 4
_kk$ = -56						; size = 4
tv333 = -52						; size = 4
_j$ = -48						; size = 4
tv414 = -44						; size = 4
_t$ = -40						; size = 24
_inx$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_old_order$ = 8						; size = 4
_new_order$ = 12					; size = 4
_trans$ = 16						; size = 4
_bezier_trans_2d PROC					; COMDAT

; 2975 : { int i,j,k,m,jj,kk;

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2999 :         }
; 3000 :     }
; 3001 :   
; 3002 :   /* now get final transition matrix */
; 3003 :   mat_mult(bezier2invert[new_order],x,trans,new_numpts,new_numpts,old_numpts);

	mov	eax, DWORD PTR _trans$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _new_order$[ebp]
	push	esi
	mov	DWORD PTR _trans$GSCopy$[ebp], eax
	push	edi
	mov	edi, DWORD PTR _old_order$[ebp]
	lea	ecx, DWORD PTR [edi+1]
	lea	eax, DWORD PTR [edi+2]
	imul	eax, ecx
	cdq
	sub	eax, edx
	mov	ecx, eax
	lea	edx, DWORD PTR [ebx+1]
	lea	eax, DWORD PTR [ebx+2]
	imul	eax, edx
	cdq
	push	2983					; 00000ba7H
	sar	ecx, 1
	sub	eax, edx
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	mov	DWORD PTR _old_numpts$[ebp], ecx
	mov	esi, eax
	dec	ecx
	push	ecx
	sar	esi, 1
	push	0
	lea	eax, DWORD PTR [esi-1]
	push	eax
	push	0
	mov	DWORD PTR _new_order$GSCopy$[ebp], ebx
	mov	DWORD PTR _new_numpts$[ebp], esi
	call	_kb_dmatrix
	add	esp, 24					; 00000018H
	cmp	DWORD PTR _bezier2invert[ebx*4], 0
	mov	DWORD PTR _x$[ebp], eax
	jne	SHORT $LN13@bezier_tra@2

; 2976 :   int inx[3];
; 2977 :   REAL t[3];
; 2978 :   int old_numpts = ((old_order+1)*(old_order+2))/2;
; 2979 :   int new_numpts = ((new_order+1)*(new_order+2))/2;
; 2980 :   REAL **x;
; 2981 : 
; 2982 :   /* old control to surface points */
; 2983 :   x = dmatrix(0,new_numpts-1,0,old_numpts-1);
; 2984 : 
; 2985 :   if ( !bezier2invert[new_order] )
; 2986 :     bezier_convert_2D_init(new_order);

	push	ebx
	call	_bezier_convert_2D_init
	add	esp, 4
$LN13@bezier_tra@2:

; 2987 : 
; 2988 :   /* old control to surface point matrix */
; 2989 :   for ( j = 0, jj=0 ; j <= new_order ; j++ )

	xor	ecx, ecx
	mov	DWORD PTR _j$[ebp], ecx
	mov	DWORD PTR _jj$[ebp], ecx
	cmp	ebx, ecx
	jl	$LN10@bezier_tra@2
	mov	DWORD PTR tv414[ebp], ebx
	npad	3
$LL27@bezier_tra@2:

; 2990 :     for ( i = 0 ; i+j <= new_order ; i++,jj++ )

	mov	DWORD PTR _i$[ebp], 0
	cmp	ecx, ebx
	jg	$LN11@bezier_tra@2
	fild	DWORD PTR _new_order$GSCopy$[ebp]
	mov	edx, DWORD PTR tv414[ebp]
	mov	DWORD PTR tv388[ebp], edx
	fst	QWORD PTR tv213[ebp]

; 2993 :       t[1] = j/(REAL)new_order;

	fild	DWORD PTR _j$[ebp]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _t$[ebp+8]
$LN26@bezier_tra@2:

; 2994 :       t[2] = i/(REAL)new_order;
; 2995 :       for ( k = 0, kk = 0 ; k <= old_order ; k++ )

	fild	DWORD PTR tv388[ebp]
	xor	eax, eax
	mov	DWORD PTR _k$[ebp], eax
	mov	DWORD PTR _kk$[ebp], eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _t$[ebp]
	fild	DWORD PTR _i$[ebp]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _t$[ebp+16]
	test	edi, edi
	js	SHORT $LN8@bezier_tra@2

; 2991 :     { 
; 2992 :       t[0] = (new_order - i - j)/(REAL)new_order;

	mov	DWORD PTR tv333[ebp], edi
$LN24@bezier_tra@2:

; 2996 :         for ( m = 0 ; m+k <= old_order ; m++, kk++ )

	xor	esi, esi
	cmp	eax, edi
	jg	SHORT $LN5@bezier_tra@2
	mov	ecx, DWORD PTR _jj$[ebp]
	fstp	ST(0)
	mov	edi, DWORD PTR tv333[ebp]

; 2997 :         { inx[0] = old_order-k-m; inx[1] = k; inx[2] = m;

	mov	DWORD PTR _inx$[ebp+4], eax
	mov	eax, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _kk$[ebp]
	lea	ebx, DWORD PTR [edx+eax*8]
	npad	1
$LL3@bezier_tra@2:

; 2998 :           x[jj][kk] = bezier_eval(old_order,2,inx,t);

	mov	eax, DWORD PTR _old_order$[ebp]
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	push	2
	push	eax
	mov	DWORD PTR _inx$[ebp], edi
	mov	DWORD PTR _inx$[ebp+8], esi
	call	_bezier_eval
	fstp	QWORD PTR [ebx]
	mov	ecx, DWORD PTR _k$[ebp]
	inc	DWORD PTR _kk$[ebp]
	inc	esi
	lea	edx, DWORD PTR [esi+ecx]
	add	esp, 16					; 00000010H
	dec	edi
	add	ebx, 8
	cmp	edx, DWORD PTR _old_order$[ebp]
	jle	SHORT $LL3@bezier_tra@2

; 2996 :         for ( m = 0 ; m+k <= old_order ; m++, kk++ )

	fld	QWORD PTR tv213[ebp]
	mov	edi, DWORD PTR _old_order$[ebp]
	mov	ebx, DWORD PTR _new_order$GSCopy$[ebp]
	mov	eax, ecx
$LN5@bezier_tra@2:

; 2994 :       t[2] = i/(REAL)new_order;
; 2995 :       for ( k = 0, kk = 0 ; k <= old_order ; k++ )

	dec	DWORD PTR tv333[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, edi
	jle	SHORT $LN24@bezier_tra@2
	mov	esi, DWORD PTR _new_numpts$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
$LN8@bezier_tra@2:

; 2990 :     for ( i = 0 ; i+j <= new_order ; i++,jj++ )

	mov	eax, DWORD PTR _i$[ebp]
	dec	DWORD PTR tv388[ebp]
	inc	DWORD PTR _jj$[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	add	eax, ecx
	cmp	eax, ebx
	jle	$LN26@bezier_tra@2
	fstp	ST(0)
$LN11@bezier_tra@2:

; 2987 : 
; 2988 :   /* old control to surface point matrix */
; 2989 :   for ( j = 0, jj=0 ; j <= new_order ; j++ )

	dec	DWORD PTR tv414[ebp]
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, ebx
	jle	$LL27@bezier_tra@2
$LN10@bezier_tra@2:

; 2999 :         }
; 3000 :     }
; 3001 :   
; 3002 :   /* now get final transition matrix */
; 3003 :   mat_mult(bezier2invert[new_order],x,trans,new_numpts,new_numpts,old_numpts);

	mov	eax, DWORD PTR _old_numpts$[ebp]
	mov	ecx, DWORD PTR _trans$GSCopy$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	push	eax
	mov	eax, DWORD PTR _bezier2invert[ebx*4]
	push	esi
	push	esi
	push	ecx
	push	edx
	push	eax
	call	_mat_mult

; 3004 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_bezier_trans_2d ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_bezier_refine_1d_init
EXTRN	_bezier_refine_1d:BYTE
EXTRN	__chkstk:PROC
; Function compile flags: /Ogtp
;	COMDAT _bezier_refine_1d_init
_TEXT	SEGMENT
_xqXvS$ = -7112						; size = 164
_t$ = -6948						; size = 16
tv205 = -6932						; size = 8
_inx$ = -6924						; size = 8
tv192 = -6916						; size = 4
tv197 = -6912						; size = 4
_x$ = -6908						; size = 4
tv270 = -6904						; size = 4
_i$ = -6900						; size = 4
tv314 = -6896						; size = 4
_xxJ$ = -6892						; size = 6888
__$ArrayPad$ = -4					; size = 4
_order$ = 8						; size = 4
_bezier_refine_1d_init PROC				; COMDAT

; 3015 : { int i,k;

	push	ebp
	mov	ebp, esp
	mov	eax, 7112				; 00001bc8H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _order$[ebp]

; 3016 :   int inx[2];
; 3017 :   REAL t[2];
; 3018 :   MAT2D(x,2*MAXLAGRANGE+1,MAXLAGRANGE+1);  /* old control to curve points */

	push	21					; 00000015H
	push	41					; 00000029H
	lea	eax, DWORD PTR _xxJ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _xqXvS$[ebp]
	push	ecx
	call	_mat2d_setup

; 3019 : 
; 3020 :   if ( bezier_refine_1d[order] ) return;

	lea	ebx, DWORD PTR [esi*4]
	add	esp, 16					; 00000010H
	cmp	DWORD PTR _bezier_refine_1d[ebx], 0
	mov	DWORD PTR _x$[ebp], eax
	mov	DWORD PTR tv192[ebp], ebx
	jne	$LN9@bezier_ref

; 3021 :   bezier_refine_1d[order] = dmatrix(0,2*order,0,order);

	push	edi
	push	3021					; 00000bcdH
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	push	esi
	lea	edi, DWORD PTR [esi+esi]
	push	0
	push	edi
	push	0
	mov	DWORD PTR tv197[ebp], edi
	call	_kb_dmatrix
	add	esp, 24					; 00000018H

; 3022 : 
; 3023 :   if ( !bezier1invert[order] )

	cmp	DWORD PTR _bezier1invert[ebx], 0
	mov	DWORD PTR _bezier_refine_1d[ebx], eax
	jne	SHORT $LN7@bezier_ref

; 3024 :     bezier_convert_1D_init(order);

	push	esi
	call	_bezier_convert_1D_init
	add	esp, 4
$LN7@bezier_ref:

; 3025 : 
; 3026 :   /* old control to curve point matrix */
; 3027 :   for ( i = 0 ; i <= 2*order ; i++ )

	xor	eax, eax
	mov	DWORD PTR _i$[ebp], eax
	test	edi, edi
	js	$LN4@bezier_ref
	fild	DWORD PTR tv197[ebp]
	mov	DWORD PTR tv314[ebp], edi
	fst	QWORD PTR tv205[ebp]
$LN15@bezier_ref:

; 3028 :   { 
; 3029 :     t[0] = (2*order - i)/(REAL)(2*order);

	fild	DWORD PTR tv314[ebp]

; 3030 :     t[1] = i/(REAL)(2*order);
; 3031 :     for ( k = 0 ; k <= order ; k++ )

	xor	edi, edi
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _t$[ebp]
	fild	DWORD PTR _i$[ebp]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _t$[ebp+8]
	test	esi, esi
	js	SHORT $LN5@bezier_ref
	mov	edx, DWORD PTR _x$[ebp]
	fstp	ST(0)
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv270[ebp], eax
	mov	ebx, esi
	npad	9
$LL3@bezier_ref:

; 3032 :     { inx[0] = order-k; inx[1] = k;
; 3033 :       x[i][k] = bezier_eval(order,1,inx,t);

	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	push	1
	push	esi
	mov	DWORD PTR _inx$[ebp], ebx
	mov	DWORD PTR _inx$[ebp+4], edi
	call	_bezier_eval
	mov	eax, DWORD PTR tv270[ebp]
	fstp	QWORD PTR [eax]
	inc	edi
	add	eax, 8
	add	esp, 16					; 00000010H
	dec	ebx
	mov	DWORD PTR tv270[ebp], eax
	cmp	edi, esi
	jle	SHORT $LL3@bezier_ref

; 3030 :     t[1] = i/(REAL)(2*order);
; 3031 :     for ( k = 0 ; k <= order ; k++ )

	fld	QWORD PTR tv205[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ebx, DWORD PTR tv192[ebp]
$LN5@bezier_ref:

; 3025 : 
; 3026 :   /* old control to curve point matrix */
; 3027 :   for ( i = 0 ; i <= 2*order ; i++ )

	dec	DWORD PTR tv314[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	cmp	eax, DWORD PTR tv197[ebp]
	jle	$LN15@bezier_ref
	fstp	ST(0)
$LN4@bezier_ref:

; 3034 :     }
; 3035 :   }
; 3036 :   
; 3037 :   /* now get final transition matrix */
; 3038 :   mat_mult(bezier1invert[order],x,bezier_refine_1d[order],
; 3039 :     order+1,order+1,order+1);

	mov	eax, DWORD PTR _bezier_refine_1d[ebx]
	mov	edi, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _bezier1invert[ebx]
	inc	esi
	push	esi
	push	esi
	push	esi
	push	eax
	push	edi
	push	ecx
	call	_mat_mult

; 3040 :   mat_mult(bezier1invert[order],x+order,bezier_refine_1d[order]+order,
; 3041 :     order+1,order+1,order+1);

	mov	edx, DWORD PTR _bezier_refine_1d[ebx]
	mov	ecx, DWORD PTR _bezier1invert[ebx]
	push	esi
	push	esi
	push	esi
	add	edx, ebx
	push	edx
	lea	eax, DWORD PTR [ebx+edi]
	push	eax
	push	ecx
	call	_mat_mult
	add	esp, 48					; 00000030H
	pop	edi
$LN9@bezier_ref:

; 3042 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_bezier_refine_1d_init ENDP
_TEXT	ENDS
PUBLIC	_order$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_bezier_refine_2d_init
EXTRN	_bezier_refine_2d:BYTE
; Function compile flags: /Ogtp
;	COMDAT _bezier_refine_2d_init
_TEXT	SEGMENT
tv1302 = -96						; size = 8
tv5185 = -92						; size = 4
tv4730 = -92						; size = 4
_x$ = -88						; size = 4
tv5293 = -84						; size = 4
tv1284 = -84						; size = 4
tv1700 = -80						; size = 4
_z$ = -80						; size = 4
_w$ = -76						; size = 4
_i$ = -76						; size = 4
_order$GSCopy$ = -72					; size = 4
tv3755 = -68						; size = 4
tv2221 = -68						; size = 4
tv1341 = -68						; size = 4
_k$ = -68						; size = 4
tv5011 = -64						; size = 4
tv4658 = -64						; size = 4
tv3994 = -64						; size = 4
tv3619 = -64						; size = 4
tv2928 = -64						; size = 4
tv2539 = -64						; size = 4
tv1952 = -64						; size = 4
tv1601 = -64						; size = 4
tv256 = -64						; size = 4
_kk$ = -60						; size = 4
tv5265 = -56						; size = 4
tv4770 = -56						; size = 4
tv4063 = -56						; size = 4
tv3655 = -56						; size = 4
tv3022 = -56						; size = 4
tv2641 = -56						; size = 4
tv2226 = -56						; size = 4
tv1988 = -56						; size = 4
tv1634 = -56						; size = 4
_j$ = -52						; size = 4
tv4876 = -48						; size = 4
tv4695 = -48						; size = 4
tv3848 = -48						; size = 4
tv3744 = -48						; size = 4
tv2807 = -48						; size = 4
tv2668 = -48						; size = 4
tv2099 = -48						; size = 4
tv2024 = -48						; size = 4
tv1610 = -48						; size = 4
tv1740 = -44						; size = 4
_jj$ = -44						; size = 4
_t$ = -40						; size = 24
_inx$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_order$ = 8						; size = 4
_bezier_refine_2d_init PROC				; COMDAT

; 3053 : { int i,j,k,m,kk,mm,jj;

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	mov	esi, DWORD PTR _order$[ebp]

; 3054 :   int inx[3];
; 3055 :   REAL t[3];
; 3056 :   int old_numpts = ((order+1)*(order+2))/2;

	lea	ecx, DWORD PTR [esi+1]
	lea	eax, DWORD PTR [esi+2]
	imul	eax, ecx
	push	edi
	cdq
	sub	eax, edx

; 3058 :   REAL ***x = dmatrix3(2*order+1,2*order+1,old_numpts);

	push	3058					; 00000bf2H
	mov	ebx, eax
	lea	edi, DWORD PTR [esi+esi]
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	sar	ebx, 1
	mov	DWORD PTR tv1284[ebp], edi
	inc	edi
	push	ebx
	push	edi
	push	edi
	mov	DWORD PTR _order$GSCopy$[ebp], esi
	call	_kb_dmatrix3

; 3059 :               /* old control to curve points */
; 3060 :   REAL **z,**w; /* for pieces of whole matrix */
; 3061 : 
; 3062 :   if ( bezier_refine_2d[order] ) return;

	add	esi, esi
	add	esi, esi
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _bezier_refine_2d[esi], 0
	mov	DWORD PTR _x$[ebp], eax
	jne	$LN87@bezier_ref@2

; 3057 :   int new_numpts = (2*order+1)*(order+1);

	mov	eax, DWORD PTR _order$GSCopy$[ebp]
	inc	eax

; 3063 :   bezier_refine_2d[order] = dmatrix(0,new_numpts,0,old_numpts);

	push	3063					; 00000bf7H
	imul	edi, eax
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	push	ebx
	push	0
	push	edi
	push	0
	call	_kb_dmatrix
	add	esp, 24					; 00000018H

; 3064 : 
; 3065 :   if ( !bezier2invert[order] )

	cmp	DWORD PTR _bezier2invert[esi], 0
	mov	DWORD PTR _bezier_refine_2d[esi], eax
	jne	SHORT $LN85@bezier_ref@2

; 3066 :     bezier_convert_2D_init(order);

	mov	eax, DWORD PTR _order$GSCopy$[ebp]
	push	eax
	call	_bezier_convert_2D_init
	add	esp, 4
$LN85@bezier_ref@2:

; 3067 : 
; 3068 :   /* old control to curve point matrix */
; 3069 :   for ( j = 0 ; j <= 2*order ; j++ )

	cmp	DWORD PTR tv1284[ebp], 0
	mov	DWORD PTR _j$[ebp], 0
	jl	$LN82@bezier_ref@2
	mov	ecx, DWORD PTR tv1284[ebp]
	mov	DWORD PTR tv1740[ebp], ecx
	npad	6
$LL84@bezier_ref@2:

; 3070 :     for ( i = 0 ; i+j <= 2*order ; i++ )

	mov	edx, DWORD PTR tv1284[ebp]
	mov	DWORD PTR _i$[ebp], 0
	cmp	DWORD PTR _j$[ebp], edx
	jg	$LN83@bezier_ref@2
	fild	DWORD PTR tv1284[ebp]
	mov	eax, DWORD PTR tv1740[ebp]
	mov	DWORD PTR tv1700[ebp], eax
	fst	QWORD PTR tv1302[ebp]

; 3073 :       t[1] = j/(REAL)(2*order);

	fild	DWORD PTR _j$[ebp]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _t$[ebp+8]
$LN81@bezier_ref@2:

; 3074 :       t[2] = i/(REAL)(2*order);
; 3075 :       for ( k = 0, kk = 0 ; k <= order ; k++ )

	fild	DWORD PTR tv1700[ebp]
	xor	eax, eax
	mov	DWORD PTR _k$[ebp], eax
	mov	DWORD PTR _kk$[ebp], eax
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _t$[ebp]
	fild	DWORD PTR _i$[ebp]
	fdiv	ST(0), ST(1)
	fstp	QWORD PTR _t$[ebp+16]
	cmp	DWORD PTR _order$GSCopy$[ebp], eax
	jl	$LN80@bezier_ref@2

; 3071 :     { 
; 3072 :       t[0] = (2*order - i - j)/(REAL)(2*order);

	mov	ecx, DWORD PTR _order$GSCopy$[ebp]
	mov	DWORD PTR tv1634[ebp], ecx
$LN78@bezier_ref@2:

; 3076 :         for ( m = 0 ; m+k <= order ; m++,kk++ )

	mov	edx, DWORD PTR _order$GSCopy$[ebp]
	xor	edi, edi
	cmp	DWORD PTR _k$[ebp], edx
	jg	SHORT $LN77@bezier_ref@2

; 3077 :         { inx[0] = order-k-m; inx[1] = k; inx[2] = m;

	mov	eax, DWORD PTR _k$[ebp]
	fstp	ST(0)
	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _inx$[ebp+4], eax
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _kk$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR tv1634[ebp]
	mov	DWORD PTR tv1601[ebp], ecx
	mov	DWORD PTR tv1610[ebp], edx
	npad	2
$LL75@bezier_ref@2:
	mov	eax, DWORD PTR tv1610[ebp]

; 3078 :           x[i][j][kk] = bezier_eval(order,2,inx,t);

	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	lea	edx, DWORD PTR _inx$[ebp]
	push	edx
	mov	DWORD PTR _inx$[ebp], eax
	mov	eax, DWORD PTR _order$GSCopy$[ebp]
	push	2
	push	eax
	mov	DWORD PTR _inx$[ebp+8], edi
	call	_bezier_eval
	mov	eax, DWORD PTR tv1601[ebp]
	mov	ecx, 1
	fstp	QWORD PTR [eax]
	sub	DWORD PTR tv1610[ebp], ecx
	add	DWORD PTR _kk$[ebp], ecx
	add	edi, ecx
	mov	ecx, DWORD PTR _k$[ebp]
	add	eax, 8
	lea	edx, DWORD PTR [edi+ecx]
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv1601[ebp], eax
	cmp	edx, DWORD PTR _order$GSCopy$[ebp]
	jle	SHORT $LL75@bezier_ref@2

; 3076 :         for ( m = 0 ; m+k <= order ; m++,kk++ )

	fld	QWORD PTR tv1302[ebp]
$LN77@bezier_ref@2:

; 3074 :       t[2] = i/(REAL)(2*order);
; 3075 :       for ( k = 0, kk = 0 ; k <= order ; k++ )

	mov	eax, DWORD PTR _k$[ebp]
	dec	DWORD PTR tv1634[ebp]
	inc	eax
	mov	DWORD PTR _k$[ebp], eax
	cmp	eax, DWORD PTR _order$GSCopy$[ebp]
	jle	$LN78@bezier_ref@2
$LN80@bezier_ref@2:

; 3070 :     for ( i = 0 ; i+j <= 2*order ; i++ )

	mov	eax, DWORD PTR _i$[ebp]
	dec	DWORD PTR tv1700[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	add	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR tv1284[ebp]
	jle	$LN81@bezier_ref@2
	fstp	ST(0)
$LN83@bezier_ref@2:

; 3067 : 
; 3068 :   /* old control to curve point matrix */
; 3069 :   for ( j = 0 ; j <= 2*order ; j++ )

	mov	eax, DWORD PTR _j$[ebp]
	dec	DWORD PTR tv1740[ebp]
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, DWORD PTR tv1284[ebp]
	jle	$LL84@bezier_ref@2
$LN82@bezier_ref@2:

; 3079 :         }
; 3080 :     }
; 3081 :   
; 3082 :   /* now get final transition matrix in four sections */
; 3083 :   z =  dmatrix(0,old_numpts-1,0,old_numpts-1);

	push	3083					; 00000c0bH
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	lea	edi, DWORD PTR [ebx-1]
	push	edi
	push	0
	push	edi
	push	0
	call	_kb_dmatrix

; 3084 :   w =  dmatrix(0,old_numpts-1,0,old_numpts-1);

	push	3084					; 00000c0cH
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	push	edi
	push	0
	push	edi
	push	0
	mov	DWORD PTR _z$[ebp], eax
	call	_kb_dmatrix

; 3085 :   /* lower left */
; 3086 :   for ( j = 0, jj = 0 ; j <= order ; j++ )

	mov	edi, DWORD PTR _order$GSCopy$[ebp]
	xor	ecx, ecx
	add	esp, 48					; 00000030H
	mov	DWORD PTR _w$[ebp], eax
	mov	DWORD PTR _j$[ebp], ecx
	mov	DWORD PTR _jj$[ebp], ecx
	test	edi, edi
	js	$LN169@bezier_ref@2

; 3087 :     for ( i = 0 ; i+j <= order ; i++, jj++ )

	cmp	ecx, edi
	jg	$LN71@bezier_ref@2
$LN192@bezier_ref@2:
	mov	edx, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv1952[ebp], ecx
	mov	DWORD PTR tv1988[ebp], edx
	npad	3
$LL180@bezier_ref@2:

; 3088 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	DWORD PTR _kk$[ebp], 0
	cmp	ebx, 4
	jl	SHORT $LN173@bezier_ref@2
	mov	eax, DWORD PTR tv1988[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _jj$[ebp]
	mov	edi, DWORD PTR [eax+edx*4]
	lea	edx, DWORD PTR [ecx+24]

; 3089 :         z[jj][kk] = x[i][j][kk];

	sub	ecx, edi
	mov	DWORD PTR tv2024[ebp], ecx
	lea	ecx, DWORD PTR [ebx-4]
	shr	ecx, 2
	lea	eax, DWORD PTR [edi+8]
	inc	ecx
	lea	edi, DWORD PTR [ecx*4]
	mov	DWORD PTR _kk$[ebp], edi
	mov	edi, DWORD PTR tv2024[ebp]
	npad	4
$LL147@bezier_ref@2:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	add	edx, 32					; 00000020H
	dec	ecx
	fld	QWORD PTR [edi+eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LL147@bezier_ref@2

; 3088 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	edi, DWORD PTR _order$GSCopy$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
$LN173@bezier_ref@2:
	cmp	DWORD PTR _kk$[ebp], ebx
	jge	SHORT $LN68@bezier_ref@2

; 3133 :   free_matrix(w);

	mov	edx, DWORD PTR _jj$[ebp]
	mov	eax, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _kk$[ebp]
	mov	DWORD PTR tv1341[ebp], eax
	lea	eax, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR tv1988[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+ecx*4]
	sub	ecx, DWORD PTR tv1341[ebp]
	mov	DWORD PTR tv2024[ebp], ecx
	mov	edx, ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR _kk$[ebp]
$LC66@bezier_ref@2:

; 3088 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	fld	QWORD PTR [edx+eax]
	add	eax, 8
	dec	ecx

; 3089 :         z[jj][kk] = x[i][j][kk];

	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC66@bezier_ref@2

; 3088 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	ecx, DWORD PTR _j$[ebp]
$LN68@bezier_ref@2:

; 3087 :     for ( i = 0 ; i+j <= order ; i++, jj++ )

	mov	eax, DWORD PTR tv1952[ebp]
	add	DWORD PTR tv1988[ebp], 4
	inc	DWORD PTR _jj$[ebp]
	inc	eax
	mov	DWORD PTR tv1952[ebp], eax
	cmp	eax, edi
	jle	$LL180@bezier_ref@2
$LN71@bezier_ref@2:

; 3085 :   /* lower left */
; 3086 :   for ( j = 0, jj = 0 ; j <= order ; j++ )

	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, edi
	jle	$LN192@bezier_ref@2
$LN169@bezier_ref@2:

; 3090 :   mat_mult(bezier2invert[order],z,w,old_numpts,old_numpts,old_numpts);

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _bezier2invert[esi]
	push	ebx
	push	ebx
	push	ebx
	push	eax
	push	ecx
	push	edx
	call	_mat_mult

; 3091 :   for ( j = 0, jj = 0, mm = 0 ; j <= order ; j++, mm += order )

	xor	eax, eax
	add	esp, 24					; 00000018H
	xor	ecx, ecx
	mov	DWORD PTR _j$[ebp], eax
	mov	DWORD PTR _jj$[ebp], eax
	cmp	eax, edi
	jg	$LN61@bezier_ref@2
$LN194@bezier_ref@2:

; 3092 :     for ( i = 0 ; i+j <= order ; i++, jj++, mm++ )

	mov	DWORD PTR tv2226[ebp], eax
$LL60@bezier_ref@2:

; 3093 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	xor	eax, eax
	cmp	ebx, 4
	jl	$LN172@bezier_ref@2
	mov	eax, DWORD PTR _w$[ebp]
	mov	edx, DWORD PTR _jj$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	lea	edi, DWORD PTR [ebx-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv256[ebp], edi
	lea	eax, DWORD PTR [edx+16]

; 3094 :         bezier_refine_2d[order][mm][kk] = w[jj][kk];

	neg	edx
	add	edi, edi
	add	edi, edi
	mov	DWORD PTR tv2099[ebp], 16		; 00000010H
	mov	DWORD PTR tv2221[ebp], edx
	mov	DWORD PTR _kk$[ebp], edi
	jmp	SHORT $LN150@bezier_ref@2
	npad	6
$LL171@bezier_ref@2:

; 3093 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	edx, DWORD PTR tv2221[ebp]
$LN150@bezier_ref@2:

; 3094 :         bezier_refine_2d[order][mm][kk] = w[jj][kk];

	mov	edi, DWORD PTR _bezier_refine_2d[esi]
	fld	QWORD PTR [eax-16]
	mov	edi, DWORD PTR [edi+ecx*4]
	lea	edx, DWORD PTR [edx+eax-16]
	fstp	QWORD PTR [edx+edi]
	mov	edi, DWORD PTR _bezier_refine_2d[esi]
	mov	edi, DWORD PTR [edi+ecx*4]
	fld	QWORD PTR [eax-8]
	fstp	QWORD PTR [edi+edx+8]
	mov	edx, DWORD PTR _bezier_refine_2d[esi]
	mov	edx, DWORD PTR [edx+ecx*4]
	fld	QWORD PTR [eax]
	mov	edi, DWORD PTR tv2099[ebp]
	add	DWORD PTR tv2099[ebp], 32		; 00000020H
	fstp	QWORD PTR [edi+edx]
	mov	edx, DWORD PTR _bezier_refine_2d[esi]
	fld	QWORD PTR [eax+8]
	mov	edi, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR tv2221[ebp]
	add	edx, 8
	add	edi, edx
	fstp	QWORD PTR [edi+eax]
	add	eax, 32					; 00000020H
	dec	DWORD PTR tv256[ebp]
	jne	SHORT $LL171@bezier_ref@2

; 3093 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	edi, DWORD PTR _order$GSCopy$[ebp]
	mov	eax, DWORD PTR _kk$[ebp]
$LN172@bezier_ref@2:
	cmp	eax, ebx
	jge	SHORT $LN59@bezier_ref@2
	mov	edx, DWORD PTR _w$[ebp]
	mov	edi, DWORD PTR _jj$[ebp]
	mov	edx, DWORD PTR [edx+edi*4]
	npad	3
$LC57@bezier_ref@2:

; 3094 :         bezier_refine_2d[order][mm][kk] = w[jj][kk];

	mov	edi, DWORD PTR _bezier_refine_2d[esi]
	fld	QWORD PTR [edx+eax*8]
	mov	edi, DWORD PTR [edi+ecx*4]
	fstp	QWORD PTR [edi+eax*8]
	inc	eax
	cmp	eax, ebx
	jl	SHORT $LC57@bezier_ref@2

; 3093 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	edi, DWORD PTR _order$GSCopy$[ebp]
$LN59@bezier_ref@2:

; 3092 :     for ( i = 0 ; i+j <= order ; i++, jj++, mm++ )

	mov	eax, DWORD PTR tv2226[ebp]
	inc	DWORD PTR _jj$[ebp]
	inc	eax
	inc	ecx
	mov	DWORD PTR tv2226[ebp], eax
	cmp	eax, edi
	jle	$LL60@bezier_ref@2
	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	add	ecx, edi
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, edi
	jle	$LN194@bezier_ref@2
$LN61@bezier_ref@2:

; 3095 : 
; 3096 :   /* lower right */
; 3097 :   for ( j = 0, jj = 0 ; j <= order ; j++ )

	xor	ecx, ecx
	mov	DWORD PTR _j$[ebp], ecx
	mov	DWORD PTR _jj$[ebp], ecx
	cmp	ecx, edi
	jg	$LN52@bezier_ref@2
$LN196@bezier_ref@2:

; 3098 :     for ( i = 0 ; i+j <= order ; i++, jj++ )

	mov	eax, DWORD PTR _x$[ebp]
	lea	edx, DWORD PTR [esi+eax]
	mov	DWORD PTR tv2539[ebp], ecx
	mov	DWORD PTR tv2641[ebp], edx
	npad	9
$LL179@bezier_ref@2:

; 3099 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	DWORD PTR _kk$[ebp], 0
	cmp	ebx, 4
	jl	SHORT $LN174@bezier_ref@2
	mov	eax, DWORD PTR tv2641[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	eax, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _jj$[ebp]
	mov	edi, DWORD PTR [eax+edx*4]
	lea	edx, DWORD PTR [ecx+24]

; 3100 :         z[jj][kk] = x[i+order][j][kk];

	sub	ecx, edi
	mov	DWORD PTR tv2668[ebp], ecx
	lea	ecx, DWORD PTR [ebx-4]
	shr	ecx, 2
	lea	eax, DWORD PTR [edi+8]
	inc	ecx
	lea	edi, DWORD PTR [ecx*4]
	mov	DWORD PTR _kk$[ebp], edi
	mov	edi, DWORD PTR tv2668[ebp]
	npad	4
$LL153@bezier_ref@2:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	add	edx, 32					; 00000020H
	dec	ecx
	fld	QWORD PTR [edi+eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LL153@bezier_ref@2

; 3099 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	edi, DWORD PTR _order$GSCopy$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
$LN174@bezier_ref@2:
	cmp	DWORD PTR _kk$[ebp], ebx
	jge	SHORT $LN50@bezier_ref@2

; 3133 :   free_matrix(w);

	mov	edx, DWORD PTR _jj$[ebp]
	mov	eax, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _kk$[ebp]
	mov	DWORD PTR tv1341[ebp], eax
	lea	eax, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR tv2641[ebp]
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+ecx*4]
	sub	ecx, DWORD PTR tv1341[ebp]
	mov	DWORD PTR tv2668[ebp], ecx
	mov	edx, ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR _kk$[ebp]
$LC48@bezier_ref@2:

; 3099 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	fld	QWORD PTR [edx+eax]
	add	eax, 8
	dec	ecx

; 3100 :         z[jj][kk] = x[i+order][j][kk];

	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC48@bezier_ref@2

; 3099 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	ecx, DWORD PTR _j$[ebp]
$LN50@bezier_ref@2:

; 3098 :     for ( i = 0 ; i+j <= order ; i++, jj++ )

	mov	eax, DWORD PTR tv2539[ebp]
	add	DWORD PTR tv2641[ebp], 4
	inc	DWORD PTR _jj$[ebp]
	inc	eax
	mov	DWORD PTR tv2539[ebp], eax
	cmp	eax, edi
	jle	$LL179@bezier_ref@2

; 3095 : 
; 3096 :   /* lower right */
; 3097 :   for ( j = 0, jj = 0 ; j <= order ; j++ )

	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, edi
	jle	$LN196@bezier_ref@2
$LN52@bezier_ref@2:

; 3101 :   mat_mult(bezier2invert[order],z,w,old_numpts,old_numpts,old_numpts);

	mov	eax, DWORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	edx, DWORD PTR _bezier2invert[esi]
	push	ebx
	push	ebx
	push	ebx
	push	eax
	push	ecx
	push	edx
	call	_mat_mult

; 3102 :   for ( j = 0, jj = 0, mm = order ; j <= order ; j++, mm += order )

	xor	eax, eax
	add	esp, 24					; 00000018H
	mov	DWORD PTR _j$[ebp], eax
	mov	DWORD PTR _jj$[ebp], eax
	mov	ecx, edi
	cmp	eax, edi
	jg	$LN43@bezier_ref@2
$LN198@bezier_ref@2:

; 3103 :     for ( i = 0 ; i+j <= order ; i++, jj++, mm++ )

	mov	DWORD PTR tv3022[ebp], eax
$LL42@bezier_ref@2:

; 3104 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	xor	eax, eax
	cmp	ebx, 4
	jl	$LC155@bezier_ref@2
	mov	eax, DWORD PTR _w$[ebp]
	mov	edx, DWORD PTR _jj$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	lea	edi, DWORD PTR [ebx-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv2928[ebp], edi
	lea	eax, DWORD PTR [edx+16]

; 3105 :         bezier_refine_2d[order][mm][kk] = w[jj][kk];

	neg	edx
	add	edi, edi
	add	edi, edi
	mov	DWORD PTR tv2807[ebp], 16		; 00000010H
	mov	DWORD PTR tv2221[ebp], edx
	mov	DWORD PTR _kk$[ebp], edi
	npad	8
$LL156@bezier_ref@2:
	mov	edi, DWORD PTR _bezier_refine_2d[esi]
	fld	QWORD PTR [eax-16]
	mov	edi, DWORD PTR [edi+ecx*4]
	lea	edx, DWORD PTR [eax+edx-16]
	fstp	QWORD PTR [edx+edi]
	mov	edi, DWORD PTR _bezier_refine_2d[esi]
	mov	edi, DWORD PTR [edi+ecx*4]
	fld	QWORD PTR [eax-8]
	fstp	QWORD PTR [edi+edx+8]
	mov	edx, DWORD PTR _bezier_refine_2d[esi]
	mov	edx, DWORD PTR [edx+ecx*4]
	fld	QWORD PTR [eax]
	mov	edi, DWORD PTR tv2807[ebp]
	add	DWORD PTR tv2807[ebp], 32		; 00000020H
	fstp	QWORD PTR [edi+edx]
	mov	edx, DWORD PTR _bezier_refine_2d[esi]
	fld	QWORD PTR [eax+8]
	mov	edi, DWORD PTR [edx+ecx*4]
	mov	edx, DWORD PTR tv2221[ebp]
	add	edi, eax
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [edi+edx+8]
	dec	DWORD PTR tv2928[ebp]
	jne	SHORT $LL156@bezier_ref@2

; 3104 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	edi, DWORD PTR _order$GSCopy$[ebp]
	mov	eax, DWORD PTR _kk$[ebp]
$LC155@bezier_ref@2:
	cmp	eax, ebx
	jge	SHORT $LN41@bezier_ref@2
	mov	edx, DWORD PTR _w$[ebp]
	mov	edi, DWORD PTR _jj$[ebp]
	mov	edx, DWORD PTR [edx+edi*4]
	npad	8
$LC39@bezier_ref@2:

; 3105 :         bezier_refine_2d[order][mm][kk] = w[jj][kk];

	mov	edi, DWORD PTR _bezier_refine_2d[esi]
	fld	QWORD PTR [edx+eax*8]
	mov	edi, DWORD PTR [edi+ecx*4]
	fstp	QWORD PTR [edi+eax*8]
	inc	eax
	cmp	eax, ebx
	jl	SHORT $LC39@bezier_ref@2

; 3104 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	edi, DWORD PTR _order$GSCopy$[ebp]
$LN41@bezier_ref@2:

; 3103 :     for ( i = 0 ; i+j <= order ; i++, jj++, mm++ )

	mov	eax, DWORD PTR tv3022[ebp]
	inc	DWORD PTR _jj$[ebp]
	inc	eax
	inc	ecx
	mov	DWORD PTR tv3022[ebp], eax
	cmp	eax, edi
	jle	$LL42@bezier_ref@2
	mov	eax, DWORD PTR _j$[ebp]
	inc	eax
	add	ecx, edi
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, edi
	jle	$LN198@bezier_ref@2
$LN43@bezier_ref@2:

; 3106 : 
; 3107 :   /* upper left */
; 3108 :   for ( j = 0, jj = 0 ; j <= order ; j++ )

	xor	eax, eax
	mov	DWORD PTR _j$[ebp], eax
	mov	DWORD PTR _jj$[ebp], eax
	cmp	eax, edi
	jg	$LN34@bezier_ref@2
	mov	DWORD PTR tv3744[ebp], esi
$LN200@bezier_ref@2:

; 3109 :     for ( i = 0 ; i+j <= order ; i++, jj++ )

	mov	DWORD PTR tv3619[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR tv3655[ebp], eax
$LL177@bezier_ref@2:

; 3110 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	xor	ecx, ecx
	mov	DWORD PTR _kk$[ebp], ecx
	cmp	ebx, 4
	jl	SHORT $LN175@bezier_ref@2
	mov	ecx, DWORD PTR tv3655[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR tv3744[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR _jj$[ebp]
	mov	edi, DWORD PTR [edx+eax*4]
	lea	edx, DWORD PTR [ecx+24]

; 3111 :         z[jj][kk] = x[i][j+order][kk];

	sub	ecx, edi
	mov	DWORD PTR tv3755[ebp], ecx
	lea	ecx, DWORD PTR [ebx-4]
	shr	ecx, 2
	lea	eax, DWORD PTR [edi+8]
	inc	ecx
	lea	edi, DWORD PTR [ecx*4]
	mov	DWORD PTR _kk$[ebp], edi
	mov	edi, DWORD PTR tv3755[ebp]
$LL159@bezier_ref@2:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	add	edx, 32					; 00000020H
	dec	ecx
	fld	QWORD PTR [edi+eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LL159@bezier_ref@2

; 3110 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	edi, DWORD PTR _order$GSCopy$[ebp]
	mov	ecx, DWORD PTR _kk$[ebp]
$LN175@bezier_ref@2:
	cmp	ecx, ebx
	jge	SHORT $LN32@bezier_ref@2

; 3133 :   free_matrix(w);

	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR _jj$[ebp]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR tv1341[ebp], eax
	lea	eax, DWORD PTR [eax+ecx*8]
	mov	ecx, DWORD PTR tv3655[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv3744[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	sub	ecx, DWORD PTR tv1341[ebp]
	mov	DWORD PTR tv3755[ebp], ecx
	mov	edx, ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR _kk$[ebp]
$LC30@bezier_ref@2:

; 3110 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	fld	QWORD PTR [edx+eax]
	add	eax, 8
	dec	ecx

; 3111 :         z[jj][kk] = x[i][j+order][kk];

	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC30@bezier_ref@2
$LN32@bezier_ref@2:

; 3109 :     for ( i = 0 ; i+j <= order ; i++, jj++ )

	mov	eax, DWORD PTR tv3619[ebp]
	add	DWORD PTR tv3655[ebp], 4
	inc	DWORD PTR _jj$[ebp]
	inc	eax
	mov	DWORD PTR tv3619[ebp], eax
	cmp	eax, edi
	jle	$LL177@bezier_ref@2
	mov	eax, DWORD PTR _j$[ebp]
	add	DWORD PTR tv3744[ebp], 4
	inc	eax
	mov	DWORD PTR _j$[ebp], eax
	cmp	eax, edi
	jle	$LN200@bezier_ref@2
$LN34@bezier_ref@2:

; 3112 :   mat_mult(bezier2invert[order],z,w,old_numpts,old_numpts,old_numpts);

	mov	edx, DWORD PTR _w$[ebp]
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _bezier2invert[esi]
	push	ebx
	push	ebx
	push	ebx
	push	edx
	push	eax
	push	ecx
	call	_mat_mult

; 3113 :   for ( j = 0, jj = 0, mm = 3*((order+1)*order)/2 ; j <= order ; j++ )

	lea	eax, DWORD PTR [edi+1]
	imul	eax, edi
	lea	eax, DWORD PTR [eax+eax*2]
	cdq
	xor	ecx, ecx
	sub	eax, edx
	add	esp, 24					; 00000018H
	sar	eax, 1
	mov	DWORD PTR _j$[ebp], ecx
	mov	DWORD PTR _jj$[ebp], ecx
	cmp	edi, ecx
	jl	$LN25@bezier_ref@2
$LL27@bezier_ref@2:

; 3114 :     for ( i = 0 ; i+j <= order ; i++, jj++, mm++ )

	cmp	DWORD PTR _j$[ebp], edi
	jg	$LN26@bezier_ref@2
	mov	edx, DWORD PTR _j$[ebp]
	mov	DWORD PTR tv4063[ebp], edx
$LL24@bezier_ref@2:

; 3115 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	xor	ecx, ecx
	cmp	ebx, 4
	jl	$LC161@bezier_ref@2
	mov	ecx, DWORD PTR _w$[ebp]
	mov	edx, DWORD PTR _jj$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	lea	edi, DWORD PTR [ebx-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv3994[ebp], edi
	lea	ecx, DWORD PTR [edx+16]

; 3116 :         bezier_refine_2d[order][mm][kk] = w[jj][kk];

	neg	edx
	add	edi, edi
	add	edi, edi
	mov	DWORD PTR tv3848[ebp], 16		; 00000010H
	mov	DWORD PTR tv2221[ebp], edx
	mov	DWORD PTR _kk$[ebp], edi
	npad	9
$LL162@bezier_ref@2:
	mov	edi, DWORD PTR _bezier_refine_2d[esi]
	fld	QWORD PTR [ecx-16]
	mov	edi, DWORD PTR [edi+eax*4]
	lea	edx, DWORD PTR [ecx+edx-16]
	fstp	QWORD PTR [edx+edi]
	mov	edi, DWORD PTR _bezier_refine_2d[esi]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [ecx-8]
	fstp	QWORD PTR [edi+edx+8]
	mov	edx, DWORD PTR _bezier_refine_2d[esi]
	mov	edx, DWORD PTR [edx+eax*4]
	fld	QWORD PTR [ecx]
	mov	edi, DWORD PTR tv3848[ebp]
	add	DWORD PTR tv3848[ebp], 32		; 00000020H
	fstp	QWORD PTR [edi+edx]
	mov	edx, DWORD PTR _bezier_refine_2d[esi]
	fld	QWORD PTR [ecx+8]
	mov	edi, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR tv2221[ebp]
	add	edi, ecx
	add	ecx, 32					; 00000020H
	fstp	QWORD PTR [edi+edx+8]
	dec	DWORD PTR tv3994[ebp]
	jne	SHORT $LL162@bezier_ref@2

; 3115 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	edi, DWORD PTR _order$GSCopy$[ebp]
	mov	ecx, DWORD PTR _kk$[ebp]
$LC161@bezier_ref@2:
	cmp	ecx, ebx
	jge	SHORT $LN23@bezier_ref@2
	mov	edx, DWORD PTR _w$[ebp]
	mov	edi, DWORD PTR _jj$[ebp]
	mov	edx, DWORD PTR [edx+edi*4]
	npad	8
$LC21@bezier_ref@2:

; 3116 :         bezier_refine_2d[order][mm][kk] = w[jj][kk];

	mov	edi, DWORD PTR _bezier_refine_2d[esi]
	fld	QWORD PTR [edx+ecx*8]
	mov	edi, DWORD PTR [edi+eax*4]
	fstp	QWORD PTR [edi+ecx*8]
	inc	ecx
	cmp	ecx, ebx
	jl	SHORT $LC21@bezier_ref@2

; 3115 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	edi, DWORD PTR _order$GSCopy$[ebp]
$LN23@bezier_ref@2:

; 3114 :     for ( i = 0 ; i+j <= order ; i++, jj++, mm++ )

	mov	ecx, DWORD PTR tv4063[ebp]
	inc	DWORD PTR _jj$[ebp]
	inc	ecx
	inc	eax
	mov	DWORD PTR tv4063[ebp], ecx
	cmp	ecx, edi
	jle	$LL24@bezier_ref@2
$LN26@bezier_ref@2:

; 3113 :   for ( j = 0, jj = 0, mm = 3*((order+1)*order)/2 ; j <= order ; j++ )

	mov	ecx, DWORD PTR _j$[ebp]
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, edi
	jle	$LL27@bezier_ref@2
$LN25@bezier_ref@2:

; 3117 : 
; 3118 :   /* middle */
; 3119 :   for ( j = order, jj = 0 ; j >= 0 ; j-- )

	mov	edx, edi
	mov	DWORD PTR _j$[ebp], edx
	mov	DWORD PTR _jj$[ebp], 0
	test	edi, edi
	js	$LN170@bezier_ref@2
	mov	eax, DWORD PTR tv1284[ebp]
	mov	DWORD PTR tv4770[ebp], eax
$LL18@bezier_ref@2:

; 3120 :     for ( i = order ; i+j >= order ; i--, jj++ )

	cmp	eax, edi
	jl	$LN17@bezier_ref@2
	mov	DWORD PTR tv4658[ebp], eax
	mov	eax, DWORD PTR _x$[ebp]
	lea	ecx, DWORD PTR [esi+eax]
	mov	DWORD PTR tv4695[ebp], ecx
$LL178@bezier_ref@2:

; 3121 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	xor	eax, eax
	mov	DWORD PTR _kk$[ebp], eax
	cmp	ebx, 4
	jl	SHORT $LC164@bezier_ref@2
	mov	eax, DWORD PTR tv4695[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	edx, DWORD PTR _z$[ebp]
	mov	eax, DWORD PTR _jj$[ebp]
	mov	edi, DWORD PTR [edx+eax*4]
	lea	edx, DWORD PTR [ecx+24]

; 3122 :         z[jj][kk] = x[i][j][kk];

	sub	ecx, edi
	mov	DWORD PTR tv4730[ebp], ecx
	lea	ecx, DWORD PTR [ebx-4]
	shr	ecx, 2
	lea	eax, DWORD PTR [edi+8]
	inc	ecx
	lea	edi, DWORD PTR [ecx*4]
	mov	DWORD PTR _kk$[ebp], edi
	mov	edi, DWORD PTR tv4730[ebp]
$LL165@bezier_ref@2:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	add	edx, 32					; 00000020H
	dec	ecx
	fld	QWORD PTR [edi+eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LL165@bezier_ref@2

; 3121 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	edi, DWORD PTR _order$GSCopy$[ebp]
	mov	eax, DWORD PTR _kk$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
$LC164@bezier_ref@2:
	cmp	eax, ebx
	jge	SHORT $LN14@bezier_ref@2
	mov	edi, DWORD PTR _jj$[ebp]
	mov	ecx, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR tv4695[ebp]
	mov	edi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi+edx*4]
	lea	eax, DWORD PTR [ecx+eax*8]
	sub	edi, ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR _kk$[ebp]
	npad	5
$LC12@bezier_ref@2:

; 3122 :         z[jj][kk] = x[i][j][kk];

	fld	QWORD PTR [edi+eax]
	add	eax, 8
	dec	ecx
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC12@bezier_ref@2

; 3121 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	edi, DWORD PTR _order$GSCopy$[ebp]
$LN14@bezier_ref@2:

; 3120 :     for ( i = order ; i+j >= order ; i--, jj++ )

	mov	eax, DWORD PTR tv4658[ebp]
	sub	DWORD PTR tv4695[ebp], 4
	inc	DWORD PTR _jj$[ebp]
	dec	eax
	mov	DWORD PTR tv4658[ebp], eax
	cmp	eax, edi
	jge	$LL178@bezier_ref@2
	mov	eax, DWORD PTR tv4770[ebp]
$LN17@bezier_ref@2:

; 3117 : 
; 3118 :   /* middle */
; 3119 :   for ( j = order, jj = 0 ; j >= 0 ; j-- )

	dec	edx
	dec	eax
	mov	DWORD PTR _j$[ebp], edx
	mov	DWORD PTR tv4770[ebp], eax
	test	edx, edx
	jns	$LL18@bezier_ref@2
$LN170@bezier_ref@2:

; 3123 :   mat_mult(bezier2invert[order],z,w,old_numpts,old_numpts,old_numpts);

	mov	edx, DWORD PTR _w$[ebp]
	mov	eax, DWORD PTR _z$[ebp]
	mov	ecx, DWORD PTR _bezier2invert[esi]
	push	ebx
	push	ebx
	push	ebx
	push	edx
	push	eax
	push	ecx
	call	_mat_mult

; 3124 :   for ( j=order, jj=0, mm = ((3*order+2)*(order+1))/2-1 ; j >= 0 ;
; 3125 :                    j--,mm -= 2*(order-j)-1 )

	lea	eax, DWORD PTR [edi+edi*2+2]
	lea	ecx, DWORD PTR [edi+1]
	imul	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esp, 24					; 00000018H
	dec	eax
	mov	DWORD PTR _j$[ebp], edi
	mov	DWORD PTR _jj$[ebp], 0
	test	edi, edi
	js	$LN7@bezier_ref@2

; 3123 :   mat_mult(bezier2invert[order],z,w,old_numpts,old_numpts,old_numpts);

	mov	ecx, DWORD PTR tv1284[ebp]
	mov	DWORD PTR tv5265[ebp], ecx
	mov	DWORD PTR tv5293[ebp], 0
	jmp	SHORT $LN9@bezier_ref@2
$LL176@bezier_ref@2:
	mov	ecx, DWORD PTR tv5265[ebp]
$LN9@bezier_ref@2:

; 3126 :     for ( i = order ; i+j >= order ; i--, jj++, mm-- )

	cmp	ecx, edi
	jl	$LN8@bezier_ref@2
	mov	DWORD PTR tv5185[ebp], ecx
$LL6@bezier_ref@2:

; 3127 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	xor	ecx, ecx
	cmp	ebx, 4
	jl	$LC167@bezier_ref@2
	mov	ecx, DWORD PTR _jj$[ebp]
	mov	edx, DWORD PTR _w$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	lea	edi, DWORD PTR [ebx-4]
	shr	edi, 2
	inc	edi
	mov	DWORD PTR tv5011[ebp], edi
	lea	ecx, DWORD PTR [edx+16]

; 3128 :          bezier_refine_2d[order][mm][kk] = w[jj][kk];

	neg	edx
	add	edi, edi
	add	edi, edi
	mov	DWORD PTR tv4876[ebp], 16		; 00000010H
	mov	DWORD PTR tv2221[ebp], edx
	mov	DWORD PTR _kk$[ebp], edi
	npad	11
$LL168@bezier_ref@2:
	mov	edi, DWORD PTR _bezier_refine_2d[esi]
	fld	QWORD PTR [ecx-16]
	mov	edi, DWORD PTR [edi+eax*4]
	lea	edx, DWORD PTR [ecx+edx-16]
	fstp	QWORD PTR [edx+edi]
	mov	edi, DWORD PTR _bezier_refine_2d[esi]
	mov	edi, DWORD PTR [edi+eax*4]
	fld	QWORD PTR [ecx-8]
	fstp	QWORD PTR [edi+edx+8]
	mov	edx, DWORD PTR _bezier_refine_2d[esi]
	mov	edx, DWORD PTR [edx+eax*4]
	fld	QWORD PTR [ecx]
	mov	edi, DWORD PTR tv4876[ebp]
	add	DWORD PTR tv4876[ebp], 32		; 00000020H
	fstp	QWORD PTR [edi+edx]
	mov	edx, DWORD PTR _bezier_refine_2d[esi]
	fld	QWORD PTR [ecx+8]
	mov	edi, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR tv2221[ebp]
	add	edi, ecx
	add	ecx, 32					; 00000020H
	fstp	QWORD PTR [edi+edx+8]
	dec	DWORD PTR tv5011[ebp]
	jne	SHORT $LL168@bezier_ref@2

; 3127 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	edi, DWORD PTR _order$GSCopy$[ebp]
	mov	ecx, DWORD PTR _kk$[ebp]
$LC167@bezier_ref@2:
	cmp	ecx, ebx
	jge	SHORT $LN5@bezier_ref@2
	mov	edx, DWORD PTR _w$[ebp]
	mov	edi, DWORD PTR _jj$[ebp]
	mov	edx, DWORD PTR [edx+edi*4]
	npad	8
$LC3@bezier_ref@2:

; 3128 :          bezier_refine_2d[order][mm][kk] = w[jj][kk];

	mov	edi, DWORD PTR _bezier_refine_2d[esi]
	fld	QWORD PTR [edx+ecx*8]
	mov	edi, DWORD PTR [edi+eax*4]
	fstp	QWORD PTR [edi+ecx*8]
	inc	ecx
	cmp	ecx, ebx
	jl	SHORT $LC3@bezier_ref@2

; 3127 :       for ( kk = 0 ; kk < old_numpts ; kk++ )

	mov	edi, DWORD PTR _order$GSCopy$[ebp]
$LN5@bezier_ref@2:

; 3126 :     for ( i = order ; i+j >= order ; i--, jj++, mm-- )

	mov	ecx, DWORD PTR tv5185[ebp]
	inc	DWORD PTR _jj$[ebp]
	dec	ecx
	dec	eax
	mov	DWORD PTR tv5185[ebp], ecx
	cmp	ecx, edi
	jge	$LL6@bezier_ref@2
$LN8@bezier_ref@2:

; 3124 :   for ( j=order, jj=0, mm = ((3*order+2)*(order+1))/2-1 ; j >= 0 ;
; 3125 :                    j--,mm -= 2*(order-j)-1 )

	mov	ecx, DWORD PTR _j$[ebp]
	sub	DWORD PTR tv5293[ebp], 2
	dec	DWORD PTR tv5265[ebp]
	mov	edx, DWORD PTR tv5293[ebp]
	dec	ecx
	mov	DWORD PTR _j$[ebp], ecx
	lea	eax, DWORD PTR [eax+edx+1]
	test	ecx, ecx
	jns	$LL176@bezier_ref@2
$LN7@bezier_ref@2:

; 3129 : 
; 3130 : 
; 3131 :   free_matrix3(x);

	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	_free_matrix3

; 3132 :   free_matrix(z);

	mov	ecx, DWORD PTR _z$[ebp]
	push	ecx
	call	_free_matrix

; 3133 :   free_matrix(w);

	mov	edx, DWORD PTR _w$[ebp]
	push	edx
	call	_free_matrix
	add	esp, 12					; 0000000cH
$LN87@bezier_ref@2:

; 3134 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_bezier_refine_2d_init ENDP
_TEXT	ENDS
PUBLIC	_lagrange_eval_1d
; Function compile flags: /Ogtp
;	COMDAT _lagrange_eval_1d
_TEXT	SEGMENT
tv1695 = -12						; size = 4
tv1693 = -12						; size = 4
tv1691 = -12						; size = 4
tv1689 = -12						; size = 4
tv1687 = -12						; size = 4
tv1146 = -12						; size = 4
tv1028 = -12						; size = 4
tv1024 = -12						; size = 4
tv988 = -12						; size = 4
tv984 = -12						; size = 4
tv980 = -12						; size = 4
tv902 = -12						; size = 4
tv692 = -8						; size = 4
tv1700 = -4						; size = 4
tv1698 = -4						; size = 4
tv976 = -4						; size = 4
_m$ = -4						; size = 4
_order$ = 8						; size = 4
_sdim$ = 12						; size = 4
_t$ = 16						; size = 8
_ctrl$ = 24						; size = 4
_dest$ = 28						; size = 4
_lagrange_eval_1d PROC					; COMDAT

; 3150 : {

	push	ebp
	mov	ebp, esp

; 3151 :   int i,k,m;
; 3152 : 
; 3153 :   for ( k = 0 ; k < sdim ; k++ )

	mov	edx, DWORD PTR _sdim$[ebp]
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	test	edx, edx
	jle	SHORT $LN38@lagrange_e
	mov	edi, DWORD PTR _dest$[ebp]
	mov	ecx, edx
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	rep stosd
$LN38@lagrange_e:

; 3154 :     dest[k] = 0.0;
; 3155 :   for ( i = 0 ; i <= order ;  i++ )

	mov	edi, DWORD PTR _order$[ebp]
	xor	esi, esi
	test	edi, edi
	js	$LN8@lagrange_e
	fld	QWORD PTR _t$[ebp]
	push	ebx
	fld1
$LN39@lagrange_e:

; 3158 :     for ( m = 0 ; m <= order ; m++ )

	xor	ecx, ecx
	fld	ST(0)
	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR _m$[ebp], ecx
	cmp	eax, 8
	jl	$LC25@lagrange_e

; 3156 :   {
; 3157 :     REAL p=1.0;

	mov	eax, 2
	lea	ebx, DWORD PTR [esi-2]
	lea	edx, DWORD PTR [edi-7]
	mov	DWORD PTR tv692[ebp], eax
	mov	DWORD PTR tv902[ebp], ebx

; 3158 :     for ( m = 0 ; m <= order ; m++ )

$LN34@lagrange_e:

; 3159 :     { if ( m == i ) continue;

	cmp	ecx, esi
	je	SHORT $LN26@lagrange_e

; 3160 :       p *= (t*order - m)/(i - m);

	fild	DWORD PTR _order$[ebp]
	lea	edi, DWORD PTR [ebx+2]
	fmul	ST(0), ST(3)
	fisub	DWORD PTR _m$[ebp]
	mov	DWORD PTR tv1700[ebp], edi
	fild	DWORD PTR tv1700[ebp]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
$LN26@lagrange_e:

; 3159 :     { if ( m == i ) continue;

	lea	edi, DWORD PTR [eax-1]
	mov	DWORD PTR tv976[ebp], edi
	cmp	edi, esi
	je	SHORT $LN27@lagrange_e

; 3160 :       p *= (t*order - m)/(i - m);

	fild	DWORD PTR _order$[ebp]
	lea	edi, DWORD PTR [ebx+1]
	fmul	ST(0), ST(3)
	fisub	DWORD PTR tv976[ebp]
	mov	DWORD PTR tv1698[ebp], edi
	fild	DWORD PTR tv1698[ebp]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
$LN27@lagrange_e:

; 3159 :     { if ( m == i ) continue;

	cmp	eax, esi
	je	SHORT $LN28@lagrange_e

; 3160 :       p *= (t*order - m)/(i - m);

	fild	DWORD PTR _order$[ebp]
	fmul	ST(0), ST(3)
	fisub	DWORD PTR tv692[ebp]
	fidiv	DWORD PTR tv902[ebp]
	fmulp	ST(1), ST(0)
$LN28@lagrange_e:

; 3156 :   {
; 3157 :     REAL p=1.0;

	lea	edi, DWORD PTR [eax+1]
	mov	DWORD PTR tv980[ebp], edi

; 3159 :     { if ( m == i ) continue;

	cmp	edi, esi
	je	SHORT $LN29@lagrange_e

; 3160 :       p *= (t*order - m)/(i - m);

	fild	DWORD PTR _order$[ebp]
	lea	edi, DWORD PTR [ebx-1]
	fmul	ST(0), ST(3)
	fisub	DWORD PTR tv980[ebp]
	mov	DWORD PTR tv1695[ebp], edi
	fild	DWORD PTR tv1695[ebp]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
$LN29@lagrange_e:

; 3156 :   {
; 3157 :     REAL p=1.0;

	lea	edi, DWORD PTR [eax+2]
	mov	DWORD PTR tv984[ebp], edi

; 3159 :     { if ( m == i ) continue;

	cmp	edi, esi
	je	SHORT $LN30@lagrange_e

; 3160 :       p *= (t*order - m)/(i - m);

	fild	DWORD PTR _order$[ebp]
	lea	edi, DWORD PTR [ebx-2]
	fmul	ST(0), ST(3)
	fisub	DWORD PTR tv984[ebp]
	mov	DWORD PTR tv1693[ebp], edi
	fild	DWORD PTR tv1693[ebp]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
$LN30@lagrange_e:

; 3156 :   {
; 3157 :     REAL p=1.0;

	lea	edi, DWORD PTR [eax+3]
	mov	DWORD PTR tv988[ebp], edi

; 3159 :     { if ( m == i ) continue;

	cmp	edi, esi
	je	SHORT $LN31@lagrange_e

; 3160 :       p *= (t*order - m)/(i - m);

	fild	DWORD PTR _order$[ebp]
	lea	edi, DWORD PTR [ebx-3]
	fmul	ST(0), ST(3)
	fisub	DWORD PTR tv988[ebp]
	mov	DWORD PTR tv1691[ebp], edi
	fild	DWORD PTR tv1691[ebp]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
$LN31@lagrange_e:

; 3156 :   {
; 3157 :     REAL p=1.0;

	lea	edi, DWORD PTR [eax+4]
	mov	DWORD PTR tv1024[ebp], edi

; 3159 :     { if ( m == i ) continue;

	cmp	edi, esi
	je	SHORT $LN32@lagrange_e

; 3160 :       p *= (t*order - m)/(i - m);

	fild	DWORD PTR _order$[ebp]
	lea	edi, DWORD PTR [ebx-4]
	fmul	ST(0), ST(3)
	fisub	DWORD PTR tv1024[ebp]
	mov	DWORD PTR tv1689[ebp], edi
	fild	DWORD PTR tv1689[ebp]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
$LN32@lagrange_e:

; 3156 :   {
; 3157 :     REAL p=1.0;

	lea	edi, DWORD PTR [eax+5]
	mov	DWORD PTR tv1028[ebp], edi

; 3159 :     { if ( m == i ) continue;

	cmp	edi, esi
	je	SHORT $LN33@lagrange_e

; 3160 :       p *= (t*order - m)/(i - m);

	fild	DWORD PTR _order$[ebp]
	lea	edi, DWORD PTR [ebx-5]
	fmul	ST(0), ST(3)
	fisub	DWORD PTR tv1028[ebp]
	mov	DWORD PTR tv1687[ebp], edi
	fild	DWORD PTR tv1687[ebp]
	fdivp	ST(1), ST(0)
	fmulp	ST(1), ST(0)
$LN33@lagrange_e:

; 3156 :   {
; 3157 :     REAL p=1.0;

	add	ecx, 8
	add	eax, 8
	sub	ebx, 8
	mov	DWORD PTR _m$[ebp], ecx
	mov	DWORD PTR tv692[ebp], eax
	mov	DWORD PTR tv902[ebp], ebx
	cmp	ecx, edx
	jle	$LN34@lagrange_e
	mov	edi, DWORD PTR _order$[ebp]
	mov	edx, DWORD PTR _sdim$[ebp]
$LC25@lagrange_e:

; 3158 :     for ( m = 0 ; m <= order ; m++ )

	cmp	ecx, edi
	jg	SHORT $LN24@lagrange_e
	mov	eax, esi
	sub	eax, ecx
	mov	DWORD PTR tv1146[ebp], eax
$LC7@lagrange_e:

; 3159 :     { if ( m == i ) continue;

	cmp	ecx, esi
	je	SHORT $LN6@lagrange_e

; 3160 :       p *= (t*order - m)/(i - m);

	fild	DWORD PTR _order$[ebp]
	fmul	ST(0), ST(3)
	fisub	DWORD PTR _m$[ebp]
	fidiv	DWORD PTR tv1146[ebp]
	fmulp	ST(1), ST(0)
$LN6@lagrange_e:

; 3158 :     for ( m = 0 ; m <= order ; m++ )

	inc	ecx
	dec	eax
	mov	DWORD PTR _m$[ebp], ecx
	mov	DWORD PTR tv1146[ebp], eax
	cmp	ecx, edi
	jle	SHORT $LC7@lagrange_e
$LN24@lagrange_e:

; 3161 :     }
; 3162 :     for ( k = 0 ; k < sdim ; k++ )

	xor	ebx, ebx
	cmp	edx, 4
	jl	SHORT $LC36@lagrange_e
	mov	eax, DWORD PTR _ctrl$[ebp]
	mov	edi, DWORD PTR [eax+esi*4]
	mov	ecx, DWORD PTR _dest$[ebp]
	lea	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [edi+24]

; 3163 :       dest[k] += p*ctrl[i][k];

	sub	edi, ecx
	mov	ecx, DWORD PTR _sdim$[ebp]
	add	ecx, -4					; fffffffcH
	shr	ecx, 2
	inc	ecx
	lea	ebx, DWORD PTR [ecx*4]
$LN37@lagrange_e:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	dec	ecx
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [edi+eax-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	ST(0)
	fmul	QWORD PTR [edx-32]
	fadd	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN37@lagrange_e

; 3161 :     }
; 3162 :     for ( k = 0 ; k < sdim ; k++ )

	mov	edi, DWORD PTR _order$[ebp]
	mov	edx, DWORD PTR _sdim$[ebp]
$LC36@lagrange_e:
	cmp	ebx, edx
	jge	SHORT $LN85@lagrange_e
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edi, DWORD PTR _ctrl$[ebp]
	mov	edi, DWORD PTR [edi+esi*4]
	lea	eax, DWORD PTR [ecx+ebx*8]
	sub	edi, ecx
	mov	ecx, edx
	sub	ecx, ebx
$LC3@lagrange_e:

; 3163 :       dest[k] += p*ctrl[i][k];

	fld	QWORD PTR [eax+edi]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC3@lagrange_e

; 3161 :     }
; 3162 :     for ( k = 0 ; k < sdim ; k++ )

	mov	edi, DWORD PTR _order$[ebp]
$LN85@lagrange_e:

; 3154 :     dest[k] = 0.0;
; 3155 :   for ( i = 0 ; i <= order ;  i++ )

	inc	esi

; 3161 :     }
; 3162 :     for ( k = 0 ; k < sdim ; k++ )

	fstp	ST(0)
	cmp	esi, edi
	jle	$LN39@lagrange_e

; 3154 :     dest[k] = 0.0;
; 3155 :   for ( i = 0 ; i <= order ;  i++ )

	fstp	ST(1)
	pop	ebx
	fstp	ST(0)
$LN8@lagrange_e:
	pop	edi
	pop	esi

; 3164 :   }
; 3165 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_lagrange_eval_1d ENDP
_TEXT	ENDS
PUBLIC	_lagrange_eval_2d
; Function compile flags: /Ogtp
;	COMDAT _lagrange_eval_2d
_TEXT	SEGMENT
tv2441 = -28						; size = 4
tv2399 = -24						; size = 4
tv2396 = -24						; size = 4
tv2375 = -24						; size = 4
tv2372 = -24						; size = 4
tv2348 = -24						; size = 4
tv2345 = -24						; size = 4
tv1682 = -24						; size = 4
tv1388 = -24						; size = 4
tv1365 = -24						; size = 4
tv1167 = -24						; size = 4
tv1144 = -24						; size = 4
tv1051 = -24						; size = 4
tv1493 = -20						; size = 4
tv1272 = -20						; size = 4
tv946 = -20						; size = 4
_jj$ = -16						; size = 4
_j$ = -12						; size = 4
tv2323 = -8						; size = 4
tv2409 = -4						; size = 4
tv2407 = -4						; size = 4
tv2404 = -4						; size = 4
tv2385 = -4						; size = 4
tv2383 = -4						; size = 4
tv2380 = -4						; size = 4
tv2358 = -4						; size = 4
tv2356 = -4						; size = 4
tv2353 = -4						; size = 4
_m$ = -4						; size = 4
_order$ = 8						; size = 4
_sdim$ = 12						; size = 4
_t$ = 16						; size = 4
_ctrl$ = 20						; size = 4
_dest$ = 24						; size = 4
_lagrange_eval_2d PROC					; COMDAT

; 3182 : {

	push	ebp
	mov	ebp, esp

; 3183 :   int i,j,k,m,jj;
; 3184 :   
; 3185 :   for ( m = 0 ; m < sdim ; m++ )

	mov	ecx, DWORD PTR _sdim$[ebp]
	sub	esp, 28					; 0000001cH
	push	esi
	xor	esi, esi
	push	edi
	cmp	ecx, esi
	jle	SHORT $LN50@lagrange_e@2
	mov	edi, DWORD PTR _dest$[ebp]
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	rep stosd
$LN50@lagrange_e@2:

; 3186 :     dest[m] = 0.0;
; 3187 :   for ( j = 0, jj = 0 ; j <= order ;  j++ )

	mov	eax, DWORD PTR _order$[ebp]
	mov	DWORD PTR _j$[ebp], esi
	mov	DWORD PTR _jj$[ebp], esi
	cmp	eax, esi
	jl	$LN16@lagrange_e@2
	fld1
	mov	edi, eax
	push	ebx
	mov	DWORD PTR tv2441[ebp], edi
$LN54@lagrange_e@2:

; 3188 :   {
; 3189 :     for ( i = 0 ; i+j <= order ; i++,jj++ )

	xor	ebx, ebx
	cmp	esi, eax
	jg	$LN17@lagrange_e@2
	mov	DWORD PTR tv2323[ebp], edi
	jmp	SHORT $LN15@lagrange_e@2
$LN51@lagrange_e@2:
	mov	edi, DWORD PTR tv2323[ebp]
$LN15@lagrange_e@2:

; 3190 :     { REAL p=1.0;
; 3191 : 
; 3192 :       k = order-i-j;
; 3193 :       for ( m = 0 ; m < i ; m++ )

	xor	ecx, ecx
	fld	ST(0)
	mov	DWORD PTR _m$[ebp], ecx
	cmp	ebx, 4
	jl	$LC39@lagrange_e@2

; 3194 :         p *= (t[0]*order - m)/(i - m);

	fild	DWORD PTR _order$[ebp]
	mov	eax, DWORD PTR _t$[ebp]
	lea	esi, DWORD PTR [ebx-2]
	mov	edx, 2
	fmul	QWORD PTR [eax]
	mov	DWORD PTR tv946[ebp], edx
	mov	eax, esi
	mov	DWORD PTR tv1051[ebp], esi
$LN40@lagrange_e@2:
	fild	DWORD PTR _m$[ebp]
	lea	edi, DWORD PTR [eax+2]
	mov	DWORD PTR tv2409[ebp], edi
	lea	edi, DWORD PTR [edx-1]
	fsubr	ST(0), ST(1)
	add	ecx, 4
	fild	DWORD PTR tv2409[ebp]
	mov	DWORD PTR tv2407[ebp], edi
	lea	edi, DWORD PTR [eax+1]
	fdivp	ST(1), ST(0)
	fmulp	ST(2), ST(0)
	fild	DWORD PTR tv2407[ebp]
	mov	DWORD PTR tv2404[ebp], edi
	lea	edi, DWORD PTR [edx+1]
	add	edx, 4
	fsubr	ST(0), ST(1)
	fild	DWORD PTR tv2404[ebp]
	mov	DWORD PTR _m$[ebp], ecx
	fdivp	ST(1), ST(0)
	fmulp	ST(2), ST(0)
	fild	DWORD PTR tv946[ebp]
	mov	DWORD PTR tv946[ebp], edx
	fsubr	ST(0), ST(1)
	fidiv	DWORD PTR tv1051[ebp]
	mov	DWORD PTR tv2399[ebp], edi
	lea	edi, DWORD PTR [eax-1]
	sub	eax, 4
	fmulp	ST(2), ST(0)
	fild	DWORD PTR tv2399[ebp]
	mov	DWORD PTR tv2396[ebp], edi
	lea	edi, DWORD PTR [esi-1]
	fsubr	ST(0), ST(1)
	fild	DWORD PTR tv2396[ebp]
	mov	DWORD PTR tv1051[ebp], eax
	fdivp	ST(1), ST(0)
	fmulp	ST(2), ST(0)
	cmp	ecx, edi
	jl	SHORT $LN40@lagrange_e@2
	mov	esi, DWORD PTR _j$[ebp]
	fstp	ST(0)
	mov	edi, DWORD PTR tv2323[ebp]
$LC39@lagrange_e@2:

; 3190 :     { REAL p=1.0;
; 3191 : 
; 3192 :       k = order-i-j;
; 3193 :       for ( m = 0 ; m < i ; m++ )

	mov	edx, DWORD PTR _t$[ebp]
	cmp	ecx, ebx
	jge	SHORT $LN38@lagrange_e@2
	fild	DWORD PTR _order$[ebp]
	mov	eax, ebx
	sub	eax, ecx
	mov	DWORD PTR tv1144[ebp], eax
	fmul	QWORD PTR [edx]
$LC12@lagrange_e@2:

; 3194 :         p *= (t[0]*order - m)/(i - m);

	fild	DWORD PTR _m$[ebp]
	inc	ecx
	dec	eax
	mov	DWORD PTR _m$[ebp], ecx
	fsubr	ST(0), ST(1)
	fidiv	DWORD PTR tv1144[ebp]
	mov	DWORD PTR tv1144[ebp], eax
	fmulp	ST(2), ST(0)
	cmp	ecx, ebx
	jl	SHORT $LC12@lagrange_e@2

; 3190 :     { REAL p=1.0;
; 3191 : 
; 3192 :       k = order-i-j;
; 3193 :       for ( m = 0 ; m < i ; m++ )

	fstp	ST(0)
$LN38@lagrange_e@2:

; 3195 :       for ( m = 0 ; m < j ; m++ )

	xor	ecx, ecx
	mov	DWORD PTR _m$[ebp], ecx
	cmp	esi, 4
	jl	$LC42@lagrange_e@2

; 3196 :         p *= (t[1]*order - m)/(j - m);

	fild	DWORD PTR _order$[ebp]
	add	esi, -3					; fffffffdH
	lea	eax, DWORD PTR [esi+1]
	mov	DWORD PTR tv1272[ebp], eax
	fmul	QWORD PTR [edx+8]
	mov	edx, 2
	mov	DWORD PTR tv1167[ebp], edx
$LN43@lagrange_e@2:
	fild	DWORD PTR _m$[ebp]
	lea	edi, DWORD PTR [eax+2]
	mov	DWORD PTR tv2385[ebp], edi
	lea	edi, DWORD PTR [edx-1]
	fsubr	ST(0), ST(1)
	add	ecx, 4
	fild	DWORD PTR tv2385[ebp]
	mov	DWORD PTR tv2383[ebp], edi
	lea	edi, DWORD PTR [eax+1]
	fdivp	ST(1), ST(0)
	fmulp	ST(2), ST(0)
	fild	DWORD PTR tv2383[ebp]
	mov	DWORD PTR tv2380[ebp], edi
	lea	edi, DWORD PTR [edx+1]
	add	edx, 4
	fsubr	ST(0), ST(1)
	fild	DWORD PTR tv2380[ebp]
	mov	DWORD PTR _m$[ebp], ecx
	fdivp	ST(1), ST(0)
	fmulp	ST(2), ST(0)
	fild	DWORD PTR tv1167[ebp]
	mov	DWORD PTR tv2375[ebp], edi
	lea	edi, DWORD PTR [eax-1]
	sub	eax, 4
	fsubr	ST(0), ST(1)
	fidiv	DWORD PTR tv1272[ebp]
	mov	DWORD PTR tv1272[ebp], eax
	fmulp	ST(2), ST(0)
	fild	DWORD PTR tv2375[ebp]
	mov	DWORD PTR tv2372[ebp], edi
	fsubr	ST(0), ST(1)
	fild	DWORD PTR tv2372[ebp]
	mov	DWORD PTR tv1167[ebp], edx
	fdivp	ST(1), ST(0)
	fmulp	ST(2), ST(0)
	cmp	ecx, esi
	jl	SHORT $LN43@lagrange_e@2
	mov	edx, DWORD PTR _t$[ebp]
	fstp	ST(0)
	mov	esi, DWORD PTR _j$[ebp]
	mov	edi, DWORD PTR tv2323[ebp]
$LC42@lagrange_e@2:

; 3195 :       for ( m = 0 ; m < j ; m++ )

	cmp	ecx, esi
	jge	SHORT $LN41@lagrange_e@2
	fild	DWORD PTR _order$[ebp]
	mov	eax, esi
	sub	eax, ecx
	mov	DWORD PTR tv1365[ebp], eax
	fmul	QWORD PTR [edx+8]
$LC9@lagrange_e@2:

; 3196 :         p *= (t[1]*order - m)/(j - m);

	fild	DWORD PTR _m$[ebp]
	inc	ecx
	dec	eax
	mov	DWORD PTR _m$[ebp], ecx
	fsubr	ST(0), ST(1)
	fidiv	DWORD PTR tv1365[ebp]
	mov	DWORD PTR tv1365[ebp], eax
	fmulp	ST(2), ST(0)
	cmp	ecx, esi
	jl	SHORT $LC9@lagrange_e@2

; 3195 :       for ( m = 0 ; m < j ; m++ )

	fstp	ST(0)
$LN41@lagrange_e@2:

; 3197 :       for ( m = 0 ; m < k ; m++ )

	xor	ecx, ecx
	mov	DWORD PTR _m$[ebp], ecx
	cmp	edi, 4
	jl	$LC45@lagrange_e@2
	fld	ST(1)
	lea	eax, DWORD PTR [edi-2]
	fsub	QWORD PTR [edx]
	lea	esi, DWORD PTR [edi-3]
	mov	DWORD PTR tv1493[ebp], eax
	fsub	QWORD PTR [edx+8]
	mov	edx, 2
	mov	DWORD PTR tv1388[ebp], edx

; 3198 :         p *= ((1-t[0]-t[1])*order - m)/(k - m);

	fimul	DWORD PTR _order$[ebp]
$LN46@lagrange_e@2:
	fild	DWORD PTR _m$[ebp]
	lea	edi, DWORD PTR [eax+2]
	mov	DWORD PTR tv2358[ebp], edi
	lea	edi, DWORD PTR [edx-1]
	fsubr	ST(0), ST(1)
	add	ecx, 4
	fild	DWORD PTR tv2358[ebp]
	mov	DWORD PTR tv2356[ebp], edi
	lea	edi, DWORD PTR [eax+1]
	fdivp	ST(1), ST(0)
	fmulp	ST(2), ST(0)
	fild	DWORD PTR tv2356[ebp]
	mov	DWORD PTR tv2353[ebp], edi
	lea	edi, DWORD PTR [edx+1]
	add	edx, 4
	fsubr	ST(0), ST(1)
	fild	DWORD PTR tv2353[ebp]
	mov	DWORD PTR _m$[ebp], ecx
	fdivp	ST(1), ST(0)
	fmulp	ST(2), ST(0)
	fild	DWORD PTR tv1388[ebp]
	mov	DWORD PTR tv2348[ebp], edi
	lea	edi, DWORD PTR [eax-1]
	sub	eax, 4
	fsubr	ST(0), ST(1)
	fidiv	DWORD PTR tv1493[ebp]
	mov	DWORD PTR tv1493[ebp], eax
	fmulp	ST(2), ST(0)
	fild	DWORD PTR tv2348[ebp]
	mov	DWORD PTR tv2345[ebp], edi
	fsubr	ST(0), ST(1)
	fild	DWORD PTR tv2345[ebp]
	mov	DWORD PTR tv1388[ebp], edx
	fdivp	ST(1), ST(0)
	fmulp	ST(2), ST(0)
	cmp	ecx, esi
	jl	SHORT $LN46@lagrange_e@2
	mov	edx, DWORD PTR _t$[ebp]
	fstp	ST(0)
	mov	edi, DWORD PTR tv2323[ebp]
$LC45@lagrange_e@2:

; 3197 :       for ( m = 0 ; m < k ; m++ )

	cmp	ecx, edi
	jge	SHORT $LN44@lagrange_e@2
	fld	ST(1)
	mov	eax, edi
	fsub	QWORD PTR [edx]
	sub	eax, ecx
	mov	DWORD PTR tv1682[ebp], eax
	fsub	QWORD PTR [edx+8]
	fimul	DWORD PTR _order$[ebp]
$LC6@lagrange_e@2:

; 3198 :         p *= ((1-t[0]-t[1])*order - m)/(k - m);

	fild	DWORD PTR _m$[ebp]
	inc	ecx
	dec	eax
	mov	DWORD PTR _m$[ebp], ecx
	fsubr	ST(0), ST(1)
	fidiv	DWORD PTR tv1682[ebp]
	mov	DWORD PTR tv1682[ebp], eax
	fmulp	ST(2), ST(0)
	cmp	ecx, edi
	jl	SHORT $LC6@lagrange_e@2

; 3197 :       for ( m = 0 ; m < k ; m++ )

	fstp	ST(0)
$LN44@lagrange_e@2:

; 3199 : 
; 3200 :       for ( m = 0 ; m < sdim ; m++ )

	xor	edi, edi
	cmp	DWORD PTR _sdim$[ebp], 4
	jl	SHORT $LC48@lagrange_e@2
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR _jj$[ebp]
	mov	esi, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _dest$[ebp]
	lea	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [esi+24]

; 3201 :         dest[m] += p*ctrl[jj][m];

	sub	esi, ecx
	mov	ecx, DWORD PTR _sdim$[ebp]
	add	ecx, -4					; fffffffcH
	shr	ecx, 2
	inc	ecx
	lea	edi, DWORD PTR [ecx*4]
$LN49@lagrange_e@2:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	dec	ecx
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [esi+eax-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	ST(0)
	fmul	QWORD PTR [edx-32]
	fadd	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN49@lagrange_e@2
$LC48@lagrange_e@2:

; 3199 : 
; 3200 :       for ( m = 0 ; m < sdim ; m++ )

	cmp	edi, DWORD PTR _sdim$[ebp]
	jge	SHORT $LN103@lagrange_e@2
	mov	ecx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR _jj$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _sdim$[ebp]
	sub	edx, DWORD PTR _dest$[ebp]
	lea	eax, DWORD PTR [eax+edi*8]
	sub	ecx, edi
$LC3@lagrange_e@2:

; 3201 :         dest[m] += p*ctrl[jj][m];

	fld	QWORD PTR [edx+eax]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC3@lagrange_e@2
$LN103@lagrange_e@2:

; 3188 :   {
; 3189 :     for ( i = 0 ; i+j <= order ; i++,jj++ )

	mov	eax, 1

; 3199 : 
; 3200 :       for ( m = 0 ; m < sdim ; m++ )

	fstp	ST(0)
	sub	DWORD PTR tv2323[ebp], eax
	add	DWORD PTR _jj$[ebp], eax
	add	ebx, eax
	mov	eax, DWORD PTR _j$[ebp]
	lea	ecx, DWORD PTR [ebx+eax]
	mov	esi, eax
	cmp	ecx, DWORD PTR _order$[ebp]
	jle	$LN51@lagrange_e@2

; 3188 :   {
; 3189 :     for ( i = 0 ; i+j <= order ; i++,jj++ )

	mov	eax, DWORD PTR _order$[ebp]
$LN17@lagrange_e@2:

; 3186 :     dest[m] = 0.0;
; 3187 :   for ( j = 0, jj = 0 ; j <= order ;  j++ )

	mov	edi, DWORD PTR tv2441[ebp]
	inc	esi
	dec	edi
	mov	DWORD PTR _j$[ebp], esi
	mov	DWORD PTR tv2441[ebp], edi
	cmp	esi, eax
	jle	$LN54@lagrange_e@2
	fstp	ST(0)
	pop	ebx
$LN16@lagrange_e@2:
	pop	edi
	pop	esi

; 3202 :     }
; 3203 :   }
; 3204 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_lagrange_eval_2d ENDP
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	_bezier_eval_2d
; Function compile flags: /Ogtp
;	COMDAT _bezier_eval_2d
_TEXT	SEGMENT
_jj$ = -60						; size = 4
tv966 = -56						; size = 4
_j$ = -52						; size = 4
_i$ = -48						; size = 4
tv1018 = -44						; size = 4
_t$ = -40						; size = 24
_inx$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_order$ = 8						; size = 4
_sdim$ = 12						; size = 4
_p$ = 16						; size = 4
_ctrl$ = 20						; size = 4
_dest$ = 24						; size = 4
_bezier_eval_2d PROC					; COMDAT

; 3220 : { int inx[3];

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _p$[ebp]

; 3221 :   REAL t[3];
; 3222 :   int i,j,k,jj;
; 3223 : 
; 3224 :   t[0] = p[0]; t[1] = p[1]; t[2] = 1.0 - t[0] - t[1];

	fld	QWORD PTR [eax]

; 3225 :   for ( k = 0 ; k < sdim ; k++ ) dest[k] = 0.0;

	mov	ecx, DWORD PTR _sdim$[ebp]
	fst	QWORD PTR _t$[ebp]
	push	ebx
	fld	QWORD PTR [eax+8]
	mov	ebx, DWORD PTR _dest$[ebp]
	fst	QWORD PTR _t$[ebp+8]
	push	esi
	fld1
	push	edi
	fsubrp	ST(2), ST(0)
	fsubp	ST(1), ST(0)
	fstp	QWORD PTR _t$[ebp+16]
	test	ecx, ecx
	jle	SHORT $LN12@bezier_eva@3
	and	ecx, 536870911				; 1fffffffH
	add	ecx, ecx
	xor	eax, eax
	mov	edi, ebx
	rep stosd
$LN12@bezier_eva@3:

; 3226 :   for ( j = 0, jj = 0  ; j <= order ; j++ )

	mov	eax, DWORD PTR _order$[ebp]
	xor	ecx, ecx
	xor	esi, esi
	mov	DWORD PTR _j$[ebp], ecx
	mov	DWORD PTR _jj$[ebp], esi
	test	eax, eax
	js	$LN7@bezier_eva@3
	mov	DWORD PTR tv1018[ebp], eax
	npad	6
$LL27@bezier_eva@3:

; 3227 :     for ( i = 0 ; i+j <= order ; i++,jj++ )

	mov	DWORD PTR _i$[ebp], 0
	cmp	ecx, eax
	jg	$LN8@bezier_eva@3

; 3230 :       inx[1] = j;

	mov	DWORD PTR _inx$[ebp+4], ecx
	mov	ecx, DWORD PTR tv1018[ebp]
	mov	DWORD PTR tv966[ebp], ecx
	npad	8
$LL6@bezier_eva@3:

; 3231 :       inx[2] = i;

	mov	edx, DWORD PTR tv966[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _inx$[ebp], edx

; 3232 :       bezval = bezier_eval(order,2,inx,t);

	lea	edx, DWORD PTR _t$[ebp]
	push	edx
	mov	DWORD PTR _inx$[ebp+8], ecx
	lea	ecx, DWORD PTR _inx$[ebp]
	push	ecx
	push	2
	push	eax
	call	_bezier_eval

; 3233 :       for ( k = 0 ; k < sdim ; k++ )

	mov	ecx, DWORD PTR _sdim$[ebp]
	add	esp, 16					; 00000010H
	xor	edi, edi
	cmp	ecx, 4
	jl	SHORT $LC24@bezier_eva@3
	mov	edx, DWORD PTR _ctrl$[ebp]
	mov	esi, DWORD PTR [edx+esi*4]
	add	ecx, -4					; fffffffcH
	lea	edx, DWORD PTR [esi+24]
	shr	ecx, 2

; 3234 :         dest[k] += bezval*ctrl[jj][k];

	sub	esi, ebx
	inc	ecx
	lea	eax, DWORD PTR [ebx+8]
	lea	edi, DWORD PTR [ecx*4]
$LN25@bezier_eva@3:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fmul	ST(0), ST(1)
	add	edx, 32					; 00000020H
	dec	ecx
	fadd	QWORD PTR [eax-40]
	fstp	QWORD PTR [eax-40]
	fld	QWORD PTR [esi+eax-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-24]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LN25@bezier_eva@3

; 3228 :     { REAL bezval;
; 3229 :       inx[0] = order-i-j;

	mov	esi, DWORD PTR _jj$[ebp]
	mov	ecx, DWORD PTR _sdim$[ebp]
$LC24@bezier_eva@3:

; 3233 :       for ( k = 0 ; k < sdim ; k++ )

	cmp	edi, ecx
	jge	SHORT $LN38@bezier_eva@3
	mov	edx, DWORD PTR _ctrl$[ebp]
	mov	edx, DWORD PTR [edx+esi*4]
	sub	edx, ebx
	lea	eax, DWORD PTR [ebx+edi*8]
	sub	ecx, edi
$LC3@bezier_eva@3:

; 3234 :         dest[k] += bezval*ctrl[jj][k];

	fld	QWORD PTR [eax+edx]
	add	eax, 8
	dec	ecx
	fmul	ST(0), ST(1)
	fadd	QWORD PTR [eax-8]
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC3@bezier_eva@3
$LN38@bezier_eva@3:

; 3227 :     for ( i = 0 ; i+j <= order ; i++,jj++ )

	mov	eax, DWORD PTR _i$[ebp]

; 3233 :       for ( k = 0 ; k < sdim ; k++ )

	fstp	ST(0)
	dec	DWORD PTR tv966[ebp]
	inc	eax
	mov	DWORD PTR _i$[ebp], eax
	add	eax, DWORD PTR _j$[ebp]
	inc	esi
	cmp	eax, DWORD PTR _order$[ebp]
	mov	eax, DWORD PTR _order$[ebp]
	mov	DWORD PTR _jj$[ebp], esi
	jle	$LL6@bezier_eva@3

; 3227 :     for ( i = 0 ; i+j <= order ; i++,jj++ )

	mov	ecx, DWORD PTR _j$[ebp]
$LN8@bezier_eva@3:

; 3226 :   for ( j = 0, jj = 0  ; j <= order ; j++ )

	dec	DWORD PTR tv1018[ebp]
	inc	ecx
	mov	DWORD PTR _j$[ebp], ecx
	cmp	ecx, eax
	jle	$LL27@bezier_eva@3
$LN7@bezier_eva@3:

; 3235 :     }
; 3236 : 
; 3237 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_bezier_eval_2d ENDP
_TEXT	ENDS
PUBLIC	__real@4018000000000000
PUBLIC	__$ArrayPad$
PUBLIC	_tetra_vol
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _tetra_vol
_TEXT	SEGMENT
_bb$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_d$ = 20						; size = 4
_tetra_vol PROC						; COMDAT

; 3247 : { REAL bb[3],cc[3],dd[3];

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3248 :   REAL vol;
; 3249 :   int i;
; 3250 :   for ( i = 0 ; i < 3 ; i++ )
; 3251 :   { bb[i] = b[i] - a[i];

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	QWORD PTR [ecx]

; 3252 :     cc[i] = c[i] - a[i];

	mov	edx, DWORD PTR _c$[ebp]
	fsub	QWORD PTR [eax]
	push	esi

; 3253 :     dd[i] = d[i] - a[i];

	mov	esi, DWORD PTR _d$[ebp]
	fstp	QWORD PTR _bb$[ebp]
	fld	QWORD PTR [edx]
	fsub	QWORD PTR [eax]
	fld	QWORD PTR [esi]
	fsub	QWORD PTR [eax]
	fld	QWORD PTR [ecx+8]
	fsub	QWORD PTR [eax+8]
	fstp	QWORD PTR _bb$[ebp+8]
	fld	QWORD PTR [edx+8]
	fsub	QWORD PTR [eax+8]
	fld	QWORD PTR [esi+8]
	fsub	QWORD PTR [eax+8]
	fld	QWORD PTR [ecx+16]

; 3254 :   }
; 3255 :   vol = (bb[0]*(cc[1]*dd[2] - cc[2]*dd[1]) + bb[1]*(cc[2]*dd[0] - cc[0]*dd[2])
; 3256 :       + bb[2]*(cc[0]*dd[1] - cc[1]*dd[0]))/6;
; 3257 :   return vol;
; 3258 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fsub	QWORD PTR [eax+16]
	xor	ecx, ebp
	fstp	QWORD PTR _bb$[ebp+16]
	fld	QWORD PTR [edx+16]
	fsub	QWORD PTR [eax+16]
	fld	QWORD PTR [esi+16]
	pop	esi
	fsub	QWORD PTR [eax+16]
	fld	ST(4)
	fmul	ST(0), ST(2)
	fld	ST(6)
	fmul	ST(0), ST(2)
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR _bb$[ebp+8]
	fxch	ST(1)
	fmul	ST(0), ST(4)
	fld	ST(3)
	fmulp	ST(3), ST(0)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fmul	QWORD PTR _bb$[ebp]
	faddp	ST(1), ST(0)
	fxch	ST(4)
	fmulp	ST(1), ST(0)
	fxch	ST(2)
	fmulp	ST(1), ST(0)
	fsubp	ST(1), ST(0)
	fmul	QWORD PTR _bb$[ebp+16]
	faddp	ST(1), ST(0)
	fdiv	QWORD PTR __real@4018000000000000
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_tetra_vol ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@BGLFHIGF@matrix_multiply?3?5illegal?5matrix?5@ ; `string'
PUBLIC	??_C@_0DF@HFIEDACC@matrix_multiply?5third?5array?5is?5n@ ; `string'
PUBLIC	??_C@_0DP@FALLGHMN@matrix_multiply?3?5sizes?5of?5second@ ; `string'
PUBLIC	??_C@_0DO@PBDPEBDL@matrix_multiply?3?5sizes?5of?5first?5@ ; `string'
PUBLIC	??_C@_0DP@KFNIHALG@matrix_multiply?3?5sizes?5of?5first?5@ ; `string'
PUBLIC	??_C@_0DF@CEKELINI@matrix_multiply?5third?5array?5is?5n@ ; `string'
PUBLIC	_matrix_multiply_command
;	COMDAT ??_C@_0CM@BGLFHIGF@matrix_multiply?3?5illegal?5matrix?5@
CONST	SEGMENT
??_C@_0CM@BGLFHIGF@matrix_multiply?3?5illegal?5matrix?5@ DB 'matrix_multi'
	DB	'ply: illegal matrix dimensions', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HFIEDACC@matrix_multiply?5third?5array?5is?5n@
CONST	SEGMENT
??_C@_0DF@HFIEDACC@matrix_multiply?5third?5array?5is?5n@ DB 'matrix_multi'
	DB	'ply third array is not one-dimensional.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@FALLGHMN@matrix_multiply?3?5sizes?5of?5second@
CONST	SEGMENT
??_C@_0DP@FALLGHMN@matrix_multiply?3?5sizes?5of?5second@ DB 'matrix_multi'
	DB	'ply: sizes of second and third matrices disagree.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@PBDPEBDL@matrix_multiply?3?5sizes?5of?5first?5@
CONST	SEGMENT
??_C@_0DO@PBDPEBDL@matrix_multiply?3?5sizes?5of?5first?5@ DB 'matrix_mult'
	DB	'iply: sizes of first and third matrices disagree.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@KFNIHALG@matrix_multiply?3?5sizes?5of?5first?5@
CONST	SEGMENT
??_C@_0DP@KFNIHALG@matrix_multiply?3?5sizes?5of?5first?5@ DB 'matrix_mult'
	DB	'iply: sizes of first and second matrices disagree.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@CEKELINI@matrix_multiply?5third?5array?5is?5n@
CONST	SEGMENT
??_C@_0DF@CEKELINI@matrix_multiply?5third?5array?5is?5n@ DB 'matrix_multi'
	DB	'ply third array is not two-dimensional.', 0aH, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _matrix_multiply_command
_TEXT	SEGMENT
tv2887 = -32						; size = 4
tv1749 = -32						; size = 4
_k$ = -32						; size = 4
tv2286 = -28						; size = 4
_i$ = -28						; size = 4
tv2400 = -24						; size = 4
tv1813 = -24						; size = 4
tv2398 = -20						; size = 4
tv1207 = -20						; size = 4
tv2396 = -16						; size = 4
tv1209 = -16						; size = 4
tv1211 = -12						; size = 4
$T94320 = -12						; size = 4
tv2880 = -8						; size = 4
tv1152 = -8						; size = 4
_j$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_adata$ = 20						; size = 4
_bdata$ = 24						; size = 4
_cdata$ = 28						; size = 4
_matrix_multiply_command PROC				; COMDAT

; 3270 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx

; 3271 :   int i,j,k;
; 3272 : 
; 3273 :   if ( (a->dim == 2) && (b->dim == 2) )

	mov	ebx, DWORD PTR _b$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, 2
	cmp	eax, ecx
	jne	$LN33@matrix_mul
	cmp	DWORD PTR [ebx+4], ecx
	jne	$LN33@matrix_mul

; 3274 :   {
; 3275 :     if ( c->dim != 2 )

	mov	esi, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [esi+4], ecx
	je	SHORT $LN63@matrix_mul

; 3276 :       kb_error(3798,"matrix_multiply third array is not two-dimensional.\n",
; 3277 :         RECOVERABLE); 

	push	1
	push	OFFSET ??_C@_0DF@CEKELINI@matrix_multiply?5third?5array?5is?5n@
	push	3798					; 00000ed6H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN63@matrix_mul:

; 3278 :   
; 3279 :     if ( a->sizes[1] != b->sizes[0] )

	mov	eax, DWORD PTR [edi+28]
	cmp	eax, DWORD PTR [ebx+24]
	je	SHORT $LN31@matrix_mul

; 3280 :       kb_error(4012,
; 3281 :        "matrix_multiply: sizes of first and second matrices disagree.\n",
; 3282 :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DP@KFNIHALG@matrix_multiply?3?5sizes?5of?5first?5@
	push	4012					; 00000facH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN31@matrix_mul:

; 3283 :     if ( a->sizes[0] != c->sizes[0] )

	mov	ecx, DWORD PTR [edi+24]
	cmp	ecx, DWORD PTR [esi+24]
	je	SHORT $LN30@matrix_mul

; 3284 :       kb_error(3217,
; 3285 :        "matrix_multiply: sizes of first and third matrices disagree.\n",
; 3286 :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DO@PBDPEBDL@matrix_multiply?3?5sizes?5of?5first?5@
	push	3217					; 00000c91H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN30@matrix_mul:

; 3287 :     if ( b->sizes[1] != c->sizes[1] )

	mov	edx, DWORD PTR [ebx+28]
	cmp	edx, DWORD PTR [esi+28]
	je	SHORT $LN29@matrix_mul

; 3288 :       kb_error(3862,
; 3289 :        "matrix_multiply: sizes of second and third matrices disagree.\n",
; 3290 :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DP@FALLGHMN@matrix_multiply?3?5sizes?5of?5second@
	push	3862					; 00000f16H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN29@matrix_mul:

; 3291 :   
; 3292 :     /* finally ready to roll */
; 3293 :     for ( i = 0 ; i < a->sizes[0] ; i++ )

	xor	edx, edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR [edi+24], edx
	jle	$LN34@matrix_mul
	mov	eax, DWORD PTR [ebx+28]
	fldz
$LN65@matrix_mul:

; 3294 :       for ( j = 0 ; j < b->sizes[1] ; j++ )

	xor	esi, esi
	mov	DWORD PTR _j$[ebp], esi
	test	eax, eax
	jle	$LN27@matrix_mul
	mov	ecx, DWORD PTR _bdata$[ebp]
	mov	DWORD PTR tv1813[ebp], ecx
$LN25@matrix_mul:

; 3296 :         for ( k = 0 ; k < a->sizes[1] ; k++ )

	mov	edi, DWORD PTR [edi+28]
	fld	ST(0)
	xor	ecx, ecx
	cmp	edi, 4
	jl	$LC51@matrix_mul

; 3295 :       { REAL sum = 0.0;

	mov	ebx, edi
	imul	ebx, edx
	mov	edx, DWORD PTR _adata$[ebp]
	lea	edx, DWORD PTR [edx+ebx*8+16]
	mov	ebx, DWORD PTR tv1813[ebp]
	mov	DWORD PTR tv1152[ebp], ebx
	lea	ebx, DWORD PTR [esi+eax*2]
	mov	esi, DWORD PTR _bdata$[ebp]
	add	ebx, eax
	lea	ebx, DWORD PTR [esi+ebx*8]
	mov	DWORD PTR tv1207[ebp], ebx
	mov	ebx, DWORD PTR _j$[ebp]
	lea	ebx, DWORD PTR [ebx+eax*2]
	lea	ebx, DWORD PTR [esi+ebx*8]
	mov	DWORD PTR tv1209[ebp], ebx
	mov	ebx, DWORD PTR _j$[ebp]
	add	ebx, eax
	lea	esi, DWORD PTR [esi+ebx*8]
	mov	DWORD PTR tv1211[ebp], esi
	lea	esi, DWORD PTR [edi-4]
	mov	ecx, eax
	shr	esi, 2
	shl	ecx, 5
	inc	esi
	lea	ebx, DWORD PTR [esi*4]
	mov	DWORD PTR _k$[ebp], ebx

; 3296 :         for ( k = 0 ; k < a->sizes[1] ; k++ )

$LN52@matrix_mul:

; 3297 :           sum += adata[i*a->sizes[1]+k]*bdata[k*b->sizes[1]+j];

	mov	ebx, DWORD PTR tv1152[ebp]
	fld	QWORD PTR [edx-16]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv1211[ebp]
	add	DWORD PTR tv1152[ebp], ecx
	add	DWORD PTR tv1211[ebp], ecx
	faddp	ST(1), ST(0)
	add	edx, 32					; 00000020H
	fld	QWORD PTR [edx-40]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv1209[ebp]
	add	DWORD PTR tv1209[ebp], ecx
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv1207[ebp]
	fmul	QWORD PTR [edx-32]
	add	DWORD PTR tv1207[ebp], ecx
	dec	esi
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx-24]
	fmul	QWORD PTR [ebx]
	faddp	ST(1), ST(0)
	jne	SHORT $LN52@matrix_mul

; 3295 :       { REAL sum = 0.0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _j$[ebp]
	mov	ebx, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
$LC51@matrix_mul:

; 3296 :         for ( k = 0 ; k < a->sizes[1] ; k++ )

	cmp	ecx, edi
	jge	SHORT $LN50@matrix_mul
	lea	ebx, DWORD PTR [eax*8]
	imul	eax, ecx
	mov	DWORD PTR tv1749[ebp], ebx
	mov	ebx, edi
	imul	ebx, edx
	mov	edx, DWORD PTR _adata$[ebp]
	add	ebx, ecx
	lea	edx, DWORD PTR [edx+ebx*8]
	mov	ebx, DWORD PTR _bdata$[ebp]
	add	eax, esi
	sub	edi, ecx
	mov	ecx, DWORD PTR tv1749[ebp]
	lea	eax, DWORD PTR [ebx+eax*8]
$LC22@matrix_mul:

; 3297 :           sum += adata[i*a->sizes[1]+k]*bdata[k*b->sizes[1]+j];

	fld	QWORD PTR [edx]
	add	edx, 8
	fmul	QWORD PTR [eax]
	add	eax, ecx
	dec	edi
	faddp	ST(1), ST(0)
	jne	SHORT $LC22@matrix_mul

; 3296 :         for ( k = 0 ; k < a->sizes[1] ; k++ )

	mov	ebx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
$LN50@matrix_mul:

; 3298 :         cdata[i*c->sizes[1]+j] = sum;

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _cdata$[ebp]
	imul	ecx, edx
	add	DWORD PTR tv1813[ebp], 8
	mov	edi, DWORD PTR _a$[ebp]
	add	ecx, esi
	inc	esi
	mov	DWORD PTR _j$[ebp], esi
	fstp	QWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [ebx+28]
	cmp	esi, eax
	jl	$LN25@matrix_mul
$LN27@matrix_mul:

; 3291 :   
; 3292 :     /* finally ready to roll */
; 3293 :     for ( i = 0 ; i < a->sizes[0] ; i++ )

	inc	edx
	mov	DWORD PTR _i$[ebp], edx
	cmp	edx, DWORD PTR [edi+24]
	jl	$LN65@matrix_mul
	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx

; 3353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN33@matrix_mul:

; 3299 :       }
; 3300 :     return;
; 3301 :   } /* end 2D by 2D */
; 3302 : 
; 3303 : 
; 3304 :   if ( (a->dim == 1) && (b->dim == 2) )

	mov	esi, 1
	cmp	eax, esi
	jne	$LN19@matrix_mul
	cmp	DWORD PTR [ebx+4], ecx
	jne	$LN19@matrix_mul

; 3305 :   {
; 3306 :     if ( c->dim != 1 )

	mov	esi, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [esi+4], 1
	je	SHORT $LN18@matrix_mul

; 3307 :       kb_error(4013,"matrix_multiply third array is not one-dimensional.\n",
; 3308 :         RECOVERABLE); 

	push	1
	push	OFFSET ??_C@_0DF@HFIEDACC@matrix_multiply?5third?5array?5is?5n@
	push	4013					; 00000fadH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN18@matrix_mul:

; 3309 :   
; 3310 :     if ( a->sizes[0] != b->sizes[0] )

	mov	ecx, DWORD PTR [edi+24]
	cmp	ecx, DWORD PTR [ebx+24]
	je	SHORT $LN17@matrix_mul

; 3311 :       kb_error(3860,
; 3312 :        "matrix_multiply: sizes of first and second matrices disagree.\n",
; 3313 :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DP@KFNIHALG@matrix_multiply?3?5sizes?5of?5first?5@
	push	3860					; 00000f14H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN17@matrix_mul:

; 3314 :     if ( b->sizes[1] != c->sizes[0] )

	mov	edx, DWORD PTR [ebx+28]
	cmp	edx, DWORD PTR [esi+24]
	je	SHORT $LN16@matrix_mul

; 3315 :       kb_error(4010,
; 3316 :        "matrix_multiply: sizes of second and third matrices disagree.\n",
; 3317 :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DP@FALLGHMN@matrix_multiply?3?5sizes?5of?5second@
	push	4010					; 00000faaH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN16@matrix_mul:

; 3318 :   
; 3319 :     /* finally ready to roll */
; 3320 :       for ( j = 0 ; j < b->sizes[1] ; j++ )

	mov	ecx, DWORD PTR [ebx+28]
	xor	esi, esi
	mov	DWORD PTR _j$[ebp], esi
	test	ecx, ecx
	jle	$LN34@matrix_mul
	mov	eax, DWORD PTR _cdata$[ebp]
	fldz
	mov	edx, DWORD PTR _bdata$[ebp]
	sub	edx, eax
	mov	DWORD PTR tv2887[ebp], edx
	mov	edx, DWORD PTR _adata$[ebp]
	mov	DWORD PTR tv2880[ebp], eax
$LN66@matrix_mul:

; 3321 :       { REAL sum = 0.0;

	mov	eax, DWORD PTR _a$[ebp]
	fld	ST(0)
	mov	eax, DWORD PTR [eax+24]

; 3322 :         for ( k = 0 ; k < a->sizes[0] ; k++ )

	xor	edi, edi

; 3324 :         cdata[j] = sum;

	mov	DWORD PTR $T94320[ebp], eax
	cmp	eax, 4
	jl	$LN61@matrix_mul

; 3318 :   
; 3319 :     /* finally ready to roll */
; 3320 :       for ( j = 0 ; j < b->sizes[1] ; j++ )

	mov	edi, DWORD PTR tv2887[ebp]
	add	edi, DWORD PTR tv2880[ebp]

; 3321 :       { REAL sum = 0.0;

	lea	ebx, DWORD PTR [esi+ecx*2]
	add	ebx, ecx
	mov	DWORD PTR tv2286[ebp], edi
	mov	edi, DWORD PTR _bdata$[ebp]
	lea	ebx, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR tv2396[ebp], ebx
	lea	ebx, DWORD PTR [esi+ecx*2]
	add	esi, ecx
	lea	esi, DWORD PTR [edi+esi*8]
	mov	DWORD PTR tv2400[ebp], esi
	mov	esi, DWORD PTR $T94320[ebp]
	add	esi, -4					; fffffffcH
	mov	eax, ecx
	shr	esi, 2
	shl	eax, 5
	add	edx, 16					; 00000010H
	lea	ebx, DWORD PTR [edi+ebx*8]
	inc	esi
	mov	DWORD PTR tv2398[ebp], ebx
	lea	edi, DWORD PTR [esi*4]
$LN59@matrix_mul:

; 3323 :           sum += adata[k]*bdata[k*b->sizes[1]+j];

	mov	ebx, DWORD PTR tv2286[ebp]
	fld	QWORD PTR [edx-16]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv2400[ebp]
	add	DWORD PTR tv2286[ebp], eax
	add	DWORD PTR tv2400[ebp], eax
	faddp	ST(1), ST(0)
	add	edx, 32					; 00000020H
	fld	QWORD PTR [edx-40]
	fmul	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv2398[ebp]
	add	DWORD PTR tv2398[ebp], eax
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ebx]
	mov	ebx, DWORD PTR tv2396[ebp]
	fmul	QWORD PTR [edx-32]
	add	DWORD PTR tv2396[ebp], eax
	dec	esi
	faddp	ST(1), ST(0)
	fld	QWORD PTR [edx-24]
	fmul	QWORD PTR [ebx]
	faddp	ST(1), ST(0)
	jne	SHORT $LN59@matrix_mul

; 3321 :       { REAL sum = 0.0;

	mov	ebx, DWORD PTR _b$[ebp]
	mov	esi, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _adata$[ebp]
$LN61@matrix_mul:

; 3322 :         for ( k = 0 ; k < a->sizes[0] ; k++ )

	mov	eax, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR $T94320[ebp], eax
	cmp	edi, eax
	jge	SHORT $LN64@matrix_mul
	mov	ebx, DWORD PTR _bdata$[ebp]
	lea	eax, DWORD PTR [ecx*8]
	imul	ecx, edi
	add	ecx, esi
	lea	ecx, DWORD PTR [ebx+ecx*8]
	mov	ebx, DWORD PTR $T94320[ebp]
$LC12@matrix_mul:

; 3323 :           sum += adata[k]*bdata[k*b->sizes[1]+j];

	fld	QWORD PTR [edx+edi*8]
	inc	edi
	fmul	QWORD PTR [ecx]
	add	ecx, eax
	faddp	ST(1), ST(0)
	cmp	edi, ebx
	jl	SHORT $LC12@matrix_mul

; 3322 :         for ( k = 0 ; k < a->sizes[0] ; k++ )

	mov	ebx, DWORD PTR _b$[ebp]
$LN64@matrix_mul:

; 3324 :         cdata[j] = sum;

	mov	eax, DWORD PTR tv2880[ebp]
	fstp	QWORD PTR [eax]
	mov	ecx, DWORD PTR [ebx+28]
	inc	esi
	add	eax, 8
	mov	DWORD PTR _j$[ebp], esi
	mov	DWORD PTR tv2880[ebp], eax
	cmp	esi, ecx
	jl	$LN66@matrix_mul

; 3318 :   
; 3319 :     /* finally ready to roll */
; 3320 :       for ( j = 0 ; j < b->sizes[1] ; j++ )

	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx

; 3353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN19@matrix_mul:

; 3325 :       }
; 3326 : 
; 3327 :       return;
; 3328 :     } /* end 1D by 2D */
; 3329 : 
; 3330 :   if ( (a->dim == 2) && (b->dim == 1) )

	cmp	eax, ecx
	jne	$LN9@matrix_mul
	cmp	DWORD PTR [ebx+4], esi
	jne	$LN9@matrix_mul

; 3331 :   {
; 3332 :     if ( c->dim != 1 )

	mov	ecx, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [ecx+4], esi
	je	SHORT $LN8@matrix_mul

; 3333 :       kb_error(4014,"matrix_multiply third array is not one-dimensional.\n",
; 3334 :         RECOVERABLE); 

	push	esi
	push	OFFSET ??_C@_0DF@HFIEDACC@matrix_multiply?5third?5array?5is?5n@
	push	4014					; 00000faeH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN8@matrix_mul:

; 3335 :   
; 3336 :     if ( a->sizes[1] != b->sizes[0] )

	mov	edx, DWORD PTR [edi+28]
	cmp	edx, DWORD PTR [ebx+24]
	je	SHORT $LN7@matrix_mul

; 3337 :       kb_error(4011,
; 3338 :        "matrix_multiply: sizes of first and second matrices disagree.\n",
; 3339 :          RECOVERABLE);

	push	esi
	push	OFFSET ??_C@_0DP@KFNIHALG@matrix_multiply?3?5sizes?5of?5first?5@
	push	4011					; 00000fabH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN7@matrix_mul:

; 3340 :   
; 3341 :     /* finally ready to roll */
; 3342 :     for ( i = 0 ; i < a->sizes[0] ; i++ )

	xor	ebx, ebx
	cmp	DWORD PTR [edi+24], ebx
	jle	$LN34@matrix_mul
	fldz
	jmp	SHORT $LN6@matrix_mul
$LN62@matrix_mul:
	mov	edi, ecx
$LN6@matrix_mul:

; 3344 :         for ( k = 0 ; k < a->sizes[1] ; k++ )

	mov	edi, DWORD PTR [edi+28]
	fld	ST(0)
	xor	esi, esi
	cmp	edi, 4
	jl	SHORT $LC57@matrix_mul

; 3343 :       { REAL sum = 0.0;

	mov	edx, DWORD PTR _adata$[ebp]
	mov	eax, DWORD PTR _bdata$[ebp]
	mov	ecx, edi
	imul	ecx, ebx
	lea	ecx, DWORD PTR [edx+ecx*8+16]
	lea	edx, DWORD PTR [edi-4]
	shr	edx, 2
	add	eax, 16					; 00000010H
	inc	edx
	lea	esi, DWORD PTR [edx*4]

; 3344 :         for ( k = 0 ; k < a->sizes[1] ; k++ )

$LN58@matrix_mul:

; 3345 :           sum += adata[i*a->sizes[1]+k]*bdata[k];

	fld	QWORD PTR [ecx-16]
	add	eax, 32					; 00000020H
	fmul	QWORD PTR [eax-48]
	add	ecx, 32					; 00000020H
	dec	edx
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-40]
	fmul	QWORD PTR [eax-40]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-32]
	fmul	QWORD PTR [eax-32]
	faddp	ST(1), ST(0)
	fld	QWORD PTR [ecx-24]
	fmul	QWORD PTR [eax-24]
	faddp	ST(1), ST(0)
	jne	SHORT $LN58@matrix_mul
$LC57@matrix_mul:

; 3344 :         for ( k = 0 ; k < a->sizes[1] ; k++ )

	cmp	esi, edi
	jge	SHORT $LN56@matrix_mul
	mov	ecx, DWORD PTR _adata$[ebp]
	mov	eax, edi
	imul	eax, ebx
	add	eax, esi
	lea	eax, DWORD PTR [ecx+eax*8]
$LC3@matrix_mul:

; 3345 :           sum += adata[i*a->sizes[1]+k]*bdata[k];

	mov	edx, DWORD PTR _bdata$[ebp]
	fld	QWORD PTR [edx+esi*8]
	inc	esi
	fmul	QWORD PTR [eax]
	add	eax, 8
	faddp	ST(1), ST(0)
	cmp	esi, edi
	jl	SHORT $LC3@matrix_mul
$LN56@matrix_mul:

; 3346 :         cdata[i] = sum;

	mov	eax, DWORD PTR _cdata$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	fstp	QWORD PTR [eax+ebx*8]
	inc	ebx
	cmp	ebx, DWORD PTR [ecx+24]
	jl	$LN62@matrix_mul

; 3340 :   
; 3341 :     /* finally ready to roll */
; 3342 :     for ( i = 0 ; i < a->sizes[0] ; i++ )

	pop	edi
	fstp	ST(0)
	pop	esi
	pop	ebx

; 3353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@matrix_mul:

; 3347 :       }
; 3348 :      return;
; 3349 :     } /* end 2D by 1D */
; 3350 : 
; 3351 : 
; 3352 :    kb_error(3869,"matrix_multiply: illegal matrix dimensions\n",RECOVERABLE);

	push	esi
	push	OFFSET ??_C@_0CM@BGLFHIGF@matrix_multiply?3?5illegal?5matrix?5@
	push	3869					; 00000f1dH
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN34@matrix_mul:
	pop	edi
	pop	esi
	pop	ebx

; 3353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_matrix_multiply_command ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DO@FNHAAFCI@matrix_inverse?3?5sizes?5of?5first?5a@ ; `string'
PUBLIC	??_C@_0CO@KLIHJOBK@matrix_inverse?3?5second?5matrix?5is@ ; `string'
PUBLIC	??_C@_0CN@MELOCMOJ@matrix_inverse?3?5first?5matrix?5is?5@ ; `string'
PUBLIC	_matrix_inverse_command
;	COMDAT ??_C@_0DO@FNHAAFCI@matrix_inverse?3?5sizes?5of?5first?5a@
CONST	SEGMENT
??_C@_0DO@FNHAAFCI@matrix_inverse?3?5sizes?5of?5first?5a@ DB 'matrix_inve'
	DB	'rse: sizes of first and second matrices disagree.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KLIHJOBK@matrix_inverse?3?5second?5matrix?5is@
CONST	SEGMENT
??_C@_0CO@KLIHJOBK@matrix_inverse?3?5second?5matrix?5is@ DB 'matrix_inver'
	DB	'se: second matrix is not square.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MELOCMOJ@matrix_inverse?3?5first?5matrix?5is?5@
CONST	SEGMENT
??_C@_0CN@MELOCMOJ@matrix_inverse?3?5first?5matrix?5is?5@ DB 'matrix_inve'
	DB	'rse: first matrix is not square.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _matrix_inverse_command
_TEXT	SEGMENT
_bptrspace$ = -400					; size = 400
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_adata$ = 16						; size = 4
_bdata$ = 20						; size = 4
_matrix_inverse_command PROC				; COMDAT

; 3366 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 400				; 00000190H
	push	edi

; 3367 :   int i;
; 3368 :   int retval = 1;  /* 1 for success, 0 for singular */
; 3369 :   REAL **bptrs;
; 3370 : #define BPTRSPACE 100
; 3371 :   REAL *bptrspace[BPTRSPACE]; // for row pointers
; 3372 : 
; 3373 :   if ( a->sizes[0] != a->sizes[1] )

	mov	edi, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [edi+24]
	cmp	eax, DWORD PTR [edi+28]
	je	SHORT $LN14@matrix_inv

; 3374 :     kb_error(3218, "matrix_inverse: first matrix is not square.\n",
; 3375 :        RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CN@MELOCMOJ@matrix_inverse?3?5first?5matrix?5is?5@
	push	3218					; 00000c92H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN14@matrix_inv:

; 3376 :   if ( b->sizes[0] != b->sizes[1] )

	push	esi
	mov	esi, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, DWORD PTR [esi+28]
	je	SHORT $LN13@matrix_inv

; 3377 :     kb_error(3872, "matrix_inverse: second matrix is not square.\n",
; 3378 :        RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CO@KLIHJOBK@matrix_inverse?3?5second?5matrix?5is@
	push	3872					; 00000f20H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN13@matrix_inv:

; 3379 :   if ( a->sizes[0] != b->sizes[0] )

	mov	edx, DWORD PTR [edi+24]
	cmp	edx, DWORD PTR [esi+24]
	je	SHORT $LN12@matrix_inv

; 3380 :     kb_error(3873,
; 3381 :      "matrix_inverse: sizes of first and second matrices disagree.\n",
; 3382 :        RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DO@FNHAAFCI@matrix_inverse?3?5sizes?5of?5first?5a@
	push	3873					; 00000f21H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN12@matrix_inv:

; 3383 : 
; 3384 :   if ( bdata != adata )

	mov	edx, DWORD PTR _adata$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _bdata$[ebp]
	cmp	ebx, edx
	je	SHORT $LN22@matrix_inv

; 3385 :     for ( i = 0 ; i < a->datacount ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR [edi+16], ecx
	jle	SHORT $LN22@matrix_inv
	mov	eax, ebx
	sub	edx, ebx
	npad	5
$LL10@matrix_inv:

; 3386 :       bdata[i] = adata[i];

	fld	QWORD PTR [edx+eax]
	inc	ecx
	fstp	QWORD PTR [eax]
	add	eax, 8
	cmp	ecx, DWORD PTR [edi+16]
	jl	SHORT $LL10@matrix_inv
$LN22@matrix_inv:

; 3387 : 
; 3388 :   /* set up row pointers */
; 3389 :   if ( b->sizes[0] <= BPTRSPACE )

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, 100				; 00000064H
	jg	SHORT $LN7@matrix_inv

; 3390 :     bptrs = bptrspace;

	lea	eax, DWORD PTR _bptrspace$[ebp]

; 3391 :   else

	jmp	SHORT $LN6@matrix_inv
$LN7@matrix_inv:

; 3392 :     bptrs = (REAL**)temp_calloc(b->sizes[0],sizeof(REAL*));

	push	3392					; 00000d40H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	push	4
	push	eax
	call	_kb_temp_calloc
	add	esp, 16					; 00000010H
$LN6@matrix_inv:

; 3393 :   for ( i = 0 ; i < b->sizes[0] ; i++ )

	xor	ecx, ecx
	cmp	DWORD PTR [esi+24], ecx
	jle	SHORT $LN3@matrix_inv
	npad	6
$LL5@matrix_inv:

; 3394 :     bptrs[i] = bdata + i*b->sizes[1];

	mov	edx, DWORD PTR [esi+28]
	imul	edx, ecx
	lea	edx, DWORD PTR [ebx+edx*8]
	mov	DWORD PTR [eax+ecx*4], edx
	inc	ecx
	cmp	ecx, DWORD PTR [esi+24]
	jl	SHORT $LL5@matrix_inv
$LN3@matrix_inv:

; 3395 :  
; 3396 :   /* finally ready to roll */
; 3397 :   retval = mat_inv(bptrs,a->sizes[0]);

	mov	ecx, DWORD PTR [edi+24]
	push	ecx
	push	eax
	call	_mat_inv
	add	esp, 8
	mov	edi, eax
	pop	ebx

; 3398 :   if ( retval < 0 )

	test	edi, edi
	jns	SHORT $LN2@matrix_inv

; 3399 :     retval = 0; 

	xor	edi, edi
$LN2@matrix_inv:

; 3400 : 
; 3401 :   if ( b->sizes[0] > BPTRSPACE )

	cmp	DWORD PTR [esi+24], 100			; 00000064H
	pop	esi
	jle	SHORT $LN21@matrix_inv

; 3402 :     temp_free((char*)bptrspace);

	lea	edx, DWORD PTR _bptrspace$[ebp]
	push	edx
	call	_temp_free
	add	esp, 4
$LN21@matrix_inv:

; 3403 : 
; 3404 :   return retval;

	mov	eax, edi
	pop	edi

; 3405 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_matrix_inverse_command ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@EGGPHGML@matrix_determinant?3?5matrix?5is?5no@ ; `string'
PUBLIC	??_C@_0CL@KKMHBPGF@matrix_determinant?3?5matrix?5is?5no@ ; `string'
PUBLIC	_matrix_determinant_command
;	COMDAT ??_C@_0DB@EGGPHGML@matrix_determinant?3?5matrix?5is?5no@
CONST	SEGMENT
??_C@_0DB@EGGPHGML@matrix_determinant?3?5matrix?5is?5no@ DB 'matrix_deter'
	DB	'minant: matrix is not of type REAL.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KKMHBPGF@matrix_determinant?3?5matrix?5is?5no@
CONST	SEGMENT
??_C@_0CL@KKMHBPGF@matrix_determinant?3?5matrix?5is?5no@ DB 'matrix_deter'
	DB	'minant: matrix is not square.', 0aH, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _matrix_determinant_command
_TEXT	SEGMENT
_retval$ = -8						; size = 8
_atmp$ = 8						; size = 4
_a$ = 8							; size = 4
_adata$ = 12						; size = 4
_matrix_determinant_command PROC			; COMDAT

; 3416 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi

; 3417 :   REAL **atmp;
; 3418 :   int i,j;
; 3419 :   REAL retval;
; 3420 : 
; 3421 :   if ( a->sizes[0] != a->sizes[1] )

	mov	esi, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [esi+24]
	push	edi
	cmp	eax, DWORD PTR [esi+28]
	je	SHORT $LN15@matrix_det

; 3422 :     kb_error(3220, "matrix_determinant: matrix is not square.\n",
; 3423 :        RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0CL@KKMHBPGF@matrix_determinant?3?5matrix?5is?5no@
	push	3220					; 00000c94H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN15@matrix_det:

; 3424 : 
; 3425 :   if ( a->datatype != REAL_TYPE )

	cmp	DWORD PTR [esi+8], 1
	je	SHORT $LN7@matrix_det

; 3426 :      kb_error(3221,"matrix_determinant: matrix is not of type REAL.\n",
; 3427 :          RECOVERABLE);

	push	1
	push	OFFSET ??_C@_0DB@EGGPHGML@matrix_determinant?3?5matrix?5is?5no@
	push	3221					; 00000c95H
	call	_kb_error
	add	esp, 12					; 0000000cH
$LN7@matrix_det:

; 3428 : 
; 3429 :   atmp = dmatrix(0,a->sizes[0],0,a->sizes[1]);  

	mov	ecx, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [esi+24]
	push	3429					; 00000d65H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	push	ecx
	push	0
	push	edx
	push	0
	call	_kb_dmatrix

; 3430 :  
; 3431 :   for ( i = 0 ; i < a->sizes[0] ; i++ )

	xor	edi, edi
	add	esp, 24					; 00000018H
	mov	ebx, eax
	mov	DWORD PTR _atmp$[ebp], ebx
	cmp	DWORD PTR [esi+24], edi
	jle	SHORT $LN4@matrix_det
	mov	edx, DWORD PTR [esi+28]
	mov	ebx, DWORD PTR _adata$[ebp]
$LL6@matrix_det:

; 3432 :     for ( j = 0 ; j < a->sizes[1] ; j++ )

	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN5@matrix_det

; 3430 :  
; 3431 :   for ( i = 0 ; i < a->sizes[0] ; i++ )

	mov	ecx, DWORD PTR _atmp$[ebp]
	mov	ecx, DWORD PTR [ecx+edi*4]
	npad	2
$LL3@matrix_det:

; 3433 :       atmp[i][j] = adata[i*a->sizes[0]+j];

	mov	edx, DWORD PTR [esi+24]
	imul	edx, edi
	add	edx, eax
	inc	eax
	add	ecx, 8
	fld	QWORD PTR [ebx+edx*8]
	fstp	QWORD PTR [ecx-8]
	mov	edx, DWORD PTR [esi+28]
	cmp	eax, edx
	jl	SHORT $LL3@matrix_det
$LN5@matrix_det:

; 3430 :  
; 3431 :   for ( i = 0 ; i < a->sizes[0] ; i++ )

	inc	edi
	cmp	edi, DWORD PTR [esi+24]
	jl	SHORT $LL6@matrix_det
	mov	ebx, DWORD PTR _atmp$[ebp]
$LN4@matrix_det:

; 3434 :  
; 3435 :   /* finally ready to roll */
; 3436 :   retval = determinant(atmp,a->sizes[0]);

	mov	eax, DWORD PTR [esi+24]
	push	eax
	push	ebx
	call	_determinant
	fstp	QWORD PTR _retval$[ebp]

; 3437 : 
; 3438 :   free_matrix(atmp);

	push	ebx
	call	_free_matrix

; 3439 :  
; 3440 :   return retval;

	fld	QWORD PTR _retval$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 3441 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_matrix_determinant_command ENDP
_TEXT	ENDS
PUBLIC	_matrix3_reorder
; Function compile flags: /Ogtp
;	COMDAT _matrix3_reorder
_TEXT	SEGMENT
_newa$ = -12						; size = 4
tv671 = -8						; size = 4
tv724 = -4						; size = 4
_a$ = 8							; size = 4
tv789 = 12						; size = 4
_maxi$ = 12						; size = 4
_maxj$ = 16						; size = 4
_maxk$ = 20						; size = 4
_matrix3_reorder PROC					; COMDAT

; 163  : { int i,j,k;

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 164  :   REAL ***newa;
; 165  :   newa = dmatrix3(maxi,maxj,maxk);

	mov	eax, DWORD PTR _maxk$[ebp]
	mov	ecx, DWORD PTR _maxj$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _maxi$[ebp]
	push	esi
	push	165					; 000000a5H
	push	OFFSET ??_C@_08PHBNMDHD@MATRIX?4C?$AA@
	push	eax
	push	ecx
	push	ebx
	call	_kb_dmatrix3
	add	esp, 20					; 00000014H
	mov	esi, eax
	mov	DWORD PTR _newa$[ebp], esi

; 166  :   for ( i = 0 ; i < maxi; i++ )

	test	ebx, ebx
	jle	$LN22@matrix3_re
	push	edi
	mov	edi, DWORD PTR _a$[ebp]
	mov	edx, esi
	sub	edi, esi
	mov	DWORD PTR tv724[ebp], edx
	mov	DWORD PTR tv789[ebp], edi
	mov	DWORD PTR tv671[ebp], ebx
$LL24@matrix3_re:

; 167  :     for ( j = 0 ; j < maxj ; j++ )

	xor	ebx, ebx
	cmp	DWORD PTR _maxj$[ebp], ebx
	jle	$LN8@matrix3_re
	npad	1
$LL23@matrix3_re:

; 168  :       for ( k = 0 ; k < maxk ; k++ )

	xor	esi, esi
	cmp	DWORD PTR _maxk$[ebp], 4
	jl	SHORT $LC19@matrix3_re
	mov	eax, DWORD PTR [edi+edx]
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	edx, DWORD PTR [edx]
	mov	esi, DWORD PTR [edx+ebx*4]

; 169  :         newa[i][j][k] = a[i][j][k];

	mov	edi, ecx
	lea	edx, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR _maxk$[ebp]
	add	ecx, -4					; fffffffcH
	sub	edi, esi
	shr	ecx, 2
	inc	ecx
	lea	eax, DWORD PTR [esi+8]
	lea	esi, DWORD PTR [ecx*4]
	npad	2
$LL20@matrix3_re:
	fld	QWORD PTR [edx-24]
	add	eax, 32					; 00000020H
	fstp	QWORD PTR [eax-40]
	add	edx, 32					; 00000020H
	dec	ecx
	fld	QWORD PTR [edi+eax-32]
	fstp	QWORD PTR [eax-32]
	fld	QWORD PTR [edx-40]
	fstp	QWORD PTR [eax-24]
	fld	QWORD PTR [edx-32]
	fstp	QWORD PTR [eax-16]
	jne	SHORT $LL20@matrix3_re

; 168  :       for ( k = 0 ; k < maxk ; k++ )

	mov	edx, DWORD PTR tv724[ebp]
	mov	edi, DWORD PTR tv789[ebp]
$LC19@matrix3_re:
	cmp	esi, DWORD PTR _maxk$[ebp]
	jge	SHORT $LN5@matrix3_re
	mov	eax, DWORD PTR [edx]
	mov	edi, DWORD PTR [edi+edx]
	mov	ecx, DWORD PTR [eax+ebx*4]
	mov	edi, DWORD PTR [edi+ebx*4]
	lea	eax, DWORD PTR [ecx+esi*8]
	sub	edi, ecx
	mov	ecx, DWORD PTR _maxk$[ebp]
	sub	ecx, esi
$LC3@matrix3_re:

; 169  :         newa[i][j][k] = a[i][j][k];

	fld	QWORD PTR [edi+eax]
	add	eax, 8
	dec	ecx
	fstp	QWORD PTR [eax-8]
	jne	SHORT $LC3@matrix3_re

; 168  :       for ( k = 0 ; k < maxk ; k++ )

	mov	edi, DWORD PTR tv789[ebp]
$LN5@matrix3_re:

; 167  :     for ( j = 0 ; j < maxj ; j++ )

	inc	ebx
	cmp	ebx, DWORD PTR _maxj$[ebp]
	jl	$LL23@matrix3_re
	mov	esi, DWORD PTR _newa$[ebp]
$LN8@matrix3_re:

; 166  :   for ( i = 0 ; i < maxi; i++ )

	add	edx, 4
	dec	DWORD PTR tv671[ebp]
	mov	DWORD PTR tv724[ebp], edx
	jne	$LL24@matrix3_re
	pop	edi
$LN22@matrix3_re:

; 170  :   free_matrix3(a);

	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	_free_matrix3
	add	esp, 4

; 171  :   return newa;

	mov	eax, esi
	pop	esi
	pop	ebx

; 172  : } // end matrix3_reorder()

	mov	esp, ebp
	pop	ebp
	ret	0
_matrix3_reorder ENDP
_TEXT	ENDS
PUBLIC	_n$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	_vnormal
; Function compile flags: /Ogtp
;	COMDAT _vnormal
_TEXT	SEGMENT
tv854 = -136						; size = 4
tv831 = -132						; size = 4
tv846 = -128						; size = 4
tv826 = -124						; size = 4
_n$GSCopy$ = -120					; size = 4
tv858 = -116						; size = 4
tv1030 = -112						; size = 4
tv1026 = -108						; size = 4
tv862 = -104						; size = 4
_bb$ = -100						; size = 48
_aa$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_n$ = 20						; size = 4
_vnormal PROC						; COMDAT

; 575  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 582  :   }
; 583  :   cross_prod(aa,bb,n);

	mov	eax, DWORD PTR _n$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _web+616
	push	esi
	mov	esi, DWORD PTR _c$[ebp]
	xor	ecx, ecx
	push	edi
	mov	edi, DWORD PTR _b$[ebp]
	mov	DWORD PTR _n$GSCopy$[ebp], eax
	cmp	ebx, 4
	jl	$LC9@vnormal

; 581  :     bb[i] = b[i] - c[i];

	mov	ebx, edi
	sub	ebx, esi
	mov	DWORD PTR tv831[ebp], ebx
	lea	ebx, DWORD PTR _aa$[ebp]
	sub	ebx, esi
	mov	DWORD PTR tv846[ebp], ebx
	lea	ebx, DWORD PTR _bb$[ebp]
	sub	ebx, esi
	mov	DWORD PTR tv854[ebp], ebx
	lea	ebx, DWORD PTR _aa$[ebp+8]
	sub	ebx, esi
	mov	DWORD PTR tv858[ebp], ebx
	lea	ebx, DWORD PTR _bb$[ebp+8]
	sub	ebx, esi
	mov	DWORD PTR tv862[ebp], ebx
	lea	ebx, DWORD PTR _aa$[ebp+16]
	sub	ebx, esi
	mov	DWORD PTR tv1026[ebp], ebx
	lea	ebx, DWORD PTR _bb$[ebp+16]
	sub	ebx, esi
	mov	DWORD PTR tv1030[ebp], ebx
	mov	ebx, DWORD PTR _a$[ebp]
	sub	ebx, edi
	lea	edx, DWORD PTR [edi+16]
	lea	eax, DWORD PTR [esi+8]
	mov	DWORD PTR tv826[ebp], ebx
	npad	2
$LL11@vnormal:

; 580  :   { aa[i] = a[i] - c[i];

	mov	edi, DWORD PTR _a$[ebp]
	fld	QWORD PTR [edi+ecx*8]
	mov	edi, DWORD PTR tv831[ebp]
	fsub	QWORD PTR [eax-8]
	add	edi, eax

; 581  :     bb[i] = b[i] - c[i];

	add	ecx, 4
	add	eax, 32					; 00000020H
	fstp	QWORD PTR _aa$[ebp+ecx*8-32]
	add	edx, 32					; 00000020H
	fld	QWORD PTR [edx-48]
	fsub	QWORD PTR [eax-40]
	fstp	QWORD PTR _bb$[ebp+ecx*8-32]
	fld	QWORD PTR [edi+ebx]
	mov	ebx, DWORD PTR tv846[ebp]
	fsub	QWORD PTR [eax-32]
	fstp	QWORD PTR [ebx+eax-32]
	mov	ebx, DWORD PTR tv826[ebp]
	fld	QWORD PTR [edi]
	mov	edi, DWORD PTR tv854[ebp]
	fsub	QWORD PTR [eax-32]
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv858[ebp]
	fld	QWORD PTR [ebx+edx-32]
	fsub	QWORD PTR [eax-24]
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR tv862[ebp]
	fld	QWORD PTR [edx-32]
	fsub	QWORD PTR [eax-24]
	fstp	QWORD PTR [edi+eax-32]
	mov	edi, DWORD PTR _a$[ebp]
	fld	QWORD PTR [edi+ecx*8-8]
	mov	edi, DWORD PTR tv1026[ebp]
	fsub	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax+edi-32]
	mov	edi, DWORD PTR tv1030[ebp]
	fld	QWORD PTR [edx-24]
	fsub	QWORD PTR [eax-16]
	fstp	QWORD PTR [eax+edi-32]
	mov	edi, DWORD PTR _web+616
	add	edi, -3					; fffffffdH
	cmp	ecx, edi
	jl	$LL11@vnormal
	mov	edi, DWORD PTR _b$[ebp]
	mov	ebx, DWORD PTR _web+616
$LC9@vnormal:

; 576  :   REAL aa[MAXCOORD],bb[MAXCOORD];
; 577  :   int i;
; 578  : 
; 579  :   for ( i = 0 ; i < SDIM ; i++ )

	cmp	ecx, ebx
	jge	SHORT $LN8@vnormal
	mov	edx, DWORD PTR _a$[ebp]
	lea	eax, DWORD PTR _aa$[ebp]
	sub	edx, eax
	sub	edi, eax
	sub	esi, eax
	npad	3
$LC3@vnormal:
	lea	eax, DWORD PTR _aa$[ebp+ecx*8]

; 580  :   { aa[i] = a[i] - c[i];

	fld	QWORD PTR [eax+edx]
	inc	ecx
	fsub	QWORD PTR [eax+esi]
	fstp	QWORD PTR [eax]

; 581  :     bb[i] = b[i] - c[i];

	fld	QWORD PTR [eax+edi]
	fsub	QWORD PTR [eax+esi]
	fstp	QWORD PTR _bb$[ebp+ecx*8-8]
	cmp	ecx, ebx
	jl	SHORT $LC3@vnormal
$LN8@vnormal:

; 582  :   }
; 583  :   cross_prod(aa,bb,n);

	mov	ecx, DWORD PTR _n$GSCopy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _bb$[ebp]
	push	edx
	lea	eax, DWORD PTR _aa$[ebp]
	push	eax
	call	_cross_prod

; 584  : } // end vnormal()

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_vnormal ENDP
_TEXT	ENDS
END
